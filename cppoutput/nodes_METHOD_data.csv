111669149696,METHOD,cli/cmdlinelogger.h:<global>,TYPE_DECL,<global>,1,27,cli/cmdlinelogger.h,cli/cmdlinelogger.h:<global>,<empty>,,false,1,37,<global>,,,1,
111669149697,METHOD,cli/cmdlineparser.cpp:<global>,TYPE_DECL,"static bool addFilesToList(const std::string& fileList, std::vector<std::string>& pathNames)
{
    std::istream *files;
    std::ifstream infile;
    if (fileList == ""-"") { // read from stdin
        files = &std::cin;
    } else {
        infile.open(fileList);
        if (!infile.is_open())
            return false;
        files = &infile;
    }
    std::string fileName;
    // cppcheck-suppress accessMoved - FP
    while (std::getline(*files, fileName)) { // next line
        // cppcheck-suppress accessMoved - FP
        if (!fileName.empty()) {
            pathNames.emplace_back(std::move(fileName));
        }
    }

    return true;
}",1,1,cli/cmdlineparser.cpp,"addFilesToList:bool(std.string&,std.vector<std.string>&)",<empty>,,false,62,84,addFilesToList,,,1,"bool(std.string&,std.vector<std.string>&)"
111669149698,METHOD,cli/cmdlineparser.cpp:<global>,TYPE_DECL,<global>,1,1,cli/cmdlineparser.cpp,cli/cmdlineparser.cpp:<global>,<empty>,,false,1,2139,<global>,,,1,
111669149699,METHOD,cli/cmdlineparser.cpp:<global>,TYPE_DECL,"static bool addIncludePathsToList(const std::string& fileList, std::list<std::string>& pathNames)
{
    std::ifstream files(fileList);
    if (files) {
        std::string pathName;
        // cppcheck-suppress accessMoved - FP
        while (std::getline(files, pathName)) { // next line
            if (!pathName.empty()) {
                pathName = Path::removeQuotationMarks(std::move(pathName));
                pathName = Path::fromNativeSeparators(std::move(pathName));

                // If path doesn't end with / or \\, add it
                if (!endsWith(pathName, '/'))
                    pathName += '/';

                pathNames.emplace_back(std::move(pathName));
            }
        }
        return true;
    }
    return false;
}",1,1,cli/cmdlineparser.cpp,"addIncludePathsToList:bool(std.string&,std.list<std.string>&)",<empty>,,false,86,107,addIncludePathsToList,,,1,"bool(std.string&,std.list<std.string>&)"
111669149700,METHOD,cli/cmdlineparser.cpp:<global>,TYPE_DECL,"static bool addPathsToSet(const std::string& fileName, std::set<std::string>& set)
{
    std::list<std::string> templist;
    if (!addIncludePathsToList(fileName, templist))
        return false;
    set.insert(templist.cbegin(), templist.cend());
    return true;
}",1,1,cli/cmdlineparser.cpp,"addPathsToSet:bool(std.string&,std.set<std.string>&)",<empty>,,false,109,116,addPathsToSet,,,1,"bool(std.string&,std.set<std.string>&)"
111669149701,METHOD,XMLErrorMessagesLogger,TYPE_DECL,"void reportOut(const std::string & outmsg, Color /*c*/ = Color::Reset) override
        {
            std::cout << outmsg << std::endl;
        }",9,9,cli/cmdlineparser.cpp,"XMLErrorMessagesLogger.reportOut:void(std.string&,Color)",<empty>,,false,121,124,reportOut,,,1,"void(std.string&,Color)"
111669149702,METHOD,XMLErrorMessagesLogger,TYPE_DECL,"void reportErr(const ErrorMessage &msg) override
        {
            reportOut(msg.toXML());
        }",9,9,cli/cmdlineparser.cpp,XMLErrorMessagesLogger.reportErr:void(ErrorMessage&),<empty>,,false,126,129,reportErr,,,2,void(ErrorMessage&)
111669149703,METHOD,XMLErrorMessagesLogger,TYPE_DECL,"void reportProgress(const std::string & /*filename*/, const char /*stage*/[], const std::size_t /*value*/) override
        {}",9,10,cli/cmdlineparser.cpp,"XMLErrorMessagesLogger.reportProgress:void(std.string&,char[],std.size_t)",<empty>,,false,131,132,reportProgress,,,3,"void(std.string&,char[],std.size_t)"
111669149704,METHOD,cli/cmdlineparser.cpp:<global>,TYPE_DECL,"CmdLineParser::CmdLineParser(CmdLineLogger &logger, Settings &settings, Suppressions &suppressions)
    : mLogger(logger)
    , mSettings(settings)
    , mSuppressions(suppressions)
{}",1,2,cli/cmdlineparser.cpp,"CmdLineParser.CmdLineParser:ANY(CmdLineLogger&,Settings&,Suppressions&)",<empty>,,false,136,140,CmdLineParser,,,1,"CmdLineParser.CmdLineParser:ANY(CmdLineLogger&,Settings&,Suppressions&)(CmdLineLogger&,Settings&,Suppressions&)"
111669149705,METHOD,<empty>,<empty>,"[](const std::string& i) {
        return Path::isHeader(i);
    }",69,5,cli/cmdlineparser.cpp,cli/cmdlineparser.cpp:<global>.CmdLineParser.fillSettingsFromArgs.<lambda>0:bool(std.string&),<empty>,,false,184,186,<lambda>0,,,1,bool(std.string&)
111669149706,METHOD,<empty>,<empty>,"[&](const FileSettings &fs) {
                return matchglobs(mSettings.fileFilters, fs.filename());
            }",110,13,cli/cmdlineparser.cpp,cli/cmdlineparser.cpp:<global>.CmdLineParser.fillSettingsFromArgs.<lambda>1:bool(FileSettings&),<empty>,,false,204,206,<lambda>1,,,1,bool(FileSettings&)
111669149707,METHOD,<empty>,<empty>,"[&](const FileSettings &fs) {
            return !mSettings.library.markupFile(fs.filename()) || !mSettings.library.processMarkupAfterCode(fs.filename());
        }",101,9,cli/cmdlineparser.cpp,cli/cmdlineparser.cpp:<global>.CmdLineParser.fillSettingsFromArgs.<lambda>2:bool(FileSettings&),<empty>,,false,252,254,<lambda>2,,,1,bool(FileSettings&)
111669149708,METHOD,<empty>,<empty>,"[&](const FileSettings &fs) {
            return mSettings.library.markupFile(fs.filename()) && mSettings.library.processMarkupAfterCode(fs.filename());
        }",101,9,cli/cmdlineparser.cpp,cli/cmdlineparser.cpp:<global>.CmdLineParser.fillSettingsFromArgs.<lambda>3:bool(FileSettings&),<empty>,,false,256,258,<lambda>3,,,1,bool(FileSettings&)
111669149709,METHOD,<empty>,<empty>,"[&](const FileWithDetails& entry) {
                    return entry.path() == name;
                }",88,17,cli/cmdlineparser.cpp,cli/cmdlineparser.cpp:<global>.CmdLineParser.fillSettingsFromArgs.<lambda>4:bool(FileWithDetails&),<empty>,,false,300,302,<lambda>4,,,1,bool(FileWithDetails&)
111669149710,METHOD,<empty>,<empty>,"[&](const FileWithDetails& entry) {
                return matchglobs(mSettings.fileFilters, entry.path());
            }",107,13,cli/cmdlineparser.cpp,cli/cmdlineparser.cpp:<global>.CmdLineParser.fillSettingsFromArgs.<lambda>5:bool(FileWithDetails&),<empty>,,false,309,311,<lambda>5,,,1,bool(FileWithDetails&)
111669149711,METHOD,<empty>,<empty>,"[&](const FileWithDetails& entry) {
            return !mSettings.library.markupFile(entry.path()) || !mSettings.library.processMarkupAfterCode(entry.path());
        }",89,9,cli/cmdlineparser.cpp,cli/cmdlineparser.cpp:<global>.CmdLineParser.fillSettingsFromArgs.<lambda>6:bool(FileWithDetails&),<empty>,,false,357,359,<lambda>6,,,1,bool(FileWithDetails&)
111669149712,METHOD,<empty>,<empty>,"[&](const FileWithDetails& entry) {
            return mSettings.library.markupFile(entry.path()) && mSettings.library.processMarkupAfterCode(entry.path());
        }",89,9,cli/cmdlineparser.cpp,cli/cmdlineparser.cpp:<global>.CmdLineParser.fillSettingsFromArgs.<lambda>7:bool(FileWithDetails&),<empty>,,false,361,363,<lambda>7,,,1,bool(FileWithDetails&)
111669149713,METHOD,cli/cmdlineparser.cpp:<global>,TYPE_DECL,"bool CmdLineParser::fillSettingsFromArgs(int argc, const char* const argv[])
{
    const Result result = parseFromArgs(argc, argv);

    switch (result) {
    case Result::Success:
        break;
    case Result::Exit:
        Settings::terminate();
        return true;
    case Result::Fail:
        return false;
    }

    // Libraries must be loaded before FileLister is executed to ensure markup files will be
    // listed properly.
    if (!loadLibraries(mSettings))
        return false;

    if (!loadAddons(mSettings))
        return false;

    // Check that all include paths exist
    {
        for (auto iter = mSettings.includePaths.cbegin();
             iter != mSettings.includePaths.cend();
             ) {
            const std::string path(Path::toNativeSeparators(*iter));
            if (Path::isDirectory(path))
                ++iter;
            else {
                // TODO: this bypasses the template format and other settings
                // If the include path...",1,1,cli/cmdlineparser.cpp,"CmdLineParser.fillSettingsFromArgs:bool(int,char[]*)",<empty>,,false,142,372,fillSettingsFromArgs,,,1,"bool(int,char[]*)"
111669149714,METHOD,cli/cmdlineparser.cpp:<global>,TYPE_DECL,"CmdLineParser::Result CmdLineParser::parseFromArgs(int argc, const char* const argv[])
{
    mSettings.exename = Path::getCurrentExecutablePath(argv[0]);

    // default to --check-level=normal from CLI for now
    mSettings.setCheckLevel(Settings::CheckLevel::normal);

    if (argc <= 1) {
        printHelp();
        return Result::Exit;
    }

    // check for exclusive options
    for (int i = 1; i < argc; i++) {
        // documentation..
        if (std::strcmp(argv[i], ""--doc"") == 0) {
            std::ostringstream doc;
            // Get documentation..
            for (const Check * it : Check::instances()) {
                const std::string& name(it->name());
                const std::string info(it->classInfo());
                if (!name.empty() && !info.empty())
                    doc << ""## "" << name << "" ##\\n""
                        << info << ""\\n"";
            }

            mLogger.printRaw(doc.str());
            return Result::Exit;
        }

        // prin...",1,1,cli/cmdlineparser.cpp,"CmdLineParser.parseFromArgs:CmdLineParser.Result(int,char[]*)",<empty>,,false,376,1645,parseFromArgs,,,1,"CmdLineParser.Result(int,char[]*)"
111669149715,METHOD,cli/cmdlineparser.cpp:<global>,TYPE_DECL,"void CmdLineParser::printHelp() const
{
    const std::string manualUrl(isCppcheckPremium() ?
                                ""https://cppcheck.sourceforge.io/manual.pdf"" :
                                ""https://files.cppchecksolutions.com/manual.pdf"");

    std::ostringstream oss;
    oss << ""Cppcheck - A tool for static C/C++ code analysis\\n""
        ""\\n""
        ""Syntax:\\n""
        ""    cppcheck [OPTIONS] [files or paths]\\n""
        ""\\n""
        ""If a directory is given instead of a filename, *.cpp, *.cxx, *.cc, *.c++, *.c, *.ipp,\\n""
        ""*.ixx, *.tpp, and *.txx files are checked recursively from the given directory.\\n\\n""
        ""Options:\\n""
        ""    --addon=<addon>\\n""
        ""                         Execute addon. i.e. --addon=misra. If options must be\\n""
        ""                         provided a json configuration is needed.\\n""
        ""    --addon-python=<python interpreter>\\n""
        ""                         You can specify the python interpreter either in t...",1,1,cli/cmdlineparser.cpp,CmdLineParser.printHelp<const>:void(),<empty>,,false,1647,2022,printHelp,,,1,void()
111669149716,METHOD,cli/cmdlineparser.cpp:<global>,TYPE_DECL,"std::string CmdLineParser::getVersion() const {
    if (!mSettings.cppcheckCfgProductName.empty())
        return mSettings.cppcheckCfgProductName;
    const char * const extraVersion = CppCheck::extraVersion();
    if (*extraVersion != '\\0')
        return std::string(""Cppcheck "") + CppCheck::version() + "" (""+ extraVersion + ')';
    return std::string(""Cppcheck "") + CppCheck::version();
}",1,1,cli/cmdlineparser.cpp,CmdLineParser.getVersion<const>:string(),<empty>,,false,2024,2031,getVersion,,,1,string()
111669149717,METHOD,cli/cmdlineparser.cpp:<global>,TYPE_DECL,"bool CmdLineParser::isCppcheckPremium() const {
    if (mSettings.cppcheckCfgProductName.empty())
        Settings::loadCppcheckCfg(mSettings, mSuppressions, mSettings.debuglookup || mSettings.debuglookupConfig);
    return startsWith(mSettings.cppcheckCfgProductName, ""Cppcheck Premium"");
}",1,1,cli/cmdlineparser.cpp,CmdLineParser.isCppcheckPremium<const>:bool(),<empty>,,false,2033,2037,isCppcheckPremium,,,1,bool()
111669149718,METHOD,cli/cmdlineparser.cpp:<global>,TYPE_DECL,"bool CmdLineParser::tryLoadLibrary(Library& destination, const std::string& basepath, const char* filename, bool debug)
{
    const Library::Error err = destination.load(basepath.c_str(), filename, debug);

    if (err.errorcode == Library::ErrorCode::UNKNOWN_ELEMENT)
        mLogger.printMessage(""Found unknown elements in configuration file '"" + std::string(filename) + ""': "" + err.reason); // TODO: print as errors
    else if (err.errorcode != Library::ErrorCode::OK) {
        std::string msg = ""Failed to load library configuration file '"" + std::string(filename) + ""'. "";
        switch (err.errorcode) {
        case Library::ErrorCode::OK:
            break;
        case Library::ErrorCode::FILE_NOT_FOUND:
            msg += ""File not found"";
            break;
        case Library::ErrorCode::BAD_XML:
            msg += ""Bad XML"";
            break;
        case Library::ErrorCode::UNKNOWN_ELEMENT:
            msg += ""Unexpected element"";
            break;
        case Library::...",1,1,cli/cmdlineparser.cpp,"CmdLineParser.tryLoadLibrary:bool(Library&,std.string&,char*,bool)",<empty>,,false,2039,2084,tryLoadLibrary,,,1,"bool(Library&,std.string&,char*,bool)"
111669149719,METHOD,cli/cmdlineparser.cpp:<global>,TYPE_DECL,"bool CmdLineParser::loadLibraries(Settings& settings)
{
    if (!tryLoadLibrary(settings.library, settings.exename, ""std.cfg"", settings.debuglookup || settings.debuglookupLibrary)) {
        const std::string msg(""Failed to load std.cfg. Your Cppcheck installation is broken, please re-install."");
#ifdef FILESDIR
        const std::string details(""The Cppcheck binary was compiled with FILESDIR set to \\""""
                                  FILESDIR ""\\"" and will therefore search for ""
                                  ""std.cfg in "" FILESDIR ""/cfg."");
#else
        const std::string cfgfolder(Path::fromNativeSeparators(Path::getPathFromFilename(settings.exename)) + ""cfg"");
        const std::string details(""The Cppcheck binary was compiled without FILESDIR set. Either the ""
                                  ""std.cfg should be available in "" + cfgfolder + "" or the FILESDIR ""
                                  ""should be configured."");
#endif
        mLogger.printRaw(msg + "" "" + details); /...",1,1,cli/cmdlineparser.cpp,CmdLineParser.loadLibraries:bool(Settings&),<empty>,,false,2086,2111,loadLibraries,,,1,bool(Settings&)
111669149720,METHOD,cli/cmdlineparser.cpp:<global>,TYPE_DECL,"bool CmdLineParser::loadAddons(Settings& settings)
{
    bool result = true;
    for (const std::string &addon: settings.addons) {
        AddonInfo addonInfo;
        const std::string failedToGetAddonInfo = addonInfo.getAddonInfo(addon, settings.exename, settings.debuglookup || settings.debuglookupAddon);
        if (!failedToGetAddonInfo.empty()) {
            mLogger.printRaw(failedToGetAddonInfo); // TODO: do not print as raw
            result = false;
            continue;
        }
        settings.addonInfos.emplace_back(std::move(addonInfo));
    }
    return result;
}",1,1,cli/cmdlineparser.cpp,CmdLineParser.loadAddons:bool(Settings&),<empty>,,false,2113,2127,loadAddons,,,1,bool(Settings&)
111669149721,METHOD,cli/cmdlineparser.cpp:<global>,TYPE_DECL,"bool CmdLineParser::loadCppcheckCfg()
{
    if (!mSettings.cppcheckCfgProductName.empty())
        return true;
    const std::string cfgErr = Settings::loadCppcheckCfg(mSettings, mSuppressions, mSettings.debuglookup || mSettings.debuglookupConfig);
    if (!cfgErr.empty()) {
        mLogger.printError(""could not load cppcheck.cfg - "" + cfgErr);
        return false;
    }
    return true;
}",1,1,cli/cmdlineparser.cpp,CmdLineParser.loadCppcheckCfg:bool(),<empty>,,false,2129,2139,loadCppcheckCfg,,,1,bool()
111669149722,METHOD,cli/cmdlineparser.h:<global>,TYPE_DECL,<global>,1,1,cli/cmdlineparser.h,cli/cmdlineparser.h:<global>,<empty>,,false,1,172,<global>,,,1,
111669149723,METHOD,SarifReport,TYPE_DECL,"void addFinding(ErrorMessage msg) {
            mFindings.push_back(std::move(msg));
        }",9,9,cli/cppcheckexecutor.cpp,SarifReport.addFinding:void(ErrorMessage),<empty>,,false,83,85,addFinding,,,1,void(ErrorMessage)
111669149724,METHOD,SarifReport,TYPE_DECL,"picojson::array serializeRules() const {
            picojson::array ret;
            std::set<std::string> ruleIds;
            for (const auto& finding : mFindings) {
                // github only supports findings with locations
                if (finding.callStack.empty())
                    continue;
                if (ruleIds.insert(finding.id).second) {
                    picojson::object rule;
                    rule[""id""] = picojson::value(finding.id);
                    // rule.shortDescription.text
                    picojson::object shortDescription;
                    shortDescription[""text""] = picojson::value(finding.shortMessage());
                    rule[""shortDescription""] = picojson::value(shortDescription);
                    // rule.fullDescription.text
                    picojson::object fullDescription;
                    fullDescription[""text""] = picojson::value(finding.verboseMessage());
                    rule[""fullDescription""] = picojson::va...",9,9,cli/cppcheckexecutor.cpp,SarifReport.serializeRules<const>:array(),<empty>,,false,87,128,serializeRules,,,2,array()
111669149725,METHOD,SarifReport,TYPE_DECL,"static picojson::array serializeLocations(const ErrorMessage& finding) {
            picojson::array ret;
            for (const auto& location : finding.callStack) {
                picojson::object physicalLocation;
                picojson::object artifactLocation;
                artifactLocation[""uri""] = picojson::value(location.getfile(false));
                physicalLocation[""artifactLocation""] = picojson::value(artifactLocation);
                picojson::object region;
                region[""startLine""] = picojson::value(static_cast<int64_t>(location.line));
                region[""startColumn""] = picojson::value(static_cast<int64_t>(location.column));
                region[""endLine""] = region[""startLine""];
                region[""endColumn""] = region[""startColumn""];
                physicalLocation[""region""] = picojson::value(region);
                picojson::object loc;
                loc[""physicalLocation""] = picojson::value(physicalLocation);
                ret.em...",9,9,cli/cppcheckexecutor.cpp,SarifReport.serializeLocations:array(ErrorMessage&),<empty>,,false,130,148,serializeLocations,,,3,array(ErrorMessage&)
111669149726,METHOD,SarifReport,TYPE_DECL,"picojson::array serializeResults() const {
            picojson::array results;
            for (const auto& finding : mFindings) {
                // github only supports findings with locations
                if (finding.callStack.empty())
                    continue;
                picojson::object res;
                res[""level""] = picojson::value(sarifSeverity(finding));
                res[""locations""] = picojson::value(serializeLocations(finding));
                picojson::object message;
                message[""text""] = picojson::value(finding.shortMessage());
                res[""message""] = picojson::value(message);
                res[""ruleId""] = picojson::value(finding.id);
                results.emplace_back(res);
            }
            return results;
        }",9,9,cli/cppcheckexecutor.cpp,SarifReport.serializeResults<const>:array(),<empty>,,false,150,166,serializeResults,,,4,array()
111669149727,METHOD,SarifReport,TYPE_DECL,"picojson::value serializeRuns(const std::string& productName, const std::string& version) const {
            picojson::object driver;
            driver[""name""] = picojson::value(productName);
            driver[""semanticVersion""] = picojson::value(version);
            driver[""informationUri""] = picojson::value(""https://cppcheck.sourceforge.io"");
            driver[""rules""] = picojson::value(serializeRules());
            picojson::object tool;
            tool[""driver""] = picojson::value(driver);
            picojson::object run;
            run[""tool""] = picojson::value(tool);
            run[""results""] = picojson::value(serializeResults());
            picojson::array runs{picojson::value(run)};
            return picojson::value(runs);
        }",9,9,cli/cppcheckexecutor.cpp,"SarifReport.serializeRuns<const>:value(std.string&,std.string&)",<empty>,,false,168,181,serializeRuns,,,5,"value(std.string&,std.string&)"
111669149728,METHOD,SarifReport,TYPE_DECL,"std::string serialize(std::string productName) const {
            const auto nameAndVersion = Settings::getNameAndVersion(productName);
            productName = nameAndVersion.first.empty() ? ""Cppcheck"" : nameAndVersion.first;
            std::string version = nameAndVersion.first.empty() ? CppCheck::version() : nameAndVersion.second;
            if (version.find(' ') != std::string::npos)
                version.erase(version.find(' '), std::string::npos);

            picojson::object doc;
            doc[""version""] = picojson::value(""2.1.0"");
            doc[""$schema""] = picojson::value(""https://docs.oasis-open.org/sarif/sarif/v2.1.0/errata01/os/schemas/sarif-schema-2.1.0.json"");
            doc[""runs""] = serializeRuns(productName, version);

            return picojson::value(doc).serialize(true);
        }",9,9,cli/cppcheckexecutor.cpp,SarifReport.serialize<const>:string(std.string),<empty>,,false,183,196,serialize,,,6,string(std.string)
111669149729,METHOD,SarifReport,TYPE_DECL,"static std::string sarifSeverity(const ErrorMessage& errmsg) {
            if (ErrorLogger::isCriticalErrorId(errmsg.id))
                return ""error"";
            switch (errmsg.severity) {
            case Severity::error:
            case Severity::warning:
            case Severity::style:
            case Severity::portability:
            case Severity::performance:
                return ""warning"";
            case Severity::information:
            case Severity::internal:
            case Severity::debug:
            case Severity::none:
                return ""note"";
            }
            return ""note"";
        }",9,9,cli/cppcheckexecutor.cpp,SarifReport.sarifSeverity:string(ErrorMessage&),<empty>,,false,199,216,sarifSeverity,,,7,string(ErrorMessage&)
111669149730,METHOD,SarifReport,TYPE_DECL,"static std::string sarifPrecision(const ErrorMessage& errmsg) {
            if (errmsg.certainty == Certainty::inconclusive)
                return ""medium"";
            return ""high"";
        }",9,9,cli/cppcheckexecutor.cpp,SarifReport.sarifPrecision:string(ErrorMessage&),<empty>,,false,218,222,sarifPrecision,,,8,string(ErrorMessage&)
111669149731,METHOD,CmdLineLoggerStd,TYPE_DECL,CmdLineLoggerStd() = default;,9,37,cli/cppcheckexecutor.cpp,CmdLineLoggerStd.CmdLineLoggerStd:ANY(),<empty>,,false,230,230,CmdLineLoggerStd,,,1,ANY()
111669149732,METHOD,CmdLineLoggerStd,TYPE_DECL,"void printMessage(const std::string &message) override
        {
            printRaw(""cppcheck: "" + message);
        }",9,9,cli/cppcheckexecutor.cpp,CmdLineLoggerStd.printMessage:void(std.string&),<empty>,,false,232,235,printMessage,,,2,void(std.string&)
111669149733,METHOD,CmdLineLoggerStd,TYPE_DECL,"void printError(const std::string &message) override
        {
            printMessage(""error: "" + message);
        }",9,9,cli/cppcheckexecutor.cpp,CmdLineLoggerStd.printError:void(std.string&),<empty>,,false,237,240,printError,,,3,void(std.string&)
111669149734,METHOD,CmdLineLoggerStd,TYPE_DECL,"void printRaw(const std::string &message) override
        {
            std::cout << message << std::endl; // TODO: should not append newline
        }",9,9,cli/cppcheckexecutor.cpp,CmdLineLoggerStd.printRaw:void(std.string&),<empty>,,false,242,245,printRaw,,,4,void(std.string&)
111669149735,METHOD,StdLogger,TYPE_DECL,"explicit StdLogger(const Settings& settings)
            : mSettings(settings)
            , mGuidelineMapping(createGuidelineMapping(settings.reportType))
        {
            if (!mSettings.outputFile.empty()) {
                mErrorOutput = new std::ofstream(settings.outputFile);
            }
        }",9,9,cli/cppcheckexecutor.cpp,StdLogger.StdLogger:ANY(Settings&),<empty>,,false,251,258,StdLogger,,,1,StdLogger.StdLogger:ANY(Settings&)(Settings&)
111669149736,METHOD,StdLogger,TYPE_DECL,"~StdLogger() override {
            if (mSettings.outputFormat == Settings::OutputFormat::sarif) {
                reportErr(mSarifReport.serialize(mSettings.cppcheckCfgProductName));
            }
            delete mErrorOutput;
        }",9,9,cli/cppcheckexecutor.cpp,StdLogger.~StdLogger:ANY(),<empty>,,false,260,265,~StdLogger,,,2,ANY()
111669149737,METHOD,StdLogger,TYPE_DECL,StdLogger(const StdLogger&) = delete;,9,45,cli/cppcheckexecutor.cpp,StdLogger.StdLogger:ANY(StdLogger&),<empty>,,false,267,267,StdLogger,,,3,ANY(StdLogger&)
111669149738,METHOD,StdLogger,TYPE_DECL,StdLogger& operator=(const SingleExecutor &) = delete;,9,62,cli/cppcheckexecutor.cpp,StdLogger.=:StdLogger&(SingleExecutor&),<empty>,,false,268,268,=,,,4,StdLogger&(SingleExecutor&)
111669149739,METHOD,StdLogger,TYPE_DECL,"void resetLatestProgressOutputTime() {
            mLatestProgressOutputTime = std::time(nullptr);
        }",9,9,cli/cppcheckexecutor.cpp,StdLogger.resetLatestProgressOutputTime:void(),<empty>,,false,270,272,resetLatestProgressOutputTime,,,5,void()
111669149740,METHOD,StdLogger,TYPE_DECL,"bool hasCriticalErrors() const {
            return !mCriticalErrors.empty();
        }",9,9,cli/cppcheckexecutor.cpp,StdLogger.hasCriticalErrors<const>:bool(),<empty>,,false,285,287,hasCriticalErrors,,,6,bool()
111669149741,METHOD,StdLogger,TYPE_DECL,"const std::string& getCtuInfo() const {
            return mCtuInfo;
        }",9,9,cli/cppcheckexecutor.cpp,StdLogger.getCtuInfo<const>:ANY(),<empty>,,false,289,291,getCtuInfo,,,7,ANY()
111669149742,METHOD,<empty>,<empty>,<empty>,5,,cli/cppcheckexecutor.cpp,StdLogger.<clinit>,<empty>,,false,248,,<clinit>,,,17,
111669149743,METHOD,cli/cppcheckexecutor.cpp:<global>,TYPE_DECL,"int CppCheckExecutor::check(int argc, const char* const argv[])
{
    Settings settings;
    CmdLineLoggerStd logger;
    Suppressions supprs;
    CmdLineParser parser(logger, settings, supprs);
    if (!parser.fillSettingsFromArgs(argc, argv)) {
        return EXIT_FAILURE;
    }
    if (Settings::terminated()) {
        return EXIT_SUCCESS;
    }

    settings.loadSummaries();

    mFiles = parser.getFiles();
    mFileSettings = parser.getFileSettings();

    settings.setMisraRuleTexts(executeCommand);

    const int ret = check_wrapper(settings, supprs);

    return ret;
}",1,1,cli/cppcheckexecutor.cpp,"CppCheckExecutor.check:int(int,char[]*)",<empty>,,false,355,378,check,,,1,"int(int,char[]*)"
111669149744,METHOD,cli/cppcheckexecutor.cpp:<global>,TYPE_DECL,<global>,1,1,cli/cppcheckexecutor.cpp,cli/cppcheckexecutor.cpp:<global>,<empty>,,false,1,727,<global>,,,1,
111669149745,METHOD,cli/cppcheckexecutor.cpp:<global>,TYPE_DECL,"int CppCheckExecutor::check_wrapper(const Settings& settings, Suppressions& supprs)
{
#ifdef USE_WINDOWS_SEH
    if (settings.exceptionHandling) {
        CALL_WITH_SEH_WRAPPER(check_internal(settings, supprs));
    }
#elif defined(USE_UNIX_SIGNAL_HANDLING)
    if (settings.exceptionHandling)
        register_signal_handler(settings.exceptionOutput);
#endif
    return check_internal(settings, supprs);
}",1,1,cli/cppcheckexecutor.cpp,"CppCheckExecutor.check_wrapper:int(Settings&,Suppressions&)",<empty>,,false,380,391,check_wrapper,,,1,"int(Settings&,Suppressions&)"
111669149746,METHOD,<empty>,<empty>,"[](const SuppressionList::Suppression& s) {
        return s.errorId == ""unmatchedSuppression"" && s.fileName.empty() && s.lineNumber == SuppressionList::Suppression::NO_LINE;
    }",49,5,cli/cppcheckexecutor.cpp,cli/cppcheckexecutor.cpp:<global>.CppCheckExecutor.reportSuppressions.<lambda>0:bool(SuppressionList.Suppression&),<empty>,,false,395,397,<lambda>0,,,1,bool(SuppressionList.Suppression&)
111669149747,METHOD,cli/cppcheckexecutor.cpp:<global>,TYPE_DECL,"bool CppCheckExecutor::reportSuppressions(const Settings &settings, const SuppressionList& suppressions, bool unusedFunctionCheckEnabled, const std::list<FileWithDetails> &files, const std::list<FileSettings>& fileSettings, ErrorLogger& errorLogger) {
    const auto& suppr = suppressions.getSuppressions();
    if (std::any_of(suppr.begin(), suppr.end(), [](const SuppressionList::Suppression& s) {
        return s.errorId == ""unmatchedSuppression"" && s.fileName.empty() && s.lineNumber == SuppressionList::Suppression::NO_LINE;
    }))
        return false;

    bool err = false;
    if (settings.useSingleJob()) {
        // the two inputs may only be used exclusively
        assert(!(!files.empty() && !fileSettings.empty()));

        for (auto i = files.cbegin(); i != files.cend(); ++i) {
            err |= SuppressionList::reportUnmatchedSuppressions(
                suppressions.getUnmatchedLocalSuppressions(*i, unusedFunctionCheckEnabled), errorLogger);
        }

        for (aut...",1,1,cli/cppcheckexecutor.cpp,"CppCheckExecutor.reportSuppressions:bool(Settings&,SuppressionList&,bool,std.list<FileWithDetails>&,std.list<FileSettings>&,ErrorLogger&)",<empty>,,false,393,423,reportSuppressions,,,1,"bool(Settings&,SuppressionList&,bool,std.list<FileWithDetails>&,std.list<FileSettings>&,ErrorLogger&)"
111669149748,METHOD,cli/cppcheckexecutor.cpp:<global>,TYPE_DECL,"int CppCheckExecutor::check_internal(const Settings& settings, Suppressions& supprs) const
{
    StdLogger stdLogger(settings);

    if (settings.reportProgress >= 0)
        stdLogger.resetLatestProgressOutputTime();

    if (settings.outputFormat == Settings::OutputFormat::xml) {
        stdLogger.reportErr(ErrorMessage::getXMLHeader(settings.cppcheckCfgProductName, settings.xml_version));
    }

    if (!settings.buildDir.empty()) {
        std::list<std::string> fileNames;
        for (auto i = mFiles.cbegin(); i != mFiles.cend(); ++i)
            fileNames.emplace_back(i->path());
        AnalyzerInformation::writeFilesTxt(settings.buildDir, fileNames, settings.userDefines, mFileSettings);
    }

    if (!settings.checkersReportFilename.empty())
        std::remove(settings.checkersReportFilename.c_str());

    CppCheck cppcheck(settings, supprs, stdLogger, true, executeCommand);

    unsigned int returnValue = 0;
    if (settings.useSingleJob()) {
        // Single process
   ...",1,1,cli/cppcheckexecutor.cpp,"CppCheckExecutor.check_internal<const>:int(Settings&,Suppressions&)",<empty>,,false,428,495,check_internal,,,1,"int(Settings&,Suppressions&)"
111669149749,METHOD,<empty>,<empty>,"[](const SuppressionList::Suppression& s) {
        return s.errorId == ""checkersReport"";
    }",92,5,cli/cppcheckexecutor.cpp,cli/cppcheckexecutor.cpp:<global>.StdLogger.writeCheckersReport.<lambda>1:bool(SuppressionList.Suppression&),<empty>,,false,509,511,<lambda>1,,,1,bool(SuppressionList.Suppression&)
111669149750,METHOD,cli/cppcheckexecutor.cpp:<global>,TYPE_DECL,"void StdLogger::writeCheckersReport(const Suppressions& supprs)
{
    const bool summary = mSettings.safety || mSettings.severity.isEnabled(Severity::information);
    const bool xmlReport = mSettings.outputFormat == Settings::OutputFormat::xml && mSettings.xml_version == 3;
    const bool textReport = !mSettings.checkersReportFilename.empty();

    if (!summary && !xmlReport && !textReport)
        return;

    CheckersReport checkersReport(mSettings, mActiveCheckers);

    const auto& suppressions = supprs.nomsg.getSuppressions();
    const bool summarySuppressed = std::any_of(suppressions.cbegin(), suppressions.cend(), [](const SuppressionList::Suppression& s) {
        return s.errorId == ""checkersReport"";
    });

    if (summary && !summarySuppressed) {
        ErrorMessage msg;
        msg.severity = Severity::information;
        msg.id = ""checkersReport"";

        const int activeCheckers = checkersReport.getActiveCheckersCount();
        const int totalCheckers = checkersR...",1,1,cli/cppcheckexecutor.cpp,StdLogger.writeCheckersReport:void(Suppressions&),<empty>,,false,497,552,writeCheckersReport,,,1,void(Suppressions&)
111669149751,METHOD,cli/cppcheckexecutor.cpp:<global>,TYPE_DECL,"static inline std::string ansiToOEM(const std::string &msg, bool doConvert)
{
    if (doConvert) {
        const unsigned msglength = msg.length();
        // convert ANSI strings to OEM strings in two steps
        std::vector<WCHAR> wcContainer(msglength);
        std::string result(msglength, '\\0');

        // ansi code page characters to wide characters
        MultiByteToWideChar(CP_ACP, 0, msg.data(), msglength, wcContainer.data(), msglength);
        // wide characters to oem codepage characters
        WideCharToMultiByte(CP_OEMCP, 0, wcContainer.data(), msglength, &result[0], msglength, nullptr, nullptr);

        return result; // hope for return value optimization
    }
    return msg;
}",1,1,cli/cppcheckexecutor.cpp,"ansiToOEM:string(std.string&,bool)",<empty>,,false,556,572,ansiToOEM,,,1,"string(std.string&,bool)"
111669149752,METHOD,cli/cppcheckexecutor.cpp:<global>,TYPE_DECL,"void StdLogger::reportErr(const std::string &errmsg)
{
    if (mErrorOutput)
        *mErrorOutput << errmsg << std::endl;
    else {
        std::cerr << ansiToOEM(errmsg, mSettings.outputFormat != Settings::OutputFormat::xml) << std::endl;
    }
}",1,21,cli/cppcheckexecutor.cpp,StdLogger.reportErr:void(std.string&),<empty>,,false,578,585,reportErr,,,1,void(std.string&)
111669149753,METHOD,cli/cppcheckexecutor.cpp:<global>,TYPE_DECL,"void StdLogger::reportOut(const std::string &outmsg, Color c)
{
    if (c == Color::Reset)
        std::cout << ansiToOEM(outmsg, true) << std::endl;
    else
        std::cout << c << ansiToOEM(outmsg, true) << Color::Reset << std::endl;
}",1,21,cli/cppcheckexecutor.cpp,"StdLogger.reportOut:void(std.string&,Color)",<empty>,,false,587,593,reportOut,,,1,"void(std.string&,Color)"
111669149754,METHOD,cli/cppcheckexecutor.cpp:<global>,TYPE_DECL,"void StdLogger::reportProgress(const std::string &filename, const char stage[], const std::size_t value)
{
    (void)filename;

    if (!mLatestProgressOutputTime)
        return;

    // Report progress messages every x seconds
    const std::time_t currentTime = std::time(nullptr);
    if (currentTime >= (mLatestProgressOutputTime + mSettings.reportProgress))
    {
        mLatestProgressOutputTime = currentTime;

        // format a progress message
        std::ostringstream ostr;
        ostr << ""progress: ""
             << stage
             << ' ' << value << '%';

        // Report progress message
        reportOut(ostr.str());
    }
}",1,1,cli/cppcheckexecutor.cpp,"StdLogger.reportProgress:void(std.string&,char[],std.size_t)",<empty>,,false,596,618,reportProgress,,,1,"void(std.string&,char[],std.size_t)"
111669149755,METHOD,cli/cppcheckexecutor.cpp:<global>,TYPE_DECL,"void StdLogger::reportErr(const ErrorMessage &msg)
{
    if (msg.severity == Severity::internal && (msg.id == ""logChecker"" || endsWith(msg.id, ""-logChecker""))) {
        const std::string& checker = msg.shortMessage();
        mActiveCheckers.emplace(checker);
        return;
    }

    if (msg.severity == Severity::internal && msg.id == ""ctuinfo"") {
        mCtuInfo += msg.shortMessage() + ""\\n"";
        return;
    }

    if (ErrorLogger::isCriticalErrorId(msg.id) && mCriticalErrors.find(msg.id) == std::string::npos) {
        if (!mCriticalErrors.empty())
            mCriticalErrors += "", "";
        mCriticalErrors += msg.id;
        if (msg.severity == Severity::internal)
            mCriticalErrors += "" (suppressed)"";
    }

    if (msg.severity == Severity::internal)
        return;

    ErrorMessage msgCopy = msg;
    msgCopy.guideline = getGuideline(msgCopy.id, mSettings.reportType,
                                     mGuidelineMapping, msgCopy.severity);
    msgCopy.classif...",1,1,cli/cppcheckexecutor.cpp,StdLogger.reportErr:void(ErrorMessage&),<empty>,,false,620,662,reportErr,,,1,void(ErrorMessage&)
111669149756,METHOD,cli/cppcheckexecutor.cpp:<global>,TYPE_DECL,"int CppCheckExecutor::executeCommand(std::string exe, std::vector<std::string> args, std::string redirect, std::string &output_)
{
    output_.clear();

#ifdef _WIN32
    // Extra quoutes are needed in windows if filename has space
    if (exe.find("" "") != std::string::npos)
        exe = ""\\"""" + exe + ""\\"""";
#endif

    std::string joinedArgs;
    for (const std::string &arg : args) {
        if (!joinedArgs.empty())
            joinedArgs += "" "";
        if (arg.find(' ') != std::string::npos)
            joinedArgs += '""' + arg + '""';
        else
            joinedArgs += arg;
    }

    const std::string cmd = exe + "" "" + joinedArgs + "" "" + redirect;

#ifdef _WIN32
    FILE* p = _popen(cmd.c_str(), ""r"");
#else
    FILE *p = popen(cmd.c_str(), ""r"");
#endif
    //std::cout << ""invoking command '"" << cmd << ""'"" << std::endl;
    if (!p) {
        // TODO: how to provide to caller?
        //const int err = errno;
        //std::cout << ""popen() errno "" << std::to_string(err) << std:...",1,1,cli/cppcheckexecutor.cpp,"CppCheckExecutor.executeCommand:int(std.string,std.vector<std.string>,std.string,std.string&)",<empty>,,false,669,727,executeCommand,,,1,"int(std.string,std.vector<std.string>,std.string,std.string&)"
111669149757,METHOD,cli/cppcheckexecutor.h:<global>,TYPE_DECL,<global>,1,1,cli/cppcheckexecutor.h,cli/cppcheckexecutor.h:<global>,<empty>,,false,1,105,<global>,,,1,
111669149758,METHOD,cli/executor.cpp:<global>,TYPE_DECL,"Executor::Executor(const std::list<FileWithDetails> &files, const std::list<FileSettings>& fileSettings, const Settings &settings, Suppressions &suppressions, ErrorLogger &errorLogger)
    : mFiles(files), mFileSettings(fileSettings), mSettings(settings), mSuppressions(suppressions), mErrorLogger(errorLogger)
{
    // the two inputs may only be used exclusively
    assert(!(!files.empty() && !fileSettings.empty()));
}",1,1,cli/executor.cpp,"Executor.Executor:ANY(std.list<FileWithDetails>&,std.list<FileSettings>&,Settings&,Suppressions&,ErrorLogger&)",<empty>,,false,33,38,Executor,,,1,"Executor.Executor:ANY(std.list<FileWithDetails>&,std.list<FileSettings>&,Settings&,Suppressions&,ErrorLogger&)(std.list<FileWithDetails>&,std.list<FileSettings>&,Settings&,Suppressions&,ErrorLogger&)"
111669149759,METHOD,cli/executor.cpp:<global>,TYPE_DECL,<global>,1,1,cli/executor.cpp,cli/executor.cpp:<global>,<empty>,,false,1,74,<global>,,,1,
111669149760,METHOD,cli/executor.cpp:<global>,TYPE_DECL,"bool Executor::hasToLog(const ErrorMessage &msg)
{
    if (msg.severity == Severity::internal)
        return true;

    if (!mSuppressions.nomsg.isSuppressed(msg, {}))
    {
        // TODO: there should be no need for verbose and default messages here
        std::string errmsg = msg.toString(mSettings.verbose, mSettings.templateFormat, mSettings.templateLocation);
        if (errmsg.empty())
            return false;

        if (mSettings.emitDuplicates)
            return true;

        std::lock_guard<std::mutex> lg(mErrorListSync);
        if (mErrorList.emplace(std::move(errmsg)).second) {
            return true;
        }
    }
    return false;
}",1,1,cli/executor.cpp,Executor.hasToLog:bool(ErrorMessage&),<empty>,,false,41,62,hasToLog,,,1,bool(ErrorMessage&)
111669149761,METHOD,cli/executor.cpp:<global>,TYPE_DECL,"void Executor::reportStatus(std::size_t fileindex, std::size_t filecount, std::size_t sizedone, std::size_t sizetotal)
{
    if (filecount > 1) {
        std::ostringstream oss;
        const unsigned long percentDone = (sizetotal > 0) ? (100 * sizedone) / sizetotal : 0;
        oss << fileindex << '/' << filecount
            << "" files checked "" << percentDone
            << ""% done"";
        mErrorLogger.reportOut(oss.str(), Color::FgBlue);
    }
}",1,1,cli/executor.cpp,"Executor.reportStatus:void(std.size_t,std.size_t,std.size_t,std.size_t)",<empty>,,false,64,74,reportStatus,,,1,"void(std.size_t,std.size_t,std.size_t,std.size_t)"
111669149762,METHOD,cli/executor.h:<global>,TYPE_DECL,<global>,1,20,cli/executor.h,cli/executor.h:<global>,<empty>,,false,1,84,<global>,,,1,
111669149763,METHOD,cli/filelister.cpp:<global>,TYPE_DECL,"static std::string addFiles2(std::list<FileWithDetails>&files, const std::string &path, const std::set<std::string> &extra, bool recursive, const PathMatch& ignored, bool debug = false)
{
    const std::string cleanedPath = Path::toNativeSeparators(path);

    // basedir is the base directory which is used to form pathnames.
    // It always has a trailing backslash available for concatenation.
    std::string basedir;

    // searchPattern is the search string passed into FindFirst and FindNext.
    std::string searchPattern = cleanedPath;

    // The user wants to check all files in a dir
    const bool checkAllFilesInDir = Path::isDirectory(cleanedPath);

    if (checkAllFilesInDir) {
        const char c = cleanedPath.back();
        switch (c) {
        case '\\\\':
            searchPattern += '*';
            basedir = cleanedPath;
            break;
        case '*':
            basedir = cleanedPath.substr(0, cleanedPath.length() - 1);
            break;
        default:
    ...",1,1,cli/filelister.cpp,"addFiles2<duplicate>0:string(std.list<FileWithDetails>&,std.string&,std.set<std.string>&,bool,PathMatch&,bool)",<empty>,,false,49,166,addFiles2,,,1,"string(std.list<FileWithDetails>&,std.string&,std.set<std.string>&,bool,PathMatch&,bool)"
111669149764,METHOD,cli/filelister.cpp:<global>,TYPE_DECL,<global>,1,1,cli/filelister.cpp,cli/filelister.cpp:<global>,<empty>,,false,1,308,<global>,,,1,
111669149765,METHOD,cli/filelister.cpp:<global>,TYPE_DECL,"std::string FileLister::addFiles(std::list<FileWithDetails> &files, const std::string &path, const std::set<std::string> &extra, bool recursive, const PathMatch& ignored, bool debug)
{
    if (path.empty())
        return ""no path specified"";

    std::list<FileWithDetails> filesSorted;

    std::string err = addFiles2(filesSorted, path, extra, recursive, ignored, debug);

    // files need to be sorted as the filesystems dosn't provide a stable order
    filesSorted.sort([](const FileWithDetails& a, const FileWithDetails& b) {
        return a.path() < b.path();
    });
    files.insert(files.end(), std::make_move_iterator(filesSorted.begin()), std::make_move_iterator(filesSorted.end()));

    return err;
}",1,1,cli/filelister.cpp,"FileLister.addFiles:string(std.list<FileWithDetails>&,std.string&,std.set<std.string>&,bool,PathMatch&,bool)",<empty>,,false,168,184,addFiles,,,1,"string(std.list<FileWithDetails>&,std.string&,std.set<std.string>&,bool,PathMatch&,bool)"
111669149766,METHOD,cli/filelister.cpp:<global>,TYPE_DECL,"static std::string addFiles2(std::list<FileWithDetails> &files,
                             const std::string &path,
                             const std::set<std::string> &extra,
                             bool recursive,
                             const PathMatch& ignored,
                             bool debug)
{
    if (ignored.match(path))
    {
        if (debug)
            std::cout << ""ignored path: "" << path << std::endl;
        return """";
    }

    struct stat file_stat;
    if (stat(path.c_str(), &file_stat) == -1)
        return """"; // TODO: return error?
    if ((file_stat.st_mode & S_IFMT) != S_IFDIR)
    {
        files.emplace_back(path, Standards::Language::None, file_stat.st_size);
        return """";
    }

    // process directory entry

    DIR * dir = opendir(path.c_str());
    if (!dir) {
        const int err = errno;
        return ""could not open directory '"" + path + ""' (errno: "" + std::to_string(err) + "")"";
    }
    std::unique_ptr<DIR, decltyp...",1,1,cli/filelister.cpp,"addFiles2:string(std.list<FileWithDetails>&,std.string&,std.set<std.string>&,bool,PathMatch&,bool)",<empty>,,false,196,279,addFiles2,,,1,"string(std.list<FileWithDetails>&,std.string&,std.set<std.string>&,bool,PathMatch&,bool)"
111669149767,METHOD,<empty>,<empty>,"[](const FileWithDetails& a, const FileWithDetails& b) {
        return a.path() < b.path();
    }",22,5,cli/filelister.cpp,"cli/filelister.cpp:<global>.FileLister.addFiles.<lambda>0:bool(FileWithDetails&,FileWithDetails&)",<empty>,,false,295,297,<lambda>0,,,1,"bool(FileWithDetails&,FileWithDetails&)"
111669149768,METHOD,cli/filelister.cpp:<global>,TYPE_DECL,"std::string FileLister::addFiles(std::list<FileWithDetails> &files, const std::string &path, const std::set<std::string> &extra, bool recursive, const PathMatch& ignored, bool debug)
{
    if (path.empty())
        return ""no path specified"";

    std::string corrected_path = path;
    if (endsWith(corrected_path, '/'))
        corrected_path.erase(corrected_path.end() - 1);

    std::list<FileWithDetails> filesSorted;

    std::string err = addFiles2(filesSorted, corrected_path, extra, recursive, ignored, debug);

    // files need to be sorted as the filesystems dosn't provide a stable order
    filesSorted.sort([](const FileWithDetails& a, const FileWithDetails& b) {
        return a.path() < b.path();
    });
    files.insert(files.end(), std::make_move_iterator(filesSorted.begin()), std::make_move_iterator(filesSorted.end()));

    return err;
}",1,1,cli/filelister.cpp,"FileLister.addFiles<duplicate>0:string(std.list<FileWithDetails>&,std.string&,std.set<std.string>&,bool,PathMatch&,bool)",<empty>,,false,281,301,addFiles,,,1,"string(std.list<FileWithDetails>&,std.string&,std.set<std.string>&,bool,PathMatch&,bool)"
111669149769,METHOD,cli/filelister.cpp:<global>,TYPE_DECL,"std::string FileLister::recursiveAddFiles(std::list<FileWithDetails> &files, const std::string &path, const std::set<std::string> &extra, const PathMatch& ignored, bool debug)
{
    return addFiles(files, path, extra, true, ignored, debug);
}",1,1,cli/filelister.cpp,"FileLister.recursiveAddFiles:string(std.list<FileWithDetails>&,std.string&,std.set<std.string>&,PathMatch&,bool)",<empty>,,false,305,308,recursiveAddFiles,,,1,"string(std.list<FileWithDetails>&,std.string&,std.set<std.string>&,PathMatch&,bool)"
111669149770,METHOD,cli/filelister.h:<global>,TYPE_DECL,<global>,1,29,cli/filelister.h,cli/filelister.h:<global>,<empty>,,false,1,67,<global>,,,1,
111669149771,METHOD,cli/main.cpp:<global>,TYPE_DECL,"int main(int argc, char* argv[])
{
    // MS Visual C++ memory leak debug tracing
#if defined(_MSC_VER) && defined(_DEBUG)
    _CrtSetDbgFlag(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) | _CRTDBG_LEAK_CHECK_DF);
#endif

    CppCheckExecutor exec;

// *INDENT-OFF*
#ifdef NDEBUG
    try {
#endif
        return exec.check(argc, argv);
#ifdef NDEBUG
    } catch (const InternalError& e) {
        std::cout << e.errorMessage << std::endl;
    } catch (const std::exception& error) {
        std::cout << error.what() << std::endl;
    } catch (...) {
        std::cout << ""Unknown exception"" << std::endl;
    }
    return EXIT_FAILURE;
#endif
// *INDENT-ON*
}",1,1,cli/main.cpp,"main:int(int,char[]*)",<empty>,,false,77,102,main,,,1,"int(int,char[]*)"
111669149772,METHOD,cli/main.cpp:<global>,TYPE_DECL,<global>,1,1,cli/main.cpp,cli/main.cpp:<global>,<empty>,,false,1,102,<global>,,,1,
111669149773,METHOD,cli/precompiled.h:<global>,TYPE_DECL,<global>,1,27,cli/precompiled.h,cli/precompiled.h:<global>,<empty>,,false,1,25,<global>,,,1,
111669149774,METHOD,cli/processexecutor.cpp:<global>,TYPE_DECL,<global>,1,1,cli/processexecutor.cpp,cli/processexecutor.cpp:<global>,<empty>,,false,1,464,<global>,,,1,
111669149775,METHOD,cli/processexecutor.cpp:<global>,TYPE_DECL,"ProcessExecutor::ProcessExecutor(const std::list<FileWithDetails> &files, const std::list<FileSettings>& fileSettings, const Settings &settings, Suppressions &suppressions, ErrorLogger &errorLogger, CppCheck::ExecuteCmdFn executeCommand)
    : Executor(files, fileSettings, settings, suppressions, errorLogger)
    , mExecuteCommand(std::move(executeCommand))
{
    assert(mSettings.jobs > 1);
}",1,1,cli/processexecutor.cpp,"ProcessExecutor.ProcessExecutor:ANY(std.list<FileWithDetails>&,std.list<FileSettings>&,Settings&,Suppressions&,ErrorLogger&,CppCheck.ExecuteCmdFn)",<empty>,,false,71,76,ProcessExecutor,,,1,"ProcessExecutor.ProcessExecutor:ANY(std.list<FileWithDetails>&,std.list<FileSettings>&,Settings&,Suppressions&,ErrorLogger&,CppCheck.ExecuteCmdFn)(std.list<FileWithDetails>&,std.list<FileSettings>&,Settings&,Suppressions&,ErrorLogger&,CppCheck.ExecuteCmdFn)"
111669149776,METHOD,<empty>,<empty>,<empty>,9,,cli/processexecutor.cpp,PipeWriter.PipeSignal:<clinit>,<empty>,,false,81,,<clinit>,,,5,
111669149777,METHOD,PipeWriter,TYPE_DECL,explicit PipeWriter(int pipe) : mWpipe(pipe) {},9,55,cli/processexecutor.cpp,PipeWriter.PipeWriter:ANY(int),<empty>,,false,83,83,PipeWriter,,,2,PipeWriter.PipeWriter:ANY(int)(int)
111669149778,METHOD,PipeWriter,TYPE_DECL,"void reportOut(const std::string &outmsg, Color c) override {
            writeToPipe(REPORT_OUT, static_cast<char>(c) + outmsg);
        }",9,9,cli/processexecutor.cpp,"PipeWriter.reportOut:void(std.string&,Color)",<empty>,,false,85,87,reportOut,,,3,"void(std.string&,Color)"
111669149779,METHOD,PipeWriter,TYPE_DECL,"void reportErr(const ErrorMessage &msg) override {
            writeToPipe(REPORT_ERROR, msg.serialize());
        }",9,9,cli/processexecutor.cpp,PipeWriter.reportErr:void(ErrorMessage&),<empty>,,false,89,91,reportErr,,,4,void(ErrorMessage&)
111669149780,METHOD,PipeWriter,TYPE_DECL,"void writeSuppr(const SuppressionList &supprs) const {
            for (const auto& suppr : supprs.getSuppressions())
            {
                if (!suppr.isInline)
                    continue;

                writeToPipe(REPORT_SUPPR_INLINE, suppressionToString(suppr));
            }
            // TODO: update suppression states?
        }",9,9,cli/processexecutor.cpp,PipeWriter.writeSuppr<const>:void(SuppressionList&),<empty>,,false,93,102,writeSuppr,,,5,void(SuppressionList&)
111669149781,METHOD,PipeWriter,TYPE_DECL,"void writeEnd(const std::string& str) const {
            writeToPipe(CHILD_END, str);
        }",9,9,cli/processexecutor.cpp,PipeWriter.writeEnd<const>:void(std.string&),<empty>,,false,104,106,writeEnd,,,6,void(std.string&)
111669149782,METHOD,PipeWriter,TYPE_DECL,"static std::string suppressionToString(const SuppressionList::Suppression &suppr)
        {
            std::string suppr_str = suppr.toString();
            suppr_str += "";"";
            suppr_str += suppr.checked ? ""1"" : ""0"";
            suppr_str += "";"";
            suppr_str += suppr.matched ? ""1"" : ""0"";
            return suppr_str;
        }",9,9,cli/processexecutor.cpp,PipeWriter.suppressionToString:string(SuppressionList.Suppression&),<empty>,,false,109,117,suppressionToString,,,7,string(SuppressionList.Suppression&)
111669149783,METHOD,PipeWriter,TYPE_DECL,"void writeToPipeInternal(PipeSignal type, const void* data, std::size_t to_write) const
        {
            const ssize_t bytes_written = write(mWpipe, data, to_write);
            if (bytes_written <= 0) {
                const int err = errno;
                std::cerr << ""#### ThreadExecutor::writeToPipeInternal() error for type "" << type << "": "" << std::strerror(err) << std::endl;
                std::exit(EXIT_FAILURE);
            }
            // TODO: write until everything is written
            if (bytes_written != to_write) {
                std::cerr << ""#### ThreadExecutor::writeToPipeInternal() error for type "" << type << "": insufficient data written (expected: "" << to_write << "" / got: "" << bytes_written << "")"" << std::endl;
                std::exit(EXIT_FAILURE);
            }
        }",9,9,cli/processexecutor.cpp,"PipeWriter.writeToPipeInternal<const>:void(PipeWriter.PipeSignal,void*,std.size_t)",<empty>,,false,120,133,writeToPipeInternal,,,8,"void(PipeWriter.PipeSignal,void*,std.size_t)"
111669149784,METHOD,PipeWriter,TYPE_DECL,"void writeToPipe(PipeSignal type, const std::string &data) const
        {
            {
                const auto t = static_cast<char>(type);
                writeToPipeInternal(type, &t, 1);
            }

            const auto len = static_cast<unsigned int>(data.length());
            {
                static constexpr std::size_t l_size = sizeof(unsigned int);
                writeToPipeInternal(type, &len, l_size);
            }

            if (len > 0) // TODO: unexpected - write a warning?
                writeToPipeInternal(type, data.c_str(), len);
        }",9,9,cli/processexecutor.cpp,"PipeWriter.writeToPipe<const>:void(PipeWriter.PipeSignal,std.string&)",<empty>,,false,135,150,writeToPipe,,,9,"void(PipeWriter.PipeSignal,std.string&)"
111669149785,METHOD,cli/processexecutor.cpp:<global>,TYPE_DECL,"bool ProcessExecutor::handleRead(int rpipe, unsigned int &result, const std::string& filename)
{
    std::size_t bytes_to_read;
    ssize_t bytes_read;

    char type = 0;
    bytes_to_read = sizeof(char);
    bytes_read = read(rpipe, &type, bytes_to_read);
    if (bytes_read <= 0) {
        if (errno == EAGAIN)
            return true;

        // TODO: log details about failure

        // need to increment so a missing pipe (i.e. premature exit of forked process) results in an error exitcode
        ++result;
        return false;
    }
    if (bytes_read != bytes_to_read) {
        std::cerr << ""#### ThreadExecutor::handleRead("" << filename << "") error (type): insufficient data read (expected: "" << bytes_to_read << "" / got: "" << bytes_read << "")"" << std::endl;
        std::exit(EXIT_FAILURE);
    }

    if (type != PipeWriter::REPORT_OUT &&
        type != PipeWriter::REPORT_ERROR &&
        type != PipeWriter::REPORT_SUPPR_INLINE &&
        type != PipeWriter::CHILD_END) {
    ...",1,1,cli/processexecutor.cpp,"ProcessExecutor.handleRead:bool(int,unsigned int&,std.string&)",<empty>,,false,156,262,handleRead,,,1,"bool(int,unsigned int&,std.string&)"
111669149786,METHOD,cli/processexecutor.cpp:<global>,TYPE_DECL,"bool ProcessExecutor::checkLoadAverage(size_t nchildren)
{
#if defined(__QNX__) || defined(__HAIKU__)  // getloadavg() is unsupported on Qnx, Haiku.
    (void)nchildren;
    return true;
#else
    if (!nchildren || !mSettings.loadAverage) {
        return true;
    }

    double sample(0);
    if (getloadavg(&sample, 1) != 1) {
        // disable load average checking on getloadavg error
        return true;
    }
    if (sample < mSettings.loadAverage) {
        return true;
    }
    return false;
#endif
}",1,1,cli/processexecutor.cpp,ProcessExecutor.checkLoadAverage:bool(size_t),<empty>,,false,264,284,checkLoadAverage,,,1,bool(size_t)
111669149787,METHOD,<empty>,<empty>,"[](std::size_t v, const FileWithDetails& p) {
        return v + p.size();
    }",103,5,cli/processexecutor.cpp,"cli/processexecutor.cpp:<global>.ProcessExecutor.check.<lambda>0:ANY(std.size_t,FileWithDetails&)",<empty>,,false,291,293,<lambda>0,,,1,"ANY(std.size_t,FileWithDetails&)"
111669149788,METHOD,<empty>,<empty>,"[&name](const FileWithDetails& entry) {
                                    return entry.path() == name;
                                }",94,33,cli/processexecutor.cpp,cli/processexecutor.cpp:<global>.ProcessExecutor.check.<lambda>1:bool(FileWithDetails&),<empty>,,false,389,391,<lambda>1,,,1,bool(FileWithDetails&)
111669149789,METHOD,cli/processexecutor.cpp:<global>,TYPE_DECL,"unsigned int ProcessExecutor::check()
{
    unsigned int fileCount = 0;
    unsigned int result = 0;

    const std::size_t totalfilesize = std::accumulate(mFiles.cbegin(), mFiles.cend(), std::size_t(0), [](std::size_t v, const FileWithDetails& p) {
        return v + p.size();
    });

    std::list<int> rpipes;
    std::map<pid_t, std::string> childFile;
    std::map<int, std::string> pipeFile;
    std::size_t processedsize = 0;
    auto iFile = mFiles.cbegin();
    auto iFileSettings = mFileSettings.cbegin();
    for (;;) {
        // Start a new child
        const size_t nchildren = childFile.size();
        if ((iFile != mFiles.cend() || iFileSettings != mFileSettings.cend()) && nchildren < mSettings.jobs && checkLoadAverage(nchildren)) {
            int pipes[2];
            if (pipe(pipes) == -1) {
                std::cerr << ""#### ThreadExecutor::check, pipe() failed: ""<< std::strerror(errno) << std::endl;
                std::exit(EXIT_FAILURE);
            }

           ...",1,1,cli/processexecutor.cpp,ProcessExecutor.check:unsigned int(),<empty>,,false,286,447,check,,,1,unsigned int()
111669149790,METHOD,cli/processexecutor.cpp:<global>,TYPE_DECL,"void ProcessExecutor::reportInternalChildErr(const std::string &childname, const std::string &msg)
{
    std::list<ErrorMessage::FileLocation> locations;
    locations.emplace_back(childname, 0, 0);
    const ErrorMessage errmsg(std::move(locations),
                              """",
                              Severity::error,
                              ""Internal error: "" + msg,
                              ""cppcheckError"",
                              Certainty::normal);

    if (!mSuppressions.nomsg.isSuppressed(errmsg, {}))
        mErrorLogger.reportErr(errmsg);
}",1,1,cli/processexecutor.cpp,"ProcessExecutor.reportInternalChildErr:void(std.string&,std.string&)",<empty>,,false,449,462,reportInternalChildErr,,,1,"void(std.string&,std.string&)"
111669149791,METHOD,cli/processexecutor.h:<global>,TYPE_DECL,<global>,1,1,cli/processexecutor.h,cli/processexecutor.h:<global>,<empty>,,false,1,75,<global>,,,1,
111669149792,METHOD,cli/sehwrapper.cpp:<global>,TYPE_DECL,"void set_seh_output(FILE* f)
{
    sehOutput = f;
}",1,1,cli/sehwrapper.cpp,set_seh_output:void(FILE*),<empty>,,false,31,34,set_seh_output,,,1,void(FILE*)
111669149793,METHOD,cli/sehwrapper.cpp:<global>,TYPE_DECL,<global>,1,1,cli/sehwrapper.cpp,cli/sehwrapper.cpp:<global>,<empty>,,false,1,270,<global>,,,1,
111669149794,METHOD,cli/sehwrapper.h:<global>,TYPE_DECL,<global>,1,1,cli/sehwrapper.h,cli/sehwrapper.h:<global>,<empty>,,false,1,51,<global>,,,1,
111669149795,METHOD,cli/signalhandler.cpp:<global>,TYPE_DECL,"static bool IsAddressOnStack(const void* ptr)
{
    if (nullptr==ptr)
        return false;
    char a;
    if (bStackBelowHeap)
        return ptr < &a;
    return ptr > &a;
}",1,1,cli/signalhandler.cpp,IsAddressOnStack:bool(void*),<empty>,,false,72,80,IsAddressOnStack,,,1,bool(void*)
111669149796,METHOD,cli/signalhandler.cpp:<global>,TYPE_DECL,<global>,1,1,cli/signalhandler.cpp,cli/signalhandler.cpp:<global>,<empty>,,false,1,334,<global>,,,1,
111669149797,METHOD,cli/signalhandler.cpp:<global>,TYPE_DECL,"static void CppcheckSignalHandler(int signo, siginfo_t * info, void * context)
{
    int type = -1;
    pid_t killid;
    // TODO: separate these two defines
#if defined(__linux__) && defined(REG_ERR)
    const auto* const uc = reinterpret_cast<const ucontext_t*>(context);
    killid = (pid_t) syscall(SYS_gettid);
    if (uc) {
        type = (int)uc->uc_mcontext.gregs[REG_ERR] & 2;
    }
#else
    (void)context;
    killid = getpid();
#endif

    const auto it = utils::as_const(listofsignals).find(signo);
    const char * const signame = (it==listofsignals.end()) ? ""unknown"" : it->second.c_str();
    bool unexpectedSignal=true; // unexpected indicates program failure
    bool terminate=true; // exit process/thread
    const bool isAddressOnStack = IsAddressOnStack(info->si_addr);
    FILE * const output = signalOutput;
    switch (signo) {
    case SIGABRT:
        fputs(""Internal error: cppcheck received signal "", output);
        fputs(signame, output);
        fputs(
#ifdef NDEB...",1,1,cli/signalhandler.cpp,"CppcheckSignalHandler:void(int,siginfo_t*,void*)",<empty>,,false,112,301,CppcheckSignalHandler,,,1,"void(int,siginfo_t*,void*)"
111669149798,METHOD,cli/signalhandler.cpp:<global>,TYPE_DECL,"void register_signal_handler(FILE * const output)
{
    signalOutput = output;

    // determine stack vs. heap
    char stackVariable;
    char *heapVariable=static_cast<char*>(malloc(1));
    bStackBelowHeap = &stackVariable < heapVariable;
    free(heapVariable);

    // set up alternative stack for signal handler
    stack_t segv_stack;
    segv_stack.ss_sp = mytstack;
    segv_stack.ss_flags = 0;
    segv_stack.ss_size = MYSTACKSIZE;
    if (sigaltstack(&segv_stack, nullptr) != 0) {
        // TODO: log errno
        fputs(""could not set alternate signal stack context.\\n"", output);
        std::exit(EXIT_FAILURE);
    }

    // install signal handler
    struct sigaction act;
    memset(&act, 0, sizeof(act));
    act.sa_flags=SA_SIGINFO|SA_ONSTACK;
    act.sa_sigaction=CppcheckSignalHandler;
    for (auto sig=listofsignals.cbegin(); sig!=listofsignals.cend(); ++sig) {
        sigaction(sig->first, &act, nullptr);
    }
}",1,1,cli/signalhandler.cpp,register_signal_handler:void(FILE*),<empty>,,false,303,332,register_signal_handler,,,1,void(FILE*)
111669149799,METHOD,cli/signalhandler.h:<global>,TYPE_DECL,<global>,1,1,cli/signalhandler.h,cli/signalhandler.h:<global>,<empty>,,false,1,32,<global>,,,1,
111669149800,METHOD,cli/singleexecutor.cpp:<global>,TYPE_DECL,"SingleExecutor::SingleExecutor(CppCheck &cppcheck, const std::list<FileWithDetails> &files, const std::list<FileSettings>& fileSettings, const Settings &settings, Suppressions &suppressions, ErrorLogger &errorLogger)
    : Executor(files, fileSettings, settings, suppressions, errorLogger)
    , mCppcheck(cppcheck)
{
    assert(mSettings.jobs == 1);
}",1,1,cli/singleexecutor.cpp,"SingleExecutor.SingleExecutor:ANY(CppCheck&,std.list<FileWithDetails>&,std.list<FileSettings>&,Settings&,Suppressions&,ErrorLogger&)",<empty>,,false,33,38,SingleExecutor,,,1,"SingleExecutor.SingleExecutor:ANY(CppCheck&,std.list<FileWithDetails>&,std.list<FileSettings>&,Settings&,Suppressions&,ErrorLogger&)(CppCheck&,std.list<FileWithDetails>&,std.list<FileSettings>&,Settings&,Suppressions&,ErrorLogger&)"
111669149801,METHOD,cli/singleexecutor.cpp:<global>,TYPE_DECL,<global>,1,1,cli/singleexecutor.cpp,cli/singleexecutor.cpp:<global>,<empty>,,false,1,79,<global>,,,1,
111669149802,METHOD,<empty>,<empty>,"[](std::size_t v, const FileWithDetails& f) {
        return v + f.size();
    }",103,5,cli/singleexecutor.cpp,"cli/singleexecutor.cpp:<global>.SingleExecutor.check.<lambda>0:ANY(std.size_t,FileWithDetails&)",<empty>,,false,45,47,<lambda>0,,,1,"ANY(std.size_t,FileWithDetails&)"
111669149803,METHOD,cli/singleexecutor.cpp:<global>,TYPE_DECL,"unsigned int SingleExecutor::check()
{
    unsigned int result = 0;

    const std::size_t totalfilesize = std::accumulate(mFiles.cbegin(), mFiles.cend(), std::size_t(0), [](std::size_t v, const FileWithDetails& f) {
        return v + f.size();
    });

    std::size_t processedsize = 0;
    unsigned int c = 0;

    for (auto i = mFiles.cbegin(); i != mFiles.cend(); ++i) {
        result += mCppcheck.check(*i);
        processedsize += i->size();
        ++c;
        if (!mSettings.quiet)
            reportStatus(c, mFiles.size(), processedsize, totalfilesize);
        // TODO: call analyseClangTidy()?
    }

    // filesettings
    // check all files of the project
    for (const FileSettings &fs : mFileSettings) {
        result += mCppcheck.check(fs);
        ++c;
        if (!mSettings.quiet)
            reportStatus(c, mFileSettings.size(), c, mFileSettings.size());
        if (mSettings.clangTidy)
            mCppcheck.analyseClangTidy(fs);
    }

    if (mCppcheck.analyseWho...",1,1,cli/singleexecutor.cpp,SingleExecutor.check:unsigned int(),<empty>,,false,41,79,check,,,1,unsigned int()
111669149804,METHOD,cli/singleexecutor.h:<global>,TYPE_DECL,<global>,1,1,cli/singleexecutor.h,cli/singleexecutor.h:<global>,<empty>,,false,1,46,<global>,,,1,
111669149805,METHOD,cli/stacktrace.cpp:<global>,TYPE_DECL,"void print_stacktrace(FILE* output, int start_idx, bool demangling, int maxdepth, bool omit_above_own)
{
    // 32 vs. 64bit
#define ADDRESSDISPLAYLENGTH ((sizeof(long)==8)?12:8)
    void *callstackArray[32]= {nullptr}; // the less resources the better...
    const int currentdepth = backtrace(callstackArray, (int)getArrayLength(callstackArray));
    // set offset to 1 to omit the printing function itself
    int offset=start_idx+1; // some entries on top are within our own exception handling code or libc
    if (maxdepth<0)
        maxdepth=currentdepth-offset;
    else
        maxdepth = std::min(maxdepth, currentdepth);

    char **symbolStringList = backtrace_symbols(callstackArray, currentdepth);
    if (!symbolStringList) {
        fputs(""Callstack could not be obtained\\n"", output);
        return;
    }

    fputs(""Callstack:\\n"", output);
    bool own_code = false;
    char demangle_buffer[2048]= {0};
    for (int i = offset; i < maxdepth; ++i) {
        const char * const sy...",1,1,cli/stacktrace.cpp,"print_stacktrace:void(FILE*,int,bool,int,bool)",<empty>,,false,31,100,print_stacktrace,,,1,"void(FILE*,int,bool,int,bool)"
111669149806,METHOD,cli/stacktrace.cpp:<global>,TYPE_DECL,<global>,1,1,cli/stacktrace.cpp,cli/stacktrace.cpp:<global>,<empty>,,false,1,102,<global>,,,1,
111669149807,METHOD,cli/stacktrace.h:<global>,TYPE_DECL,<global>,1,1,cli/stacktrace.h,cli/stacktrace.h:<global>,<empty>,,false,1,44,<global>,,,1,
111669149808,METHOD,cli/threadexecutor.cpp:<global>,TYPE_DECL,"ThreadExecutor::ThreadExecutor(const std::list<FileWithDetails> &files, const std::list<FileSettings>& fileSettings, const Settings &settings, Suppressions &suppressions, ErrorLogger &errorLogger, CppCheck::ExecuteCmdFn executeCommand)
    : Executor(files, fileSettings, settings, suppressions, errorLogger)
    , mExecuteCommand(std::move(executeCommand))
{
    assert(mSettings.jobs > 1);
}",1,1,cli/threadexecutor.cpp,"ThreadExecutor.ThreadExecutor:ANY(std.list<FileWithDetails>&,std.list<FileSettings>&,Settings&,Suppressions&,ErrorLogger&,CppCheck.ExecuteCmdFn)",<empty>,,false,41,46,ThreadExecutor,,,1,"ThreadExecutor.ThreadExecutor:ANY(std.list<FileWithDetails>&,std.list<FileSettings>&,Settings&,Suppressions&,ErrorLogger&,CppCheck.ExecuteCmdFn)(std.list<FileWithDetails>&,std.list<FileSettings>&,Settings&,Suppressions&,ErrorLogger&,CppCheck.ExecuteCmdFn)"
111669149809,METHOD,cli/threadexecutor.cpp:<global>,TYPE_DECL,<global>,1,1,cli/threadexecutor.cpp,cli/threadexecutor.cpp:<global>,<empty>,,false,1,219,<global>,,,1,
111669149810,METHOD,SyncLogForwarder,TYPE_DECL,"explicit SyncLogForwarder(ThreadExecutor &threadExecutor, ErrorLogger &errorLogger)
        : mThreadExecutor(threadExecutor), mErrorLogger(errorLogger) {}",5,71,cli/threadexecutor.cpp,"SyncLogForwarder.SyncLogForwarder:ANY(ThreadExecutor&,ErrorLogger&)",<empty>,,false,51,52,SyncLogForwarder,,,1,"SyncLogForwarder.SyncLogForwarder:ANY(ThreadExecutor&,ErrorLogger&)(ThreadExecutor&,ErrorLogger&)"
111669149811,METHOD,SyncLogForwarder,TYPE_DECL,"void reportOut(const std::string &outmsg, Color c) override
    {
        std::lock_guard<std::mutex> lg(mReportSync);

        mErrorLogger.reportOut(outmsg, c);
    }",5,5,cli/threadexecutor.cpp,"SyncLogForwarder.reportOut:void(std.string&,Color)",<empty>,,false,54,59,reportOut,,,2,"void(std.string&,Color)"
111669149812,METHOD,SyncLogForwarder,TYPE_DECL,"void reportErr(const ErrorMessage &msg) override {
        if (!mThreadExecutor.hasToLog(msg))
            return;

        std::lock_guard<std::mutex> lg(mReportSync);
        mErrorLogger.reportErr(msg);
    }",5,5,cli/threadexecutor.cpp,SyncLogForwarder.reportErr:void(ErrorMessage&),<empty>,,false,61,67,reportErr,,,3,void(ErrorMessage&)
111669149813,METHOD,SyncLogForwarder,TYPE_DECL,"void reportStatus(std::size_t fileindex, std::size_t filecount, std::size_t sizedone, std::size_t sizetotal) {
        std::lock_guard<std::mutex> lg(mReportSync);
        mThreadExecutor.reportStatus(fileindex, filecount, sizedone, sizetotal);
    }",5,5,cli/threadexecutor.cpp,"SyncLogForwarder.reportStatus:void(std.size_t,std.size_t,std.size_t,std.size_t)",<empty>,,false,69,72,reportStatus,,,4,"void(std.size_t,std.size_t,std.size_t,std.size_t)"
111669149814,METHOD,<empty>,<empty>,"[](std::size_t v, const FileWithDetails& p) {
            return v + p.size();
        }",90,9,cli/threadexecutor.cpp,"cli/threadexecutor.cpp:<global>.ThreadData.ThreadData:ANY(ThreadExecutor&,ErrorLogger&,Settings&,Suppressions&,std.list<FileWithDetails>&,std.list<FileSettings>&,CppCheck.ExecuteCmdFn).<lambda>0:ANY(std.size_t,FileWithDetails&)",<empty>,,false,90,92,<lambda>0,,,1,"ANY(std.size_t,FileWithDetails&)"
111669149815,METHOD,ThreadData,TYPE_DECL,"ThreadData(ThreadExecutor &threadExecutor, ErrorLogger &errorLogger, const Settings &settings, Suppressions& supprs, const std::list<FileWithDetails> &files, const std::list<FileSettings> &fileSettings, CppCheck::ExecuteCmdFn executeCommand)
        : mFiles(files), mFileSettings(fileSettings), mSettings(settings), mSuppressions(supprs), mExecuteCommand(std::move(executeCommand)), logForwarder(threadExecutor, errorLogger)
    {
        mItNextFile = mFiles.begin();
        mItNextFileSettings = mFileSettings.begin();

        mTotalFiles = mFiles.size() + mFileSettings.size();
        mTotalFileSize = std::accumulate(mFiles.cbegin(), mFiles.cend(), std::size_t(0), [](std::size_t v, const FileWithDetails& p) {
            return v + p.size();
        });
    }",5,5,cli/threadexecutor.cpp,"ThreadData.ThreadData:ANY(ThreadExecutor&,ErrorLogger&,Settings&,Suppressions&,std.list<FileWithDetails>&,std.list<FileSettings>&,CppCheck.ExecuteCmdFn)",<empty>,,false,83,93,ThreadData,,,1,"ThreadData.ThreadData:ANY(ThreadExecutor&,ErrorLogger&,Settings&,Suppressions&,std.list<FileWithDetails>&,std.list<FileSettings>&,CppCheck.ExecuteCmdFn)(ThreadExecutor&,ErrorLogger&,Settings&,Suppressions&,std.list<FileWithDetails>&,std.list<FileSettings>&,CppCheck.ExecuteCmdFn)"
111669149816,METHOD,ThreadData,TYPE_DECL,"bool next(const FileWithDetails *&file, const FileSettings *&fs, std::size_t &fileSize) {
        std::lock_guard<std::mutex> l(mFileSync);
        if (mItNextFile != mFiles.end()) {
            file = &(*mItNextFile);
            fs = nullptr;
            fileSize = mItNextFile->size();
            ++mItNextFile;
            return true;
        }
        if (mItNextFileSettings != mFileSettings.end()) {
            file = nullptr;
            fs = &(*mItNextFileSettings);
            fileSize = 0;
            ++mItNextFileSettings;
            return true;
        }

        return false;
    }",5,5,cli/threadexecutor.cpp,"ThreadData.next:bool(FileWithDetails*&,FileSettings*&,std.size_t&)",<empty>,,false,95,113,next,,,2,"bool(FileWithDetails*&,FileSettings*&,std.size_t&)"
111669149817,METHOD,ThreadData,TYPE_DECL,"unsigned int check(ErrorLogger &errorLogger, const FileWithDetails *file, const FileSettings *fs) const {
        CppCheck fileChecker(mSettings, mSuppressions, errorLogger, false, mExecuteCommand);

        unsigned int result;
        if (fs) {
            // file settings..
            result = fileChecker.check(*fs);
            if (mSettings.clangTidy)
                fileChecker.analyseClangTidy(*fs);
        } else {
            // Read file from a file
            result = fileChecker.check(*file);
            // TODO: call analyseClangTidy()?
        }
        for (const auto& suppr : mSuppressions.nomsg.getSuppressions()) {
            // need to transfer all inline suppressions because these are used later on
            if (suppr.isInline) {
                const std::string err = mSuppressions.nomsg.addSuppression(suppr);
                if (!err.empty()) {
                    // TODO: only update state if it doesn't exist - otherwise propagate error
                   ...",5,5,cli/threadexecutor.cpp,"ThreadData.check<const>:unsigned int(ErrorLogger&,FileWithDetails*,FileSettings*)",<empty>,,false,115,147,check,,,3,"unsigned int(ErrorLogger&,FileWithDetails*,FileSettings*)"
111669149818,METHOD,ThreadData,TYPE_DECL,"void status(std::size_t fileSize) {
        std::lock_guard<std::mutex> l(mFileSync);
        mProcessedSize += fileSize;
        mProcessedFiles++;
        if (!mSettings.quiet)
            logForwarder.reportStatus(mProcessedFiles, mTotalFiles, mProcessedSize, mTotalFileSize);
    }",5,5,cli/threadexecutor.cpp,ThreadData.status:void(std.size_t),<empty>,,false,149,155,status,,,4,void(std.size_t)
111669149819,METHOD,<empty>,<empty>,<empty>,1,,cli/threadexecutor.cpp,ThreadData.<clinit>,<empty>,,false,80,,<clinit>,,,18,
111669149820,METHOD,<empty>,<empty>,"[](unsigned int v, std::future<unsigned int>& f) {
        return v + f.get();
    }",91,5,cli/threadexecutor.cpp,"cli/threadexecutor.cpp:<global>.ThreadExecutor.check.<lambda>1:ANY(unsigned int,std.future<unsignedint>&)",<empty>,,false,211,213,<lambda>1,,,1,"ANY(unsigned int,std.future<unsignedint>&)"
111669149821,METHOD,cli/threadexecutor.cpp:<global>,TYPE_DECL,"unsigned int ThreadExecutor::check()
{
    std::vector<std::future<unsigned int>> threadFutures;
    threadFutures.reserve(mSettings.jobs);

    ThreadData data(*this, mErrorLogger, mSettings, mSuppressions, mFiles, mFileSettings, mExecuteCommand);

    for (unsigned int i = 0; i < mSettings.jobs; ++i) {
        try {
            threadFutures.emplace_back(std::async(std::launch::async, &threadProc, &data));
        }
        catch (const std::system_error &e) {
            std::cerr << ""#### ThreadExecutor::check exception :"" << e.what() << std::endl;
            exit(EXIT_FAILURE);
        }
    }

    unsigned int result = std::accumulate(threadFutures.begin(), threadFutures.end(), 0U, [](unsigned int v, std::future<unsigned int>& f) {
        return v + f.get();
    });

    if (mSettings.showtime == SHOWTIME_MODES::SHOWTIME_SUMMARY || mSettings.showtime == SHOWTIME_MODES::SHOWTIME_TOP5_SUMMARY)
        CppCheck::printTimerResults(mSettings.showtime);

    return result;
}",1,1,cli/threadexecutor.cpp,ThreadExecutor.check:unsigned int(),<empty>,,false,194,219,check,,,1,unsigned int()
111669149822,METHOD,cli/threadexecutor.h:<global>,TYPE_DECL,<global>,1,1,cli/threadexecutor.h,cli/threadexecutor.h:<global>,<empty>,,false,1,55,<global>,,,1,
111669149823,METHOD,democlient/democlient.cpp:<global>,TYPE_DECL,<global>,1,1,democlient/democlient.cpp,democlient/democlient.cpp:<global>,<empty>,,false,1,140,<global>,,,1,
111669149824,METHOD,democlient/democlient.cpp:<global>,TYPE_DECL,"static void unencode(const char *src, char *dest)
{
    for (; *src; src++, dest++) {
        if (*src == '+')
            *dest = ' ';
        else if (*src == '%') {
            unsigned int code;
            if (std::sscanf(src+1, ""%2x"", &code) != 1)
                code = '?';
            *dest = code;
            src += 2;
        } else
            *dest = *src;
    }
    *dest = '\\0';
}",1,1,democlient/democlient.cpp,"unencode:void(char*,char*)",<empty>,,false,38,53,unencode,,,1,"void(char*,char*)"
111669149825,METHOD,CppcheckExecutor,TYPE_DECL,"CppcheckExecutor(const Settings& settings)
        : stoptime(std::time(nullptr)+2U)
        , cppcheck(settings, supprs, *this, false, nullptr)
    {}",5,6,democlient/democlient.cpp,CppcheckExecutor.CppcheckExecutor:ANY(Settings&),<empty>,,false,64,67,CppcheckExecutor,,,4,CppcheckExecutor.CppcheckExecutor:ANY(Settings&)(Settings&)
111669149826,METHOD,CppcheckExecutor,TYPE_DECL,"void run(const char code[]) {
        cppcheck.check(FileWithDetails(""test.cpp""), code);
    }",5,5,democlient/democlient.cpp,CppcheckExecutor.run:void(char[]),<empty>,,false,69,71,run,,,5,void(char[])
111669149827,METHOD,CppcheckExecutor,TYPE_DECL,"void reportOut(const std::string & /*outmsg*/, Color /*c*/) override {}",5,75,democlient/democlient.cpp,"CppcheckExecutor.reportOut:void(std.string&,Color)",<empty>,,false,73,73,reportOut,,,6,"void(std.string&,Color)"
111669149828,METHOD,CppcheckExecutor,TYPE_DECL,"void reportErr(const ErrorMessage &msg) override {
        const std::string s = msg.toString(true);

        std::cout << s << std::endl;

        if (logfile != nullptr)
            std::fprintf(logfile, ""%s\\n"", s.c_str());
    }",5,5,democlient/democlient.cpp,CppcheckExecutor.reportErr:void(ErrorMessage&),<empty>,,false,74,81,reportErr,,,7,void(ErrorMessage&)
111669149829,METHOD,CppcheckExecutor,TYPE_DECL,"void reportProgress(const std::string& /*filename*/,
                        const char /*stage*/[],
                        const std::size_t /*value*/) override {
        if (std::time(nullptr) >= stoptime) {
            std::cout << ""Time to analyse the code exceeded 2 seconds. Terminating.\\n\\n"";
            Settings::terminate();
        }
    }",5,5,democlient/democlient.cpp,"CppcheckExecutor.reportProgress:void(std.string&,char[],std.size_t)",<empty>,,false,83,90,reportProgress,,,8,"void(std.string&,char[],std.size_t)"
111669149830,METHOD,democlient/democlient.cpp:<global>,TYPE_DECL,"int main()
{
    std::cout << ""Content-type: text/html\\r\\n\\r\\n""
              << ""<!DOCTYPE html>\\n"";

    char data[4096] = {0};

    const char *query_string = std::getenv(""QUERY_STRING"");
    if (query_string)
        std::strncpy(data, query_string, sizeof(data)-2);

    const char *lenstr = std::getenv(""CONTENT_LENGTH"");
    if (lenstr) {
        int len = std::min(1 + std::atoi(lenstr), (int)(sizeof(data) - 2));
        std::fgets(data, len, stdin);
    }

    if (data[4000] != '\\0') {
        std::cout << ""<html><body>For performance reasons the code must be shorter than 1000 chars.</body></html>"";
        return EXIT_SUCCESS;
    }

    const char *pdata = data;
    if (std::strncmp(pdata, ""code="", 5)==0)
        pdata += 5;

    char code[4096] = {0};
    unencode(pdata, code);

    logfile = std::fopen(""democlient.log"", ""at"");
    if (logfile != nullptr)
        std::fprintf(logfile, ""===========================================================\\n%s\\n"", code);

    std::cout...",1,41,democlient/democlient.cpp,main:int(),<empty>,,false,94,140,main,,,1,int()
111669149831,METHOD,externals/picojson/picojson.h:<global>,TYPE_DECL,<global>,1,4,externals/picojson/picojson.h,externals/picojson/picojson.h:<global>,<empty>,,false,1,1200,<global>,,,1,
111669149832,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static bool isHex(const std::string &s)
{
    return s.size()>2 && (s.compare(0,2,""0x"")==0 || s.compare(0,2,""0X"")==0);
}",1,1,externals/simplecpp/simplecpp.cpp,isHex:bool(std.string&),<empty>,,false,60,63,isHex,,,1,bool(std.string&)
111669149833,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,<global>,1,1,externals/simplecpp/simplecpp.cpp,externals/simplecpp/simplecpp.cpp:<global>,<empty>,,false,1,3901,<global>,,,1,
111669149834,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static bool isOct(const std::string &s)
{
    return s.size()>1 && (s[0]=='0') && (s[1] >= '0') && (s[1] < '8');
}",1,1,externals/simplecpp/simplecpp.cpp,isOct:bool(std.string&),<empty>,,false,65,68,isOct,,,1,bool(std.string&)
111669149835,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static bool isStringLiteral_(const std::string &s)
{
    return s.size() > 1 && (s[0]=='\\""') && (*s.rbegin()=='\\""');
}",1,1,externals/simplecpp/simplecpp.cpp,isStringLiteral_:bool(std.string&),<empty>,,false,71,74,isStringLiteral_,,,1,bool(std.string&)
111669149836,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static bool isCharLiteral_(const std::string &s)
{
    // char literal patterns can include 'a', '\\t', '\\000', '\\xff', 'abcd', and maybe ''
    // This only checks for the surrounding '' but doesn't parse the content.
    return s.size() > 1 && (s[0]=='\\'') && (*s.rbegin()=='\\'');
}",1,1,externals/simplecpp/simplecpp.cpp,isCharLiteral_:bool(std.string&),<empty>,,false,77,82,isCharLiteral_,,,1,bool(std.string&)
111669149837,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static std::string toString(T t)
{
    // NOLINTNEXTLINE(misc-const-correctness) - false positive
    std::ostringstream ostr;
    ostr << t;
    return ostr.str();
}",19,1,externals/simplecpp/simplecpp.cpp,toString:string(T),<empty>,,false,105,111,toString,,,1,string(T)
111669149838,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static std::string locstring(const simplecpp::Location &loc)
{
    std::ostringstream ostr;
    ostr << '[' << loc.file() << ':' << loc.line << ':' << loc.col << ']';
    return ostr.str();
}",1,1,externals/simplecpp/simplecpp.cpp,locstring:string(simplecpp.Location&),<empty>,,false,114,119,locstring,,,1,string(simplecpp.Location&)
111669149839,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static long long stringToLL(const std::string &s)
{
    long long ret;
    const bool hex = isHex(s);
    const bool oct = isOct(s);
    std::istringstream istr(hex ? s.substr(2) : oct ? s.substr(1) : s);
    if (hex)
        istr >> std::hex;
    else if (oct)
        istr >> std::oct;
    istr >> ret;
    return ret;
}",1,1,externals/simplecpp/simplecpp.cpp,stringToLL:longlong(std.string&),<empty>,,false,122,134,stringToLL,,,1,longlong(std.string&)
111669149840,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static unsigned long long stringToULL(const std::string &s)
{
    unsigned long long ret;
    const bool hex = isHex(s);
    const bool oct = isOct(s);
    std::istringstream istr(hex ? s.substr(2) : oct ? s.substr(1) : s);
    if (hex)
        istr >> std::hex;
    else if (oct)
        istr >> std::oct;
    istr >> ret;
    return ret;
}",1,1,externals/simplecpp/simplecpp.cpp,stringToULL:longlong(std.string&),<empty>,,false,136,148,stringToULL,,,1,longlong(std.string&)
111669149841,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static bool endsWith(const std::string &s, const std::string &e)
{
    return (s.size() >= e.size()) && std::equal(e.rbegin(), e.rend(), s.rbegin());
}",1,1,externals/simplecpp/simplecpp.cpp,"endsWith:bool(std.string&,std.string&)",<empty>,,false,150,153,endsWith,,,1,"bool(std.string&,std.string&)"
111669149842,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static bool sameline(const simplecpp::Token *tok1, const simplecpp::Token *tok2)
{
    return tok1 && tok2 && tok1->location.sameline(tok2->location);
}",1,1,externals/simplecpp/simplecpp.cpp,"sameline:bool(simplecpp.Token*,simplecpp.Token*)",<empty>,,false,155,158,sameline,,,1,"bool(simplecpp.Token*,simplecpp.Token*)"
111669149843,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static bool isAlternativeBinaryOp(const simplecpp::Token *tok, const std::string &alt)
{
    return (tok->name &&
            tok->str() == alt &&
            tok->previous &&
            tok->next &&
            (tok->previous->number || tok->previous->name || tok->previous->op == ')') &&
            (tok->next->number || tok->next->name || tok->next->op == '('));
}",1,1,externals/simplecpp/simplecpp.cpp,"isAlternativeBinaryOp:bool(simplecpp.Token*,std.string&)",<empty>,,false,160,168,isAlternativeBinaryOp,,,1,"bool(simplecpp.Token*,std.string&)"
111669149844,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static bool isAlternativeUnaryOp(const simplecpp::Token *tok, const std::string &alt)
{
    return ((tok->name && tok->str() == alt) &&
            (!tok->previous || tok->previous->op == '(') &&
            (tok->next && (tok->next->name || tok->next->number)));
}",1,1,externals/simplecpp/simplecpp.cpp,"isAlternativeUnaryOp:bool(simplecpp.Token*,std.string&)",<empty>,,false,170,175,isAlternativeUnaryOp,,,1,"bool(simplecpp.Token*,std.string&)"
111669149845,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static std::string replaceAll(std::string s, const std::string& from, const std::string& to)
{
    for (size_t pos = s.find(from); pos != std::string::npos; pos = s.find(from, pos + to.size()))
        s.replace(pos, from.size(), to);
    return s;
}",1,1,externals/simplecpp/simplecpp.cpp,"replaceAll:string(std.string,std.string&,std.string&)",<empty>,,false,177,182,replaceAll,,,1,"string(std.string,std.string&,std.string&)"
111669149846,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::Location::adjust(const std::string &str)
{
    if (strpbrk(str.c_str(), ""\\r\\n"") == nullptr) {
        col += str.size();
        return;
    }

    for (std::size_t i = 0U; i < str.size(); ++i) {
        col++;
        if (str[i] == '\\n' || str[i] == '\\r') {
            col = 1;
            line++;
            if (str[i] == '\\r' && (i+1)<str.size() && str[i+1]=='\\n')
                ++i;
        }
    }
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.Location.adjust:void(std.string&),<empty>,,false,186,202,adjust,,,1,void(std.string&)
111669149847,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"bool simplecpp::Token::isOneOf(const char ops[]) const
{
    return (op != '\\0') && (std::strchr(ops, op) != nullptr);
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.Token.isOneOf<const>:bool(char[]),<empty>,,false,204,207,isOneOf,,,1,bool(char[])
111669149848,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"bool simplecpp::Token::startsWithOneOf(const char c[]) const
{
    return std::strchr(c, string[0]) != nullptr;
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.Token.startsWithOneOf<const>:bool(char[]),<empty>,,false,209,212,startsWithOneOf,,,1,bool(char[])
111669149849,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"bool simplecpp::Token::endsWithOneOf(const char c[]) const
{
    return std::strchr(c, string[string.size() - 1U]) != nullptr;
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.Token.endsWithOneOf<const>:bool(char[]),<empty>,,false,214,217,endsWithOneOf,,,1,bool(char[])
111669149850,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::Token::printAll() const
{
    const Token *tok = this;
    while (tok->previous)
        tok = tok->previous;
    for (; tok; tok = tok->next) {
        if (tok->previous) {
            std::cout << (sameline(tok, tok->previous) ? ' ' : '\\n');
        }
        std::cout << tok->str();
    }
    std::cout << std::endl;
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.Token.printAll<const>:void(),<empty>,,false,219,231,printAll,,,1,void()
111669149851,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::Token::printOut() const
{
    for (const Token *tok = this; tok; tok = tok->next) {
        if (tok != this) {
            std::cout << (sameline(tok, tok->previous) ? ' ' : '\\n');
        }
        std::cout << tok->str();
    }
    std::cout << std::endl;
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.Token.printOut<const>:void(),<empty>,,false,233,242,printOut,,,1,void()
111669149852,METHOD,simplecpp.TokenList.Stream,TYPE_DECL,virtual ~Stream() {},5,24,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.Stream.~Stream:ANY(),<empty>,,false,247,247,~Stream,,,1,ANY()
111669149853,METHOD,simplecpp.TokenList.Stream,TYPE_DECL,"unsigned char readChar() {
        unsigned char ch = static_cast<unsigned char>(get());

        // For UTF-16 encoded files the BOM is 0xfeff/0xfffe. If the
        // character is non-ASCII character then replace it with 0xff
        if (isUtf16) {
            const unsigned char ch2 = static_cast<unsigned char>(get());
            const int ch16 = makeUtf16Char(ch, ch2);
            ch = static_cast<unsigned char>(((ch16 >= 0x80) ? 0xff : ch16));
        }

        // Handling of newlines..
        if (ch == '\\r') {
            ch = '\\n';

            int ch2 = get();
            if (isUtf16) {
                const int c2 = get();
                ch2 = makeUtf16Char(ch2, c2);
            }

            if (ch2 != '\\n')
                ungetChar();
        }

        return ch;
    }",5,5,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.Stream.readChar:unsigned char(),<empty>,,false,254,280,readChar,,,2,unsigned char()
111669149854,METHOD,simplecpp.TokenList.Stream,TYPE_DECL,"unsigned char peekChar() {
        unsigned char ch = static_cast<unsigned char>(peek());

        // For UTF-16 encoded files the BOM is 0xfeff/0xfffe. If the
        // character is non-ASCII character then replace it with 0xff
        if (isUtf16) {
            (void)get();
            const unsigned char ch2 = static_cast<unsigned char>(peek());
            unget();
            const int ch16 = makeUtf16Char(ch, ch2);
            ch = static_cast<unsigned char>(((ch16 >= 0x80) ? 0xff : ch16));
        }

        // Handling of newlines..
        if (ch == '\\r')
            ch = '\\n';

        return ch;
    }",5,5,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.Stream.peekChar:unsigned char(),<empty>,,false,282,300,peekChar,,,3,unsigned char()
111669149855,METHOD,simplecpp.TokenList.Stream,TYPE_DECL,"void ungetChar() {
        unget();
        if (isUtf16)
            unget();
    }",5,5,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.Stream.ungetChar:void(),<empty>,,false,302,306,ungetChar,,,4,void()
111669149856,METHOD,simplecpp.TokenList.Stream,TYPE_DECL,"void init() {
        // initialize since we use peek() in getAndSkipBOM()
        isUtf16 = false;
        bom = getAndSkipBOM();
        isUtf16 = (bom == 0xfeff || bom == 0xfffe);
    }",5,5,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.Stream.init:void(),<empty>,,false,309,314,init,,,5,void()
111669149857,METHOD,simplecpp.TokenList.Stream,TYPE_DECL,"inline int makeUtf16Char(const unsigned char ch, const unsigned char ch2) const {
        return (bom == 0xfeff) ? (ch<<8 | ch2) : (ch2<<8 | ch);
    }",5,5,externals/simplecpp/simplecpp.cpp,"simplecpp.TokenList.Stream.makeUtf16Char<const>:int(unsigned char,unsigned char)",<empty>,,false,317,319,makeUtf16Char,,,6,"int(unsigned char,unsigned char)"
111669149858,METHOD,simplecpp.TokenList.Stream,TYPE_DECL,"unsigned short getAndSkipBOM() {
        const int ch1 = peek();

        // The UTF-16 BOM is 0xfffe or 0xfeff.
        if (ch1 >= 0xfe) {
            (void)get();
            const unsigned short byte = (static_cast<unsigned char>(ch1) << 8);
            if (peek() >= 0xfe)
                return byte | static_cast<unsigned char>(get());
            unget();
            return 0;
        }

        // Skip UTF-8 BOM 0xefbbbf
        if (ch1 == 0xef) {
            (void)get();
            if (peek() == 0xbb) {
                (void)get();
                if (peek() == 0xbf) {
                    (void)get();
                    return 0;
                }
                unget();
            }
            unget();
        }

        return 0;
    }",5,5,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.Stream.getAndSkipBOM:short(),<empty>,,false,321,349,getAndSkipBOM,,,7,short()
111669149859,METHOD,StdIStream,TYPE_DECL,"EXPLICIT StdIStream(std::istream &istr)
        : istr(istr) {
        assert(istr.good());
        init();
    }",5,12,externals/simplecpp/simplecpp.cpp,StdIStream.StdIStream:ANY(std.istream&),<empty>,,false,359,363,StdIStream,,,1,StdIStream.StdIStream:ANY(std.istream&)(std.istream&)
111669149860,METHOD,StdIStream,TYPE_DECL,"virtual int get() OVERRIDE {
        return istr.get();
    }",5,22,externals/simplecpp/simplecpp.cpp,StdIStream.get:int(),<empty>,,false,365,367,get,,,2,int()
111669149861,METHOD,StdIStream,TYPE_DECL,"virtual int peek() OVERRIDE {
        return istr.peek();
    }",5,23,externals/simplecpp/simplecpp.cpp,StdIStream.peek:int(),<empty>,,false,368,370,peek,,,3,int()
111669149862,METHOD,StdIStream,TYPE_DECL,"virtual void unget() OVERRIDE {
        istr.unget();
    }",5,25,externals/simplecpp/simplecpp.cpp,StdIStream.unget:void(),<empty>,,false,371,373,unget,,,4,void()
111669149863,METHOD,StdIStream,TYPE_DECL,"virtual bool good() OVERRIDE {
        return istr.good();
    }",5,24,externals/simplecpp/simplecpp.cpp,StdIStream.good:bool(),<empty>,,false,374,376,good,,,5,bool()
111669149864,METHOD,StdCharBufStream,TYPE_DECL,"StdCharBufStream(const unsigned char* str, std::size_t size)
        : str(str)
        , size(size)
        , pos(0)
        , lastStatus(0) {
        init();
    }",5,5,externals/simplecpp/simplecpp.cpp,"StdCharBufStream.StdCharBufStream:ANY(unsigned char*,std.size_t)",<empty>,,false,385,391,StdCharBufStream,,,1,"StdCharBufStream.StdCharBufStream:ANY(unsignedchar*,std.size_t)(unsigned char*,std.size_t)"
111669149865,METHOD,StdCharBufStream,TYPE_DECL,"virtual int get() OVERRIDE {
        if (pos >= size)
            return lastStatus = EOF;
        return str[pos++];
    }",5,22,externals/simplecpp/simplecpp.cpp,StdCharBufStream.get:int(),<empty>,,false,393,397,get,,,2,int()
111669149866,METHOD,StdCharBufStream,TYPE_DECL,"virtual int peek() OVERRIDE {
        if (pos >= size)
            return lastStatus = EOF;
        return str[pos];
    }",5,23,externals/simplecpp/simplecpp.cpp,StdCharBufStream.peek:int(),<empty>,,false,398,402,peek,,,3,int()
111669149867,METHOD,StdCharBufStream,TYPE_DECL,"virtual void unget() OVERRIDE {
        --pos;
    }",5,25,externals/simplecpp/simplecpp.cpp,StdCharBufStream.unget:void(),<empty>,,false,403,405,unget,,,4,void()
111669149868,METHOD,StdCharBufStream,TYPE_DECL,"virtual bool good() OVERRIDE {
        return lastStatus != EOF;
    }",5,24,externals/simplecpp/simplecpp.cpp,StdCharBufStream.good:bool(),<empty>,,false,406,408,good,,,5,bool()
111669149869,METHOD,FileStream,TYPE_DECL,"EXPLICIT FileStream(const std::string &filename, std::vector<std::string> &files)
        : file(fopen(filename.c_str(), ""rb""))
        , lastCh(0)
        , lastStatus(0) {
        if (!file) {
            files.push_back(filename);
            throw simplecpp::Output(files, simplecpp::Output::FILE_NOT_FOUND, ""File is missing: "" + filename);
        }
        init();
    }",5,12,externals/simplecpp/simplecpp.cpp,"FileStream.FileStream:ANY(std.string&,std.vector<std.string>&)",<empty>,,false,420,429,FileStream,,,1,"FileStream.FileStream:ANY(std.string&,std.vector<std.string>&)(std.string&,std.vector<std.string>&)"
111669149870,METHOD,FileStream,TYPE_DECL,"~FileStream() OVERRIDE {
        fclose(file);
        file = nullptr;
    }",5,18,externals/simplecpp/simplecpp.cpp,FileStream.~FileStream:ANY(),<empty>,,false,431,434,~FileStream,,,2,ANY()
111669149871,METHOD,FileStream,TYPE_DECL,"virtual int get() OVERRIDE {
        lastStatus = lastCh = fgetc(file);
        return lastCh;
    }",5,22,externals/simplecpp/simplecpp.cpp,FileStream.get:int(),<empty>,,false,436,439,get,,,3,int()
111669149872,METHOD,FileStream,TYPE_DECL,"virtual int peek() OVERRIDE{
        // keep lastCh intact
        const int ch = fgetc(file);
        unget_internal(ch);
        return ch;
    }",5,23,externals/simplecpp/simplecpp.cpp,FileStream.peek:int(),<empty>,,false,440,445,peek,,,4,int()
111669149873,METHOD,FileStream,TYPE_DECL,"virtual void unget() OVERRIDE {
        unget_internal(lastCh);
    }",5,25,externals/simplecpp/simplecpp.cpp,FileStream.unget:void(),<empty>,,false,446,448,unget,,,5,void()
111669149874,METHOD,FileStream,TYPE_DECL,"virtual bool good() OVERRIDE {
        return lastStatus != EOF;
    }",5,24,externals/simplecpp/simplecpp.cpp,FileStream.good:bool(),<empty>,,false,449,451,good,,,6,bool()
111669149875,METHOD,FileStream,TYPE_DECL,"void unget_internal(int ch) {
        if (isUtf16) {
            // TODO: use ungetc() as well
            // UTF-16 has subsequent unget() calls
            fseek(file, -1, SEEK_CUR);
        } else
            ungetc(ch, file);
    }",5,5,externals/simplecpp/simplecpp.cpp,FileStream.unget_internal:void(int),<empty>,,false,454,461,unget_internal,,,7,void(int)
111669149876,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"simplecpp::TokenList::TokenList(std::vector<std::string> &filenames) : frontToken(nullptr), backToken(nullptr), files(filenames) {}",1,131,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.TokenList:ANY(std.vector<std.string>&),<empty>,,false,471,471,TokenList,,,1,simplecpp.TokenList.TokenList:ANY(std.vector<std.string>&)(std.vector<std.string>&)
111669149877,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"simplecpp::TokenList::TokenList(std::istream &istr, std::vector<std::string> &filenames, const std::string &filename, OutputList *outputList)
    : frontToken(nullptr), backToken(nullptr), files(filenames)
{
    StdIStream stream(istr);
    readfile(stream,filename,outputList);
}",1,1,externals/simplecpp/simplecpp.cpp,"simplecpp.TokenList.TokenList:ANY(std.istream&,std.vector<std.string>&,std.string&,simplecpp.OutputList*)",<empty>,,false,473,478,TokenList,,,1,"simplecpp.TokenList.TokenList:ANY(std.istream&,std.vector<std.string>&,std.string&,simplecpp.OutputList*)(std.istream&,std.vector<std.string>&,std.string&,simplecpp.OutputList*)"
111669149878,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"simplecpp::TokenList::TokenList(const unsigned char* data, std::size_t size, std::vector<std::string> &filenames, const std::string &filename, OutputList *outputList)
    : frontToken(nullptr), backToken(nullptr), files(filenames)
{
    StdCharBufStream stream(data, size);
    readfile(stream,filename,outputList);
}",1,1,externals/simplecpp/simplecpp.cpp,"simplecpp.TokenList.TokenList:ANY(unsigned char*,std.size_t,std.vector<std.string>&,std.string&,simplecpp.OutputList*)",<empty>,,false,480,485,TokenList,,,1,"simplecpp.TokenList.TokenList:ANY(unsignedchar*,std.size_t,std.vector<std.string>&,std.string&,simplecpp.OutputList*)(unsigned char*,std.size_t,std.vector<std.string>&,std.string&,simplecpp.OutputList*)"
111669149879,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"simplecpp::TokenList::TokenList(const char* data, std::size_t size, std::vector<std::string> &filenames, const std::string &filename, OutputList *outputList)
    : frontToken(nullptr), backToken(nullptr), files(filenames)
{
    StdCharBufStream stream(reinterpret_cast<const unsigned char*>(data), size);
    readfile(stream,filename,outputList);
}",1,1,externals/simplecpp/simplecpp.cpp,"simplecpp.TokenList.TokenList:ANY(char*,std.size_t,std.vector<std.string>&,std.string&,simplecpp.OutputList*)",<empty>,,false,487,492,TokenList,,,1,"simplecpp.TokenList.TokenList:ANY(char*,std.size_t,std.vector<std.string>&,std.string&,simplecpp.OutputList*)(char*,std.size_t,std.vector<std.string>&,std.string&,simplecpp.OutputList*)"
111669149880,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"simplecpp::TokenList::TokenList(const std::string &filename, std::vector<std::string> &filenames, OutputList *outputList)
    : frontToken(nullptr), backToken(nullptr), files(filenames)
{
    try {
        FileStream stream(filename, filenames);
        readfile(stream,filename,outputList);
    } catch (const simplecpp::Output & e) { // TODO handle extra type of errors
        outputList->push_back(e);
    }
}",1,1,externals/simplecpp/simplecpp.cpp,"simplecpp.TokenList.TokenList:ANY(std.string&,std.vector<std.string>&,simplecpp.OutputList*)",<empty>,,false,494,503,TokenList,,,1,"simplecpp.TokenList.TokenList:ANY(std.string&,std.vector<std.string>&,simplecpp.OutputList*)(std.string&,std.vector<std.string>&,simplecpp.OutputList*)"
111669149881,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"simplecpp::TokenList::TokenList(const TokenList &other) : frontToken(nullptr), backToken(nullptr), files(other.files)
{
    *this = other;
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.TokenList:ANY(simplecpp.TokenList&),<empty>,,false,505,508,TokenList,,,1,simplecpp.TokenList.TokenList:ANY(simplecpp.TokenList&)(simplecpp.TokenList&)
111669149882,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"simplecpp::TokenList::TokenList(TokenList &&other) : frontToken(nullptr), backToken(nullptr), files(other.files)
{
    *this = std::move(other);
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.TokenList:ANY(simplecpp.TokenList&&),<empty>,,false,511,514,TokenList,,,1,simplecpp.TokenList.TokenList:ANY(simplecpp.TokenList&&)(simplecpp.TokenList&&)
111669149883,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"simplecpp::TokenList::~TokenList()
{
    clear();
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.~TokenList:ANY(),<empty>,,false,517,520,~TokenList,,,1,ANY()
111669149884,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"simplecpp::TokenList &simplecpp::TokenList::operator=(const TokenList &other)
{
    if (this != &other) {
        clear();
        files = other.files;
        for (const Token *tok = other.cfront(); tok; tok = tok->next)
            push_back(new Token(*tok));
        sizeOfType = other.sizeOfType;
    }
    return *this;
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.=:simplecpp.TokenList&(simplecpp.TokenList&),<empty>,,false,522,532,=,,,1,simplecpp.TokenList&(simplecpp.TokenList&)
111669149885,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"simplecpp::TokenList &simplecpp::TokenList::operator=(TokenList &&other)
{
    if (this != &other) {
        clear();
        frontToken = other.frontToken;
        other.frontToken = nullptr;
        backToken = other.backToken;
        other.backToken = nullptr;
        files = other.files;
        sizeOfType = std::move(other.sizeOfType);
    }
    return *this;
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.=:simplecpp.TokenList&(simplecpp.TokenList&&),<empty>,,false,535,547,=,,,1,simplecpp.TokenList&(simplecpp.TokenList&&)
111669149886,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::TokenList::clear()
{
    backToken = nullptr;
    while (frontToken) {
        Token * const next = frontToken->next;
        delete frontToken;
        frontToken = next;
    }
    sizeOfType.clear();
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.clear:void(),<empty>,,false,550,559,clear,,,1,void()
111669149887,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::TokenList::push_back(Token *tok)
{
    if (!frontToken)
        frontToken = tok;
    else
        backToken->next = tok;
    tok->previous = backToken;
    backToken = tok;
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.push_back:void(simplecpp.Token*),<empty>,,false,561,569,push_back,,,1,void(simplecpp.Token*)
111669149888,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::TokenList::dump() const
{
    std::cout << stringify() << std::endl;
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.dump<const>:void(),<empty>,,false,571,574,dump,,,1,void()
111669149889,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"std::string simplecpp::TokenList::stringify() const
{
    std::ostringstream ret;
    Location loc(files);
    for (const Token *tok = cfront(); tok; tok = tok->next) {
        if (tok->location.line < loc.line || tok->location.fileIndex != loc.fileIndex) {
            ret << ""\\n#line "" << tok->location.line << "" \\"""" << tok->location.file() << ""\\""\\n"";
            loc = tok->location;
        }

        while (tok->location.line > loc.line) {
            ret << '\\n';
            loc.line++;
        }

        if (sameline(tok->previous, tok))
            ret << ' ';

        ret << tok->str();

        loc.adjust(tok->str());
    }

    return ret.str();
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.stringify<const>:string(),<empty>,,false,576,600,stringify,,,1,string()
111669149890,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static bool isNameChar(unsigned char ch)
{
    return std::isalnum(ch) || ch == '_' || ch == '$';
}",1,1,externals/simplecpp/simplecpp.cpp,isNameChar:bool(unsigned char),<empty>,,false,602,605,isNameChar,,,1,bool(unsigned char)
111669149891,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static std::string escapeString(const std::string &str)
{
    std::ostringstream ostr;
    ostr << '\\""';
    for (std::size_t i = 1U; i < str.size() - 1; ++i) {
        const char c = str[i];
        if (c == '\\\\' || c == '\\""' || c == '\\'')
            ostr << '\\\\';
        ostr << c;
    }
    ostr << '\\""';
    return ostr.str();
}",1,1,externals/simplecpp/simplecpp.cpp,escapeString:string(std.string&),<empty>,,false,607,619,escapeString,,,1,string(std.string&)
111669149892,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static void portabilityBackslash(simplecpp::OutputList *outputList, const std::vector<std::string> &files, const simplecpp::Location &location)
{
    if (!outputList)
        return;
    simplecpp::Output err(files);
    err.type = simplecpp::Output::PORTABILITY_BACKSLASH;
    err.location = location;
    err.msg = ""Combination 'backslash space newline' is not portable."";
    outputList->push_back(err);
}",1,1,externals/simplecpp/simplecpp.cpp,"portabilityBackslash:void(simplecpp.OutputList*,std.vector<std.string>&,simplecpp.Location&)",<empty>,,false,621,630,portabilityBackslash,,,1,"void(simplecpp.OutputList*,std.vector<std.string>&,simplecpp.Location&)"
111669149893,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static bool isStringLiteralPrefix(const std::string &str)
{
    return str == ""u"" || str == ""U"" || str == ""L"" || str == ""u8"" ||
           str == ""R"" || str == ""uR"" || str == ""UR"" || str == ""LR"" || str == ""u8R"";
}",1,1,externals/simplecpp/simplecpp.cpp,isStringLiteralPrefix:bool(std.string&),<empty>,,false,632,636,isStringLiteralPrefix,,,1,bool(std.string&)
111669149894,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::TokenList::lineDirective(unsigned int fileIndex, unsigned int line, Location *location)
{
    if (fileIndex != location->fileIndex || line >= location->line) {
        location->fileIndex = fileIndex;
        location->line = line;
        return;
    }

    if (line + 2 >= location->line) {
        location->line = line;
        while (cback()->op != '#')
            deleteToken(back());
        deleteToken(back());
        return;
    }
}",1,1,externals/simplecpp/simplecpp.cpp,"simplecpp.TokenList.lineDirective:void(unsigned int,unsigned int,simplecpp.Location*)",<empty>,,false,638,653,lineDirective,,,1,"void(unsigned int,unsigned int,simplecpp.Location*)"
111669149895,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::TokenList::readfile(Stream &stream, const std::string &filename, OutputList *outputList)
{
    std::stack<simplecpp::Location> loc;

    unsigned int multiline = 0U;

    const Token *oldLastToken = nullptr;

    Location location(files);
    location.fileIndex = fileIndex(filename);
    location.line = 1U;
    location.col  = 1U;
    while (stream.good()) {
        unsigned char ch = stream.readChar();
        if (!stream.good())
            break;

        if (ch >= 0x80) {
            if (outputList) {
                simplecpp::Output err(files);
                err.type = simplecpp::Output::UNHANDLED_CHAR_ERROR;
                err.location = location;
                std::ostringstream s;
                s << static_cast<int>(ch);
                err.msg = ""The code contains unhandled character(s) (character code="" + s.str() + ""). Neither unicode nor extended ascii is supported."";
                outputList->push_back(err);
            }
            clear();
  ...",1,1,externals/simplecpp/simplecpp.cpp,"simplecpp.TokenList.readfile:void(simplecpp.TokenList.Stream&,std.string&,simplecpp.OutputList*)",<empty>,,false,657,925,readfile,,,1,"void(simplecpp.TokenList.Stream&,std.string&,simplecpp.OutputList*)"
111669149896,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::TokenList::constFold()
{
    while (cfront()) {
        // goto last '('
        Token *tok = back();
        while (tok && tok->op != '(')
            tok = tok->previous;

        // no '(', goto first token
        if (!tok)
            tok = front();

        // Constant fold expression
        constFoldUnaryNotPosNeg(tok);
        constFoldMulDivRem(tok);
        constFoldAddSub(tok);
        constFoldShift(tok);
        constFoldComparison(tok);
        constFoldBitwise(tok);
        constFoldLogicalOp(tok);
        constFoldQuestionOp(&tok);

        // If there is no '(' we are done with the constant folding
        if (tok->op != '(')
            break;

        if (!tok->next || !tok->next->next || tok->next->next->op != ')')
            break;

        tok = tok->next;
        deleteToken(tok->previous);
        deleteToken(tok->next);
    }
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.constFold:void(),<empty>,,false,927,960,constFold,,,1,void()
111669149897,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static bool isFloatSuffix(const simplecpp::Token *tok)
{
    if (!tok || tok->str().size() != 1U)
        return false;
    const char c = std::tolower(tok->str()[0]);
    return c == 'f' || c == 'l';
}",1,1,externals/simplecpp/simplecpp.cpp,isFloatSuffix:bool(simplecpp.Token*),<empty>,,false,962,968,isFloatSuffix,,,1,bool(simplecpp.Token*)
111669149898,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::TokenList::combineOperators()
{
    std::stack<bool> executableScope;
    executableScope.push(false);
    for (Token *tok = front(); tok; tok = tok->next) {
        if (tok->op == '{') {
            if (executableScope.top()) {
                executableScope.push(true);
                continue;
            }
            const Token *prev = tok->previous;
            while (prev && prev->isOneOf("";{}()""))
                prev = prev->previous;
            executableScope.push(prev && prev->op == ')');
            continue;
        }
        if (tok->op == '}') {
            if (executableScope.size() > 1)
                executableScope.pop();
            continue;
        }

        if (tok->op == '.') {
            // ellipsis ...
            if (tok->next && tok->next->op == '.' && tok->next->location.col == (tok->location.col + 1) &&
                tok->next->next && tok->next->next->op == '.' && tok->next->next->location.col == (tok->location.col + 2)) {
    ...",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.combineOperators:void(),<empty>,,false,970,1096,combineOperators,,,1,void()
111669149899,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::TokenList::constFoldUnaryNotPosNeg(simplecpp::Token *tok)
{
    for (; tok && tok->op != ')'; tok = tok->next) {
        // ""not"" might be !
        if (isAlternativeUnaryOp(tok, NOT))
            tok->op = '!';
        // ""compl"" might be ~
        else if (isAlternativeUnaryOp(tok, COMPL))
            tok->op = '~';

        if (tok->op == '!' && tok->next && tok->next->number) {
            tok->setstr(tok->next->str() == ""0"" ? ""1"" : ""0"");
            deleteToken(tok->next);
        } else if (tok->op == '~' && tok->next && tok->next->number) {
            tok->setstr(toString(~stringToLL(tok->next->str())));
            deleteToken(tok->next);
        } else {
            if (tok->previous && (tok->previous->number || tok->previous->name))
                continue;
            if (!tok->next || !tok->next->number)
                continue;
            switch (tok->op) {
            case '+':
                tok->setstr(tok->next->str());
                deleteTok...",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.constFoldUnaryNotPosNeg:void(simplecpp.Token*),<empty>,,false,1100,1133,constFoldUnaryNotPosNeg,,,1,void(simplecpp.Token*)
111669149900,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::TokenList::constFoldMulDivRem(Token *tok)
{
    for (; tok && tok->op != ')'; tok = tok->next) {
        if (!tok->previous || !tok->previous->number)
            continue;
        if (!tok->next || !tok->next->number)
            continue;

        long long result;
        if (tok->op == '*')
            result = (stringToLL(tok->previous->str()) * stringToLL(tok->next->str()));
        else if (tok->op == '/' || tok->op == '%') {
            const long long rhs = stringToLL(tok->next->str());
            if (rhs == 0)
                throw std::overflow_error(""division/modulo by zero"");
            const long long lhs = stringToLL(tok->previous->str());
            if (rhs == -1 && lhs == std::numeric_limits<long long>::min())
                throw std::overflow_error(""division overflow"");
            if (tok->op == '/')
                result = (lhs / rhs);
            else
                result = (lhs % rhs);
        } else
            continue;

        tok = ...",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.constFoldMulDivRem:void(simplecpp.Token*),<empty>,,false,1135,1165,constFoldMulDivRem,,,1,void(simplecpp.Token*)
111669149901,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::TokenList::constFoldAddSub(Token *tok)
{
    for (; tok && tok->op != ')'; tok = tok->next) {
        if (!tok->previous || !tok->previous->number)
            continue;
        if (!tok->next || !tok->next->number)
            continue;

        long long result;
        if (tok->op == '+')
            result = stringToLL(tok->previous->str()) + stringToLL(tok->next->str());
        else if (tok->op == '-')
            result = stringToLL(tok->previous->str()) - stringToLL(tok->next->str());
        else
            continue;

        tok = tok->previous;
        tok->setstr(toString(result));
        deleteToken(tok->next);
        deleteToken(tok->next);
    }
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.constFoldAddSub:void(simplecpp.Token*),<empty>,,false,1167,1188,constFoldAddSub,,,1,void(simplecpp.Token*)
111669149902,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::TokenList::constFoldShift(Token *tok)
{
    for (; tok && tok->op != ')'; tok = tok->next) {
        if (!tok->previous || !tok->previous->number)
            continue;
        if (!tok->next || !tok->next->number)
            continue;

        long long result;
        if (tok->str() == ""<<"")
            result = stringToLL(tok->previous->str()) << stringToLL(tok->next->str());
        else if (tok->str() == "">>"")
            result = stringToLL(tok->previous->str()) >> stringToLL(tok->next->str());
        else
            continue;

        tok = tok->previous;
        tok->setstr(toString(result));
        deleteToken(tok->next);
        deleteToken(tok->next);
    }
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.constFoldShift:void(simplecpp.Token*),<empty>,,false,1190,1211,constFoldShift,,,1,void(simplecpp.Token*)
111669149903,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::TokenList::constFoldComparison(Token *tok)
{
    for (; tok && tok->op != ')'; tok = tok->next) {
        if (isAlternativeBinaryOp(tok,NOTEQ))
            tok->setstr(""!="");

        if (!tok->startsWithOneOf(""<>=!""))
            continue;
        if (!tok->previous || !tok->previous->number)
            continue;
        if (!tok->next || !tok->next->number)
            continue;

        int result;
        if (tok->str() == ""=="")
            result = (stringToLL(tok->previous->str()) == stringToLL(tok->next->str()));
        else if (tok->str() == ""!="")
            result = (stringToLL(tok->previous->str()) != stringToLL(tok->next->str()));
        else if (tok->str() == "">"")
            result = (stringToLL(tok->previous->str()) > stringToLL(tok->next->str()));
        else if (tok->str() == "">="")
            result = (stringToLL(tok->previous->str()) >= stringToLL(tok->next->str()));
        else if (tok->str() == ""<"")
            result = (stringToLL(tok->prev...",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.constFoldComparison:void(simplecpp.Token*),<empty>,,false,1214,1248,constFoldComparison,,,1,void(simplecpp.Token*)
111669149904,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::TokenList::constFoldBitwise(Token *tok)
{
    Token * const tok1 = tok;
    for (const char *op = ""&^|""; *op; op++) {
        const std::string* alternativeOp;
        if (*op == '&')
            alternativeOp = &BITAND;
        else if (*op == '|')
            alternativeOp = &BITOR;
        else
            alternativeOp = &XOR;
        for (tok = tok1; tok && tok->op != ')'; tok = tok->next) {
            if (tok->op != *op && !isAlternativeBinaryOp(tok, *alternativeOp))
                continue;
            if (!tok->previous || !tok->previous->number)
                continue;
            if (!tok->next || !tok->next->number)
                continue;
            long long result;
            if (*op == '&')
                result = (stringToLL(tok->previous->str()) & stringToLL(tok->next->str()));
            else if (*op == '^')
                result = (stringToLL(tok->previous->str()) ^ stringToLL(tok->next->str()));
            else /*if (*op == '|')*/
    ...",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.constFoldBitwise:void(simplecpp.Token*),<empty>,,false,1253,1284,constFoldBitwise,,,1,void(simplecpp.Token*)
111669149905,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::TokenList::constFoldLogicalOp(Token *tok)
{
    for (; tok && tok->op != ')'; tok = tok->next) {
        if (tok->name) {
            if (isAlternativeBinaryOp(tok,AND))
                tok->setstr(""&&"");
            else if (isAlternativeBinaryOp(tok,OR))
                tok->setstr(""||"");
        }
        if (tok->str() != ""&&"" && tok->str() != ""||"")
            continue;
        if (!tok->previous || !tok->previous->number)
            continue;
        if (!tok->next || !tok->next->number)
            continue;

        int result;
        if (tok->str() == ""||"")
            result = (stringToLL(tok->previous->str()) || stringToLL(tok->next->str()));
        else /*if (tok->str() == ""&&"")*/
            result = (stringToLL(tok->previous->str()) && stringToLL(tok->next->str()));

        tok = tok->previous;
        tok->setstr(toString(result));
        deleteToken(tok->next);
        deleteToken(tok->next);
    }
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.constFoldLogicalOp:void(simplecpp.Token*),<empty>,,false,1288,1315,constFoldLogicalOp,,,1,void(simplecpp.Token*)
111669149906,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::TokenList::constFoldQuestionOp(Token **tok1)
{
    bool gotoTok1 = false;
    for (Token *tok = *tok1; tok && tok->op != ')'; tok =  gotoTok1 ? *tok1 : tok->next) {
        gotoTok1 = false;
        if (tok->str() != ""?"")
            continue;
        if (!tok->previous || !tok->next || !tok->next->next)
            throw std::runtime_error(""invalid expression"");
        if (!tok->previous->number)
            continue;
        if (tok->next->next->op != ':')
            continue;
        Token * const condTok = tok->previous;
        Token * const trueTok = tok->next;
        Token * const falseTok = trueTok->next->next;
        if (!falseTok)
            throw std::runtime_error(""invalid expression"");
        if (condTok == *tok1)
            *tok1 = (condTok->str() != ""0"" ? trueTok : falseTok);
        deleteToken(condTok->next); // ?
        deleteToken(trueTok->next); // :
        deleteToken(condTok->str() == ""0"" ? trueTok : falseTok);
        deleteToken(condT...",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.constFoldQuestionOp:void(simplecpp.Token**),<empty>,,false,1317,1343,constFoldQuestionOp,,,1,void(simplecpp.Token**)
111669149907,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::TokenList::removeComments()
{
    Token *tok = frontToken;
    while (tok) {
        Token * const tok1 = tok;
        tok = tok->next;
        if (tok1->comment)
            deleteToken(tok1);
    }
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.removeComments:void(),<empty>,,false,1345,1354,removeComments,,,1,void()
111669149908,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"std::string simplecpp::TokenList::readUntil(Stream &stream, const Location &location, const char start, const char end, OutputList *outputList)
{
    std::string ret;
    ret += start;

    bool backslash = false;
    char ch = 0;
    while (ch != end && ch != '\\r' && ch != '\\n' && stream.good()) {
        ch = stream.readChar();
        if (backslash && ch == '\\n') {
            ch = 0;
            backslash = false;
            continue;
        }
        backslash = false;
        ret += ch;
        if (ch == '\\\\') {
            bool update_ch = false;
            char next = 0;
            do {
                next = stream.readChar();
                if (next == '\\r' || next == '\\n') {
                    ret.erase(ret.size()-1U);
                    backslash = (next == '\\r');
                    update_ch = false;
                } else if (next == '\\\\')
                    update_ch = !update_ch;
                ret += next;
            } while (next == '\\\\');
            if...",1,1,externals/simplecpp/simplecpp.cpp,"simplecpp.TokenList.readUntil:string(simplecpp.TokenList.Stream&,simplecpp.Location&,char,char,simplecpp.OutputList*)",<empty>,,false,1356,1403,readUntil,,,1,"string(simplecpp.TokenList.Stream&,simplecpp.Location&,char,char,simplecpp.OutputList*)"
111669149909,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"std::string simplecpp::TokenList::lastLine(int maxsize) const
{
    std::string ret;
    int count = 0;
    for (const Token *tok = cback(); ; tok = tok->previous) {
        if (!sameline(tok, cback())) {
            break;
        }
        if (tok->comment)
            continue;
        if (++count > maxsize)
            return """";
        if (!ret.empty())
            ret += ' ';
        // add tokens in reverse for performance reasons
        if (tok->str()[0] == '\\""')
            ret += ""%rts%""; // %str%
        else if (tok->number)
            ret += ""%mun%""; // %num%
        else {
            ret += tok->str();
            std::reverse(ret.end() - tok->str().length(), ret.end());
        }
    }
    std::reverse(ret.begin(), ret.end());
    return ret;
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.lastLine<const>:string(int),<empty>,,false,1405,1431,lastLine,,,1,string(int)
111669149910,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"const simplecpp::Token* simplecpp::TokenList::lastLineTok(int maxsize) const
{
    const Token* prevTok = nullptr;
    int count = 0;
    for (const Token *tok = cback(); ; tok = tok->previous) {
        if (!sameline(tok, cback()))
            break;
        if (tok->comment)
            continue;
        if (++count > maxsize)
            return nullptr;
        prevTok = tok;
    }
    return prevTok;
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.lastLineTok<const>:simplecpp.Token*(int),<empty>,,false,1433,1447,lastLineTok,,,1,simplecpp.Token*(int)
111669149911,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"bool simplecpp::TokenList::isLastLinePreprocessor(int maxsize) const
{
    const Token * const prevTok = lastLineTok(maxsize);
    return prevTok && prevTok->op == '#';
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.isLastLinePreprocessor<const>:bool(int),<empty>,,false,1449,1453,isLastLinePreprocessor,,,1,bool(int)
111669149912,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"unsigned int simplecpp::TokenList::fileIndex(const std::string &filename)
{
    for (unsigned int i = 0; i < files.size(); ++i) {
        if (files[i] == filename)
            return i;
    }
    files.push_back(filename);
    return files.size() - 1U;
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.fileIndex:unsigned int(std.string&),<empty>,,false,1455,1463,fileIndex,,,1,unsigned int(std.string&)
111669149913,METHOD,simplecpp.Macro.Error,TYPE_DECL,"Error(const Location &loc, const std::string &s) : location(loc), what(s) {}",13,88,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.Error.Error:ANY(simplecpp.Location&,std.string&)",<empty>,,false,1649,1649,Error,,,1,"simplecpp.Macro.Error.Error:ANY(simplecpp.Location&,std.string&)(simplecpp.Location&,std.string&)"
111669149914,METHOD,simplecpp.Macro.wrongNumberOfParameters,TYPE_DECL,"wrongNumberOfParameters(const Location &loc, const std::string &macroName) : Error(loc, ""Wrong number of parameters for macro \\'"" + macroName + ""\\'."") {}",13,165,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.wrongNumberOfParameters.wrongNumberOfParameters:ANY(simplecpp.Location&,std.string&)",<empty>,,false,1656,1656,wrongNumberOfParameters,,,1,"simplecpp.Macro.wrongNumberOfParameters.wrongNumberOfParameters:ANY(simplecpp.Location&,std.string&)(simplecpp.Location&,std.string&)"
111669149915,METHOD,simplecpp.Macro.invalidHashHash,TYPE_DECL,"static inline std::string format(const std::string &macroName, const std::string &message) {
                return ""Invalid ## usage when expanding \\'"" + macroName + ""\\': "" + message;
            }",13,13,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.invalidHashHash.format:string(std.string&,std.string&)",<empty>,,false,1661,1663,format,,,1,"string(std.string&,std.string&)"
111669149916,METHOD,simplecpp.Macro.invalidHashHash,TYPE_DECL,"invalidHashHash(const Location &loc, const std::string &macroName, const std::string &message)
                : Error(loc, format(macroName, message)) { }",13,60,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.invalidHashHash.invalidHashHash:ANY(simplecpp.Location&,std.string&,std.string&)",<empty>,,false,1665,1666,invalidHashHash,,,2,"simplecpp.Macro.invalidHashHash.invalidHashHash:ANY(simplecpp.Location&,std.string&,std.string&)(simplecpp.Location&,std.string&,std.string&)"
111669149917,METHOD,simplecpp.Macro.invalidHashHash,TYPE_DECL,"static inline invalidHashHash unexpectedToken(const Location &loc, const std::string &macroName, const Token *tokenA) {
                return invalidHashHash(loc, macroName, ""Unexpected token '""+ tokenA->str()+""'"");
            }",13,13,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.invalidHashHash.unexpectedToken:simplecpp.Macro.invalidHashHash(simplecpp.Location&,std.string&,simplecpp.Token*)",<empty>,,false,1668,1670,unexpectedToken,,,3,"simplecpp.Macro.invalidHashHash(simplecpp.Location&,std.string&,simplecpp.Token*)"
111669149918,METHOD,simplecpp.Macro.invalidHashHash,TYPE_DECL,"static inline invalidHashHash cannotCombine(const Location &loc, const std::string &macroName, const Token *tokenA, const Token *tokenB) {
                return invalidHashHash(loc, macroName, ""Combining '""+ tokenA->str()+ ""' and '""+ tokenB->str() + ""' yields an invalid token."");
            }",13,13,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.invalidHashHash.cannotCombine:simplecpp.Macro.invalidHashHash(simplecpp.Location&,std.string&,simplecpp.Token*,simplecpp.Token*)",<empty>,,false,1672,1674,cannotCombine,,,4,"simplecpp.Macro.invalidHashHash(simplecpp.Location&,std.string&,simplecpp.Token*,simplecpp.Token*)"
111669149919,METHOD,simplecpp.Macro.invalidHashHash,TYPE_DECL,"static inline invalidHashHash unexpectedNewline(const Location &loc, const std::string &macroName) {
                return invalidHashHash(loc, macroName, ""Unexpected newline"");
            }",13,13,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.invalidHashHash.unexpectedNewline:simplecpp.Macro.invalidHashHash(simplecpp.Location&,std.string&)",<empty>,,false,1676,1678,unexpectedNewline,,,5,"simplecpp.Macro.invalidHashHash(simplecpp.Location&,std.string&)"
111669149920,METHOD,simplecpp.Macro.invalidHashHash,TYPE_DECL,"static inline invalidHashHash universalCharacterUB(const Location &loc, const std::string &macroName, const Token* tokenA, const std::string& strAB) {
                return invalidHashHash(loc, macroName, ""Combining '\\\\""+ tokenA->str()+ ""' and '""+ strAB.substr(tokenA->str().size()) + ""' yields universal character '\\\\"" + strAB + ""'. This is undefined behavior according to C standard chapter 5.1.1.2, paragraph 4."");
            }",13,13,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.invalidHashHash.universalCharacterUB:simplecpp.Macro.invalidHashHash(simplecpp.Location&,std.string&,simplecpp.Token*,std.string&)",<empty>,,false,1680,1682,universalCharacterUB,,,6,"simplecpp.Macro.invalidHashHash(simplecpp.Location&,std.string&,simplecpp.Token*,std.string&)"
111669149921,METHOD,simplecpp.Macro,TYPE_DECL,"explicit Macro(std::vector<std::string> &f) : nameTokDef(nullptr), valueToken(nullptr), endToken(nullptr), files(f), tokenListDefine(f), variadic(false), valueDefinedInCode_(false) {}",9,191,externals/simplecpp/simplecpp.cpp,simplecpp.Macro.Macro:ANY(std.vector<std.string>&),<empty>,,false,1476,1476,Macro,,,1,simplecpp.Macro.Macro:ANY(std.vector<std.string>&)(std.vector<std.string>&)
111669149922,METHOD,simplecpp.Macro,TYPE_DECL,"Macro(const Token *tok, std::vector<std::string> &f) : nameTokDef(nullptr), files(f), tokenListDefine(f), valueDefinedInCode_(true) {
            if (sameline(tok->previousSkipComments(), tok))
                throw std::runtime_error(""bad macro syntax"");
            if (tok->op != '#')
                throw std::runtime_error(""bad macro syntax"");
            const Token * const hashtok = tok;
            tok = tok->next;
            if (!tok || tok->str() != DEFINE)
                throw std::runtime_error(""bad macro syntax"");
            tok = tok->next;
            if (!tok || !tok->name || !sameline(hashtok,tok))
                throw std::runtime_error(""bad macro syntax"");
            if (!parseDefine(tok))
                throw std::runtime_error(""bad macro syntax"");
        }",9,9,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.Macro:ANY(simplecpp.Token*,std.vector<std.string>&)",<empty>,,false,1478,1492,Macro,,,2,"simplecpp.Macro.Macro:ANY(simplecpp.Token*,std.vector<std.string>&)(simplecpp.Token*,std.vector<std.string>&)"
111669149923,METHOD,simplecpp.Macro,TYPE_DECL,"Macro(const std::string &name, const std::string &value, std::vector<std::string> &f) : nameTokDef(nullptr), files(f), tokenListDefine(f), valueDefinedInCode_(false) {
            const std::string def(name + ' ' + value);
            StdCharBufStream stream(reinterpret_cast<const unsigned char*>(def.data()), def.size());
            tokenListDefine.readfile(stream);
            if (!parseDefine(tokenListDefine.cfront()))
                throw std::runtime_error(""bad macro syntax. macroname="" + name + "" value="" + value);
        }",9,9,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.Macro:ANY(std.string&,std.string&,std.vector<std.string>&)",<empty>,,false,1494,1500,Macro,,,3,"simplecpp.Macro.Macro:ANY(std.string&,std.string&,std.vector<std.string>&)(std.string&,std.string&,std.vector<std.string>&)"
111669149924,METHOD,simplecpp.Macro,TYPE_DECL,"Macro(const Macro &other) : nameTokDef(nullptr), files(other.files), tokenListDefine(other.files), valueDefinedInCode_(other.valueDefinedInCode_) {
            *this = other;
        }",9,9,externals/simplecpp/simplecpp.cpp,simplecpp.Macro.Macro:ANY(simplecpp.Macro&),<empty>,,false,1502,1504,Macro,,,4,simplecpp.Macro.Macro:ANY(simplecpp.Macro&)(simplecpp.Macro&)
111669149925,METHOD,simplecpp.Macro,TYPE_DECL,"Macro &operator=(const Macro &other) {
            if (this != &other) {
                files = other.files;
                valueDefinedInCode_ = other.valueDefinedInCode_;
                if (other.tokenListDefine.empty())
                    parseDefine(other.nameTokDef);
                else {
                    tokenListDefine = other.tokenListDefine;
                    parseDefine(tokenListDefine.cfront());
                }
                usageList = other.usageList;
            }
            return *this;
        }",9,9,externals/simplecpp/simplecpp.cpp,simplecpp.Macro.=:simplecpp.Macro&(simplecpp.Macro&),<empty>,,false,1506,1519,=,,,5,simplecpp.Macro&(simplecpp.Macro&)
111669149926,METHOD,simplecpp.Macro,TYPE_DECL,"bool valueDefinedInCode() const {
            return valueDefinedInCode_;
        }",9,9,externals/simplecpp/simplecpp.cpp,simplecpp.Macro.valueDefinedInCode<const>:bool(),<empty>,,false,1521,1523,valueDefinedInCode,,,6,bool()
111669149927,METHOD,simplecpp.Macro,TYPE_DECL,"const Token * expand(TokenList * const output,
                             const Token * rawtok,
                             const MacroMap &macros,
                             std::vector<std::string> &inputFiles) const {
            std::set<TokenString> expandedmacros;

#ifdef SIMPLECPP_DEBUG_MACRO_EXPANSION
            std::cout << ""expand "" << name() << "" "" << locstring(rawtok->location) << std::endl;
#endif

            TokenList output2(inputFiles);

            if (functionLike() && rawtok->next && rawtok->next->op == '(') {
                // Copy macro call to a new tokenlist with no linebreaks
                const Token * const rawtok1 = rawtok;
                TokenList rawtokens2(inputFiles);
                rawtokens2.push_back(new Token(rawtok->str(), rawtok1->location, rawtok->whitespaceahead));
                rawtok = rawtok->next;
                rawtokens2.push_back(new Token(rawtok->str(), rawtok1->location, rawtok->whitespaceahead));
                rawtok ...",9,9,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.expand<const>:simplecpp.Token*(simplecpp.TokenList*,simplecpp.Token*,simplecpp.MacroMap&,std.vector<std.string>&)",<empty>,,false,1534,1622,expand,,,7,"simplecpp.Token*(simplecpp.TokenList*,simplecpp.Token*,simplecpp.MacroMap&,std.vector<std.string>&)"
111669149928,METHOD,simplecpp.Macro,TYPE_DECL,"const TokenString &name() const {
            return nameTokDef->str();
        }",9,9,externals/simplecpp/simplecpp.cpp,simplecpp.Macro.name<const>:ANY(),<empty>,,false,1625,1627,name,,,8,ANY()
111669149929,METHOD,simplecpp.Macro,TYPE_DECL,"const Location &defineLocation() const {
            return nameTokDef->location;
        }",9,9,externals/simplecpp/simplecpp.cpp,simplecpp.Macro.defineLocation<const>:simplecpp.Location&(),<empty>,,false,1630,1632,defineLocation,,,9,simplecpp.Location&()
111669149930,METHOD,simplecpp.Macro,TYPE_DECL,"const std::list<Location> &usage() const {
            return usageList;
        }",9,9,externals/simplecpp/simplecpp.cpp,simplecpp.Macro.usage<const>:ANY(),<empty>,,false,1635,1637,usage,,,10,ANY()
111669149931,METHOD,simplecpp.Macro,TYPE_DECL,"bool functionLike() const {
            return nameTokDef->next &&
                   nameTokDef->next->op == '(' &&
                   sameline(nameTokDef, nameTokDef->next) &&
                   nameTokDef->next->location.col == nameTokDef->location.col + nameTokDef->str().size();
        }",9,9,externals/simplecpp/simplecpp.cpp,simplecpp.Macro.functionLike<const>:bool(),<empty>,,false,1640,1645,functionLike,,,11,bool()
111669149932,METHOD,simplecpp.Macro,TYPE_DECL,"Token *newMacroToken(const TokenString &str, const Location &loc, bool replaced, const Token *expandedFromToken=nullptr) const {
            Token *tok = new Token(str,loc);
            if (replaced)
                tok->macro = nameTokDef->str();
            if (expandedFromToken)
                tok->setExpandedFrom(expandedFromToken, this);
            return tok;
        }",9,9,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.newMacroToken<const>:simplecpp.Token*(simplecpp.TokenString&,simplecpp.Location&,bool,simplecpp.Token*)",<empty>,,false,1686,1693,newMacroToken,,,15,"simplecpp.Token*(simplecpp.TokenString&,simplecpp.Location&,bool,simplecpp.Token*)"
111669149933,METHOD,simplecpp.Macro,TYPE_DECL,"bool parseDefine(const Token *nametoken) {
            nameTokDef = nametoken;
            variadic = false;
            if (!nameTokDef) {
                valueToken = endToken = nullptr;
                args.clear();
                return false;
            }

            // function like macro..
            if (functionLike()) {
                args.clear();
                const Token *argtok = nameTokDef->next->next;
                while (sameline(nametoken, argtok) && argtok->op != ')') {
                    if (argtok->str() == ""..."" &&
                        argtok->next && argtok->next->op == ')') {
                        variadic = true;
                        if (!argtok->previous->name)
                            args.push_back(""__VA_ARGS__"");
                        argtok = argtok->next; // goto ')'
                        break;
                    }
                    if (argtok->op != ',')
                        args.push_back(argtok->str());
               ...",9,9,externals/simplecpp/simplecpp.cpp,simplecpp.Macro.parseDefine:bool(simplecpp.Token*),<empty>,,false,1695,1738,parseDefine,,,16,bool(simplecpp.Token*)
111669149934,METHOD,simplecpp.Macro,TYPE_DECL,"unsigned int getArgNum(const TokenString &str) const {
            unsigned int par = 0;
            while (par < args.size()) {
                if (str == args[par])
                    return par;
                par++;
            }
            return ~0U;
        }",9,9,externals/simplecpp/simplecpp.cpp,simplecpp.Macro.getArgNum<const>:unsigned int(simplecpp.TokenString&),<empty>,,false,1740,1748,getArgNum,,,17,unsigned int(simplecpp.TokenString&)
111669149935,METHOD,simplecpp.Macro,TYPE_DECL,"std::vector<const Token *> getMacroParameters(const Token *nameTokInst, bool calledInDefine) const {
            if (!nameTokInst->next || nameTokInst->next->op != '(' || !functionLike())
                return std::vector<const Token *>();

            std::vector<const Token *> parametertokens;
            parametertokens.push_back(nameTokInst->next);
            unsigned int par = 0U;
            for (const Token *tok = nameTokInst->next->next; calledInDefine ? sameline(tok, nameTokInst) : (tok != nullptr); tok = tok->next) {
                if (tok->op == '(')
                    ++par;
                else if (tok->op == ')') {
                    if (par == 0U) {
                        parametertokens.push_back(tok);
                        break;
                    }
                    --par;
                } else if (par == 0U && tok->op == ',' && (!variadic || parametertokens.size() < args.size()))
                    parametertokens.push_back(tok);
            }
      ...",9,9,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.getMacroParameters<const>:vector<constToken*>(simplecpp.Token*,bool)",<empty>,,false,1750,1770,getMacroParameters,,,18,"vector<const Token*>(simplecpp.Token*,bool)"
111669149936,METHOD,simplecpp.Macro,TYPE_DECL,"const Token *appendTokens(TokenList *tokens,
                                  const Location &rawloc,
                                  const Token * const lpar,
                                  const MacroMap &macros,
                                  const std::set<TokenString> &expandedmacros,
                                  const std::vector<const Token*> &parametertokens) const {
            if (!lpar || lpar->op != '(')
                return nullptr;
            unsigned int par = 0;
            const Token *tok = lpar;
            while (sameline(lpar, tok)) {
                if (tok->op == '#' && sameline(tok,tok->next) && tok->next->op == '#' && sameline(tok,tok->next->next)) {
                    // A##B => AB
                    tok = expandHashHash(tokens, rawloc, tok, macros, expandedmacros, parametertokens, false);
                } else if (tok->op == '#' && sameline(tok, tok->next) && tok->next->op != '#') {
                    tok = expandHash(tokens, rawloc, t...",9,9,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.appendTokens<const>:simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,simplecpp.MacroMap&,std.set<TokenString>&,std.vector<constToken*>&)",<empty>,,false,1772,1808,appendTokens,,,19,"simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,simplecpp.MacroMap&,std.set<TokenString>&,std.vector<constToken*>&)"
111669149937,METHOD,simplecpp.Macro,TYPE_DECL,"const Token * expand(TokenList * const output, const Location &loc, const Token * const nameTokInst, const MacroMap &macros, std::set<TokenString> expandedmacros) const {
            expandedmacros.insert(nameTokInst->str());

#ifdef SIMPLECPP_DEBUG_MACRO_EXPANSION
            std::cout << ""  expand "" << name() << "" "" << locstring(defineLocation()) << std::endl;
#endif

            usageList.push_back(loc);

            if (nameTokInst->str() == ""__FILE__"") {
                output->push_back(new Token('\\""'+loc.file()+'\\""', loc));
                return nameTokInst->next;
            }
            if (nameTokInst->str() == ""__LINE__"") {
                output->push_back(new Token(toString(loc.line), loc));
                return nameTokInst->next;
            }
            if (nameTokInst->str() == ""__COUNTER__"") {
                output->push_back(new Token(toString(usageList.size()-1U), loc));
                return nameTokInst->next;
            }

            const bool calledIn...",9,9,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.expand<const>:simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,simplecpp.MacroMap&,std.set<TokenString>)",<empty>,,false,1810,1964,expand,,,20,"simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,simplecpp.MacroMap&,std.set<TokenString>)"
111669149938,METHOD,simplecpp.Macro,TYPE_DECL,"const Token *recursiveExpandToken(TokenList *output, TokenList &temp, const Location &loc, const Token *tok, const MacroMap &macros, const std::set<TokenString> &expandedmacros, const std::vector<const Token*> &parametertokens) const {
            if (!(temp.cback() && temp.cback()->name && tok->next && tok->next->op == '(')) {
                output->takeTokens(temp);
                return tok->next;
            }

            if (!sameline(tok, tok->next)) {
                output->takeTokens(temp);
                return tok->next;
            }

            const MacroMap::const_iterator it = macros.find(temp.cback()->str());
            if (it == macros.end() || expandedmacros.find(temp.cback()->str()) != expandedmacros.end()) {
                output->takeTokens(temp);
                return tok->next;
            }

            const Macro &calledMacro = it->second;
            if (!calledMacro.functionLike()) {
                output->takeTokens(temp);
                retur...",9,9,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.recursiveExpandToken<const>:simplecpp.Token*(simplecpp.TokenList*,simplecpp.TokenList&,simplecpp.Location&,simplecpp.Token*,simplecpp.MacroMap&,std.set<TokenString>&,std.vector<constToken*>&)",<empty>,,false,1966,1999,recursiveExpandToken,,,21,"simplecpp.Token*(simplecpp.TokenList*,simplecpp.TokenList&,simplecpp.Location&,simplecpp.Token*,simplecpp.MacroMap&,std.set<TokenString>&,std.vector<constToken*>&)"
111669149939,METHOD,simplecpp.Macro,TYPE_DECL,"const Token *expandToken(TokenList *output, const Location &loc, const Token *tok, const MacroMap &macros, const std::set<TokenString> &expandedmacros, const std::vector<const Token*> &parametertokens) const {
            // Not name..
            if (!tok->name) {
                output->push_back(newMacroToken(tok->str(), loc, true, tok));
                return tok->next;
            }

            // Macro parameter..
            {
                TokenList temp(files);
                if (tok->str() == ""__VA_OPT__"") {
                    if (sameline(tok, tok->next) && tok->next->str() == ""("") {
                        tok = tok->next;
                        int paren = 1;
                        while (sameline(tok, tok->next)) {
                            if (tok->next->str() == ""("")
                                ++paren;
                            else if (tok->next->str() == "")"")
                                --paren;
                            if (paren == 0)
     ...",9,9,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.expandToken<const>:simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,simplecpp.MacroMap&,std.set<TokenString>&,std.vector<constToken*>&)",<empty>,,false,2001,2104,expandToken,,,22,"simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,simplecpp.MacroMap&,std.set<TokenString>&,std.vector<constToken*>&)"
111669149940,METHOD,simplecpp.Macro,TYPE_DECL,"bool expandArg(TokenList *output, const Token *tok, const std::vector<const Token*> &parametertokens) const {
            if (!tok->name)
                return false;

            const unsigned int argnr = getArgNum(tok->str());
            if (argnr >= args.size())
                return false;

            // empty variadic parameter
            if (variadic && argnr + 1U >= parametertokens.size())
                return true;

            for (const Token *partok = parametertokens[argnr]->next; partok != parametertokens[argnr + 1U]; partok = partok->next)
                output->push_back(new Token(*partok));

            return true;
        }",9,9,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.expandArg<const>:bool(simplecpp.TokenList*,simplecpp.Token*,std.vector<constToken*>&)",<empty>,,false,2106,2122,expandArg,,,23,"bool(simplecpp.TokenList*,simplecpp.Token*,std.vector<constToken*>&)"
111669149941,METHOD,simplecpp.Macro,TYPE_DECL,"bool expandArg(TokenList *output, const Token *tok, const Location &loc, const MacroMap &macros, const std::set<TokenString> &expandedmacros, const std::vector<const Token*> &parametertokens) const {
            if (!tok->name)
                return false;
            const unsigned int argnr = getArgNum(tok->str());
            if (argnr >= args.size())
                return false;
            if (variadic && argnr + 1U >= parametertokens.size()) // empty variadic parameter
                return true;
            for (const Token *partok = parametertokens[argnr]->next; partok != parametertokens[argnr + 1U];) {
                const MacroMap::const_iterator it = macros.find(partok->str());
                if (it != macros.end() && !partok->isExpandedFrom(&it->second) && (partok->str() == name() || expandedmacros.find(partok->str()) == expandedmacros.end())) {
                    std::set<TokenString> expandedmacros2(expandedmacros); // temporary amnesia to allow reexpansion of cu...",9,9,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.expandArg<const>:bool(simplecpp.TokenList*,simplecpp.Token*,simplecpp.Location&,simplecpp.MacroMap&,std.set<TokenString>&,std.vector<constToken*>&)",<empty>,,false,2124,2147,expandArg,,,24,"bool(simplecpp.TokenList*,simplecpp.Token*,simplecpp.Location&,simplecpp.MacroMap&,std.set<TokenString>&,std.vector<constToken*>&)"
111669149942,METHOD,simplecpp.Macro,TYPE_DECL,"const Token *expandHash(TokenList *output, const Location &loc, const Token *tok, const std::set<TokenString> &expandedmacros, const std::vector<const Token*> &parametertokens) const {
            TokenList tokenListHash(files);
            const MacroMap macros2; // temporarily bypass macro expansion
            tok = expandToken(&tokenListHash, loc, tok->next, macros2, expandedmacros, parametertokens);
            std::ostringstream ostr;
            ostr << '\\""';
            for (const Token *hashtok = tokenListHash.cfront(), *next; hashtok; hashtok = next) {
                next = hashtok->next;
                ostr << hashtok->str();
                if (next && hashtok->whitespaceahead)
                    ostr << ' ';
            }
            ostr << '\\""';
            output->push_back(newMacroToken(escapeString(ostr.str()), loc, isReplaced(expandedmacros)));
            return tok;
        }",9,9,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.expandHash<const>:simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,std.set<TokenString>&,std.vector<constToken*>&)",<empty>,,false,2158,2173,expandHash,,,25,"simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,std.set<TokenString>&,std.vector<constToken*>&)"
111669149943,METHOD,simplecpp.Macro,TYPE_DECL,"const Token *expandHashHash(TokenList *output, const Location &loc, const Token *tok, const MacroMap &macros, const std::set<TokenString> &expandedmacros, const std::vector<const Token*> &parametertokens, bool expandResult=true) const {
            Token *A = output->back();
            if (!A)
                throw invalidHashHash(tok->location, name(), ""Missing first argument"");
            if (!sameline(tok, tok->next) || !sameline(tok, tok->next->next))
                throw invalidHashHash::unexpectedNewline(tok->location, name());

            const bool canBeConcatenatedWithEqual = A->isOneOf(""+-*/%&|^"") || A->str() == ""<<"" || A->str() == "">>"";
            const bool canBeConcatenatedStringOrChar = isStringLiteral_(A->str()) || isCharLiteral_(A->str());
            const bool unexpectedA = (!A->name && !A->number && !A->str().empty() && !canBeConcatenatedWithEqual && !canBeConcatenatedStringOrChar);

            Token * const B = tok->next->next;
            if (!B->name && !...",9,9,externals/simplecpp/simplecpp.cpp,"simplecpp.Macro.expandHashHash<const>:simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,simplecpp.MacroMap&,std.set<TokenString>&,std.vector<constToken*>&,bool)",<empty>,,false,2187,2294,expandHashHash,,,26,"simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,simplecpp.MacroMap&,std.set<TokenString>&,std.vector<constToken*>&,bool)"
111669149944,METHOD,simplecpp.Macro,TYPE_DECL,"static bool isReplaced(const std::set<std::string> &expandedmacros) {
            // return true if size > 1
            std::set<std::string>::const_iterator it = expandedmacros.begin();
            if (it == expandedmacros.end())
                return false;
            ++it;
            return (it != expandedmacros.end());
        }",9,9,externals/simplecpp/simplecpp.cpp,simplecpp.Macro.isReplaced:bool(std.set<std.string>&),<empty>,,false,2296,2303,isReplaced,,,27,bool(std.set<std.string>&)
111669149945,METHOD,MyMutex,TYPE_DECL,"MyMutex() {
        InitializeCriticalSection(&m_criticalSection);
    }",5,5,externals/simplecpp/simplecpp.cpp,MyMutex.MyMutex:ANY(),<empty>,,false,2383,2385,MyMutex,,,1,ANY()
111669149946,METHOD,MyMutex,TYPE_DECL,"~MyMutex() {
        DeleteCriticalSection(&m_criticalSection);
    }",5,5,externals/simplecpp/simplecpp.cpp,MyMutex.~MyMutex:ANY(),<empty>,,false,2387,2389,~MyMutex,,,2,ANY()
111669149947,METHOD,MyMutex,TYPE_DECL,"CRITICAL_SECTION* lock() {
        return &m_criticalSection;
    }",5,5,externals/simplecpp/simplecpp.cpp,MyMutex.lock:CRITICAL_SECTION(),<empty>,,false,2391,2393,lock,,,3,CRITICAL_SECTION()
111669149948,METHOD,MyLock,TYPE_DECL,"explicit MyLock(T& m)
        : m_mutex(m) {
        EnterCriticalSection(m_mutex.lock());
    }",5,5,externals/simplecpp/simplecpp.cpp,MyLock.MyLock:ANY(T&),<empty>,,false,2401,2404,MyLock,,,1,MyLock.MyLock:ANY(T&)(T&)
111669149949,METHOD,MyLock,TYPE_DECL,"~MyLock() {
        LeaveCriticalSection(m_mutex.lock());
    }",5,5,externals/simplecpp/simplecpp.cpp,MyLock.~MyLock:ANY(),<empty>,,false,2406,2408,~MyLock,,,2,ANY()
111669149950,METHOD,RealFileNameMap,TYPE_DECL,RealFileNameMap() {},5,24,externals/simplecpp/simplecpp.cpp,RealFileNameMap.RealFileNameMap:ANY(),<empty>,,false,2420,2420,RealFileNameMap,,,1,ANY()
111669149951,METHOD,RealFileNameMap,TYPE_DECL,"bool getCacheEntry(const std::string& path, std::string& returnPath) {
        MyLock<MyMutex> lock(m_mutex);

        const std::map<std::string, std::string>::iterator it = m_fileMap.find(path);
        if (it != m_fileMap.end()) {
            returnPath = it->second;
            return true;
        }
        return false;
    }",5,5,externals/simplecpp/simplecpp.cpp,"RealFileNameMap.getCacheEntry:bool(std.string&,std.string&)",<empty>,,false,2422,2431,getCacheEntry,,,2,"bool(std.string&,std.string&)"
111669149952,METHOD,RealFileNameMap,TYPE_DECL,"void addToCache(const std::string& path, const std::string& actualPath) {
        MyLock<MyMutex> lock(m_mutex);
        m_fileMap[path] = actualPath;
    }",5,5,externals/simplecpp/simplecpp.cpp,"RealFileNameMap.addToCache:void(std.string&,std.string&)",<empty>,,false,2433,2436,addToCache,,,3,"void(std.string&,std.string&)"
111669149953,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static bool realFileName(const std::string &f, std::string &result)
{
    // are there alpha characters in last subpath?
    bool alpha = false;
    for (std::string::size_type pos = 1; pos <= f.size(); ++pos) {
        const unsigned char c = f[f.size() - pos];
        if (c == '/' || c == '\\\\')
            break;
        if (std::isalpha(c)) {
            alpha = true;
            break;
        }
    }

    // do not convert this path if there are no alpha characters (either pointless or cause wrong results for . and ..)
    if (!alpha)
        return false;

    // Lookup filename or foldername on file system
    if (!realFileNameMap.getCacheEntry(f, result)) {

        WIN32_FIND_DATAA FindFileData;

#ifdef __CYGWIN__
        const std::string fConverted = simplecpp::convertCygwinToWindowsPath(f);
        const HANDLE hFind = FindFirstFileExA(fConverted.c_str(), FindExInfoBasic, &FindFileData, FindExSearchNameMatch, NULL, 0);
#else
        HANDLE hFind = FindFirstFileExA(f.c_st...",1,1,externals/simplecpp/simplecpp.cpp,"realFileName:bool(std.string&,std.string&)",<empty>,,false,2445,2482,realFileName,,,1,"bool(std.string&,std.string&)"
111669149954,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static std::string realFilename(const std::string &f)
{
    std::string ret;
    ret.reserve(f.size()); // this will be the final size
    if (realFilePathMap.getCacheEntry(f, ret))
        return ret;

    // Current subpath
    std::string subpath;

    for (std::string::size_type pos = 0; pos < f.size(); ++pos) {
        const unsigned char c = f[pos];

        // Separator.. add subpath and separator
        if (c == '/' || c == '\\\\') {
            // if subpath is empty just add separator
            if (subpath.empty()) {
                ret += c;
                continue;
            }

            const bool isDriveSpecification =
                (pos == 2 && subpath.size() == 2 && std::isalpha(subpath[0]) && subpath[1] == ':');

            // Append real filename (proper case)
            std::string f2;
            if (!isDriveSpecification && realFileName(f.substr(0, pos), f2))
                ret += f2;
            else
                ret += subpath;

            subpa...",1,1,externals/simplecpp/simplecpp.cpp,realFilename:string(std.string&),<empty>,,false,2487,2537,realFilename,,,1,string(std.string&)
111669149955,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static bool isAbsolutePath(const std::string &path)
{
    if (path.length() >= 3 && path[0] > 0 && std::isalpha(path[0]) && path[1] == ':' && (path[2] == '\\\\' || path[2] == '/'))
        return true;
    return path.length() > 1U && (path[0] == '/' || path[0] == '\\\\');
}",1,1,externals/simplecpp/simplecpp.cpp,isAbsolutePath:bool(std.string&),<empty>,,false,2539,2544,isAbsolutePath,,,1,bool(std.string&)
111669149956,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static bool isAbsolutePath(const std::string &path)
{
    return path.length() > 1U && path[0] == '/';
}",1,1,externals/simplecpp/simplecpp.cpp,isAbsolutePath<duplicate>0:bool(std.string&),<empty>,,false,2548,2551,isAbsolutePath,,,1,bool(std.string&)
111669149957,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"std::string simplifyPath(std::string path)
    {
        if (path.empty())
            return path;

        std::string::size_type pos;

        // replace backslash separators
        std::replace(path.begin(), path.end(), '\\\\', '/');

        const bool unc(path.compare(0,2,""//"") == 0);

        // replace ""//"" with ""/""
        pos = 0;
        while ((pos = path.find(""//"",pos)) != std::string::npos) {
            path.erase(pos,1);
        }

        // remove ""./""
        pos = 0;
        while ((pos = path.find(""./"",pos)) != std::string::npos) {
            if (pos == 0 || path[pos - 1U] == '/')
                path.erase(pos,2);
            else
                pos += 2;
        }

        // remove trailing dot if path ends with ""/.""
        if (endsWith(path,""/.""))
            path.erase(path.size()-1);

        // simplify ""..""
        pos = 1; // don't simplify "".."" if path starts with that
        while ((pos = path.find(""/.."", pos)) != std::string::npos) {
            /...",5,56,externals/simplecpp/simplecpp.cpp,simplecpp.simplifyPath:string(std.string),<empty>,,false,2558,2627,simplifyPath,,,1,string(std.string)
111669149958,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static void simplifySizeof(simplecpp::TokenList &expr, const std::map<std::string, std::size_t> &sizeOfType)
{
    for (simplecpp::Token *tok = expr.front(); tok; tok = tok->next) {
        if (tok->str() != ""sizeof"")
            continue;
        simplecpp::Token *tok1 = tok->next;
        if (!tok1) {
            throw std::runtime_error(""missing sizeof argument"");
        }
        simplecpp::Token *tok2 = tok1->next;
        if (!tok2) {
            throw std::runtime_error(""missing sizeof argument"");
        }
        if (tok1->op == '(') {
            tok1 = tok1->next;
            while (tok2->op != ')') {
                tok2 = tok2->next;
                if (!tok2) {
                    throw std::runtime_error(""invalid sizeof expression"");
                }
            }
        }

        std::string type;
        for (simplecpp::Token *typeToken = tok1; typeToken != tok2; typeToken = typeToken->next) {
            if ((typeToken->str() == ""unsigned"" || typeToken->str() =...",1,1,externals/simplecpp/simplecpp.cpp,"simplifySizeof:void(simplecpp.TokenList&,std.map<std.string,std.size_t>&)",<empty>,,false,2631,2675,simplifySizeof,,,1,"void(simplecpp.TokenList&,std.map<std.string,std.size_t>&)"
111669149959,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static bool isCpp17OrLater(const simplecpp::DUI &dui)
{
    const std::string std_ver = simplecpp::getCppStdString(dui.std);
    return !std_ver.empty() && (std_ver >= ""201703L"");
}",1,1,externals/simplecpp/simplecpp.cpp,isCpp17OrLater:bool(simplecpp.DUI&),<empty>,,false,2678,2682,isCpp17OrLater,,,1,bool(simplecpp.DUI&)
111669149960,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static void simplifyHasInclude(simplecpp::TokenList &expr, const simplecpp::DUI &dui)
{
    if (!isCpp17OrLater(dui))
        return;

    for (simplecpp::Token *tok = expr.front(); tok; tok = tok->next) {
        if (tok->str() != HAS_INCLUDE)
            continue;
        simplecpp::Token *tok1 = tok->next;
        if (!tok1) {
            throw std::runtime_error(""missing __has_include argument"");
        }
        simplecpp::Token *tok2 = tok1->next;
        if (!tok2) {
            throw std::runtime_error(""missing __has_include argument"");
        }
        if (tok1->op == '(') {
            tok1 = tok1->next;
            while (tok2->op != ')') {
                tok2 = tok2->next;
                if (!tok2) {
                    throw std::runtime_error(""invalid __has_include expression"");
                }
            }
        }

        const std::string &sourcefile = tok->location.file();
        const bool systemheader = (tok1 && tok1->op == '<');
        std::string hea...",1,21,externals/simplecpp/simplecpp.cpp,"simplifyHasInclude:void(simplecpp.TokenList&,simplecpp.DUI&)",<empty>,,false,2685,2741,simplifyHasInclude,,,1,"void(simplecpp.TokenList&,simplecpp.DUI&)"
111669149961,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static void simplifyName(simplecpp::TokenList &expr)
{
    for (simplecpp::Token *tok = expr.front(); tok; tok = tok->next) {
        if (tok->name) {
            if (altop.find(tok->str()) != altop.end()) {
                bool alt;
                if (tok->str() == ""not"" || tok->str() == ""compl"") {
                    alt = isAlternativeUnaryOp(tok,tok->str());
                } else {
                    alt = isAlternativeBinaryOp(tok,tok->str());
                }
                if (alt)
                    continue;
            }
            tok->setstr(""0"");
        }
    }
}",1,1,externals/simplecpp/simplecpp.cpp,simplifyName:void(simplecpp.TokenList&),<empty>,,false,2745,2762,simplifyName,,,1,void(simplecpp.TokenList&)
111669149962,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static unsigned long long stringToULLbounded(
    const std::string& s,
    std::size_t& pos,
    int base = 0,
    std::ptrdiff_t minlen = 1,
    std::size_t maxlen = std::string::npos
)
{
    const std::string sub = s.substr(pos, maxlen);
    const char * const start = sub.c_str();
    char* end;
    const unsigned long long value = std::strtoull(start, &end, base);
    pos += end - start;
    if (end - start < minlen)
        throw std::runtime_error(""expected digit"");
    return value;
}",1,1,externals/simplecpp/simplecpp.cpp,"stringToULLbounded:longlong(std.string&,std.size_t&,int,std.ptrdiff_t,std.size_t)",<empty>,,false,2772,2788,stringToULLbounded,,,1,"longlong(std.string&,std.size_t&,int,std.ptrdiff_t,std.size_t)"
111669149963,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"long long simplecpp::characterLiteralToLL(const std::string& str)
{
    // default is wide/utf32
    bool narrow = false;
    bool utf8 = false;
    bool utf16 = false;

    std::size_t pos;

    if (!str.empty() && str[0] == '\\'') {
        narrow = true;
        pos = 1;
    } else if (str.size() >= 2 && str[0] == 'u' && str[1] == '\\'') {
        utf16 = true;
        pos = 2;
    } else if (str.size() >= 3 && str[0] == 'u' && str[1] == '8' && str[2] == '\\'') {
        utf8 = true;
        pos = 3;
    } else if (str.size() >= 2 && (str[0] == 'L' || str[0] == 'U') && str[1] == '\\'') {
        pos = 2;
    } else
        throw std::runtime_error(""expected a character literal"");

    unsigned long long multivalue = 0;

    std::size_t nbytes = 0;

    while (pos + 1 < str.size()) {
        if (str[pos] == '\\'' || str[pos] == '\\n')
            throw std::runtime_error(""raw single quotes and newlines not allowed in character literals"");

        if (nbytes >= 1 && !narrow)
           ...",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.characterLiteralToLL:longlong(std.string&),<empty>,,false,2818,3009,characterLiteralToLL,,,1,longlong(std.string&)
111669149964,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static void simplifyNumbers(simplecpp::TokenList &expr)
{
    for (simplecpp::Token *tok = expr.front(); tok; tok = tok->next) {
        if (tok->str().size() == 1U)
            continue;
        if (tok->str().compare(0,2,""0x"") == 0)
            tok->setstr(toString(stringToULL(tok->str())));
        else if (!tok->number && tok->str().find('\\'') != std::string::npos)
            tok->setstr(toString(simplecpp::characterLiteralToLL(tok->str())));
    }
}",1,1,externals/simplecpp/simplecpp.cpp,simplifyNumbers:void(simplecpp.TokenList&),<empty>,,false,3011,3021,simplifyNumbers,,,1,void(simplecpp.TokenList&)
111669149965,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static void simplifyComments(simplecpp::TokenList &expr)
{
    for (simplecpp::Token *tok = expr.front(); tok;) {
        simplecpp::Token * const d = tok;
        tok = tok->next;
        if (d->comment)
            expr.deleteToken(d);
    }
}",1,1,externals/simplecpp/simplecpp.cpp,simplifyComments:void(simplecpp.TokenList&),<empty>,,false,3023,3031,simplifyComments,,,1,void(simplecpp.TokenList&)
111669149966,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static long long evaluate(simplecpp::TokenList &expr, const simplecpp::DUI &dui, const std::map<std::string, std::size_t> &sizeOfType)
{
    simplifyComments(expr);
    simplifySizeof(expr, sizeOfType);
    simplifyHasInclude(expr, dui);
    simplifyName(expr);
    simplifyNumbers(expr);
    expr.constFold();
    // TODO: handle invalid expressions
    return expr.cfront() && expr.cfront() == expr.cback() && expr.cfront()->number ? stringToLL(expr.cfront()->str()) : 0LL;
}",1,1,externals/simplecpp/simplecpp.cpp,"evaluate:longlong(simplecpp.TokenList&,simplecpp.DUI&,std.map<std.string,std.size_t>&)",<empty>,,false,3033,3043,evaluate,,,1,"longlong(simplecpp.TokenList&,simplecpp.DUI&,std.map<std.string,std.size_t>&)"
111669149967,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static const simplecpp::Token *gotoNextLine(const simplecpp::Token *tok)
{
    const unsigned int line = tok->location.line;
    const unsigned int file = tok->location.fileIndex;
    while (tok && tok->location.line == line && tok->location.fileIndex == file)
        tok = tok->next;
    return tok;
}",1,1,externals/simplecpp/simplecpp.cpp,gotoNextLine:simplecpp.Token*(simplecpp.Token*),<empty>,,false,3045,3052,gotoNextLine,,,1,simplecpp.Token*(simplecpp.Token*)
111669149968,METHOD,NonExistingFilesCache,TYPE_DECL,NonExistingFilesCache() {},5,30,externals/simplecpp/simplecpp.cpp,NonExistingFilesCache.NonExistingFilesCache:ANY(),<empty>,,false,3058,3058,NonExistingFilesCache,,,1,ANY()
111669149969,METHOD,NonExistingFilesCache,TYPE_DECL,"bool contains(const std::string& path) {
        MyLock<MyMutex> lock(m_mutex);
        return (m_pathSet.find(path) != m_pathSet.end());
    }",5,5,externals/simplecpp/simplecpp.cpp,NonExistingFilesCache.contains:bool(std.string&),<empty>,,false,3060,3063,contains,,,2,bool(std.string&)
111669149970,METHOD,NonExistingFilesCache,TYPE_DECL,"void add(const std::string& path) {
        MyLock<MyMutex> lock(m_mutex);
        m_pathSet.insert(path);
    }",5,5,externals/simplecpp/simplecpp.cpp,NonExistingFilesCache.add:void(std.string&),<empty>,,false,3065,3068,add,,,3,void(std.string&)
111669149971,METHOD,NonExistingFilesCache,TYPE_DECL,"void clear() {
        MyLock<MyMutex> lock(m_mutex);
        m_pathSet.clear();
    }",5,5,externals/simplecpp/simplecpp.cpp,NonExistingFilesCache.clear:void(),<empty>,,false,3070,3073,clear,,,4,void()
111669149972,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static std::string openHeader(std::ifstream &f, const std::string &path)
{
    std::string simplePath = simplecpp::simplifyPath(path);
#ifdef SIMPLECPP_WINDOWS
    if (nonExistingFilesCache.contains(simplePath))
        return """";  // file is known not to exist, skip expensive file open call
#endif
    f.open(simplePath.c_str());
    if (f.is_open())
        return simplePath;
#ifdef SIMPLECPP_WINDOWS
    nonExistingFilesCache.add(simplePath);
#endif
    return """";
}",1,1,externals/simplecpp/simplecpp.cpp,"openHeader:string(std.ifstream&,std.string&)",<empty>,,false,3084,3098,openHeader,,,1,"string(std.ifstream&,std.string&)"
111669149973,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static std::string getRelativeFileName(const std::string &sourcefile, const std::string &header)
{
    if (sourcefile.find_first_of(""\\\\/"") != std::string::npos)
        return simplecpp::simplifyPath(sourcefile.substr(0, sourcefile.find_last_of(""\\\\/"") + 1U) + header);
    return simplecpp::simplifyPath(header);
}",1,1,externals/simplecpp/simplecpp.cpp,"getRelativeFileName:string(std.string&,std.string&)",<empty>,,false,3100,3105,getRelativeFileName,,,1,"string(std.string&,std.string&)"
111669149974,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static std::string openHeaderRelative(std::ifstream &f, const std::string &sourcefile, const std::string &header)
{
    return openHeader(f, getRelativeFileName(sourcefile, header));
}",1,1,externals/simplecpp/simplecpp.cpp,"openHeaderRelative:string(std.ifstream&,std.string&,std.string&)",<empty>,,false,3107,3110,openHeaderRelative,,,1,"string(std.ifstream&,std.string&,std.string&)"
111669149975,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static std::string getIncludePathFileName(const std::string &includePath, const std::string &header)
{
    std::string path = includePath;
    if (!path.empty() && path[path.size()-1U]!='/' && path[path.size()-1U]!='\\\\')
        path += '/';
    return path + header;
}",1,1,externals/simplecpp/simplecpp.cpp,"getIncludePathFileName:string(std.string&,std.string&)",<empty>,,false,3112,3118,getIncludePathFileName,,,1,"string(std.string&,std.string&)"
111669149976,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static std::string openHeaderIncludePath(std::ifstream &f, const simplecpp::DUI &dui, const std::string &header)
{
    for (std::list<std::string>::const_iterator it = dui.includePaths.begin(); it != dui.includePaths.end(); ++it) {
        std::string simplePath = openHeader(f, getIncludePathFileName(*it, header));
        if (!simplePath.empty())
            return simplePath;
    }
    return """";
}",1,1,externals/simplecpp/simplecpp.cpp,"openHeaderIncludePath:string(std.ifstream&,simplecpp.DUI&,std.string&)",<empty>,,false,3120,3128,openHeaderIncludePath,,,1,"string(std.ifstream&,simplecpp.DUI&,std.string&)"
111669149977,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static std::string openHeader(std::ifstream &f, const simplecpp::DUI &dui, const std::string &sourcefile, const std::string &header, bool systemheader)
{
    if (isAbsolutePath(header))
        return openHeader(f, header);

    std::string ret;

    if (systemheader) {
        ret = openHeaderIncludePath(f, dui, header);
        return ret;
    }

    ret = openHeaderRelative(f, sourcefile, header);
    if (ret.empty())
        return openHeaderIncludePath(f, dui, header);
    return ret;
}",1,1,externals/simplecpp/simplecpp.cpp,"openHeader:string(std.ifstream&,simplecpp.DUI&,std.string&,std.string&,bool)",<empty>,,false,3130,3146,openHeader,,,1,"string(std.ifstream&,simplecpp.DUI&,std.string&,std.string&,bool)"
111669149978,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static std::string getFileName(const std::map<std::string, simplecpp::TokenList *> &filedata, const std::string &sourcefile, const std::string &header, const simplecpp::DUI &dui, bool systemheader)
{
    if (filedata.empty()) {
        return """";
    }
    if (isAbsolutePath(header)) {
        return (filedata.find(header) != filedata.end()) ? simplecpp::simplifyPath(header) : """";
    }

    if (!systemheader) {
        const std::string relativeFilename = getRelativeFileName(sourcefile, header);
        if (filedata.find(relativeFilename) != filedata.end())
            return relativeFilename;
    }

    for (std::list<std::string>::const_iterator it = dui.includePaths.begin(); it != dui.includePaths.end(); ++it) {
        std::string s = simplecpp::simplifyPath(getIncludePathFileName(*it, header));
        if (filedata.find(s) != filedata.end())
            return s;
    }

    if (systemheader && filedata.find(header) != filedata.end())
        return header;

    return """";
}",1,1,externals/simplecpp/simplecpp.cpp,"getFileName:string(std.map<std.string,simplecpp.TokenList*>&,std.string&,std.string&,simplecpp.DUI&,bool)",<empty>,,false,3148,3173,getFileName,,,1,"string(std.map<std.string,simplecpp.TokenList*>&,std.string&,std.string&,simplecpp.DUI&,bool)"
111669149979,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static bool hasFile(const std::map<std::string, simplecpp::TokenList *> &filedata, const std::string &sourcefile, const std::string &header, const simplecpp::DUI &dui, bool systemheader)
{
    return !getFileName(filedata, sourcefile, header, dui, systemheader).empty();
}",1,1,externals/simplecpp/simplecpp.cpp,"hasFile:bool(std.map<std.string,simplecpp.TokenList*>&,std.string&,std.string&,simplecpp.DUI&,bool)",<empty>,,false,3175,3178,hasFile,,,1,"bool(std.map<std.string,simplecpp.TokenList*>&,std.string&,std.string&,simplecpp.DUI&,bool)"
111669149980,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"std::map<std::string, simplecpp::TokenList*> simplecpp::load(const simplecpp::TokenList &rawtokens, std::vector<std::string> &filenames, const simplecpp::DUI &dui, simplecpp::OutputList *outputList)
{
#ifdef SIMPLECPP_WINDOWS
    if (dui.clearIncludeCache)
        nonExistingFilesCache.clear();
#endif

    std::map<std::string, simplecpp::TokenList*> ret;

    std::list<const Token *> filelist;

    // -include files
    for (std::list<std::string>::const_iterator it = dui.includes.begin(); it != dui.includes.end(); ++it) {
        const std::string &filename = realFilename(*it);

        if (ret.find(filename) != ret.end())
            continue;

        std::ifstream fin(filename.c_str());
        if (!fin.is_open()) {
            if (outputList) {
                simplecpp::Output err(filenames);
                err.type = simplecpp::Output::EXPLICIT_INCLUDE_NOT_FOUND;
                err.location = Location(filenames);
                err.msg = ""Can not open include file '"" + fi...",1,38,externals/simplecpp/simplecpp.cpp,"simplecpp.load:map<std.string,simplecpp.TokenList*>(simplecpp.TokenList&,std.vector<std.string>&,simplecpp.DUI&,simplecpp.OutputList*)",<empty>,,false,3180,3262,load,,,1,"map<std::string,simplecpp::TokenList*>(simplecpp.TokenList&,std.vector<std.string>&,simplecpp.DUI&,simplecpp.OutputList*)"
111669149981,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static bool preprocessToken(simplecpp::TokenList &output, const simplecpp::Token **tok1, simplecpp::MacroMap &macros, std::vector<std::string> &files, simplecpp::OutputList *outputList)
{
    const simplecpp::Token * const tok = *tok1;
    const simplecpp::MacroMap::const_iterator it = macros.find(tok->str());
    if (it != macros.end()) {
        simplecpp::TokenList value(files);
        try {
            *tok1 = it->second.expand(&value, tok, macros, files);
        } catch (simplecpp::Macro::Error &err) {
            if (outputList) {
                simplecpp::Output out(files);
                out.type = simplecpp::Output::SYNTAX_ERROR;
                out.location = err.location;
                out.msg = ""failed to expand \\'"" + tok->str() + ""\\', "" + err.what;
                outputList->push_back(out);
            }
            return false;
        }
        output.takeTokens(value);
    } else {
        if (!tok->comment)
            output.push_back(new simplecpp::Token(*...",1,1,externals/simplecpp/simplecpp.cpp,"preprocessToken:bool(simplecpp.TokenList&,simplecpp.Token**,simplecpp.MacroMap&,std.vector<std.string>&,simplecpp.OutputList*)",<empty>,,false,3264,3289,preprocessToken,,,1,"bool(simplecpp.TokenList&,simplecpp.Token**,simplecpp.MacroMap&,std.vector<std.string>&,simplecpp.OutputList*)"
111669149982,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static void getLocaltime(struct tm &ltime)
{
    time_t t;
    time(&t);
#ifndef _WIN32
    // NOLINTNEXTLINE(misc-include-cleaner) - false positive
    localtime_r(&t, &ltime);
#else
    localtime_s(&ltime, &t);
#endif
}",1,1,externals/simplecpp/simplecpp.cpp,getLocaltime:void(tm&),<empty>,,false,3291,3301,getLocaltime,,,1,void(tm&)
111669149983,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static std::string getDateDefine(const struct tm *timep)
{
    char buf[] = ""??? ?? ????"";
    strftime(buf, sizeof(buf), ""%b %d %Y"", timep);
    return std::string(""\\"""").append(buf).append(""\\"""");
}",1,1,externals/simplecpp/simplecpp.cpp,getDateDefine:string(tm*),<empty>,,false,3303,3308,getDateDefine,,,1,string(tm*)
111669149984,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static std::string getTimeDefine(const struct tm *timep)
{
    char buf[] = ""??:??:??"";
    strftime(buf, sizeof(buf), ""%T"", timep);
    return std::string(""\\"""").append(buf).append(""\\"""");
}",1,1,externals/simplecpp/simplecpp.cpp,getTimeDefine:string(tm*),<empty>,,false,3310,3315,getTimeDefine,,,1,string(tm*)
111669149985,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::preprocess(simplecpp::TokenList &output, const simplecpp::TokenList &rawtokens, std::vector<std::string> &files, std::map<std::string, simplecpp::TokenList *> &filedata, const simplecpp::DUI &dui, simplecpp::OutputList *outputList, std::list<simplecpp::MacroUsage> *macroUsage, std::list<simplecpp::IfCond> *ifCond)
{
#ifdef SIMPLECPP_WINDOWS
    if (dui.clearIncludeCache)
        nonExistingFilesCache.clear();
#endif

    std::map<std::string, std::size_t> sizeOfType(rawtokens.sizeOfType);
    sizeOfType.insert(std::make_pair(""char"", sizeof(char)));
    sizeOfType.insert(std::make_pair(""short"", sizeof(short)));
    sizeOfType.insert(std::make_pair(""short int"", sizeOfType[""short""]));
    sizeOfType.insert(std::make_pair(""int"", sizeof(int)));
    sizeOfType.insert(std::make_pair(""long"", sizeof(long)));
    sizeOfType.insert(std::make_pair(""long int"", sizeOfType[""long""]));
    sizeOfType.insert(std::make_pair(""long long"", sizeof(long long)));
    sizeOfType.insert(std::m...",1,41,externals/simplecpp/simplecpp.cpp,"simplecpp.preprocess:void(simplecpp.TokenList&,simplecpp.TokenList&,std.vector<std.string>&,std.map<std.string,simplecpp.TokenList*>&,simplecpp.DUI&,simplecpp.OutputList*,std.list<simplecpp.MacroUsage>*,std.list<simplecpp.IfCond>*)",<empty>,,false,3317,3793,preprocess,,,1,"void(simplecpp.TokenList&,simplecpp.TokenList&,std.vector<std.string>&,std.map<std.string,simplecpp.TokenList*>&,simplecpp.DUI&,simplecpp.OutputList*,std.list<simplecpp.MacroUsage>*,std.list<simplecpp.IfCond>*)"
111669149986,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"void simplecpp::cleanup(std::map<std::string, TokenList*> &filedata)
{
    for (std::map<std::string, TokenList*>::iterator it = filedata.begin(); it != filedata.end(); ++it)
        delete it->second;
    filedata.clear();
}",1,1,externals/simplecpp/simplecpp.cpp,"simplecpp.cleanup:void(std.map<std.string,TokenList*>&)",<empty>,,false,3795,3800,cleanup,,,1,"void(std.map<std.string,TokenList*>&)"
111669149987,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"simplecpp::cstd_t simplecpp::getCStd(const std::string &std)
{
    if (std == ""c90"" || std == ""c89"" || std == ""iso9899:1990"" || std == ""iso9899:199409"" || std == ""gnu90"" || std == ""gnu89"")
        return C89;
    if (std == ""c99"" || std == ""c9x"" || std == ""iso9899:1999"" || std == ""iso9899:199x"" || std == ""gnu99""|| std == ""gnu9x"")
        return C99;
    if (std == ""c11"" || std == ""c1x"" || std == ""iso9899:2011"" || std == ""gnu11"" || std == ""gnu1x"")
        return C11;
    if (std == ""c17"" || std == ""c18"" || std == ""iso9899:2017"" || std == ""iso9899:2018"" || std == ""gnu17""|| std == ""gnu18"")
        return C17;
    if (std == ""c23"" || std == ""gnu23"" || std == ""c2x"" || std == ""gnu2x"")
        return C23;
    return CUnknown;
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.getCStd:simplecpp.cstd_t(std.string&),<empty>,,false,3802,3815,getCStd,,,1,simplecpp.cstd_t(std.string&)
111669149988,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"std::string simplecpp::getCStdString(cstd_t std)
{
    switch (std) {
    case C89:
        // __STDC_VERSION__ is not set for C90 although the macro was added in the 1994 amendments
        return """";
    case C99:
        return ""199901L"";
    case C11:
        return ""201112L"";
    case C17:
        return ""201710L"";
    case C23:
        // supported by GCC 9+ and Clang 9+
        // Clang 9, 10, 11, 12, 13 return ""201710L""
        // Clang 14, 15, 16, 17 return ""202000L""
        // Clang 9, 10, 11, 12, 13, 14, 15, 16, 17 do not support ""c23"" and ""gnu23""
        return ""202311L"";
    case CUnknown:
        return """";
    }
    return """";
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.getCStdString:string(simplecpp.cstd_t),<empty>,,false,3817,3839,getCStdString,,,1,string(simplecpp.cstd_t)
111669149989,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"std::string simplecpp::getCStdString(const std::string &std)
{
    return getCStdString(getCStd(std));
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.getCStdString:string(std.string&),<empty>,,false,3841,3844,getCStdString,,,1,string(std.string&)
111669149990,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"simplecpp::cppstd_t simplecpp::getCppStd(const std::string &std)
{
    if (std == ""c++98"" || std == ""c++03"" || std == ""gnu++98"" || std == ""gnu++03"")
        return CPP03;
    if (std == ""c++11"" || std == ""gnu++11"" || std == ""c++0x"" || std == ""gnu++0x"")
        return CPP11;
    if (std == ""c++14"" || std == ""c++1y"" || std == ""gnu++14"" || std == ""gnu++1y"")
        return CPP14;
    if (std == ""c++17"" || std == ""c++1z"" || std == ""gnu++17"" || std == ""gnu++1z"")
        return CPP17;
    if (std == ""c++20"" || std == ""c++2a"" || std == ""gnu++20"" || std == ""gnu++2a"")
        return CPP20;
    if (std == ""c++23"" || std == ""c++2b"" || std == ""gnu++23"" || std == ""gnu++2b"")
        return CPP23;
    if (std == ""c++26"" || std == ""c++2c"" || std == ""gnu++26"" || std == ""gnu++2c"")
        return CPP26;
    return CPPUnknown;
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.getCppStd:simplecpp.cppstd_t(std.string&),<empty>,,false,3846,3863,getCppStd,,,1,simplecpp.cppstd_t(std.string&)
111669149991,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"std::string simplecpp::getCppStdString(cppstd_t std)
{
    switch (std) {
    case CPP03:
        return ""199711L"";
    case CPP11:
        return ""201103L"";
    case CPP14:
        return ""201402L"";
    case CPP17:
        return ""201703L"";
    case CPP20:
        // GCC 10 returns ""201703L"" - correct in 11+
        return ""202002L"";
    case CPP23:
        // supported by GCC 11+ and Clang 12+
        // GCC 11, 12, 13 return ""202100L""
        // Clang 12, 13, 14, 15, 16 do not support ""c++23"" and ""gnu++23"" and return ""202101L""
        // Clang 17, 18 return ""202302L""
        return ""202302L"";
    case CPP26:
        // supported by Clang 17+
        return ""202400L"";
    case CPPUnknown:
        return """";
    }
    return """";
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.getCppStdString:string(simplecpp.cppstd_t),<empty>,,false,3865,3892,getCppStdString,,,1,string(simplecpp.cppstd_t)
111669149992,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"std::string simplecpp::getCppStdString(const std::string &std)
{
    return getCppStdString(getCppStd(std));
}",1,1,externals/simplecpp/simplecpp.cpp,simplecpp.getCppStdString:string(std.string&),<empty>,,false,3894,3897,getCppStdString,,,1,string(std.string&)
111669149993,METHOD,externals/simplecpp/simplecpp.h:<global>,TYPE_DECL,<global>,1,10,externals/simplecpp/simplecpp.h,externals/simplecpp/simplecpp.h:<global>,<empty>,,false,1,402,<global>,,,1,
111669149994,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"static inline int TIXML_SNPRINTF( char* buffer, size_t size, const char* format, ... )
	{
		va_list va;
		va_start( va, format );
		const int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );
		va_end( va );
		return result;
	}",2,2,externals/tinyxml2/tinyxml2.cpp,"TIXML_SNPRINTF:int(char*,size_t,char*...)",<empty>,,false,44,51,TIXML_SNPRINTF,,,1,"int(char*,size_t,char*...)"
111669149995,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,<global>,1,1,externals/tinyxml2/tinyxml2.cpp,externals/tinyxml2/tinyxml2.cpp:<global>,<empty>,,false,1,3031,<global>,,,1,
111669149996,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"static inline int TIXML_VSNPRINTF( char* buffer, size_t size, const char* format, va_list va )
	{
		const int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );
		return result;
	}",2,2,externals/tinyxml2/tinyxml2.cpp,"TIXML_VSNPRINTF:int(char*,size_t,char*,va_list)",<empty>,,false,53,57,TIXML_VSNPRINTF,,,1,"int(char*,size_t,char*,va_list)"
111669149997,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"static inline int TIXML_VSCPRINTF( const char* format, va_list va )
		{
			int len = 512;
			for (;;) {
				len = len*2;
				char* str = new char[len]();
				const int required = _vsnprintf(str, len, format, va);
				delete[] str;
				if ( required != -1 ) {
					TIXMLASSERT( required >= 0 );
					len = required;
					break;
				}
			}
			TIXMLASSERT( len >= 0 );
			return len;
		}",3,5,externals/tinyxml2/tinyxml2.cpp,"TIXML_VSCPRINTF:int(char*,va_list)",<empty>,,false,71,87,TIXML_VSCPRINTF,,,1,"int(char*,va_list)"
111669149998,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"static inline int TIXML_VSCPRINTF( const char* format, va_list va )
	{
		int len = vsnprintf( 0, 0, format, va );
		TIXMLASSERT( len >= 0 );
		return len;
	}",2,2,externals/tinyxml2/tinyxml2.cpp,"TIXML_VSCPRINTF<duplicate>0:int(char*,va_list)",<empty>,,false,94,99,TIXML_VSCPRINTF,,,1,"int(char*,va_list)"
111669149999,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"StrPair::~StrPair()
{
    Reset();
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.StrPair.~StrPair:ANY(),<empty>,,false,157,160,~StrPair,,,1,ANY()
111669150000,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void StrPair::TransferTo( StrPair* other )
{
    if ( this == other ) {
        return;
    }
    // This in effect implements the assignment operator by ""moving""
    // ownership (as in auto_ptr).

    TIXMLASSERT( other != 0 );
    TIXMLASSERT( other->_flags == 0 );
    TIXMLASSERT( other->_start == 0 );
    TIXMLASSERT( other->_end == 0 );

    other->Reset();

    other->_flags = _flags;
    other->_start = _start;
    other->_end = _end;

    _flags = 0;
    _start = 0;
    _end = 0;
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.StrPair.TransferTo:void(tinyxml2.StrPair*),<empty>,,false,163,185,TransferTo,,,1,void(tinyxml2.StrPair*)
111669150001,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void StrPair::Reset()
{
    if ( _flags & NEEDS_DELETE ) {
        delete [] _start;
    }
    _flags = 0;
    _start = 0;
    _end = 0;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.StrPair.Reset:void(),<empty>,,false,188,196,Reset,,,1,void()
111669150002,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void StrPair::SetStr( const char* str, int flags )
{
    TIXMLASSERT( str );
    Reset();
    size_t len = strlen( str );
    TIXMLASSERT( _start == 0 );
    _start = new char[ len+1 ];
    memcpy( _start, str, len+1 );
    _end = _start + len;
    _flags = flags | NEEDS_DELETE;
}",1,4,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.StrPair.SetStr:void(char*,int)",<empty>,,false,199,209,SetStr,,,1,"void(char*,int)"
111669150003,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"char* StrPair::ParseText( char* p, const char* endTag, int strFlags, int* curLineNumPtr )
{
    TIXMLASSERT( p );
    TIXMLASSERT( endTag && *endTag );
	TIXMLASSERT(curLineNumPtr);

    char* start = p;
    const char  endChar = *endTag;
    size_t length = strlen( endTag );

    // Inner loop of text parsing.
    while ( *p ) {
        if ( *p == endChar && strncmp( p, endTag, length ) == 0 ) {
            Set( start, p, strFlags );
            return p + length;
        } else if (*p == '\\n') {
            ++(*curLineNumPtr);
        }
        ++p;
        TIXMLASSERT( p );
    }
    return 0;
}",1,4,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.StrPair.ParseText:char*(char*,char*,int,int*)",<empty>,,false,212,234,ParseText,,,1,"char*(char*,char*,int,int*)"
111669150004,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"char* StrPair::ParseName( char* p )
{
    if ( !p || !(*p) ) {
        return 0;
    }
    if ( !XMLUtil::IsNameStartChar( (unsigned char) *p ) ) {
        return 0;
    }

    char* const start = p;
    ++p;
    while ( *p && XMLUtil::IsNameChar( (unsigned char) *p ) ) {
        ++p;
    }

    Set( start, p, 0 );
    return p;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.StrPair.ParseName:char*(char*),<empty>,,false,237,254,ParseName,,,1,char*(char*)
111669150005,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void StrPair::CollapseWhitespace()
{
    // Adjusting _start would cause undefined behavior on delete[]
    TIXMLASSERT( ( _flags & NEEDS_DELETE ) == 0 );
    // Trim leading space.
    _start = XMLUtil::SkipWhiteSpace( _start, 0 );

    if ( *_start ) {
        const char* p = _start;	// the read pointer
        char* q = _start;	// the write pointer

        while( *p ) {
            if ( XMLUtil::IsWhiteSpace( *p )) {
                p = XMLUtil::SkipWhiteSpace( p, 0 );
                if ( *p == 0 ) {
                    break;    // don't write to q; this trims the trailing space.
                }
                *q = ' ';
                ++q;
            }
            *q = *p;
            ++q;
            ++p;
        }
        *q = 0;
    }
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.StrPair.CollapseWhitespace:void(),<empty>,,false,257,283,CollapseWhitespace,,,1,void()
111669150006,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"const char* StrPair::GetStr()
{
    TIXMLASSERT( _start );
    TIXMLASSERT( _end );
    if ( _flags & NEEDS_FLUSH ) {
        *_end = 0;
        _flags ^= NEEDS_FLUSH;

        if ( _flags ) {
            const char* p = _start;	// the read pointer
            char* q = _start;	// the write pointer

            while( p < _end ) {
                if ( (_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == CR ) {
                    // CR-LF pair becomes LF
                    // CR alone becomes LF
                    // LF-CR becomes LF
                    if ( *(p+1) == LF ) {
                        p += 2;
                    }
                    else {
                        ++p;
                    }
                    *q = LF;
                    ++q;
                }
                else if ( (_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == LF ) {
                    if ( *(p+1) == CR ) {
                        p += 2;
                    }
                    else {
          ...",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.StrPair.GetStr:char*(),<empty>,,false,286,384,GetStr,,,1,char*()
111669150007,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLUtil::SetBoolSerialization(const char* writeTrue, const char* writeFalse)
{
	static const char* defTrue  = ""true"";
	static const char* defFalse = ""false"";

	writeBoolTrue = (writeTrue) ? writeTrue : defTrue;
	writeBoolFalse = (writeFalse) ? writeFalse : defFalse;
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLUtil.SetBoolSerialization:void(char*,char*)",<empty>,,false,394,401,SetBoolSerialization,,,1,"void(char*,char*)"
111669150008,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"const char* XMLUtil::ReadBOM( const char* p, bool* bom )
{
    TIXMLASSERT( p );
    TIXMLASSERT( bom );
    *bom = false;
    const unsigned char* pu = reinterpret_cast<const unsigned char*>(p);
    // Check for BOM:
    if (    *(pu+0) == TIXML_UTF_LEAD_0
            && *(pu+1) == TIXML_UTF_LEAD_1
            && *(pu+2) == TIXML_UTF_LEAD_2 ) {
        *bom = true;
        p += 3;
    }
    TIXMLASSERT( p );
    return p;
}",1,4,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLUtil.ReadBOM:char*(char*,bool*)",<empty>,,false,404,419,ReadBOM,,,1,"char*(char*,bool*)"
111669150009,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLUtil::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )
{
    const unsigned long BYTE_MASK = 0xBF;
    const unsigned long BYTE_MARK = 0x80;
    const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };

    if (input < 0x80) {
        *length = 1;
    }
    else if ( input < 0x800 ) {
        *length = 2;
    }
    else if ( input < 0x10000 ) {
        *length = 3;
    }
    else if ( input < 0x200000 ) {
        *length = 4;
    }
    else {
        *length = 0;    // This code won't convert this correctly anyway.
        return;
    }

    output += *length;

    // Scary scary fall throughs are annotated with carefully designed comments
    // to suppress compiler warnings such as -Wimplicit-fallthrough in gcc
    switch (*length) {
        case 4:
            --output;
            *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
            input >>= 6;
            //fall through
        case 3:
            -...",1,12,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLUtil.ConvertUTF32ToUTF8:void(longunsigned,char*,int*)",<empty>,,false,422,472,ConvertUTF32ToUTF8,,,1,"void(longunsigned,char*,int*)"
111669150010,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"const char* XMLUtil::GetCharacterRef( const char* p, char* value, int* length )
{
    // Presume an entity, and pull it out.
    *length = 0;

    if ( *(p+1) == '#' && *(p+2) ) {
        unsigned long ucs = 0;
        TIXMLASSERT( sizeof( ucs ) >= 4 );
        ptrdiff_t delta = 0;
        unsigned mult = 1;
        static const char SEMICOLON = ';';

        if ( *(p+2) == 'x' ) {
            // Hexadecimal.
            const char* q = p+3;
            if ( !(*q) ) {
                return 0;
            }

            q = strchr( q, SEMICOLON );

            if ( !q ) {
                return 0;
            }
            TIXMLASSERT( *q == SEMICOLON );

            delta = q-p;
            --q;

            while ( *q != 'x' ) {
                unsigned int digit = 0;

                if ( *q >= '0' && *q <= '9' ) {
                    digit = *q - '0';
                }
                else if ( *q >= 'a' && *q <= 'f' ) {
                    digit = *q - 'a' + 10;
               ...",1,8,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLUtil.GetCharacterRef:char*(char*,char*,int*)",<empty>,,false,475,568,GetCharacterRef,,,1,"char*(char*,char*,int*)"
111669150011,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLUtil::ToStr( int v, char* buffer, int bufferSize )
{
    TIXML_SNPRINTF( buffer, bufferSize, ""%d"", v );
}",1,4,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLUtil.ToStr:void(int,char*,int)",<empty>,,false,571,574,ToStr,,,1,"void(int,char*,int)"
111669150012,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLUtil::ToStr( unsigned v, char* buffer, int bufferSize )
{
    TIXML_SNPRINTF( buffer, bufferSize, ""%u"", v );
}",1,4,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLUtil.ToStr:void(unsigned,char*,int)",<empty>,,false,577,580,ToStr,,,1,"void(unsigned,char*,int)"
111669150013,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLUtil::ToStr( bool v, char* buffer, int bufferSize )
{
    TIXML_SNPRINTF( buffer, bufferSize, ""%s"", v ? writeBoolTrue : writeBoolFalse);
}",1,4,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLUtil.ToStr:void(bool,char*,int)",<empty>,,false,583,586,ToStr,,,1,"void(bool,char*,int)"
111669150014,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLUtil::ToStr( float v, char* buffer, int bufferSize )
{
    TIXML_SNPRINTF( buffer, bufferSize, ""%.8g"", v );
}",1,4,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLUtil.ToStr:void(float,char*,int)",<empty>,,false,592,595,ToStr,,,1,"void(float,char*,int)"
111669150015,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLUtil::ToStr( double v, char* buffer, int bufferSize )
{
    TIXML_SNPRINTF( buffer, bufferSize, ""%.17g"", v );
}",1,4,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLUtil.ToStr:void(double,char*,int)",<empty>,,false,598,601,ToStr,,,1,"void(double,char*,int)"
111669150016,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLUtil::ToStr( int64_t v, char* buffer, int bufferSize )
{
	// horrible syntax trick to make the compiler happy about %lld
	TIXML_SNPRINTF(buffer, bufferSize, ""%lld"", static_cast<long long>(v));
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLUtil.ToStr:void(int64_t,char*,int)",<empty>,,false,604,608,ToStr,,,1,"void(int64_t,char*,int)"
111669150017,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLUtil::ToStr( uint64_t v, char* buffer, int bufferSize )
{
    // horrible syntax trick to make the compiler happy about %llu
    TIXML_SNPRINTF(buffer, bufferSize, ""%llu"", (long long)v);
}",1,4,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLUtil.ToStr:void(uint64_t,char*,int)",<empty>,,false,610,614,ToStr,,,1,"void(uint64_t,char*,int)"
111669150018,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLUtil::ToInt(const char* str, int* value)
{
    if (IsPrefixHex(str)) {
        unsigned v;
        if (TIXML_SSCANF(str, ""%x"", &v) == 1) {
            *value = static_cast<int>(v);
            return true;
        }
    }
    else {
        if (TIXML_SSCANF(str, ""%d"", value) == 1) {
            return true;
        }
    }
    return false;
}",1,12,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLUtil.ToInt:bool(char*,int*)",<empty>,,false,616,631,ToInt,,,1,"bool(char*,int*)"
111669150019,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLUtil::ToUnsigned(const char* str, unsigned* value)
{
    if (TIXML_SSCANF(str, IsPrefixHex(str) ? ""%x"" : ""%u"", value) == 1) {
        return true;
    }
    return false;
}",1,8,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLUtil.ToUnsigned:bool(char*,unsigned*)",<empty>,,false,633,639,ToUnsigned,,,1,"bool(char*,unsigned*)"
111669150020,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLUtil::ToBool( const char* str, bool* value )
{
    int ival = 0;
    if ( ToInt( str, &ival )) {
        *value = (ival==0) ? false : true;
        return true;
    }
    static const char* TRUE_VALS[] = { ""true"", ""True"", ""TRUE"", 0 };
    static const char* FALSE_VALS[] = { ""false"", ""False"", ""FALSE"", 0 };

    for (int i = 0; TRUE_VALS[i]; ++i) {
        if (StringEqual(str, TRUE_VALS[i])) {
            *value = true;
            return true;
        }
    }
    for (int i = 0; FALSE_VALS[i]; ++i) {
        if (StringEqual(str, FALSE_VALS[i])) {
            *value = false;
            return true;
        }
    }
    return false;
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLUtil.ToBool:bool(char*,bool*)",<empty>,,false,641,664,ToBool,,,1,"bool(char*,bool*)"
111669150021,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLUtil::ToFloat( const char* str, float* value )
{
    if ( TIXML_SSCANF( str, ""%f"", value ) == 1 ) {
        return true;
    }
    return false;
}",1,9,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLUtil.ToFloat:bool(char*,float*)",<empty>,,false,667,673,ToFloat,,,1,"bool(char*,float*)"
111669150022,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLUtil::ToDouble( const char* str, double* value )
{
    if ( TIXML_SSCANF( str, ""%lf"", value ) == 1 ) {
        return true;
    }
    return false;
}",1,9,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLUtil.ToDouble:bool(char*,double*)",<empty>,,false,676,682,ToDouble,,,1,"bool(char*,double*)"
111669150023,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLUtil::ToInt64(const char* str, int64_t* value)
{
    if (IsPrefixHex(str)) {
        unsigned long long v = 0;	// horrible syntax trick to make the compiler happy about %llx
        if (TIXML_SSCANF(str, ""%llx"", &v) == 1) {
            *value = static_cast<int64_t>(v);
            return true;
        }
    }
    else {
        long long v = 0;	// horrible syntax trick to make the compiler happy about %lld
        if (TIXML_SSCANF(str, ""%lld"", &v) == 1) {
            *value = static_cast<int64_t>(v);
            return true;
        }
    }
	return false;
}",1,12,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLUtil.ToInt64:bool(char*,int64_t*)",<empty>,,false,685,702,ToInt64,,,1,"bool(char*,int64_t*)"
111669150024,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLUtil::ToUnsigned64(const char* str, uint64_t* value) {
    unsigned long long v = 0;	// horrible syntax trick to make the compiler happy about %llu
    if(TIXML_SSCANF(str, IsPrefixHex(str) ? ""%llx"" : ""%llu"", &v) == 1) {
        *value = (uint64_t)v;
        return true;
    }
    return false;
}",1,7,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLUtil.ToUnsigned64:bool(char*,uint64_t*)",<empty>,,false,705,712,ToUnsigned64,,,1,"bool(char*,uint64_t*)"
111669150025,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"char* XMLDocument::Identify( char* p, XMLNode** node, bool first )
{
    TIXMLASSERT( node );
    TIXMLASSERT( p );
    char* const start = p;
    int const startLine = _parseCurLineNum;
    p = XMLUtil::SkipWhiteSpace( p, &_parseCurLineNum );
    if( !*p ) {
        *node = 0;
        TIXMLASSERT( p );
        return p;
    }

    // These strings define the matching patterns:
    static const char* xmlHeader		= { ""<?"" };
    static const char* commentHeader	= { ""<!--"" };
    static const char* cdataHeader		= { ""<![CDATA["" };
    static const char* dtdHeader		= { ""<!"" };
    static const char* elementHeader	= { ""<"" };	// and a header for everything else; check last.

    static const int xmlHeaderLen		= 2;
    static const int commentHeaderLen	= 4;
    static const int cdataHeaderLen		= 9;
    static const int dtdHeaderLen		= 2;
    static const int elementHeaderLen	= 1;

    TIXMLASSERT( sizeof( XMLComment ) == sizeof( XMLUnknown ) );		// use same memory pool
    TIXMLASSERT( size...",1,4,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLDocument.Identify:char*(char*,tinyxml2.XMLNode**,bool)",<empty>,,false,715,792,Identify,,,1,"char*(char*,tinyxml2.XMLNode**,bool)"
111669150026,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLDocument::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    if ( visitor->VisitEnter( *this ) ) {
        for ( const XMLNode* node=FirstChild(); node; node=node->NextSibling() ) {
            if ( !node->Accept( visitor ) ) {
                break;
            }
        }
    }
    return visitor->VisitExit( *this );
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.Accept<const>:bool(tinyxml2.XMLVisitor*),<empty>,,false,795,806,Accept,,,1,bool(tinyxml2.XMLVisitor*)
111669150027,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLNode::XMLNode( XMLDocument* doc ) :
    _document( doc ),
    _parent( 0 ),
    _value(),
    _parseLineNum( 0 ),
    _firstChild( 0 ), _lastChild( 0 ),
    _prev( 0 ), _next( 0 ),
	_userData( 0 ),
    _memPool( 0 )
{
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLNode.XMLNode:ANY(tinyxml2.XMLDocument*),<empty>,,false,811,821,XMLNode,,,1,tinyxml2.XMLNode.XMLNode:ANY(tinyxml2.XMLDocument*)(tinyxml2.XMLDocument*)
111669150028,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLNode::~XMLNode()
{
    DeleteChildren();
    if ( _parent ) {
        _parent->Unlink( this );
    }
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLNode.~XMLNode:ANY(),<empty>,,false,824,830,~XMLNode,,,1,ANY()
111669150029,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"int XMLNode::ChildElementCount(const char *value) const {
	int count = 0;

	const XMLElement *e = FirstChildElement(value);

	while (e) {
		e = e->NextSiblingElement(value);
		count++;
	}

	return count;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLNode.ChildElementCount<const>:int(char*),<empty>,,false,834,845,ChildElementCount,,,1,int(char*)
111669150030,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"int XMLNode::ChildElementCount() const {
	int count = 0;

	const XMLElement *e = FirstChildElement();

	while (e) {
		e = e->NextSiblingElement();
		count++;
	}

	return count;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLNode.ChildElementCount<const>:int(),<empty>,,false,847,858,ChildElementCount,,,1,int()
111669150031,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"const char* XMLNode::Value() const
{
    // Edge case: XMLDocuments don't have a Value. Return null.
    if ( this->ToDocument() )
        return 0;
    return _value.GetStr();
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLNode.Value<const>:char*(),<empty>,,false,860,866,Value,,,1,char*()
111669150032,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLNode::SetValue( const char* str, bool staticMem )
{
    if ( staticMem ) {
        _value.SetInternedStr( str );
    }
    else {
        _value.SetStr( str );
    }
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLNode.SetValue:void(char*,bool)",<empty>,,false,868,876,SetValue,,,1,"void(char*,bool)"
111669150033,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLNode* XMLNode::DeepClone(XMLDocument* target) const
{
	XMLNode* clone = this->ShallowClone(target);
	if (!clone) return 0;

	for (const XMLNode* child = this->FirstChild(); child; child = child->NextSibling()) {
		XMLNode* childClone = child->DeepClone(target);
		TIXMLASSERT(childClone);
		clone->InsertEndChild(childClone);
	}
	return clone;
}",1,2,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLNode.DeepClone<const>:tinyxml2.XMLNode*(tinyxml2.XMLDocument*),<empty>,,false,878,889,DeepClone,,,1,tinyxml2.XMLNode*(tinyxml2.XMLDocument*)
111669150034,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLNode::DeleteChildren()
{
    while( _firstChild ) {
        TIXMLASSERT( _lastChild );
        DeleteChild( _firstChild );
    }
    _firstChild = _lastChild = 0;
}",1,8,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLNode.DeleteChildren:void(),<empty>,,false,891,898,DeleteChildren,,,1,void()
111669150035,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLNode::Unlink( XMLNode* child )
{
    TIXMLASSERT( child );
    TIXMLASSERT( child->_document == _document );
    TIXMLASSERT( child->_parent == this );
    if ( child == _firstChild ) {
        _firstChild = _firstChild->_next;
    }
    if ( child == _lastChild ) {
        _lastChild = _lastChild->_prev;
    }

    if ( child->_prev ) {
        child->_prev->_next = child->_next;
    }
    if ( child->_next ) {
        child->_next->_prev = child->_prev;
    }
	child->_next = 0;
	child->_prev = 0;
	child->_parent = 0;
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLNode.Unlink:void(tinyxml2.XMLNode*),<empty>,,false,901,922,Unlink,,,1,void(tinyxml2.XMLNode*)
111669150036,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLNode::DeleteChild( XMLNode* node )
{
    TIXMLASSERT( node );
    TIXMLASSERT( node->_document == _document );
    TIXMLASSERT( node->_parent == this );
    Unlink( node );
	TIXMLASSERT(node->_prev == 0);
	TIXMLASSERT(node->_next == 0);
	TIXMLASSERT(node->_parent == 0);
    DeleteNode( node );
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLNode.DeleteChild:void(tinyxml2.XMLNode*),<empty>,,false,925,935,DeleteChild,,,1,void(tinyxml2.XMLNode*)
111669150037,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLNode* XMLNode::InsertEndChild( XMLNode* addThis )
{
    TIXMLASSERT( addThis );
    if ( addThis->_document != _document ) {
        TIXMLASSERT( false );
        return 0;
    }
    InsertChildPreamble( addThis );

    if ( _lastChild ) {
        TIXMLASSERT( _firstChild );
        TIXMLASSERT( _lastChild->_next == 0 );
        _lastChild->_next = addThis;
        addThis->_prev = _lastChild;
        _lastChild = addThis;

        addThis->_next = 0;
    }
    else {
        TIXMLASSERT( _firstChild == 0 );
        _firstChild = _lastChild = addThis;

        addThis->_prev = 0;
        addThis->_next = 0;
    }
    addThis->_parent = this;
    return addThis;
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLNode.InsertEndChild:tinyxml2.XMLNode*(tinyxml2.XMLNode*),<empty>,,false,938,965,InsertEndChild,,,1,tinyxml2.XMLNode*(tinyxml2.XMLNode*)
111669150038,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLNode* XMLNode::InsertFirstChild( XMLNode* addThis )
{
    TIXMLASSERT( addThis );
    if ( addThis->_document != _document ) {
        TIXMLASSERT( false );
        return 0;
    }
    InsertChildPreamble( addThis );

    if ( _firstChild ) {
        TIXMLASSERT( _lastChild );
        TIXMLASSERT( _firstChild->_prev == 0 );

        _firstChild->_prev = addThis;
        addThis->_next = _firstChild;
        _firstChild = addThis;

        addThis->_prev = 0;
    }
    else {
        TIXMLASSERT( _lastChild == 0 );
        _firstChild = _lastChild = addThis;

        addThis->_prev = 0;
        addThis->_next = 0;
    }
    addThis->_parent = this;
    return addThis;
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLNode.InsertFirstChild:tinyxml2.XMLNode*(tinyxml2.XMLNode*),<empty>,,false,968,996,InsertFirstChild,,,1,tinyxml2.XMLNode*(tinyxml2.XMLNode*)
111669150039,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLNode* XMLNode::InsertAfterChild( XMLNode* afterThis, XMLNode* addThis )
{
    TIXMLASSERT( addThis );
    if ( addThis->_document != _document ) {
        TIXMLASSERT( false );
        return 0;
    }

    TIXMLASSERT( afterThis );

    if ( afterThis->_parent != this ) {
        TIXMLASSERT( false );
        return 0;
    }
    if ( afterThis == addThis ) {
        // Current state: BeforeThis -> AddThis -> OneAfterAddThis
        // Now AddThis must disappear from it's location and then
        // reappear between BeforeThis and OneAfterAddThis.
        // So just leave it where it is.
        return addThis;
    }

    if ( afterThis->_next == 0 ) {
        // The last node or the only node.
        return InsertEndChild( addThis );
    }
    InsertChildPreamble( addThis );
    addThis->_prev = afterThis;
    addThis->_next = afterThis->_next;
    afterThis->_next->_prev = addThis;
    afterThis->_next = addThis;
    addThis->_parent = this;
    return addThis;
}",1,4,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLNode.InsertAfterChild:tinyxml2.XMLNode*(tinyxml2.XMLNode*,tinyxml2.XMLNode*)",<empty>,,false,999,1032,InsertAfterChild,,,1,"tinyxml2.XMLNode*(tinyxml2.XMLNode*,tinyxml2.XMLNode*)"
111669150040,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"const XMLElement* XMLNode::FirstChildElement( const char* name ) const
{
    for( const XMLNode* node = _firstChild; node; node = node->_next ) {
        const XMLElement* element = node->ToElementWithName( name );
        if ( element ) {
            return element;
        }
    }
    return 0;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLNode.FirstChildElement<const>:tinyxml2.XMLElement*(char*),<empty>,,false,1037,1046,FirstChildElement,,,1,tinyxml2.XMLElement*(char*)
111669150041,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"const XMLElement* XMLNode::LastChildElement( const char* name ) const
{
    for( const XMLNode* node = _lastChild; node; node = node->_prev ) {
        const XMLElement* element = node->ToElementWithName( name );
        if ( element ) {
            return element;
        }
    }
    return 0;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLNode.LastChildElement<const>:tinyxml2.XMLElement*(char*),<empty>,,false,1049,1058,LastChildElement,,,1,tinyxml2.XMLElement*(char*)
111669150042,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"const XMLElement* XMLNode::NextSiblingElement( const char* name ) const
{
    for( const XMLNode* node = _next; node; node = node->_next ) {
        const XMLElement* element = node->ToElementWithName( name );
        if ( element ) {
            return element;
        }
    }
    return 0;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLNode.NextSiblingElement<const>:tinyxml2.XMLElement*(char*),<empty>,,false,1061,1070,NextSiblingElement,,,1,tinyxml2.XMLElement*(char*)
111669150043,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"const XMLElement* XMLNode::PreviousSiblingElement( const char* name ) const
{
    for( const XMLNode* node = _prev; node; node = node->_prev ) {
        const XMLElement* element = node->ToElementWithName( name );
        if ( element ) {
            return element;
        }
    }
    return 0;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLNode.PreviousSiblingElement<const>:tinyxml2.XMLElement*(char*),<empty>,,false,1073,1082,PreviousSiblingElement,,,1,tinyxml2.XMLElement*(char*)
111669150044,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"char* XMLNode::ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr )
{
    // This is a recursive method, but thinking about it ""at the current level""
    // it is a pretty simple flat list:
    //		<foo/>
    //		<!-- comment -->
    //
    // With a special case:
    //		<foo>
    //		</foo>
    //		<!-- comment -->
    //
    // Where the closing element (/foo) *must* be the next thing after the opening
    // element, and the names must match. BUT the tricky bit is that the closing
    // element will be read by the child.
    //
    // 'endTag' is the end tag for this node, it is returned by a call to a child.
    // 'parentEnd' is the end tag for the parent, which is filled in and returned.

	XMLDocument::DepthTracker tracker(_document);
	if (_document->Error())
		return 0;

	bool first = true;
	while( p && *p ) {
        XMLNode* node = 0;

        p = _document->Identify( p, &node, first );
        TIXMLASSERT( p );
        if ( node == 0 ) {
            break;
   ...",1,8,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLNode.ParseDeep:char*(char*,tinyxml2.StrPair*,int*)",<empty>,,false,1085,1199,ParseDeep,,,1,"char*(char*,tinyxml2.StrPair*,int*)"
111669150045,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLNode::DeleteNode( XMLNode* node )
{
    if ( node == 0 ) {
        return;
    }
	TIXMLASSERT(node->_document);
	if (!node->ToDocument()) {
		node->_document->MarkInUse(node);
	}

    MemPool* pool = node->_memPool;
    node->~XMLNode();
    pool->Free( node );
}",12,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLNode.DeleteNode:void(tinyxml2.XMLNode*),<empty>,,false,1201,1214,DeleteNode,,,1,void(tinyxml2.XMLNode*)
111669150046,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLNode::InsertChildPreamble( XMLNode* insertThis ) const
{
    TIXMLASSERT( insertThis );
    TIXMLASSERT( insertThis->_document == _document );

	if (insertThis->_parent) {
        insertThis->_parent->Unlink( insertThis );
	}
	else {
		insertThis->_document->MarkInUse(insertThis);
        insertThis->_memPool->SetTracked();
	}
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLNode.InsertChildPreamble<const>:void(tinyxml2.XMLNode*),<empty>,,false,1216,1228,InsertChildPreamble,,,1,void(tinyxml2.XMLNode*)
111669150047,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"const XMLElement* XMLNode::ToElementWithName( const char* name ) const
{
    const XMLElement* element = this->ToElement();
    if ( element == 0 ) {
        return 0;
    }
    if ( name == 0 ) {
        return element;
    }
    if ( XMLUtil::StringEqual( element->Name(), name ) ) {
       return element;
    }
    return 0;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLNode.ToElementWithName<const>:tinyxml2.XMLElement*(char*),<empty>,,false,1230,1243,ToElementWithName,,,1,tinyxml2.XMLElement*(char*)
111669150048,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"char* XMLText::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
{
    if ( this->CData() ) {
        p = _value.ParseText( p, ""]]>"", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
        if ( !p ) {
            _document->SetError( XML_ERROR_PARSING_CDATA, _parseLineNum, 0 );
        }
        return p;
    }
    else {
        int flags = _document->ProcessEntities() ? StrPair::TEXT_ELEMENT : StrPair::TEXT_ELEMENT_LEAVE_ENTITIES;
        if ( _document->WhitespaceMode() == COLLAPSE_WHITESPACE ) {
            flags |= StrPair::NEEDS_WHITESPACE_COLLAPSING;
        }

        p = _value.ParseText( p, ""<"", flags, curLineNumPtr );
        if ( p && *p ) {
            return p-1;
        }
        if ( !p ) {
            _document->SetError( XML_ERROR_PARSING_TEXT, _parseLineNum, 0 );
        }
    }
    return 0;
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLText.ParseDeep:char*(char*,tinyxml2.StrPair*,int*)",<empty>,,false,1246,1270,ParseDeep,,,1,"char*(char*,tinyxml2.StrPair*,int*)"
111669150049,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLNode* XMLText::ShallowClone( XMLDocument* doc ) const
{
    if ( !doc ) {
        doc = _document;
    }
    XMLText* text = doc->NewText( Value() );	// fixme: this will always allocate memory. Intern?
    text->SetCData( this->CData() );
    return text;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLText.ShallowClone<const>:tinyxml2.XMLNode*(tinyxml2.XMLDocument*),<empty>,,false,1273,1281,ShallowClone,,,1,tinyxml2.XMLNode*(tinyxml2.XMLDocument*)
111669150050,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLText::ShallowEqual( const XMLNode* compare ) const
{
    TIXMLASSERT( compare );
    const XMLText* text = compare->ToText();
    return ( text && XMLUtil::StringEqual( text->Value(), Value() ) );
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLText.ShallowEqual<const>:bool(tinyxml2.XMLNode*),<empty>,,false,1284,1289,ShallowEqual,,,1,bool(tinyxml2.XMLNode*)
111669150051,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLText::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    return visitor->Visit( *this );
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLText.Accept<const>:bool(tinyxml2.XMLVisitor*),<empty>,,false,1292,1296,Accept,,,1,bool(tinyxml2.XMLVisitor*)
111669150052,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLComment::XMLComment( XMLDocument* doc ) : XMLNode( doc )
{
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLComment.XMLComment:ANY(tinyxml2.XMLDocument*),<empty>,,false,1301,1303,XMLComment,,,1,tinyxml2.XMLComment.XMLComment:ANY(tinyxml2.XMLDocument*)(tinyxml2.XMLDocument*)
111669150053,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLComment::~XMLComment()
{
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLComment.~XMLComment:ANY(),<empty>,,false,1306,1308,~XMLComment,,,1,ANY()
111669150054,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"char* XMLComment::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
{
    // Comment parses as text.
    p = _value.ParseText( p, ""-->"", StrPair::COMMENT, curLineNumPtr );
    if ( p == 0 ) {
        _document->SetError( XML_ERROR_PARSING_COMMENT, _parseLineNum, 0 );
    }
    return p;
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLComment.ParseDeep:char*(char*,tinyxml2.StrPair*,int*)",<empty>,,false,1311,1319,ParseDeep,,,1,"char*(char*,tinyxml2.StrPair*,int*)"
111669150055,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLNode* XMLComment::ShallowClone( XMLDocument* doc ) const
{
    if ( !doc ) {
        doc = _document;
    }
    XMLComment* comment = doc->NewComment( Value() );	// fixme: this will always allocate memory. Intern?
    return comment;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLComment.ShallowClone<const>:tinyxml2.XMLNode*(tinyxml2.XMLDocument*),<empty>,,false,1322,1329,ShallowClone,,,1,tinyxml2.XMLNode*(tinyxml2.XMLDocument*)
111669150056,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLComment::ShallowEqual( const XMLNode* compare ) const
{
    TIXMLASSERT( compare );
    const XMLComment* comment = compare->ToComment();
    return ( comment && XMLUtil::StringEqual( comment->Value(), Value() ));
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLComment.ShallowEqual<const>:bool(tinyxml2.XMLNode*),<empty>,,false,1332,1337,ShallowEqual,,,1,bool(tinyxml2.XMLNode*)
111669150057,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLComment::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    return visitor->Visit( *this );
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLComment.Accept<const>:bool(tinyxml2.XMLVisitor*),<empty>,,false,1340,1344,Accept,,,1,bool(tinyxml2.XMLVisitor*)
111669150058,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLDeclaration::XMLDeclaration( XMLDocument* doc ) : XMLNode( doc )
{
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDeclaration.XMLDeclaration:ANY(tinyxml2.XMLDocument*),<empty>,,false,1349,1351,XMLDeclaration,,,1,tinyxml2.XMLDeclaration.XMLDeclaration:ANY(tinyxml2.XMLDocument*)(tinyxml2.XMLDocument*)
111669150059,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLDeclaration::~XMLDeclaration()
{
    //printf( ""~XMLDeclaration\\n"" );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDeclaration.~XMLDeclaration:ANY(),<empty>,,false,1354,1357,~XMLDeclaration,,,1,ANY()
111669150060,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"char* XMLDeclaration::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
{
    // Declaration parses as text.
    p = _value.ParseText( p, ""?>"", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
    if ( p == 0 ) {
        _document->SetError( XML_ERROR_PARSING_DECLARATION, _parseLineNum, 0 );
    }
    return p;
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLDeclaration.ParseDeep:char*(char*,tinyxml2.StrPair*,int*)",<empty>,,false,1360,1368,ParseDeep,,,1,"char*(char*,tinyxml2.StrPair*,int*)"
111669150061,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLNode* XMLDeclaration::ShallowClone( XMLDocument* doc ) const
{
    if ( !doc ) {
        doc = _document;
    }
    XMLDeclaration* dec = doc->NewDeclaration( Value() );	// fixme: this will always allocate memory. Intern?
    return dec;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDeclaration.ShallowClone<const>:tinyxml2.XMLNode*(tinyxml2.XMLDocument*),<empty>,,false,1371,1378,ShallowClone,,,1,tinyxml2.XMLNode*(tinyxml2.XMLDocument*)
111669150062,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLDeclaration::ShallowEqual( const XMLNode* compare ) const
{
    TIXMLASSERT( compare );
    const XMLDeclaration* declaration = compare->ToDeclaration();
    return ( declaration && XMLUtil::StringEqual( declaration->Value(), Value() ));
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDeclaration.ShallowEqual<const>:bool(tinyxml2.XMLNode*),<empty>,,false,1381,1386,ShallowEqual,,,1,bool(tinyxml2.XMLNode*)
111669150063,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLDeclaration::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    return visitor->Visit( *this );
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDeclaration.Accept<const>:bool(tinyxml2.XMLVisitor*),<empty>,,false,1390,1394,Accept,,,1,bool(tinyxml2.XMLVisitor*)
111669150064,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLUnknown::XMLUnknown( XMLDocument* doc ) : XMLNode( doc )
{
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLUnknown.XMLUnknown:ANY(tinyxml2.XMLDocument*),<empty>,,false,1398,1400,XMLUnknown,,,1,tinyxml2.XMLUnknown.XMLUnknown:ANY(tinyxml2.XMLDocument*)(tinyxml2.XMLDocument*)
111669150065,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLUnknown::~XMLUnknown()
{
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLUnknown.~XMLUnknown:ANY(),<empty>,,false,1403,1405,~XMLUnknown,,,1,ANY()
111669150066,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"char* XMLUnknown::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
{
    // Unknown parses as text.
    p = _value.ParseText( p, "">"", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
    if ( !p ) {
        _document->SetError( XML_ERROR_PARSING_UNKNOWN, _parseLineNum, 0 );
    }
    return p;
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLUnknown.ParseDeep:char*(char*,tinyxml2.StrPair*,int*)",<empty>,,false,1408,1416,ParseDeep,,,1,"char*(char*,tinyxml2.StrPair*,int*)"
111669150067,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLNode* XMLUnknown::ShallowClone( XMLDocument* doc ) const
{
    if ( !doc ) {
        doc = _document;
    }
    XMLUnknown* text = doc->NewUnknown( Value() );	// fixme: this will always allocate memory. Intern?
    return text;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLUnknown.ShallowClone<const>:tinyxml2.XMLNode*(tinyxml2.XMLDocument*),<empty>,,false,1419,1426,ShallowClone,,,1,tinyxml2.XMLNode*(tinyxml2.XMLDocument*)
111669150068,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLUnknown::ShallowEqual( const XMLNode* compare ) const
{
    TIXMLASSERT( compare );
    const XMLUnknown* unknown = compare->ToUnknown();
    return ( unknown && XMLUtil::StringEqual( unknown->Value(), Value() ));
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLUnknown.ShallowEqual<const>:bool(tinyxml2.XMLNode*),<empty>,,false,1429,1434,ShallowEqual,,,1,bool(tinyxml2.XMLNode*)
111669150069,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLUnknown::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    return visitor->Visit( *this );
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLUnknown.Accept<const>:bool(tinyxml2.XMLVisitor*),<empty>,,false,1437,1441,Accept,,,1,bool(tinyxml2.XMLVisitor*)
111669150070,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"const char* XMLAttribute::Name() const
{
    return _name.GetStr();
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLAttribute.Name<const>:char*(),<empty>,,false,1445,1448,Name,,,1,char*()
111669150071,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"const char* XMLAttribute::Value() const
{
    return _value.GetStr();
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLAttribute.Value<const>:char*(),<empty>,,false,1450,1453,Value,,,1,char*()
111669150072,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"char* XMLAttribute::ParseDeep( char* p, bool processEntities, int* curLineNumPtr )
{
    // Parse using the name rules: bug fix, was using ParseText before
    p = _name.ParseName( p );
    if ( !p || !*p ) {
        return 0;
    }

    // Skip white space before =
    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
    if ( *p != '=' ) {
        return 0;
    }

    ++p;	// move up to opening quote
    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
    if ( *p != '\\""' && *p != '\\'' ) {
        return 0;
    }

    const char endTag[2] = { *p, 0 };
    ++p;	// move past opening quote

    p = _value.ParseText( p, endTag, processEntities ? StrPair::ATTRIBUTE_VALUE : StrPair::ATTRIBUTE_VALUE_LEAVE_ENTITIES, curLineNumPtr );
    return p;
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLAttribute.ParseDeep:char*(char*,bool,int*)",<empty>,,false,1455,1480,ParseDeep,,,1,"char*(char*,bool,int*)"
111669150073,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLAttribute::SetName( const char* n )
{
    _name.SetStr( n );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLAttribute.SetName:void(char*),<empty>,,false,1483,1486,SetName,,,1,void(char*)
111669150074,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLError XMLAttribute::QueryIntValue( int* value ) const
{
    if ( XMLUtil::ToInt( Value(), value )) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLAttribute.QueryIntValue<const>:tinyxml2.XMLError(int*),<empty>,,false,1489,1495,QueryIntValue,,,1,tinyxml2.XMLError(int*)
111669150075,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLError XMLAttribute::QueryUnsignedValue( unsigned int* value ) const
{
    if ( XMLUtil::ToUnsigned( Value(), value )) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLAttribute.QueryUnsignedValue<const>:tinyxml2.XMLError(unsigned int*),<empty>,,false,1498,1504,QueryUnsignedValue,,,1,tinyxml2.XMLError(unsigned int*)
111669150076,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLError XMLAttribute::QueryInt64Value(int64_t* value) const
{
	if (XMLUtil::ToInt64(Value(), value)) {
		return XML_SUCCESS;
	}
	return XML_WRONG_ATTRIBUTE_TYPE;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLAttribute.QueryInt64Value<const>:tinyxml2.XMLError(int64_t*),<empty>,,false,1507,1513,QueryInt64Value,,,1,tinyxml2.XMLError(int64_t*)
111669150077,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLError XMLAttribute::QueryUnsigned64Value(uint64_t* value) const
{
    if(XMLUtil::ToUnsigned64(Value(), value)) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLAttribute.QueryUnsigned64Value<const>:tinyxml2.XMLError(uint64_t*),<empty>,,false,1516,1522,QueryUnsigned64Value,,,1,tinyxml2.XMLError(uint64_t*)
111669150078,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLError XMLAttribute::QueryBoolValue( bool* value ) const
{
    if ( XMLUtil::ToBool( Value(), value )) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLAttribute.QueryBoolValue<const>:tinyxml2.XMLError(bool*),<empty>,,false,1525,1531,QueryBoolValue,,,1,tinyxml2.XMLError(bool*)
111669150079,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLError XMLAttribute::QueryFloatValue( float* value ) const
{
    if ( XMLUtil::ToFloat( Value(), value )) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLAttribute.QueryFloatValue<const>:tinyxml2.XMLError(float*),<empty>,,false,1534,1540,QueryFloatValue,,,1,tinyxml2.XMLError(float*)
111669150080,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLError XMLAttribute::QueryDoubleValue( double* value ) const
{
    if ( XMLUtil::ToDouble( Value(), value )) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLAttribute.QueryDoubleValue<const>:tinyxml2.XMLError(double*),<empty>,,false,1543,1549,QueryDoubleValue,,,1,tinyxml2.XMLError(double*)
111669150081,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLAttribute::SetAttribute( const char* v )
{
    _value.SetStr( v );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLAttribute.SetAttribute:void(char*),<empty>,,false,1552,1555,SetAttribute,,,1,void(char*)
111669150082,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLAttribute::SetAttribute( int v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    _value.SetStr( buf );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLAttribute.SetAttribute:void(int),<empty>,,false,1558,1563,SetAttribute,,,1,void(int)
111669150083,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLAttribute::SetAttribute( unsigned v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    _value.SetStr( buf );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLAttribute.SetAttribute:void(unsigned),<empty>,,false,1566,1571,SetAttribute,,,1,void(unsigned)
111669150084,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLAttribute::SetAttribute(int64_t v)
{
	char buf[BUF_SIZE];
	XMLUtil::ToStr(v, buf, BUF_SIZE);
	_value.SetStr(buf);
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLAttribute.SetAttribute:void(int64_t),<empty>,,false,1574,1579,SetAttribute,,,1,void(int64_t)
111669150085,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLAttribute::SetAttribute(uint64_t v)
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr(v, buf, BUF_SIZE);
    _value.SetStr(buf);
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLAttribute.SetAttribute:void(uint64_t),<empty>,,false,1581,1586,SetAttribute,,,1,void(uint64_t)
111669150086,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLAttribute::SetAttribute( bool v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    _value.SetStr( buf );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLAttribute.SetAttribute:void(bool),<empty>,,false,1589,1594,SetAttribute,,,1,void(bool)
111669150087,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLAttribute::SetAttribute( double v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    _value.SetStr( buf );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLAttribute.SetAttribute:void(double),<empty>,,false,1596,1601,SetAttribute,,,1,void(double)
111669150088,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLAttribute::SetAttribute( float v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    _value.SetStr( buf );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLAttribute.SetAttribute:void(float),<empty>,,false,1603,1608,SetAttribute,,,1,void(float)
111669150089,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLElement::XMLElement( XMLDocument* doc ) : XMLNode( doc ),
    _closingType( OPEN ),
    _rootAttribute( 0 )
{
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.XMLElement:ANY(tinyxml2.XMLDocument*),<empty>,,false,1612,1616,XMLElement,,,1,tinyxml2.XMLElement.XMLElement:ANY(tinyxml2.XMLDocument*)(tinyxml2.XMLDocument*)
111669150090,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLElement::~XMLElement()
{
    while( _rootAttribute ) {
        XMLAttribute* next = _rootAttribute->_next;
        DeleteAttribute( _rootAttribute );
        _rootAttribute = next;
    }
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.~XMLElement:ANY(),<empty>,,false,1619,1626,~XMLElement,,,1,ANY()
111669150091,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"const XMLAttribute* XMLElement::FindAttribute( const char* name ) const
{
    for( XMLAttribute* a = _rootAttribute; a; a = a->_next ) {
        if ( XMLUtil::StringEqual( a->Name(), name ) ) {
            return a;
        }
    }
    return 0;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.FindAttribute<const>:tinyxml2.XMLAttribute*(char*),<empty>,,false,1629,1637,FindAttribute,,,1,tinyxml2.XMLAttribute*(char*)
111669150092,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"const char* XMLElement::Attribute( const char* name, const char* value ) const
{
    const XMLAttribute* a = FindAttribute( name );
    if ( !a ) {
        return 0;
    }
    if ( !value || XMLUtil::StringEqual( a->Value(), value )) {
        return a->Value();
    }
    return 0;
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLElement.Attribute<const>:char*(char*,char*)",<empty>,,false,1640,1650,Attribute,,,1,"char*(char*,char*)"
111669150093,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"int XMLElement::IntAttribute(const char* name, int defaultValue) const
{
	int i = defaultValue;
	QueryIntAttribute(name, &i);
	return i;
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLElement.IntAttribute<const>:int(char*,int)",<empty>,,false,1652,1657,IntAttribute,,,1,"int(char*,int)"
111669150094,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"unsigned XMLElement::UnsignedAttribute(const char* name, unsigned defaultValue) const
{
	unsigned i = defaultValue;
	QueryUnsignedAttribute(name, &i);
	return i;
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLElement.UnsignedAttribute<const>:unsigned int(char*,unsigned)",<empty>,,false,1659,1664,UnsignedAttribute,,,1,"unsigned int(char*,unsigned)"
111669150095,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"int64_t XMLElement::Int64Attribute(const char* name, int64_t defaultValue) const
{
	int64_t i = defaultValue;
	QueryInt64Attribute(name, &i);
	return i;
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLElement.Int64Attribute<const>:int64_t(char*,int64_t)",<empty>,,false,1666,1671,Int64Attribute,,,1,"int64_t(char*,int64_t)"
111669150096,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"uint64_t XMLElement::Unsigned64Attribute(const char* name, uint64_t defaultValue) const
{
	uint64_t i = defaultValue;
	QueryUnsigned64Attribute(name, &i);
	return i;
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLElement.Unsigned64Attribute<const>:uint64_t(char*,uint64_t)",<empty>,,false,1673,1678,Unsigned64Attribute,,,1,"uint64_t(char*,uint64_t)"
111669150097,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLElement::BoolAttribute(const char* name, bool defaultValue) const
{
	bool b = defaultValue;
	QueryBoolAttribute(name, &b);
	return b;
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLElement.BoolAttribute<const>:bool(char*,bool)",<empty>,,false,1680,1685,BoolAttribute,,,1,"bool(char*,bool)"
111669150098,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"double XMLElement::DoubleAttribute(const char* name, double defaultValue) const
{
	double d = defaultValue;
	QueryDoubleAttribute(name, &d);
	return d;
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLElement.DoubleAttribute<const>:double(char*,double)",<empty>,,false,1687,1692,DoubleAttribute,,,1,"double(char*,double)"
111669150099,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"float XMLElement::FloatAttribute(const char* name, float defaultValue) const
{
	float f = defaultValue;
	QueryFloatAttribute(name, &f);
	return f;
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLElement.FloatAttribute<const>:float(char*,float)",<empty>,,false,1694,1699,FloatAttribute,,,1,"float(char*,float)"
111669150100,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"const char* XMLElement::GetText() const
{
    /* skip comment node */
    const XMLNode* node = FirstChild();
    while (node) {
        if (node->ToComment()) {
            node = node->NextSibling();
            continue;
        }
        break;
    }

    if ( node && node->ToText() ) {
        return node->Value();
    }
    return 0;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.GetText<const>:char*(),<empty>,,false,1701,1717,GetText,,,1,char*()
111669150101,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void	XMLElement::SetText( const char* inText )
{
	if ( FirstChild() && FirstChild()->ToText() )
		FirstChild()->SetValue( inText );
	else {
		XMLText*	theText = GetDocument()->NewText( inText );
		InsertFirstChild( theText );
	}
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.SetText:void(char*),<empty>,,false,1720,1728,SetText,,,1,void(char*)
111669150102,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLElement::SetText( int v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    SetText( buf );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.SetText:void(int),<empty>,,false,1731,1736,SetText,,,1,void(int)
111669150103,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLElement::SetText( unsigned v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    SetText( buf );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.SetText:void(unsigned),<empty>,,false,1739,1744,SetText,,,1,void(unsigned)
111669150104,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLElement::SetText(int64_t v)
{
	char buf[BUF_SIZE];
	XMLUtil::ToStr(v, buf, BUF_SIZE);
	SetText(buf);
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.SetText:void(int64_t),<empty>,,false,1747,1752,SetText,,,1,void(int64_t)
111669150105,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLElement::SetText(uint64_t v) {
    char buf[BUF_SIZE];
    XMLUtil::ToStr(v, buf, BUF_SIZE);
    SetText(buf);
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.SetText:void(uint64_t),<empty>,,false,1754,1758,SetText,,,1,void(uint64_t)
111669150106,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLElement::SetText( bool v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    SetText( buf );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.SetText:void(bool),<empty>,,false,1761,1766,SetText,,,1,void(bool)
111669150107,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLElement::SetText( float v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    SetText( buf );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.SetText:void(float),<empty>,,false,1769,1774,SetText,,,1,void(float)
111669150108,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLElement::SetText( double v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    SetText( buf );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.SetText:void(double),<empty>,,false,1777,1782,SetText,,,1,void(double)
111669150109,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLError XMLElement::QueryIntText( int* ival ) const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        const char* t = FirstChild()->Value();
        if ( XMLUtil::ToInt( t, ival ) ) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.QueryIntText<const>:tinyxml2.XMLError(int*),<empty>,,false,1785,1795,QueryIntText,,,1,tinyxml2.XMLError(int*)
111669150110,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLError XMLElement::QueryUnsignedText( unsigned* uval ) const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        const char* t = FirstChild()->Value();
        if ( XMLUtil::ToUnsigned( t, uval ) ) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.QueryUnsignedText<const>:tinyxml2.XMLError(unsigned*),<empty>,,false,1798,1808,QueryUnsignedText,,,1,tinyxml2.XMLError(unsigned*)
111669150111,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLError XMLElement::QueryInt64Text(int64_t* ival) const
{
	if (FirstChild() && FirstChild()->ToText()) {
		const char* t = FirstChild()->Value();
		if (XMLUtil::ToInt64(t, ival)) {
			return XML_SUCCESS;
		}
		return XML_CAN_NOT_CONVERT_TEXT;
	}
	return XML_NO_TEXT_NODE;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.QueryInt64Text<const>:tinyxml2.XMLError(int64_t*),<empty>,,false,1811,1821,QueryInt64Text,,,1,tinyxml2.XMLError(int64_t*)
111669150112,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLError XMLElement::QueryUnsigned64Text(uint64_t* uval) const
{
    if(FirstChild() && FirstChild()->ToText()) {
        const char* t = FirstChild()->Value();
        if(XMLUtil::ToUnsigned64(t, uval)) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.QueryUnsigned64Text<const>:tinyxml2.XMLError(uint64_t*),<empty>,,false,1824,1834,QueryUnsigned64Text,,,1,tinyxml2.XMLError(uint64_t*)
111669150113,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLError XMLElement::QueryBoolText( bool* bval ) const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        const char* t = FirstChild()->Value();
        if ( XMLUtil::ToBool( t, bval ) ) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.QueryBoolText<const>:tinyxml2.XMLError(bool*),<empty>,,false,1837,1847,QueryBoolText,,,1,tinyxml2.XMLError(bool*)
111669150114,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLError XMLElement::QueryDoubleText( double* dval ) const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        const char* t = FirstChild()->Value();
        if ( XMLUtil::ToDouble( t, dval ) ) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.QueryDoubleText<const>:tinyxml2.XMLError(double*),<empty>,,false,1850,1860,QueryDoubleText,,,1,tinyxml2.XMLError(double*)
111669150115,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLError XMLElement::QueryFloatText( float* fval ) const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        const char* t = FirstChild()->Value();
        if ( XMLUtil::ToFloat( t, fval ) ) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.QueryFloatText<const>:tinyxml2.XMLError(float*),<empty>,,false,1863,1873,QueryFloatText,,,1,tinyxml2.XMLError(float*)
111669150116,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"int XMLElement::IntText(int defaultValue) const
{
	int i = defaultValue;
	QueryIntText(&i);
	return i;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.IntText<const>:int(int),<empty>,,false,1875,1880,IntText,,,1,int(int)
111669150117,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"unsigned XMLElement::UnsignedText(unsigned defaultValue) const
{
	unsigned i = defaultValue;
	QueryUnsignedText(&i);
	return i;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.UnsignedText<const>:unsigned int(unsigned),<empty>,,false,1882,1887,UnsignedText,,,1,unsigned int(unsigned)
111669150118,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"int64_t XMLElement::Int64Text(int64_t defaultValue) const
{
	int64_t i = defaultValue;
	QueryInt64Text(&i);
	return i;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.Int64Text<const>:int64_t(int64_t),<empty>,,false,1889,1894,Int64Text,,,1,int64_t(int64_t)
111669150119,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"uint64_t XMLElement::Unsigned64Text(uint64_t defaultValue) const
{
	uint64_t i = defaultValue;
	QueryUnsigned64Text(&i);
	return i;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.Unsigned64Text<const>:uint64_t(uint64_t),<empty>,,false,1896,1901,Unsigned64Text,,,1,uint64_t(uint64_t)
111669150120,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLElement::BoolText(bool defaultValue) const
{
	bool b = defaultValue;
	QueryBoolText(&b);
	return b;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.BoolText<const>:bool(bool),<empty>,,false,1903,1908,BoolText,,,1,bool(bool)
111669150121,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"double XMLElement::DoubleText(double defaultValue) const
{
	double d = defaultValue;
	QueryDoubleText(&d);
	return d;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.DoubleText<const>:double(double),<empty>,,false,1910,1915,DoubleText,,,1,double(double)
111669150122,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"float XMLElement::FloatText(float defaultValue) const
{
	float f = defaultValue;
	QueryFloatText(&f);
	return f;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.FloatText<const>:float(float),<empty>,,false,1917,1922,FloatText,,,1,float(float)
111669150123,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLAttribute* XMLElement::FindOrCreateAttribute( const char* name )
{
    XMLAttribute* last = 0;
    XMLAttribute* attrib = 0;
    for( attrib = _rootAttribute;
            attrib;
            last = attrib, attrib = attrib->_next ) {
        if ( XMLUtil::StringEqual( attrib->Name(), name ) ) {
            break;
        }
    }
    if ( !attrib ) {
        attrib = CreateAttribute();
        TIXMLASSERT( attrib );
        if ( last ) {
            TIXMLASSERT( last->_next == 0 );
            last->_next = attrib;
        }
        else {
            TIXMLASSERT( _rootAttribute == 0 );
            _rootAttribute = attrib;
        }
        attrib->SetName( name );
    }
    return attrib;
}",1,8,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.FindOrCreateAttribute:tinyxml2.XMLAttribute*(char*),<empty>,,false,1925,1950,FindOrCreateAttribute,,,1,tinyxml2.XMLAttribute*(char*)
111669150124,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLElement::DeleteAttribute( const char* name )
{
    XMLAttribute* prev = 0;
    for( XMLAttribute* a=_rootAttribute; a; a=a->_next ) {
        if ( XMLUtil::StringEqual( name, a->Name() ) ) {
            if ( prev ) {
                prev->_next = a->_next;
            }
            else {
                _rootAttribute = a->_next;
            }
            DeleteAttribute( a );
            break;
        }
        prev = a;
    }
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.DeleteAttribute:void(char*),<empty>,,false,1953,1969,DeleteAttribute,,,1,void(char*)
111669150125,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"char* XMLElement::ParseAttributes( char* p, int* curLineNumPtr )
{
    XMLAttribute* prevAttribute = 0;

    // Read the attributes.
    while( p ) {
        p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
        if ( !(*p) ) {
            _document->SetError( XML_ERROR_PARSING_ELEMENT, _parseLineNum, ""XMLElement name=%s"", Name() );
            return 0;
        }

        // attribute.
        if (XMLUtil::IsNameStartChar( (unsigned char) *p ) ) {
            XMLAttribute* attrib = CreateAttribute();
            TIXMLASSERT( attrib );
            attrib->_parseLineNum = _document->_parseCurLineNum;

            const int attrLineNum = attrib->_parseLineNum;

            p = attrib->ParseDeep( p, _document->ProcessEntities(), curLineNumPtr );
            if ( !p || Attribute( attrib->Name() ) ) {
                DeleteAttribute( attrib );
                _document->SetError( XML_ERROR_PARSING_ATTRIBUTE, attrLineNum, ""XMLElement name=%s"", Name() );
                return 0;
       ...",1,12,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLElement.ParseAttributes:char*(char*,int*)",<empty>,,false,1972,2029,ParseAttributes,,,1,"char*(char*,int*)"
111669150126,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLElement::DeleteAttribute( XMLAttribute* attribute )
{
    if ( attribute == 0 ) {
        return;
    }
    MemPool* pool = attribute->_memPool;
    attribute->~XMLAttribute();
    pool->Free( attribute );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.DeleteAttribute:void(tinyxml2.XMLAttribute*),<empty>,,false,2031,2039,DeleteAttribute,,,1,void(tinyxml2.XMLAttribute*)
111669150127,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLAttribute* XMLElement::CreateAttribute()
{
    TIXMLASSERT( sizeof( XMLAttribute ) == _document->_attributePool.ItemSize() );
    XMLAttribute* attrib = new (_document->_attributePool.Alloc() ) XMLAttribute();
    TIXMLASSERT( attrib );
    attrib->_memPool = &_document->_attributePool;
    attrib->_memPool->SetTracked();
    return attrib;
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.CreateAttribute:tinyxml2.XMLAttribute*(),<empty>,,false,2041,2049,CreateAttribute,,,1,tinyxml2.XMLAttribute*()
111669150128,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLElement* XMLElement::InsertNewChildElement(const char* name)
{
    XMLElement* node = _document->NewElement(name);
    return InsertEndChild(node) ? node : 0;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.InsertNewChildElement:tinyxml2.XMLElement*(char*),<empty>,,false,2052,2056,InsertNewChildElement,,,1,tinyxml2.XMLElement*(char*)
111669150129,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLComment* XMLElement::InsertNewComment(const char* comment)
{
    XMLComment* node = _document->NewComment(comment);
    return InsertEndChild(node) ? node : 0;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.InsertNewComment:tinyxml2.XMLComment*(char*),<empty>,,false,2058,2062,InsertNewComment,,,1,tinyxml2.XMLComment*(char*)
111669150130,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLText* XMLElement::InsertNewText(const char* text)
{
    XMLText* node = _document->NewText(text);
    return InsertEndChild(node) ? node : 0;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.InsertNewText:tinyxml2.XMLText*(char*),<empty>,,false,2064,2068,InsertNewText,,,1,tinyxml2.XMLText*(char*)
111669150131,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLDeclaration* XMLElement::InsertNewDeclaration(const char* text)
{
    XMLDeclaration* node = _document->NewDeclaration(text);
    return InsertEndChild(node) ? node : 0;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.InsertNewDeclaration:tinyxml2.XMLDeclaration*(char*),<empty>,,false,2070,2074,InsertNewDeclaration,,,1,tinyxml2.XMLDeclaration*(char*)
111669150132,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLUnknown* XMLElement::InsertNewUnknown(const char* text)
{
    XMLUnknown* node = _document->NewUnknown(text);
    return InsertEndChild(node) ? node : 0;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.InsertNewUnknown:tinyxml2.XMLUnknown*(char*),<empty>,,false,2076,2080,InsertNewUnknown,,,1,tinyxml2.XMLUnknown*(char*)
111669150133,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"char* XMLElement::ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr )
{
    // Read the element name.
    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );

    // The closing element is the </element> form. It is
    // parsed just like a regular element then deleted from
    // the DOM.
    if ( *p == '/' ) {
        _closingType = CLOSING;
        ++p;
    }

    p = _value.ParseName( p );
    if ( _value.Empty() ) {
        return 0;
    }

    p = ParseAttributes( p, curLineNumPtr );
    if ( !p || !*p || _closingType != OPEN ) {
        return p;
    }

    p = XMLNode::ParseDeep( p, parentEndTag, curLineNumPtr );
    return p;
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLElement.ParseDeep:char*(char*,tinyxml2.StrPair*,int*)",<empty>,,false,2088,2113,ParseDeep,,,1,"char*(char*,tinyxml2.StrPair*,int*)"
111669150134,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLNode* XMLElement::ShallowClone( XMLDocument* doc ) const
{
    if ( !doc ) {
        doc = _document;
    }
    XMLElement* element = doc->NewElement( Value() );					// fixme: this will always allocate memory. Intern?
    for( const XMLAttribute* a=FirstAttribute(); a; a=a->Next() ) {
        element->SetAttribute( a->Name(), a->Value() );					// fixme: this will always allocate memory. Intern?
    }
    return element;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.ShallowClone<const>:tinyxml2.XMLNode*(tinyxml2.XMLDocument*),<empty>,,false,2117,2127,ShallowClone,,,1,tinyxml2.XMLNode*(tinyxml2.XMLDocument*)
111669150135,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLElement::ShallowEqual( const XMLNode* compare ) const
{
    TIXMLASSERT( compare );
    const XMLElement* other = compare->ToElement();
    if ( other && XMLUtil::StringEqual( other->Name(), Name() )) {

        const XMLAttribute* a=FirstAttribute();
        const XMLAttribute* b=other->FirstAttribute();

        while ( a && b ) {
            if ( !XMLUtil::StringEqual( a->Value(), b->Value() ) ) {
                return false;
            }
            a = a->Next();
            b = b->Next();
        }
        if ( a || b ) {
            // different count
            return false;
        }
        return true;
    }
    return false;
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.ShallowEqual<const>:bool(tinyxml2.XMLNode*),<empty>,,false,2130,2153,ShallowEqual,,,1,bool(tinyxml2.XMLNode*)
111669150136,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLElement::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    if ( visitor->VisitEnter( *this, _rootAttribute ) ) {
        for ( const XMLNode* node=FirstChild(); node; node=node->NextSibling() ) {
            if ( !node->Accept( visitor ) ) {
                break;
            }
        }
    }
    return visitor->VisitExit( *this );
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLElement.Accept<const>:bool(tinyxml2.XMLVisitor*),<empty>,,false,2156,2167,Accept,,,1,bool(tinyxml2.XMLVisitor*)
111669150137,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLDocument::XMLDocument( bool processEntities, Whitespace whitespaceMode ) :
    XMLNode( 0 ),
    _writeBOM( false ),
    _processEntities( processEntities ),
    _errorID(XML_SUCCESS),
    _whitespaceMode( whitespaceMode ),
    _errorStr(),
    _errorLineNum( 0 ),
    _charBuffer( 0 ),
    _parseCurLineNum( 0 ),
	_parsingDepth(0),
    _unlinked(),
    _elementPool(),
    _attributePool(),
    _textPool(),
    _commentPool()
{
    // avoid VC++ C4355 warning about 'this' in initializer list (C4355 is off by default in VS2012+)
    _document = this;
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLDocument.XMLDocument:ANY(bool,tinyxml2.Whitespace)",<empty>,,false,2196,2215,XMLDocument,,,1,"tinyxml2.XMLDocument.XMLDocument:ANY(bool,tinyxml2.Whitespace)(bool,tinyxml2.Whitespace)"
111669150138,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLDocument::~XMLDocument()
{
    Clear();
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.~XMLDocument:ANY(),<empty>,,false,2218,2221,~XMLDocument,,,1,ANY()
111669150139,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLDocument::MarkInUse(const XMLNode* const node)
{
	TIXMLASSERT(node);
	TIXMLASSERT(node->_parent == 0);

	for (int i = 0; i < _unlinked.Size(); ++i) {
		if (node == _unlinked[i]) {
			_unlinked.SwapRemove(i);
			break;
		}
	}
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.MarkInUse:void(tinyxml2.XMLNode*),<empty>,,false,2224,2235,MarkInUse,,,1,void(tinyxml2.XMLNode*)
111669150140,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLDocument::Clear()
{
    DeleteChildren();
	while( _unlinked.Size()) {
		DeleteNode(_unlinked[0]);	// Will remove from _unlinked as part of delete.
	}

#ifdef TINYXML2_DEBUG
    const bool hadError = Error();
#endif
    ClearError();

    delete [] _charBuffer;
    _charBuffer = 0;
	_parsingDepth = 0;

#if 0
    _textPool.Trace( ""text"" );
    _elementPool.Trace( ""element"" );
    _commentPool.Trace( ""comment"" );
    _attributePool.Trace( ""attribute"" );
#endif

#ifdef TINYXML2_DEBUG
    if ( !hadError ) {
        TIXMLASSERT( _elementPool.CurrentAllocs()   == _elementPool.Untracked() );
        TIXMLASSERT( _attributePool.CurrentAllocs() == _attributePool.Untracked() );
        TIXMLASSERT( _textPool.CurrentAllocs()      == _textPool.Untracked() );
        TIXMLASSERT( _commentPool.CurrentAllocs()   == _commentPool.Untracked() );
    }
#endif
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.Clear:void(),<empty>,,false,2237,2268,Clear,,,1,void()
111669150141,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLDocument::DeepCopy(XMLDocument* target) const
{
	TIXMLASSERT(target);
    if (target == this) {
        return; // technically success - a no-op.
    }

	target->Clear();
	for (const XMLNode* node = this->FirstChild(); node; node = node->NextSibling()) {
		target->InsertEndChild(node->DeepClone(target));
	}
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.DeepCopy<const>:void(tinyxml2.XMLDocument*),<empty>,,false,2271,2282,DeepCopy,,,1,void(tinyxml2.XMLDocument*)
111669150142,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLElement* XMLDocument::NewElement( const char* name )
{
    XMLElement* ele = CreateUnlinkedNode<XMLElement>( _elementPool );
    ele->SetName( name );
    return ele;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.NewElement:tinyxml2.XMLElement*(char*),<empty>,,false,2284,2289,NewElement,,,1,tinyxml2.XMLElement*(char*)
111669150143,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLComment* XMLDocument::NewComment( const char* str )
{
    XMLComment* comment = CreateUnlinkedNode<XMLComment>( _commentPool );
    comment->SetValue( str );
    return comment;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.NewComment:tinyxml2.XMLComment*(char*),<empty>,,false,2292,2297,NewComment,,,1,tinyxml2.XMLComment*(char*)
111669150144,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLText* XMLDocument::NewText( const char* str )
{
    XMLText* text = CreateUnlinkedNode<XMLText>( _textPool );
    text->SetValue( str );
    return text;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.NewText:tinyxml2.XMLText*(char*),<empty>,,false,2300,2305,NewText,,,1,tinyxml2.XMLText*(char*)
111669150145,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLDeclaration* XMLDocument::NewDeclaration( const char* str )
{
    XMLDeclaration* dec = CreateUnlinkedNode<XMLDeclaration>( _commentPool );
    dec->SetValue( str ? str : ""xml version=\\""1.0\\"" encoding=\\""UTF-8\\"""" );
    return dec;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.NewDeclaration:tinyxml2.XMLDeclaration*(char*),<empty>,,false,2308,2313,NewDeclaration,,,1,tinyxml2.XMLDeclaration*(char*)
111669150146,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLUnknown* XMLDocument::NewUnknown( const char* str )
{
    XMLUnknown* unk = CreateUnlinkedNode<XMLUnknown>( _commentPool );
    unk->SetValue( str );
    return unk;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.NewUnknown:tinyxml2.XMLUnknown*(char*),<empty>,,false,2316,2321,NewUnknown,,,1,tinyxml2.XMLUnknown*(char*)
111669150147,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"static FILE* callfopen( const char* filepath, const char* mode )
{
    TIXMLASSERT( filepath );
    TIXMLASSERT( mode );
#if defined(_MSC_VER) && (_MSC_VER >= 1400 ) && (!defined WINCE)
    FILE* fp = 0;
    const errno_t err = fopen_s( &fp, filepath, mode );
    if ( err ) {
        return 0;
    }
#else
    FILE* fp = fopen( filepath, mode );
#endif
    return fp;
}",1,4,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.callfopen:FILE(char*,char*)",<empty>,,false,2323,2337,callfopen,,,1,"FILE(char*,char*)"
111669150148,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLDocument::DeleteNode( XMLNode* node )	{
    TIXMLASSERT( node );
    TIXMLASSERT(node->_document == this );
    if (node->_parent) {
        node->_parent->DeleteChild( node );
    }
    else {
        // Isn't in the tree.
        // Use the parent delete.
        // Also, we need to mark it tracked: we 'know'
        // it was never used.
        node->_memPool->SetTracked();
        // Call the static XMLNode version:
        XMLNode::DeleteNode(node);
    }
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.DeleteNode:void(tinyxml2.XMLNode*),<empty>,,false,2339,2354,DeleteNode,,,1,void(tinyxml2.XMLNode*)
111669150149,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLError XMLDocument::LoadFile( const char* filename )
{
    if ( !filename ) {
        TIXMLASSERT( false );
        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, ""filename=<null>"" );
        return _errorID;
    }

    Clear();
    FILE* fp = callfopen( filename, ""rb"" );
    if ( !fp ) {
        SetError( XML_ERROR_FILE_NOT_FOUND, 0, ""filename=%s"", filename );
        return _errorID;
    }
    LoadFile( fp );
    fclose( fp );
    return _errorID;
}",1,8,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.LoadFile:tinyxml2.XMLError(char*),<empty>,,false,2357,2374,LoadFile,,,1,tinyxml2.XMLError(char*)
111669150150,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLError XMLDocument::LoadFile( FILE* fp )
{
    Clear();

    TIXML_FSEEK( fp, 0, SEEK_SET );
    if ( fgetc( fp ) == EOF && ferror( fp ) != 0 ) {
        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
        return _errorID;
    }

    TIXML_FSEEK( fp, 0, SEEK_END );

    unsigned long long filelength;
    {
        const long long fileLengthSigned = TIXML_FTELL( fp );
        TIXML_FSEEK( fp, 0, SEEK_SET );
        if ( fileLengthSigned == -1L ) {
            SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
            return _errorID;
        }
        TIXMLASSERT( fileLengthSigned >= 0 );
        filelength = static_cast<unsigned long long>(fileLengthSigned);
    }

    const size_t maxSizeT = static_cast<size_t>(-1);
    // We'll do the comparison as an unsigned long long, because that's guaranteed to be at
    // least 8 bytes, even on a 32-bit platform.
    if ( filelength >= static_cast<unsigned long long>(maxSizeT) ) {
        // Cannot handle files which won't fit in buffer to...",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.LoadFile:tinyxml2.XMLError(FILE*),<empty>,,false,2376,2427,LoadFile,,,1,tinyxml2.XMLError(FILE*)
111669150151,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLError XMLDocument::SaveFile( const char* filename, bool compact )
{
    if ( !filename ) {
        TIXMLASSERT( false );
        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, ""filename=<null>"" );
        return _errorID;
    }

    FILE* fp = callfopen( filename, ""w"" );
    if ( !fp ) {
        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, ""filename=%s"", filename );
        return _errorID;
    }
    SaveFile(fp, compact);
    fclose( fp );
    return _errorID;
}",1,8,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLDocument.SaveFile:tinyxml2.XMLError(char*,bool)",<empty>,,false,2430,2446,SaveFile,,,1,"tinyxml2.XMLError(char*,bool)"
111669150152,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLError XMLDocument::SaveFile( FILE* fp, bool compact )
{
    // Clear any error from the last save, otherwise it will get reported
    // for *this* call.
    ClearError();
    XMLPrinter stream( fp, compact );
    Print( &stream );
    return _errorID;
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLDocument.SaveFile:tinyxml2.XMLError(FILE*,bool)",<empty>,,false,2449,2457,SaveFile,,,1,"tinyxml2.XMLError(FILE*,bool)"
111669150153,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLError XMLDocument::Parse( const char* xml, size_t nBytes )
{
    Clear();

    if ( nBytes == 0 || !xml || !*xml ) {
        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );
        return _errorID;
    }
    if ( nBytes == static_cast<size_t>(-1) ) {
        nBytes = strlen( xml );
    }
    TIXMLASSERT( _charBuffer == 0 );
    _charBuffer = new char[ nBytes+1 ];
    memcpy( _charBuffer, xml, nBytes );
    _charBuffer[nBytes] = 0;

    Parse();
    if ( Error() ) {
        // clean up now essentially dangling memory.
        // and the parse fail can put objects in the
        // pools that are dead and inaccessible.
        DeleteChildren();
        _elementPool.Clear();
        _attributePool.Clear();
        _textPool.Clear();
        _commentPool.Clear();
    }
    return _errorID;
}",1,4,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLDocument.Parse:tinyxml2.XMLError(char*,size_t)",<empty>,,false,2460,2488,Parse,,,1,"tinyxml2.XMLError(char*,size_t)"
111669150154,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLDocument::Print( XMLPrinter* streamer ) const
{
    if ( streamer ) {
        Accept( streamer );
    }
    else {
        XMLPrinter stdoutStreamer( stdout );
        Accept( &stdoutStreamer );
    }
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.Print<const>:void(tinyxml2.XMLPrinter*),<empty>,,false,2491,2500,Print,,,1,void(tinyxml2.XMLPrinter*)
111669150155,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLDocument::ClearError() {
    _errorID = XML_SUCCESS;
    _errorLineNum = 0;
    _errorStr.Reset();
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.ClearError:void(),<empty>,,false,2503,2507,ClearError,,,1,void()
111669150156,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLDocument::SetError( XMLError error, int lineNum, const char* format, ... )
{
    TIXMLASSERT( error >= 0 && error < XML_ERROR_COUNT );
    _errorID = error;
    _errorLineNum = lineNum;
	_errorStr.Reset();

    const size_t BUFFER_SIZE = 1000;
    char* buffer = new char[BUFFER_SIZE];

    TIXMLASSERT(sizeof(error) <= sizeof(int));
    TIXML_SNPRINTF(buffer, BUFFER_SIZE, ""Error=%s ErrorID=%d (0x%x) Line number=%d"", ErrorIDToName(error), int(error), int(error), lineNum);

	if (format) {
		size_t len = strlen(buffer);
		TIXML_SNPRINTF(buffer + len, BUFFER_SIZE - len, "": "");
		len = strlen(buffer);

		va_list va;
		va_start(va, format);
		TIXML_VSNPRINTF(buffer + len, BUFFER_SIZE - len, format, va);
		va_end(va);
	}
	_errorStr.SetStr(buffer);
	delete[] buffer;
}",1,4,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLDocument.SetError:void(tinyxml2.XMLError,int,char*...)",<empty>,,false,2510,2535,SetError,,,1,"void(tinyxml2.XMLError,int,char*...)"
111669150157,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"const char* XMLDocument::ErrorIDToName(XMLError errorID)
{
	TIXMLASSERT( errorID >= 0 && errorID < XML_ERROR_COUNT );
    const char* errorName = _errorNames[errorID];
    TIXMLASSERT( errorName && errorName[0] );
    return errorName;
}",12,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.ErrorIDToName:char*(tinyxml2.XMLError),<empty>,,false,2538,2544,ErrorIDToName,,,1,char*(tinyxml2.XMLError)
111669150158,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"const char* XMLDocument::ErrorStr() const
{
	return _errorStr.Empty() ? """" : _errorStr.GetStr();
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.ErrorStr<const>:char*(),<empty>,,false,2546,2549,ErrorStr,,,1,char*()
111669150159,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLDocument::PrintError() const
{
    printf(""%s\\n"", ErrorStr());
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.PrintError<const>:void(),<empty>,,false,2552,2555,PrintError,,,1,void()
111669150160,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"const char* XMLDocument::ErrorName() const
{
    return ErrorIDToName(_errorID);
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.ErrorName<const>:char*(),<empty>,,false,2557,2560,ErrorName,,,1,char*()
111669150161,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLDocument::Parse()
{
    TIXMLASSERT( NoChildren() ); // Clear() must have been called previously
    TIXMLASSERT( _charBuffer );
    _parseCurLineNum = 1;
    _parseLineNum = 1;
    char* p = _charBuffer;
    p = XMLUtil::SkipWhiteSpace( p, &_parseCurLineNum );
    p = const_cast<char*>( XMLUtil::ReadBOM( p, &_writeBOM ) );
    if ( !*p ) {
        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );
        return;
    }
    ParseDeep(p, 0, &_parseCurLineNum );
}",1,4,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.Parse:void(),<empty>,,false,2562,2576,Parse,,,1,void()
111669150162,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLDocument::PushDepth()
{
	_parsingDepth++;
	if (_parsingDepth == TINYXML2_MAX_ELEMENT_DEPTH) {
		SetError(XML_ELEMENT_DEPTH_EXCEEDED, _parseCurLineNum, ""Element nesting is too deep."" );
	}
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.PushDepth:void(),<empty>,,false,2578,2584,PushDepth,,,1,void()
111669150163,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLDocument::PopDepth()
{
	TIXMLASSERT(_parsingDepth > 0);
	--_parsingDepth;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLDocument.PopDepth:void(),<empty>,,false,2586,2590,PopDepth,,,1,void()
111669150164,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"XMLPrinter::XMLPrinter( FILE* file, bool compact, int depth ) :
    _elementJustOpened( false ),
    _stack(),
    _firstElement( true ),
    _fp( file ),
    _depth( depth ),
    _textDepth( -1 ),
    _processEntities( true ),
    _compactMode( compact ),
    _buffer()
{
    for( int i=0; i<ENTITY_RANGE; ++i ) {
        _entityFlag[i] = false;
        _restrictedEntityFlag[i] = false;
    }
    for( int i=0; i<NUM_ENTITIES; ++i ) {
        const char entityValue = entities[i].value;
        const unsigned char flagIndex = static_cast<unsigned char>(entityValue);
        TIXMLASSERT( flagIndex < ENTITY_RANGE );
        _entityFlag[flagIndex] = true;
    }
    _restrictedEntityFlag[static_cast<unsigned char>('&')] = true;
    _restrictedEntityFlag[static_cast<unsigned char>('<')] = true;
    _restrictedEntityFlag[static_cast<unsigned char>('>')] = true;	// not required, but consistency is nice
    _buffer.Push( 0 );
}",1,8,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLPrinter.XMLPrinter:ANY(FILE*,bool,int)",<empty>,,false,2592,2617,XMLPrinter,,,1,"tinyxml2.XMLPrinter.XMLPrinter:ANY(FILE*,bool,int)(FILE*,bool,int)"
111669150165,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::Print( const char* format, ... )
{
    va_list     va;
    va_start( va, format );

    if ( _fp ) {
        vfprintf( _fp, format, va );
    }
    else {
        const int len = TIXML_VSCPRINTF( format, va );
        // Close out and re-start the va-args
        va_end( va );
        TIXMLASSERT( len >= 0 );
        va_start( va, format );
        TIXMLASSERT( _buffer.Size() > 0 && _buffer[_buffer.Size() - 1] == 0 );
        char* p = _buffer.PushArr( len ) - 1;	// back up over the null terminator.
		TIXML_VSNPRINTF( p, len+1, format, va );
    }
    va_end( va );
}",1,8,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.Print:void(char*...),<empty>,,false,2620,2639,Print,,,1,void(char*...)
111669150166,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::Write( const char* data, size_t size )
{
    if ( _fp ) {
        fwrite ( data , sizeof(char), size, _fp);
    }
    else {
        char* p = _buffer.PushArr( static_cast<int>(size) ) - 1;   // back up over the null terminator.
        memcpy( p, data, size );
        p[size] = 0;
    }
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLPrinter.Write:void(char*,size_t)",<empty>,,false,2642,2652,Write,,,1,"void(char*,size_t)"
111669150167,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::Putc( char ch )
{
    if ( _fp ) {
        fputc ( ch, _fp);
    }
    else {
        char* p = _buffer.PushArr( sizeof(char) ) - 1;   // back up over the null terminator.
        p[0] = ch;
        p[1] = 0;
    }
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.Putc:void(char),<empty>,,false,2655,2665,Putc,,,1,void(char)
111669150168,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PrintSpace( int depth )
{
    for( int i=0; i<depth; ++i ) {
        Write( ""    "" );
    }
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.PrintSpace:void(int),<empty>,,false,2668,2673,PrintSpace,,,1,void(int)
111669150169,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PrintString( const char* p, bool restricted )
{
    // Look for runs of bytes between entities to print.
    const char* q = p;

    if ( _processEntities ) {
        const bool* flag = restricted ? _restrictedEntityFlag : _entityFlag;
        while ( *q ) {
            TIXMLASSERT( p <= q );
            // Remember, char is sometimes signed. (How many times has that bitten me?)
            if ( *q > 0 && *q < ENTITY_RANGE ) {
                // Check for entities. If one is found, flush
                // the stream up until the entity, write the
                // entity, and keep looking.
                if ( flag[static_cast<unsigned char>(*q)] ) {
                    while ( p < q ) {
                        const size_t delta = q - p;
                        const int toPrint = ( INT_MAX < delta ) ? INT_MAX : static_cast<int>(delta);
                        Write( p, toPrint );
                        p += toPrint;
                    }
                    boo...",1,12,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLPrinter.PrintString:void(char*,bool)",<empty>,,false,2676,2728,PrintString,,,1,"void(char*,bool)"
111669150170,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PushHeader( bool writeBOM, bool writeDec )
{
    if ( writeBOM ) {
        static const unsigned char bom[] = { TIXML_UTF_LEAD_0, TIXML_UTF_LEAD_1, TIXML_UTF_LEAD_2, 0 };
        Write( reinterpret_cast< const char* >( bom ) );
    }
    if ( writeDec ) {
        PushDeclaration( ""xml version=\\""1.0\\"""" );
    }
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLPrinter.PushHeader:void(bool,bool)",<empty>,,false,2731,2740,PushHeader,,,1,"void(bool,bool)"
111669150171,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PrepareForNewNode( bool compactMode )
{
    SealElementIfJustOpened();

    if ( compactMode ) {
        return;
    }

    if ( _firstElement ) {
        PrintSpace (_depth);
    } else if ( _textDepth < 0) {
        Putc( '\\n' );
        PrintSpace( _depth );
    }

    _firstElement = false;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.PrepareForNewNode:void(bool),<empty>,,false,2742,2758,PrepareForNewNode,,,1,void(bool)
111669150172,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::OpenElement( const char* name, bool compactMode )
{
    PrepareForNewNode( compactMode );
    _stack.Push( name );

    Write ( ""<"" );
    Write ( name );

    _elementJustOpened = true;
    ++_depth;
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLPrinter.OpenElement:void(char*,bool)",<empty>,,false,2760,2770,OpenElement,,,1,"void(char*,bool)"
111669150173,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PushAttribute( const char* name, const char* value )
{
    TIXMLASSERT( _elementJustOpened );
    Putc ( ' ' );
    Write( name );
    Write( ""=\\"""" );
    PrintString( value, false );
    Putc ( '\\""' );
}",1,4,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLPrinter.PushAttribute:void(char*,char*)",<empty>,,false,2773,2781,PushAttribute,,,1,"void(char*,char*)"
111669150174,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PushAttribute( const char* name, int v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    PushAttribute( name, buf );
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLPrinter.PushAttribute:void(char*,int)",<empty>,,false,2784,2789,PushAttribute,,,1,"void(char*,int)"
111669150175,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PushAttribute( const char* name, unsigned v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    PushAttribute( name, buf );
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLPrinter.PushAttribute:void(char*,unsigned)",<empty>,,false,2792,2797,PushAttribute,,,1,"void(char*,unsigned)"
111669150176,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PushAttribute(const char* name, int64_t v)
{
	char buf[BUF_SIZE];
	XMLUtil::ToStr(v, buf, BUF_SIZE);
	PushAttribute(name, buf);
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLPrinter.PushAttribute:void(char*,int64_t)",<empty>,,false,2800,2805,PushAttribute,,,1,"void(char*,int64_t)"
111669150177,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PushAttribute(const char* name, uint64_t v)
{
	char buf[BUF_SIZE];
	XMLUtil::ToStr(v, buf, BUF_SIZE);
	PushAttribute(name, buf);
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLPrinter.PushAttribute:void(char*,uint64_t)",<empty>,,false,2808,2813,PushAttribute,,,1,"void(char*,uint64_t)"
111669150178,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PushAttribute( const char* name, bool v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    PushAttribute( name, buf );
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLPrinter.PushAttribute:void(char*,bool)",<empty>,,false,2816,2821,PushAttribute,,,1,"void(char*,bool)"
111669150179,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PushAttribute( const char* name, double v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    PushAttribute( name, buf );
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLPrinter.PushAttribute:void(char*,double)",<empty>,,false,2824,2829,PushAttribute,,,1,"void(char*,double)"
111669150180,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::CloseElement( bool compactMode )
{
    --_depth;
    const char* name = _stack.Pop();

    if ( _elementJustOpened ) {
        Write( ""/>"" );
    }
    else {
        if ( _textDepth < 0 && !compactMode) {
            Putc( '\\n' );
            PrintSpace( _depth );
        }
        Write ( ""</"" );
        Write ( name );
        Write ( "">"" );
    }

    if ( _textDepth == _depth ) {
        _textDepth = -1;
    }
    if ( _depth == 0 && !compactMode) {
        Putc( '\\n' );
    }
    _elementJustOpened = false;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.CloseElement:void(bool),<empty>,,false,2832,2857,CloseElement,,,1,void(bool)
111669150181,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::SealElementIfJustOpened()
{
    if ( !_elementJustOpened ) {
        return;
    }
    _elementJustOpened = false;
    Putc( '>' );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.SealElementIfJustOpened:void(),<empty>,,false,2860,2867,SealElementIfJustOpened,,,1,void()
111669150182,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PushText( const char* text, bool cdata )
{
    _textDepth = _depth-1;

    SealElementIfJustOpened();
    if ( cdata ) {
        Write( ""<![CDATA["" );
        Write( text );
        Write( ""]]>"" );
    }
    else {
        PrintString( text, true );
    }
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLPrinter.PushText:void(char*,bool)",<empty>,,false,2870,2883,PushText,,,1,"void(char*,bool)"
111669150183,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PushText( int64_t value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.PushText:void(int64_t),<empty>,,false,2886,2891,PushText,,,1,void(int64_t)
111669150184,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PushText( uint64_t value )
{
	char buf[BUF_SIZE];
	XMLUtil::ToStr(value, buf, BUF_SIZE);
	PushText(buf, false);
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.PushText:void(uint64_t),<empty>,,false,2894,2899,PushText,,,1,void(uint64_t)
111669150185,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PushText( int value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.PushText:void(int),<empty>,,false,2902,2907,PushText,,,1,void(int)
111669150186,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PushText( unsigned value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.PushText:void(unsigned),<empty>,,false,2910,2915,PushText,,,1,void(unsigned)
111669150187,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PushText( bool value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.PushText:void(bool),<empty>,,false,2918,2923,PushText,,,1,void(bool)
111669150188,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PushText( float value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.PushText:void(float),<empty>,,false,2926,2931,PushText,,,1,void(float)
111669150189,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PushText( double value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.PushText:void(double),<empty>,,false,2934,2939,PushText,,,1,void(double)
111669150190,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PushComment( const char* comment )
{
    PrepareForNewNode( _compactMode );

    Write( ""<!--"" );
    Write( comment );
    Write( ""-->"" );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.PushComment:void(char*),<empty>,,false,2942,2949,PushComment,,,1,void(char*)
111669150191,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PushDeclaration( const char* value )
{
    PrepareForNewNode( _compactMode );

    Write( ""<?"" );
    Write( value );
    Write( ""?>"" );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.PushDeclaration:void(char*),<empty>,,false,2952,2959,PushDeclaration,,,1,void(char*)
111669150192,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"void XMLPrinter::PushUnknown( const char* value )
{
    PrepareForNewNode( _compactMode );

    Write( ""<!"" );
    Write( value );
    Putc( '>' );
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.PushUnknown:void(char*),<empty>,,false,2962,2969,PushUnknown,,,1,void(char*)
111669150193,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLPrinter::VisitEnter( const XMLDocument& doc )
{
    _processEntities = doc.ProcessEntities();
    if ( doc.HasBOM() ) {
        PushHeader( true, false );
    }
    return true;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.VisitEnter:bool(tinyxml2.XMLDocument&),<empty>,,false,2972,2979,VisitEnter,,,1,bool(tinyxml2.XMLDocument&)
111669150194,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLPrinter::VisitEnter( const XMLElement& element, const XMLAttribute* attribute )
{
    const XMLElement* parentElem = 0;
    if ( element.Parent() ) {
        parentElem = element.Parent()->ToElement();
    }
    const bool compactMode = parentElem ? CompactMode( *parentElem ) : _compactMode;
    OpenElement( element.Name(), compactMode );
    while ( attribute ) {
        PushAttribute( attribute->Name(), attribute->Value() );
        attribute = attribute->Next();
    }
    return true;
}",1,1,externals/tinyxml2/tinyxml2.cpp,"tinyxml2.XMLPrinter.VisitEnter:bool(tinyxml2.XMLElement&,tinyxml2.XMLAttribute*)",<empty>,,false,2982,2995,VisitEnter,,,1,"bool(tinyxml2.XMLElement&,tinyxml2.XMLAttribute*)"
111669150195,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLPrinter::VisitExit( const XMLElement& element )
{
    CloseElement( CompactMode(element) );
    return true;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.VisitExit:bool(tinyxml2.XMLElement&),<empty>,,false,2998,3002,VisitExit,,,1,bool(tinyxml2.XMLElement&)
111669150196,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLPrinter::Visit( const XMLText& text )
{
    PushText( text.Value(), text.CData() );
    return true;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.Visit:bool(tinyxml2.XMLText&),<empty>,,false,3005,3009,Visit,,,1,bool(tinyxml2.XMLText&)
111669150197,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLPrinter::Visit( const XMLComment& comment )
{
    PushComment( comment.Value() );
    return true;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.Visit:bool(tinyxml2.XMLComment&),<empty>,,false,3012,3016,Visit,,,1,bool(tinyxml2.XMLComment&)
111669150198,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLPrinter::Visit( const XMLDeclaration& declaration )
{
    PushDeclaration( declaration.Value() );
    return true;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.Visit:bool(tinyxml2.XMLDeclaration&),<empty>,,false,3018,3022,Visit,,,1,bool(tinyxml2.XMLDeclaration&)
111669150199,METHOD,externals/tinyxml2/tinyxml2.cpp:<global>,TYPE_DECL,"bool XMLPrinter::Visit( const XMLUnknown& unknown )
{
    PushUnknown( unknown.Value() );
    return true;
}",1,1,externals/tinyxml2/tinyxml2.cpp,tinyxml2.XMLPrinter.Visit:bool(tinyxml2.XMLUnknown&),<empty>,,false,3025,3029,Visit,,,1,bool(tinyxml2.XMLUnknown&)
111669150200,METHOD,externals/tinyxml2/tinyxml2.h:<global>,TYPE_DECL,<global>,1,6,externals/tinyxml2/tinyxml2.h,externals/tinyxml2/tinyxml2.h:<global>,<empty>,,false,1,2384,<global>,,,1,
111669150201,METHOD,gui/aboutdialog.cpp:<global>,TYPE_DECL,"AboutDialog::AboutDialog(const QString &version, const QString &extraVersion, QWidget *parent)
    : QDialog(parent)
    , mUI(new Ui::About)
{
    mUI->setupUi(this);

    QString fmtVersion(version);
    if (!extraVersion.isEmpty()) {
        fmtVersion += "" ("" + extraVersion + "")"";
    }
    mUI->mVersion->setText(mUI->mVersion->text().arg(fmtVersion));
    QString date = __DATE__;
    mUI->mCopyright->setText(mUI->mCopyright->text().arg(date.right(4)));
    QString url = ""<a href=\\""https://cppcheck.sourceforge.io/\\"">https://cppcheck.sourceforge.io/</a>"";
    mUI->mHomepage->setText(mUI->mHomepage->text().arg(url));
    connect(mUI->mButtons, &QDialogButtonBox::accepted, this, &AboutDialog::accept);
}",1,19,gui/aboutdialog.cpp,"AboutDialog.AboutDialog:ANY(QString&,QString&,QWidget*)",<empty>,,false,26,42,AboutDialog,,,1,"AboutDialog.AboutDialog:ANY(QString&,QString&,QWidget*)(QString&,QString&,QWidget*)"
111669150202,METHOD,gui/aboutdialog.cpp:<global>,TYPE_DECL,<global>,1,1,gui/aboutdialog.cpp,gui/aboutdialog.cpp:<global>,<empty>,,false,1,47,<global>,,,1,
111669150203,METHOD,gui/aboutdialog.cpp:<global>,TYPE_DECL,"AboutDialog::~AboutDialog()
{
    delete mUI;
}",1,1,gui/aboutdialog.cpp,AboutDialog.~AboutDialog:ANY(),<empty>,,false,44,47,~AboutDialog,,,1,ANY()
111669150204,METHOD,gui/aboutdialog.h:<global>,TYPE_DECL,<global>,1,24,gui/aboutdialog.h,gui/aboutdialog.h:<global>,<empty>,,false,1,51,<global>,,,1,
111669150205,METHOD,gui/application.cpp:<global>,TYPE_DECL,"Application::Application(QString name, QString path,
                         QString params)
    : mName(std::move(name))
    , mPath(std::move(path))
    , mParameters(std::move(params))
{}",1,2,gui/application.cpp,"Application.Application:ANY(QString,QString,QString)",<empty>,,false,23,28,Application,,,1,"Application.Application:ANY(QString,QString,QString)(QString,QString,QString)"
111669150206,METHOD,gui/application.cpp:<global>,TYPE_DECL,<global>,1,1,gui/application.cpp,gui/application.cpp:<global>,<empty>,,false,1,28,<global>,,,1,
111669150207,METHOD,gui/application.h:<global>,TYPE_DECL,<global>,1,23,gui/application.h,gui/application.h:<global>,<empty>,,false,1,114,<global>,,,1,
111669150208,METHOD,gui/applicationdialog.cpp:<global>,TYPE_DECL,"ApplicationDialog::ApplicationDialog(const QString &title,
                                     Application &app,
                                     QWidget *parent) :
    QDialog(parent),
    mUI(new Ui::ApplicationDialog),
    mApplication(app)
{
    mUI->setupUi(this);

    connect(mUI->mButtonBrowse, &QPushButton::clicked, this, &ApplicationDialog::browse);
    connect(mUI->mButtons, &QDialogButtonBox::accepted, this, &ApplicationDialog::ok);
    connect(mUI->mButtons, &QDialogButtonBox::rejected, this, &ApplicationDialog::reject);
    mUI->mPath->setText(app.getPath());
    mUI->mName->setText(app.getName());
    mUI->mParameters->setText(app.getParameters());
    setWindowTitle(title);
    adjustSize();
}",1,1,gui/applicationdialog.cpp,"ApplicationDialog.ApplicationDialog:ANY(QString&,Application&,QWidget*)",<empty>,,false,34,51,ApplicationDialog,,,1,"ApplicationDialog.ApplicationDialog:ANY(QString&,Application&,QWidget*)(QString&,Application&,QWidget*)"
111669150209,METHOD,gui/applicationdialog.cpp:<global>,TYPE_DECL,<global>,1,1,gui/applicationdialog.cpp,gui/applicationdialog.cpp:<global>,<empty>,,false,1,99,<global>,,,1,
111669150210,METHOD,gui/applicationdialog.cpp:<global>,TYPE_DECL,"ApplicationDialog::~ApplicationDialog()
{
    delete mUI;
}",1,1,gui/applicationdialog.cpp,ApplicationDialog.~ApplicationDialog:ANY(),<empty>,,false,54,57,~ApplicationDialog,,,1,ANY()
111669150211,METHOD,gui/applicationdialog.cpp:<global>,TYPE_DECL,"void ApplicationDialog::browse()
{
    QString filter;
#ifdef Q_OS_WIN
    // In Windows (almost) all executables have .exe extension
    // so it does not make sense to show everything.
    filter += tr(""Executable files (*.exe);;All files(*.*)"");
#endif // Q_OS_WIN
    QString selectedFile = QFileDialog::getOpenFileName(this,
                                                        tr(""Select viewer application""),
                                                        getPath(SETTINGS_LAST_APP_PATH),
                                                        filter);

    if (!selectedFile.isEmpty()) {
        setPath(SETTINGS_LAST_APP_PATH, selectedFile);
        QString path(QDir::toNativeSeparators(selectedFile));
        mUI->mPath->setText(path);
    }
}",1,64,gui/applicationdialog.cpp,ApplicationDialog.browse:void(),<empty>,,false,59,77,browse,,,1,void()
111669150212,METHOD,gui/applicationdialog.cpp:<global>,TYPE_DECL,"void ApplicationDialog::ok()
{
    if (mUI->mName->text().isEmpty() || mUI->mPath->text().isEmpty()) {
        QMessageBox msg(QMessageBox::Warning,
                        tr(""Cppcheck""),
                        tr(""You must specify a name, a path and optionally parameters for the application!""),
                        QMessageBox::Ok,
                        this);

        msg.exec();

        reject();
    } else {
        // Convert possible native (Windows) path to internal presentation format
        mApplication.setName(mUI->mName->text());
        mApplication.setPath(QDir::fromNativeSeparators(mUI->mPath->text()));
        mApplication.setParameters(mUI->mParameters->text());

        accept();
    }
}",1,1,gui/applicationdialog.cpp,ApplicationDialog.ok:void(),<empty>,,false,79,99,ok,,,1,void()
111669150213,METHOD,gui/applicationdialog.h:<global>,TYPE_DECL,<global>,1,29,gui/applicationdialog.h,gui/applicationdialog.h:<global>,<empty>,,false,1,82,<global>,,,1,
111669150214,METHOD,gui/applicationlist.cpp:<global>,TYPE_DECL,"ApplicationList::ApplicationList(QObject *parent) :
    QObject(parent)
{
    //ctor
}",1,1,gui/applicationlist.cpp,ApplicationList.ApplicationList:ANY(QObject*),<empty>,,false,29,33,ApplicationList,,,1,ApplicationList.ApplicationList:ANY(QObject*)(QObject*)
111669150215,METHOD,gui/applicationlist.cpp:<global>,TYPE_DECL,<global>,1,1,gui/applicationlist.cpp,gui/applicationlist.cpp:<global>,<empty>,,false,1,266,<global>,,,1,
111669150216,METHOD,gui/applicationlist.cpp:<global>,TYPE_DECL,"ApplicationList::~ApplicationList()
{
    clear();
}",1,1,gui/applicationlist.cpp,ApplicationList.~ApplicationList:ANY(),<empty>,,false,35,38,~ApplicationList,,,1,ANY()
111669150217,METHOD,gui/applicationlist.cpp:<global>,TYPE_DECL,"bool ApplicationList::loadSettings()
{
    QSettings settings;
    QStringList names = settings.value(SETTINGS_APPLICATION_NAMES, QStringList()).toStringList();
    QStringList paths = settings.value(SETTINGS_APPLICATION_PATHS, QStringList()).toStringList();
    QStringList params = settings.value(SETTINGS_APPLICATION_PARAMS, QStringList()).toStringList();
    int defapp = settings.value(SETTINGS_APPLICATION_DEFAULT, -1).toInt();

    // Params will be empty first time starting with the new setting.
    // Return false and inform user about problem with application settings.
    bool succeeded = true;
    if (!names.empty() && !paths.empty() && params.empty()) {
        for (int i = 0; i < paths.length(); i++)
            params << QString();
        succeeded = false;
    }

    if (names.empty() && paths.empty() && params.empty()) {
#ifndef _WIN32
        // use as default for gnome environments
        if (QFileInfo(""/usr/bin/gedit"").isExecutable()) {
            Application app;...",1,39,gui/applicationlist.cpp,ApplicationList.loadSettings:bool(),<empty>,,false,40,99,loadSettings,,,1,bool()
111669150218,METHOD,gui/applicationlist.cpp:<global>,TYPE_DECL,"void ApplicationList::saveSettings() const
{
    QSettings settings;
    QStringList names;
    QStringList paths;
    QStringList params;

    for (int i = 0; i < getApplicationCount(); i++) {
        const Application& app = getApplication(i);
        names << app.getName();
        paths << app.getPath();
        params << app.getParameters();
    }

    settings.setValue(SETTINGS_APPLICATION_NAMES, names);
    settings.setValue(SETTINGS_APPLICATION_PATHS, paths);
    settings.setValue(SETTINGS_APPLICATION_PARAMS, params);
    settings.setValue(SETTINGS_APPLICATION_DEFAULT, mDefaultApplicationIndex);
}",1,22,gui/applicationlist.cpp,ApplicationList.saveSettings<const>:void(),<empty>,,false,101,119,saveSettings,,,1,void()
111669150219,METHOD,gui/applicationlist.cpp:<global>,TYPE_DECL,"int ApplicationList::getApplicationCount() const
{
    return mApplications.size();
}",1,1,gui/applicationlist.cpp,ApplicationList.getApplicationCount<const>:int(),<empty>,,false,121,124,getApplicationCount,,,1,int()
111669150220,METHOD,gui/applicationlist.cpp:<global>,TYPE_DECL,"Application& ApplicationList::getApplication(const int index)
{
    if (index >= 0 && index < mApplications.size()) {
        return mApplications[index];
    }

    static Application dummy; // TODO: Throw exception instead?
    return dummy;
}",1,1,gui/applicationlist.cpp,ApplicationList.getApplication:Application&(int),<empty>,,false,126,134,getApplication,,,1,Application&(int)
111669150221,METHOD,gui/applicationlist.cpp:<global>,TYPE_DECL,"const Application& ApplicationList::getApplication(const int index) const
{
    if (index >= 0 && index < mApplications.size()) {
        return mApplications[index];
    }

    static const Application dummy; // TODO: Throw exception instead?
    return dummy;
}",1,1,gui/applicationlist.cpp,ApplicationList.getApplication<const>:Application&(int),<empty>,,false,136,144,getApplication,,,1,Application&(int)
111669150222,METHOD,gui/applicationlist.cpp:<global>,TYPE_DECL,"void ApplicationList::addApplication(const Application &app)
{
    if (app.getName().isEmpty() || app.getPath().isEmpty()) {
        return;
    }
    mApplications << app;
}",1,1,gui/applicationlist.cpp,ApplicationList.addApplication:void(Application&),<empty>,,false,146,152,addApplication,,,1,void(Application&)
111669150223,METHOD,gui/applicationlist.cpp:<global>,TYPE_DECL,"void ApplicationList::removeApplication(const int index)
{
    mApplications.removeAt(index);
}",1,1,gui/applicationlist.cpp,ApplicationList.removeApplication:void(int),<empty>,,false,154,157,removeApplication,,,1,void(int)
111669150224,METHOD,gui/applicationlist.cpp:<global>,TYPE_DECL,"void ApplicationList::setDefault(const int index)
{
    if (index < mApplications.size() && index >= 0) {
        mDefaultApplicationIndex = index;
    }
}",1,1,gui/applicationlist.cpp,ApplicationList.setDefault:void(int),<empty>,,false,159,164,setDefault,,,1,void(int)
111669150225,METHOD,gui/applicationlist.cpp:<global>,TYPE_DECL,"void ApplicationList::copy(const ApplicationList *list)
{
    if (!list) {
        return;
    }

    clear();
    for (int i = 0; i < list->getApplicationCount(); i++) {
        const Application& app = list->getApplication(i);
        addApplication(app);
    }
    mDefaultApplicationIndex = list->getDefaultApplication();
}",1,1,gui/applicationlist.cpp,ApplicationList.copy:void(ApplicationList*),<empty>,,false,166,178,copy,,,1,void(ApplicationList*)
111669150226,METHOD,gui/applicationlist.cpp:<global>,TYPE_DECL,"void ApplicationList::clear()
{
    mApplications.clear();
    mDefaultApplicationIndex = -1;
}",1,1,gui/applicationlist.cpp,ApplicationList.clear:void(),<empty>,,false,180,184,clear,,,1,void()
111669150227,METHOD,gui/applicationlist.cpp:<global>,TYPE_DECL,"bool ApplicationList::checkAndAddApplication(const QString& appPath, const QString& name, const QString& parameters)
{
    if (QFileInfo::exists(appPath) && QFileInfo(appPath).isExecutable()) {
        Application app;
        app.setName(name);
        app.setPath(""\\"""" + appPath + ""\\"""");
        app.setParameters(parameters);
        addApplication(app);
        return true;
    }
    return false;
}",1,1,gui/applicationlist.cpp,"ApplicationList.checkAndAddApplication:bool(QString&,QString&,QString&)",<empty>,,false,186,197,checkAndAddApplication,,,1,"bool(QString&,QString&,QString&)"
111669150228,METHOD,gui/applicationlist.cpp:<global>,TYPE_DECL,"bool ApplicationList::findDefaultWindowsEditor()
{
    bool foundOne = false;
#ifdef WIN64 // As long as we do support 32-bit XP, we cannot be sure that the environment variable ""ProgramFiles(x86)"" exists
    const QString appPathx86(getenv(""ProgramFiles(x86)""));
#else
    const QString appPathx86(getenv(""ProgramFiles""));
#endif
    const QString appPathx64(getenv(""ProgramW6432""));
    const QString windowsPath(getenv(""windir""));

    if (checkAndAddApplication(appPathx86 + ""\\\\Notepad++\\\\notepad++.exe"", ""Notepad++"", ""-n(line) (file)""))
        foundOne = true;
    else if (checkAndAddApplication(appPathx64 + ""\\\\Notepad++\\\\notepad++.exe"", ""Notepad++"", ""-n(line) (file)""))
        foundOne = true;

    if (checkAndAddApplication(appPathx86 + ""\\\\Notepad2\\\\Notepad2.exe"", ""Notepad2"", ""/g (line) (file)""))
        foundOne = true;
    else if (checkAndAddApplication(appPathx64 + ""\\\\Notepad2\\\\Notepad2.exe"", ""Notepad2"", ""/g (line) (file)""))
        foundOne = true;

    if (checkAndAddApplica...",1,1,gui/applicationlist.cpp,ApplicationList.findDefaultWindowsEditor:bool(),<empty>,,false,200,265,findDefaultWindowsEditor,,,1,bool()
111669150229,METHOD,gui/applicationlist.h:<global>,TYPE_DECL,<global>,1,1,gui/applicationlist.h,gui/applicationlist.h:<global>,<empty>,,false,1,139,<global>,,,1,
111669150230,METHOD,gui/checkstatistics.cpp:<global>,TYPE_DECL,"CheckStatistics::CheckStatistics(QObject *parent)
    : QObject(parent)
{
    clear();
}",1,1,gui/checkstatistics.cpp,CheckStatistics.CheckStatistics:ANY(QObject*),<empty>,,false,25,29,CheckStatistics,,,1,CheckStatistics.CheckStatistics:ANY(QObject*)(QObject*)
111669150231,METHOD,gui/checkstatistics.cpp:<global>,TYPE_DECL,<global>,1,1,gui/checkstatistics.cpp,gui/checkstatistics.cpp:<global>,<empty>,,false,1,117,<global>,,,1,
111669150232,METHOD,gui/checkstatistics.cpp:<global>,TYPE_DECL,"static void addItem(QMap<QString,unsigned> &m, const QString &key)
{
    if (m.contains(key))
        m[key]++;
    else
        m[key] = 0;
}",1,1,gui/checkstatistics.cpp,"addItem:void(QMap<QString,unsigned>&,QString&)",<empty>,,false,31,37,addItem,,,1,"void(QMap<QString,unsigned>&,QString&)"
111669150233,METHOD,gui/checkstatistics.cpp:<global>,TYPE_DECL,"void CheckStatistics::addItem(const QString &tool, ShowTypes::ShowType type)
{
    const QString lower = tool.toLower();
    switch (type) {
    case ShowTypes::ShowStyle:
        ::addItem(mStyle, lower);
        break;
    case ShowTypes::ShowWarnings:
        ::addItem(mWarning, lower);
        break;
    case ShowTypes::ShowPerformance:
        ::addItem(mPerformance, lower);
        break;
    case ShowTypes::ShowPortability:
        ::addItem(mPortability, lower);
        break;
    case ShowTypes::ShowErrors:
        ::addItem(mError, lower);
        break;
    case ShowTypes::ShowInformation:
        ::addItem(mInformation, lower);
        break;
    case ShowTypes::ShowNone:
    default:
        qDebug() << ""Unknown error type - not added to statistics."";
        break;
    }
}",1,1,gui/checkstatistics.cpp,"CheckStatistics.addItem:void(QString&,ShowTypes.ShowType)",<empty>,,false,39,66,addItem,,,1,"void(QString&,ShowTypes.ShowType)"
111669150234,METHOD,gui/checkstatistics.cpp:<global>,TYPE_DECL,"void CheckStatistics::addChecker(const QString &checker)
{
    mActiveCheckers.insert(checker.toStdString());
}",1,1,gui/checkstatistics.cpp,CheckStatistics.addChecker:void(QString&),<empty>,,false,68,71,addChecker,,,1,void(QString&)
111669150235,METHOD,gui/checkstatistics.cpp:<global>,TYPE_DECL,"void CheckStatistics::clear()
{
    mStyle.clear();
    mWarning.clear();
    mPerformance.clear();
    mPortability.clear();
    mInformation.clear();
    mError.clear();
    mActiveCheckers.clear();
    mCheckersReport.clear();
}",1,1,gui/checkstatistics.cpp,CheckStatistics.clear:void(),<empty>,,false,73,83,clear,,,1,void()
111669150236,METHOD,gui/checkstatistics.cpp:<global>,TYPE_DECL,"unsigned CheckStatistics::getCount(const QString &tool, ShowTypes::ShowType type) const
{
    const QString lower = tool.toLower();
    switch (type) {
    case ShowTypes::ShowStyle:
        return mStyle.value(lower,0);
    case ShowTypes::ShowWarnings:
        return mWarning.value(lower,0);
    case ShowTypes::ShowPerformance:
        return mPerformance.value(lower,0);
    case ShowTypes::ShowPortability:
        return mPortability.value(lower,0);
    case ShowTypes::ShowErrors:
        return mError.value(lower,0);
    case ShowTypes::ShowInformation:
        return mInformation.value(lower,0);
    case ShowTypes::ShowNone:
    default:
        qDebug() << ""Unknown error type - returning zero statistics."";
        return 0;
    }
}",1,1,gui/checkstatistics.cpp,"CheckStatistics.getCount<const>:unsigned int(QString&,ShowTypes.ShowType)",<empty>,,false,85,106,getCount,,,1,"unsigned int(QString&,ShowTypes.ShowType)"
111669150237,METHOD,gui/checkstatistics.cpp:<global>,TYPE_DECL,"QStringList CheckStatistics::getTools() const
{
    QSet<QString> ret;
    for (const QString& tool: mStyle.keys()) ret.insert(tool);
    for (const QString& tool: mWarning.keys()) ret.insert(tool);
    for (const QString& tool: mPerformance.keys()) ret.insert(tool);
    for (const QString& tool: mPortability.keys()) ret.insert(tool);
    for (const QString& tool: mError.keys()) ret.insert(tool);
    return ret.values();
}",1,1,gui/checkstatistics.cpp,CheckStatistics.getTools<const>:QStringList(),<empty>,,false,108,117,getTools,,,1,QStringList()
111669150238,METHOD,gui/checkstatistics.h:<global>,TYPE_DECL,<global>,1,1,gui/checkstatistics.h,gui/checkstatistics.h:<global>,<empty>,,false,1,102,<global>,,,1,
111669150239,METHOD,gui/checkthread.cpp:<global>,TYPE_DECL,"static QString unquote(QString s) {
    if (s.startsWith(""\\""""))
        s = s.mid(1, s.size() - 2);
    return s;
}",1,1,gui/checkthread.cpp,unquote:QString(QString),<empty>,,false,59,63,unquote,,,1,QString(QString)
111669150240,METHOD,gui/checkthread.cpp:<global>,TYPE_DECL,<global>,1,1,gui/checkthread.cpp,gui/checkthread.cpp:<global>,<empty>,,false,1,496,<global>,,,1,
111669150241,METHOD,gui/checkthread.cpp:<global>,TYPE_DECL,"int CheckThread::executeCommand(std::string exe, std::vector<std::string> args, std::string redirect, std::string &output) // cppcheck-suppress [passedByValue,passedByValueCallback]
{
    output.clear();

    QStringList args2;
    for (const std::string &arg: args)
        args2 << QString::fromStdString(arg);

    QProcess process;

    QString e = unquote(QString::fromStdString(exe));

    if (e.toLower().replace(""\\\\"", ""/"").endsWith(""/python.exe"") && !args.empty()) {
        const QString path = e.left(e.size()-11);
        QProcessEnvironment env = QProcessEnvironment::systemEnvironment();
        env.insert(""PYTHONPATH"", path + ""/Lib/site-packages"");
        env.insert(""PYTHONHOME"", path);
        process.setProcessEnvironment(env);

        const QString pythonScript = unquote(args2[0]);
        if (pythonScript.endsWith("".py"")) {
            const QString path2 = pythonScript.left(QString(pythonScript).replace('\\\\', '/').lastIndexOf(""/""));
            process.setWorkingDirect...",1,1,gui/checkthread.cpp,"CheckThread.executeCommand:int(std.string,std.vector<std.string>,std.string,std.string&)",<empty>,,false,66,107,executeCommand,,,1,"int(std.string,std.vector<std.string>,std.string,std.string&)"
111669150242,METHOD,gui/checkthread.cpp:<global>,TYPE_DECL,"CheckThread::CheckThread(ThreadResult &result) :
    mResult(result)
{}",1,2,gui/checkthread.cpp,CheckThread.CheckThread:ANY(ThreadResult&),<empty>,,false,110,112,CheckThread,,,1,CheckThread.CheckThread:ANY(ThreadResult&)(ThreadResult&)
111669150243,METHOD,gui/checkthread.cpp:<global>,TYPE_DECL,"void CheckThread::setSettings(const Settings &settings, std::shared_ptr<Suppressions> supprs)
{
    mFiles.clear();
    mSettings = settings; // this is a copy
    mSuppressions = std::move(supprs);
}",1,1,gui/checkthread.cpp,"CheckThread.setSettings:void(Settings&,std.shared_ptr<Suppressions>)",<empty>,,false,114,119,setSettings,,,1,"void(Settings&,std.shared_ptr<Suppressions>)"
111669150244,METHOD,gui/checkthread.cpp:<global>,TYPE_DECL,"void CheckThread::analyseWholeProgram(const QStringList &files, const std::string& ctuInfo)
{
    mFiles = files;
    mAnalyseWholeProgram = true;
    mCtuInfo = ctuInfo;
    start();
}",1,1,gui/checkthread.cpp,"CheckThread.analyseWholeProgram:void(QStringList&,std.string&)",<empty>,,false,121,127,analyseWholeProgram,,,1,"void(QStringList&,std.string&)"
111669150245,METHOD,<empty>,<empty>,"[&](const QString& file) {
            return FileWithDetails{file.toStdString(), Path::identify(file.toStdString(), mSettings.cppHeaderProbe), 0};
        }",84,9,gui/checkthread.cpp,gui/checkthread.cpp:<global>.CheckThread.run.<lambda>0:FileWithDetails(QString&),<empty>,,false,142,144,<lambda>0,,,1,FileWithDetails(QString&)
111669150246,METHOD,gui/checkthread.cpp:<global>,TYPE_DECL,"void CheckThread::run()
{
    mState = Running;

    CppCheck cppcheck(mSettings, *mSuppressions, mResult, true, executeCommand);

    if (!mFiles.isEmpty() || mAnalyseWholeProgram) {
        mAnalyseWholeProgram = false;
        std::string ctuInfo;
        ctuInfo.swap(mCtuInfo);
        qDebug() << ""Whole program analysis"";
        std::list<FileWithDetails> files2;
        std::transform(mFiles.cbegin(), mFiles.cend(), std::back_inserter(files2), [&](const QString& file) {
            return FileWithDetails{file.toStdString(), Path::identify(file.toStdString(), mSettings.cppHeaderProbe), 0};
        });
        cppcheck.analyseWholeProgram(mSettings.buildDir, files2, {}, ctuInfo);
        mFiles.clear();
        emit done();
        return;
    }

    QString file = mResult.getNextFile();
    while (!file.isEmpty() && mState == Running) {
        qDebug() << ""Checking file"" << file;
        cppcheck.check(FileWithDetails(file.toStdString()));
        runAddonsAndTools(mSettings,...",1,1,gui/checkthread.cpp,CheckThread.run:void(),<empty>,,false,130,181,run,,,1,void()
111669150247,METHOD,gui/checkthread.cpp:<global>,TYPE_DECL,"void CheckThread::runAddonsAndTools(const Settings& settings, const FileSettings *fileSettings, const QString &fileName)
{
    for (const QString& addon : mAddonsAndTools) {
        if (addon == CLANG_ANALYZER || addon == CLANG_TIDY) {
            if (!fileSettings)
                continue;

            if (!fileSettings->cfg.empty() && !startsWith(fileSettings->cfg,""Debug""))
                continue;

            QStringList args;
            for (auto incIt = fileSettings->includePaths.cbegin(); incIt != fileSettings->includePaths.cend(); ++incIt)
                args << (""-I"" + QString::fromStdString(*incIt));
            for (auto i = fileSettings->systemIncludePaths.cbegin(); i != fileSettings->systemIncludePaths.cend(); ++i)
                args << ""-isystem"" << QString::fromStdString(*i);
            for (const QString& def : QString::fromStdString(fileSettings->defines).split("";"")) {
                args << (""-D"" + def);
            }
            for (const std::string& U :...",1,21,gui/checkthread.cpp,"CheckThread.runAddonsAndTools:void(Settings&,FileSettings*,QString&)",<empty>,,false,183,334,runAddonsAndTools,,,1,"void(Settings&,FileSettings*,QString&)"
111669150248,METHOD,gui/checkthread.cpp:<global>,TYPE_DECL,"void CheckThread::stop()
{
    mState = Stopping;
    Settings::terminate();
}",1,1,gui/checkthread.cpp,CheckThread.stop:void(),<empty>,,false,336,340,stop,,,1,void()
111669150249,METHOD,<empty>,<empty>,"[](const QErrorPathItem& path) {
            return ErrorMessage::FileLocation(path.file.toStdString(), path.info.toStdString(), path.line, path.column);
        }",97,9,gui/checkthread.cpp,gui/checkthread.cpp:<global>.CheckThread.parseClangErrors.<lambda>1:ErrorMessage.FileLocation(QErrorPathItem&),<empty>,,false,430,432,<lambda>1,,,1,ErrorMessage.FileLocation(QErrorPathItem&)
111669150250,METHOD,gui/checkthread.cpp:<global>,TYPE_DECL,"void CheckThread::parseClangErrors(const QString &tool, const QString &file0, QString err)
{
    QList<ErrorItem> errorItems;
    ErrorItem errorItem;
    static const QRegularExpression r1(""^(.+):([0-9]+):([0-9]+): (note|warning|error|fatal error): (.*)$"");
    static const QRegularExpression r2(""^(.*)\\\\[([a-zA-Z0-9\\\\-_\\\\.]+)\\\\]$"");
    QTextStream in(&err, QIODevice::ReadOnly);
    while (!in.atEnd()) {
        QString line = in.readLine();

        if (line.startsWith(""Assertion failed:"")) {
            ErrorItem e;
            e.errorPath.append(QErrorPathItem());
            e.errorPath.last().file   = file0;
            e.errorPath.last().line   = 1;
            e.errorPath.last().column = 1;
            e.errorId = tool + ""-internal-error"";
            e.file0 = file0;
            e.message = line;
            e.severity = Severity::information;
            errorItems.append(e);
            continue;
        }

        const QRegularExpressionMatch r1MatchRes = r1.match(line)...",1,24,gui/checkthread.cpp,"CheckThread.parseClangErrors:void(QString&,QString&,QString)",<empty>,,false,342,439,parseClangErrors,,,1,"void(QString&,QString&,QString)"
111669150251,METHOD,<empty>,<empty>,"[&](const SuppressionList::Suppression& s) {
        return s.isSuppressed(errorMessage);
    }",74,5,gui/checkthread.cpp,gui/checkthread.cpp:<global>.CheckThread.isSuppressed<const>.<lambda>2:bool(SuppressionList.Suppression&),<empty>,,false,443,445,<lambda>2,,,1,bool(SuppressionList.Suppression&)
111669150252,METHOD,gui/checkthread.cpp:<global>,TYPE_DECL,"bool CheckThread::isSuppressed(const SuppressionList::ErrorMessage &errorMessage) const
{
    return std::any_of(mSuppressionsUi.cbegin(), mSuppressionsUi.cend(), [&](const SuppressionList::Suppression& s) {
        return s.isSuppressed(errorMessage);
    });
}",1,1,gui/checkthread.cpp,CheckThread.isSuppressed<const>:bool(SuppressionList.ErrorMessage&),<empty>,,false,441,446,isSuppressed,,,1,bool(SuppressionList.ErrorMessage&)
111669150253,METHOD,gui/checkthread.cpp:<global>,TYPE_DECL,"QString CheckThread::clangCmd()
{
    QString path = QSettings().value(SETTINGS_CLANG_PATH,QString()).toString();
    if (!path.isEmpty())
        path += '/';
    path += ""clang"";
#ifdef Q_OS_WIN
    path += "".exe"";
#endif

    QProcess process;
    process.start(path, QStringList() << ""--version"");
    process.waitForFinished();
    if (process.exitCode() == 0)
        return path;

#ifdef Q_OS_WIN
    // Try to autodetect clang
    if (QFileInfo(""C:/Program Files/LLVM/bin/clang.exe"").exists())
        return ""C:/Program Files/LLVM/bin/clang.exe"";
#endif

    return QString();
}",1,37,gui/checkthread.cpp,CheckThread.clangCmd:QString(),<empty>,,false,448,471,clangCmd,,,1,QString()
111669150254,METHOD,gui/checkthread.cpp:<global>,TYPE_DECL,"QString CheckThread::clangTidyCmd()
{
    QString path = QSettings().value(SETTINGS_CLANG_PATH,QString()).toString();
    if (!path.isEmpty())
        path += '/';
    path += ""clang-tidy"";
#ifdef Q_OS_WIN
    path += "".exe"";
#endif

    QProcess process;
    process.start(path, QStringList() << ""--version"");
    process.waitForFinished();
    if (process.exitCode() == 0)
        return path;

#ifdef Q_OS_WIN
    // Try to autodetect clang-tidy
    if (QFileInfo(""C:/Program Files/LLVM/bin/clang-tidy.exe"").exists())
        return ""C:/Program Files/LLVM/bin/clang-tidy.exe"";
#endif

    return QString();
}",1,37,gui/checkthread.cpp,CheckThread.clangTidyCmd:QString(),<empty>,,false,473,496,clangTidyCmd,,,1,QString()
111669150255,METHOD,gui/checkthread.h:<global>,TYPE_DECL,<global>,1,1,gui/checkthread.h,gui/checkthread.h:<global>,<empty>,,false,1,153,<global>,,,1,
111669150256,METHOD,gui/codeeditor.cpp:<global>,TYPE_DECL,"Highlighter::Highlighter(QTextDocument *parent,
                         CodeEditorStyle *widgetStyle) :
    QSyntaxHighlighter(parent),
    mWidgetStyle(widgetStyle)
{
    HighlightingRule rule;

    mKeywordFormat.setForeground(mWidgetStyle->keywordColor);
    mKeywordFormat.setFontWeight(mWidgetStyle->keywordWeight);
    QStringList keywordPatterns;
    // TODO: use Keywords::getX()
    keywordPatterns << ""alignas""
                    << ""alignof""
                    << ""asm""
                    << ""auto""
                    << ""bool""
                    << ""break""
                    << ""case""
                    << ""catch""
                    << ""char""
                    << ""char8_t""
                    << ""char16_t""
                    << ""char32_t""
                    << ""class""
                    << ""concept""
                    << ""const""
                    << ""consteval""
                    << ""constexpr""
                    << ""constinit""
                    << ""const_...",1,1,gui/codeeditor.cpp,"Highlighter.Highlighter:ANY(QTextDocument*,CodeEditorStyle*)",<empty>,,false,43,179,Highlighter,,,1,"Highlighter.Highlighter:ANY(QTextDocument*,CodeEditorStyle*)(QTextDocument*,CodeEditorStyle*)"
111669150257,METHOD,gui/codeeditor.cpp:<global>,TYPE_DECL,<global>,1,1,gui/codeeditor.cpp,gui/codeeditor.cpp:<global>,<empty>,,false,1,460,<global>,,,1,
111669150258,METHOD,gui/codeeditor.cpp:<global>,TYPE_DECL,"void Highlighter::setSymbols(const QStringList &symbols)
{
    mHighlightingRulesWithSymbols = mHighlightingRules;
    for (const QString &sym : symbols) {
        HighlightingRule rule;
        rule.pattern = QRegularExpression(""\\\\b"" + sym + ""\\\\b"");
        rule.format = mSymbolFormat;
        rule.ruleRole = RuleRole::Symbol;
        mHighlightingRulesWithSymbols.append(rule);
    }
}",1,1,gui/codeeditor.cpp,Highlighter.setSymbols:void(QStringList&),<empty>,,false,181,191,setSymbols,,,1,void(QStringList&)
111669150259,METHOD,gui/codeeditor.cpp:<global>,TYPE_DECL,"void Highlighter::setStyle(const CodeEditorStyle &newStyle)
{
    mKeywordFormat.setForeground(newStyle.keywordColor);
    mKeywordFormat.setFontWeight(newStyle.keywordWeight);
    mClassFormat.setForeground(newStyle.classColor);
    mClassFormat.setFontWeight(newStyle.classWeight);
    mSingleLineCommentFormat.setForeground(newStyle.commentColor);
    mSingleLineCommentFormat.setFontWeight(newStyle.commentWeight);
    mMultiLineCommentFormat.setForeground(newStyle.commentColor);
    mMultiLineCommentFormat.setFontWeight(newStyle.commentWeight);
    mQuotationFormat.setForeground(newStyle.quoteColor);
    mQuotationFormat.setFontWeight(newStyle.quoteWeight);
    mSymbolFormat.setForeground(newStyle.symbolFGColor);
    mSymbolFormat.setBackground(newStyle.symbolBGColor);
    mSymbolFormat.setFontWeight(newStyle.symbolWeight);
    for (HighlightingRule& rule : mHighlightingRules) {
        applyFormat(rule);
    }

    for (HighlightingRule& rule : mHighlightingRulesWithSymbols) {
   ...",1,1,gui/codeeditor.cpp,Highlighter.setStyle:void(CodeEditorStyle&),<empty>,,false,193,215,setStyle,,,1,void(CodeEditorStyle&)
111669150260,METHOD,gui/codeeditor.cpp:<global>,TYPE_DECL,"void Highlighter::highlightBlock(const QString &text)
{
    for (const HighlightingRule &rule : mHighlightingRulesWithSymbols) {
        QRegularExpressionMatchIterator matchIterator = rule.pattern.globalMatch(text);
        while (matchIterator.hasNext()) {
            QRegularExpressionMatch match = matchIterator.next();
            setFormat(match.capturedStart(), match.capturedLength(), rule.format);
        }
    }

    setCurrentBlockState(0);

    int startIndex = 0;
    if (previousBlockState() != 1)
        startIndex = text.indexOf(mCommentStartExpression);

    while (startIndex >= 0) {
        QRegularExpressionMatch match = mCommentEndExpression.match(text, startIndex);
        const int endIndex = match.capturedStart();
        int commentLength = 0;
        if (endIndex == -1) {
            setCurrentBlockState(1);
            commentLength = text.length() - startIndex;
        } else {
            commentLength = endIndex - startIndex
                            + ma...",1,1,gui/codeeditor.cpp,Highlighter.highlightBlock:void(QString&),<empty>,,false,217,247,highlightBlock,,,1,void(QString&)
111669150261,METHOD,gui/codeeditor.cpp:<global>,TYPE_DECL,"void Highlighter::applyFormat(HighlightingRule &rule)
{
    switch (rule.ruleRole) {
    case RuleRole::Keyword:
        rule.format = mKeywordFormat;
        break;
    case RuleRole::Class:
        rule.format = mClassFormat;
        break;
    case RuleRole::Comment:
        rule.format = mSingleLineCommentFormat;
        break;
    case RuleRole::Quote:
        rule.format = mQuotationFormat;
        break;
    case RuleRole::Symbol:
        rule.format = mSymbolFormat;
        break;
    }
}",1,1,gui/codeeditor.cpp,Highlighter.applyFormat:void(Highlighter.HighlightingRule&),<empty>,,false,249,268,applyFormat,,,1,void(Highlighter.HighlightingRule&)
111669150262,METHOD,gui/codeeditor.cpp:<global>,TYPE_DECL,"CodeEditor::CodeEditor(QWidget *parent) :
    QPlainTextEdit(parent),
    mWidgetStyle(new CodeEditorStyle(defaultStyleLight))
{
    mLineNumberArea = new LineNumberArea(this);
    mHighlighter = new Highlighter(document(), mWidgetStyle);
    mErrorPosition = -1;

    QFont font(""Monospace"");
    font.setStyleHint(QFont::TypeWriter);
    setFont(font);
    mLineNumberArea->setFont(font);

    // set widget coloring by overriding widget style sheet
    setObjectName(""CodeEditor"");
    setStyleSheet(generateStyleString());

#if (QT_VERSION >= QT_VERSION_CHECK(6, 0, 0))
    auto *copyText = new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_C),this);
    auto *allText = new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_A),this);
#else
    const auto *copyText = new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_C),this);
    const auto *allText = new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_A),this);
#endif

    connect(this, SIGNAL(blockCountChanged(int)), this, SLOT(updateLineNumberAreaWidth(int)...",1,1,gui/codeeditor.cpp,CodeEditor.CodeEditor:ANY(QWidget*),<empty>,,false,270,301,CodeEditor,,,1,CodeEditor.CodeEditor:ANY(QWidget*)(QWidget*)
111669150263,METHOD,gui/codeeditor.cpp:<global>,TYPE_DECL,"CodeEditor::~CodeEditor()
{
    // NOTE: not a Qt Object - delete manually
    delete mWidgetStyle;
}",1,1,gui/codeeditor.cpp,CodeEditor.~CodeEditor:ANY(),<empty>,,false,303,307,~CodeEditor,,,1,ANY()
111669150264,METHOD,gui/codeeditor.cpp:<global>,TYPE_DECL,"static int getPos(const QString &fileData, int lineNumber)
{
    if (lineNumber <= 1)
        return 0;
    for (int pos = 0, line = 1; pos < fileData.size(); ++pos) {
        if (fileData[pos] != '\\n')
            continue;
        ++line;
        if (line >= lineNumber)
            return pos + 1;
    }
    return fileData.size();
}",1,1,gui/codeeditor.cpp,"getPos:int(QString&,int)",<empty>,,false,309,321,getPos,,,1,"int(QString&,int)"
111669150265,METHOD,gui/codeeditor.cpp:<global>,TYPE_DECL,"void CodeEditor::setStyle(const CodeEditorStyle& newStyle)
{
    *mWidgetStyle = newStyle;
    // apply new styling
    setStyleSheet(generateStyleString());
    mHighlighter->setStyle(newStyle);
    mHighlighter->rehighlight();
    highlightErrorLine();
}",1,1,gui/codeeditor.cpp,CodeEditor.setStyle:void(CodeEditorStyle&),<empty>,,false,323,331,setStyle,,,1,void(CodeEditorStyle&)
111669150266,METHOD,gui/codeeditor.cpp:<global>,TYPE_DECL,"void CodeEditor::setError(const QString &code, int errorLine, const QStringList &symbols)
{
    mHighlighter->setSymbols(symbols);

    setPlainText(code);

    mErrorPosition = getPos(code, errorLine);
    QTextCursor tc = textCursor();
    tc.setPosition(mErrorPosition);
    setTextCursor(tc);
    centerCursor();

    highlightErrorLine();
}",1,1,gui/codeeditor.cpp,"CodeEditor.setError:void(QString&,int,QStringList&)",<empty>,,false,333,346,setError,,,1,"void(QString&,int,QStringList&)"
111669150267,METHOD,gui/codeeditor.cpp:<global>,TYPE_DECL,"void CodeEditor::setError(int errorLine, const QStringList &symbols)
{
    mHighlighter->setSymbols(symbols);

    mErrorPosition = getPos(toPlainText(), errorLine);
    QTextCursor tc = textCursor();
    tc.setPosition(mErrorPosition);
    setTextCursor(tc);
    centerCursor();

    highlightErrorLine();
}",1,1,gui/codeeditor.cpp,"CodeEditor.setError:void(int,QStringList&)",<empty>,,false,348,359,setError,,,1,"void(int,QStringList&)"
111669150268,METHOD,gui/codeeditor.cpp:<global>,TYPE_DECL,"int CodeEditor::lineNumberAreaWidth()
{
    int digits = 1;
    int max = qMax(1, blockCount());
    while (max >= 10) {
        max /= 10;
        ++digits;
    }

#if (QT_VERSION >= QT_VERSION_CHECK(5, 11, 0))
    const int space = 3 + (fontMetrics().horizontalAdvance(QLatin1Char('9')) * digits);
#else
    const int space = 3 + (fontMetrics().width(QLatin1Char('9')) * digits);
#endif
    return space;
}",1,1,gui/codeeditor.cpp,CodeEditor.lineNumberAreaWidth:int(),<empty>,,false,361,376,lineNumberAreaWidth,,,1,int()
111669150269,METHOD,gui/codeeditor.cpp:<global>,TYPE_DECL,"void CodeEditor::updateLineNumberAreaWidth(int /* newBlockCount */)
{
    setViewportMargins(lineNumberAreaWidth(), 0, 0, 0);
}",1,1,gui/codeeditor.cpp,CodeEditor.updateLineNumberAreaWidth:void(int),<empty>,,false,378,381,updateLineNumberAreaWidth,,,1,void(int)
111669150270,METHOD,gui/codeeditor.cpp:<global>,TYPE_DECL,"void CodeEditor::updateLineNumberArea(const QRect &rect, int dy)
{
    if (dy)
        mLineNumberArea->scroll(0, dy);
    else
        mLineNumberArea->update(0, rect.y(), mLineNumberArea->width(), rect.height());

    if (rect.contains(viewport()->rect()))
        updateLineNumberAreaWidth(0);
}",1,1,gui/codeeditor.cpp,"CodeEditor.updateLineNumberArea:void(QRect&,int)",<empty>,,false,383,392,updateLineNumberArea,,,1,"void(QRect&,int)"
111669150271,METHOD,gui/codeeditor.cpp:<global>,TYPE_DECL,"void CodeEditor::resizeEvent(QResizeEvent *event)
{
    QPlainTextEdit::resizeEvent(event);
    QRect cr = contentsRect();
    mLineNumberArea->setGeometry(QRect(cr.left(), cr.top(), lineNumberAreaWidth(), cr.height()));
}",1,1,gui/codeeditor.cpp,CodeEditor.resizeEvent:void(QResizeEvent*),<empty>,,false,394,399,resizeEvent,,,1,void(QResizeEvent*)
111669150272,METHOD,gui/codeeditor.cpp:<global>,TYPE_DECL,"void CodeEditor::highlightErrorLine()
{
    QList<QTextEdit::ExtraSelection> extraSelections;

    QTextEdit::ExtraSelection selection;

    selection.format.setBackground(mWidgetStyle->highlightBGColor);
    selection.format.setProperty(QTextFormat::FullWidthSelection, true);
    selection.cursor = QTextCursor(document());
    if (mErrorPosition >= 0) {
        selection.cursor.setPosition(mErrorPosition);
    } else {
        selection.cursor.setPosition(0);
    }
    selection.cursor.clearSelection();
    extraSelections.append(selection);

    setExtraSelections(extraSelections);
}",1,1,gui/codeeditor.cpp,CodeEditor.highlightErrorLine:void(),<empty>,,false,401,419,highlightErrorLine,,,1,void()
111669150273,METHOD,gui/codeeditor.cpp:<global>,TYPE_DECL,"void CodeEditor::lineNumberAreaPaintEvent(const QPaintEvent *event)
{
    QPainter painter(mLineNumberArea);
    painter.fillRect(event->rect(), mWidgetStyle->lineNumBGColor);

    QTextBlock block = firstVisibleBlock();
    int blockNumber = block.blockNumber();
    int top = (int) blockBoundingGeometry(block).translated(contentOffset()).top();
    int bottom = top + (int) blockBoundingRect(block).height();

    while (block.isValid() && top <= event->rect().bottom()) {
        if (block.isVisible() && bottom >= event->rect().top()) {
            QString number = QString::number(blockNumber + 1);
            painter.setPen(mWidgetStyle->lineNumFGColor);
            painter.drawText(0, top, mLineNumberArea->width(), fontMetrics().height(),
                             Qt::AlignRight, number);
        }

        block = block.next();
        top = bottom;
        bottom = top + (int) blockBoundingRect(block).height();
        ++blockNumber;
    }
}",1,1,gui/codeeditor.cpp,CodeEditor.lineNumberAreaPaintEvent:void(QPaintEvent*),<empty>,,false,421,444,lineNumberAreaPaintEvent,,,1,void(QPaintEvent*)
111669150274,METHOD,gui/codeeditor.cpp:<global>,TYPE_DECL,"QString CodeEditor::generateStyleString()
{
    QString bgcolor = QString(""background:rgb(%1,%2,%3);"")
                      .arg(mWidgetStyle->widgetBGColor.red())
                      .arg(mWidgetStyle->widgetBGColor.green())
                      .arg(mWidgetStyle->widgetBGColor.blue());
    QString fgcolor = QString(""color:rgb(%1,%2,%3);"")
                      .arg(mWidgetStyle->widgetFGColor.red())
                      .arg(mWidgetStyle->widgetFGColor.green())
                      .arg(mWidgetStyle->widgetFGColor.blue());
    QString style = QString(""%1 %2"")
                    .arg(bgcolor)
                    .arg(fgcolor);
    return style;
}",1,1,gui/codeeditor.cpp,CodeEditor.generateStyleString:QString(),<empty>,,false,446,460,generateStyleString,,,1,QString()
111669150275,METHOD,gui/codeeditor.h:<global>,TYPE_DECL,<global>,1,22,gui/codeeditor.h,gui/codeeditor.h:<global>,<empty>,,false,1,166,<global>,,,1,
111669150276,METHOD,gui/codeeditorstyle.cpp:<global>,TYPE_DECL,"CodeEditorStyle::CodeEditorStyle(
    // cppcheck-suppress naming-varname - TODO: fix this
    QColor CtrlFGColor, QColor CtrlBGColor,
    // cppcheck-suppress naming-varname - TODO: fix this
    QColor HiLiBGColor,
    // cppcheck-suppress naming-varname - TODO: fix this
    QColor LnNumFGColor, QColor LnNumBGColor,
    // cppcheck-suppress naming-varname - TODO: fix this
    QColor KeyWdFGColor, QFont::Weight KeyWdWeight,
    // cppcheck-suppress naming-varname - TODO: fix this
    QColor ClsFGColor, QFont::Weight ClsWeight,
    // cppcheck-suppress naming-varname - TODO: fix this
    QColor QteFGColor, QFont::Weight QteWeight,
    // cppcheck-suppress naming-varname - TODO: fix this
    QColor CmtFGColor, QFont::Weight CmtWeight,
    // cppcheck-suppress naming-varname - TODO: fix this
    QColor SymbFGColor, QColor SymbBGColor,
    // cppcheck-suppress naming-varname - TODO: fix this
    QFont::Weight SymbWeight) :
    widgetFGColor(CtrlFGColor),
    widgetBGColor(CtrlBGColor),
...",1,2,gui/codeeditorstyle.cpp,"CodeEditorStyle.CodeEditorStyle:ANY(QColor,QColor,QColor,QColor,QColor,QColor,QFont.Weight,QColor,QFont.Weight,QColor,QFont.Weight,QColor,QFont.Weight,QColor,QColor,QFont.Weight)",<empty>,,false,24,59,CodeEditorStyle,,,1,"CodeEditorStyle.CodeEditorStyle:ANY(QColor,QColor,QColor,QColor,QColor,QColor,QFont.Weight,QColor,QFont.Weight,QColor,QFont.Weight,QColor,QFont.Weight,QColor,QColor,QFont.Weight)(QColor,QColor,QColor,QColor,QColor,QColor,QFont.Weight,QColor,QFont.Weight,QColor,QFont.Weight,QColor,QFont.Weight,QColor,QColor,QFont.Weight)"
111669150277,METHOD,gui/codeeditorstyle.cpp:<global>,TYPE_DECL,<global>,1,1,gui/codeeditorstyle.cpp,gui/codeeditorstyle.cpp:<global>,<empty>,,false,1,231,<global>,,,1,
111669150278,METHOD,gui/codeeditorstyle.cpp:<global>,TYPE_DECL,"bool CodeEditorStyle::operator==(const CodeEditorStyle& rhs) const
{
    if (mSystemTheme != rhs.mSystemTheme) return false;
    if (widgetFGColor != rhs.widgetFGColor) return false;
    if (widgetBGColor != rhs.widgetBGColor) return false;
    if (highlightBGColor != rhs.highlightBGColor) return false;
    if (lineNumFGColor != rhs.lineNumFGColor) return false;
    if (lineNumBGColor != rhs.lineNumBGColor) return false;
    if (keywordColor != rhs.keywordColor) return false;
    if (keywordWeight != rhs.keywordWeight) return false;
    if (classColor != rhs.classColor) return false;
    if (classWeight != rhs.classWeight) return false;
    if (quoteColor != rhs.quoteColor) return false;
    if (quoteWeight != rhs.quoteWeight) return false;
    if (commentColor != rhs.commentColor) return false;
    if (commentWeight != rhs.commentWeight) return false;
    if (symbolFGColor != rhs.symbolFGColor) return false;
    if (symbolBGColor != rhs.symbolBGColor) return false;
    if (symbolWe...",1,1,gui/codeeditorstyle.cpp,CodeEditorStyle.==<const>:bool(CodeEditorStyle&),<empty>,,false,61,81,==,,,1,bool(CodeEditorStyle&)
111669150279,METHOD,gui/codeeditorstyle.cpp:<global>,TYPE_DECL,"bool CodeEditorStyle::operator!=(const CodeEditorStyle& rhs) const
{
    return !(*this == rhs);
}",1,1,gui/codeeditorstyle.cpp,CodeEditorStyle.!=<const>:bool(CodeEditorStyle&),<empty>,,false,83,86,!=,,,1,bool(CodeEditorStyle&)
111669150280,METHOD,gui/codeeditorstyle.cpp:<global>,TYPE_DECL,"CodeEditorStyle CodeEditorStyle::getSystemTheme()
{
    CodeEditorStyle theStyle(defaultStyleLight);
    theStyle.mSystemTheme = true;
    return theStyle;
}",1,1,gui/codeeditorstyle.cpp,CodeEditorStyle.getSystemTheme:CodeEditorStyle(),<empty>,,false,88,93,getSystemTheme,,,1,CodeEditorStyle()
111669150281,METHOD,gui/codeeditorstyle.cpp:<global>,TYPE_DECL,"CodeEditorStyle CodeEditorStyle::loadSettings(QSettings *settings)
{
    CodeEditorStyle theStyle(CodeEditorStyle::getSystemTheme());
    if (!settings)
        return theStyle;

    if (!settings->childGroups().contains(SETTINGS_STYLE_GROUP))
        return theStyle;

    // style section exists - load values
    settings->beginGroup(SETTINGS_STYLE_GROUP);
    QString type = settings->value(
        SETTINGS_STYLE_TYPE,
        QVariant(SETTINGS_STYLE_TYPE_LIGHT)
        ).toString();
    if (type == SETTINGS_STYLE_TYPE_LIGHT) {
        settings->endGroup();
        return theStyle;
    }
    if (type == SETTINGS_STYLE_TYPE_DARK) {
        theStyle = defaultStyleDark;
        settings->endGroup();
        return theStyle;
    }
    if (type == SETTINGS_STYLE_TYPE_CUSTOM) {
        theStyle.widgetFGColor = settings->value(
            SETTINGS_STYLE_WIDGETFG,
            QVariant(defaultStyleLight.widgetFGColor)).value<QColor>();
        theStyle.widgetBGColor = settings->value(
   ...",1,1,gui/codeeditorstyle.cpp,CodeEditorStyle.loadSettings:CodeEditorStyle(QSettings*),<empty>,,false,95,171,loadSettings,,,1,CodeEditorStyle(QSettings*)
111669150282,METHOD,gui/codeeditorstyle.cpp:<global>,TYPE_DECL,"void CodeEditorStyle::saveSettings(QSettings *settings,
                                   const CodeEditorStyle& theStyle)
{
    if (!settings)
        return;

    if (settings->childGroups().contains(SETTINGS_STYLE_GROUP)) {
        settings->remove(SETTINGS_STYLE_GROUP);
        if (theStyle.isSystemTheme())
            return;
    }

    settings->beginGroup(SETTINGS_STYLE_GROUP);
    const bool isDefaultLight = (defaultStyleLight == theStyle);
    const bool isDefaultDark = (defaultStyleDark == theStyle);
    if (isDefaultLight && !isDefaultDark) {
        settings->setValue(SETTINGS_STYLE_TYPE,
                           SETTINGS_STYLE_TYPE_LIGHT);
    } else if (!isDefaultLight && isDefaultDark) {
        settings->setValue(SETTINGS_STYLE_TYPE,
                           SETTINGS_STYLE_TYPE_DARK);
    } else {
        settings->setValue(SETTINGS_STYLE_TYPE,
                           SETTINGS_STYLE_TYPE_CUSTOM);
        settings->setValue(SETTINGS_STYLE_WIDGETFG,
           ...",1,1,gui/codeeditorstyle.cpp,"CodeEditorStyle.saveSettings:void(QSettings*,CodeEditorStyle&)",<empty>,,false,173,231,saveSettings,,,1,"void(QSettings*,CodeEditorStyle&)"
111669150283,METHOD,gui/codeeditorstyle.h:<global>,TYPE_DECL,<global>,1,30,gui/codeeditorstyle.h,gui/codeeditorstyle.h:<global>,<empty>,,false,1,128,<global>,,,1,
111669150284,METHOD,gui/codeeditstylecontrols.cpp:<global>,TYPE_DECL,"SelectColorButton::SelectColorButton(QWidget* parent) :
    QPushButton(parent),
    mColor(QColor(255, 255, 255))
{
    updateColor();
    connect(this, SIGNAL(clicked()), this, SLOT(changeColor()));
}",1,1,gui/codeeditstylecontrols.cpp,SelectColorButton.SelectColorButton:ANY(QWidget*),<empty>,,false,29,35,SelectColorButton,,,1,SelectColorButton.SelectColorButton:ANY(QWidget*)(QWidget*)
111669150285,METHOD,gui/codeeditstylecontrols.cpp:<global>,TYPE_DECL,<global>,1,1,gui/codeeditstylecontrols.cpp,gui/codeeditstylecontrols.cpp:<global>,<empty>,,false,1,128,<global>,,,1,
111669150286,METHOD,gui/codeeditstylecontrols.cpp:<global>,TYPE_DECL,"void SelectColorButton::updateColor()
{
    QString btnColorStyle = QString(
        ""background-color:rgb(%1,%2,%3);""
        ""border-style:outset;""
        ""border-width: 1px;"")
                            .arg(mColor.red())
                            .arg(mColor.green())
                            .arg(mColor.blue());
    setObjectName(""SelectColorButton"");
    setStyleSheet(btnColorStyle);
}",1,1,gui/codeeditstylecontrols.cpp,SelectColorButton.updateColor:void(),<empty>,,false,37,48,updateColor,,,1,void()
111669150287,METHOD,gui/codeeditstylecontrols.cpp:<global>,TYPE_DECL,"void SelectColorButton::changeColor()
{
    QColorDialog pDlg(mColor);
    pDlg.setModal(true);
    const int nResult = pDlg.exec();
    if (nResult == QDialog::Accepted) {
        setColor(pDlg.selectedColor());
        emit colorChanged(mColor);
    }
}",1,1,gui/codeeditstylecontrols.cpp,SelectColorButton.changeColor:void(),<empty>,,false,50,59,changeColor,,,1,void()
111669150288,METHOD,gui/codeeditstylecontrols.cpp:<global>,TYPE_DECL,"void SelectColorButton::setColor(const QColor& color)
{
    mColor = color;
    updateColor();
}",1,1,gui/codeeditstylecontrols.cpp,SelectColorButton.setColor:void(QColor&),<empty>,,false,61,65,setColor,,,1,void(QColor&)
111669150289,METHOD,gui/codeeditstylecontrols.cpp:<global>,TYPE_DECL,"const QColor& SelectColorButton::getColor() const
{
    return mColor;
}",1,1,gui/codeeditstylecontrols.cpp,SelectColorButton.getColor<const>:ANY(),<empty>,,false,68,71,getColor,,,1,ANY()
111669150290,METHOD,gui/codeeditstylecontrols.cpp:<global>,TYPE_DECL,"SelectFontWeightCombo::SelectFontWeightCombo(QWidget* parent) :
    QComboBox(parent)
{
    addItem(QObject::tr(""Thin""),
            QVariant(static_cast<int>(QFont::Thin)));
    addItem(QObject::tr(""ExtraLight""),
            QVariant(static_cast<int>(QFont::ExtraLight)));
    addItem(QObject::tr(""Light""),
            QVariant(static_cast<int>(QFont::Light)));
    addItem(QObject::tr(""Normal""),
            QVariant(static_cast<int>(QFont::Normal)));
    addItem(QObject::tr(""Medium""),
            QVariant(static_cast<int>(QFont::Medium)));
    addItem(QObject::tr(""DemiBold""),
            QVariant(static_cast<int>(QFont::DemiBold)));
    addItem(QObject::tr(""Bold""),
            QVariant(static_cast<int>(QFont::Bold)));
    addItem(QObject::tr(""ExtraBold""),
            QVariant(static_cast<int>(QFont::ExtraBold)));
    addItem(QObject::tr(""Black""),
            QVariant(static_cast<int>(QFont::Black)));
    updateWeight();
    connect(this, SIGNAL(currentIndexChanged(int)),
            ...",1,1,gui/codeeditstylecontrols.cpp,SelectFontWeightCombo.SelectFontWeightCombo:ANY(QWidget*),<empty>,,false,73,97,SelectFontWeightCombo,,,1,SelectFontWeightCombo.SelectFontWeightCombo:ANY(QWidget*)(QWidget*)
111669150291,METHOD,gui/codeeditstylecontrols.cpp:<global>,TYPE_DECL,"void SelectFontWeightCombo::updateWeight()
{
    const int nResult = findData(QVariant(static_cast<int>(mWeight)));

    if (nResult != -1) {
        setCurrentIndex(nResult);
    } else {
        setCurrentIndex(findData(static_cast<int>(QFont::Normal)));
    }
}",1,1,gui/codeeditstylecontrols.cpp,SelectFontWeightCombo.updateWeight:void(),<empty>,,false,99,108,updateWeight,,,1,void()
111669150292,METHOD,gui/codeeditstylecontrols.cpp:<global>,TYPE_DECL,"void SelectFontWeightCombo::changeWeight(int index)
{
    if (index != -1) {
        setWeight(static_cast<QFont::Weight>(itemData(index).toInt()));
        emit weightChanged(mWeight);
    }
}",1,1,gui/codeeditstylecontrols.cpp,SelectFontWeightCombo.changeWeight:void(int),<empty>,,false,110,116,changeWeight,,,1,void(int)
111669150293,METHOD,gui/codeeditstylecontrols.cpp:<global>,TYPE_DECL,"void SelectFontWeightCombo::setWeight(QFont::Weight weight)
{
    mWeight = weight;
    updateWeight();
}",1,1,gui/codeeditstylecontrols.cpp,SelectFontWeightCombo.setWeight:void(QFont.Weight),<empty>,,false,118,122,setWeight,,,1,void(QFont.Weight)
111669150294,METHOD,gui/codeeditstylecontrols.cpp:<global>,TYPE_DECL,"const QFont::Weight& SelectFontWeightCombo::getWeight() const
{
    return mWeight;
}",1,1,gui/codeeditstylecontrols.cpp,SelectFontWeightCombo.getWeight<const>:ANY(),<empty>,,false,125,128,getWeight,,,1,ANY()
111669150295,METHOD,gui/codeeditstylecontrols.h:<global>,TYPE_DECL,<global>,1,36,gui/codeeditstylecontrols.h,gui/codeeditstylecontrols.h:<global>,<empty>,,false,1,74,<global>,,,1,
111669150296,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"StyleEditDialog::StyleEditDialog(const CodeEditorStyle& newStyle,
                                 QWidget *parent /*= nullptr*/) :
    QDialog(parent),
    mStyleIncoming(newStyle),
    mStyleOutgoing(newStyle)
{
    auto *vboxMain = new QVBoxLayout(this);
    auto *hboxEdit = new QHBoxLayout();
    // Color/Weight controls
    auto *flEditControls = new QFormLayout();
    mBtnWidgetColorFG = new SelectColorButton(this);
    flEditControls->addRow(QObject::tr(""Editor Foreground Color""),
                           mBtnWidgetColorFG);
    mBtnWidgetColorBG = new SelectColorButton(this);
    flEditControls->addRow(QObject::tr(""Editor Background Color""),
                           mBtnWidgetColorBG);
    mBtnHighlightBG = new SelectColorButton(this);
    flEditControls->addRow(QObject::tr(""Highlight Background Color""),
                           mBtnHighlightBG);
    mBtnLineNumFG = new SelectColorButton(this);
    flEditControls->addRow(QObject::tr(""Line Number Foreground Color""),
   ...",1,1,gui/codeeditstyledialog.cpp,"StyleEditDialog.StyleEditDialog:ANY(CodeEditorStyle&,QWidget*)",<empty>,,false,70,208,StyleEditDialog,,,1,"StyleEditDialog.StyleEditDialog:ANY(CodeEditorStyle&,QWidget*)(CodeEditorStyle&,QWidget*)"
111669150297,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,<global>,1,1,gui/codeeditstyledialog.cpp,gui/codeeditstyledialog.cpp:<global>,<empty>,,false,1,358,<global>,,,1,
111669150298,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::updateControls()
{
    mBtnWidgetColorFG->setColor(mStyleOutgoing.widgetFGColor);
    mBtnWidgetColorBG->setColor(mStyleOutgoing.widgetBGColor);
    mBtnHighlightBG->setColor(mStyleOutgoing.highlightBGColor);
    mBtnLineNumFG->setColor(mStyleOutgoing.lineNumFGColor);
    mBtnLineNumBG->setColor(mStyleOutgoing.lineNumBGColor);
    mBtnKeywordFG->setColor(mStyleOutgoing.keywordColor);
    mCBKeywordWeight->setWeight(mStyleOutgoing.keywordWeight);
    mBtnClassFG->setColor(mStyleOutgoing.classColor);
    mCBClassWeight->setWeight(mStyleOutgoing.classWeight);
    mBtnQuoteFG->setColor(mStyleOutgoing.quoteColor);
    mCBQuoteWeight->setWeight(mStyleOutgoing.quoteWeight);
    mBtnCommentFG->setColor(mStyleOutgoing.commentColor);
    mCBCommentWeight->setWeight(mStyleOutgoing.commentWeight);
    mBtnSymbolFG->setColor(mStyleOutgoing.symbolFGColor);
    mBtnSymbolBG->setColor(mStyleOutgoing.symbolBGColor);
    mCBSymbolWeight->setWeight(mStyleOutgoing.symbolWeight);
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.updateControls:void(),<empty>,,false,210,228,updateControls,,,1,void()
111669150299,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::updateStyle()
{
    mBtnDefaultLight->setEnabled(mStyleOutgoing != defaultStyleLight);
    mBtnDefaultDark->setEnabled(mStyleOutgoing != defaultStyleDark);
    // set Editor Styling
    mSampleEditor->setStyle(mStyleOutgoing);
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.updateStyle:void(),<empty>,,false,230,236,updateStyle,,,1,void()
111669150300,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"CodeEditorStyle StyleEditDialog::getStyle() const
{
    return mStyleOutgoing;
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.getStyle<const>:CodeEditorStyle(),<empty>,,false,238,241,getStyle,,,1,CodeEditorStyle()
111669150301,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::resetStyle()
{
    mStyleOutgoing = mStyleIncoming;
    updateControls();
    updateStyle();
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.resetStyle:void(),<empty>,,false,243,248,resetStyle,,,1,void()
111669150302,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::setStyleDefaultLight()
{
    mStyleOutgoing = defaultStyleLight;
    updateControls();
    updateStyle();
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.setStyleDefaultLight:void(),<empty>,,false,250,255,setStyleDefaultLight,,,1,void()
111669150303,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::setStyleDefaultDark()
{
    mStyleOutgoing = defaultStyleDark;
    updateControls();
    updateStyle();
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.setStyleDefaultDark:void(),<empty>,,false,257,262,setStyleDefaultDark,,,1,void()
111669150304,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::colorChangedWidgetFG(const QColor& newColor)
{
    mStyleOutgoing.widgetFGColor = newColor;
    updateStyle();
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.colorChangedWidgetFG:void(QColor&),<empty>,,false,264,268,colorChangedWidgetFG,,,1,void(QColor&)
111669150305,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::colorChangedWidgetBG(const QColor& newColor)
{
    mStyleOutgoing.widgetBGColor = newColor;
    updateStyle();
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.colorChangedWidgetBG:void(QColor&),<empty>,,false,270,274,colorChangedWidgetBG,,,1,void(QColor&)
111669150306,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::colorChangedHighlightBG(const QColor& newColor)
{
    mStyleOutgoing.highlightBGColor = newColor;
    updateStyle();
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.colorChangedHighlightBG:void(QColor&),<empty>,,false,276,280,colorChangedHighlightBG,,,1,void(QColor&)
111669150307,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::colorChangedLineNumFG(const QColor& newColor)
{
    mStyleOutgoing.lineNumFGColor = newColor;
    updateStyle();
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.colorChangedLineNumFG:void(QColor&),<empty>,,false,282,286,colorChangedLineNumFG,,,1,void(QColor&)
111669150308,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::colorChangedLineNumBG(const QColor& newColor)
{
    mStyleOutgoing.lineNumBGColor = newColor;
    updateStyle();
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.colorChangedLineNumBG:void(QColor&),<empty>,,false,288,292,colorChangedLineNumBG,,,1,void(QColor&)
111669150309,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::colorChangedKeywordFG(const QColor& newColor)
{
    mStyleOutgoing.keywordColor = newColor;
    updateStyle();
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.colorChangedKeywordFG:void(QColor&),<empty>,,false,294,298,colorChangedKeywordFG,,,1,void(QColor&)
111669150310,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::weightChangedKeyword(QFont::Weight newWeight)
{
    mStyleOutgoing.keywordWeight = newWeight;
    updateStyle();
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.weightChangedKeyword:void(QFont.Weight),<empty>,,false,300,304,weightChangedKeyword,,,1,void(QFont.Weight)
111669150311,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::colorChangedClassFG(const QColor& newColor)
{
    mStyleOutgoing.classColor = newColor;
    updateStyle();
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.colorChangedClassFG:void(QColor&),<empty>,,false,306,310,colorChangedClassFG,,,1,void(QColor&)
111669150312,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::weightChangedClass(QFont::Weight newWeight)
{
    mStyleOutgoing.classWeight = newWeight;
    updateStyle();
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.weightChangedClass:void(QFont.Weight),<empty>,,false,312,316,weightChangedClass,,,1,void(QFont.Weight)
111669150313,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::colorChangedQuoteFG(const QColor& newColor)
{
    mStyleOutgoing.quoteColor = newColor;
    updateStyle();
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.colorChangedQuoteFG:void(QColor&),<empty>,,false,318,322,colorChangedQuoteFG,,,1,void(QColor&)
111669150314,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::weightChangedQuote(QFont::Weight newWeight)
{
    mStyleOutgoing.quoteWeight = newWeight;
    updateStyle();
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.weightChangedQuote:void(QFont.Weight),<empty>,,false,324,328,weightChangedQuote,,,1,void(QFont.Weight)
111669150315,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::colorChangedCommentFG(const QColor& newColor)
{
    mStyleOutgoing.commentColor = newColor;
    updateStyle();
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.colorChangedCommentFG:void(QColor&),<empty>,,false,330,334,colorChangedCommentFG,,,1,void(QColor&)
111669150316,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::weightChangedComment(QFont::Weight newWeight)
{
    mStyleOutgoing.commentWeight = newWeight;
    updateStyle();
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.weightChangedComment:void(QFont.Weight),<empty>,,false,336,340,weightChangedComment,,,1,void(QFont.Weight)
111669150317,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::colorChangedSymbolFG(const QColor& newColor)
{
    mStyleOutgoing.symbolFGColor = newColor;
    updateStyle();
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.colorChangedSymbolFG:void(QColor&),<empty>,,false,342,346,colorChangedSymbolFG,,,1,void(QColor&)
111669150318,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::colorChangedSymbolBG(const QColor& newColor)
{
    mStyleOutgoing.symbolBGColor = newColor;
    updateStyle();
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.colorChangedSymbolBG:void(QColor&),<empty>,,false,348,352,colorChangedSymbolBG,,,1,void(QColor&)
111669150319,METHOD,gui/codeeditstyledialog.cpp:<global>,TYPE_DECL,"void StyleEditDialog::weightChangedSymbol(QFont::Weight newWeight)
{
    mStyleOutgoing.symbolWeight = newWeight;
    updateStyle();
}",1,1,gui/codeeditstyledialog.cpp,StyleEditDialog.weightChangedSymbol:void(QFont.Weight),<empty>,,false,354,358,weightChangedSymbol,,,1,void(QFont.Weight)
111669150320,METHOD,gui/codeeditstyledialog.h:<global>,TYPE_DECL,<global>,1,1,gui/codeeditstyledialog.h,gui/codeeditstyledialog.h:<global>,<empty>,,false,1,104,<global>,,,1,
111669150321,METHOD,gui/common.cpp:<global>,TYPE_DECL,"QString getPath(const QString &type)
{
    QSettings settings;
    QString path = settings.value(type, QString()).toString();
    if (path.isEmpty()) {
        // if not set, fallback to last check path hoping that it will be close enough
        path = settings.value(SETTINGS_LAST_CHECK_PATH, QString()).toString();
        if (path.isEmpty())
            // if not set, return user's home directory as the best we can do for now
            return QDir::homePath();
    }
    return path;
}",1,30,gui/common.cpp,getPath:QString(QString&),<empty>,,false,33,45,getPath,,,1,QString(QString&)
111669150322,METHOD,gui/common.cpp:<global>,TYPE_DECL,<global>,1,1,gui/common.cpp,gui/common.cpp:<global>,<empty>,,false,1,88,<global>,,,1,
111669150323,METHOD,gui/common.cpp:<global>,TYPE_DECL,"void setPath(const QString &type, const QString &value)
{
    QSettings settings;
    settings.setValue(type, value);
}",1,1,gui/common.cpp,"setPath:void(QString&,QString&)",<empty>,,false,47,51,setPath,,,1,"void(QString&,QString&)"
111669150324,METHOD,gui/common.cpp:<global>,TYPE_DECL,"QString toFilterString(const QMap<QString,QString>& filters, bool addAllSupported, bool addAll)
{
    QStringList entries;

    if (addAllSupported) {
        entries << QCoreApplication::translate(""toFilterString"", ""All supported files (%1)"")
            .arg(filters.values().join("" ""));
    }

    if (addAll) {
        entries << QCoreApplication::translate(""toFilterString"", ""All files (%1)"").arg(""*.*"");
    }

    // We're using the description of the filters as the map keys, the file
    // name patterns are our values. The generated filter string list will
    // thus be sorted alphabetically over the descriptions.
    for (const auto& k: filters.keys()) {
        entries << QString(""%1 (%2)"").arg(k).arg(filters.value(k));
    }

    return entries.join("";;"");
}",1,1,gui/common.cpp,"toFilterString:QString(QMap<QString,QString>&,bool,bool)",<empty>,,false,53,74,toFilterString,,,1,"QString(QMap<QString,QString>&,bool,bool)"
111669150325,METHOD,gui/common.cpp:<global>,TYPE_DECL,"QString getDataDir()
{
    QSettings settings;
    const QString dataDir = settings.value(""DATADIR"", QString()).toString();
    if (!dataDir.isEmpty())
        return dataDir;
    const QString appPath = QFileInfo(QCoreApplication::applicationFilePath()).canonicalPath();
    if (QFileInfo::exists(appPath + ""/std.cfg""))
        return appPath;
    if (appPath.indexOf(""/cppcheck/"", 0, Qt::CaseInsensitive) > 0)
        return appPath.left(appPath.indexOf(""/cppcheck/"", 0, Qt::CaseInsensitive) + 9);
    return appPath;
}",1,1,gui/common.cpp,getDataDir:QString(),<empty>,,false,76,88,getDataDir,,,1,QString()
111669150326,METHOD,gui/common.h:<global>,TYPE_DECL,<global>,1,6,gui/common.h,gui/common.h:<global>,<empty>,,false,1,158,<global>,,,1,
111669150327,METHOD,gui/compliancereportdialog.cpp:<global>,TYPE_DECL,"static void addHeaders(const QString& file1, QSet<QString> &allFiles) {
    if (allFiles.contains(file1))
        return;
    QFile file(file1);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
        return;
    allFiles << file1;
    const QRegularExpression re(""^#include[ ]*\\""([^\\"">]+)\\"".*"");
    QTextStream in(&file);
    QString line = in.readLine();
    while (!in.atEnd()) {
        if (line.startsWith(""#include"")) {
            const QRegularExpressionMatch match = re.match(line);
            if (match.hasMatch()) {
                QString hfile = match.captured(1);
                if (file1.contains(""/""))
                    hfile = file1.mid(0,file1.lastIndexOf(""/"") + 1) + hfile;
                addHeaders(hfile, allFiles);
            }
        }
        line = in.readLine();
    }
}",1,1,gui/compliancereportdialog.cpp,"addHeaders:void(QString&,QSet<QString>&)",<empty>,,false,57,79,addHeaders,,,1,"void(QString&,QSet<QString>&)"
111669150328,METHOD,gui/compliancereportdialog.cpp:<global>,TYPE_DECL,<global>,1,1,gui/compliancereportdialog.cpp,gui/compliancereportdialog.cpp:<global>,<empty>,,false,1,245,<global>,,,1,
111669150329,METHOD,<empty>,<empty>,"[](const QString& e) {
        return e.toStdString();
    }",73,5,gui/compliancereportdialog.cpp,gui/compliancereportdialog.cpp:<global>.toStdStringList:vector<std.string>(QStringList&).<lambda>0:ANY(QString&),<empty>,,false,83,85,<lambda>0,,,1,ANY(QString&)
111669150330,METHOD,gui/compliancereportdialog.cpp:<global>,TYPE_DECL,"static std::vector<std::string> toStdStringList(const QStringList& from) {
    std::vector<std::string> ret;
    std::transform(from.cbegin(), from.cend(), std::back_inserter(ret), [](const QString& e) {
        return e.toStdString();
    });
    return ret;
}",1,1,gui/compliancereportdialog.cpp,toStdStringList:vector<std.string>(QStringList&),<empty>,,false,81,87,toStdStringList,,,1,vector<std::string>(QStringList&)
111669150331,METHOD,gui/compliancereportdialog.cpp:<global>,TYPE_DECL,"ComplianceReportDialog::ComplianceReportDialog(ProjectFile* projectFile, QString resultsFile, QString checkersReport)
    : QDialog(nullptr),
    mUI(new Ui::ComplianceReportDialog),
    mProjectFile(projectFile),
    mResultsFile(std::move(resultsFile)),
    mCheckersReport(std::move(checkersReport))
{
    mUI->setupUi(this);
    mUI->mEditProjectName->setText(projectFile->getProjectName());
    connect(mUI->buttonBox, &QDialogButtonBox::clicked, this, &ComplianceReportDialog::buttonClicked);
    mUI->mCodingStandard->clear();
    if (!projectFile->getCodingStandards().contains(""misra-c-2023"") && projectFile->getAddons().contains(""misra""))
        mUI->mCodingStandard->addItem(""Misra C 2012"");
    for (QString std: projectFile->getCodingStandards()) {
        std[0] = std[0].toUpper();
        std = std.replace(""-"", "" "").replace("" c "", "" C "").replace("" cpp "", "" C++ "").replace("" c++ "", "" C++ "");
        mUI->mCodingStandard->addItem(std);
    }
}",1,1,gui/compliancereportdialog.cpp,"ComplianceReportDialog.ComplianceReportDialog:ANY(ProjectFile*,QString,QString)",<empty>,,false,89,107,ComplianceReportDialog,,,1,"ComplianceReportDialog.ComplianceReportDialog:ANY(ProjectFile*,QString,QString)(ProjectFile*,QString,QString)"
111669150332,METHOD,gui/compliancereportdialog.cpp:<global>,TYPE_DECL,"ComplianceReportDialog::~ComplianceReportDialog()
{
    delete mUI;
}",1,1,gui/compliancereportdialog.cpp,ComplianceReportDialog.~ComplianceReportDialog:ANY(),<empty>,,false,109,112,~ComplianceReportDialog,,,1,ANY()
111669150333,METHOD,gui/compliancereportdialog.cpp:<global>,TYPE_DECL,"void ComplianceReportDialog::buttonClicked(QAbstractButton* button)
{
    switch (mUI->buttonBox->standardButton(button)) {
    case QDialogButtonBox::StandardButton::Save:
        save();
        break;
    case QDialogButtonBox::StandardButton::Close:
        close();
        break;
    default:
        break;
    }
}",1,1,gui/compliancereportdialog.cpp,ComplianceReportDialog.buttonClicked:void(QAbstractButton*),<empty>,,false,114,126,buttonClicked,,,1,void(QAbstractButton*)
111669150334,METHOD,gui/compliancereportdialog.cpp:<global>,TYPE_DECL,"void ComplianceReportDialog::save()
{
    const QString std(mUI->mCodingStandard->currentText().toLower().replace("" "", ""-""));

    const QString outFile = QFileDialog::getSaveFileName(this,
                                                         tr(""Compliance report""),
                                                         QDir::homePath() + ""/"" + std + ""-compliance-report.html"",
                                                         tr(""HTML files (*.html)""));
    if (outFile.isEmpty())
        return;

    close();

    const QString& projectName = mUI->mEditProjectName->text();
    const QString& projectVersion = mUI->mEditProjectVersion->text();
    const bool files = mUI->mCheckFiles->isChecked();

    if (projectName != mProjectFile->getProjectName()) {
        mProjectFile->setProjectName(projectName);
        mProjectFile->write();
    }

    QTemporaryFile tempCheckersReport;
    if (tempCheckersReport.open()) {
        QTextStream out(&tempCheckersReport);
        ou...",1,1,gui/compliancereportdialog.cpp,ComplianceReportDialog.save:void(),<empty>,,false,128,245,save,,,1,void()
111669150335,METHOD,gui/compliancereportdialog.h:<global>,TYPE_DECL,<global>,1,34,gui/compliancereportdialog.h,gui/compliancereportdialog.h:<global>,<empty>,,false,1,53,<global>,,,1,
111669150336,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static std::string unhandledElement(const QXmlStreamReader &xmlReader)
{
    throw std::runtime_error(QObject::tr(""line %1: Unhandled element %2"").arg(xmlReader.lineNumber()).arg(xmlReader.name().toString()).toStdString());
}",1,1,gui/cppchecklibrarydata.cpp,unhandledElement:string(QXmlStreamReader&),<empty>,,false,41,44,unhandledElement,,,1,string(QXmlStreamReader&)
111669150337,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,<global>,1,1,gui/cppchecklibrarydata.cpp,gui/cppchecklibrarydata.cpp:<global>,<empty>,,false,1,945,<global>,,,1,
111669150338,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static std::string mandatoryAttibuteMissing(const QXmlStreamReader &xmlReader, const QString& attributeName)
{
    throw std::runtime_error(QObject::tr(""line %1: Mandatory attribute '%2' missing in '%3'"")
                             .arg(xmlReader.lineNumber())
                             .arg(attributeName)
                             .arg(xmlReader.name().toString()).toStdString());
}",1,1,gui/cppchecklibrarydata.cpp,"mandatoryAttibuteMissing:string(QXmlStreamReader&,QString&)",<empty>,,false,46,52,mandatoryAttibuteMissing,,,1,"string(QXmlStreamReader&,QString&)"
111669150339,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static CppcheckLibraryData::Container loadContainer(QXmlStreamReader &xmlReader)
{
    CppcheckLibraryData::Container container;
    container.id            = xmlReader.attributes().value(""id"").toString();
    container.inherits      = xmlReader.attributes().value(""inherits"").toString();
    container.startPattern  = xmlReader.attributes().value(""startPattern"").toString();
    container.endPattern    = xmlReader.attributes().value(""endPattern"").toString();
    container.opLessAllowed = xmlReader.attributes().value(""opLessAllowed"").toString();
    container.itEndPattern  = xmlReader.attributes().value(""itEndPattern"").toString();

    QXmlStreamReader::TokenType type;
    while ((type = xmlReader.readNext()) != QXmlStreamReader::EndElement ||
           xmlReader.name().toString() != ""container"") {
        if (type != QXmlStreamReader::StartElement)
            continue;
        const QString elementName = xmlReader.name().toString();
        if (elementName == ""type"") {
            c...",1,1,gui/cppchecklibrarydata.cpp,loadContainer:CppcheckLibraryData.Container(QXmlStreamReader&),<empty>,,false,54,107,loadContainer,,,1,CppcheckLibraryData.Container(QXmlStreamReader&)
111669150340,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static CppcheckLibraryData::Define loadDefine(const QXmlStreamReader &xmlReader)
{
    CppcheckLibraryData::Define define;
    define.name = xmlReader.attributes().value(""name"").toString();
    define.value = xmlReader.attributes().value(""value"").toString();
    return define;
}",1,1,gui/cppchecklibrarydata.cpp,loadDefine:CppcheckLibraryData.Define(QXmlStreamReader&),<empty>,,false,109,115,loadDefine,,,1,CppcheckLibraryData.Define(QXmlStreamReader&)
111669150341,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static QString loadUndefine(const QXmlStreamReader &xmlReader)
{
    return xmlReader.attributes().value(""name"").toString();
}",1,1,gui/cppchecklibrarydata.cpp,loadUndefine:QString(QXmlStreamReader&),<empty>,,false,117,120,loadUndefine,,,1,QString(QXmlStreamReader&)
111669150342,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static CppcheckLibraryData::SmartPointer loadSmartPointer(QXmlStreamReader &xmlReader)
{
    CppcheckLibraryData::SmartPointer smartPointer;
    smartPointer.name = xmlReader.attributes().value(""class-name"").toString();
    QXmlStreamReader::TokenType type;
    while ((type = xmlReader.readNext()) != QXmlStreamReader::EndElement ||
           xmlReader.name().toString() != ""smart-pointer"") {
        if (type != QXmlStreamReader::StartElement)
            continue;
        const QString elementName = xmlReader.name().toString();
        if (elementName == ""unique"") {
            smartPointer.unique = true;
        } else {
            unhandledElement(xmlReader);
        }
    }
    return smartPointer;
}",1,1,gui/cppchecklibrarydata.cpp,loadSmartPointer:CppcheckLibraryData.SmartPointer(QXmlStreamReader&),<empty>,,false,122,139,loadSmartPointer,,,1,CppcheckLibraryData.SmartPointer(QXmlStreamReader&)
111669150343,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static CppcheckLibraryData::TypeChecks loadTypeChecks(QXmlStreamReader &xmlReader)
{
    CppcheckLibraryData::TypeChecks typeChecks;
    QXmlStreamReader::TokenType type;
    while ((type = xmlReader.readNext()) != QXmlStreamReader::EndElement ||
           xmlReader.name().toString() != ""type-checks"") {
        if (type != QXmlStreamReader::StartElement)
            continue;
        const QString elementName = xmlReader.name().toString();
        if (elementName == ""suppress"" || elementName == ""check"") {
            std::pair<QString, QString> entry(elementName, xmlReader.readElementText());
            typeChecks.append(entry);
        }
    }
    return typeChecks;
}",1,1,gui/cppchecklibrarydata.cpp,loadTypeChecks:TypeChecks(QXmlStreamReader&),<empty>,,false,141,156,loadTypeChecks,,,1,TypeChecks(QXmlStreamReader&)
111669150344,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static CppcheckLibraryData::Function::Arg loadFunctionArg(QXmlStreamReader &xmlReader)
{
    CppcheckLibraryData::Function::Arg arg;
    QString argnr = xmlReader.attributes().value(""nr"").toString();
    if (argnr == ""any"")
        arg.nr = CppcheckLibraryData::Function::Arg::ANY;
    else if (argnr == ""variadic"")
        arg.nr = CppcheckLibraryData::Function::Arg::VARIADIC;
    else
        arg.nr = argnr.toUInt();
    arg.defaultValue = xmlReader.attributes().value(""default"").toString();

    QXmlStreamReader::TokenType type;
    while ((type = xmlReader.readNext()) != QXmlStreamReader::EndElement ||
           xmlReader.name().toString() != ""arg"") {
        if (type != QXmlStreamReader::StartElement)
            continue;
        const QString elementName = xmlReader.name().toString();
        if (elementName == ""not-bool"")
            arg.notbool = true;
        else if (elementName == ""not-null"")
            arg.notnull = true;
        else if (elementName == ""not-uninit"")
   ...",1,1,gui/cppchecklibrarydata.cpp,loadFunctionArg:CppcheckLibraryData.Function.Arg(QXmlStreamReader&),<empty>,,false,158,202,loadFunctionArg,,,1,CppcheckLibraryData.Function.Arg(QXmlStreamReader&)
111669150345,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static CppcheckLibraryData::Function loadFunction(QXmlStreamReader &xmlReader, const QString &comments)
{
    CppcheckLibraryData::Function function;
    function.comments = comments;
    function.name = xmlReader.attributes().value(""name"").toString();
    QXmlStreamReader::TokenType type;
    while ((type = xmlReader.readNext()) != QXmlStreamReader::EndElement ||
           xmlReader.name().toString() != ""function"") {
        if (type != QXmlStreamReader::StartElement)
            continue;
        const QString elementName = xmlReader.name().toString();
        if (elementName == ""noreturn"")
            function.noreturn = (xmlReader.readElementText() == ""true"") ? CppcheckLibraryData::Function::True : CppcheckLibraryData::Function::False;
        else if (elementName == ""pure"")
            function.gccPure = true;
        else if (elementName == ""const"")
            function.gccConst = true;
        else if (elementName == ""leak-ignore"")
            function.leakignore = true;
   ...",1,1,gui/cppchecklibrarydata.cpp,"loadFunction:CppcheckLibraryData.Function(QXmlStreamReader&,QString&)",<empty>,,false,204,260,loadFunction,,,1,"CppcheckLibraryData.Function(QXmlStreamReader&,QString&)"
111669150346,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static CppcheckLibraryData::MemoryResource loadMemoryResource(QXmlStreamReader &xmlReader)
{
    CppcheckLibraryData::MemoryResource memoryresource;
    memoryresource.type = xmlReader.name().toString();
    QXmlStreamReader::TokenType type;
    while ((type = xmlReader.readNext()) != QXmlStreamReader::EndElement ||
           xmlReader.name().toString() != memoryresource.type) {
        if (type != QXmlStreamReader::StartElement)
            continue;
        const QString elementName = xmlReader.name().toString();
        if (elementName == ""alloc"" || elementName == ""realloc"") {
            CppcheckLibraryData::MemoryResource::Alloc alloc;
            alloc.isRealloc = (elementName == ""realloc"");
            alloc.init = (xmlReader.attributes().value(""init"").toString() == ""true"");
            if (xmlReader.attributes().hasAttribute(""arg"")) {
                alloc.arg = xmlReader.attributes().value(""arg"").toInt();
            }
            if (alloc.isRealloc && xmlReader.attribute...",1,1,gui/cppchecklibrarydata.cpp,loadMemoryResource:CppcheckLibraryData.MemoryResource(QXmlStreamReader&),<empty>,,false,262,300,loadMemoryResource,,,1,CppcheckLibraryData.MemoryResource(QXmlStreamReader&)
111669150347,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static CppcheckLibraryData::PodType loadPodType(const QXmlStreamReader &xmlReader)
{
    CppcheckLibraryData::PodType podtype;
    podtype.name = xmlReader.attributes().value(""name"").toString();
    if (podtype.name.isEmpty()) {
        mandatoryAttibuteMissing(xmlReader, ""name"");
    }
    podtype.stdtype = xmlReader.attributes().value(""stdtype"").toString();
    podtype.size = xmlReader.attributes().value(""size"").toString();
    podtype.sign = xmlReader.attributes().value(""sign"").toString();
    return podtype;
}",1,1,gui/cppchecklibrarydata.cpp,loadPodType:CppcheckLibraryData.PodType(QXmlStreamReader&),<empty>,,false,302,313,loadPodType,,,1,CppcheckLibraryData.PodType(QXmlStreamReader&)
111669150348,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static CppcheckLibraryData::PlatformType loadPlatformType(QXmlStreamReader &xmlReader)
{
    CppcheckLibraryData::PlatformType platformType;
    platformType.name = xmlReader.attributes().value(""name"").toString();
    platformType.value = xmlReader.attributes().value(""value"").toString();

    QXmlStreamReader::TokenType type;
    while ((type = xmlReader.readNext()) != QXmlStreamReader::EndElement ||
           xmlReader.name().toString() != ""platformtype"") {
        if (type != QXmlStreamReader::StartElement)
            continue;
        const QString elementName = xmlReader.name().toString();
        if (QStringList({""unsigned"", ""long"", ""pointer"", ""const_ptr"", ""ptr_ptr""}).contains(elementName)) {
            platformType.types.append(elementName);
        } else if (elementName == ""platform"") {
            platformType.platforms.append(xmlReader.attributes().value(""type"").toString());
        } else {
            unhandledElement(xmlReader);
        }
    }
    return platformTyp...",1,1,gui/cppchecklibrarydata.cpp,loadPlatformType:CppcheckLibraryData.PlatformType(QXmlStreamReader&),<empty>,,false,315,336,loadPlatformType,,,1,CppcheckLibraryData.PlatformType(QXmlStreamReader&)
111669150349,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static CppcheckLibraryData::Reflection loadReflection(QXmlStreamReader &xmlReader)
{
    CppcheckLibraryData::Reflection reflection;

    QXmlStreamReader::TokenType type;
    while ((type = xmlReader.readNext()) != QXmlStreamReader::EndElement ||
           xmlReader.name().toString() != ""reflection"") {
        if (type != QXmlStreamReader::StartElement)
            continue;
        const QString elementName = xmlReader.name().toString();
        if (elementName == ""call"") {
            CppcheckLibraryData::Reflection::Call call;
            if (xmlReader.attributes().hasAttribute(""arg"")) {
                call.arg = xmlReader.attributes().value(""arg"").toInt();
            } else {
                mandatoryAttibuteMissing(xmlReader, ""arg"");
            }
            call.name = xmlReader.readElementText();
            reflection.calls.append(call);
        } else {
            unhandledElement(xmlReader);
        }
    }

    return reflection;
}",1,1,gui/cppchecklibrarydata.cpp,loadReflection:CppcheckLibraryData.Reflection(QXmlStreamReader&),<empty>,,false,338,363,loadReflection,,,1,CppcheckLibraryData.Reflection(QXmlStreamReader&)
111669150350,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static CppcheckLibraryData::Markup loadMarkup(QXmlStreamReader &xmlReader)
{
    CppcheckLibraryData::Markup markup;

    QXmlStreamReader::TokenType type;
    if (xmlReader.attributes().hasAttribute(""ext"")) {
        markup.ext = xmlReader.attributes().value(""ext"").toString();
    } else {
        mandatoryAttibuteMissing(xmlReader, ""ext"");
    }
    if (xmlReader.attributes().hasAttribute(""aftercode"")) {
        markup.afterCode = (xmlReader.attributes().value(""aftercode"") == QString(""true""));
    } else {
        mandatoryAttibuteMissing(xmlReader, ""aftercode"");
    }
    if (xmlReader.attributes().hasAttribute(""reporterrors"")) {
        markup.reportErrors = (xmlReader.attributes().value(""reporterrors"") == QString(""true""));
    } else {
        mandatoryAttibuteMissing(xmlReader, ""reporterrors"");
    }

    while ((type = xmlReader.readNext()) != QXmlStreamReader::EndElement ||
           xmlReader.name().toString() != ""markup"") {
        if (type != QXmlStreamReader::StartEleme...",1,1,gui/cppchecklibrarydata.cpp,loadMarkup:CppcheckLibraryData.Markup(QXmlStreamReader&),<empty>,,false,365,455,loadMarkup,,,1,CppcheckLibraryData.Markup(QXmlStreamReader&)
111669150351,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static CppcheckLibraryData::Entrypoint loadEntrypoint(const QXmlStreamReader &xmlReader)
{
    CppcheckLibraryData::Entrypoint entrypoint;
    entrypoint.name = xmlReader.attributes().value(""name"").toString();
    return entrypoint;
}",1,1,gui/cppchecklibrarydata.cpp,loadEntrypoint:CppcheckLibraryData.Entrypoint(QXmlStreamReader&),<empty>,,false,457,462,loadEntrypoint,,,1,CppcheckLibraryData.Entrypoint(QXmlStreamReader&)
111669150352,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"QString CppcheckLibraryData::open(QIODevice &file)
{
    clear();
    QString comments;
    QXmlStreamReader xmlReader(&file);
    while (!xmlReader.atEnd()) {
        const QXmlStreamReader::TokenType t = xmlReader.readNext();
        switch (t) {
        case QXmlStreamReader::Comment:
            if (!comments.isEmpty())
                comments += ""\\n"";
            comments += xmlReader.text().toString();
            break;
        case QXmlStreamReader::StartElement:
            try {
                const QString elementName(xmlReader.name().toString());
                if (elementName == ""def"")
                    ;
                else if (elementName == ""container"")
                    containers.append(loadContainer(xmlReader));
                else if (elementName == ""define"")
                    defines.append(loadDefine(xmlReader));
                else if (elementName == ""undefine"")
                    undefines.append(loadUndefine(xmlReader));
                else if ...",1,1,gui/cppchecklibrarydata.cpp,CppcheckLibraryData.open:QString(QIODevice&),<empty>,,false,464,520,open,,,1,QString(QIODevice&)
111669150353,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static void writeContainerFunctions(QXmlStreamWriter &xmlWriter, const QString &name, int extra, const QList<CppcheckLibraryData::Container::Function> &functions)
{
    if (functions.isEmpty() && extra < 0)
        return;
    xmlWriter.writeStartElement(name);
    if (extra >= 0) {
        if (name == ""access"")
            xmlWriter.writeAttribute(""indexOperator"", ""array-like"");
        else if (name == ""size"")
            xmlWriter.writeAttribute(""templateParameter"", QString::number(extra));
    }
    for (const CppcheckLibraryData::Container::Function &function : functions) {
        xmlWriter.writeStartElement(""function"");
        xmlWriter.writeAttribute(""name"", function.name);
        if (!function.action.isEmpty())
            xmlWriter.writeAttribute(""action"", function.action);
        if (!function.yields.isEmpty())
            xmlWriter.writeAttribute(""yields"", function.yields);
        xmlWriter.writeEndElement();
    }
    xmlWriter.writeEndElement();
}",1,1,gui/cppchecklibrarydata.cpp,"writeContainerFunctions:void(QXmlStreamWriter&,QString&,int,QList<CppcheckLibraryData.Container.Function>&)",<empty>,,false,522,543,writeContainerFunctions,,,1,"void(QXmlStreamWriter&,QString&,int,QList<CppcheckLibraryData.Container.Function>&)"
111669150354,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static void writeContainerRangeItemRecords(QXmlStreamWriter &xmlWriter, const QList<CppcheckLibraryData::Container::RangeItemRecordType> &rangeItemRecords)
{
    if (rangeItemRecords.isEmpty())
        return;
    xmlWriter.writeStartElement(""rangeItemRecordType"");
    for (const CppcheckLibraryData::Container::RangeItemRecordType &item : rangeItemRecords) {
        xmlWriter.writeStartElement(""member"");
        xmlWriter.writeAttribute(""name"", item.name);
        xmlWriter.writeAttribute(""templateParameter"", item.templateParameter);
        xmlWriter.writeEndElement();
    }
    xmlWriter.writeEndElement();
}",1,1,gui/cppchecklibrarydata.cpp,"writeContainerRangeItemRecords:void(QXmlStreamWriter&,QList<CppcheckLibraryData.Container.RangeItemRecordType>&)",<empty>,,false,545,557,writeContainerRangeItemRecords,,,1,"void(QXmlStreamWriter&,QList<CppcheckLibraryData.Container.RangeItemRecordType>&)"
111669150355,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static void writeContainer(QXmlStreamWriter &xmlWriter, const CppcheckLibraryData::Container &container)
{
    xmlWriter.writeStartElement(""container"");
    xmlWriter.writeAttribute(""id"", container.id);
    if (!container.startPattern.isEmpty())
        xmlWriter.writeAttribute(""startPattern"", container.startPattern);
    if (!container.endPattern.isNull())
        xmlWriter.writeAttribute(""endPattern"", container.endPattern);
    if (!container.inherits.isEmpty())
        xmlWriter.writeAttribute(""inherits"", container.inherits);
    if (!container.opLessAllowed.isEmpty())
        xmlWriter.writeAttribute(""opLessAllowed"", container.opLessAllowed);
    if (!container.itEndPattern.isEmpty())
        xmlWriter.writeAttribute(""itEndPattern"", container.itEndPattern);

    if (!container.type.templateParameter.isEmpty() || !container.type.string.isEmpty()) {
        xmlWriter.writeStartElement(""type"");
        if (!container.type.templateParameter.isEmpty())
            xmlWriter.writeAttr...",1,1,gui/cppchecklibrarydata.cpp,"writeContainer:void(QXmlStreamWriter&,CppcheckLibraryData.Container&)",<empty>,,false,559,587,writeContainer,,,1,"void(QXmlStreamWriter&,CppcheckLibraryData.Container&)"
111669150356,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static void writeFunction(QXmlStreamWriter &xmlWriter, const CppcheckLibraryData::Function &function)
{
    QString comments = function.comments;
    while (comments.startsWith(""\\n""))
        comments = comments.mid(1);
    while (comments.endsWith(""\\n""))
        comments.chop(1);
    for (const QString &comment : comments.split('\\n')) {
        if (comment.length() >= 1)
            xmlWriter.writeComment(comment);
    }

    xmlWriter.writeStartElement(""function"");
    xmlWriter.writeAttribute(""name"", function.name);

    if (function.useretval)
        xmlWriter.writeEmptyElement(""use-retval"");
    if (function.gccConst)
        xmlWriter.writeEmptyElement(""const"");
    if (function.gccPure)
        xmlWriter.writeEmptyElement(""pure"");
    if (!function.returnValue.empty()) {
        xmlWriter.writeStartElement(""returnValue"");
        if (!function.returnValue.type.isNull())
            xmlWriter.writeAttribute(""type"", function.returnValue.type);
        if (function.returnValue....",1,1,gui/cppchecklibrarydata.cpp,"writeFunction:void(QXmlStreamWriter&,CppcheckLibraryData.Function&)",<empty>,,false,589,714,writeFunction,,,1,"void(QXmlStreamWriter&,CppcheckLibraryData.Function&)"
111669150357,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static void writeMemoryResource(QXmlStreamWriter &xmlWriter, const CppcheckLibraryData::MemoryResource &mr)
{
    xmlWriter.writeStartElement(mr.type);
    for (const CppcheckLibraryData::MemoryResource::Alloc &alloc : mr.alloc) {
        if (alloc.isRealloc) {
            xmlWriter.writeStartElement(""realloc"");
        } else {
            xmlWriter.writeStartElement(""alloc"");
        }
        xmlWriter.writeAttribute(""init"", bool_to_string(alloc.init));
        if (alloc.arg != -1) {
            xmlWriter.writeAttribute(""arg"", QString(""%1"").arg(alloc.arg));
        }
        if (alloc.isRealloc && alloc.reallocArg != -1) {
            xmlWriter.writeAttribute(""realloc-arg"", QString(""%1"").arg(alloc.reallocArg));
        }
        if (mr.type == ""memory"" && !alloc.bufferSize.isEmpty()) {
            xmlWriter.writeAttribute(""buffer-size"", alloc.bufferSize);
        }
        xmlWriter.writeCharacters(alloc.name);
        xmlWriter.writeEndElement();
    }

    for (const CppcheckLi...",1,1,gui/cppchecklibrarydata.cpp,"writeMemoryResource:void(QXmlStreamWriter&,CppcheckLibraryData.MemoryResource&)",<empty>,,false,716,752,writeMemoryResource,,,1,"void(QXmlStreamWriter&,CppcheckLibraryData.MemoryResource&)"
111669150358,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static void writeTypeChecks(QXmlStreamWriter &xmlWriter, const CppcheckLibraryData::TypeChecks &typeChecks)
{
    xmlWriter.writeStartElement(""type-checks"");
    if (!typeChecks.isEmpty()) {
        xmlWriter.writeStartElement(""unusedvar"");
    }
    for (const std::pair<QString, QString> &check : typeChecks) {
        xmlWriter.writeStartElement(check.first);
        xmlWriter.writeCharacters(check.second);
        xmlWriter.writeEndElement();
    }
    if (!typeChecks.isEmpty()) {
        xmlWriter.writeEndElement();
    }
    xmlWriter.writeEndElement();
}",1,1,gui/cppchecklibrarydata.cpp,"writeTypeChecks:void(QXmlStreamWriter&,CppcheckLibraryData.TypeChecks&)",<empty>,,false,754,769,writeTypeChecks,,,1,"void(QXmlStreamWriter&,CppcheckLibraryData.TypeChecks&)"
111669150359,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static void writePlatformType(QXmlStreamWriter &xmlWriter, const CppcheckLibraryData::PlatformType &pt)
{
    xmlWriter.writeStartElement(""platformtype"");
    xmlWriter.writeAttribute(""name"", pt.name);
    xmlWriter.writeAttribute(""value"", pt.value);
    for (const QString &type : pt.types) {
        xmlWriter.writeStartElement(type);
        xmlWriter.writeEndElement();
    }
    for (const QString &platform : pt.platforms) {
        xmlWriter.writeStartElement(""platform"");
        if (!platform.isEmpty()) {
            xmlWriter.writeAttribute(""type"", platform);
        }
        xmlWriter.writeEndElement();
    }
    xmlWriter.writeEndElement();
}",1,1,gui/cppchecklibrarydata.cpp,"writePlatformType:void(QXmlStreamWriter&,CppcheckLibraryData.PlatformType&)",<empty>,,false,771,788,writePlatformType,,,1,"void(QXmlStreamWriter&,CppcheckLibraryData.PlatformType&)"
111669150360,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static void writeReflection(QXmlStreamWriter &xmlWriter, const CppcheckLibraryData::Reflection &refl)
{
    xmlWriter.writeStartElement(""reflection"");
    for (const CppcheckLibraryData::Reflection::Call &call : refl.calls) {
        xmlWriter.writeStartElement(""call"");
        xmlWriter.writeAttribute(""arg"", QString(""%1"").arg(call.arg));
        xmlWriter.writeCharacters(call.name);
        xmlWriter.writeEndElement();
    }
    xmlWriter.writeEndElement();
}",1,1,gui/cppchecklibrarydata.cpp,"writeReflection:void(QXmlStreamWriter&,CppcheckLibraryData.Reflection&)",<empty>,,false,790,800,writeReflection,,,1,"void(QXmlStreamWriter&,CppcheckLibraryData.Reflection&)"
111669150361,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"static void writeMarkup(QXmlStreamWriter &xmlWriter, const CppcheckLibraryData::Markup &mup)
{
    xmlWriter.writeStartElement(""markup"");
    xmlWriter.writeAttribute(""ext"", mup.ext);
    xmlWriter.writeAttribute(""aftercode"", QVariant(mup.afterCode).toString());
    xmlWriter.writeAttribute(""reporterrors"", QVariant(mup.reportErrors).toString());
    if (!mup.keywords.isEmpty()) {
        xmlWriter.writeStartElement(""keywords"");
        for (const QString &keyword : mup.keywords) {
            xmlWriter.writeStartElement(""keyword"");
            xmlWriter.writeAttribute(""name"", keyword);
            xmlWriter.writeEndElement();
        }
        xmlWriter.writeEndElement();
    }
    if (!mup.importer.isEmpty()) {
        xmlWriter.writeStartElement(""imported"");
        for (const QString &import : mup.importer) {
            xmlWriter.writeStartElement(""importer"");
            xmlWriter.writeCharacters(import);
            xmlWriter.writeEndElement();
        }
        xmlWriter.writ...",1,1,gui/cppchecklibrarydata.cpp,"writeMarkup:void(QXmlStreamWriter&,CppcheckLibraryData.Markup&)",<empty>,,false,802,862,writeMarkup,,,1,"void(QXmlStreamWriter&,CppcheckLibraryData.Markup&)"
111669150362,METHOD,gui/cppchecklibrarydata.cpp:<global>,TYPE_DECL,"QString CppcheckLibraryData::toString() const
{
    QString outputString;
    QXmlStreamWriter xmlWriter(&outputString);
    xmlWriter.setAutoFormatting(true);
    xmlWriter.setAutoFormattingIndent(2);
    xmlWriter.writeStartDocument(""1.0"");
    xmlWriter.writeStartElement(""def"");
    xmlWriter.writeAttribute(""format"",""2"");

    for (const Define &define : defines) {
        xmlWriter.writeStartElement(""define"");
        xmlWriter.writeAttribute(""name"", define.name);
        xmlWriter.writeAttribute(""value"", define.value);
        xmlWriter.writeEndElement();
    }

    for (const QString &undef : undefines) {
        xmlWriter.writeStartElement(""undefine"");
        xmlWriter.writeAttribute(""name"", undef);
        xmlWriter.writeEndElement();
    }

    for (const Function &function : functions) {
        writeFunction(xmlWriter, function);
    }

    for (const MemoryResource &mr : memoryresource) {
        writeMemoryResource(xmlWriter, mr);
    }

    for (const Container &conta...",1,1,gui/cppchecklibrarydata.cpp,CppcheckLibraryData.toString<const>:QString(),<empty>,,false,864,945,toString,,,1,QString()
111669150363,METHOD,gui/cppchecklibrarydata.h:<global>,TYPE_DECL,<global>,1,1,gui/cppchecklibrarydata.h,gui/cppchecklibrarydata.h:<global>,<empty>,,false,1,264,<global>,,,1,
111669150364,METHOD,gui/csvreport.cpp:<global>,TYPE_DECL,"CsvReport::CsvReport(const QString &filename) :
    Report(filename)
{}",1,2,gui/csvreport.cpp,CsvReport.CsvReport:ANY(QString&),<empty>,,false,29,31,CsvReport,,,1,CsvReport.CsvReport:ANY(QString&)(QString&)
111669150365,METHOD,gui/csvreport.cpp:<global>,TYPE_DECL,<global>,1,1,gui/csvreport.cpp,gui/csvreport.cpp:<global>,<empty>,,false,1,72,<global>,,,1,
111669150366,METHOD,gui/csvreport.cpp:<global>,TYPE_DECL,"bool CsvReport::create()
{
    if (Report::create()) {
        mTxtWriter.setDevice(Report::getFile());
        return true;
    }
    return false;
}",1,1,gui/csvreport.cpp,CsvReport.create:bool(),<empty>,,false,33,40,create,,,1,bool()
111669150367,METHOD,gui/csvreport.cpp:<global>,TYPE_DECL,"void CsvReport::writeHeader()
{
    // Added 5 columns to the header.
#if (QT_VERSION >= QT_VERSION_CHECK(5, 14, 0))
    mTxtWriter << ""File, Line, Severity, Id, Summary"" << Qt::endl;
#else
    mTxtWriter << ""File, Line, Severity, Id, Summary"" << endl;
#endif
}",1,1,gui/csvreport.cpp,CsvReport.writeHeader:void(),<empty>,,false,42,50,writeHeader,,,1,void()
111669150368,METHOD,gui/csvreport.cpp:<global>,TYPE_DECL,"void CsvReport::writeFooter()
{
    // No footer for CSV report
}",1,1,gui/csvreport.cpp,CsvReport.writeFooter:void(),<empty>,,false,52,55,writeFooter,,,1,void()
111669150369,METHOD,gui/csvreport.cpp:<global>,TYPE_DECL,"void CsvReport::writeError(const ErrorItem &error)
{
    /*
       Error as CSV line
       gui/test.cpp,23,error,Mismatching allocation and deallocation: k
     */

    const QString file = QDir::toNativeSeparators(error.errorPath.back().file);
    QString line = QString(""%1,%2,"").arg(file).arg(error.errorPath.back().line);
    line += QString(""%1,%2,%3"").arg(GuiSeverity::toString(error.severity)).arg(error.errorId).arg(error.summary);
#if (QT_VERSION >= QT_VERSION_CHECK(5, 14, 0))
    mTxtWriter << line << Qt::endl;
#else
    mTxtWriter << line << endl;
#endif
}",1,1,gui/csvreport.cpp,CsvReport.writeError:void(ErrorItem&),<empty>,,false,57,72,writeError,,,1,void(ErrorItem&)
111669150370,METHOD,gui/csvreport.h:<global>,TYPE_DECL,<global>,1,1,gui/csvreport.h,gui/csvreport.h:<global>,<empty>,,false,1,71,<global>,,,1,
111669150371,METHOD,gui/erroritem.cpp:<global>,TYPE_DECL,"QErrorPathItem::QErrorPathItem(const ErrorMessage::FileLocation &loc)
    : file(QString::fromStdString(loc.getfile(false)))
    , line(loc.line)
    , column(loc.column)
    , info(QString::fromStdString(loc.getinfo()))
{}",1,2,gui/erroritem.cpp,QErrorPathItem.QErrorPathItem:ANY(ErrorMessage.FileLocation&),<empty>,,false,25,30,QErrorPathItem,,,1,QErrorPathItem.QErrorPathItem:ANY(ErrorMessage.FileLocation&)(ErrorMessage.FileLocation&)
111669150372,METHOD,gui/erroritem.cpp:<global>,TYPE_DECL,<global>,1,1,gui/erroritem.cpp,gui/erroritem.cpp:<global>,<empty>,,false,1,97,<global>,,,1,
111669150373,METHOD,gui/erroritem.cpp:<global>,TYPE_DECL,"bool operator==(const QErrorPathItem &i1, const QErrorPathItem &i2)
{
    return i1.file == i2.file && i1.column == i2.column && i1.line == i2.line && i1.info == i2.info;
}",1,1,gui/erroritem.cpp,"==:bool(QErrorPathItem&,QErrorPathItem&)",<empty>,,false,32,35,==,,,1,"bool(QErrorPathItem&,QErrorPathItem&)"
111669150374,METHOD,gui/erroritem.cpp:<global>,TYPE_DECL,"ErrorItem::ErrorItem()
    : severity(Severity::none)
    , inconclusive(false)
    , cwe(-1)
    , hash(0)
{}",1,2,gui/erroritem.cpp,ErrorItem.ErrorItem:ANY(),<empty>,,false,37,42,ErrorItem,,,1,ErrorItem.ErrorItem:ANY()()
111669150375,METHOD,gui/erroritem.cpp:<global>,TYPE_DECL,"ErrorItem::ErrorItem(const ErrorMessage &errmsg)
    : file0(QString::fromStdString(errmsg.file0))
    , errorId(QString::fromStdString(errmsg.id))
    , severity(errmsg.severity)
    , inconclusive(errmsg.certainty == Certainty::inconclusive)
    , summary(QString::fromStdString(errmsg.shortMessage()))
    , message(QString::fromStdString(errmsg.verboseMessage()))
    , cwe(errmsg.cwe.id)
    , hash(errmsg.hash)
    , symbolNames(QString::fromStdString(errmsg.symbolNames()))
    , remark(QString::fromStdString(errmsg.remark))
{
    for (const auto& loc: errmsg.callStack)
        errorPath << QErrorPathItem(loc);
}",1,1,gui/erroritem.cpp,ErrorItem.ErrorItem:ANY(ErrorMessage&),<empty>,,false,44,58,ErrorItem,,,1,ErrorItem.ErrorItem:ANY(ErrorMessage&)(ErrorMessage&)
111669150376,METHOD,gui/erroritem.cpp:<global>,TYPE_DECL,"QString ErrorItem::tool() const
{
    if (errorId == CLANG_ANALYZER)
        return CLANG_ANALYZER;
    if (errorId.startsWith(CLANG_TIDY))
        return CLANG_TIDY;
    if (errorId.startsWith(""clang-""))
        return ""clang"";
    return ""cppcheck"";
}",1,19,gui/erroritem.cpp,ErrorItem.tool<const>:QString(),<empty>,,false,60,69,tool,,,1,QString()
111669150377,METHOD,gui/erroritem.cpp:<global>,TYPE_DECL,"QString ErrorItem::toString() const
{
    QString str = errorPath.back().file + "" - "" + errorId + "" - "";
    if (inconclusive)
        str += ""inconclusive "";
    str += GuiSeverity::toString(severity) +""\\n"";
    str += summary + ""\\n"";
    str += message + ""\\n"";
    for (const QErrorPathItem& i : errorPath) {
        str += ""  "" + i.file + "": "" + QString::number(i.line) + ""\\n"";
    }
    return str;
}",1,1,gui/erroritem.cpp,ErrorItem.toString<const>:QString(),<empty>,,false,71,83,toString,,,1,QString()
111669150378,METHOD,gui/erroritem.cpp:<global>,TYPE_DECL,"bool ErrorItem::sameCID(const ErrorItem &errorItem1, const ErrorItem &errorItem2)
{
    if (errorItem1.hash || errorItem2.hash)
        return errorItem1.hash == errorItem2.hash;

    // fallback
    return errorItem1.errorId == errorItem2.errorId &&
           errorItem1.errorPath == errorItem2.errorPath &&
           errorItem1.file0 == errorItem2.file0 &&
           errorItem1.message == errorItem2.message &&
           errorItem1.inconclusive == errorItem2.inconclusive &&
           errorItem1.severity == errorItem2.severity;
}",1,1,gui/erroritem.cpp,"ErrorItem.sameCID:bool(ErrorItem&,ErrorItem&)",<empty>,,false,85,97,sameCID,,,1,"bool(ErrorItem&,ErrorItem&)"
111669150379,METHOD,gui/erroritem.h:<global>,TYPE_DECL,<global>,1,1,gui/erroritem.h,gui/erroritem.h:<global>,<empty>,,false,1,132,<global>,,,1,
111669150380,METHOD,gui/filelist.cpp:<global>,TYPE_DECL,"QStringList FileList::getDefaultFilters()
{
    QStringList extensions;
    extensions << ""*.cpp"" << ""*.cxx"" << ""*.cc"" << ""*.c"" << ""*.c++"" << ""*.txx"" << ""*.tpp"" << ""*.ipp"" << ""*.ixx"";
    return extensions;
}",1,1,gui/filelist.cpp,FileList.getDefaultFilters:QStringList(),<empty>,,false,31,36,getDefaultFilters,,,1,QStringList()
111669150381,METHOD,gui/filelist.cpp:<global>,TYPE_DECL,<global>,1,1,gui/filelist.cpp,gui/filelist.cpp:<global>,<empty>,,false,1,137,<global>,,,1,
111669150382,METHOD,gui/filelist.cpp:<global>,TYPE_DECL,"bool FileList::filterMatches(const QFileInfo &inf)
{
    if (inf.isFile()) {
        const QStringList filters = FileList::getDefaultFilters();
        QString ext(""*."");
        ext += inf.suffix();
        if (filters.contains(ext, Qt::CaseInsensitive))
            return true;
    }
    return false;
}",1,1,gui/filelist.cpp,FileList.filterMatches:bool(QFileInfo&),<empty>,,false,38,48,filterMatches,,,1,bool(QFileInfo&)
111669150383,METHOD,gui/filelist.cpp:<global>,TYPE_DECL,"void FileList::addFile(const QString &filepath)
{
    QFileInfo inf(filepath);
    if (filterMatches(inf))
        mFileList << inf;
}",1,1,gui/filelist.cpp,FileList.addFile:void(QString&),<empty>,,false,50,55,addFile,,,1,void(QString&)
111669150384,METHOD,gui/filelist.cpp:<global>,TYPE_DECL,"void FileList::addDirectory(const QString &directory, bool recursive)
{
    QDir dir(directory);
    dir.setSorting(QDir::Name);
    const QStringList filters = FileList::getDefaultFilters();
    const QStringList origNameFilters = dir.nameFilters();
    dir.setNameFilters(filters);
    if (!recursive) {
        dir.setFilter(QDir::Files | QDir::NoDotAndDotDot);
        QFileInfoList items = dir.entryInfoList();
        mFileList += items;
    } else {
        dir.setFilter(QDir::Files | QDir::NoDotAndDotDot);
        QFileInfoList items = dir.entryInfoList();
        mFileList += items;

        dir.setNameFilters(origNameFilters);
        dir.setFilter(QDir::Dirs | QDir::NoDotAndDotDot);
        for (const QFileInfo& item : dir.entryInfoList()) {
            const QString path = item.canonicalFilePath();
            addDirectory(path, recursive);
        }
    }
}",1,1,gui/filelist.cpp,"FileList.addDirectory:void(QString&,bool)",<empty>,,false,57,80,addDirectory,,,1,"void(QString&,bool)"
111669150385,METHOD,gui/filelist.cpp:<global>,TYPE_DECL,"void FileList::addPathList(const QStringList &paths)
{
    for (const QString& path : paths) {
        QFileInfo inf(path);
        if (inf.isFile())
            addFile(path);
        else
            addDirectory(path, true);
    }
}",1,1,gui/filelist.cpp,FileList.addPathList:void(QStringList&),<empty>,,false,82,91,addPathList,,,1,void(QStringList&)
111669150386,METHOD,gui/filelist.cpp:<global>,TYPE_DECL,"QStringList FileList::getFileList() const
{
    if (mExcludedPaths.empty()) {
        QStringList names;
        for (const QFileInfo& item : mFileList) {
            QString name = QDir::fromNativeSeparators(item.filePath());
            names << name;
        }
        return names;
    }
    return applyExcludeList();
}",1,1,gui/filelist.cpp,FileList.getFileList<const>:QStringList(),<empty>,,false,93,104,getFileList,,,1,QStringList()
111669150387,METHOD,gui/filelist.cpp:<global>,TYPE_DECL,"void FileList::addExcludeList(const QStringList &paths)
{
    mExcludedPaths = paths;
}",1,1,gui/filelist.cpp,FileList.addExcludeList:void(QStringList&),<empty>,,false,106,109,addExcludeList,,,1,void(QStringList&)
111669150388,METHOD,<empty>,<empty>,"[](const QString& s) {
        return s.toStdString();
    }",85,5,gui/filelist.cpp,gui/filelist.cpp:<global>.toStdStringList:vector<std.string>(QStringList&).<lambda>0:ANY(QString&),<empty>,,false,114,116,<lambda>0,,,1,ANY(QString&)
111669150389,METHOD,gui/filelist.cpp:<global>,TYPE_DECL,"static std::vector<std::string> toStdStringList(const QStringList &stringList)
{
    std::vector<std::string> ret;
    std::transform(stringList.cbegin(), stringList.cend(), std::back_inserter(ret), [](const QString& s) {
        return s.toStdString();
    });
    return ret;
}",1,1,gui/filelist.cpp,toStdStringList:vector<std.string>(QStringList&)<duplicate>0,<empty>,,false,111,118,toStdStringList,,,1,vector<std::string>(QStringList&)
111669150390,METHOD,gui/filelist.cpp:<global>,TYPE_DECL,"QStringList FileList::applyExcludeList() const
{
#ifdef _WIN32
    const PathMatch pathMatch(toStdStringList(mExcludedPaths), true);
#else
    const PathMatch pathMatch(toStdStringList(mExcludedPaths), false);
#endif

    QStringList paths;
    for (const QFileInfo& item : mFileList) {
        if (pathMatch.match(QDir::fromNativeSeparators(item.filePath()).toStdString()))
            continue;
        QString canonical = QDir::fromNativeSeparators(item.canonicalFilePath());
        if (!pathMatch.match(canonical.toStdString()))
            paths << canonical;
    }
    return paths;
}",1,1,gui/filelist.cpp,FileList.applyExcludeList<const>:QStringList(),<empty>,,false,120,137,applyExcludeList,,,1,QStringList()
111669150391,METHOD,gui/filelist.h:<global>,TYPE_DECL,<global>,1,20,gui/filelist.h,gui/filelist.h:<global>,<empty>,,false,1,101,<global>,,,1,
111669150392,METHOD,gui/fileviewdialog.cpp:<global>,TYPE_DECL,"FileViewDialog::FileViewDialog(const QString &file,
                               const QString &title,
                               QWidget *parent)
    : QDialog(parent)
    , mUI(new Ui::Fileview)
{
    mUI->setupUi(this);


    setWindowTitle(title);
    connect(mUI->mButtons, SIGNAL(accepted()), this, SLOT(accept()));
    loadTextFile(file, mUI->mText);
}",1,1,gui/fileviewdialog.cpp,"FileViewDialog.FileViewDialog:ANY(QString&,QString&,QWidget*)",<empty>,,false,30,42,FileViewDialog,,,1,"FileViewDialog.FileViewDialog:ANY(QString&,QString&,QWidget*)(QString&,QString&,QWidget*)"
111669150393,METHOD,gui/fileviewdialog.cpp:<global>,TYPE_DECL,<global>,1,1,gui/fileviewdialog.cpp,gui/fileviewdialog.cpp:<global>,<empty>,,false,1,82,<global>,,,1,
111669150394,METHOD,gui/fileviewdialog.cpp:<global>,TYPE_DECL,"FileViewDialog::~FileViewDialog()
{
    delete mUI;
}",1,1,gui/fileviewdialog.cpp,FileViewDialog.~FileViewDialog:ANY(),<empty>,,false,44,47,~FileViewDialog,,,1,ANY()
111669150395,METHOD,gui/fileviewdialog.cpp:<global>,TYPE_DECL,"void FileViewDialog::loadTextFile(const QString &filename, QTextEdit *edit)
{
    QFile file(filename);
    if (!file.exists()) {
        QString msg(tr(""Could not find the file: %1""));
        msg = msg.arg(filename);

        QMessageBox msgbox(QMessageBox::Critical,
                           tr(""Cppcheck""),
                           msg,
                           QMessageBox::Ok,
                           this);
        msgbox.exec();
        return;
    }

    file.open(QIODevice::ReadOnly | QIODevice::Text);
    if (!file.isReadable()) {
        QString msg(tr(""Could not read the file: %1""));
        msg = msg.arg(filename);

        QMessageBox msgbox(QMessageBox::Critical,
                           tr(""Cppcheck""),
                           msg,
                           QMessageBox::Ok,
                           this);
        msgbox.exec();
        return;
    }
    QByteArray filedata = file.readAll();
    file.close();

    edit->setPlainText(filedata);
}",1,1,gui/fileviewdialog.cpp,"FileViewDialog.loadTextFile:void(QString&,QTextEdit*)",<empty>,,false,49,82,loadTextFile,,,1,"void(QString&,QTextEdit*)"
111669150396,METHOD,gui/fileviewdialog.h:<global>,TYPE_DECL,<global>,1,27,gui/fileviewdialog.h,gui/fileviewdialog.h:<global>,<empty>,,false,1,64,<global>,,,1,
111669150397,METHOD,gui/helpdialog.cpp:<global>,TYPE_DECL,"void HelpBrowser::setHelpEngine(QHelpEngine *helpEngine)
{
    mHelpEngine = helpEngine;
}",1,1,gui/helpdialog.cpp,HelpBrowser.setHelpEngine:void(QHelpEngine*),<empty>,,false,38,41,setHelpEngine,,,1,void(QHelpEngine*)
111669150398,METHOD,gui/helpdialog.cpp:<global>,TYPE_DECL,<global>,1,1,gui/helpdialog.cpp,gui/helpdialog.cpp:<global>,<empty>,,false,1,121,<global>,,,1,
111669150399,METHOD,gui/helpdialog.cpp:<global>,TYPE_DECL,"QVariant HelpBrowser::loadResource(int type, const QUrl &name)
{
    if (name.scheme() == ""qthelp"") {
        QString url(name.toString());
        while (url.indexOf(""/./"") > 0)
            url.remove(url.indexOf(""/./""), 2);
        return QVariant(mHelpEngine->fileData(QUrl(url)));
    }
    return QTextBrowser::loadResource(type, name);
}",1,1,gui/helpdialog.cpp,"HelpBrowser.loadResource:QVariant(int,QUrl&)",<empty>,,false,43,52,loadResource,,,1,"QVariant(int,QUrl&)"
111669150400,METHOD,gui/helpdialog.cpp:<global>,TYPE_DECL,"static QString getHelpFile()
{
    const QString datadir = getDataDir();

    QStringList paths;
    paths << (datadir + ""/help"")
          << datadir
          << (QApplication::applicationDirPath() + ""/help"")
          << QApplication::applicationDirPath();
#ifdef FILESDIR
    const QString filesdir = FILESDIR;
    paths << (filesdir + ""/help"")
          << filesdir;
#endif
    for (const QString &p: paths) {
        QString filename = p + ""/online-help.qhc"";
        if (QFileInfo::exists(filename))
            return filename;
    }
    return QString();
}",1,1,gui/helpdialog.cpp,getHelpFile:QString(),<empty>,,false,54,74,getHelpFile,,,1,QString()
111669150401,METHOD,gui/helpdialog.cpp:<global>,TYPE_DECL,"HelpDialog::HelpDialog(QWidget *parent) :
    QDialog(parent),
    mUi(new Ui::HelpDialog)
{
    mUi->setupUi(this);

    QString helpFile = getHelpFile();
    if (helpFile.isEmpty()) {
        const QString msg = tr(""Helpfile '%1' was not found"").arg(""online-help.qhc"");
        QMessageBox msgBox(QMessageBox::Warning,
                           tr(""Cppcheck""),
                           msg,
                           QMessageBox::Ok,
                           this);
        msgBox.exec();
        mHelpEngine = nullptr;
        return;
    }

    mHelpEngine = new QHelpEngine(helpFile);
    // Disable the timestamp check of online-help.qhc by setting _q_readonly
    mHelpEngine->setProperty(""_q_readonly"", QVariant::fromValue<bool>(true));
    mHelpEngine->setupData();

    mUi->contents->addWidget(mHelpEngine->contentWidget());
    mUi->index->addWidget(mHelpEngine->indexWidget());

    mUi->textBrowser->setHelpEngine(mHelpEngine);

    mUi->textBrowser->setSource(QUrl(""qthelp://c...",1,1,gui/helpdialog.cpp,HelpDialog.HelpDialog:ANY(QWidget*),<empty>,,false,76,115,HelpDialog,,,1,HelpDialog.HelpDialog:ANY(QWidget*)(QWidget*)
111669150402,METHOD,gui/helpdialog.cpp:<global>,TYPE_DECL,"HelpDialog::~HelpDialog()
{
    delete mUi;
    delete mHelpEngine;
}",1,1,gui/helpdialog.cpp,HelpDialog.~HelpDialog:ANY(),<empty>,,false,117,121,~HelpDialog,,,1,ANY()
111669150403,METHOD,gui/helpdialog.h:<global>,TYPE_DECL,<global>,1,22,gui/helpdialog.h,gui/helpdialog.h:<global>,<empty>,,false,1,58,<global>,,,1,
111669150404,METHOD,gui/libraryaddfunctiondialog.cpp:<global>,TYPE_DECL,"LibraryAddFunctionDialog::LibraryAddFunctionDialog(QWidget *parent) :
    QDialog(parent),
    mUi(new Ui::LibraryAddFunctionDialog)
{
    mUi->setupUi(this);
    static const QRegularExpression rx(NAMES);
    QValidator *validator = new QRegularExpressionValidator(rx, this);
    mUi->functionName->setValidator(validator);
}",1,39,gui/libraryaddfunctiondialog.cpp,LibraryAddFunctionDialog.LibraryAddFunctionDialog:ANY(QWidget*),<empty>,,false,30,38,LibraryAddFunctionDialog,,,1,LibraryAddFunctionDialog.LibraryAddFunctionDialog:ANY(QWidget*)(QWidget*)
111669150405,METHOD,gui/libraryaddfunctiondialog.cpp:<global>,TYPE_DECL,<global>,1,1,gui/libraryaddfunctiondialog.cpp,gui/libraryaddfunctiondialog.cpp:<global>,<empty>,,false,1,53,<global>,,,1,
111669150406,METHOD,gui/libraryaddfunctiondialog.cpp:<global>,TYPE_DECL,"LibraryAddFunctionDialog::~LibraryAddFunctionDialog()
{
    delete mUi;
}",1,1,gui/libraryaddfunctiondialog.cpp,LibraryAddFunctionDialog.~LibraryAddFunctionDialog:ANY(),<empty>,,false,40,43,~LibraryAddFunctionDialog,,,1,ANY()
111669150407,METHOD,gui/libraryaddfunctiondialog.cpp:<global>,TYPE_DECL,"QString LibraryAddFunctionDialog::functionName() const
{
    return mUi->functionName->text();
}",1,1,gui/libraryaddfunctiondialog.cpp,LibraryAddFunctionDialog.functionName<const>:QString(),<empty>,,false,45,48,functionName,,,1,QString()
111669150408,METHOD,gui/libraryaddfunctiondialog.cpp:<global>,TYPE_DECL,"int LibraryAddFunctionDialog::numberOfArguments() const
{
    return mUi->numberOfArguments->value();
}",1,1,gui/libraryaddfunctiondialog.cpp,LibraryAddFunctionDialog.numberOfArguments<const>:int(),<empty>,,false,50,53,numberOfArguments,,,1,int()
111669150409,METHOD,gui/libraryaddfunctiondialog.h:<global>,TYPE_DECL,<global>,1,36,gui/libraryaddfunctiondialog.h,gui/libraryaddfunctiondialog.h:<global>,<empty>,,false,1,51,<global>,,,1,
111669150410,METHOD,FunctionListItem,TYPE_DECL,"FunctionListItem(QListWidget *view,
                         CppcheckLibraryData::Function *function,
                         bool selected)
            : QListWidgetItem(view), function(function) {
            setText(function->name);
            setFlags(flags() | Qt::ItemIsEditable);
            setSelected(selected);
        }",9,9,gui/librarydialog.cpp,"FunctionListItem.FunctionListItem:ANY(FunctionListItem.QListWidget*,CppcheckLibraryData.Function*,bool)",<empty>,,false,53,60,FunctionListItem,,,1,"FunctionListItem.FunctionListItem:ANY(FunctionListItem.QListWidget*,CppcheckLibraryData.Function*,bool)(FunctionListItem.QListWidget*,CppcheckLibraryData.Function*,bool)"
111669150411,METHOD,gui/librarydialog.cpp:<global>,TYPE_DECL,"LibraryDialog::LibraryDialog(QWidget *parent) :
    QDialog(parent),
    mUi(new Ui::LibraryDialog)
{
    mUi->setupUi(this);
    mUi->buttonSave->setEnabled(false);
    mUi->buttonSaveAs->setEnabled(false);
    mUi->sortFunctions->setEnabled(false);
    mUi->filter->setEnabled(false);
    mUi->addFunction->setEnabled(false);

    //As no function selected, this disables function editing widgets
    selectFunction();
}",1,1,gui/librarydialog.cpp,LibraryDialog.LibraryDialog:ANY(QWidget*),<empty>,,false,65,78,LibraryDialog,,,1,LibraryDialog.LibraryDialog:ANY(QWidget*)(QWidget*)
111669150412,METHOD,gui/librarydialog.cpp:<global>,TYPE_DECL,<global>,1,1,gui/librarydialog.cpp,gui/librarydialog.cpp:<global>,<empty>,,false,1,367,<global>,,,1,
111669150413,METHOD,gui/librarydialog.cpp:<global>,TYPE_DECL,"LibraryDialog::~LibraryDialog()
{
    delete mUi;
}",1,1,gui/librarydialog.cpp,LibraryDialog.~LibraryDialog:ANY(),<empty>,,false,80,83,~LibraryDialog,,,1,ANY()
111669150414,METHOD,gui/librarydialog.cpp:<global>,TYPE_DECL,"CppcheckLibraryData::Function *LibraryDialog::currentFunction()
{
    QList<QListWidgetItem *> selitems = mUi->functions->selectedItems();
    if (selitems.count() != 1)
        return nullptr;
    return dynamic_cast<FunctionListItem *>(selitems.first())->function;
}",1,1,gui/librarydialog.cpp,LibraryDialog.currentFunction:CppcheckLibraryData.Function*(),<empty>,,false,85,91,currentFunction,,,1,CppcheckLibraryData.Function*()
111669150415,METHOD,gui/librarydialog.cpp:<global>,TYPE_DECL,"void LibraryDialog::openCfg()
{
    const QString datadir = getDataDir();

    QString selectedFilter;
    const QString filter(tr(""Library files (*.cfg)""));
    const QString selectedFile = QFileDialog::getOpenFileName(this,
                                                              tr(""Open library file""),
                                                              datadir,
                                                              filter,
                                                              &selectedFilter);

    if (selectedFile.isEmpty())
        return;

    QFile file(selectedFile);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        QMessageBox msg(QMessageBox::Critical,
                        tr(""Cppcheck""),
                        tr(""Cannot open file %1."").arg(selectedFile),
                        QMessageBox::Ok,
                        this);
        msg.exec();
        return;
    }

    CppcheckLibraryData tempdata;
    const QStrin...",1,1,gui/librarydialog.cpp,LibraryDialog.openCfg:void(),<empty>,,false,93,147,openCfg,,,1,void()
111669150416,METHOD,gui/librarydialog.cpp:<global>,TYPE_DECL,"void LibraryDialog::saveCfg()
{
    if (mFileName.isNull())
        return;
    QFile file(mFileName);
    if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        QTextStream ts(&file);
        ts << mData.toString() << '\\n';
        mUi->buttonSave->setEnabled(false);
    } else {
        QMessageBox msg(QMessageBox::Critical,
                        tr(""Cppcheck""),
                        tr(""Cannot save file %1."").arg(mFileName),
                        QMessageBox::Ok,
                        this);
        msg.exec();
    }
}",1,1,gui/librarydialog.cpp,LibraryDialog.saveCfg:void(),<empty>,,false,149,166,saveCfg,,,1,void()
111669150417,METHOD,gui/librarydialog.cpp:<global>,TYPE_DECL,"void LibraryDialog::saveCfgAs()
{
    const QString filter(tr(""Library files (*.cfg)""));
    const QString path = Path::getPathFromFilename(mFileName.toStdString()).c_str();
    QString selectedFile = QFileDialog::getSaveFileName(this,
                                                        tr(""Save the library as""),
                                                        path,
                                                        filter);
    if (selectedFile.isEmpty())
        return;

    if (!selectedFile.endsWith("".cfg"", Qt::CaseInsensitive))
        selectedFile += "".cfg"";

    mFileName = selectedFile;
    saveCfg();
}",1,1,gui/librarydialog.cpp,LibraryDialog.saveCfgAs:void(),<empty>,,false,168,184,saveCfgAs,,,1,void()
111669150418,METHOD,gui/librarydialog.cpp:<global>,TYPE_DECL,"void LibraryDialog::addFunction()
{
    auto *d = new LibraryAddFunctionDialog;
    if (d->exec() == QDialog::Accepted && !d->functionName().isEmpty()) {

        CppcheckLibraryData::Function f;
        f.name = d->functionName();
        const int args = d->numberOfArguments();

        for (int i = 1; i <= args; i++) {
            CppcheckLibraryData::Function::Arg arg;
            arg.nr = i;
            f.args.append(arg);
        }
        mData.functions.append(f);
        mUi->functions->addItem(new FunctionListItem(mUi->functions, &mData.functions.back(), false));
        mUi->buttonSave->setEnabled(true);
        mUi->sortFunctions->setEnabled(!mData.functions.empty());
        mUi->filter->setEnabled(!mData.functions.empty());
    }
    delete d;
}",1,1,gui/librarydialog.cpp,LibraryDialog.addFunction:void(),<empty>,,false,186,207,addFunction,,,1,void()
111669150419,METHOD,gui/librarydialog.cpp:<global>,TYPE_DECL,"void LibraryDialog::editFunctionName(QListWidgetItem* item)
{
    if (mIgnoreChanges)
        return;
    QString functionName = item->text();
    CppcheckLibraryData::Function * const function = dynamic_cast<FunctionListItem*>(item)->function;
    if (functionName != function->name) {
        const QRegularExpressionMatch matchRes = QRegularExpression(""^"" NAMES ""$"").match(functionName);
        if (matchRes.hasMatch()) {
            function->name = functionName;
            mUi->buttonSave->setEnabled(true);
        } else {
            mIgnoreChanges = true;
            item->setText(function->name);
            mIgnoreChanges = false;
        }
    }
}",1,72,gui/librarydialog.cpp,LibraryDialog.editFunctionName:void(QListWidgetItem*),<empty>,,false,209,226,editFunctionName,,,1,void(QListWidgetItem*)
111669150420,METHOD,gui/librarydialog.cpp:<global>,TYPE_DECL,"void LibraryDialog::selectFunction()
{
    const CppcheckLibraryData::Function * const function = currentFunction();

    if (function == nullptr) {
        mUi->comments->clear();
        mUi->comments->setEnabled(false);

        mUi->noreturn->setCurrentIndex(0);
        mUi->noreturn->setEnabled(false);

        mUi->useretval->setChecked(false);
        mUi->useretval->setEnabled(false);

        mUi->leakignore->setChecked(false);
        mUi->leakignore->setEnabled(false);

        mUi->arguments->clear();
        mUi->arguments->setEnabled(false);

        mUi->editArgButton->setEnabled(false);
        return;
    }

    mIgnoreChanges = true;
    mUi->comments->setPlainText(function->comments);
    mUi->comments->setEnabled(true);

    mUi->noreturn->setCurrentIndex(function->noreturn);
    mUi->noreturn->setEnabled(true);

    mUi->useretval->setChecked(function->useretval);
    mUi->useretval->setEnabled(true);

    mUi->leakignore->setChecked(function->leakignore);
    m...",1,1,gui/librarydialog.cpp,LibraryDialog.selectFunction:void(),<empty>,,false,228,270,selectFunction,,,1,void()
111669150421,METHOD,gui/librarydialog.cpp:<global>,TYPE_DECL,"void LibraryDialog::sortFunctions(bool sort)
{
    if (sort) {
        mUi->functions->sortItems();
    } else {
        mIgnoreChanges = true;
        const CppcheckLibraryData::Function* selfunction = currentFunction();
        mUi->functions->clear();
        for (CppcheckLibraryData::Function &function : mData.functions) {
            mUi->functions->addItem(new FunctionListItem(mUi->functions,
                                                         &function,
                                                         selfunction == &function));
        }
        if (!mUi->filter->text().isEmpty())
            filterFunctions(mUi->filter->text());
        mIgnoreChanges = false;
    }
}",1,1,gui/librarydialog.cpp,LibraryDialog.sortFunctions:void(bool),<empty>,,false,272,289,sortFunctions,,,1,void(bool)
111669150422,METHOD,gui/librarydialog.cpp:<global>,TYPE_DECL,"void LibraryDialog::filterFunctions(const QString& filter)
{
    QList<QListWidgetItem *> allItems = mUi->functions->findItems(QString(), Qt::MatchContains);

    if (filter.isEmpty()) {
        for (QListWidgetItem *item : allItems) {
            item->setHidden(false);
        }
    } else {
        for (QListWidgetItem *item : allItems) {
            item->setHidden(!item->text().startsWith(filter));
        }
    }
}",1,1,gui/librarydialog.cpp,LibraryDialog.filterFunctions:void(QString&),<empty>,,false,291,304,filterFunctions,,,1,void(QString&)
111669150423,METHOD,gui/librarydialog.cpp:<global>,TYPE_DECL,"void LibraryDialog::changeFunction()
{
    if (mIgnoreChanges)
        return;

    CppcheckLibraryData::Function *function = currentFunction();
    if (!function)
        return;

    function->comments   = mUi->comments->toPlainText();
    function->noreturn   = (CppcheckLibraryData::Function::TrueFalseUnknown)mUi->noreturn->currentIndex();
    function->useretval  = mUi->useretval->isChecked();
    function->leakignore = mUi->leakignore->isChecked();

    mUi->buttonSave->setEnabled(true);
}",1,1,gui/librarydialog.cpp,LibraryDialog.changeFunction:void(),<empty>,,false,306,321,changeFunction,,,1,void()
111669150424,METHOD,gui/librarydialog.cpp:<global>,TYPE_DECL,"void LibraryDialog::editArg()
{
    CppcheckLibraryData::Function *function = currentFunction();
    if (!function)
        return;

    if (mUi->arguments->selectedItems().count() != 1)
        return;
    CppcheckLibraryData::Function::Arg &arg = function->args[mUi->arguments->row(mUi->arguments->selectedItems().first())];

    LibraryEditArgDialog d(nullptr, arg);
    if (d.exec() == QDialog::Accepted) {
        const unsigned number = arg.nr;
        arg = d.getArg();
        arg.nr = number;
        mUi->arguments->selectedItems().first()->setText(getArgText(arg));
    }
    mUi->buttonSave->setEnabled(true);
}",1,1,gui/librarydialog.cpp,LibraryDialog.editArg:void(),<empty>,,false,323,341,editArg,,,1,void()
111669150425,METHOD,gui/librarydialog.cpp:<global>,TYPE_DECL,"QString LibraryDialog::getArgText(const CppcheckLibraryData::Function::Arg &arg)
{
    QString s(""arg"");
    if (arg.nr != CppcheckLibraryData::Function::Arg::ANY)
        s += QString::number(arg.nr);

    s += ""\\n    not bool: "" + QString(bool_to_string(arg.notbool));
    s += ""\\n    not null: "" +  QString(bool_to_string(arg.notnull));
    s += ""\\n    not uninit: "" +  QString(bool_to_string(arg.notuninit));
    s += ""\\n    format string: "" +  QString(bool_to_string(arg.formatstr));
    s += ""\\n    strz: "" +  QString(bool_to_string(arg.strz));
    s += ""\\n    valid: "" + (arg.valid.isEmpty() ? ""any"" : arg.valid);
    for (const CppcheckLibraryData::Function::Arg::MinSize &minsize : arg.minsizes) {
        s += ""\\n    minsize: "" + minsize.type + "" "" + minsize.arg + "" "" + minsize.arg2;
    }
    return s;
}",1,1,gui/librarydialog.cpp,LibraryDialog.getArgText:QString(CppcheckLibraryData.Function.Arg&),<empty>,,false,343,359,getArgText,,,1,QString(CppcheckLibraryData.Function.Arg&)
111669150426,METHOD,gui/librarydialog.cpp:<global>,TYPE_DECL,"void LibraryDialog::updateArguments(const CppcheckLibraryData::Function &function)
{
    mUi->arguments->clear();
    for (const CppcheckLibraryData::Function::Arg &arg : function.args) {
        mUi->arguments->addItem(getArgText(arg));
    }
}",1,1,gui/librarydialog.cpp,LibraryDialog.updateArguments:void(CppcheckLibraryData.Function&),<empty>,,false,361,367,updateArguments,,,1,void(CppcheckLibraryData.Function&)
111669150427,METHOD,gui/librarydialog.h:<global>,TYPE_DECL,<global>,1,1,gui/librarydialog.h,gui/librarydialog.h:<global>,<empty>,,false,1,66,<global>,,,1,
111669150428,METHOD,gui/libraryeditargdialog.cpp:<global>,TYPE_DECL,"LibraryEditArgDialog::LibraryEditArgDialog(QWidget *parent, const CppcheckLibraryData::Function::Arg &arg) :
    QDialog(parent),
    mUi(new Ui::LibraryEditArgDialog),
    mMinSizes(arg.minsizes)
{
    mUi->setupUi(this);
    mUi->notbool->setChecked(arg.notbool);
    mUi->notnull->setChecked(arg.notnull);
    mUi->notuninit->setChecked(arg.notuninit);
    mUi->strz->setChecked(arg.strz);
    mUi->formatstr->setChecked(arg.formatstr);
    mUi->valid->setText(arg.valid);

    mUi->minsize1type->setEnabled(true);
    mUi->minsize1arg->setEnabled(arg.minsizes.count() >= 1);
    mUi->minsize1arg2->setEnabled(arg.minsizes.count() >= 1 && arg.minsizes[0].type == ""mul"");
    mUi->minsize2type->setEnabled(arg.minsizes.count() >= 1);
    mUi->minsize2arg->setEnabled(arg.minsizes.count() >= 2);
    mUi->minsize2arg2->setEnabled(arg.minsizes.count() >= 2 && arg.minsizes[1].type == ""mul"");

    QStringList items;
    items << ""None"" << ""argvalue"" << ""mul"" << ""sizeof"" << ""strlen"";

    mUi->min...",1,1,gui/libraryeditargdialog.cpp,"LibraryEditArgDialog.LibraryEditArgDialog:ANY(QWidget*,CppcheckLibraryData.Function.Arg&)",<empty>,,false,32,84,LibraryEditArgDialog,,,1,"LibraryEditArgDialog.LibraryEditArgDialog:ANY(QWidget*,CppcheckLibraryData.Function.Arg&)(QWidget*,CppcheckLibraryData.Function.Arg&)"
111669150429,METHOD,gui/libraryeditargdialog.cpp:<global>,TYPE_DECL,<global>,1,1,gui/libraryeditargdialog.cpp,gui/libraryeditargdialog.cpp:<global>,<empty>,,false,1,127,<global>,,,1,
111669150430,METHOD,gui/libraryeditargdialog.cpp:<global>,TYPE_DECL,"LibraryEditArgDialog::~LibraryEditArgDialog()
{
    delete mUi;
}",1,1,gui/libraryeditargdialog.cpp,LibraryEditArgDialog.~LibraryEditArgDialog:ANY(),<empty>,,false,86,89,~LibraryEditArgDialog,,,1,ANY()
111669150431,METHOD,gui/libraryeditargdialog.cpp:<global>,TYPE_DECL,"CppcheckLibraryData::Function::Arg LibraryEditArgDialog::getArg() const
{
    CppcheckLibraryData::Function::Arg ret;
    ret.notbool   = mUi->notbool->isChecked();
    ret.notnull   = mUi->notnull->isChecked();
    ret.notuninit = mUi->notuninit->isChecked();
    ret.strz      = mUi->strz->isChecked();
    ret.formatstr = mUi->formatstr->isChecked();
    if (mUi->minsize1type->currentIndex() != 0) {
        CppcheckLibraryData::Function::Arg::MinSize minsize1;
        minsize1.type = mUi->minsize1type->currentText();
        minsize1.arg  = QString::number(mUi->minsize1arg->value());
        if (minsize1.type == ""mul"")
            minsize1.arg2 = QString::number(mUi->minsize1arg2->value());
        ret.minsizes.append(minsize1);

        if (mUi->minsize2type->currentIndex() != 0) {
            CppcheckLibraryData::Function::Arg::MinSize minsize2;
            minsize2.type = mUi->minsize2type->currentText();
            minsize2.arg  = QString::number(mUi->minsize2arg->value());
  ...",1,1,gui/libraryeditargdialog.cpp,LibraryEditArgDialog.getArg<const>:CppcheckLibraryData.Function.Arg(),<empty>,,false,91,118,getArg,,,1,CppcheckLibraryData.Function.Arg()
111669150432,METHOD,gui/libraryeditargdialog.cpp:<global>,TYPE_DECL,"void LibraryEditArgDialog::minsizeChanged()
{
    mUi->minsize1arg->setEnabled(mUi->minsize1type->currentIndex() != 0);
    mUi->minsize1arg2->setEnabled(mUi->minsize1type->currentText() == ""mul"");
    mUi->minsize2type->setEnabled(mUi->minsize1type->currentIndex() != 0);
    mUi->minsize2arg->setEnabled(mUi->minsize2type->currentIndex() != 0);
    mUi->minsize2arg2->setEnabled(mUi->minsize2type->currentText() == ""mul"");
}",1,1,gui/libraryeditargdialog.cpp,LibraryEditArgDialog.minsizeChanged:void(),<empty>,,false,120,127,minsizeChanged,,,1,void()
111669150433,METHOD,gui/libraryeditargdialog.h:<global>,TYPE_DECL,<global>,1,1,gui/libraryeditargdialog.h,gui/libraryeditargdialog.h:<global>,<empty>,,false,1,53,<global>,,,1,
111669150434,METHOD,<empty>,<empty>,"[](const QString& arg) {
        return arg.startsWith(""--data-dir="");
    }",56,5,gui/main.cpp,gui/main.cpp:<global>.main.<lambda>0:ANY(QString&),<empty>,,false,65,67,<lambda>0,,,1,ANY(QString&)
111669150435,METHOD,gui/main.cpp:<global>,TYPE_DECL,"int main(int argc, char *argv[])
{

#if (QT_VERSION >= QT_VERSION_CHECK(5, 6, 0)) && (QT_VERSION < QT_VERSION_CHECK(6, 0, 0))
    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
    QApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);
#endif

    QApplication app(argc, argv);

    QCoreApplication::setOrganizationName(""Cppcheck"");
    QCoreApplication::setApplicationName(""Cppcheck-GUI"");

    auto* settings = new QSettings(""Cppcheck"", ""Cppcheck-GUI"", &app);

    // Set data dir..
    const QStringList args = QApplication::arguments();
    auto it = std::find_if(args.cbegin(), args.cend(), [](const QString& arg) {
        return arg.startsWith(""--data-dir="");
    });
    if (it != args.end()) {
        settings->setValue(""DATADIR"", it->mid(11));
        return 0;
    }

    auto* th = new TranslationHandler(&app);
    th->setLanguage(settings->value(SETTINGS_LANGUAGE, th->suggestLanguage()).toString());

    if (!CheckArgs(QApplication::arguments()))
        return 0;

    ...",1,36,gui/main.cpp,"main<duplicate>0:int(int,char[]*)",<empty>,,false,48,87,main,,,1,"int(int,char[]*)"
111669150436,METHOD,gui/main.cpp:<global>,TYPE_DECL,<global>,1,1,gui/main.cpp,gui/main.cpp:<global>,<empty>,,false,1,146,<global>,,,1,
111669150437,METHOD,gui/main.cpp:<global>,TYPE_DECL,"static bool CheckArgs(const QStringList &args)
{
    if (args.contains(""-h"") || args.contains(""--help"")) {
        ShowUsage();
        return false;
    }
    if (args.contains(""-v"") || args.contains(""--version"")) {
        ShowVersion();
        return false;
    }
    return true;
}",1,1,gui/main.cpp,CheckArgs:bool(QStringList&),<empty>,,false,91,102,CheckArgs,,,1,bool(QStringList&)
111669150438,METHOD,gui/main.cpp:<global>,TYPE_DECL,"static void ShowUsage()
{
    QString helpMessage = MainWindow::tr(
        ""Cppcheck GUI.\\n\\n""
        ""Syntax:\\n""
        ""    cppcheck-gui [OPTIONS] [files or paths]\\n\\n""
        ""Options:\\n""
        ""    -h, --help              Print this help\\n""
        ""    -p <file>               Open given project file and start checking it\\n""
        ""    -l <file>               Open given results xml file\\n""
        ""    -d <directory>          Specify the directory that was checked to generate the results xml specified with -l\\n""
        ""    -v, --version           Show program version\\n""
        ""    --data-dir=<directory>  This option is for installation scripts so they can configure the directory where\\n""
        ""                            datafiles are located (translations, cfg). The GUI is not started when this option\\n""
        ""                            is used."");
#if defined(_WIN32)
    QMessageBox msgBox(QMessageBox::Information,
                       MainWindow::tr(""Cppc...",1,1,gui/main.cpp,ShowUsage:void(),<empty>,,false,104,129,ShowUsage,,,1,void()
111669150439,METHOD,gui/main.cpp:<global>,TYPE_DECL,"static void ShowVersion()
{
#if defined(_WIN32)
    AboutDialog *dlg = new AboutDialog(CppCheck::version(), CppCheck::extraVersion(), 0);
    dlg->exec();
    delete dlg;
#else
    std::string versionMessage(""Cppcheck "");
    versionMessage += CppCheck::version();
    const char * extraVersion = CppCheck::extraVersion();
    if (*extraVersion != 0)
        versionMessage += std::string("" ("") + extraVersion + "")"";

    std::cout << versionMessage << std::endl;
#endif
}",1,1,gui/main.cpp,ShowVersion:void(),<empty>,,false,131,146,ShowVersion,,,1,void()
111669150440,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"static QString fromNativePath(const QString& p) {
#ifdef Q_OS_WIN
    QString ret(p);
    ret.replace('\\\\', '/');
    return ret;
#else
    return p;
#endif
}",1,1,gui/mainwindow.cpp,fromNativePath:QString(QString&),<empty>,,false,106,114,fromNativePath,,,1,QString(QString&)
111669150441,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,<global>,1,1,gui/mainwindow.cpp,gui/mainwindow.cpp:<global>,<empty>,,false,1,2333,<global>,,,1,
111669150442,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"MainWindow::MainWindow(TranslationHandler* th, QSettings* settings) :
    mSettings(settings),
    mApplications(new ApplicationList(this)),
    mTranslation(th),
    mUI(new Ui::MainWindow),
    mPlatformActions(new QActionGroup(this)),
    mCStandardActions(new QActionGroup(this)),
    mCppStandardActions(new QActionGroup(this)),
    mSelectLanguageActions(new QActionGroup(this)),
    mSelectReportActions(new QActionGroup(this))
{
    {
        Settings tempSettings;
        tempSettings.exename = QCoreApplication::applicationFilePath().toStdString();
        Suppressions tempSupprs;
        Settings::loadCppcheckCfg(tempSettings, tempSupprs); // TODO: how to handle error?
        mCppcheckCfgProductName = QString::fromStdString(tempSettings.cppcheckCfgProductName);
        mCppcheckCfgAbout = QString::fromStdString(tempSettings.cppcheckCfgAbout);
    }

    mUI->setupUi(this);
    mThread = new ThreadHandler(this);
    mUI->mResults->initialize(mSettings, mApplications, mThread);...",1,77,gui/mainwindow.cpp,"MainWindow.MainWindow:ANY(TranslationHandler*,QSettings*)",<empty>,,false,116,338,MainWindow,,,1,"MainWindow.MainWindow:ANY(TranslationHandler*,QSettings*)(TranslationHandler*,QSettings*)"
111669150443,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"MainWindow::~MainWindow()
{
    delete mProjectFile;
    delete mScratchPad;
    delete mUI;
}",1,1,gui/mainwindow.cpp,MainWindow.~MainWindow:ANY(),<empty>,,false,340,345,~MainWindow,,,1,ANY()
111669150444,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::handleCLIParams(const QStringList &params)
{
    int index;
    if (params.contains(""-p"")) {
        index = params.indexOf(""-p"");
        if ((index + 1) < params.length())
            loadProjectFile(params[index + 1]);
    } else if (params.contains(""-l"")) {
        QString logFile;
        index = params.indexOf(""-l"");
        if ((index + 1) < params.length())
            logFile = params[index + 1];

        if (params.contains(""-d"")) {
            QString checkedDir;
            index = params.indexOf(""-d"");
            if ((index + 1) < params.length())
                checkedDir = params[index + 1];

            loadResults(logFile, checkedDir);
        } else {
            loadResults(logFile);
        }
    } else if ((index = params.indexOf(QRegularExpression("".*\\\\.cppcheck$"", QRegularExpression::CaseInsensitiveOption))) >= 0 && index < params.length() && QFile(params[index]).exists()) {
        loadProjectFile(params[index]);
    } else if ((index = par...",1,1,gui/mainwindow.cpp,MainWindow.handleCLIParams:void(QStringList&),<empty>,,false,347,376,handleCLIParams,,,1,void(QStringList&)
111669150445,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::loadSettings()
{
    // Window/dialog sizes
    if (mSettings->value(SETTINGS_WINDOW_MAXIMIZED, false).toBool()) {
        showMaximized();
    } else {
        resize(mSettings->value(SETTINGS_WINDOW_WIDTH, 800).toInt(),
               mSettings->value(SETTINGS_WINDOW_HEIGHT, 600).toInt());
    }

    const ReportType reportType = (ReportType)mSettings->value(SETTINGS_REPORT_TYPE, (int)ReportType::normal).toInt();
    mUI->mActionReportNormal->setChecked(reportType <= ReportType::normal);
    mUI->mActionReportAutosar->setChecked(reportType == ReportType::autosar);
    mUI->mActionReportCertC->setChecked(reportType == ReportType::certC);
    mUI->mActionReportCertCpp->setChecked(reportType == ReportType::certCpp);
    mUI->mActionReportMisraC->setChecked(reportType == ReportType::misraC);
    mUI->mActionReportMisraCpp2008->setChecked(reportType == ReportType::misraCpp2008);
    mUI->mActionReportMisraCpp2023->setChecked(reportType == ReportType::misraCpp2023);

  ...",1,25,gui/mainwindow.cpp,MainWindow.loadSettings:void(),<empty>,,false,378,470,loadSettings,,,1,void()
111669150446,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::saveSettings() const
{
    // Window/dialog sizes
    mSettings->setValue(SETTINGS_WINDOW_WIDTH, size().width());
    mSettings->setValue(SETTINGS_WINDOW_HEIGHT, size().height());
    mSettings->setValue(SETTINGS_WINDOW_MAXIMIZED, isMaximized());

    const ReportType reportType = mUI->mActionReportAutosar->isChecked() ? ReportType::autosar :
                                  mUI->mActionReportCertC->isChecked() ? ReportType::certC :
                                  mUI->mActionReportCertCpp->isChecked() ? ReportType::certCpp :
                                  mUI->mActionReportMisraC->isChecked() ? ReportType::misraC :
                                  mUI->mActionReportMisraCpp2008->isChecked() ? ReportType::misraCpp2008 :
                                  mUI->mActionReportMisraCpp2023->isChecked() ? ReportType::misraCpp2023 :
                                  ReportType::normal;
    mSettings->setValue(SETTINGS_REPORT_TYPE, (int)reportType);

    // Show * sta...",1,24,gui/mainwindow.cpp,MainWindow.saveSettings<const>:void(),<empty>,,false,472,541,saveSettings,,,1,void()
111669150447,METHOD,<empty>,<empty>,"[](const QString& e) {
            return e.toStdString();
        }",83,9,gui/mainwindow.cpp,gui/mainwindow.cpp:<global>.MainWindow.doAnalyzeProject.<lambda>0:ANY(QString&),<empty>,,false,556,558,<lambda>0,,,1,ANY(QString&)
111669150448,METHOD,<empty>,<empty>,"[](const QString& e) {
                return e.toStdString();
            }",98,13,gui/mainwindow.cpp,gui/mainwindow.cpp:<global>.MainWindow.doAnalyzeProject.<lambda>1:ANY(QString&),<empty>,,false,565,567,<lambda>1,,,1,ANY(QString&)
111669150449,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::doAnalyzeProject(ImportProject p, const bool checkLibrary, const bool checkConfiguration)
{
    Settings checkSettings;
    auto supprs = std::make_shared<Suppressions>();
    if (!getCppcheckSettings(checkSettings, *supprs))
        return;

    clearResults();

    mIsLogfileLoaded = false;
    if (mProjectFile) {
        std::vector<std::string> v;
        const QStringList excluded = mProjectFile->getExcludedPaths();
        std::transform(excluded.cbegin(), excluded.cend(), std::back_inserter(v), [](const QString& e) {
            return e.toStdString();
        });
        p.ignorePaths(v);

        if (!mProjectFile->getAnalyzeAllVsConfigs()) {
            const Platform::Type platform = (Platform::Type) mSettings->value(SETTINGS_CHECKED_PLATFORM, 0).toInt();
            std::vector<std::string> configurations;
            const QStringList configs = mProjectFile->getVsConfigurations();
            std::transform(configs.cbegin(), configs.cend(), std::back_in...",1,78,gui/mainwindow.cpp,"MainWindow.doAnalyzeProject:void(ImportProject,bool,bool)",<empty>,,false,543,609,doAnalyzeProject,,,1,"void(ImportProject,bool,bool)"
111669150450,METHOD,<empty>,<empty>,"[](const QString& s) {
            return s.toStdString();
        }",95,9,gui/mainwindow.cpp,gui/mainwindow.cpp:<global>.MainWindow.doAnalyzeFiles.<lambda>2:ANY(QString&),<empty>,,false,668,670,<lambda>2,,,1,ANY(QString&)
111669150451,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::doAnalyzeFiles(const QStringList &files, const bool checkLibrary, const bool checkConfiguration)
{
    if (files.isEmpty())
        return;

    Settings checkSettings;
    auto supprs = std::make_shared<Suppressions>();
    if (!getCppcheckSettings(checkSettings, *supprs))
        return;

    clearResults();

    mIsLogfileLoaded = false;
    FileList pathList;
    pathList.addPathList(files);
    if (mProjectFile) {
        pathList.addExcludeList(mProjectFile->getExcludedPaths());
    } else {
        enableProjectActions(false);
    }
    QStringList fileNames = pathList.getFileList();

    mUI->mResults->clear(true);
    mThread->clearFiles();

    if (fileNames.isEmpty()) {
        QMessageBox msg(QMessageBox::Warning,
                        tr(""Cppcheck""),
                        tr(""No suitable files found to analyze!""),
                        QMessageBox::Ok,
                        this);
        msg.exec();
        return;
    }

    mUI->mResults->che...",1,12,gui/mainwindow.cpp,"MainWindow.doAnalyzeFiles:void(QStringList&,bool,bool)",<empty>,,false,611,677,doAnalyzeFiles,,,1,"void(QStringList&,bool,bool)"
111669150452,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::analyzeCode(const QString& code, const QString& filename)
{
    Settings checkSettings;
    Suppressions supprs;
    if (!getCppcheckSettings(checkSettings, supprs))
        return;

    // Initialize dummy ThreadResult as ErrorLogger
    ThreadResult result;
    result.setFiles(QStringList(filename));
    connect(&result, SIGNAL(progress(int,QString)),
            mUI->mResults, SLOT(progress(int,QString)));
    connect(&result, SIGNAL(error(ErrorItem)),
            mUI->mResults, SLOT(error(ErrorItem)));
    connect(&result, SIGNAL(log(QString)),
            mUI->mResults, SLOT(log(QString)));
    connect(&result, SIGNAL(debugError(ErrorItem)),
            mUI->mResults, SLOT(debugError(ErrorItem)));

    // Create CppCheck instance
    CppCheck cppcheck(checkSettings, supprs, result, true, nullptr);

    // Check
    checkLockDownUI();
    clearResults();
    mUI->mResults->checkingStarted(1);
    cppcheck.check(FileWithDetails(filename.toStdString()), code.toStd...",1,1,gui/mainwindow.cpp,"MainWindow.analyzeCode:void(QString&,QString&)",<empty>,,false,679,711,analyzeCode,,,1,"void(QString&,QString&)"
111669150453,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"QStringList MainWindow::selectFilesToAnalyze(QFileDialog::FileMode mode)
{
    if (mProjectFile) {
        QMessageBox msgBox(this);
        msgBox.setWindowTitle(tr(""Cppcheck""));
        const QString msg(tr(""You must close the project file before selecting new files or directories!""));
        msgBox.setText(msg);
        msgBox.setIcon(QMessageBox::Critical);
        msgBox.exec();
        return QStringList();
    }

    QStringList selected;

    // NOTE: we use QFileDialog::getOpenFileNames() and
    // QFileDialog::getExistingDirectory() because they show native Windows
    // selection dialog which is a lot more usable than Qt:s own dialog.
    if (mode == QFileDialog::ExistingFiles) {
        QMap<QString,QString> filters;
        filters[tr(""C/C++ Source"")] = FileList::getDefaultFilters().join("" "");
        filters[tr(""Compile database"")] = compile_commands_json;
        filters[tr(""Visual Studio"")] = ""*.sln *.vcxproj"";
        filters[tr(""Borland C++ Builder 6"")] = ""*.bpr...",1,46,gui/mainwindow.cpp,MainWindow.selectFilesToAnalyze:QStringList(QFileDialog.FileMode),<empty>,,false,713,767,selectFilesToAnalyze,,,1,QStringList(QFileDialog.FileMode)
111669150454,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::analyzeFiles()
{
    Settings::terminate(false);

    QStringList selected = selectFilesToAnalyze(QFileDialog::ExistingFiles);

    const QString file0 = (!selected.empty() ? selected[0].toLower() : QString());
    if (file0.endsWith("".sln"")
        || file0.endsWith("".vcxproj"")
        || file0.endsWith(compile_commands_json)
        || file0.endsWith("".bpr"")) {
        ImportProject p;
        p.import(selected[0].toStdString());

        if (file0.endsWith("".sln"")) {
            QStringList configs;
            for (auto it = p.fileSettings.cbegin(); it != p.fileSettings.cend(); ++it) {
                const QString cfg(QString::fromStdString(it->cfg));
                if (!configs.contains(cfg))
                    configs.push_back(cfg);
            }
            configs.sort();

            bool ok = false;
            const QString cfg = QInputDialog::getItem(this, tr(""Select configuration""), tr(""Select the configuration that will be analyzed""), configs, 0, f...",1,1,gui/mainwindow.cpp,MainWindow.analyzeFiles:void(),<empty>,,false,769,804,analyzeFiles,,,1,void()
111669150455,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::analyzeDirectory()
{
    QStringList dir = selectFilesToAnalyze(QFileDialog::Directory);
    if (dir.isEmpty())
        return;

    QDir checkDir(dir[0]);
    QStringList filters;
    filters << ""*.cppcheck"";
    checkDir.setFilter(QDir::Files | QDir::Readable);
    checkDir.setNameFilters(filters);
    QStringList projFiles = checkDir.entryList();
    if (!projFiles.empty()) {
        if (projFiles.size() == 1) {
            // If one project file found, suggest loading it
            QMessageBox msgBox(this);
            msgBox.setWindowTitle(tr(""Cppcheck""));
            const QString msg(tr(""Found project file: %1\\n\\nDo you want to ""
                                 ""load this project file instead?"").arg(projFiles[0]));
            msgBox.setText(msg);
            msgBox.setIcon(QMessageBox::Warning);
            msgBox.addButton(QMessageBox::Yes);
            msgBox.addButton(QMessageBox::No);
            msgBox.setDefaultButton(QMessageBox::Yes);
            c...",1,1,gui/mainwindow.cpp,MainWindow.analyzeDirectory:void(),<empty>,,false,806,861,analyzeDirectory,,,1,void()
111669150456,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::addIncludeDirs(const QStringList &includeDirs, Settings &result)
{
    for (const QString& dir : includeDirs) {
        QString incdir;
        if (!QDir::isAbsolutePath(dir))
            incdir = mCurrentDirectory + ""/"";
        incdir += dir;
        incdir = QDir::cleanPath(incdir);

        // include paths must end with '/'
        if (!incdir.endsWith(""/""))
            incdir += ""/"";
        result.includePaths.push_back(incdir.toStdString());
    }
}",1,1,gui/mainwindow.cpp,"MainWindow.addIncludeDirs:void(QStringList&,Settings&)",<empty>,,false,863,877,addIncludeDirs,,,1,"void(QStringList&,Settings&)"
111669150457,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"Library::Error MainWindow::loadLibrary(Library &library, const QString &filename)
{
    Library::Error ret;

    // Try to load the library from the project folder..
    if (mProjectFile) {
        QString path = QFileInfo(mProjectFile->getFilename()).canonicalPath();
        QString libpath = path+""/""+filename;
        qDebug().noquote() << ""looking for library '"" + libpath + ""'"";
        ret = library.load(nullptr, libpath.toLatin1());
        if (ret.errorcode != Library::ErrorCode::FILE_NOT_FOUND)
            return ret;
    }

    // Try to load the library from the application folder..
    const QString appPath = QFileInfo(QCoreApplication::applicationFilePath()).canonicalPath();
    QString libpath = appPath+""/""+filename;
    qDebug().noquote() << ""looking for library '"" + libpath + ""'"";
    ret = library.load(nullptr, libpath.toLatin1());
    if (ret.errorcode != Library::ErrorCode::FILE_NOT_FOUND)
        return ret;
    libpath = appPath+""/cfg/""+filename;
    qDebug().noqu...",1,1,gui/mainwindow.cpp,"MainWindow.loadLibrary:Library.Error(Library&,QString&)",<empty>,,false,879,941,loadLibrary,,,1,"Library.Error(Library&,QString&)"
111669150458,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"bool MainWindow::tryLoadLibrary(Library &library, const QString& filename)
{
    const Library::Error error = loadLibrary(library, filename);
    if (error.errorcode != Library::ErrorCode::OK) {
        if (error.errorcode == Library::ErrorCode::UNKNOWN_ELEMENT) {
            QMessageBox::information(this, tr(""Information""), tr(""The library '%1' contains unknown elements:\\n%2"").arg(filename).arg(error.reason.c_str()));
            return true;
        }

        QString errmsg;
        switch (error.errorcode) {
        case Library::ErrorCode::OK:
            break;
        case Library::ErrorCode::FILE_NOT_FOUND:
            errmsg = tr(""File not found"");
            break;
        case Library::ErrorCode::BAD_XML:
            errmsg = tr(""Bad XML"");
            break;
        case Library::ErrorCode::MISSING_ATTRIBUTE:
            errmsg = tr(""Missing attribute"");
            break;
        case Library::ErrorCode::BAD_ATTRIBUTE_VALUE:
            errmsg = tr(""Bad attribute value...",1,1,gui/mainwindow.cpp,"MainWindow.tryLoadLibrary:bool(Library&,QString&)",<empty>,,false,943,993,tryLoadLibrary,,,1,"bool(Library&,QString&)"
111669150459,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"QString MainWindow::loadAddon(Settings &settings, const QString &filesDir, const QString &pythonCmd, const QString& addon)
{
    const QString addonFilePath = fromNativePath(ProjectFile::getAddonFilePath(filesDir, addon));

    if (addonFilePath.isEmpty())
        return tr(""File not found: '%1'"").arg(addon);

    picojson::object obj;
    obj[""script""] = picojson::value(addonFilePath.toStdString());
    if (!pythonCmd.isEmpty())
        obj[""python""] = picojson::value(pythonCmd.toStdString());

    if (!isCppcheckPremium() && addon == ""misra"") {
        const QString misraFile = fromNativePath(mSettings->value(SETTINGS_MISRA_FILE).toString());
        if (!misraFile.isEmpty()) {
            QString arg;
            picojson::array arr;
            if (misraFile.endsWith("".pdf"", Qt::CaseInsensitive))
                arg = ""--misra-pdf="" + misraFile;
            else
                arg = ""--rule-texts="" + misraFile;
            arr.emplace_back(arg.toStdString());
            obj[""a...",1,66,gui/mainwindow.cpp,"MainWindow.loadAddon:QString(Settings&,QString&,QString&,QString&)",<empty>,,false,995,1032,loadAddon,,,1,"QString(Settings&,QString&,QString&,QString&)"
111669150460,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"bool MainWindow::getCppcheckSettings(Settings& settings, Suppressions& supprs)
{
    saveSettings(); // Save settings

    Settings::terminate(true);

    settings.exename = QCoreApplication::applicationFilePath().toStdString();

    // default to --check-level=normal for GUI for now
    settings.setCheckLevel(Settings::CheckLevel::normal);

    const bool std = tryLoadLibrary(settings.library, ""std.cfg"");
    if (!std) {
        QMessageBox::critical(this, tr(""Error""), tr(""Failed to load %1. Your Cppcheck installation is broken. You can use --data-dir=<directory> at the command line to specify where this file is located. Please note that --data-dir is supposed to be used by installation scripts and therefore the GUI does not start when it is used, all that happens is that the setting is configured.\\n\\nAnalysis is aborted."").arg(""std.cfg""));
        return false;
    }

    const QString filesDir(getDataDir());
    const QString pythonCmd = fromNativePath(mSettings->value(SETTINGS_P...",1,62,gui/mainwindow.cpp,"MainWindow.getCppcheckSettings:bool(Settings&,Suppressions&)",<empty>,,false,1034,1218,getCppcheckSettings,,,1,"bool(Settings&,Suppressions&)"
111669150461,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::analysisDone()
{
    if (mExiting) {
        close();
        return;
    }

    mUI->mResults->checkingFinished();
    enableCheckButtons(true);
    mUI->mActionSettings->setEnabled(true);
    mUI->mActionOpenXML->setEnabled(true);
    if (mProjectFile) {
        enableProjectActions(true);
    } else if (mIsLogfileLoaded) {
        mUI->mActionReanalyzeModified->setEnabled(false);
        mUI->mActionReanalyzeAll->setEnabled(false);
    }
    enableProjectOpenActions(true);
    mPlatformActions->setEnabled(true);
    mCStandardActions->setEnabled(true);
    mCppStandardActions->setEnabled(true);
    mSelectLanguageActions->setEnabled(true);
    mUI->mActionPosix->setEnabled(true);
    if (mScratchPad)
        mScratchPad->setEnabled(true);
    mUI->mActionViewStats->setEnabled(true);

    if (mProjectFile && !mProjectFile->getBuildDir().isEmpty()) {
        const QString prjpath = QFileInfo(mProjectFile->getFilename()).absolutePath();
        const QString buildDi...",1,25,gui/mainwindow.cpp,MainWindow.analysisDone:void(),<empty>,,false,1220,1268,analysisDone,,,1,void()
111669150462,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::checkLockDownUI()
{
    enableCheckButtons(false);
    mUI->mActionSettings->setEnabled(false);
    mUI->mActionOpenXML->setEnabled(false);
    enableProjectActions(false);
    enableProjectOpenActions(false);
    mPlatformActions->setEnabled(false);
    mCStandardActions->setEnabled(false);
    mCppStandardActions->setEnabled(false);
    mSelectLanguageActions->setEnabled(false);
    mUI->mActionPosix->setEnabled(false);
    if (mScratchPad)
        mScratchPad->setEnabled(false);

    for (QAction* recentProjectAct : mRecentProjectActs) {
        if (recentProjectAct != nullptr)
            recentProjectAct->setEnabled(false);
    }
}",1,1,gui/mainwindow.cpp,MainWindow.checkLockDownUI:void(),<empty>,,false,1270,1289,checkLockDownUI,,,1,void()
111669150463,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::programSettings()
{
    SettingsDialog dialog(mApplications, mTranslation, isCppcheckPremium(), this);
    if (dialog.exec() == QDialog::Accepted) {
        dialog.saveSettingValues();
        mSettings->sync();
        mUI->mResults->updateSettings(dialog.showFullPath(),
                                      dialog.saveFullPath(),
                                      dialog.saveAllErrors(),
                                      dialog.showNoErrorsMessage(),
                                      dialog.showErrorId(),
                                      dialog.showInconclusive());
        mUI->mResults->updateStyleSetting(mSettings);
        const QString newLang = mSettings->value(SETTINGS_LANGUAGE, ""en"").toString();
        setLanguage(newLang);
    }
}",1,49,gui/mainwindow.cpp,MainWindow.programSettings:void(),<empty>,,false,1291,1307,programSettings,,,1,void()
111669150464,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::reAnalyzeModified()
{
    reAnalyze(false);
}",1,1,gui/mainwindow.cpp,MainWindow.reAnalyzeModified:void(),<empty>,,false,1309,1312,reAnalyzeModified,,,1,void()
111669150465,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::reAnalyzeAll()
{
    if (mProjectFile)
        analyzeProject(mProjectFile, QStringList());
    else
        reAnalyze(true);
}",1,1,gui/mainwindow.cpp,MainWindow.reAnalyzeAll:void(),<empty>,,false,1314,1320,reAnalyzeAll,,,1,void()
111669150466,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::checkLibrary()
{
    if (mProjectFile)
        analyzeProject(mProjectFile, QStringList(), true);
}",1,1,gui/mainwindow.cpp,MainWindow.checkLibrary:void(),<empty>,,false,1322,1326,checkLibrary,,,1,void()
111669150467,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::checkConfiguration()
{
    if (mProjectFile)
        analyzeProject(mProjectFile, QStringList(), false, true);
}",1,1,gui/mainwindow.cpp,MainWindow.checkConfiguration:void(),<empty>,,false,1328,1332,checkConfiguration,,,1,void()
111669150468,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::reAnalyzeSelected(const QStringList& files)
{
    if (files.empty())
        return;
    if (mThread->isChecking())
        return;

    if (mProjectFile) {
        // Clear details, statistics and progress
        mUI->mResults->clear(false);
        for (int i = 0; i < files.size(); ++i)
            mUI->mResults->clearRecheckFile(files[i]);

        analyzeProject(mProjectFile, files);
        return;
    }

    Settings checkSettings;
    auto supprs = std::make_shared<Suppressions>();
    if (!getCppcheckSettings(checkSettings, *supprs))
        return;

    // Clear details, statistics and progress
    mUI->mResults->clear(false);
    for (int i = 0; i < files.size(); ++i)
        mUI->mResults->clearRecheckFile(files[i]);

    mCurrentDirectory = mUI->mResults->getCheckDirectory();
    FileList pathList;
    pathList.addPathList(files);
    if (mProjectFile)
        pathList.addExcludeList(mProjectFile->getExcludedPaths());
    QStringList fileNames = pathLis...",1,1,gui/mainwindow.cpp,MainWindow.reAnalyzeSelected:void(QStringList&),<empty>,,false,1334,1378,reAnalyzeSelected,,,1,void(QStringList&)
111669150469,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::reAnalyze(bool all)
{
    const QStringList files = mThread->getReCheckFiles(all);
    if (files.empty())
        return;

    Settings checkSettings;
    auto supprs = std::make_shared<Suppressions>();
    if (!getCppcheckSettings(checkSettings, *supprs))
        return;

    // Clear details, statistics and progress
    mUI->mResults->clear(all);

    // Clear results for changed files
    for (int i = 0; i < files.size(); ++i)
        mUI->mResults->clear(files[i]);

    checkLockDownUI(); // lock UI while checking
    mUI->mResults->checkingStarted(files.size());

    if (mProjectFile)
        qDebug() << ""Rechecking project file"" << mProjectFile->getFilename();

    mThread->setCheckFiles(all);
    mThread->check(checkSettings, supprs);
    mUI->mResults->setCheckSettings(checkSettings);
}",1,1,gui/mainwindow.cpp,MainWindow.reAnalyze:void(bool),<empty>,,false,1380,1407,reAnalyze,,,1,void(bool)
111669150470,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::clearResults()
{
    if (mProjectFile && !mProjectFile->getBuildDir().isEmpty()) {
        QDir dir(QFileInfo(mProjectFile->getFilename()).absolutePath() + '/' + mProjectFile->getBuildDir());
        for (const QString& f: dir.entryList(QDir::Files)) {
            if (!f.endsWith(""files.txt"")) {
                static const QRegularExpression rx(""^.*.s[0-9]+$"");
                if (!rx.match(f).hasMatch())
                    dir.remove(f);
            }
        }
    }
    mUI->mResults->clear(true);
    Q_ASSERT(false == mUI->mResults->hasResults());
    enableResultsButtons();
}",1,1,gui/mainwindow.cpp,MainWindow.clearResults:void(),<empty>,,false,1409,1424,clearResults,,,1,void()
111669150471,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::openResults()
{
    if (mUI->mResults->hasResults()) {
        QMessageBox msgBox(this);
        msgBox.setWindowTitle(tr(""Cppcheck""));
        const QString msg(tr(""Current results will be cleared.\\n\\n""
                             ""Opening a new XML file will clear current results.\\n""
                             ""Do you want to proceed?""));
        msgBox.setText(msg);
        msgBox.setIcon(QMessageBox::Warning);
        msgBox.addButton(QMessageBox::Yes);
        msgBox.addButton(QMessageBox::No);
        msgBox.setDefaultButton(QMessageBox::Yes);
        const int dlgResult = msgBox.exec();
        if (dlgResult == QMessageBox::No) {
            return;
        }
    }

    QString selectedFilter;
    const QString filter(tr(""XML files (*.xml)""));
    QString selectedFile = QFileDialog::getOpenFileName(this,
                                                        tr(""Open the report file""),
                                                        getPath(SETTIN...",1,64,gui/mainwindow.cpp,MainWindow.openResults:void(),<empty>,,false,1426,1456,openResults,,,1,void()
111669150472,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::loadResults(const QString &selectedFile)
{
    if (selectedFile.isEmpty())
        return;
    if (mProjectFile)
        closeProjectFile();
    mIsLogfileLoaded = true;
    mUI->mResults->clear(true);
    mUI->mActionReanalyzeModified->setEnabled(false);
    mUI->mActionReanalyzeAll->setEnabled(false);
    mUI->mResults->readErrorsXml(selectedFile);
    setPath(SETTINGS_LAST_RESULT_PATH, selectedFile);
    formatAndSetTitle(selectedFile);
}",1,12,gui/mainwindow.cpp,MainWindow.loadResults:void(QString&),<empty>,,false,1458,1471,loadResults,,,1,void(QString&)
111669150473,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::loadResults(const QString &selectedFile, const QString &sourceDirectory)
{
    loadResults(selectedFile);
    mUI->mResults->setCheckDirectory(sourceDirectory);
}",1,1,gui/mainwindow.cpp,"MainWindow.loadResults:void(QString&,QString&)",<empty>,,false,1473,1477,loadResults,,,1,"void(QString&,QString&)"
111669150474,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::enableCheckButtons(bool enable)
{
    mUI->mActionStop->setEnabled(!enable);
    mUI->mActionAnalyzeFiles->setEnabled(enable);

    if (mProjectFile) {
        mUI->mActionReanalyzeModified->setEnabled(enable);
        mUI->mActionReanalyzeAll->setEnabled(enable);
    } else if (!enable || mThread->hasPreviousFiles()) {
        mUI->mActionReanalyzeModified->setEnabled(enable);
        mUI->mActionReanalyzeAll->setEnabled(enable);
    }

    mUI->mActionAnalyzeDirectory->setEnabled(enable);

    if (isCppcheckPremium()) {
        mUI->mActionComplianceReport->setEnabled(enable && mProjectFile && (mProjectFile->getAddons().contains(""misra"") || !mProjectFile->getCodingStandards().empty()));
    }
}",1,1,gui/mainwindow.cpp,MainWindow.enableCheckButtons:void(bool),<empty>,,false,1479,1497,enableCheckButtons,,,1,void(bool)
111669150475,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::enableResultsButtons()
{
    const bool enabled = mUI->mResults->hasResults();
    mUI->mActionClearResults->setEnabled(enabled);
    mUI->mActionSave->setEnabled(enabled);
    mUI->mActionPrint->setEnabled(enabled);
    mUI->mActionPrintPreview->setEnabled(enabled);
}",1,1,gui/mainwindow.cpp,MainWindow.enableResultsButtons:void(),<empty>,,false,1499,1506,enableResultsButtons,,,1,void()
111669150476,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::showStyle(bool checked)
{
    mUI->mResults->showResults(ShowTypes::ShowStyle, checked);
}",1,1,gui/mainwindow.cpp,MainWindow.showStyle:void(bool),<empty>,,false,1508,1511,showStyle,,,1,void(bool)
111669150477,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::showErrors(bool checked)
{
    mUI->mResults->showResults(ShowTypes::ShowErrors, checked);
}",1,1,gui/mainwindow.cpp,MainWindow.showErrors:void(bool),<empty>,,false,1513,1516,showErrors,,,1,void(bool)
111669150478,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::showWarnings(bool checked)
{
    mUI->mResults->showResults(ShowTypes::ShowWarnings, checked);
}",1,1,gui/mainwindow.cpp,MainWindow.showWarnings:void(bool),<empty>,,false,1518,1521,showWarnings,,,1,void(bool)
111669150479,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::showPortability(bool checked)
{
    mUI->mResults->showResults(ShowTypes::ShowPortability, checked);
}",1,1,gui/mainwindow.cpp,MainWindow.showPortability:void(bool),<empty>,,false,1523,1526,showPortability,,,1,void(bool)
111669150480,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::showPerformance(bool checked)
{
    mUI->mResults->showResults(ShowTypes::ShowPerformance, checked);
}",1,1,gui/mainwindow.cpp,MainWindow.showPerformance:void(bool),<empty>,,false,1528,1531,showPerformance,,,1,void(bool)
111669150481,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::showInformation(bool checked)
{
    mUI->mResults->showResults(ShowTypes::ShowInformation, checked);
}",1,1,gui/mainwindow.cpp,MainWindow.showInformation:void(bool),<empty>,,false,1533,1536,showInformation,,,1,void(bool)
111669150482,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::checkAll()
{
    toggleAllChecked(true);
}",1,1,gui/mainwindow.cpp,MainWindow.checkAll:void(),<empty>,,false,1538,1541,checkAll,,,1,void()
111669150483,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::uncheckAll()
{
    toggleAllChecked(false);
}",1,1,gui/mainwindow.cpp,MainWindow.uncheckAll:void(),<empty>,,false,1543,1546,uncheckAll,,,1,void()
111669150484,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::closeEvent(QCloseEvent *event)
{
    // Check that we aren't checking files
    if (!mThread->isChecking()) {
        saveSettings();
        event->accept();
    } else {
        const QString text(tr(""Analyzer is running.\\n\\n"" \\
                              ""Do you want to stop the analysis and exit Cppcheck?""));

        QMessageBox msg(QMessageBox::Warning,
                        tr(""Cppcheck""),
                        text,
                        QMessageBox::Yes | QMessageBox::No,
                        this);

        msg.setDefaultButton(QMessageBox::No);
        const int rv = msg.exec();
        if (rv == QMessageBox::Yes) {
            // This isn't really very clean way to close threads but since the app is
            // exiting it doesn't matter.
            mThread->stop();
            saveSettings();
            mExiting = true;
        }
        event->ignore();
    }
}",1,1,gui/mainwindow.cpp,MainWindow.closeEvent:void(QCloseEvent*),<empty>,,false,1548,1575,closeEvent,,,1,void(QCloseEvent*)
111669150485,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::toggleAllChecked(bool checked)
{
    mUI->mActionShowStyle->setChecked(checked);
    showStyle(checked);
    mUI->mActionShowErrors->setChecked(checked);
    showErrors(checked);
    mUI->mActionShowWarnings->setChecked(checked);
    showWarnings(checked);
    mUI->mActionShowPortability->setChecked(checked);
    showPortability(checked);
    mUI->mActionShowPerformance->setChecked(checked);
    showPerformance(checked);
    mUI->mActionShowInformation->setChecked(checked);
    showInformation(checked);
}",1,1,gui/mainwindow.cpp,MainWindow.toggleAllChecked:void(bool),<empty>,,false,1577,1591,toggleAllChecked,,,1,void(bool)
111669150486,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::about()
{
    if (!mCppcheckCfgAbout.isEmpty()) {
        QMessageBox msg(QMessageBox::Information,
                        tr(""About""),
                        mCppcheckCfgAbout,
                        QMessageBox::Ok,
                        this);
        msg.exec();
    }
    else {
        auto *dlg = new AboutDialog(CppCheck::version(), CppCheck::extraVersion(), this);
        dlg->exec();
    }
}",1,1,gui/mainwindow.cpp,MainWindow.about:void(),<empty>,,false,1593,1607,about,,,1,void()
111669150487,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::showLicense()
{
    auto *dlg = new FileViewDialog("":COPYING"", tr(""License""), this);
    dlg->resize(570, 400);
    dlg->exec();
}",1,1,gui/mainwindow.cpp,MainWindow.showLicense:void(),<empty>,,false,1609,1614,showLicense,,,1,void()
111669150488,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::showAuthors()
{
    auto *dlg = new FileViewDialog("":AUTHORS"", tr(""Authors""), this);
    dlg->resize(350, 400);
    dlg->exec();
}",1,1,gui/mainwindow.cpp,MainWindow.showAuthors:void(),<empty>,,false,1616,1621,showAuthors,,,1,void()
111669150489,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::performSelectedFilesCheck(const QStringList &selectedFilesList)
{
    reAnalyzeSelected(selectedFilesList);
}",1,1,gui/mainwindow.cpp,MainWindow.performSelectedFilesCheck:void(QStringList&),<empty>,,false,1623,1626,performSelectedFilesCheck,,,1,void(QStringList&)
111669150490,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::save()
{
    QString selectedFilter;
    const QString filter(tr(""XML files (*.xml);;Text files (*.txt);;CSV files (*.csv)""));
    QString selectedFile = QFileDialog::getSaveFileName(this,
                                                        tr(""Save the report file""),
                                                        getPath(SETTINGS_LAST_RESULT_PATH),
                                                        filter,
                                                        &selectedFilter);

    if (!selectedFile.isEmpty()) {
        Report::Type type = Report::TXT;
        if (selectedFilter == tr(""XML files (*.xml)"")) {
            type = Report::XMLV2;
            if (!selectedFile.endsWith("".xml"", Qt::CaseInsensitive))
                selectedFile += "".xml"";
        } else if (selectedFilter == tr(""Text files (*.txt)"")) {
            type = Report::TXT;
            if (!selectedFile.endsWith("".txt"", Qt::CaseInsensitive))
                selectedFile += ""....",1,64,gui/mainwindow.cpp,MainWindow.save:void(),<empty>,,false,1628,1664,save,,,1,void()
111669150491,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::complianceReport()
{
    if (!mUI->mResults->isSuccess()) {
        QMessageBox m(QMessageBox::Critical,
                      ""Cppcheck"",
                      tr(""Cannot generate a compliance report right now, an analysis must finish successfully. Try to reanalyze the code and ensure there are no critical errors.""),
                      QMessageBox::Ok,
                      this);
        m.exec();
        return;
    }

    QTemporaryFile tempResults;
    tempResults.open();
    tempResults.close();

    mUI->mResults->save(tempResults.fileName(), Report::XMLV2, mCppcheckCfgProductName);

    ComplianceReportDialog dlg(mProjectFile, tempResults.fileName(), mUI->mResults->getStatistics()->getCheckersReport());
    dlg.exec();
}",1,1,gui/mainwindow.cpp,MainWindow.complianceReport:void(),<empty>,,false,1666,1686,complianceReport,,,1,void()
111669150492,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::resultsAdded()
{}",1,2,gui/mainwindow.cpp,MainWindow.resultsAdded:void(),<empty>,,false,1688,1689,resultsAdded,,,1,void()
111669150493,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::toggleMainToolBar()
{
    mUI->mToolBarMain->setVisible(mUI->mActionToolBarMain->isChecked());
}",1,1,gui/mainwindow.cpp,MainWindow.toggleMainToolBar:void(),<empty>,,false,1691,1694,toggleMainToolBar,,,1,void()
111669150494,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::toggleViewToolBar()
{
    mUI->mToolBarView->setVisible(mUI->mActionToolBarView->isChecked());
}",1,1,gui/mainwindow.cpp,MainWindow.toggleViewToolBar:void(),<empty>,,false,1696,1699,toggleViewToolBar,,,1,void()
111669150495,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::toggleFilterToolBar()
{
    mUI->mToolBarFilter->setVisible(mUI->mActionToolBarFilter->isChecked());
    mLineEditFilter->clear(); // Clearing the filter also disables filtering
}",1,1,gui/mainwindow.cpp,MainWindow.toggleFilterToolBar:void(),<empty>,,false,1701,1705,toggleFilterToolBar,,,1,void()
111669150496,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::formatAndSetTitle(const QString &text)
{
    QString nameWithVersion = QString(""Cppcheck %1"").arg(CppCheck::version());

    QString extraVersion = CppCheck::extraVersion();
    if (!extraVersion.isEmpty()) {
        nameWithVersion += "" ("" + extraVersion + "")"";
    }

    if (!mCppcheckCfgProductName.isEmpty())
        nameWithVersion = mCppcheckCfgProductName;

    QString title;
    if (text.isEmpty())
        title = nameWithVersion;
    else
        title = QString(""%1 - %2"").arg(nameWithVersion, text);
    setWindowTitle(title);
}",1,1,gui/mainwindow.cpp,MainWindow.formatAndSetTitle:void(QString&),<empty>,,false,1707,1725,formatAndSetTitle,,,1,void(QString&)
111669150497,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::setLanguage(const QString &code)
{
    const QString currentLang = mTranslation->getCurrentLanguage();
    if (currentLang == code)
        return;

    if (mTranslation->setLanguage(code)) {
        //Translate everything that is visible here
        mUI->retranslateUi(this);
        mUI->mResults->translate();
        mLineEditFilter->setPlaceholderText(QCoreApplication::translate(""MainWindow"", ""Quick Filter:""));
        if (mProjectFile)
            formatAndSetTitle(tr(""Project:"") + ' ' + mProjectFile->getFilename());
        if (mScratchPad)
            mScratchPad->translate();
    }
}",1,1,gui/mainwindow.cpp,MainWindow.setLanguage:void(QString&),<empty>,,false,1727,1743,setLanguage,,,1,void(QString&)
111669150498,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::aboutToShowViewMenu()
{
    mUI->mActionToolBarMain->setChecked(mUI->mToolBarMain->isVisible());
    mUI->mActionToolBarView->setChecked(mUI->mToolBarView->isVisible());
    mUI->mActionToolBarFilter->setChecked(mUI->mToolBarFilter->isVisible());
}",1,1,gui/mainwindow.cpp,MainWindow.aboutToShowViewMenu:void(),<empty>,,false,1745,1750,aboutToShowViewMenu,,,1,void()
111669150499,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::stopAnalysis()
{
    mThread->stop();
    mUI->mResults->stopAnalysis();
    mUI->mResults->disableProgressbar();
    const QString &lastResults = getLastResults();
    if (!lastResults.isEmpty()) {
        mUI->mResults->updateFromOldReport(lastResults);
    }
}",1,1,gui/mainwindow.cpp,MainWindow.stopAnalysis:void(),<empty>,,false,1752,1761,stopAnalysis,,,1,void()
111669150500,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::openHelpContents()
{
    openOnlineHelp();
}",1,1,gui/mainwindow.cpp,MainWindow.openHelpContents:void(),<empty>,,false,1763,1766,openHelpContents,,,1,void()
111669150501,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::openOnlineHelp()
{
    auto *helpDialog = new HelpDialog;
    helpDialog->showMaximized();
}",1,1,gui/mainwindow.cpp,MainWindow.openOnlineHelp:void(),<empty>,,false,1768,1772,openOnlineHelp,,,1,void()
111669150502,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::openProjectFile()
{
    const QString filter = tr(""Project files (*.cppcheck);;All files(*.*)"");
    const QString filepath = QFileDialog::getOpenFileName(this,
                                                          tr(""Select Project File""),
                                                          getPath(SETTINGS_LAST_PROJECT_PATH),
                                                          filter);

    if (!filepath.isEmpty()) {
        const QFileInfo fi(filepath);
        if (fi.exists() && fi.isFile() && fi.isReadable()) {
            setPath(SETTINGS_LAST_PROJECT_PATH, filepath);
            loadProjectFile(filepath);
        }
    }
}",1,66,gui/mainwindow.cpp,MainWindow.openProjectFile:void(),<empty>,,false,1774,1789,openProjectFile,,,1,void()
111669150503,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::showScratchpad()
{
    if (!mScratchPad)
        mScratchPad = new ScratchPad(*this);

    mScratchPad->show();

    if (!mScratchPad->isActiveWindow())
        mScratchPad->activateWindow();
}",1,1,gui/mainwindow.cpp,MainWindow.showScratchpad:void(),<empty>,,false,1791,1800,showScratchpad,,,1,void()
111669150504,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::loadProjectFile(const QString &filePath)
{
    QFileInfo inf(filePath);
    const QString filename = inf.fileName();
    formatAndSetTitle(tr(""Project:"") + ' ' + filename);
    addProjectMRU(filePath);

    mIsLogfileLoaded = false;
    mUI->mActionCloseProjectFile->setEnabled(true);
    mUI->mActionEditProjectFile->setEnabled(true);
    delete mProjectFile;
    mProjectFile = new ProjectFile(filePath, this);
    mProjectFile->setActiveProject();
    if (!loadLastResults())
        analyzeProject(mProjectFile, QStringList());
}",1,1,gui/mainwindow.cpp,MainWindow.loadProjectFile:void(QString&),<empty>,,false,1802,1817,loadProjectFile,,,1,void(QString&)
111669150505,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"QString MainWindow::getLastResults() const
{
    if (!mProjectFile || mProjectFile->getBuildDir().isEmpty())
        return QString();
    return QFileInfo(mProjectFile->getFilename()).absolutePath() + '/' + mProjectFile->getBuildDir() + ""/lastResults.xml"";
}",1,1,gui/mainwindow.cpp,MainWindow.getLastResults<const>:QString(),<empty>,,false,1819,1824,getLastResults,,,1,QString()
111669150506,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"bool MainWindow::loadLastResults()
{
    const QString &lastResults = getLastResults();
    if (lastResults.isEmpty())
        return false;
    if (!QFileInfo::exists(lastResults))
        return false;
    mUI->mResults->clear(true);
    mUI->mResults->readErrorsXml(lastResults);
    mUI->mResults->setCheckDirectory(mSettings->value(SETTINGS_LAST_CHECK_PATH,QString()).toString());
    mUI->mActionViewStats->setEnabled(true);
    enableResultsButtons();
    return true;
}",1,54,gui/mainwindow.cpp,MainWindow.loadLastResults:bool(),<empty>,,false,1826,1839,loadLastResults,,,1,bool()
111669150507,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::analyzeProject(const ProjectFile *projectFile, const QStringList& recheckFiles, const bool checkLibrary, const bool checkConfiguration)
{
    Settings::terminate(false);

    QFileInfo inf(projectFile->getFilename());
    const QString& rootpath = projectFile->getRootPath();

    if (isCppcheckPremium() && !projectFile->getLicenseFile().isEmpty()) {
        if (rootpath.isEmpty() || rootpath == ""."")
            QDir::setCurrent(inf.absolutePath());
        else if (QDir(rootpath).isAbsolute())
            QDir::setCurrent(rootpath);
        else
            QDir::setCurrent(inf.absolutePath() + ""/"" + rootpath);

        QString licenseFile = projectFile->getLicenseFile();
        if (!QFileInfo(licenseFile).isAbsolute() && !rootpath.isEmpty())
            licenseFile = inf.absolutePath() + ""/"" + licenseFile;

#ifdef Q_OS_WIN
        const QString premiumaddon = QCoreApplication::applicationDirPath() + ""/premiumaddon.exe"";
#else
        const QString premiumaddon = Q...",1,1,gui/mainwindow.cpp,"MainWindow.analyzeProject:void(ProjectFile*,QStringList&,bool,bool)",<empty>,,false,1841,1977,analyzeProject,,,1,"void(ProjectFile*,QStringList&,bool,bool)"
111669150508,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::newProjectFile()
{
    const QString filter = tr(""Project files (*.cppcheck)"");
    QString filepath = QFileDialog::getSaveFileName(this,
                                                    tr(""Select Project Filename""),
                                                    getPath(SETTINGS_LAST_PROJECT_PATH),
                                                    filter);

    if (filepath.isEmpty())
        return;
    if (!filepath.endsWith("".cppcheck"", Qt::CaseInsensitive))
        filepath += "".cppcheck"";

    setPath(SETTINGS_LAST_PROJECT_PATH, filepath);

    QFileInfo inf(filepath);
    const QString filename = inf.fileName();
    formatAndSetTitle(tr(""Project:"") + QString("" "") + filename);

    delete mProjectFile;
    mProjectFile = new ProjectFile(this);
    mProjectFile->setActiveProject();
    mProjectFile->setFilename(filepath);
    mProjectFile->setProjectName(filename.left(filename.indexOf(""."")));
    mProjectFile->setBuildDir(filename.left(filename.index...",1,60,gui/mainwindow.cpp,MainWindow.newProjectFile:void(),<empty>,,false,1979,2012,newProjectFile,,,1,void()
111669150509,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::closeProjectFile()
{
    delete mProjectFile;
    mProjectFile = nullptr;
    mUI->mResults->clear(true);
    enableProjectActions(false);
    enableProjectOpenActions(true);
    formatAndSetTitle();
}",1,1,gui/mainwindow.cpp,MainWindow.closeProjectFile:void(),<empty>,,false,2014,2022,closeProjectFile,,,1,void()
111669150510,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::editProjectFile()
{
    if (!mProjectFile) {
        QMessageBox msg(QMessageBox::Critical,
                        tr(""Cppcheck""),
                        tr(""No project file loaded""),
                        QMessageBox::Ok,
                        this);
        msg.exec();
        return;
    }

    ProjectFileDialog dlg(mProjectFile, isCppcheckPremium(), this);
    if (dlg.exec() == QDialog::Accepted) {
        mProjectFile->write();
        analyzeProject(mProjectFile, QStringList());
    }
}",1,1,gui/mainwindow.cpp,MainWindow.editProjectFile:void(),<empty>,,false,2024,2041,editProjectFile,,,1,void()
111669150511,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::showStatistics()
{
    StatsDialog statsDialog(this);

    // Show a dialog with the previous scan statistics and project information
    statsDialog.setProject(mProjectFile);
    statsDialog.setPathSelected(mCurrentDirectory);
    statsDialog.setNumberOfFilesScanned(mThread->getPreviousFilesCount());
    statsDialog.setScanDuration(mThread->getPreviousScanDuration() / 1000.0);
    statsDialog.setStatistics(mUI->mResults->getStatistics());

    statsDialog.exec();
}",1,1,gui/mainwindow.cpp,MainWindow.showStatistics:void(),<empty>,,false,2043,2055,showStatistics,,,1,void()
111669150512,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::showLibraryEditor()
{
    LibraryDialog libraryDialog(this);
    libraryDialog.exec();
}",1,1,gui/mainwindow.cpp,MainWindow.showLibraryEditor:void(),<empty>,,false,2057,2061,showLibraryEditor,,,1,void()
111669150513,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::filterResults()
{
    mUI->mResults->filterResults(mLineEditFilter->text());
}",1,1,gui/mainwindow.cpp,MainWindow.filterResults:void(),<empty>,,false,2063,2066,filterResults,,,1,void()
111669150514,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::enableProjectActions(bool enable)
{
    mUI->mActionCloseProjectFile->setEnabled(enable);
    mUI->mActionEditProjectFile->setEnabled(enable);
    mUI->mActionCheckLibrary->setEnabled(enable);
    mUI->mActionCheckConfiguration->setEnabled(enable);
}",1,1,gui/mainwindow.cpp,MainWindow.enableProjectActions:void(bool),<empty>,,false,2068,2074,enableProjectActions,,,1,void(bool)
111669150515,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::enableProjectOpenActions(bool enable)
{
    mUI->mActionNewProjectFile->setEnabled(enable);
    mUI->mActionOpenProjectFile->setEnabled(enable);
}",1,1,gui/mainwindow.cpp,MainWindow.enableProjectOpenActions:void(bool),<empty>,,false,2076,2080,enableProjectOpenActions,,,1,void(bool)
111669150516,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::openRecentProject()
{
    auto *action = qobject_cast<QAction *>(sender());
    if (!action)
        return;
    const QString project = action->data().toString();
    QFileInfo inf(project);
    if (inf.exists()) {
        if (inf.suffix() == ""xml"")
            loadResults(project);
        else {
            loadProjectFile(project);
            loadLastResults();
        }
    } else {
        const QString text(tr(""The project file\\n\\n%1\\n\\n could not be found!\\n\\n""
                              ""Do you want to remove the file from the recently ""
                              ""used projects -list?"").arg(project));

        QMessageBox msg(QMessageBox::Warning,
                        tr(""Cppcheck""),
                        text,
                        QMessageBox::Yes | QMessageBox::No,
                        this);

        msg.setDefaultButton(QMessageBox::No);
        const int rv = msg.exec();
        if (rv == QMessageBox::Yes) {
            removeProject...",1,1,gui/mainwindow.cpp,MainWindow.openRecentProject:void(),<empty>,,false,2082,2113,openRecentProject,,,1,void()
111669150517,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::updateMRUMenuItems()
{
    for (QAction* recentProjectAct : mRecentProjectActs) {
        if (recentProjectAct != nullptr)
            mUI->mMenuFile->removeAction(recentProjectAct);
    }

    QStringList projects = mSettings->value(SETTINGS_MRU_PROJECTS).toStringList();

    // Do a sanity check - remove duplicates and non-existing projects
    int removed = projects.removeDuplicates();
    for (int i = projects.size() - 1; i >= 0; i--) {
        if (!QFileInfo::exists(projects[i])) {
            projects.removeAt(i);
            removed++;
        }
    }

    if (removed)
        mSettings->setValue(SETTINGS_MRU_PROJECTS, projects);

    const int numRecentProjects = qMin(projects.size(), (int)MaxRecentProjects);
    for (int i = 0; i < numRecentProjects; i++) {
        const QString filename = QFileInfo(projects[i]).fileName();
        const QString text = QString(""&%1 %2"").arg(i + 1).arg(filename);
        mRecentProjectActs[i]->setText(text);
        mRecentP...",1,44,gui/mainwindow.cpp,MainWindow.updateMRUMenuItems:void(),<empty>,,false,2115,2148,updateMRUMenuItems,,,1,void()
111669150518,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::addProjectMRU(const QString &project)
{
    QStringList files = mSettings->value(SETTINGS_MRU_PROJECTS).toStringList();
    files.removeAll(project);
    files.prepend(project);
    while (files.size() > MaxRecentProjects)
        files.removeLast();

    mSettings->setValue(SETTINGS_MRU_PROJECTS, files);
    updateMRUMenuItems();
}",1,41,gui/mainwindow.cpp,MainWindow.addProjectMRU:void(QString&),<empty>,,false,2150,2160,addProjectMRU,,,1,void(QString&)
111669150519,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::removeProjectMRU(const QString &project)
{
    QStringList files = mSettings->value(SETTINGS_MRU_PROJECTS).toStringList();
    files.removeAll(project);

    mSettings->setValue(SETTINGS_MRU_PROJECTS, files);
    updateMRUMenuItems();
}",1,41,gui/mainwindow.cpp,MainWindow.removeProjectMRU:void(QString&),<empty>,,false,2162,2169,removeProjectMRU,,,1,void(QString&)
111669150520,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::selectPlatform()
{
    auto *action = qobject_cast<QAction *>(sender());
    if (action) {
        const Platform::Type platform = (Platform::Type) action->data().toInt();
        mSettings->setValue(SETTINGS_CHECKED_PLATFORM, platform);
    }
}",1,28,gui/mainwindow.cpp,MainWindow.selectPlatform:void(),<empty>,,false,2171,2178,selectPlatform,,,1,void()
111669150521,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::suppressIds(QStringList ids)
{
    if (!mProjectFile)
        return;
    ids.removeDuplicates();

    QList<SuppressionList::Suppression> suppressions = mProjectFile->getSuppressions();
    for (const QString& id : ids) {
        // Remove all matching suppressions
        std::string id2 = id.toStdString();
        for (int i = 0; i < suppressions.size();) {
            if (suppressions[i].errorId == id2)
                suppressions.removeAt(i);
            else
                ++i;
        }

        SuppressionList::Suppression newSuppression;
        newSuppression.errorId = id2;
        suppressions << newSuppression;
    }

    mProjectFile->setSuppressions(suppressions);
    mProjectFile->write();
}",1,1,gui/mainwindow.cpp,MainWindow.suppressIds:void(QStringList),<empty>,,false,2180,2204,suppressIds,,,1,void(QStringList)
111669150522,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"static int getVersion(const QString& nameWithVersion) {
    int ret = 0;
    int v = 0;
    int dot = 0;
    for (const auto c: nameWithVersion) {
        if (c == '\\n' || c == '\\r')
            break;
        if (c == ' ') {
            if (ret > 0 && dot == 1 && nameWithVersion.endsWith("" dev""))
                return (ret * 1000000) + (v * 1000) + 500;
            dot = ret = v = 0;
        }
        else if (c == '.') {
            ++dot;
            ret = ret * 1000 + v;
            v = 0;
        } else if (c >= '0' && c <= '9')
            v = v * 10 + (c.toLatin1() - '0');
    }
    ret = ret * 1000 + v;
    while (dot < 2) {
        ++dot;
        ret *= 1000;
    }
    return ret;
}",1,1,gui/mainwindow.cpp,getVersion:int(QString&),<empty>,,false,2206,2231,getVersion,,,1,int(QString&)
111669150523,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::replyFinished(QNetworkReply *reply) {
    reply->deleteLater();
    if (reply->error()) {
        mUI->mLayoutInformation->deleteLater();
        qDebug() << ""Response: ERROR"";
        return;
    }
    const QString str = reply->readAll();
    qDebug() << ""Response: "" << str;
    if (reply->url().fileName() == ""version.txt"") {
        QString nameWithVersion = QString(""Cppcheck %1"").arg(CppCheck::version());
        if (!mCppcheckCfgProductName.isEmpty())
            nameWithVersion = mCppcheckCfgProductName;
        const int appVersion = getVersion(nameWithVersion);
        const int latestVersion = getVersion(str.trimmed());
        if (appVersion < latestVersion) {
            if (mSettings->value(SETTINGS_CHECK_VERSION, 0).toInt() != latestVersion) {
                QString install;
                if (isCppcheckPremium()) {
#ifdef Q_OS_WIN
                    const QString url(""https://cppchecksolutions.com/cppcheck-premium-installation"");
#else
             ...",1,33,gui/mainwindow.cpp,MainWindow.replyFinished:void(QNetworkReply*),<empty>,,false,2233,2268,replyFinished,,,1,void(QNetworkReply*)
111669150524,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::hideInformation() {
    int version = getVersion(mUI->mLabelInformation->text());
    mSettings->setValue(SETTINGS_CHECK_VERSION, version);
    mUI->mLabelInformation->setVisible(false);
    mUI->mButtonHideInformation->setVisible(false);
    mUI->mLayoutInformation->deleteLater();
}",1,24,gui/mainwindow.cpp,MainWindow.hideInformation:void(),<empty>,,false,2270,2276,hideInformation,,,1,void()
111669150525,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"bool MainWindow::isCppcheckPremium() const {
    return mCppcheckCfgProductName.startsWith(""Cppcheck Premium "");
}",1,1,gui/mainwindow.cpp,MainWindow.isCppcheckPremium<const>:bool(),<empty>,,false,2278,2280,isCppcheckPremium,,,1,bool()
111669150526,METHOD,<empty>,<empty>,"[](QAction* a, const QString& s) {
        a->setVisible(!s.isEmpty());
        a->setText(s);
        a->setToolTip(s);
    }",27,5,gui/mainwindow.cpp,"gui/mainwindow.cpp:<global>.MainWindow.changeReportType.<lambda>3:void(QAction*,QString&)",<empty>,,false,2293,2297,<lambda>3,,,1,"void(QAction*,QString&)"
111669150527,METHOD,gui/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::changeReportType() {
    const ReportType reportType = mUI->mActionReportAutosar->isChecked() ? ReportType::autosar :
                                  mUI->mActionReportCertC->isChecked() ? ReportType::certC :
                                  mUI->mActionReportCertCpp->isChecked() ? ReportType::certCpp :
                                  mUI->mActionReportMisraC->isChecked() ? ReportType::misraC :
                                  mUI->mActionReportMisraCpp2008->isChecked() ? ReportType::misraCpp2008 :
                                  mUI->mActionReportMisraCpp2023->isChecked() ? ReportType::misraCpp2023 :
                                  ReportType::normal;

    mUI->mResults->setReportType(reportType);

    auto setTextAndHint = [](QAction* a, const QString& s) {
        a->setVisible(!s.isEmpty());
        a->setText(s);
        a->setToolTip(s);
    };

    const QString showMandatory = tr(""Show Mandatory"");
    const QString showRequired = tr(""Show Required...",1,1,gui/mainwindow.cpp,MainWindow.changeReportType:void(),<empty>,,false,2282,2333,changeReportType,,,1,void()
111669150528,METHOD,gui/mainwindow.h:<global>,TYPE_DECL,<global>,1,1,gui/mainwindow.h,gui/mainwindow.h:<global>,<empty>,,false,1,490,<global>,,,1,
111669150529,METHOD,gui/newsuppressiondialog.cpp:<global>,TYPE_DECL,"NewSuppressionDialog::NewSuppressionDialog(QWidget *parent) :
    QDialog(parent),
    mUI(new Ui::NewSuppressionDialog)
{
    mUI->setupUi(this);

    class QErrorLogger : public ErrorLogger {
    public:
        void reportOut(const std::string & /*outmsg*/, Color /*c*/) override {}
        void reportErr(const ErrorMessage &msg) override {
            errorIds << QString::fromStdString(msg.id);
        }
        QStringList errorIds;
    };

    QErrorLogger errorLogger;
    CppCheck::getErrorMessages(errorLogger);
    errorLogger.errorIds.sort();

    mUI->mComboErrorId->addItems(errorLogger.errorIds);
    mUI->mComboErrorId->setCurrentIndex(-1);
    mUI->mComboErrorId->setCurrentText("""");
}",1,1,gui/newsuppressiondialog.cpp,NewSuppressionDialog.NewSuppressionDialog:ANY(QWidget*),<empty>,,false,36,58,NewSuppressionDialog,,,1,NewSuppressionDialog.NewSuppressionDialog:ANY(QWidget*)(QWidget*)
111669150530,METHOD,gui/newsuppressiondialog.cpp:<global>,TYPE_DECL,<global>,1,1,gui/newsuppressiondialog.cpp,gui/newsuppressiondialog.cpp:<global>,<empty>,,false,1,85,<global>,,,1,
111669150531,METHOD,gui/newsuppressiondialog.cpp:<global>,TYPE_DECL,"NewSuppressionDialog::~NewSuppressionDialog()
{
    delete mUI;
}",1,1,gui/newsuppressiondialog.cpp,NewSuppressionDialog.~NewSuppressionDialog:ANY(),<empty>,,false,60,63,~NewSuppressionDialog,,,1,ANY()
111669150532,METHOD,gui/newsuppressiondialog.cpp:<global>,TYPE_DECL,"SuppressionList::Suppression NewSuppressionDialog::getSuppression() const
{
    SuppressionList::Suppression ret;
    ret.errorId = mUI->mComboErrorId->currentText().toStdString();
    if (ret.errorId.empty())
        ret.errorId = ""*"";
    ret.fileName = mUI->mTextFileName->text().toStdString();
    if (!mUI->mTextLineNumber->text().isEmpty())
        ret.lineNumber = mUI->mTextLineNumber->text().toInt();
    ret.symbolName = mUI->mTextSymbolName->text().toStdString();
    return ret;
}",1,1,gui/newsuppressiondialog.cpp,NewSuppressionDialog.getSuppression<const>:SuppressionList.Suppression(),<empty>,,false,65,76,getSuppression,,,1,SuppressionList.Suppression()
111669150533,METHOD,gui/newsuppressiondialog.cpp:<global>,TYPE_DECL,"void NewSuppressionDialog::setSuppression(const SuppressionList::Suppression &suppression)
{
    setWindowTitle(tr(""Edit suppression""));
    mUI->mComboErrorId->setCurrentText(QString::fromStdString(suppression.errorId));
    mUI->mTextFileName->setText(QString::fromStdString(suppression.fileName));
    mUI->mTextLineNumber->setText(suppression.lineNumber > 0 ? QString::number(suppression.lineNumber) : QString());
    mUI->mTextSymbolName->setText(QString::fromStdString(suppression.symbolName));
}",1,1,gui/newsuppressiondialog.cpp,NewSuppressionDialog.setSuppression:void(SuppressionList.Suppression&),<empty>,,false,78,85,setSuppression,,,1,void(SuppressionList.Suppression&)
111669150534,METHOD,gui/newsuppressiondialog.h:<global>,TYPE_DECL,<global>,1,1,gui/newsuppressiondialog.h,gui/newsuppressiondialog.h:<global>,<empty>,,false,1,58,<global>,,,1,
111669150535,METHOD,gui/platforms.cpp:<global>,TYPE_DECL,"Platforms::Platforms(QObject *parent)
    : QObject(parent)
{
    init();
}",1,1,gui/platforms.cpp,Platforms.Platforms:ANY(QObject*),<empty>,,false,21,25,Platforms,,,1,Platforms.Platforms:ANY(QObject*)(QObject*)
111669150536,METHOD,gui/platforms.cpp:<global>,TYPE_DECL,<global>,1,1,gui/platforms.cpp,gui/platforms.cpp:<global>,<empty>,,false,1,61,<global>,,,1,
111669150537,METHOD,gui/platforms.cpp:<global>,TYPE_DECL,"void Platforms::add(const QString &title, Platform::Type platform)
{
    PlatformData plat;
    plat.mTitle = title;
    plat.mType = platform;
    plat.mActMainWindow = nullptr;
    mPlatforms << plat;
}",1,1,gui/platforms.cpp,"Platforms.add:void(QString&,Platform.Type)",<empty>,,false,27,34,add,,,1,"void(QString&,Platform.Type)"
111669150538,METHOD,gui/platforms.cpp:<global>,TYPE_DECL,"void Platforms::init()
{
    add(tr(""Native""), Platform::Type::Native);
    add(tr(""Unix 32-bit""), Platform::Type::Unix32);
    add(tr(""Unix 64-bit""), Platform::Type::Unix64);
    add(tr(""Windows 32-bit ANSI""), Platform::Type::Win32A);
    add(tr(""Windows 32-bit Unicode""), Platform::Type::Win32W);
    add(tr(""Windows 64-bit""), Platform::Type::Win64);
}",1,1,gui/platforms.cpp,Platforms.init:void(),<empty>,,false,36,44,init,,,1,void()
111669150539,METHOD,gui/platforms.cpp:<global>,TYPE_DECL,"int Platforms::getCount() const
{
    return mPlatforms.count();
}",1,1,gui/platforms.cpp,Platforms.getCount<const>:int(),<empty>,,false,46,49,getCount,,,1,int()
111669150540,METHOD,gui/platforms.cpp:<global>,TYPE_DECL,"PlatformData& Platforms::get(Platform::Type platform)
{
    auto iter = mPlatforms.begin();
    while (iter != mPlatforms.end()) {
        if (iter->mType == platform) {
            return *iter;
        }
        ++iter;
    }
    return mPlatforms.first();
}",1,1,gui/platforms.cpp,Platforms.get:PlatformData&(Platform.Type),<empty>,,false,51,61,get,,,1,PlatformData&(Platform.Type)
111669150541,METHOD,gui/platforms.h:<global>,TYPE_DECL,<global>,1,1,gui/platforms.h,gui/platforms.h:<global>,<empty>,,false,1,59,<global>,,,1,
111669150542,METHOD,gui/precompiled.h:<global>,TYPE_DECL,<global>,1,27,gui/precompiled.h,gui/precompiled.h:<global>,<empty>,,false,1,33,<global>,,,1,
111669150543,METHOD,gui/precompiled_qmake.h:<global>,TYPE_DECL,<global>,1,13,gui/precompiled_qmake.h,gui/precompiled_qmake.h:<global>,<empty>,,false,1,23,<global>,,,1,
111669150544,METHOD,gui/printablereport.cpp:<global>,TYPE_DECL,"PrintableReport::PrintableReport() :
    Report(QString())
{}",1,2,gui/printablereport.cpp,PrintableReport.PrintableReport:ANY(),<empty>,,false,26,28,PrintableReport,,,1,PrintableReport.PrintableReport:ANY()()
111669150545,METHOD,gui/printablereport.cpp:<global>,TYPE_DECL,<global>,1,1,gui/printablereport.cpp,gui/printablereport.cpp:<global>,<empty>,,false,1,58,<global>,,,1,
111669150546,METHOD,gui/printablereport.cpp:<global>,TYPE_DECL,"bool PrintableReport::create()
{
    return true;
}",1,1,gui/printablereport.cpp,PrintableReport.create:bool(),<empty>,,false,30,33,create,,,1,bool()
111669150547,METHOD,gui/printablereport.cpp:<global>,TYPE_DECL,"void PrintableReport::writeHeader()
{
    // No header for printable report
}",1,1,gui/printablereport.cpp,PrintableReport.writeHeader:void(),<empty>,,false,35,38,writeHeader,,,1,void()
111669150548,METHOD,gui/printablereport.cpp:<global>,TYPE_DECL,"void PrintableReport::writeFooter()
{
    // No footer for printable report
}",1,1,gui/printablereport.cpp,PrintableReport.writeFooter:void(),<empty>,,false,40,43,writeFooter,,,1,void()
111669150549,METHOD,gui/printablereport.cpp:<global>,TYPE_DECL,"void PrintableReport::writeError(const ErrorItem &error)
{
    const QString file = QDir::toNativeSeparators(error.errorPath.back().file);
    QString line = QString(""%1,%2,"").arg(file).arg(error.errorPath.back().line);
    line += QString(""%1,%2"").arg(GuiSeverity::toString(error.severity)).arg(error.summary);

    mFormattedReport += line;
    mFormattedReport += ""\\n"";
}",1,1,gui/printablereport.cpp,PrintableReport.writeError:void(ErrorItem&),<empty>,,false,45,53,writeError,,,1,void(ErrorItem&)
111669150550,METHOD,gui/printablereport.cpp:<global>,TYPE_DECL,"const QString& PrintableReport::getFormattedReportText() const
{
    return mFormattedReport;
}",1,1,gui/printablereport.cpp,PrintableReport.getFormattedReportText<const>:ANY(),<empty>,,false,55,58,getFormattedReportText,,,1,ANY()
111669150551,METHOD,gui/printablereport.h:<global>,TYPE_DECL,<global>,1,1,gui/printablereport.h,gui/printablereport.h:<global>,<empty>,,false,1,73,<global>,,,1,
111669150552,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"ProjectFile::ProjectFile(QObject *parent) :
    QObject(parent)
{
    clear();
}",1,1,gui/projectfile.cpp,ProjectFile.ProjectFile:ANY(QObject*),<empty>,,false,44,48,ProjectFile,,,1,ProjectFile.ProjectFile:ANY(QObject*)(QObject*)
111669150553,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,<global>,1,1,gui/projectfile.cpp,gui/projectfile.cpp:<global>,<empty>,,false,1,1182,<global>,,,1,
111669150554,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"ProjectFile::ProjectFile(QString filename, QObject *parent) :
    QObject(parent),
    mFilename(std::move(filename))
{
    clear();
    read();
}",1,1,gui/projectfile.cpp,"ProjectFile.ProjectFile:ANY(QString,QObject*)",<empty>,,false,50,56,ProjectFile,,,1,"ProjectFile.ProjectFile:ANY(QString,QObject*)(QString,QObject*)"
111669150555,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::clear()
{
    const Settings settings;
    clangParser = false;
    mCheckLevel = CheckLevel::normal;
    mRootPath.clear();
    mBuildDir.clear();
    mImportProject.clear();
    mIncludeDirs.clear();
    mDefines.clear();
    mUndefines.clear();
    mPaths.clear();
    mExcludedPaths.clear();
    mLibraries.clear();
    mPlatform.clear();
    mProjectName.clear();
    mSuppressions.clear();
    mAddons.clear();
    mClangAnalyzer = mClangTidy = false;
    mAnalyzeAllVsConfigs = false;
    mCheckHeaders = true;
    mCheckUnusedTemplates = true;
    mInlineSuppression = true;
    mMaxCtuDepth = settings.maxCtuDepth;
    mMaxTemplateRecursion = settings.maxTemplateRecursion;
    mCheckUnknownFunctionReturn.clear();
    safeChecks.clear();
    mVsConfigurations.clear();
    mTags.clear();
    mWarningTags.clear();

    // Premium
    mBughunting = false;
    mCertIntPrecision = 0;
    mCodingStandards.clear();
    mPremiumLicenseFile.clear();
}",1,1,gui/projectfile.cpp,ProjectFile.clear:void(),<empty>,,false,58,94,clear,,,1,void()
111669150556,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"bool ProjectFile::read(const QString &filename)
{
    if (!filename.isEmpty())
        mFilename = filename;

    QFile file(mFilename);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
        return false;

    clear();

    QXmlStreamReader xmlReader(&file);
    bool insideProject = false;
    bool projectTagFound = false;
    while (!xmlReader.atEnd()) {
        switch (xmlReader.readNext()) {
        case QXmlStreamReader::StartElement:
            if (xmlReader.name() == QString(CppcheckXml::ProjectElementName)) {
                insideProject = true;
                projectTagFound = true;
                break;
            }
            if (!insideProject)
                break;

            // Read root path from inside project element
            if (xmlReader.name() == QString(CppcheckXml::RootPathName))
                readRootPath(xmlReader);

            // Read root path from inside project element
            if (xmlReader.name() == QString(CppcheckXml::Bui...",1,48,gui/projectfile.cpp,ProjectFile.read:bool(QString&),<empty>,,false,96,263,read,,,1,bool(QString&)
111669150557,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::readRootPath(const QXmlStreamReader &reader)
{
    QXmlStreamAttributes attribs = reader.attributes();
    QString name = attribs.value(QString(), CppcheckXml::RootPathNameAttrib).toString();
    if (!name.isEmpty())
        mRootPath = name;
}",1,1,gui/projectfile.cpp,ProjectFile.readRootPath:void(QXmlStreamReader&),<empty>,,false,265,271,readRootPath,,,1,void(QXmlStreamReader&)
111669150558,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::readBuildDir(QXmlStreamReader &reader)
{
    mBuildDir.clear();
    do {
        const QXmlStreamReader::TokenType type = reader.readNext();
        switch (type) {
        case QXmlStreamReader::Characters:
            mBuildDir = reader.text().toString();
            FALLTHROUGH;
        case QXmlStreamReader::EndElement:
            return;
        // Not handled
        case QXmlStreamReader::StartElement:
        case QXmlStreamReader::NoToken:
        case QXmlStreamReader::Invalid:
        case QXmlStreamReader::StartDocument:
        case QXmlStreamReader::EndDocument:
        case QXmlStreamReader::Comment:
        case QXmlStreamReader::DTD:
        case QXmlStreamReader::EntityReference:
        case QXmlStreamReader::ProcessingInstruction:
            break;
        }
    } while (true);
}",1,12,gui/projectfile.cpp,ProjectFile.readBuildDir:void(QXmlStreamReader&),<empty>,,false,273,297,readBuildDir,,,1,void(QXmlStreamReader&)
111669150559,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::readImportProject(QXmlStreamReader &reader)
{
    mImportProject.clear();
    do {
        const QXmlStreamReader::TokenType type = reader.readNext();
        switch (type) {
        case QXmlStreamReader::Characters:
            mImportProject = reader.text().toString();
            FALLTHROUGH;
        case QXmlStreamReader::EndElement:
            return;
        // Not handled
        case QXmlStreamReader::StartElement:
        case QXmlStreamReader::NoToken:
        case QXmlStreamReader::Invalid:
        case QXmlStreamReader::StartDocument:
        case QXmlStreamReader::EndDocument:
        case QXmlStreamReader::Comment:
        case QXmlStreamReader::DTD:
        case QXmlStreamReader::EntityReference:
        case QXmlStreamReader::ProcessingInstruction:
            break;
        }
    } while (true);
}",1,12,gui/projectfile.cpp,ProjectFile.readImportProject:void(QXmlStreamReader&),<empty>,,false,299,323,readImportProject,,,1,void(QXmlStreamReader&)
111669150560,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"bool ProjectFile::readBool(QXmlStreamReader &reader)
{
    bool ret = false;
    do {
        const QXmlStreamReader::TokenType type = reader.readNext();
        switch (type) {
        case QXmlStreamReader::Characters:
            ret = (reader.text().toString() == ""true"");
            FALLTHROUGH;
        case QXmlStreamReader::EndElement:
            return ret;
        // Not handled
        case QXmlStreamReader::StartElement:
        case QXmlStreamReader::NoToken:
        case QXmlStreamReader::Invalid:
        case QXmlStreamReader::StartDocument:
        case QXmlStreamReader::EndDocument:
        case QXmlStreamReader::Comment:
        case QXmlStreamReader::DTD:
        case QXmlStreamReader::EntityReference:
        case QXmlStreamReader::ProcessingInstruction:
            break;
        }
    } while (true);
}",1,12,gui/projectfile.cpp,ProjectFile.readBool:bool(QXmlStreamReader&),<empty>,,false,325,349,readBool,,,1,bool(QXmlStreamReader&)
111669150561,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"int ProjectFile::readInt(QXmlStreamReader &reader, int defaultValue)
{
    int ret = defaultValue;
    do {
        const QXmlStreamReader::TokenType type = reader.readNext();
        switch (type) {
        case QXmlStreamReader::Characters:
            ret = reader.text().toString().toInt();
            FALLTHROUGH;
        case QXmlStreamReader::EndElement:
            return ret;
        // Not handled
        case QXmlStreamReader::StartElement:
        case QXmlStreamReader::NoToken:
        case QXmlStreamReader::Invalid:
        case QXmlStreamReader::StartDocument:
        case QXmlStreamReader::EndDocument:
        case QXmlStreamReader::Comment:
        case QXmlStreamReader::DTD:
        case QXmlStreamReader::EntityReference:
        case QXmlStreamReader::ProcessingInstruction:
            break;
        }
    } while (true);
}",1,12,gui/projectfile.cpp,"ProjectFile.readInt:int(QXmlStreamReader&,int)",<empty>,,false,351,375,readInt,,,1,"int(QXmlStreamReader&,int)"
111669150562,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"QString ProjectFile::readString(QXmlStreamReader &reader)
{
    QString ret;
    do {
        const QXmlStreamReader::TokenType type = reader.readNext();
        switch (type) {
        case QXmlStreamReader::Characters:
            ret = reader.text().toString();
            FALLTHROUGH;
        case QXmlStreamReader::EndElement:
            return ret;
        // Not handled
        case QXmlStreamReader::StartElement:
        case QXmlStreamReader::NoToken:
        case QXmlStreamReader::Invalid:
        case QXmlStreamReader::StartDocument:
        case QXmlStreamReader::EndDocument:
        case QXmlStreamReader::Comment:
        case QXmlStreamReader::DTD:
        case QXmlStreamReader::EntityReference:
        case QXmlStreamReader::ProcessingInstruction:
            break;
        }
    } while (true);
}",1,12,gui/projectfile.cpp,ProjectFile.readString:QString(QXmlStreamReader&),<empty>,,false,377,401,readString,,,1,QString(QXmlStreamReader&)
111669150563,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::readIncludeDirs(QXmlStreamReader &reader)
{
    bool allRead = false;
    do {
        QXmlStreamReader::TokenType type = reader.readNext();
        switch (type) {
        case QXmlStreamReader::StartElement:

            // Read dir-elements
            if (reader.name().toString() == CppcheckXml::DirElementName) {
                QXmlStreamAttributes attribs = reader.attributes();
                QString name = attribs.value(QString(), CppcheckXml::DirNameAttrib).toString();
                if (!name.isEmpty())
                    mIncludeDirs << name;
            }
            break;

        case QXmlStreamReader::EndElement:
            if (reader.name().toString() == CppcheckXml::IncludeDirElementName)
                allRead = true;
            break;

        // Not handled
        case QXmlStreamReader::NoToken:
        case QXmlStreamReader::Invalid:
        case QXmlStreamReader::StartDocument:
        case QXmlStreamReader::EndDocument:
        case QX...",1,1,gui/projectfile.cpp,ProjectFile.readIncludeDirs:void(QXmlStreamReader&),<empty>,,false,403,438,readIncludeDirs,,,1,void(QXmlStreamReader&)
111669150564,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::readDefines(QXmlStreamReader &reader)
{
    bool allRead = false;
    do {
        QXmlStreamReader::TokenType type = reader.readNext();
        switch (type) {
        case QXmlStreamReader::StartElement:
            // Read define-elements
            if (reader.name().toString() == CppcheckXml::DefineName) {
                QXmlStreamAttributes attribs = reader.attributes();
                QString name = attribs.value(QString(), CppcheckXml::DefineNameAttrib).toString();
                if (!name.isEmpty())
                    mDefines << name;
            }
            break;

        case QXmlStreamReader::EndElement:
            if (reader.name().toString() == CppcheckXml::DefinesElementName)
                allRead = true;
            break;

        // Not handled
        case QXmlStreamReader::NoToken:
        case QXmlStreamReader::Invalid:
        case QXmlStreamReader::StartDocument:
        case QXmlStreamReader::EndDocument:
        case QXmlStreamRe...",1,1,gui/projectfile.cpp,ProjectFile.readDefines:void(QXmlStreamReader&),<empty>,,false,440,474,readDefines,,,1,void(QXmlStreamReader&)
111669150565,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::readCheckPaths(QXmlStreamReader &reader)
{
    bool allRead = false;
    do {
        QXmlStreamReader::TokenType type = reader.readNext();
        switch (type) {
        case QXmlStreamReader::StartElement:

            // Read dir-elements
            if (reader.name().toString() == CppcheckXml::PathName) {
                QXmlStreamAttributes attribs = reader.attributes();
                QString name = attribs.value(QString(), CppcheckXml::PathNameAttrib).toString();
                if (!name.isEmpty())
                    mPaths << name;
            }
            break;

        case QXmlStreamReader::EndElement:
            if (reader.name().toString() == CppcheckXml::PathsElementName)
                allRead = true;
            break;

        // Not handled
        case QXmlStreamReader::NoToken:
        case QXmlStreamReader::Invalid:
        case QXmlStreamReader::StartDocument:
        case QXmlStreamReader::EndDocument:
        case QXmlStreamReader::C...",1,1,gui/projectfile.cpp,ProjectFile.readCheckPaths:void(QXmlStreamReader&),<empty>,,false,476,511,readCheckPaths,,,1,void(QXmlStreamReader&)
111669150566,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::readExcludes(QXmlStreamReader &reader)
{
    bool allRead = false;
    do {
        QXmlStreamReader::TokenType type = reader.readNext();
        switch (type) {
        case QXmlStreamReader::StartElement:
            // Read exclude-elements
            if (reader.name().toString() == CppcheckXml::ExcludePathName) {
                QXmlStreamAttributes attribs = reader.attributes();
                QString name = attribs.value(QString(), CppcheckXml::ExcludePathNameAttrib).toString();
                if (!name.isEmpty())
                    mExcludedPaths << name;
            }
            // Read ignore-elements - deprecated but support reading them
            else if (reader.name().toString() == CppcheckXml::IgnorePathName) {
                QXmlStreamAttributes attribs = reader.attributes();
                QString name = attribs.value(QString(), CppcheckXml::IgnorePathNameAttrib).toString();
                if (!name.isEmpty())
                    mExcludedP...",1,1,gui/projectfile.cpp,ProjectFile.readExcludes:void(QXmlStreamReader&),<empty>,,false,513,556,readExcludes,,,1,void(QXmlStreamReader&)
111669150567,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::readVsConfigurations(QXmlStreamReader &reader)
{
    do {
        QXmlStreamReader::TokenType type = reader.readNext();
        switch (type) {
        case QXmlStreamReader::StartElement:
            // Read library-elements
            if (reader.name().toString() == CppcheckXml::VSConfigurationName) {
                QString config;
                type = reader.readNext();
                if (type == QXmlStreamReader::Characters) {
                    config = reader.text().toString();
                }
                mVsConfigurations << config;
            }
            break;

        case QXmlStreamReader::EndElement:
            if (reader.name().toString() != CppcheckXml::VSConfigurationName)
                return;
            break;

        // Not handled
        case QXmlStreamReader::NoToken:
        case QXmlStreamReader::Invalid:
        case QXmlStreamReader::StartDocument:
        case QXmlStreamReader::EndDocument:
        case QXmlStreamReader...",1,1,gui/projectfile.cpp,ProjectFile.readVsConfigurations:void(QXmlStreamReader&),<empty>,,false,558,593,readVsConfigurations,,,1,void(QXmlStreamReader&)
111669150568,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::readPlatform(QXmlStreamReader &reader)
{
    do {
        const QXmlStreamReader::TokenType type = reader.readNext();
        switch (type) {
        case QXmlStreamReader::Characters:
            mPlatform = reader.text().toString();
            FALLTHROUGH;
        case QXmlStreamReader::EndElement:
            return;
        // Not handled
        case QXmlStreamReader::StartElement:
        case QXmlStreamReader::NoToken:
        case QXmlStreamReader::Invalid:
        case QXmlStreamReader::StartDocument:
        case QXmlStreamReader::EndDocument:
        case QXmlStreamReader::Comment:
        case QXmlStreamReader::DTD:
        case QXmlStreamReader::EntityReference:
        case QXmlStreamReader::ProcessingInstruction:
            break;
        }
    } while (true);
}",1,12,gui/projectfile.cpp,ProjectFile.readPlatform:void(QXmlStreamReader&),<empty>,,false,595,618,readPlatform,,,1,void(QXmlStreamReader&)
111669150569,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::readSuppressions(QXmlStreamReader &reader)
{
    do {
        QXmlStreamReader::TokenType type = reader.readNext();
        switch (type) {
        case QXmlStreamReader::StartElement:
            // Read library-elements
            if (reader.name().toString() == CppcheckXml::SuppressionElementName) {
                SuppressionList::Suppression suppression;
                if (reader.attributes().hasAttribute(QString(),""fileName""))
                    suppression.fileName = reader.attributes().value(QString(),""fileName"").toString().toStdString();
                if (reader.attributes().hasAttribute(QString(),""lineNumber""))
                    suppression.lineNumber = reader.attributes().value(QString(),""lineNumber"").toInt();
                if (reader.attributes().hasAttribute(QString(),""symbolName""))
                    suppression.symbolName = reader.attributes().value(QString(),""symbolName"").toString().toStdString();
                if (reader.attributes().ha...",1,1,gui/projectfile.cpp,ProjectFile.readSuppressions:void(QXmlStreamReader&),<empty>,,false,621,664,readSuppressions,,,1,void(QXmlStreamReader&)
111669150570,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::readTagWarnings(QXmlStreamReader &reader, const QString &tag)
{
    do {
        QXmlStreamReader::TokenType type = reader.readNext();
        switch (type) {
        case QXmlStreamReader::StartElement:
            // Read library-elements
            if (reader.name().toString() == CppcheckXml::WarningElementName) {
                const std::size_t hash = reader.attributes().value(QString(), CppcheckXml::HashAttributeName).toULongLong();
                mWarningTags[hash] = tag;
            }
            break;

        case QXmlStreamReader::EndElement:
            if (reader.name().toString() != CppcheckXml::WarningElementName)
                return;
            break;

        // Not handled
        case QXmlStreamReader::NoToken:
        case QXmlStreamReader::Invalid:
        case QXmlStreamReader::StartDocument:
        case QXmlStreamReader::EndDocument:
        case QXmlStreamReader::Characters:
        case QXmlStreamReader::Comment:
        case QXmlS...",1,1,gui/projectfile.cpp,"ProjectFile.readTagWarnings:void(QXmlStreamReader&,QString&)",<empty>,,false,667,698,readTagWarnings,,,1,"void(QXmlStreamReader&,QString&)"
111669150571,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::readStringList(QStringList &stringlist, QXmlStreamReader &reader, const char elementname[])
{
    bool allRead = false;
    do {
        QXmlStreamReader::TokenType type = reader.readNext();
        switch (type) {
        case QXmlStreamReader::StartElement:
            // Read library-elements
            if (reader.name().toString() == elementname) {
                type = reader.readNext();
                if (type == QXmlStreamReader::Characters) {
                    QString text = reader.text().toString();
                    stringlist << text;
                }
            }
            break;

        case QXmlStreamReader::EndElement:
            if (reader.name().toString() != elementname)
                allRead = true;
            break;

        // Not handled
        case QXmlStreamReader::NoToken:
        case QXmlStreamReader::Invalid:
        case QXmlStreamReader::StartDocument:
        case QXmlStreamReader::EndDocument:
        case QXmlStream...",1,1,gui/projectfile.cpp,"ProjectFile.readStringList:void(QStringList&,QXmlStreamReader&,char[])",<empty>,,false,701,736,readStringList,,,1,"void(QStringList&,QXmlStreamReader&,char[])"
111669150572,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::setIncludes(const QStringList &includes)
{
    mIncludeDirs = includes;
}",1,1,gui/projectfile.cpp,ProjectFile.setIncludes:void(QStringList&),<empty>,,false,738,741,setIncludes,,,1,void(QStringList&)
111669150573,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::setDefines(const QStringList &defines)
{
    mDefines = defines;
}",1,1,gui/projectfile.cpp,ProjectFile.setDefines:void(QStringList&),<empty>,,false,743,746,setDefines,,,1,void(QStringList&)
111669150574,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::setUndefines(const QStringList &undefines)
{
    mUndefines = undefines;
}",1,1,gui/projectfile.cpp,ProjectFile.setUndefines:void(QStringList&),<empty>,,false,748,751,setUndefines,,,1,void(QStringList&)
111669150575,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::setCheckPaths(const QStringList &paths)
{
    mPaths = paths;
}",1,1,gui/projectfile.cpp,ProjectFile.setCheckPaths:void(QStringList&),<empty>,,false,753,756,setCheckPaths,,,1,void(QStringList&)
111669150576,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::setExcludedPaths(const QStringList &paths)
{
    mExcludedPaths = paths;
}",1,1,gui/projectfile.cpp,ProjectFile.setExcludedPaths:void(QStringList&),<empty>,,false,758,761,setExcludedPaths,,,1,void(QStringList&)
111669150577,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::setLibraries(const QStringList &libraries)
{
    mLibraries = libraries;
}",1,1,gui/projectfile.cpp,ProjectFile.setLibraries:void(QStringList&),<empty>,,false,763,766,setLibraries,,,1,void(QStringList&)
111669150578,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::setPlatform(const QString &platform)
{
    mPlatform = platform;
}",1,1,gui/projectfile.cpp,ProjectFile.setPlatform:void(QString&),<empty>,,false,768,771,setPlatform,,,1,void(QString&)
111669150579,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"QList<SuppressionList::Suppression> ProjectFile::getCheckingSuppressions() const
{
    const QRegularExpression re1(""^[a-zA-Z0-9_\\\\-]+/.*"");
    const QRegularExpression re2(""^[^/]+$"");
    QList<SuppressionList::Suppression> result;
    for (SuppressionList::Suppression suppression : mSuppressions) {
        if (re1.match(suppression.fileName.c_str()).hasMatch() || re2.match(suppression.fileName.c_str()).hasMatch()) {
            if (suppression.fileName[0] != '*')
                suppression.fileName = QFileInfo(mFilename).absolutePath().toStdString() + ""/"" + suppression.fileName;
        }
        result << suppression;
    }
    return result;
}",1,1,gui/projectfile.cpp,ProjectFile.getCheckingSuppressions<const>:QList<SuppressionList.Suppression>(),<empty>,,false,773,786,getCheckingSuppressions,,,1,QList<SuppressionList::Suppression>()
111669150580,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::setSuppressions(const QList<SuppressionList::Suppression> &suppressions)
{
    mSuppressions = suppressions;
}",1,1,gui/projectfile.cpp,ProjectFile.setSuppressions:void(QList<SuppressionList.Suppression>&),<empty>,,false,788,791,setSuppressions,,,1,void(QList<SuppressionList.Suppression>&)
111669150581,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::addSuppression(const SuppressionList::Suppression &suppression)
{
    mSuppressions.append(suppression);
}",1,1,gui/projectfile.cpp,ProjectFile.addSuppression:void(SuppressionList.Suppression&),<empty>,,false,793,796,addSuppression,,,1,void(SuppressionList.Suppression&)
111669150582,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::setAddons(const QStringList &addons)
{
    mAddons = addons;
}",1,1,gui/projectfile.cpp,ProjectFile.setAddons:void(QStringList&),<empty>,,false,798,801,setAddons,,,1,void(QStringList&)
111669150583,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::setVSConfigurations(const QStringList &vsConfigs)
{
    mVsConfigurations = vsConfigs;
}",1,1,gui/projectfile.cpp,ProjectFile.setVSConfigurations:void(QStringList&),<empty>,,false,803,806,setVSConfigurations,,,1,void(QStringList&)
111669150584,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::setCheckLevel(ProjectFile::CheckLevel checkLevel)
{
    mCheckLevel = checkLevel;
}",1,1,gui/projectfile.cpp,ProjectFile.setCheckLevel:void(ProjectFile.CheckLevel),<empty>,,false,808,811,setCheckLevel,,,1,void(ProjectFile.CheckLevel)
111669150585,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::setWarningTags(std::size_t hash, const QString& tags)
{
    if (tags.isEmpty())
        mWarningTags.erase(hash);
    else if (hash > 0)
        mWarningTags[hash] = tags;
}",1,1,gui/projectfile.cpp,"ProjectFile.setWarningTags:void(std.size_t,QString&)",<empty>,,false,813,819,setWarningTags,,,1,"void(std.size_t,QString&)"
111669150586,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"QString ProjectFile::getWarningTags(std::size_t hash) const
{
    auto it = mWarningTags.find(hash);
    return (it != mWarningTags.end()) ? it->second : QString();
}",1,1,gui/projectfile.cpp,ProjectFile.getWarningTags<const>:QString(std.size_t),<empty>,,false,821,825,getWarningTags,,,1,QString(std.size_t)
111669150587,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"bool ProjectFile::write(const QString &filename)
{
    if (!filename.isEmpty())
        mFilename = filename;

    QFile file(mFilename);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Text))
        return false;

    QXmlStreamWriter xmlWriter(&file);
    xmlWriter.setAutoFormatting(true);
    xmlWriter.writeStartDocument(""1.0"");
    xmlWriter.writeStartElement(CppcheckXml::ProjectElementName);
    xmlWriter.writeAttribute(CppcheckXml::ProjectVersionAttrib, CppcheckXml::ProjectFileVersion);

    if (!mRootPath.isEmpty()) {
        xmlWriter.writeStartElement(CppcheckXml::RootPathName);
        xmlWriter.writeAttribute(CppcheckXml::RootPathNameAttrib, mRootPath);
        xmlWriter.writeEndElement();
    }

    if (!mBuildDir.isEmpty()) {
        xmlWriter.writeStartElement(CppcheckXml::BuildDirElementName);
        xmlWriter.writeCharacters(mBuildDir);
        xmlWriter.writeEndElement();
    }

    if (!mPlatform.isEmpty()) {
        xmlWriter.writeStartElement(CppcheckXml::...",1,17,gui/projectfile.cpp,ProjectFile.write:bool(QString&),<empty>,,false,827,1062,write,,,1,bool(QString&)
111669150588,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::writeStringList(QXmlStreamWriter &xmlWriter, const QStringList &stringlist, const char startelementname[], const char stringelementname[])
{
    if (stringlist.isEmpty())
        return;

    xmlWriter.writeStartElement(startelementname);
    for (const QString& str : stringlist) {
        xmlWriter.writeStartElement(stringelementname);
        xmlWriter.writeCharacters(str);
        xmlWriter.writeEndElement();
    }
    xmlWriter.writeEndElement();
}",1,1,gui/projectfile.cpp,"ProjectFile.writeStringList:void(QXmlStreamWriter&,QStringList&,char[],char[])",<empty>,,false,1064,1076,writeStringList,,,1,"void(QXmlStreamWriter&,QStringList&,char[],char[])"
111669150589,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"QStringList ProjectFile::fromNativeSeparators(const QStringList &paths)
{
    QStringList ret;
    for (const QString &path : paths)
        ret << QDir::fromNativeSeparators(path);
    return ret;
}",1,1,gui/projectfile.cpp,ProjectFile.fromNativeSeparators:QStringList(QStringList&),<empty>,,false,1078,1084,fromNativeSeparators,,,1,QStringList(QStringList&)
111669150590,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"QStringList ProjectFile::getAddonsAndTools() const
{
    QStringList ret(mAddons);
    if (mClangAnalyzer)
        ret << CLANG_ANALYZER;
    if (mClangTidy)
        ret << CLANG_TIDY;
    return ret;
}",1,15,gui/projectfile.cpp,ProjectFile.getAddonsAndTools<const>:QStringList(),<empty>,,false,1086,1094,getAddonsAndTools,,,1,QStringList()
111669150591,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::SafeChecks::loadFromXml(QXmlStreamReader &xmlReader)
{
    classes = externalFunctions = internalFunctions = externalVariables = false;

    int level = 0;

    do {
        const QXmlStreamReader::TokenType type = xmlReader.readNext();
        switch (type) {
        case QXmlStreamReader::StartElement:
            ++level;
            if (xmlReader.name() == QString(Settings::SafeChecks::XmlClasses))
                classes = true;
            else if (xmlReader.name() == QString(Settings::SafeChecks::XmlExternalFunctions))
                externalFunctions = true;
            else if (xmlReader.name() == QString(Settings::SafeChecks::XmlInternalFunctions))
                internalFunctions = true;
            else if (xmlReader.name() == QString(Settings::SafeChecks::XmlExternalVariables))
                externalVariables = true;
            break;
        case QXmlStreamReader::EndElement:
            if (level <= 0)
                return;
            level--...",1,1,gui/projectfile.cpp,ProjectFile.SafeChecks.loadFromXml:void(QXmlStreamReader&),<empty>,,false,1096,1134,loadFromXml,,,1,void(QXmlStreamReader&)
111669150592,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"void ProjectFile::SafeChecks::saveToXml(QXmlStreamWriter &xmlWriter) const
{
    if (!classes && !externalFunctions && !internalFunctions && !externalVariables)
        return;
    xmlWriter.writeStartElement(QString(Settings::SafeChecks::XmlRootName));
    if (classes) {
        xmlWriter.writeStartElement(QString(Settings::SafeChecks::XmlClasses));
        xmlWriter.writeEndElement();
    }
    if (externalFunctions) {
        xmlWriter.writeStartElement(QString(Settings::SafeChecks::XmlExternalFunctions));
        xmlWriter.writeEndElement();
    }
    if (internalFunctions) {
        xmlWriter.writeStartElement(QString(Settings::SafeChecks::XmlInternalFunctions));
        xmlWriter.writeEndElement();
    }
    if (externalVariables) {
        xmlWriter.writeStartElement(QString(Settings::SafeChecks::XmlExternalVariables));
        xmlWriter.writeEndElement();
    }
    xmlWriter.writeEndElement();
}",1,1,gui/projectfile.cpp,ProjectFile.SafeChecks.saveToXml<const>:void(QXmlStreamWriter&),<empty>,,false,1136,1158,saveToXml,,,1,void(QXmlStreamWriter&)
111669150593,METHOD,gui/projectfile.cpp:<global>,TYPE_DECL,"QString ProjectFile::getAddonFilePath(QString filesDir, const QString &addon)
{
    if (QFile(addon).exists())
        return addon;

    if (!filesDir.endsWith(""/""))
        filesDir += ""/"";

    QStringList searchPaths;
    searchPaths << filesDir << (filesDir + ""addons/"") << (filesDir + ""../addons/"")
#ifdef FILESDIR
        << (QLatin1String(FILESDIR) + ""/addons/"")
#endif
    ;

    for (const QString& path : searchPaths) {
        QString f = path + addon + "".py"";
        if (QFile(f).exists())
            return f;
    }

    return QString();
}",1,1,gui/projectfile.cpp,"ProjectFile.getAddonFilePath:QString(QString,QString&)",<empty>,,false,1160,1182,getAddonFilePath,,,1,"QString(QString,QString&)"
111669150594,METHOD,gui/projectfile.h:<global>,TYPE_DECL,<global>,1,1,gui/projectfile.h,gui/projectfile.h:<global>,<empty>,,false,1,676,<global>,,,1,
111669150595,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"static QStringList getPaths(const QListWidget *list)
{
    const int count = list->count();
    QStringList paths;
    for (int i = 0; i < count; i++) {
        QListWidgetItem *item = list->item(i);
        paths << QDir::fromNativeSeparators(item->text());
    }
    return paths;
}",1,1,gui/projectfiledialog.cpp,getPaths:QStringList(QListWidget*),<empty>,,false,71,80,getPaths,,,1,QStringList(QListWidget*)
111669150596,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,<global>,1,1,gui/projectfiledialog.cpp,gui/projectfiledialog.cpp:<global>,<empty>,,false,1,969,<global>,,,1,
111669150597,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"QStringList ProjectFileDialog::getProjectConfigs(const QString &fileName)
{
    if (!fileName.endsWith("".sln"") && !fileName.endsWith("".vcxproj""))
        return QStringList();
    QStringList ret;
    ImportProject importer;
    Settings projSettings;
    Suppressions projSupprs;
    importer.import(fileName.toStdString(), &projSettings, &projSupprs);
    for (const std::string &cfg : importer.getVSConfigs())
        ret << QString::fromStdString(cfg);
    return ret;
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.getProjectConfigs:QStringList(QString&),<empty>,,false,92,104,getProjectConfigs,,,1,QStringList(QString&)
111669150598,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"ProjectFileDialog::ProjectFileDialog(ProjectFile *projectFile, bool premium, QWidget *parent)
    : QDialog(parent)
    , mUI(new Ui::ProjectFile)
    , mProjectFile(projectFile)
    , mPremium(premium)
{
    mUI->setupUi(this);

    mUI->mToolClangAnalyzer->hide();

    const QFileInfo inf(projectFile->getFilename());
    QString filename = inf.fileName();
    QString title = tr(""Project file: %1"").arg(filename);
    setWindowTitle(title);
    loadSettings();

    mUI->premiumLicense->setVisible(false);

    // Checkboxes for the libraries..
    const QString applicationFilePath = QCoreApplication::applicationFilePath();
    const QString appPath = QFileInfo(applicationFilePath).canonicalPath();
    const QString datadir = getDataDir();
    QStringList searchPaths;
    searchPaths << appPath << appPath + ""/cfg"" << inf.canonicalPath();
#ifdef FILESDIR
    if (FILESDIR[0])
        searchPaths << FILESDIR << FILESDIR ""/cfg"";
#endif
    if (!datadir.isEmpty())
        searchPaths << da...",1,1,gui/projectfiledialog.cpp,"ProjectFileDialog.ProjectFileDialog:ANY(ProjectFile*,bool,QWidget*)",<empty>,,false,106,251,ProjectFileDialog,,,1,"ProjectFileDialog.ProjectFileDialog:ANY(ProjectFile*,bool,QWidget*)(ProjectFile*,bool,QWidget*)"
111669150599,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"ProjectFileDialog::~ProjectFileDialog()
{
    saveSettings();
    delete mUI;
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.~ProjectFileDialog:ANY(),<empty>,,false,253,257,~ProjectFileDialog,,,1,ANY()
111669150600,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::loadSettings()
{
    QSettings settings;
    resize(settings.value(SETTINGS_PROJECT_DIALOG_WIDTH, 470).toInt(),
           settings.value(SETTINGS_PROJECT_DIALOG_HEIGHT, 330).toInt());
}",1,26,gui/projectfiledialog.cpp,ProjectFileDialog.loadSettings:void(),<empty>,,false,259,264,loadSettings,,,1,void()
111669150601,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::saveSettings() const
{
    QSettings settings;
    settings.setValue(SETTINGS_PROJECT_DIALOG_WIDTH, size().width());
    settings.setValue(SETTINGS_PROJECT_DIALOG_HEIGHT, size().height());
}",1,22,gui/projectfiledialog.cpp,ProjectFileDialog.saveSettings<const>:void(),<empty>,,false,266,271,saveSettings,,,1,void()
111669150602,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"static void updateAddonCheckBox(QCheckBox *cb, const ProjectFile *projectFile, const QString &dataDir, const QString &addon)
{
    if (projectFile)
        cb->setChecked(projectFile->getAddons().contains(addon));
    if (ProjectFile::getAddonFilePath(dataDir, addon).isEmpty()) {
        cb->setEnabled(false);
        cb->setText(cb->text() + QObject::tr("" (Not found)""));
    }
}",1,1,gui/projectfiledialog.cpp,"updateAddonCheckBox:void(QCheckBox*,ProjectFile*,QString&,QString&)",<empty>,,false,273,281,updateAddonCheckBox,,,1,"void(QCheckBox*,ProjectFile*,QString&,QString&)"
111669150603,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::checkAllVSConfigs()
{
    if (mUI->mChkAllVsConfigs->isChecked()) {
        for (int row = 0; row < mUI->mListVsConfigs->count(); ++row) {
            QListWidgetItem *item = mUI->mListVsConfigs->item(row);
            item->setCheckState(Qt::Checked);
        }
    }
    mUI->mListVsConfigs->setEnabled(!mUI->mChkAllVsConfigs->isChecked());
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.checkAllVSConfigs:void(),<empty>,,false,283,292,checkAllVSConfigs,,,1,void()
111669150604,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::loadFromProjectFile(const ProjectFile *projectFile)
{
    setRootPath(projectFile->getRootPath());
    setBuildDir(projectFile->getBuildDir());
    setIncludepaths(projectFile->getIncludeDirs());
    setDefines(projectFile->getDefines());
    setUndefines(projectFile->getUndefines());
    setCheckPaths(projectFile->getCheckPaths());
    setImportProject(projectFile->getImportProject());
    mUI->mChkAllVsConfigs->setChecked(projectFile->getAnalyzeAllVsConfigs());
    setProjectConfigurations(getProjectConfigs(mUI->mEditImportProject->text()));
    for (int row = 0; row < mUI->mListVsConfigs->count(); ++row) {
        QListWidgetItem *item = mUI->mListVsConfigs->item(row);
        if (projectFile->getAnalyzeAllVsConfigs() || projectFile->getVsConfigurations().contains(item->text()))
            item->setCheckState(Qt::Checked);
        else
            item->setCheckState(Qt::Unchecked);
    }
    switch (projectFile->getCheckLevel()) {
    case ProjectFile::C...",1,46,gui/projectfiledialog.cpp,ProjectFileDialog.loadFromProjectFile:void(ProjectFile*),<empty>,,false,294,452,loadFromProjectFile,,,1,void(ProjectFile*)
111669150605,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::saveToProjectFile(ProjectFile *projectFile) const
{
    projectFile->setRootPath(getRootPath());
    projectFile->setBuildDir(getBuildDir());
    projectFile->setImportProject(getImportProject());
    projectFile->setAnalyzeAllVsConfigs(mUI->mChkAllVsConfigs->isChecked());
    projectFile->setVSConfigurations(getProjectConfigurations());
    projectFile->setCheckHeaders(mUI->mCheckHeaders->isChecked());
    projectFile->setCheckUnusedTemplates(mUI->mCheckUnusedTemplates->isChecked());
    projectFile->setInlineSuppression(mUI->mInlineSuppressions->isChecked());
    projectFile->setMaxCtuDepth(mUI->mMaxCtuDepth->value());
    projectFile->setMaxTemplateRecursion(mUI->mMaxTemplateRecursion->value());
    projectFile->setIncludes(getIncludePaths());
    projectFile->setDefines(getDefines());
    projectFile->setUndefines(getUndefines());
    projectFile->setCheckPaths(getCheckPaths());
    projectFile->setExcludedPaths(getExcludedPaths());
    projectFile->setLi...",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.saveToProjectFile<const>:void(ProjectFile*),<empty>,,false,454,539,saveToProjectFile,,,1,void(ProjectFile*)
111669150606,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::ok()
{
    saveToProjectFile(mProjectFile);
    mProjectFile->write();
    accept();
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.ok:void(),<empty>,,false,541,546,ok,,,1,void()
111669150607,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"QString ProjectFileDialog::getExistingDirectory(const QString &caption, bool trailingSlash)
{
    const QFileInfo inf(mProjectFile->getFilename());
    const QString projectPath = inf.absolutePath();
    QString selectedDir = QFileDialog::getExistingDirectory(this,
                                                            caption,
                                                            projectPath);

    if (selectedDir.isEmpty())
        return QString();

    // Check if the path is relative to project file's path and if so
    // make it a relative path instead of absolute path.
    const QDir dir(projectPath);
    const QString relpath(dir.relativeFilePath(selectedDir));
    if (!relpath.startsWith(""../..""))
        selectedDir = relpath;

    // Trailing slash..
    if (trailingSlash && !selectedDir.endsWith('/'))
        selectedDir += '/';

    return selectedDir;
}",1,1,gui/projectfiledialog.cpp,"ProjectFileDialog.getExistingDirectory:QString(QString&,bool)",<empty>,,false,548,571,getExistingDirectory,,,1,"QString(QString&,bool)"
111669150608,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::browseBuildDir()
{
    const QString dir(getExistingDirectory(tr(""Select Cppcheck build dir""), false));
    if (!dir.isEmpty())
        mUI->mEditBuildDir->setText(dir);
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.browseBuildDir:void(),<empty>,,false,573,578,browseBuildDir,,,1,void()
111669150609,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::updatePathsAndDefines()
{
    const QString &fileName = mUI->mEditImportProject->text();
    const bool importProject = !fileName.isEmpty();
    const bool hasConfigs = fileName.endsWith("".sln"") || fileName.endsWith("".vcxproj"");
    mUI->mBtnClearImportProject->setEnabled(importProject);
    mUI->mListCheckPaths->setEnabled(!importProject);
    mUI->mListIncludeDirs->setEnabled(!importProject);
    mUI->mBtnAddCheckPath->setEnabled(!importProject);
    mUI->mBtnEditCheckPath->setEnabled(!importProject);
    mUI->mBtnRemoveCheckPath->setEnabled(!importProject);
    mUI->mEditUndefines->setEnabled(!importProject);
    mUI->mBtnAddInclude->setEnabled(!importProject);
    mUI->mBtnEditInclude->setEnabled(!importProject);
    mUI->mBtnRemoveInclude->setEnabled(!importProject);
    mUI->mBtnIncludeUp->setEnabled(!importProject);
    mUI->mBtnIncludeDown->setEnabled(!importProject);
    mUI->mChkAllVsConfigs->setEnabled(hasConfigs);
    mUI->mListVsConfigs->setEnabl...",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.updatePathsAndDefines:void(),<empty>,,false,580,601,updatePathsAndDefines,,,1,void()
111669150610,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::clearImportProject()
{
    mUI->mEditImportProject->clear();
    updatePathsAndDefines();
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.clearImportProject:void(),<empty>,,false,603,607,clearImportProject,,,1,void()
111669150611,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::browseImportProject()
{
    const QFileInfo inf(mProjectFile->getFilename());
    const QDir &dir = inf.absoluteDir();
    QMap<QString,QString> filters;
    filters[tr(""Visual Studio"")] = ""*.sln *.vcxproj"";
    filters[tr(""Compile database"")] = ""compile_commands.json"";
    filters[tr(""Borland C++ Builder 6"")] = ""*.bpr"";
    QString fileName = QFileDialog::getOpenFileName(this, tr(""Import Project""),
                                                    dir.canonicalPath(),
                                                    toFilterString(filters));
    if (!fileName.isEmpty()) {
        mUI->mEditImportProject->setText(dir.relativeFilePath(fileName));
        updatePathsAndDefines();
        setProjectConfigurations(getProjectConfigs(fileName));
        for (int row = 0; row < mUI->mListVsConfigs->count(); ++row) {
            QListWidgetItem *item = mUI->mListVsConfigs->item(row);
            item->setCheckState(Qt::Checked);
        }
    }
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.browseImportProject:void(),<empty>,,false,609,629,browseImportProject,,,1,void()
111669150612,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"QStringList ProjectFileDialog::getProjectConfigurations() const
{
    QStringList configs;
    for (int row = 0; row < mUI->mListVsConfigs->count(); ++row) {
        QListWidgetItem *item = mUI->mListVsConfigs->item(row);
        if (item->checkState() == Qt::Checked)
            configs << item->text();
    }
    return configs;
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.getProjectConfigurations<const>:QStringList(),<empty>,,false,631,640,getProjectConfigurations,,,1,QStringList()
111669150613,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::setProjectConfigurations(const QStringList &configs)
{
    mUI->mListVsConfigs->clear();
    mUI->mListVsConfigs->setEnabled(!configs.isEmpty() && !mUI->mChkAllVsConfigs->isChecked());
    for (const QString &cfg : configs) {
        auto* item = new QListWidgetItem(cfg, mUI->mListVsConfigs);
        item->setFlags(item->flags() | Qt::ItemIsUserCheckable); // set checkable flag
        item->setCheckState(Qt::Unchecked);
    }
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.setProjectConfigurations:void(QStringList&),<empty>,,false,642,651,setProjectConfigurations,,,1,void(QStringList&)
111669150614,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"QString ProjectFileDialog::getImportProject() const
{
    return mUI->mEditImportProject->text();
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.getImportProject<const>:QString(),<empty>,,false,653,656,getImportProject,,,1,QString()
111669150615,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::addIncludeDir(const QString &dir)
{
    if (dir.isEmpty())
        return;

    const QString newdir = QDir::toNativeSeparators(dir);
    auto *item = new QListWidgetItem(newdir);
    item->setFlags(item->flags() | Qt::ItemIsEditable);
    mUI->mListIncludeDirs->addItem(item);
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.addIncludeDir:void(QString&),<empty>,,false,658,667,addIncludeDir,,,1,void(QString&)
111669150616,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::addCheckPath(const QString &path)
{
    if (path.isEmpty())
        return;

    const QString newpath = QDir::toNativeSeparators(path);
    auto *item = new QListWidgetItem(newpath);
    item->setFlags(item->flags() | Qt::ItemIsEditable);
    mUI->mListCheckPaths->addItem(item);
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.addCheckPath:void(QString&),<empty>,,false,669,678,addCheckPath,,,1,void(QString&)
111669150617,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::addExcludePath(const QString &path)
{
    if (path.isEmpty())
        return;

    const QString newpath = QDir::toNativeSeparators(path);
    auto *item = new QListWidgetItem(newpath);
    item->setFlags(item->flags() | Qt::ItemIsEditable);
    mUI->mListExcludedPaths->addItem(item);
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.addExcludePath:void(QString&),<empty>,,false,680,689,addExcludePath,,,1,void(QString&)
111669150618,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"QString ProjectFileDialog::getRootPath() const
{
    QString root = mUI->mEditProjectRoot->text();
    root = root.trimmed();
    root = QDir::fromNativeSeparators(root);
    return root;
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.getRootPath<const>:QString(),<empty>,,false,691,697,getRootPath,,,1,QString()
111669150619,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"QString ProjectFileDialog::getBuildDir() const
{
    return mUI->mEditBuildDir->text();
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.getBuildDir<const>:QString(),<empty>,,false,699,702,getBuildDir,,,1,QString()
111669150620,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"QStringList ProjectFileDialog::getIncludePaths() const
{
    return getPaths(mUI->mListIncludeDirs);
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.getIncludePaths<const>:QStringList(),<empty>,,false,704,707,getIncludePaths,,,1,QStringList()
111669150621,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"QStringList ProjectFileDialog::getDefines() const
{
#if (QT_VERSION >= QT_VERSION_CHECK(5, 14, 0))
    return mUI->mEditDefines->text().trimmed().split(QRegularExpression(""\\\\s*;\\\\s*""), Qt::SkipEmptyParts);
#else
    return mUI->mEditDefines->text().trimmed().split(QRegularExpression(""\\\\s*;\\\\s*""), QString::SkipEmptyParts);
#endif
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.getDefines<const>:QStringList(),<empty>,,false,709,716,getDefines,,,1,QStringList()
111669150622,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"QStringList ProjectFileDialog::getUndefines() const
{
    const QString undefine = mUI->mEditUndefines->text().trimmed();
#if (QT_VERSION >= QT_VERSION_CHECK(5, 14, 0))
    QStringList undefines = undefine.split(QRegularExpression(""\\\\s*;\\\\s*""), Qt::SkipEmptyParts);
#else
    QStringList undefines = undefine.split(QRegularExpression(""\\\\s*;\\\\s*""), QString::SkipEmptyParts);
#endif
    undefines.removeDuplicates();
    return undefines;
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.getUndefines<const>:QStringList(),<empty>,,false,718,728,getUndefines,,,1,QStringList()
111669150623,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"QStringList ProjectFileDialog::getCheckPaths() const
{
    return getPaths(mUI->mListCheckPaths);
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.getCheckPaths<const>:QStringList(),<empty>,,false,730,733,getCheckPaths,,,1,QStringList()
111669150624,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"QStringList ProjectFileDialog::getExcludedPaths() const
{
    return getPaths(mUI->mListExcludedPaths);
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.getExcludedPaths<const>:QStringList(),<empty>,,false,735,738,getExcludedPaths,,,1,QStringList()
111669150625,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"QStringList ProjectFileDialog::getLibraries() const
{
    QStringList libraries;
    for (int row = 0; row < mUI->mLibraries->count(); ++row) {
        QListWidgetItem *item = mUI->mLibraries->item(row);
        if (item->checkState() == Qt::Checked)
            libraries << item->text();
    }
    return libraries;
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.getLibraries<const>:QStringList(),<empty>,,false,740,749,getLibraries,,,1,QStringList()
111669150626,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::setRootPath(const QString &root)
{
    mUI->mEditProjectRoot->setText(QDir::toNativeSeparators(root));
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.setRootPath:void(QString&),<empty>,,false,751,754,setRootPath,,,1,void(QString&)
111669150627,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::setBuildDir(const QString &buildDir)
{
    mUI->mEditBuildDir->setText(buildDir);
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.setBuildDir:void(QString&),<empty>,,false,756,759,setBuildDir,,,1,void(QString&)
111669150628,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::setImportProject(const QString &importProject)
{
    mUI->mEditImportProject->setText(importProject);
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.setImportProject:void(QString&),<empty>,,false,761,764,setImportProject,,,1,void(QString&)
111669150629,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::setIncludepaths(const QStringList &includes)
{
    for (const QString& dir : includes) {
        addIncludeDir(dir);
    }
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.setIncludepaths:void(QStringList&),<empty>,,false,766,771,setIncludepaths,,,1,void(QStringList&)
111669150630,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::setDefines(const QStringList &defines)
{
    mUI->mEditDefines->setText(defines.join("";""));
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.setDefines:void(QStringList&),<empty>,,false,773,776,setDefines,,,1,void(QStringList&)
111669150631,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::setUndefines(const QStringList &undefines)
{
    mUI->mEditUndefines->setText(undefines.join("";""));
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.setUndefines:void(QStringList&),<empty>,,false,778,781,setUndefines,,,1,void(QStringList&)
111669150632,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::setCheckPaths(const QStringList &paths)
{
    for (const QString& path : paths) {
        addCheckPath(path);
    }
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.setCheckPaths:void(QStringList&),<empty>,,false,783,788,setCheckPaths,,,1,void(QStringList&)
111669150633,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::setExcludedPaths(const QStringList &paths)
{
    for (const QString& path : paths) {
        addExcludePath(path);
    }
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.setExcludedPaths:void(QStringList&),<empty>,,false,790,795,setExcludedPaths,,,1,void(QStringList&)
111669150634,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::setLibraries(const QStringList &libraries)
{
    for (int row = 0; row < mUI->mLibraries->count(); ++row) {
        QListWidgetItem *item = mUI->mLibraries->item(row);
        item->setCheckState(libraries.contains(item->text()) ? Qt::Checked : Qt::Unchecked);
    }
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.setLibraries:void(QStringList&),<empty>,,false,797,803,setLibraries,,,1,void(QStringList&)
111669150635,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::addSingleSuppression(const SuppressionList::Suppression &suppression)
{
    mSuppressions += suppression;
    mUI->mListSuppressions->addItem(QString::fromStdString(suppression.getText()));
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.addSingleSuppression:void(SuppressionList.Suppression&),<empty>,,false,805,809,addSingleSuppression,,,1,void(SuppressionList.Suppression&)
111669150636,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::setSuppressions(const QList<SuppressionList::Suppression> &suppressions)
{
    mUI->mListSuppressions->clear();
    QList<SuppressionList::Suppression> new_suppressions = suppressions;
    mSuppressions.clear();
    for (const SuppressionList::Suppression &suppression : new_suppressions) {
        addSingleSuppression(suppression);
    }
    mUI->mListSuppressions->sortItems();
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.setSuppressions:void(QList<SuppressionList.Suppression>&),<empty>,,false,811,820,setSuppressions,,,1,void(QList<SuppressionList.Suppression>&)
111669150637,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::addCheckPath()
{
    QString dir = getExistingDirectory(tr(""Select a directory to check""), false);
    if (!dir.isEmpty())
        addCheckPath(dir);
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.addCheckPath:void(),<empty>,,false,822,827,addCheckPath,,,1,void()
111669150638,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::editCheckPath()
{
    QListWidgetItem *item = mUI->mListCheckPaths->currentItem();
    mUI->mListCheckPaths->editItem(item);
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.editCheckPath:void(),<empty>,,false,829,833,editCheckPath,,,1,void()
111669150639,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::removeCheckPath()
{
    const int row = mUI->mListCheckPaths->currentRow();
    QListWidgetItem *item = mUI->mListCheckPaths->takeItem(row);
    delete item;
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.removeCheckPath:void(),<empty>,,false,835,840,removeCheckPath,,,1,void()
111669150640,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::addIncludeDir()
{
    const QString dir = getExistingDirectory(tr(""Select include directory""), true);
    if (!dir.isEmpty())
        addIncludeDir(dir);
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.addIncludeDir:void(),<empty>,,false,842,847,addIncludeDir,,,1,void()
111669150641,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::removeIncludeDir()
{
    const int row = mUI->mListIncludeDirs->currentRow();
    QListWidgetItem *item = mUI->mListIncludeDirs->takeItem(row);
    delete item;
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.removeIncludeDir:void(),<empty>,,false,849,854,removeIncludeDir,,,1,void()
111669150642,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::editIncludeDir()
{
    QListWidgetItem *item = mUI->mListIncludeDirs->currentItem();
    mUI->mListIncludeDirs->editItem(item);
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.editIncludeDir:void(),<empty>,,false,856,860,editIncludeDir,,,1,void()
111669150643,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::addExcludePath()
{
    addExcludePath(getExistingDirectory(tr(""Select directory to ignore""), true));
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.addExcludePath:void(),<empty>,,false,862,865,addExcludePath,,,1,void()
111669150644,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::addExcludeFile()
{
    const QFileInfo inf(mProjectFile->getFilename());
    const QDir &dir = inf.absoluteDir();
    QMap<QString,QString> filters;
    filters[tr(""Source files"")] = ""*.c *.cpp"";
    filters[tr(""All files"")] = ""*.*"";
    addExcludePath(QFileDialog::getOpenFileName(this, tr(""Exclude file""), dir.canonicalPath(), toFilterString(filters)));
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.addExcludeFile:void(),<empty>,,false,867,875,addExcludeFile,,,1,void()
111669150645,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::editExcludePath()
{
    QListWidgetItem *item = mUI->mListExcludedPaths->currentItem();
    mUI->mListExcludedPaths->editItem(item);
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.editExcludePath:void(),<empty>,,false,877,881,editExcludePath,,,1,void()
111669150646,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::removeExcludePath()
{
    const int row = mUI->mListExcludedPaths->currentRow();
    QListWidgetItem *item = mUI->mListExcludedPaths->takeItem(row);
    delete item;
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.removeExcludePath:void(),<empty>,,false,883,888,removeExcludePath,,,1,void()
111669150647,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::moveIncludePathUp()
{
    int row = mUI->mListIncludeDirs->currentRow();
    QListWidgetItem *item = mUI->mListIncludeDirs->takeItem(row);
    row = row > 0 ? row - 1 : 0;
    mUI->mListIncludeDirs->insertItem(row, item);
    mUI->mListIncludeDirs->setCurrentItem(item);
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.moveIncludePathUp:void(),<empty>,,false,890,897,moveIncludePathUp,,,1,void()
111669150648,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::moveIncludePathDown()
{
    int row = mUI->mListIncludeDirs->currentRow();
    QListWidgetItem *item = mUI->mListIncludeDirs->takeItem(row);
    const int count = mUI->mListIncludeDirs->count();
    row = row < count ? row + 1 : count;
    mUI->mListIncludeDirs->insertItem(row, item);
    mUI->mListIncludeDirs->setCurrentItem(item);
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.moveIncludePathDown:void(),<empty>,,false,899,907,moveIncludePathDown,,,1,void()
111669150649,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::addSuppression()
{
    NewSuppressionDialog dlg;
    if (dlg.exec() == QDialog::Accepted) {
        addSingleSuppression(dlg.getSuppression());
    }
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.addSuppression:void(),<empty>,,false,909,915,addSuppression,,,1,void()
111669150650,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::removeSuppression()
{
    const int row = mUI->mListSuppressions->currentRow();
    QListWidgetItem *item = mUI->mListSuppressions->takeItem(row);
    if (!item)
        return;

    const int suppressionIndex = getSuppressionIndex(item->text());
    if (suppressionIndex >= 0)
        mSuppressions.removeAt(suppressionIndex);
    delete item;
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.removeSuppression:void(),<empty>,,false,917,928,removeSuppression,,,1,void()
111669150651,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::editSuppression(const QModelIndex & /*index*/)
{
    const int row = mUI->mListSuppressions->currentRow();
    QListWidgetItem *item = mUI->mListSuppressions->item(row);
    const int suppressionIndex = getSuppressionIndex(item->text());
    if (suppressionIndex >= 0) { // TODO what if suppression is not found?
        NewSuppressionDialog dlg;
        dlg.setSuppression(mSuppressions[suppressionIndex]);
        if (dlg.exec() == QDialog::Accepted) {
            mSuppressions[suppressionIndex] = dlg.getSuppression();
            setSuppressions(mSuppressions);
        }
    }
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.editSuppression:void(QModelIndex&),<empty>,,false,930,943,editSuppression,,,1,void(QModelIndex&)
111669150652,METHOD,<empty>,<empty>,"[&](const SuppressionList::Suppression& sup) {
        return sup.getText() == s;
    }",74,5,gui/projectfiledialog.cpp,gui/projectfiledialog.cpp:<global>.ProjectFileDialog.getSuppressionIndex<const>.<lambda>0:bool(SuppressionList.Suppression&),<empty>,,false,948,950,<lambda>0,,,1,bool(SuppressionList.Suppression&)
111669150653,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"int ProjectFileDialog::getSuppressionIndex(const QString &shortText) const
{
    const std::string s = shortText.toStdString();
    auto it = std::find_if(mSuppressions.cbegin(), mSuppressions.cend(), [&](const SuppressionList::Suppression& sup) {
        return sup.getText() == s;
    });
    return it == mSuppressions.cend() ? -1 : static_cast<int>(std::distance(mSuppressions.cbegin(), it));
}",1,1,gui/projectfiledialog.cpp,ProjectFileDialog.getSuppressionIndex<const>:int(QString&),<empty>,,false,945,952,getSuppressionIndex,,,1,int(QString&)
111669150654,METHOD,gui/projectfiledialog.cpp:<global>,TYPE_DECL,"void ProjectFileDialog::browseMisraFile()
{
    const QString fileName = QFileDialog::getOpenFileName(this,
                                                          tr(""Select MISRA rule texts file""),
                                                          QDir::homePath(),
                                                          tr(""MISRA rule texts file (%1)"").arg(""*.txt""));
    if (!fileName.isEmpty()) {
        QSettings settings;
        mUI->mEditMisraFile->setText(fileName);
        settings.setValue(SETTINGS_MISRA_FILE, fileName);

        mUI->mMisraC->setText(""MISRA C 2012"");
        mUI->mMisraC->setEnabled(true);
        updateAddonCheckBox(mUI->mMisraC, nullptr, getDataDir(), ADDON_MISRA);
    }
}",1,26,gui/projectfiledialog.cpp,ProjectFileDialog.browseMisraFile:void(),<empty>,,false,954,969,browseMisraFile,,,1,void()
111669150655,METHOD,gui/projectfiledialog.h:<global>,TYPE_DECL,<global>,1,1,gui/projectfiledialog.h,gui/projectfiledialog.h:<global>,<empty>,,false,1,338,<global>,,,1,
111669150656,METHOD,gui/report.cpp:<global>,TYPE_DECL,"Report::Report(QString filename) :
    mFilename(std::move(filename))
{}",1,2,gui/report.cpp,Report.Report:ANY(QString),<empty>,,false,25,27,Report,,,1,Report.Report:ANY(QString)(QString)
111669150657,METHOD,gui/report.cpp:<global>,TYPE_DECL,<global>,1,1,gui/report.cpp,gui/report.cpp:<global>,<empty>,,false,1,63,<global>,,,1,
111669150658,METHOD,gui/report.cpp:<global>,TYPE_DECL,"Report::~Report()
{
    close();
}",1,1,gui/report.cpp,Report.~Report:ANY(),<empty>,,false,29,32,~Report,,,1,ANY()
111669150659,METHOD,gui/report.cpp:<global>,TYPE_DECL,"bool Report::create()
{
    bool succeed = false;
    if (!mFile.isOpen()) {
        mFile.setFileName(mFilename);
        succeed = mFile.open(QIODevice::WriteOnly | QIODevice::Text);
    }
    return succeed;
}",1,1,gui/report.cpp,Report.create:bool(),<empty>,,false,34,42,create,,,1,bool()
111669150660,METHOD,gui/report.cpp:<global>,TYPE_DECL,"bool Report::open()
{
    bool succeed = false;
    if (!mFile.isOpen()) {
        mFile.setFileName(mFilename);
        succeed = mFile.open(QIODevice::ReadOnly | QIODevice::Text);
    }
    return succeed;
}",1,1,gui/report.cpp,Report.open:bool(),<empty>,,false,44,52,open,,,1,bool()
111669150661,METHOD,gui/report.cpp:<global>,TYPE_DECL,"void Report::close()
{
    if (mFile.isOpen())
        mFile.close();
}",1,1,gui/report.cpp,Report.close:void(),<empty>,,false,54,58,close,,,1,void()
111669150662,METHOD,gui/report.cpp:<global>,TYPE_DECL,"QFile* Report::getFile()
{
    return &mFile;
}",1,1,gui/report.cpp,Report.getFile:QFile(),<empty>,,false,60,63,getFile,,,1,QFile()
111669150663,METHOD,gui/report.h:<global>,TYPE_DECL,<global>,1,18,gui/report.h,gui/report.h:<global>,<empty>,,false,1,100,<global>,,,1,
111669150664,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"static QString getGuideline(ReportType reportType, const std::map<std::string, std::string> &guidelineMapping,
                            const QString& errorId, Severity severity) {
    return QString::fromStdString(getGuideline(errorId.toStdString(),
                                               reportType, guidelineMapping,
                                               severity));
}",1,1,gui/resultstree.cpp,"getGuideline:QString(ReportType,std.map<std.string,std.string>&,QString&,Severity)",<empty>,,false,100,105,getGuideline,,,1,"QString(ReportType,std.map<std.string,std.string>&,QString&,Severity)"
111669150665,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,<global>,1,1,gui/resultstree.cpp,gui/resultstree.cpp:<global>,<empty>,,false,1,1540,<global>,,,1,
111669150666,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"static QString getClassification(ReportType reportType, const QString& guideline) {
    return QString::fromStdString(getClassification(guideline.toStdString(), reportType));
}",1,1,gui/resultstree.cpp,"getClassification:QString(ReportType,QString&)",<empty>,,false,107,109,getClassification,,,1,"QString(ReportType,QString&)"
111669150667,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"static Severity getSeverityFromClassification(const QString &c) {
    if (c == checkers::Man)
        return Severity::error;
    if (c == checkers::Req)
        return Severity::warning;
    if (c == checkers::Adv)
        return Severity::style;
    if (c == checkers::Doc)
        return Severity::information;
    if (c == ""L1"")
        return Severity::error;
    if (c == ""L2"")
        return Severity::warning;
    if (c == ""L3"")
        return Severity::style;
    return Severity::none;
}",1,1,gui/resultstree.cpp,getSeverityFromClassification:Severity(QString&),<empty>,,false,111,127,getSeverityFromClassification,,,1,Severity(QString&)
111669150668,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"static QStringList getLabels() {
    return QStringList{
        QObject::tr(""File""),
        QObject::tr(""Line""),
        QObject::tr(""Severity""),
        QObject::tr(""Classification""),
        QObject::tr(""Level""),
        QObject::tr(""Inconclusive""),
        QObject::tr(""Summary""),
        QObject::tr(""Id""),
        QObject::tr(""Guideline""),
        QObject::tr(""Rule""),
        QObject::tr(""Since date""),
        QObject::tr(""Tags""),
        QObject::tr(""CWE"")};
}",1,1,gui/resultstree.cpp,getLabels:QStringList(),<empty>,,false,129,144,getLabels,,,1,QStringList()
111669150669,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"ResultsTree::ResultsTree(QWidget * parent) :
    QTreeView(parent)
{
    setModel(&mModel);
    translate(); // Adds columns to grid
    clear();
    setExpandsOnDoubleClick(false);
    setSortingEnabled(true);

    connect(this, &ResultsTree::doubleClicked, this, &ResultsTree::quickStartApplication);
}",1,1,gui/resultstree.cpp,ResultsTree.ResultsTree:ANY(QWidget*),<empty>,,false,146,156,ResultsTree,,,1,ResultsTree.ResultsTree:ANY(QWidget*)(QWidget*)
111669150670,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::keyPressEvent(QKeyEvent *event)
{
    if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return) {
        quickStartApplication(this->currentIndex());
    }
    QTreeView::keyPressEvent(event);
}",1,1,gui/resultstree.cpp,ResultsTree.keyPressEvent:void(QKeyEvent*),<empty>,,false,158,164,keyPressEvent,,,1,void(QKeyEvent*)
111669150671,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::setReportType(ReportType reportType) {
    mReportType = reportType;

    mGuideline = createGuidelineMapping(reportType);

    for (int i = 0; i < mModel.rowCount(); ++i) {
        const QStandardItem *fileItem = mModel.item(i, COLUMN_FILE);
        if (!fileItem)
            continue;
        for (int j = 0; j < fileItem->rowCount(); ++j) {
            const auto& childdata = fileItem->child(j,0)->data().toMap();
            const QString& errorId = childdata[ERRORID].toString();
            Severity severity = ShowTypes::ShowTypeToSeverity(ShowTypes::VariantToShowType(childdata[SEVERITY]));
            const QString& guideline = getGuideline(mReportType, mGuideline, errorId, severity);
            const QString& classification = getClassification(mReportType, guideline);
            fileItem->child(j, COLUMN_CERT_LEVEL)->setText(classification);
            fileItem->child(j, COLUMN_CERT_RULE)->setText(guideline);
            fileItem->child(j, COLUMN_MISRA_CLAS...",1,1,gui/resultstree.cpp,ResultsTree.setReportType:void(ReportType),<empty>,,false,166,211,setReportType,,,1,void(ReportType)
111669150672,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::initialize(QSettings *settings, ApplicationList *list, ThreadHandler *checkThreadHandler)
{
    mSettings = settings;
    mApplications = list;
    mThread = checkThreadHandler;
    loadSettings();
}",1,1,gui/resultstree.cpp,"ResultsTree.initialize:void(QSettings*,ApplicationList*,ThreadHandler*)",<empty>,,false,213,219,initialize,,,1,"void(QSettings*,ApplicationList*,ThreadHandler*)"
111669150673,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"QStandardItem *ResultsTree::createNormalItem(const QString &name)
{
    auto *item = new QStandardItem(name);
    item->setData(name, Qt::ToolTipRole);
    item->setEditable(false);
    return item;
}",1,1,gui/resultstree.cpp,ResultsTree.createNormalItem:QStandardItem(QString&),<empty>,,false,222,228,createNormalItem,,,1,QStandardItem(QString&)
111669150674,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"QStandardItem *ResultsTree::createCheckboxItem(bool checked)
{
    auto *item = new QStandardItem;
    item->setCheckable(true);
    item->setCheckState(checked ? Qt::Checked : Qt::Unchecked);
    item->setEnabled(false);
    return item;
}",1,1,gui/resultstree.cpp,ResultsTree.createCheckboxItem:QStandardItem(bool),<empty>,,false,230,237,createCheckboxItem,,,1,QStandardItem(bool)
111669150675,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"QStandardItem *ResultsTree::createLineNumberItem(const QString &linenumber)
{
    auto *item = new QStandardItem();
    item->setData(QVariant(linenumber.toInt()), Qt::DisplayRole);
    item->setToolTip(linenumber);
    item->setTextAlignment(Qt::AlignRight | Qt::AlignVCenter);
    item->setEditable(false);
    return item;
}",1,1,gui/resultstree.cpp,ResultsTree.createLineNumberItem:QStandardItem(QString&),<empty>,,false,239,247,createLineNumberItem,,,1,QStandardItem(QString&)
111669150676,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"bool ResultsTree::addErrorItem(const ErrorItem &item)
{
    if (item.errorPath.isEmpty()) {
        return false;
    }

    const QErrorPathItem &loc = item.errorId.startsWith(""clang"") ? item.errorPath.front() : item.errorPath.back();
    QString realfile = stripPath(loc.file, false);

    if (realfile.isEmpty()) {
        realfile = tr(""Undefined file"");
    }

    bool showItem = true;

    // Ids that are temporarily hidden..
    if (mHiddenMessageId.contains(item.errorId))
        showItem = false;

    //If specified, filter on summary, message, filename, and id
    if (showItem && !mFilter.isEmpty()) {
        if (!item.summary.contains(mFilter, Qt::CaseInsensitive) &&
            !item.message.contains(mFilter, Qt::CaseInsensitive) &&
            !item.errorPath.back().file.contains(mFilter, Qt::CaseInsensitive) &&
            !item.errorId.contains(mFilter, Qt::CaseInsensitive)) {
            showItem = false;
        }
    }

    if (showItem) {
        if (mReportType == ...",1,1,gui/resultstree.cpp,ResultsTree.addErrorItem:bool(ErrorItem&),<empty>,,false,249,371,addErrorItem,,,1,bool(ErrorItem&)
111669150677,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"QStandardItem *ResultsTree::addBacktraceFiles(QStandardItem *parent,
                                              const ErrorLine &item,
                                              const bool hide,
                                              const QString &icon,
                                              bool childOfMessage)
{
    if (!parent)
        return nullptr;

    //TODO message has parameter names so we'll need changes to the core
    //cppcheck so we can get proper translations

    const QString itemSeverity = childOfMessage ? tr(""note"") : severityToTranslatedString(item.severity);

    // Check for duplicate rows and don't add them if found
    for (int i = 0; i < parent->rowCount(); i++) {
        // The first column is the file name and is always the same

        // the third column is the line number so check it first
        if (parent->child(i, COLUMN_LINE)->text() == QString::number(item.line)) {
            // the second column is the severity so check it...",1,1,gui/resultstree.cpp,"ResultsTree.addBacktraceFiles:QStandardItem(QStandardItem*,ErrorLine&,bool,QString&,bool)",<empty>,,false,373,435,addBacktraceFiles,,,1,"QStandardItem(QStandardItem*,ErrorLine&,bool,QString&,bool)"
111669150678,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"QString ResultsTree::severityToTranslatedString(Severity severity)
{
    switch (severity) {
    case Severity::style:
        return tr(""style"");

    case Severity::error:
        return tr(""error"");

    case Severity::warning:
        return tr(""warning"");

    case Severity::performance:
        return tr(""performance"");

    case Severity::portability:
        return tr(""portability"");

    case Severity::information:
        return tr(""information"");

    case Severity::debug:
        return tr(""debug"");

    case Severity::internal:
        return tr(""internal"");

    case Severity::none:
    default:
        return QString();
    }
}",1,1,gui/resultstree.cpp,ResultsTree.severityToTranslatedString:QString(Severity),<empty>,,false,437,468,severityToTranslatedString,,,1,QString(Severity)
111669150679,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"QStandardItem *ResultsTree::findFileItem(const QString &name) const
{
    // The first column contains the file name. In Windows we can get filenames
    // ""header.h"" and ""Header.h"" and must compare them as identical.

    for (int i = 0; i < mModel.rowCount(); i++) {
#ifdef _WIN32
        if (QString::compare(mModel.item(i, COLUMN_FILE)->text(), name, Qt::CaseInsensitive) == 0)
#else
        if (mModel.item(i, COLUMN_FILE)->text() == name)
#endif
            return mModel.item(i, COLUMN_FILE);
    }
    return nullptr;
}",1,1,gui/resultstree.cpp,ResultsTree.findFileItem<const>:QStandardItem(QString&),<empty>,,false,470,484,findFileItem,,,1,QStandardItem(QString&)
111669150680,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::clear()
{
    mModel.removeRows(0, mModel.rowCount());

    if (const ProjectFile *activeProject = ProjectFile::getActiveProject()) {
        hideColumn(COLUMN_SINCE_DATE);
        if (activeProject->getTags().isEmpty())
            hideColumn(COLUMN_TAGS);
        else
            showColumn(COLUMN_TAGS);
    } else {
        hideColumn(COLUMN_SINCE_DATE);
        hideColumn(COLUMN_TAGS);
    }
}",1,1,gui/resultstree.cpp,ResultsTree.clear:void(),<empty>,,false,486,500,clear,,,1,void()
111669150681,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::clear(const QString &filename)
{
    const QString stripped = stripPath(filename, false);

    for (int i = 0; i < mModel.rowCount(); ++i) {
        const QStandardItem *fileItem = mModel.item(i, COLUMN_FILE);
        if (!fileItem)
            continue;

        QVariantMap fitemdata = fileItem->data().toMap();
        if (stripped == fitemdata[FILENAME].toString() ||
            filename == fitemdata[FILE0].toString()) {
            mModel.removeRow(i);
            break;
        }
    }
}",1,1,gui/resultstree.cpp,ResultsTree.clear:void(QString&),<empty>,,false,502,518,clear,,,1,void(QString&)
111669150682,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::clearRecheckFile(const QString &filename)
{
    for (int i = 0; i < mModel.rowCount(); ++i) {
        const QStandardItem *fileItem = mModel.item(i, COLUMN_FILE);
        if (!fileItem)
            continue;

        QString actualfile((!mCheckPath.isEmpty() && filename.startsWith(mCheckPath)) ? filename.mid(mCheckPath.length() + 1) : filename);
        QVariantMap fitemdata = fileItem->data().toMap();
        QString storedfile = fitemdata[FILENAME].toString();
        storedfile = ((!mCheckPath.isEmpty() && storedfile.startsWith(mCheckPath)) ? storedfile.mid(mCheckPath.length() + 1) : storedfile);
        if (actualfile == storedfile) {
            mModel.removeRow(i);
            break;
        }
    }
}",1,1,gui/resultstree.cpp,ResultsTree.clearRecheckFile:void(QString&),<empty>,,false,520,536,clearRecheckFile,,,1,void(QString&)
111669150683,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::loadSettings()
{
    for (int i = 0; i < mModel.columnCount(); i++) {
        QString temp = QString(SETTINGS_RESULT_COLUMN_WIDTH).arg(i);
        setColumnWidth(i, qMax(20, mSettings->value(temp, 800 / mModel.columnCount()).toInt()));
    }

    mSaveFullPath = mSettings->value(SETTINGS_SAVE_FULL_PATH, false).toBool();
    mSaveAllErrors = mSettings->value(SETTINGS_SAVE_ALL_ERRORS, false).toBool();
    mShowFullPath = mSettings->value(SETTINGS_SHOW_FULL_PATH, false).toBool();

    showIdColumn(mSettings->value(SETTINGS_SHOW_ERROR_ID, true).toBool());
    showInconclusiveColumn(mSettings->value(SETTINGS_INCONCLUSIVE_ERRORS, false).toBool());
}",1,31,gui/resultstree.cpp,ResultsTree.loadSettings:void(),<empty>,,false,539,552,loadSettings,,,1,void()
111669150684,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::saveSettings() const
{
    for (int i = 0; i < mModel.columnCount(); i++) {
        QString temp = QString(SETTINGS_RESULT_COLUMN_WIDTH).arg(i);
        mSettings->setValue(temp, columnWidth(i));
    }
}",1,31,gui/resultstree.cpp,ResultsTree.saveSettings<const>:void(),<empty>,,false,554,560,saveSettings,,,1,void()
111669150685,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::showResults(ShowTypes::ShowType type, bool show)
{
    if (type != ShowTypes::ShowNone && mShowSeverities.isShown(type) != show) {
        mShowSeverities.show(type, show);
        refreshTree();
    }
}",1,1,gui/resultstree.cpp,"ResultsTree.showResults:void(ShowTypes.ShowType,bool)",<empty>,,false,562,568,showResults,,,1,"void(ShowTypes.ShowType,bool)"
111669150686,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::showCppcheckResults(bool show)
{
    mShowCppcheck = show;
    refreshTree();
}",1,1,gui/resultstree.cpp,ResultsTree.showCppcheckResults:void(bool),<empty>,,false,570,574,showCppcheckResults,,,1,void(bool)
111669150687,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::showClangResults(bool show)
{
    mShowClang = show;
    refreshTree();
}",1,1,gui/resultstree.cpp,ResultsTree.showClangResults:void(bool),<empty>,,false,576,580,showClangResults,,,1,void(bool)
111669150688,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::filterResults(const QString& filter)
{
    mFilter = filter;
    refreshTree();
}",1,1,gui/resultstree.cpp,ResultsTree.filterResults:void(QString&),<empty>,,false,582,586,filterResults,,,1,void(QString&)
111669150689,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::showHiddenResults()
{
    //Clear the ""hide"" flag for each item
    mHiddenMessageId.clear();
    refreshTree();
    emit resultsHidden(false);
}",1,1,gui/resultstree.cpp,ResultsTree.showHiddenResults:void(),<empty>,,false,588,594,showHiddenResults,,,1,void()
111669150690,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::refreshTree()
{
    mVisibleErrors = false;
    //Get the amount of files in the tree
    const int filecount = mModel.rowCount();

    for (int i = 0; i < filecount; i++) {
        //Get file i
        QStandardItem *fileItem = mModel.item(i, 0);
        if (!fileItem) {
            continue;
        }

        //Get the amount of errors this file contains
        const int errorcount = fileItem->rowCount();

        //By default it shouldn't be visible
        bool showFile = false;

        for (int j = 0; j < errorcount; j++) {
            //Get the error itself
            QStandardItem *child = fileItem->child(j, 0);
            if (!child) {
                continue;
            }

            //Get error's user data and convert it to QVariantMap
            QVariantMap userdata = child->data().toMap();

            //Check if this error should be hidden
            bool hide = userdata[HIDE].toBool() || mHiddenMessageId.contains(userdata[ERRORID].toString()...",1,1,gui/resultstree.cpp,ResultsTree.refreshTree:void(),<empty>,,false,597,669,refreshTree,,,1,void()
111669150691,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"QStandardItem *ResultsTree::ensureFileItem(const QString &fullpath, const QString &file0, bool hide)
{
    QString name = stripPath(fullpath, false);
    // Since item has path with native separators we must use path with
    // native separators to find it.
    QStandardItem *item = findFileItem(QDir::toNativeSeparators(name));

    if (item) {
        if (!hide)
            setRowHidden(item->row(), QModelIndex(), hide);
        return item;
    }

    // Ensure shown path is with native separators
    name = QDir::toNativeSeparators(name);
    item = createNormalItem(name);
    item->setIcon(QIcon("":images/text-x-generic.png""));

    //Add user data to that item
    QMap<QString, QVariant> itemdata;
    itemdata[FILENAME] = fullpath;
    itemdata[FILE0] = file0;
    item->setData(QVariant(itemdata));
    mModel.appendRow(item);

    setRowHidden(item->row(), QModelIndex(), hide);

    return item;
}",1,1,gui/resultstree.cpp,"ResultsTree.ensureFileItem:QStandardItem(QString&,QString&,bool)",<empty>,,false,671,699,ensureFileItem,,,1,"QStandardItem(QString&,QString&,bool)"
111669150692,METHOD,<empty>,<empty>,"[=]() {
                        tagSelectedItems(QString());
                    }",58,21,gui/resultstree.cpp,gui/resultstree.cpp:<global>.ResultsTree.contextMenuEvent.<lambda>0:void(),<empty>,,false,796,798,<lambda>0,,,1,void()
111669150693,METHOD,<empty>,<empty>,"[=]() {
                        tagSelectedItems(tagstr);
                    }",58,21,gui/resultstree.cpp,gui/resultstree.cpp:<global>.ResultsTree.contextMenuEvent.<lambda>1:void(),<empty>,,false,804,806,<lambda>1,,,1,void()
111669150694,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::contextMenuEvent(QContextMenuEvent * e)
{
    QModelIndex index = indexAt(e->pos());
    if (index.isValid()) {
        bool multipleSelection = false;

        mSelectionModel = selectionModel();
        if (mSelectionModel->selectedRows().count() > 1)
            multipleSelection = true;

        mContextItem = mModel.itemFromIndex(index);

        //Create a new context menu
        QMenu menu(this);

        //Create a signal mapper so we don't have to store data to class
        //member variables
        QSignalMapper signalMapper;

        if (mContextItem && mApplications->getApplicationCount() > 0 && mContextItem->parent()) {
            //Create an action for the application
            int defaultApplicationIndex = mApplications->getDefaultApplication();
            defaultApplicationIndex = std::max(defaultApplicationIndex, 0);
            const Application& app = mApplications->getApplication(defaultApplicationIndex);
            auto *start = new QAc...",1,1,gui/resultstree.cpp,ResultsTree.contextMenuEvent:void(QContextMenuEvent*),<empty>,,false,701,818,contextMenuEvent,,,1,void(QContextMenuEvent*)
111669150695,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::startApplication(const QStandardItem *target, int application)
{
    //If there are no applications specified, tell the user about it
    if (mApplications->getApplicationCount() == 0) {
        QMessageBox msg(QMessageBox::Critical,
                        tr(""Cppcheck""),
                        tr(""No editor application configured.\\n\\n""
                           ""Configure the editor application for Cppcheck in preferences/Applications.""),
                        QMessageBox::Ok,
                        this);
        msg.exec();
        return;
    }

    if (application == -1)
        application = mApplications->getDefaultApplication();

    if (application == -1) {
        QMessageBox msg(QMessageBox::Critical,
                        tr(""Cppcheck""),
                        tr(""No default editor application selected.\\n\\n""
                           ""Please select the default editor application in preferences/Applications.""),
                        QMessageB...",1,1,gui/resultstree.cpp,"ResultsTree.startApplication:void(QStandardItem*,int)",<empty>,,false,820,939,startApplication,,,1,"void(QStandardItem*,int)"
111669150696,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"QString ResultsTree::askFileDir(const QString &file)
{
    QString text = tr(""Could not find file:"") + '\\n' + file + '\\n';
    QString title;
    if (file.indexOf('/')) {
        QString folderName = file.mid(0, file.indexOf('/'));
        text += tr(""Please select the folder '%1'"").arg(folderName);
        title = tr(""Select Directory '%1'"").arg(folderName);
    } else {
        text += tr(""Please select the directory where file is located."");
        title = tr(""Select Directory"");
    }

    QMessageBox msgbox(this);
    msgbox.setWindowTitle(""Cppcheck"");
    msgbox.setText(text);
    msgbox.setIcon(QMessageBox::Warning);
    msgbox.exec();

    QString dir = QFileDialog::getExistingDirectory(this, title,
                                                    getPath(SETTINGS_LAST_SOURCE_PATH),
                                                    QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);

    if (dir.isEmpty())
        return QString();

    // User selected root...",1,60,gui/resultstree.cpp,ResultsTree.askFileDir:QString(QString&),<empty>,,false,941,987,askFileDir,,,1,QString(QString&)
111669150697,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::copy()
{
    if (!mSelectionModel)
        return;

    QString text;
    for (const QModelIndex& index : mSelectionModel->selectedRows()) {
        const QStandardItem *item = mModel.itemFromIndex(index);
        if (!item->parent()) {
            text += item->text() + '\\n';
            continue;
        }
        if (item->parent()->parent())
            item = item->parent();
        QVariantMap itemdata = item->data().toMap();
        if (!itemdata.contains(""id""))
            continue;
        QString inconclusive = itemdata[INCONCLUSIVE].toBool() ? "",inconclusive"" : """";
        text += itemdata[FILENAME].toString() + ':' + QString::number(itemdata[LINE].toInt()) + ':' + QString::number(itemdata[COLUMN].toInt())
                + "": ""
                + QString::fromStdString(severityToString(ShowTypes::ShowTypeToSeverity((ShowTypes::ShowType)itemdata[SEVERITY].toInt()))) + inconclusive
                + "": ""
                + itemdata[MESSAGE].toString()
     ...",1,1,gui/resultstree.cpp,ResultsTree.copy:void(),<empty>,,false,989,1019,copy,,,1,void()
111669150698,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::hideResult()
{
    if (!mSelectionModel)
        return;

    for (QModelIndex index : mSelectionModel->selectedRows()) {
        QStandardItem *item = mModel.itemFromIndex(index);
        //Set the ""hide"" flag for this item
        QVariantMap itemdata = item->data().toMap();
        itemdata[HIDE] = true;
        item->setData(QVariant(itemdata));

        refreshTree();
        emit resultsHidden(true);
    }
}",1,1,gui/resultstree.cpp,ResultsTree.hideResult:void(),<empty>,,false,1021,1036,hideResult,,,1,void()
111669150699,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::recheckSelectedFiles()
{
    if (!mSelectionModel)
        return;

    QStringList selectedItems;
    for (QModelIndex index : mSelectionModel->selectedRows()) {
        QStandardItem *item = mModel.itemFromIndex(index);
        while (item->parent())
            item = item->parent();
        QVariantMap itemdata = item->data().toMap();
        QString currentFile = itemdata[FILENAME].toString();
        if (!currentFile.isEmpty()) {
            QString fileNameWithCheckPath;
            QFileInfo curfileInfo(currentFile);
            if (!curfileInfo.exists() && !mCheckPath.isEmpty() && currentFile.indexOf(mCheckPath) != 0)
                fileNameWithCheckPath = mCheckPath + ""/"" + currentFile;
            else
                fileNameWithCheckPath = currentFile;
            const QFileInfo fileInfo(fileNameWithCheckPath);
            if (!fileInfo.exists()) {
                askFileDir(currentFile);
                return;
            }
            if (Path::is...",1,1,gui/resultstree.cpp,ResultsTree.recheckSelectedFiles:void(),<empty>,,false,1038,1073,recheckSelectedFiles,,,1,void()
111669150700,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::hideAllIdResult()
{
    if (!mContextItem || !mContextItem->parent())
        return;

    // Make sure we are working with the first column
    if (mContextItem->column() != 0)
        mContextItem = mContextItem->parent()->child(mContextItem->row(), 0);
    QVariantMap itemdata = mContextItem->data().toMap();

    QString messageId = itemdata[ERRORID].toString();

    mHiddenMessageId.append(messageId);

    refreshTree();
    emit resultsHidden(true);
}",1,1,gui/resultstree.cpp,ResultsTree.hideAllIdResult:void(),<empty>,,false,1075,1091,hideAllIdResult,,,1,void()
111669150701,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::suppressSelectedIds()
{
    if (!mSelectionModel)
        return;

    QSet<QString> selectedIds;
    for (QModelIndex index : mSelectionModel->selectedRows()) {
        QStandardItem *item = mModel.itemFromIndex(index);
        if (!item->parent())
            continue;
        if (item->parent()->parent())
            item = item->parent();
        QVariantMap itemdata = item->data().toMap();
        if (!itemdata.contains(""id""))
            continue;
        selectedIds << itemdata[ERRORID].toString();
    }

    // delete all errors with selected message Ids
    for (int i = 0; i < mModel.rowCount(); i++) {
        QStandardItem * const file = mModel.item(i, 0);
        for (int j = 0; j < file->rowCount();) {
            QStandardItem *errorItem = file->child(j, 0);
            QVariantMap userdata = errorItem->data().toMap();
            if (selectedIds.contains(userdata[ERRORID].toString())) {
                file->removeRow(j);
            } else {
        ...",1,1,gui/resultstree.cpp,ResultsTree.suppressSelectedIds:void(),<empty>,,false,1093,1129,suppressSelectedIds,,,1,void()
111669150702,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::suppressHash()
{
    if (!mSelectionModel)
        return;

    // Extract selected warnings
    QSet<QStandardItem *> selectedWarnings;
    for (QModelIndex index : mSelectionModel->selectedRows()) {
        QStandardItem *item = mModel.itemFromIndex(index);
        if (!item->parent())
            continue;
        while (item->parent()->parent())
            item = item->parent();
        selectedWarnings.insert(item);
    }

    bool changed = false;
    ProjectFile *projectFile = ProjectFile::getActiveProject();
    for (QStandardItem *item: selectedWarnings) {
        QStandardItem *fileItem = item->parent();
        const QVariantMap itemdata = item->data().toMap();
        if (projectFile && itemdata.contains(HASH)) {
            SuppressionList::Suppression suppression;
            suppression.hash = itemdata[HASH].toULongLong();
            suppression.errorId = itemdata[ERRORID].toString().toStdString();
            suppression.fileName = itemdata[FILENA...",1,1,gui/resultstree.cpp,ResultsTree.suppressHash:void(),<empty>,,false,1131,1168,suppressHash,,,1,void()
111669150703,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::openContainingFolder()
{
    QString filePath = getFilePath(mContextItem, true);
    if (!filePath.isEmpty()) {
        filePath = QFileInfo(filePath).absolutePath();
        QDesktopServices::openUrl(QUrl::fromLocalFile(filePath));
    }
}",1,1,gui/resultstree.cpp,ResultsTree.openContainingFolder:void(),<empty>,,false,1170,1177,openContainingFolder,,,1,void()
111669150704,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::tagSelectedItems(const QString &tag)
{
    if (!mSelectionModel)
        return;
    bool isTagged = false;
    ProjectFile *currentProject = ProjectFile::getActiveProject();
    for (QModelIndex index : mSelectionModel->selectedRows()) {
        QStandardItem *item = mModel.itemFromIndex(index);
        QVariantMap itemdata = item->data().toMap();
        if (itemdata.contains(""tags"")) {
            itemdata[TAGS] = tag;
            item->setData(QVariant(itemdata));
            item->parent()->child(index.row(), COLUMN_TAGS)->setText(tag);
            if (currentProject && itemdata.contains(HASH)) {
                isTagged = true;
                currentProject->setWarningTags(itemdata[HASH].toULongLong(), tag);
            }
        }
    }
    if (isTagged)
        currentProject->write();
}",1,1,gui/resultstree.cpp,ResultsTree.tagSelectedItems:void(QString&),<empty>,,false,1179,1200,tagSelectedItems,,,1,void(QString&)
111669150705,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::context(int application)
{
    startApplication(mContextItem, application);
}",1,1,gui/resultstree.cpp,ResultsTree.context:void(int),<empty>,,false,1202,1205,context,,,1,void(int)
111669150706,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::quickStartApplication(const QModelIndex &index)
{
    startApplication(mModel.itemFromIndex(index));
}",1,1,gui/resultstree.cpp,ResultsTree.quickStartApplication:void(QModelIndex&),<empty>,,false,1207,1210,quickStartApplication,,,1,void(QModelIndex&)
111669150707,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"QString ResultsTree::getFilePath(const QStandardItem *target, bool fullPath)
{
    if (target) {
        // Make sure we are working with the first column
        if (target->column() != 0)
            target = target->parent()->child(target->row(), 0);

        QVariantMap targetdata = target->data().toMap();

        //Replace (file) with filename
        QString file = targetdata[FILENAME].toString();
        QString pathStr = QDir::toNativeSeparators(file);
        if (!fullPath) {
            QFileInfo fi(pathStr);
            pathStr = fi.fileName();
        }

        return pathStr;
    }

    return QString();
}",1,1,gui/resultstree.cpp,"ResultsTree.getFilePath:QString(QStandardItem*,bool)",<empty>,,false,1212,1233,getFilePath,,,1,"QString(QStandardItem*,bool)"
111669150708,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"QString ResultsTree::severityToIcon(Severity severity)
{
    switch (severity) {
    case Severity::error:
        return "":images/dialog-error.png"";
    case Severity::style:
        return "":images/applications-development.png"";
    case Severity::warning:
        return "":images/dialog-warning.png"";
    case Severity::portability:
        return "":images/applications-system.png"";
    case Severity::performance:
        return "":images/utilities-system-monitor.png"";
    case Severity::information:
        return "":images/dialog-information.png"";
    default:
        return QString();
    }
}",1,1,gui/resultstree.cpp,ResultsTree.severityToIcon:QString(Severity),<empty>,,false,1235,1253,severityToIcon,,,1,QString(Severity)
111669150709,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::saveResults(Report *report) const
{
    report->writeHeader();

    for (int i = 0; i < mModel.rowCount(); i++) {
        if (mSaveAllErrors || !isRowHidden(i, QModelIndex()))
            saveErrors(report, mModel.item(i, 0));
    }

    report->writeFooter();
}",1,1,gui/resultstree.cpp,ResultsTree.saveResults<const>:void(Report*),<empty>,,false,1255,1265,saveResults,,,1,void(Report*)
111669150710,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::saveErrors(Report *report, const QStandardItem *fileItem) const
{
    if (!fileItem) {
        return;
    }

    for (int i = 0; i < fileItem->rowCount(); i++) {
        const QStandardItem *error = fileItem->child(i, 0);

        if (!error) {
            continue;
        }

        if (isRowHidden(i, fileItem->index()) && !mSaveAllErrors) {
            continue;
        }

        ErrorItem item;
        readErrorItem(error, &item);

        report->writeError(item);
    }
}",1,1,gui/resultstree.cpp,"ResultsTree.saveErrors<const>:void(Report*,QStandardItem*)",<empty>,,false,1267,1289,saveErrors,,,1,"void(Report*,QStandardItem*)"
111669150711,METHOD,<empty>,<empty>,"[&](const ErrorItem& e) {
        return ErrorItem::sameCID(item, e);
    }",56,5,gui/resultstree.cpp,gui/resultstree.cpp:<global>.indexOf.<lambda>2:ANY(ErrorItem&),<empty>,,false,1293,1295,<lambda>2,,,1,ANY(ErrorItem&)
111669150712,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"static int indexOf(const QList<ErrorItem> &list, const ErrorItem &item)
{
    auto it = std::find_if(list.cbegin(), list.cend(), [&](const ErrorItem& e) {
        return ErrorItem::sameCID(item, e);
    });
    return it == list.cend() ? -1 : static_cast<int>(std::distance(list.cbegin(), it));
}",1,1,gui/resultstree.cpp,"indexOf:int(QList<ErrorItem>&,ErrorItem&)",<empty>,,false,1291,1297,indexOf,,,1,"int(QList<ErrorItem>&,ErrorItem&)"
111669150713,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::updateFromOldReport(const QString &filename)
{
    showColumn(COLUMN_SINCE_DATE);

    QList<ErrorItem> oldErrors;
    XmlReportV2 oldReport(filename, QString());
    if (oldReport.open()) {
        oldErrors = oldReport.read();
        oldReport.close();
    }

    // Read current results..
    for (int i = 0; i < mModel.rowCount(); i++) {
        QStandardItem *fileItem = mModel.item(i,0);
        for (int j = 0; j < fileItem->rowCount(); j++) {
            QStandardItem *error = fileItem->child(j,0);
            ErrorItem errorItem;
            readErrorItem(error, &errorItem);
            const int oldErrorIndex = indexOf(oldErrors, errorItem);
            QVariantMap errordata = error->data().toMap();

            // New error .. set the ""sinceDate"" property
            if (oldErrorIndex >= 0 && !oldErrors[oldErrorIndex].sinceDate.isEmpty()) {
                errordata[SINCEDATE] = oldErrors[oldErrorIndex].sinceDate;
                error->setData(errordata);
...",1,1,gui/resultstree.cpp,ResultsTree.updateFromOldReport:void(QString&),<empty>,,false,1299,1342,updateFromOldReport,,,1,void(QString&)
111669150714,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::readErrorItem(const QStandardItem *error, ErrorItem *item) const
{
    // Get error's user data
    QVariantMap errordata = error->data().toMap();

    item->severity = ShowTypes::ShowTypeToSeverity(ShowTypes::VariantToShowType(errordata[SEVERITY]));
    item->summary = errordata[SUMMARY].toString();
    item->message = errordata[MESSAGE].toString();
    item->errorId = errordata[ERRORID].toString();
    item->cwe = errordata[CWE].toInt();
    item->hash = errordata[HASH].toULongLong();
    item->inconclusive = errordata[INCONCLUSIVE].toBool();
    item->file0 = errordata[FILE0].toString();
    item->sinceDate = errordata[SINCEDATE].toString();
    item->tags = errordata[TAGS].toString();
    item->remark = errordata[REMARK].toString();
    item->classification = error->parent()->child(error->row(), COLUMN_MISRA_CLASSIFICATION)->text();
    item->guideline = error->parent()->child(error->row(), COLUMN_MISRA_GUIDELINE)->text();

    if (error->rowCount() == 0) {
   ...",1,1,gui/resultstree.cpp,"ResultsTree.readErrorItem<const>:void(QStandardItem*,ErrorItem*)",<empty>,,false,1344,1384,readErrorItem,,,1,"void(QStandardItem*,ErrorItem*)"
111669150715,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::updateSettings(bool showFullPath,
                                 bool saveFullPath,
                                 bool saveAllErrors,
                                 bool showErrorId,
                                 bool showInconclusive)
{
    if (mShowFullPath != showFullPath) {
        mShowFullPath = showFullPath;
        refreshFilePaths();
    }

    mSaveFullPath = saveFullPath;
    mSaveAllErrors = saveAllErrors;

    showIdColumn(showErrorId);
    showInconclusiveColumn(showInconclusive);
}",1,1,gui/resultstree.cpp,"ResultsTree.updateSettings:void(bool,bool,bool,bool,bool)",<empty>,,false,1386,1402,updateSettings,,,1,"void(bool,bool,bool,bool,bool)"
111669150716,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::setCheckDirectory(const QString &dir)
{
    mCheckPath = dir;
}",1,1,gui/resultstree.cpp,ResultsTree.setCheckDirectory:void(QString&),<empty>,,false,1404,1407,setCheckDirectory,,,1,void(QString&)
111669150717,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"const QString& ResultsTree::getCheckDirectory() const
{
    return mCheckPath;
}",1,1,gui/resultstree.cpp,ResultsTree.getCheckDirectory<const>:ANY(),<empty>,,false,1410,1413,getCheckDirectory,,,1,ANY()
111669150718,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"QString ResultsTree::stripPath(const QString &path, bool saving) const
{
    if ((!saving && mShowFullPath) || (saving && mSaveFullPath)) {
        return QString(path);
    }

    QDir dir(mCheckPath);
    return dir.relativeFilePath(path);
}",1,1,gui/resultstree.cpp,"ResultsTree.stripPath<const>:QString(QString&,bool)",<empty>,,false,1415,1423,stripPath,,,1,"QString(QString&,bool)"
111669150719,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::refreshFilePaths(QStandardItem *item)
{
    if (!item) {
        return;
    }

    //Mark that this file's path hasn't been updated yet
    bool updated = false;

    //Loop through all errors within this file
    for (int i = 0; i < item->rowCount(); i++) {
        //Get error i
        QStandardItem *error = item->child(i, 0);

        if (!error) {
            continue;
        }

        //Get error's user data and convert it to QVariantMap
        QVariantMap userdata = error->data().toMap();

        //Get list of files
        QString file = userdata[FILENAME].toString();

        //Update this error's text
        error->setText(stripPath(file, false));

        //If this error has backtraces make sure the files list has enough filenames
        if (error->hasChildren()) {
            //Loop through all files within the error
            for (int j = 0; j < error->rowCount(); j++) {
                //Get file
                QStandardItem *child = error->c...",1,1,gui/resultstree.cpp,ResultsTree.refreshFilePaths:void(QStandardItem*),<empty>,,false,1425,1480,refreshFilePaths,,,1,void(QStandardItem*)
111669150720,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::refreshFilePaths()
{
    qDebug(""Refreshing file paths"");

    //Go through all file items (these are parent items that contain the errors)
    for (int i = 0; i < mModel.rowCount(); i++) {
        refreshFilePaths(mModel.item(i, 0));
    }
}",1,1,gui/resultstree.cpp,ResultsTree.refreshFilePaths:void(),<empty>,,false,1482,1490,refreshFilePaths,,,1,void()
111669150721,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"bool ResultsTree::hasVisibleResults() const
{
    return mVisibleErrors;
}",1,1,gui/resultstree.cpp,ResultsTree.hasVisibleResults<const>:bool(),<empty>,,false,1492,1495,hasVisibleResults,,,1,bool()
111669150722,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"bool ResultsTree::hasResults() const
{
    return mModel.rowCount() > 0;
}",1,1,gui/resultstree.cpp,ResultsTree.hasResults<const>:bool(),<empty>,,false,1497,1500,hasResults,,,1,bool()
111669150723,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::translate()
{
    mModel.setHorizontalHeaderLabels(getLabels());
    //TODO go through all the errors in the tree and translate severity and message
}",1,1,gui/resultstree.cpp,ResultsTree.translate:void(),<empty>,,false,1502,1506,translate,,,1,void()
111669150724,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::showIdColumn(bool show)
{
    mShowErrorId = show;
    if (show)
        showColumn(COLUMN_ID);
    else
        hideColumn(COLUMN_ID);
}",1,1,gui/resultstree.cpp,ResultsTree.showIdColumn:void(bool),<empty>,,false,1508,1515,showIdColumn,,,1,void(bool)
111669150725,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::showInconclusiveColumn(bool show)
{
    if (show)
        showColumn(COLUMN_INCONCLUSIVE);
    else
        hideColumn(COLUMN_INCONCLUSIVE);
}",1,1,gui/resultstree.cpp,ResultsTree.showInconclusiveColumn:void(bool),<empty>,,false,1517,1523,showInconclusiveColumn,,,1,void(bool)
111669150726,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"void ResultsTree::currentChanged(const QModelIndex &current, const QModelIndex &previous)
{
    QTreeView::currentChanged(current, previous);
    emit treeSelectionChanged(current);
}",1,1,gui/resultstree.cpp,"ResultsTree.currentChanged:void(QModelIndex&,QModelIndex&)",<empty>,,false,1525,1529,currentChanged,,,1,"void(QModelIndex&,QModelIndex&)"
111669150727,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"bool ResultsTree::isCertReport() const {
    return mReportType == ReportType::certC || mReportType == ReportType::certCpp;
}",1,1,gui/resultstree.cpp,ResultsTree.isCertReport<const>:bool(),<empty>,,false,1531,1533,isCertReport,,,1,bool()
111669150728,METHOD,gui/resultstree.cpp:<global>,TYPE_DECL,"bool ResultsTree::isAutosarMisraReport() const {
    return mReportType == ReportType::autosar ||
           mReportType == ReportType::misraC ||
           mReportType == ReportType::misraCpp2008 ||
           mReportType == ReportType::misraCpp2023;
}",1,1,gui/resultstree.cpp,ResultsTree.isAutosarMisraReport<const>:bool(),<empty>,,false,1535,1540,isAutosarMisraReport,,,1,bool()
111669150729,METHOD,gui/resultstree.h:<global>,TYPE_DECL,<global>,1,1,gui/resultstree.h,gui/resultstree.h:<global>,<empty>,,false,1,541,<global>,,,1,
111669150730,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,<global>,1,1,gui/resultsview.cpp,gui/resultsview.cpp:<global>,<empty>,,false,1,591,<global>,,,1,
111669150731,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"ResultsView::ResultsView(QWidget * parent) :
    QWidget(parent),
    mUI(new Ui::ResultsView),
    mStatistics(new CheckStatistics(this))
{
    mUI->setupUi(this);

    connect(mUI->mTree, &ResultsTree::resultsHidden, this, &ResultsView::resultsHidden);
    connect(mUI->mTree, &ResultsTree::checkSelected, this, &ResultsView::checkSelected);
    connect(mUI->mTree, &ResultsTree::treeSelectionChanged, this, &ResultsView::updateDetails);
    connect(mUI->mTree, &ResultsTree::suppressIds, this, &ResultsView::suppressIds);
    connect(this, &ResultsView::showResults, mUI->mTree, &ResultsTree::showResults);
    connect(this, &ResultsView::showCppcheckResults, mUI->mTree, &ResultsTree::showCppcheckResults);
    connect(this, &ResultsView::showClangResults, mUI->mTree, &ResultsTree::showClangResults);
    connect(this, &ResultsView::collapseAllResults, mUI->mTree, &ResultsTree::collapseAll);
    connect(this, &ResultsView::expandAllResults, mUI->mTree, &ResultsTree::expandAll);
    connect...",1,1,gui/resultsview.cpp,ResultsView.ResultsView:ANY(QWidget*),<empty>,,false,78,97,ResultsView,,,1,ResultsView.ResultsView:ANY(QWidget*)(QWidget*)
111669150732,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::initialize(QSettings *settings, ApplicationList *list, ThreadHandler *checkThreadHandler)
{
    mUI->mProgress->setMinimum(0);
    mUI->mProgress->setVisible(false);
    mUI->mLabelCriticalErrors->setVisible(false);

    CodeEditorStyle theStyle(CodeEditorStyle::loadSettings(settings));
    mUI->mCode->setStyle(theStyle);

    QByteArray state = settings->value(SETTINGS_MAINWND_SPLITTER_STATE).toByteArray();
    mUI->mVerticalSplitter->restoreState(state);
    mShowNoErrorsMessage = settings->value(SETTINGS_SHOW_NO_ERRORS, true).toBool();

    mUI->mTree->initialize(settings, list, checkThreadHandler);
}",1,39,gui/resultsview.cpp,"ResultsView.initialize:void(QSettings*,ApplicationList*,ThreadHandler*)",<empty>,,false,99,113,initialize,,,1,"void(QSettings*,ApplicationList*,ThreadHandler*)"
111669150733,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"ResultsView::~ResultsView()
{
    delete mUI;
    delete mCheckSettings;
}",1,1,gui/resultsview.cpp,ResultsView.~ResultsView:ANY(),<empty>,,false,115,119,~ResultsView,,,1,ANY()
111669150734,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::clear(bool results)
{
    if (results) {
        mUI->mTree->clear();
    }

    mUI->mDetails->setText(QString());

    mStatistics->clear();
    delete mCheckSettings;
    mCheckSettings = nullptr;

    //Clear the progressbar
    mUI->mProgress->setMaximum(PROGRESS_MAX);
    mUI->mProgress->setValue(0);
    mUI->mProgress->setFormat(""%p%"");

    mUI->mLabelCriticalErrors->setVisible(false);

    mSuccess = false;
}",1,31,gui/resultsview.cpp,ResultsView.clear:void(bool),<empty>,,false,121,141,clear,,,1,void(bool)
111669150735,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::clear(const QString &filename)
{
    mUI->mTree->clear(filename);
}",1,1,gui/resultsview.cpp,ResultsView.clear:void(QString&),<empty>,,false,143,146,clear,,,1,void(QString&)
111669150736,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::clearRecheckFile(const QString &filename)
{
    mUI->mTree->clearRecheckFile(filename);
}",1,1,gui/resultsview.cpp,ResultsView.clearRecheckFile:void(QString&),<empty>,,false,148,151,clearRecheckFile,,,1,void(QString&)
111669150737,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"const ShowTypes & ResultsView::getShowTypes() const
{
    return mUI->mTree->mShowSeverities;
}",1,1,gui/resultsview.cpp,ResultsView.getShowTypes<const>:ShowTypes&(),<empty>,,false,153,156,getShowTypes,,,1,ShowTypes&()
111669150738,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::setReportType(ReportType reportType) {
    mUI->mTree->setReportType(reportType);
}",1,1,gui/resultsview.cpp,ResultsView.setReportType:void(ReportType),<empty>,,false,158,160,setReportType,,,1,void(ReportType)
111669150739,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::progress(int value, const QString& description)
{
    mUI->mProgress->setValue(value);
    mUI->mProgress->setFormat(QString(""%p% (%1)"").arg(description));
}",1,1,gui/resultsview.cpp,"ResultsView.progress:void(int,QString&)",<empty>,,false,162,166,progress,,,1,"void(int,QString&)"
111669150740,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::error(const ErrorItem &item)
{
    if (item.severity == Severity::internal && (item.errorId == ""logChecker"" || item.errorId.endsWith(""-logChecker""))) {
        mStatistics->addChecker(item.message);
        return;
    }

    handleCriticalError(item);

    if (item.severity == Severity::internal)
        return;

    if (mUI->mTree->addErrorItem(item)) {
        emit gotResults();
        mStatistics->addItem(item.tool(), ShowTypes::SeverityToShowType(item.severity));
    }
}",1,1,gui/resultsview.cpp,ResultsView.error:void(ErrorItem&),<empty>,,false,168,184,error,,,1,void(ErrorItem&)
111669150741,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::filterResults(const QString& filter)
{
    mUI->mTree->filterResults(filter);
}",1,1,gui/resultsview.cpp,ResultsView.filterResults:void(QString&),<empty>,,false,186,189,filterResults,,,1,void(QString&)
111669150742,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::saveStatistics(const QString &filename) const
{
    QFile f(filename);
    if (!f.open(QIODevice::Text | QIODevice::Append))
        return;
    QTextStream ts(&f);
    ts <<  '[' << QDate::currentDate().toString(""dd.MM.yyyy"") << ""]\\n"";
    ts << QDateTime::currentMSecsSinceEpoch() << '\\n';
    for (const QString& tool : mStatistics->getTools()) {
        ts << tool << ""-error:"" << mStatistics->getCount(tool, ShowTypes::ShowErrors) << '\\n';
        ts << tool << ""-warning:"" << mStatistics->getCount(tool, ShowTypes::ShowWarnings) << '\\n';
        ts << tool << ""-style:"" << mStatistics->getCount(tool, ShowTypes::ShowStyle) << '\\n';
        ts << tool << ""-performance:"" << mStatistics->getCount(tool, ShowTypes::ShowPerformance) << '\\n';
        ts << tool << ""-portability:"" << mStatistics->getCount(tool, ShowTypes::ShowPortability) << '\\n';
    }
}",1,1,gui/resultsview.cpp,ResultsView.saveStatistics<const>:void(QString&),<empty>,,false,191,206,saveStatistics,,,1,void(QString&)
111669150743,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::updateFromOldReport(const QString &filename) const
{
    mUI->mTree->updateFromOldReport(filename);
}",1,1,gui/resultsview.cpp,ResultsView.updateFromOldReport<const>:void(QString&),<empty>,,false,208,211,updateFromOldReport,,,1,void(QString&)
111669150744,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::save(const QString &filename, Report::Type type, const QString& productName) const
{
    Report *report = nullptr;

    switch (type) {
    case Report::CSV:
        report = new CsvReport(filename);
        break;
    case Report::TXT:
        report = new TxtReport(filename);
        break;
    case Report::XMLV2:
        report = new XmlReportV2(filename, productName);
        break;
    }

    if (report) {
        if (report->create())
            mUI->mTree->saveResults(report);
        else {
            QMessageBox msgBox;
            msgBox.setText(tr(""Failed to save the report.""));
            msgBox.setIcon(QMessageBox::Critical);
            msgBox.exec();
        }
        delete report;
        report = nullptr;
    } else {
        QMessageBox msgBox;
        msgBox.setText(tr(""Failed to save the report.""));
        msgBox.setIcon(QMessageBox::Critical);
        msgBox.exec();
    }
}",1,1,gui/resultsview.cpp,"ResultsView.save<const>:void(QString&,Report.Type,QString&)",<empty>,,false,213,246,save,,,1,"void(QString&,Report.Type,QString&)"
111669150745,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::print()
{
    QPrinter printer;
    QPrintDialog dialog(&printer, this);
    dialog.setWindowTitle(tr(""Print Report""));
    if (dialog.exec() != QDialog::Accepted)
        return;

    print(&printer);
}",1,1,gui/resultsview.cpp,ResultsView.print:void(),<empty>,,false,248,257,print,,,1,void()
111669150746,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::printPreview()
{
    QPrinter printer;
    QPrintPreviewDialog dialog(&printer, this);
    connect(&dialog, SIGNAL(paintRequested(QPrinter*)), SLOT(print(QPrinter*)));
    dialog.exec();
}",1,1,gui/resultsview.cpp,ResultsView.printPreview:void(),<empty>,,false,259,265,printPreview,,,1,void()
111669150747,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::print(QPrinter* printer) const
{
    if (!hasResults()) {
        QMessageBox msgBox;
        msgBox.setText(tr(""No errors found, nothing to print.""));
        msgBox.setIcon(QMessageBox::Critical);
        msgBox.exec();
        return;
    }

    PrintableReport report;
    mUI->mTree->saveResults(&report);
    QTextDocument doc(report.getFormattedReportText());
    doc.print(printer);
}",1,1,gui/resultsview.cpp,ResultsView.print<const>:void(QPrinter*),<empty>,,false,267,281,print,,,1,void(QPrinter*)
111669150748,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::updateSettings(bool showFullPath,
                                 bool saveFullPath,
                                 bool saveAllErrors,
                                 bool showNoErrorsMessage,
                                 bool showErrorId,
                                 bool showInconclusive)
{
    mUI->mTree->updateSettings(showFullPath, saveFullPath, saveAllErrors, showErrorId, showInconclusive);
    mShowNoErrorsMessage = showNoErrorsMessage;
}",1,1,gui/resultsview.cpp,"ResultsView.updateSettings:void(bool,bool,bool,bool,bool,bool)",<empty>,,false,283,292,updateSettings,,,1,"void(bool,bool,bool,bool,bool,bool)"
111669150749,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::updateStyleSetting(QSettings *settings)
{
    CodeEditorStyle theStyle(CodeEditorStyle::loadSettings(settings));
    mUI->mCode->setStyle(theStyle);
}",1,1,gui/resultsview.cpp,ResultsView.updateStyleSetting:void(QSettings*),<empty>,,false,294,298,updateStyleSetting,,,1,void(QSettings*)
111669150750,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::setCheckDirectory(const QString &dir)
{
    mUI->mTree->setCheckDirectory(dir);
}",1,1,gui/resultsview.cpp,ResultsView.setCheckDirectory:void(QString&),<empty>,,false,300,303,setCheckDirectory,,,1,void(QString&)
111669150751,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"QString ResultsView::getCheckDirectory() const
{
    return mUI->mTree->getCheckDirectory();
}",1,1,gui/resultsview.cpp,ResultsView.getCheckDirectory<const>:QString(),<empty>,,false,305,308,getCheckDirectory,,,1,QString()
111669150752,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::setCheckSettings(const Settings &settings)
{
    delete mCheckSettings;
    mCheckSettings = new Settings;
    *mCheckSettings = settings;
}",1,1,gui/resultsview.cpp,ResultsView.setCheckSettings:void(Settings&),<empty>,,false,310,315,setCheckSettings,,,1,void(Settings&)
111669150753,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::checkingStarted(int count)
{
    mSuccess = true;
    mUI->mProgress->setVisible(true);
    mUI->mProgress->setMaximum(PROGRESS_MAX);
    mUI->mProgress->setValue(0);
    mUI->mProgress->setFormat(tr(""%p% (%1 of %2 files checked)"").arg(0).arg(count));
}",1,31,gui/resultsview.cpp,ResultsView.checkingStarted:void(int),<empty>,,false,317,324,checkingStarted,,,1,void(int)
111669150754,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::checkingFinished()
{
    mUI->mProgress->setVisible(false);
    mUI->mProgress->setFormat(""%p%"");

    {
        Settings checkSettings;
        const std::set<std::string> activeCheckers = mStatistics->getActiveCheckers();
        CheckersReport checkersReport(mCheckSettings ? *mCheckSettings : checkSettings, activeCheckers);
        mStatistics->setCheckersReport(QString::fromStdString(checkersReport.getReport(mCriticalErrors.toStdString())));
    }

    // TODO: Items can be mysteriously hidden when checking is finished, this function
    // call should be redundant but it ""unhides"" the wrongly hidden items.
    mUI->mTree->refreshTree();

    //Should we inform user of non visible/not found errors?
    if (mShowNoErrorsMessage) {
        //Tell user that we found no errors
        if (!hasResults()) {
            QMessageBox msg(QMessageBox::Information,
                            tr(""Cppcheck""),
                            tr(""No errors found.""),
            ...",1,1,gui/resultsview.cpp,ResultsView.checkingFinished:void(),<empty>,,false,326,366,checkingFinished,,,1,void()
111669150755,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"bool ResultsView::hasVisibleResults() const
{
    return mUI->mTree->hasVisibleResults();
}",1,1,gui/resultsview.cpp,ResultsView.hasVisibleResults<const>:bool(),<empty>,,false,368,371,hasVisibleResults,,,1,bool()
111669150756,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"bool ResultsView::hasResults() const
{
    return mUI->mTree->hasResults();
}",1,1,gui/resultsview.cpp,ResultsView.hasResults<const>:bool(),<empty>,,false,373,376,hasResults,,,1,bool()
111669150757,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::saveSettings(QSettings *settings)
{
    mUI->mTree->saveSettings();
    QByteArray state = mUI->mVerticalSplitter->saveState();
    settings->setValue(SETTINGS_MAINWND_SPLITTER_STATE, state);
    mUI->mVerticalSplitter->restoreState(state);
}",1,23,gui/resultsview.cpp,ResultsView.saveSettings:void(QSettings*),<empty>,,false,378,384,saveSettings,,,1,void(QSettings*)
111669150758,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::translate()
{
    mUI->retranslateUi(this);
    mUI->mTree->translate();
}",1,1,gui/resultsview.cpp,ResultsView.translate:void(),<empty>,,false,386,390,translate,,,1,void()
111669150759,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::disableProgressbar()
{
    mUI->mProgress->setEnabled(false);
}",1,1,gui/resultsview.cpp,ResultsView.disableProgressbar:void(),<empty>,,false,392,395,disableProgressbar,,,1,void()
111669150760,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::readErrorsXml(const QString &filename)
{
    mSuccess = false; // Don't know if results come from an aborted analysis

    const int version = XmlReport::determineVersion(filename);
    if (version == 0) {
        QMessageBox msgBox;
        msgBox.setText(tr(""Failed to read the report.""));
        msgBox.setIcon(QMessageBox::Critical);
        msgBox.exec();
        return;
    }
    if (version == 1) {
        QMessageBox msgBox;
        msgBox.setText(tr(""XML format version 1 is no longer supported.""));
        msgBox.setIcon(QMessageBox::Critical);
        msgBox.exec();
        return;
    }

    XmlReportV2 report(filename, QString());
    QList<ErrorItem> errors;
    if (report.open()) {
        errors = report.read();
    } else {
        QMessageBox msgBox;
        msgBox.setText(tr(""Failed to read the report.""));
        msgBox.setIcon(QMessageBox::Critical);
        msgBox.exec();
    }

    for (const ErrorItem& item : errors) {
        handleCriticalEr...",1,1,gui/resultsview.cpp,ResultsView.readErrorsXml:void(QString&),<empty>,,false,397,441,readErrorsXml,,,1,void(QString&)
111669150761,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::updateDetails(const QModelIndex &index)
{
    const auto *model = qobject_cast<const QStandardItemModel*>(mUI->mTree->model());
    QStandardItem *item = model->itemFromIndex(index);

    if (!item) {
        mUI->mCode->clear();
        mUI->mDetails->setText(QString());
        return;
    }

    // Make sure we are working with the first column
    if (item->parent() && item->column() != 0)
        item = item->parent()->child(item->row(), 0);

    QVariantMap itemdata = item->data().toMap();

    // If there is no severity data then it is a parent item without summary and message
    if (!itemdata.contains(""severity"")) {
        mUI->mCode->clear();
        mUI->mDetails->setText(QString());
        return;
    }

    const QString message = itemdata[""message""].toString();
    QString formattedMsg = message;

    const QString file0 = itemdata[""file0""].toString();
    if (!file0.isEmpty() && Path::isHeader(itemdata[""file""].toString().toStdString()))
        for...",1,1,gui/resultsview.cpp,ResultsView.updateDetails:void(QModelIndex&),<empty>,,false,443,506,updateDetails,,,1,void(QModelIndex&)
111669150762,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::log(const QString &str)
{
    mUI->mListLog->addItem(str);
}",1,1,gui/resultsview.cpp,ResultsView.log:void(QString&),<empty>,,false,508,511,log,,,1,void(QString&)
111669150763,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::debugError(const ErrorItem &item)
{
    mUI->mListLog->addItem(item.toString());
}",1,1,gui/resultsview.cpp,ResultsView.debugError:void(ErrorItem&),<empty>,,false,513,516,debugError,,,1,void(ErrorItem&)
111669150764,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::logClear()
{
    mUI->mListLog->clear();
}",1,1,gui/resultsview.cpp,ResultsView.logClear:void(),<empty>,,false,518,521,logClear,,,1,void()
111669150765,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::logCopyEntry()
{
    const QListWidgetItem * item = mUI->mListLog->currentItem();
    if (nullptr != item) {
        QClipboard *clipboard = QApplication::clipboard();
        clipboard->setText(item->text());
    }
}",1,1,gui/resultsview.cpp,ResultsView.logCopyEntry:void(),<empty>,,false,523,530,logCopyEntry,,,1,void()
111669150766,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::logCopyComplete()
{
    QString logText;
    for (int i=0; i < mUI->mListLog->count(); ++i) {
        const QListWidgetItem * item = mUI->mListLog->item(i);
        if (nullptr != item) {
            logText += item->text();
        }
    }
    QClipboard *clipboard = QApplication::clipboard();
    clipboard->setText(logText);
}",1,1,gui/resultsview.cpp,ResultsView.logCopyComplete:void(),<empty>,,false,532,543,logCopyComplete,,,1,void()
111669150767,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::on_mListLog_customContextMenuRequested(const QPoint &pos)
{
    if (mUI->mListLog->count() <= 0)
        return;

    const QPoint globalPos = mUI->mListLog->mapToGlobal(pos);

    QMenu contextMenu;
    contextMenu.addAction(tr(""Clear Log""), this, SLOT(logClear()));
    contextMenu.addAction(tr(""Copy this Log entry""), this, SLOT(logCopyEntry()));
    contextMenu.addAction(tr(""Copy complete Log""), this, SLOT(logCopyComplete()));

    contextMenu.exec(globalPos);
}",1,1,gui/resultsview.cpp,ResultsView.on_mListLog_customContextMenuRequested:void(QPoint&),<empty>,,false,545,558,on_mListLog_customContextMenuRequested,,,1,void(QPoint&)
111669150768,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::stopAnalysis()
{
    mSuccess = false;
    mUI->mLabelCriticalErrors->setText(tr(""Analysis was stopped""));
    mUI->mLabelCriticalErrors->setVisible(true);
}",1,1,gui/resultsview.cpp,ResultsView.stopAnalysis:void(),<empty>,,false,560,565,stopAnalysis,,,1,void()
111669150769,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"void ResultsView::handleCriticalError(const ErrorItem &item)
{
    if (ErrorLogger::isCriticalErrorId(item.errorId.toStdString())) {
        if (!mCriticalErrors.contains(item.errorId)) {
            if (!mCriticalErrors.isEmpty())
                mCriticalErrors += "","";
            mCriticalErrors += item.errorId;
            if (item.severity == Severity::internal)
                mCriticalErrors += "" (suppressed)"";
        }
        QString msg = tr(""There was a critical error with id '%1'"").arg(item.errorId);
        if (!item.file0.isEmpty())
            msg += "", "" + tr(""when checking %1"").arg(item.file0);
        else
            msg += "", "" + tr(""when checking a file"");
        msg += "". "" + tr(""Analysis was aborted."");
        mUI->mLabelCriticalErrors->setText(msg);
        mUI->mLabelCriticalErrors->setVisible(true);
        mSuccess = false;
    }
}",1,1,gui/resultsview.cpp,ResultsView.handleCriticalError:void(ErrorItem&),<empty>,,false,567,587,handleCriticalError,,,1,void(ErrorItem&)
111669150770,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,"bool ResultsView::isSuccess() const {
    return mSuccess;
}",1,1,gui/resultsview.cpp,ResultsView.isSuccess<const>:bool(),<empty>,,false,589,591,isSuccess,,,1,bool()
111669150771,METHOD,gui/resultsview.h:<global>,TYPE_DECL,<global>,1,1,gui/resultsview.h,gui/resultsview.h:<global>,<empty>,,false,1,399,<global>,,,1,
111669150772,METHOD,gui/scratchpad.cpp:<global>,TYPE_DECL,"ScratchPad::ScratchPad(MainWindow& mainWindow)
    : QDialog(&mainWindow)
    , mUI(new Ui::ScratchPad)
    , mMainWindow(mainWindow)
{
    mUI->setupUi(this);

    connect(mUI->mCheckButton, &QPushButton::clicked, this, &ScratchPad::checkButtonClicked);
}",1,1,gui/scratchpad.cpp,ScratchPad.ScratchPad:ANY(MainWindow&),<empty>,,false,30,38,ScratchPad,,,1,ScratchPad.ScratchPad:ANY(MainWindow&)(MainWindow&)
111669150773,METHOD,gui/scratchpad.cpp:<global>,TYPE_DECL,<global>,1,1,gui/scratchpad.cpp,gui/scratchpad.cpp:<global>,<empty>,,false,1,56,<global>,,,1,
111669150774,METHOD,gui/scratchpad.cpp:<global>,TYPE_DECL,"ScratchPad::~ScratchPad()
{
    delete mUI;
}",1,1,gui/scratchpad.cpp,ScratchPad.~ScratchPad:ANY(),<empty>,,false,40,43,~ScratchPad,,,1,ANY()
111669150775,METHOD,gui/scratchpad.cpp:<global>,TYPE_DECL,"void ScratchPad::translate()
{
    mUI->retranslateUi(this);
}",1,1,gui/scratchpad.cpp,ScratchPad.translate:void(),<empty>,,false,45,48,translate,,,1,void()
111669150776,METHOD,gui/scratchpad.cpp:<global>,TYPE_DECL,"void ScratchPad::checkButtonClicked()
{
    QString filename = mUI->lineEdit->text();
    if (filename.isEmpty())
        filename = ""test.cpp"";
    mMainWindow.analyzeCode(mUI->plainTextEdit->toPlainText(), filename);
}",1,1,gui/scratchpad.cpp,ScratchPad.checkButtonClicked:void(),<empty>,,false,50,56,checkButtonClicked,,,1,void()
111669150777,METHOD,gui/scratchpad.h:<global>,TYPE_DECL,<global>,1,22,gui/scratchpad.h,gui/scratchpad.h:<global>,<empty>,,false,1,60,<global>,,,1,
111669150778,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"SettingsDialog::SettingsDialog(ApplicationList *list,
                               TranslationHandler *translator,
                               bool premium,
                               QWidget *parent) :
    QDialog(parent),
    mApplications(list),
    mTempApplications(new ApplicationList(this)),
    mTranslator(translator),
    mUI(new Ui::Settings),
    mPremium(premium)
{
    mUI->setupUi(this);
    mUI->mPythonPathWarning->setStyleSheet(""color: red"");
    QSettings settings;
    mTempApplications->copy(list);

    mUI->mJobs->setText(settings.value(SETTINGS_CHECK_THREADS, 1).toString());
    mUI->mForce->setCheckState(boolToCheckState(settings.value(SETTINGS_CHECK_FORCE, false).toBool()));
    mUI->mShowFullPath->setCheckState(boolToCheckState(settings.value(SETTINGS_SHOW_FULL_PATH, false).toBool()));
    mUI->mShowNoErrorsMessage->setCheckState(boolToCheckState(settings.value(SETTINGS_SHOW_NO_ERRORS, false).toBool()));
    mUI->mShowDebugWarnings->setCheckState(boolTo...",1,39,gui/settingsdialog.cpp,"SettingsDialog.SettingsDialog:ANY(ApplicationList*,TranslationHandler*,bool,QWidget*)",<empty>,,false,50,130,SettingsDialog,,,1,"SettingsDialog.SettingsDialog:ANY(ApplicationList*,TranslationHandler*,bool,QWidget*)(ApplicationList*,TranslationHandler*,bool,QWidget*)"
111669150779,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,<global>,1,1,gui/settingsdialog.cpp,gui/settingsdialog.cpp:<global>,<empty>,,false,1,419,<global>,,,1,
111669150780,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"SettingsDialog::~SettingsDialog()
{
    saveSettings();
    delete mCurrentStyle;
    delete mUI;
}",1,1,gui/settingsdialog.cpp,SettingsDialog.~SettingsDialog:ANY(),<empty>,,false,132,137,~SettingsDialog,,,1,ANY()
111669150781,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"void SettingsDialog::initTranslationsList()
{
    const QString current = mTranslator->getCurrentLanguage();
    for (const TranslationInfo& translation : mTranslator->getTranslations()) {
        auto *item = new QListWidgetItem;
        item->setText(translation.mName);
        item->setData(mLangCodeRole, QVariant(translation.mCode));
        mUI->mListLanguages->addItem(item);
        if (translation.mCode == current || translation.mCode == current.mid(0, 2))
            mUI->mListLanguages->setCurrentItem(item);
    }
}",1,1,gui/settingsdialog.cpp,SettingsDialog.initTranslationsList:void(),<empty>,,false,139,150,initTranslationsList,,,1,void()
111669150782,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"Qt::CheckState SettingsDialog::boolToCheckState(bool yes)
{
    if (yes) {
        return Qt::Checked;
    }
    return Qt::Unchecked;
}",1,1,gui/settingsdialog.cpp,SettingsDialog.boolToCheckState:CheckState(bool),<empty>,,false,152,158,boolToCheckState,,,1,CheckState(bool)
111669150783,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"bool SettingsDialog::checkStateToBool(Qt::CheckState state)
{
    return state == Qt::Checked;
}",1,1,gui/settingsdialog.cpp,SettingsDialog.checkStateToBool:bool(Qt.CheckState),<empty>,,false,160,163,checkStateToBool,,,1,bool(Qt.CheckState)
111669150784,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"void SettingsDialog::loadSettings()
{
    QSettings settings;
    resize(settings.value(SETTINGS_CHECK_DIALOG_WIDTH, 800).toInt(),
           settings.value(SETTINGS_CHECK_DIALOG_HEIGHT, 600).toInt());
}",1,26,gui/settingsdialog.cpp,SettingsDialog.loadSettings:void(),<empty>,,false,166,171,loadSettings,,,1,void()
111669150785,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"void SettingsDialog::saveSettings() const
{
    QSettings settings;
    settings.setValue(SETTINGS_CHECK_DIALOG_WIDTH, size().width());
    settings.setValue(SETTINGS_CHECK_DIALOG_HEIGHT, size().height());
}",1,22,gui/settingsdialog.cpp,SettingsDialog.saveSettings<const>:void(),<empty>,,false,173,178,saveSettings,,,1,void()
111669150786,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"void SettingsDialog::saveSettingValues() const
{
    int jobs = mUI->mJobs->text().toInt();
    if (jobs <= 0) {
        jobs = 1;
    }

    QSettings settings;
    settings.setValue(SETTINGS_CHECK_THREADS, jobs);
    saveCheckboxValue(&settings, mUI->mForce, SETTINGS_CHECK_FORCE);
    saveCheckboxValue(&settings, mUI->mSaveAllErrors, SETTINGS_SAVE_ALL_ERRORS);
    saveCheckboxValue(&settings, mUI->mSaveFullPath, SETTINGS_SAVE_FULL_PATH);
    saveCheckboxValue(&settings, mUI->mShowFullPath, SETTINGS_SHOW_FULL_PATH);
    saveCheckboxValue(&settings, mUI->mShowNoErrorsMessage, SETTINGS_SHOW_NO_ERRORS);
    saveCheckboxValue(&settings, mUI->mShowDebugWarnings, SETTINGS_SHOW_DEBUG_WARNINGS);
    saveCheckboxValue(&settings, mUI->mInlineSuppressions, SETTINGS_INLINE_SUPPRESSIONS);
    saveCheckboxValue(&settings, mUI->mEnableInconclusive, SETTINGS_INCONCLUSIVE_ERRORS);
    saveCheckboxValue(&settings, mUI->mShowStatistics, SETTINGS_SHOW_STATISTICS);
    saveCheckboxValue(&settings, mUI-...",1,22,gui/settingsdialog.cpp,SettingsDialog.saveSettingValues<const>:void(),<empty>,,false,180,215,saveSettingValues,,,1,void()
111669150787,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"void SettingsDialog::saveCheckboxValue(QSettings *settings, const QCheckBox *box,
                                       const QString &name)
{
    settings->setValue(name, checkStateToBool(box->checkState()));
}",1,1,gui/settingsdialog.cpp,"SettingsDialog.saveCheckboxValue:void(QSettings*,QCheckBox*,QString&)",<empty>,,false,217,221,saveCheckboxValue,,,1,"void(QSettings*,QCheckBox*,QString&)"
111669150788,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"void SettingsDialog::validateEditPythonPath()
{
    const auto pythonPath = mUI->mEditPythonPath->text();
    if (pythonPath.isEmpty()) {
        mUI->mEditPythonPath->setStyleSheet("""");
        mUI->mPythonPathWarning->hide();
        return;
    }

    QFileInfo pythonPathInfo(pythonPath);
    if (!pythonPathInfo.exists() ||
        !pythonPathInfo.isFile() ||
        !pythonPathInfo.isExecutable()) {
        mUI->mEditPythonPath->setStyleSheet(""QLineEdit {border: 1px solid red}"");
        mUI->mPythonPathWarning->setText(tr(""The executable file \\""%1\\"" is not available"").arg(pythonPath));
        mUI->mPythonPathWarning->show();
    } else {
        mUI->mEditPythonPath->setStyleSheet("""");
        mUI->mPythonPathWarning->hide();
    }
}",1,1,gui/settingsdialog.cpp,SettingsDialog.validateEditPythonPath:void(),<empty>,,false,223,243,validateEditPythonPath,,,1,void()
111669150789,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"void SettingsDialog::addApplication()
{
    Application app;
    ApplicationDialog dialog(tr(""Add a new application""), app, this);

    if (dialog.exec() == QDialog::Accepted) {
        mTempApplications->addApplication(app);
        mUI->mListWidget->addItem(app.getName());
    }
}",1,1,gui/settingsdialog.cpp,SettingsDialog.addApplication:void(),<empty>,,false,245,254,addApplication,,,1,void()
111669150790,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"void SettingsDialog::removeApplication()
{
    for (QListWidgetItem *item : mUI->mListWidget->selectedItems()) {
        const int removeIndex = mUI->mListWidget->row(item);
        const int currentDefault = mTempApplications->getDefaultApplication();
        mTempApplications->removeApplication(removeIndex);
        if (removeIndex == currentDefault)
            // If default app is removed set default to unknown
            mTempApplications->setDefault(-1);
        else if (removeIndex < currentDefault)
            // Move default app one up if earlier app was removed
            mTempApplications->setDefault(currentDefault - 1);
    }
    mUI->mListWidget->clear();
    populateApplicationList();
}",1,1,gui/settingsdialog.cpp,SettingsDialog.removeApplication:void(),<empty>,,false,256,271,removeApplication,,,1,void()
111669150791,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"void SettingsDialog::editApplication()
{
    for (QListWidgetItem *item : mUI->mListWidget->selectedItems()) {
        const int row = mUI->mListWidget->row(item);
        Application& app = mTempApplications->getApplication(row);
        ApplicationDialog dialog(tr(""Modify an application""), app, this);

        if (dialog.exec() == QDialog::Accepted) {
            QString name = app.getName();
            if (mTempApplications->getDefaultApplication() == row)
                name += tr("" [Default]"");
            item->setText(name);
        }
    }
}",1,1,gui/settingsdialog.cpp,SettingsDialog.editApplication:void(),<empty>,,false,273,287,editApplication,,,1,void()
111669150792,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"void SettingsDialog::defaultApplication()
{
    QList<QListWidgetItem *> selected = mUI->mListWidget->selectedItems();
    if (!selected.isEmpty()) {
        const int index = mUI->mListWidget->row(selected[0]);
        mTempApplications->setDefault(index);
        mUI->mListWidget->clear();
        populateApplicationList();
    }
}",1,1,gui/settingsdialog.cpp,SettingsDialog.defaultApplication:void(),<empty>,,false,289,298,defaultApplication,,,1,void()
111669150793,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"void SettingsDialog::populateApplicationList()
{
    const int defapp = mTempApplications->getDefaultApplication();
    for (int i = 0; i < mTempApplications->getApplicationCount(); i++) {
        const Application& app = mTempApplications->getApplication(i);
        QString name = app.getName();
        if (i == defapp) {
            name += "" "";
            name += tr(""[Default]"");
        }
        mUI->mListWidget->addItem(name);
    }

    // Select default application, or if there is no default app then the
    // first item.
    if (defapp == -1)
        mUI->mListWidget->setCurrentRow(0);
    else {
        if (mTempApplications->getApplicationCount() > defapp)
            mUI->mListWidget->setCurrentRow(defapp);
        else
            mUI->mListWidget->setCurrentRow(0);
    }
}",1,1,gui/settingsdialog.cpp,SettingsDialog.populateApplicationList:void(),<empty>,,false,300,323,populateApplicationList,,,1,void()
111669150794,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"void SettingsDialog::ok()
{
    mApplications->copy(mTempApplications);
    accept();
}",1,1,gui/settingsdialog.cpp,SettingsDialog.ok:void(),<empty>,,false,325,329,ok,,,1,void()
111669150795,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"bool SettingsDialog::showFullPath() const
{
    return checkStateToBool(mUI->mShowFullPath->checkState());
}",1,1,gui/settingsdialog.cpp,SettingsDialog.showFullPath<const>:bool(),<empty>,,false,331,334,showFullPath,,,1,bool()
111669150796,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"bool SettingsDialog::saveFullPath() const
{
    return checkStateToBool(mUI->mSaveFullPath->checkState());
}",1,1,gui/settingsdialog.cpp,SettingsDialog.saveFullPath<const>:bool(),<empty>,,false,336,339,saveFullPath,,,1,bool()
111669150797,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"bool SettingsDialog::saveAllErrors() const
{
    return checkStateToBool(mUI->mSaveAllErrors->checkState());
}",1,1,gui/settingsdialog.cpp,SettingsDialog.saveAllErrors<const>:bool(),<empty>,,false,341,344,saveAllErrors,,,1,bool()
111669150798,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"bool SettingsDialog::showNoErrorsMessage() const
{
    return checkStateToBool(mUI->mShowNoErrorsMessage->checkState());
}",1,1,gui/settingsdialog.cpp,SettingsDialog.showNoErrorsMessage<const>:bool(),<empty>,,false,346,349,showNoErrorsMessage,,,1,bool()
111669150799,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"bool SettingsDialog::showErrorId() const
{
    return checkStateToBool(mUI->mShowErrorId->checkState());
}",1,1,gui/settingsdialog.cpp,SettingsDialog.showErrorId<const>:bool(),<empty>,,false,351,354,showErrorId,,,1,bool()
111669150800,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"bool SettingsDialog::showInconclusive() const
{
    return checkStateToBool(mUI->mEnableInconclusive->checkState());
}",1,1,gui/settingsdialog.cpp,SettingsDialog.showInconclusive<const>:bool(),<empty>,,false,356,359,showInconclusive,,,1,bool()
111669150801,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"void SettingsDialog::browsePythonPath()
{
    QString fileName = QFileDialog::getOpenFileName(this, tr(""Select python binary""), QDir::rootPath());
    if (fileName.contains(""python"", Qt::CaseInsensitive))
        mUI->mEditPythonPath->setText(fileName);
}",1,1,gui/settingsdialog.cpp,SettingsDialog.browsePythonPath:void(),<empty>,,false,361,366,browsePythonPath,,,1,void()
111669150802,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"void SettingsDialog::browseMisraFile()
{
    const QString fileName = QFileDialog::getOpenFileName(this, tr(""Select MISRA File""), QDir::homePath(), ""Misra File (*.pdf *.txt)"");
    if (!fileName.isEmpty())
        mUI->mEditMisraFile->setText(fileName);
}",1,1,gui/settingsdialog.cpp,SettingsDialog.browseMisraFile:void(),<empty>,,false,368,373,browseMisraFile,,,1,void()
111669150803,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"void SettingsDialog::setCodeEditorStyleDefault()
{
    if (mUI->mThemeSystem->isChecked())
        *mCurrentStyle = CodeEditorStyle::getSystemTheme();
    if (mUI->mThemeLight->isChecked())
        *mCurrentStyle = defaultStyleLight;
    if (mUI->mThemeDark->isChecked())
        *mCurrentStyle = defaultStyleDark;
    manageStyleControls();
}",1,1,gui/settingsdialog.cpp,SettingsDialog.setCodeEditorStyleDefault:void(),<empty>,,false,376,385,setCodeEditorStyleDefault,,,1,void()
111669150804,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"void SettingsDialog::editCodeEditorStyle()
{
    StyleEditDialog dlg(*mCurrentStyle, this);
    const int nResult = dlg.exec();
    if (nResult == QDialog::Accepted) {
        *mCurrentStyle = dlg.getStyle();
        manageStyleControls();
    }
}",1,1,gui/settingsdialog.cpp,SettingsDialog.editCodeEditorStyle:void(),<empty>,,false,388,396,editCodeEditorStyle,,,1,void()
111669150805,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"void SettingsDialog::browseClangPath()
{
    QString selectedDir = QFileDialog::getExistingDirectory(this,
                                                            tr(""Select clang path""),
                                                            QDir::rootPath());

    if (!selectedDir.isEmpty()) {
        mUI->mEditClangPath->setText(selectedDir);
    }
}",1,1,gui/settingsdialog.cpp,SettingsDialog.browseClangPath:void(),<empty>,,false,398,407,browseClangPath,,,1,void()
111669150806,METHOD,gui/settingsdialog.cpp:<global>,TYPE_DECL,"void SettingsDialog::manageStyleControls()
{
    const bool isSystemTheme = mCurrentStyle->isSystemTheme();
    const bool isDefaultLight = !isSystemTheme && *mCurrentStyle == defaultStyleLight;
    const bool isDefaultDark =  !isSystemTheme && *mCurrentStyle == defaultStyleDark;
    mUI->mThemeSystem->setChecked(isSystemTheme);
    mUI->mThemeLight->setChecked(isDefaultLight && !isDefaultDark);
    mUI->mThemeDark->setChecked(!isDefaultLight && isDefaultDark);
    mUI->mThemeCustom->setChecked(!isSystemTheme && !isDefaultLight && !isDefaultDark);
    mUI->mBtnEditTheme->setEnabled(!isSystemTheme && !isDefaultLight && !isDefaultDark);
}",1,1,gui/settingsdialog.cpp,SettingsDialog.manageStyleControls:void(),<empty>,,false,409,419,manageStyleControls,,,1,void()
111669150807,METHOD,gui/settingsdialog.h:<global>,TYPE_DECL,<global>,1,26,gui/settingsdialog.h,gui/settingsdialog.h:<global>,<empty>,,false,1,248,<global>,,,1,
111669150808,METHOD,gui/showtypes.cpp:<global>,TYPE_DECL,"ShowTypes::ShowTypes()
{
    load();
}",1,1,gui/showtypes.cpp,ShowTypes.ShowTypes:ANY(),<empty>,,false,26,29,ShowTypes,,,1,ANY()
111669150809,METHOD,gui/showtypes.cpp:<global>,TYPE_DECL,<global>,1,1,gui/showtypes.cpp,gui/showtypes.cpp:<global>,<empty>,,false,1,130,<global>,,,1,
111669150810,METHOD,gui/showtypes.cpp:<global>,TYPE_DECL,"ShowTypes::~ShowTypes()
{
    save();
}",1,1,gui/showtypes.cpp,ShowTypes.~ShowTypes:ANY(),<empty>,,false,31,34,~ShowTypes,,,1,ANY()
111669150811,METHOD,gui/showtypes.cpp:<global>,TYPE_DECL,"ShowTypes::ShowType ShowTypes::SeverityToShowType(Severity severity)
{
    switch (severity) {
    case Severity::none:
    case Severity::internal:
        return ShowTypes::ShowNone;
    case Severity::error:
        return ShowTypes::ShowErrors;
    case Severity::style:
        return ShowTypes::ShowStyle;
    case Severity::warning:
        return ShowTypes::ShowWarnings;
    case Severity::performance:
        return ShowTypes::ShowPerformance;
    case Severity::portability:
        return ShowTypes::ShowPortability;
    case Severity::information:
        return ShowTypes::ShowInformation;
    default:
        return ShowTypes::ShowNone;
    }
}",1,1,gui/showtypes.cpp,ShowTypes.SeverityToShowType:ShowTypes.ShowType(Severity),<empty>,,false,36,57,SeverityToShowType,,,1,ShowTypes.ShowType(Severity)
111669150812,METHOD,gui/showtypes.cpp:<global>,TYPE_DECL,"Severity ShowTypes::ShowTypeToSeverity(ShowTypes::ShowType type)
{
    switch (type) {
    case ShowTypes::ShowStyle:
        return Severity::style;

    case ShowTypes::ShowErrors:
        return Severity::error;

    case ShowTypes::ShowWarnings:
        return Severity::warning;

    case ShowTypes::ShowPerformance:
        return Severity::performance;

    case ShowTypes::ShowPortability:
        return Severity::portability;

    case ShowTypes::ShowInformation:
        return Severity::information;

    case ShowTypes::ShowNone:
    default:
        return Severity::none;
    }
}",1,1,gui/showtypes.cpp,ShowTypes.ShowTypeToSeverity:Severity(ShowTypes.ShowType),<empty>,,false,59,84,ShowTypeToSeverity,,,1,Severity(ShowTypes.ShowType)
111669150813,METHOD,gui/showtypes.cpp:<global>,TYPE_DECL,"ShowTypes::ShowType ShowTypes::VariantToShowType(const QVariant &data)
{
    const int value = data.toInt();
    if (value < ShowTypes::ShowStyle || value > ShowTypes::ShowErrors) {
        return ShowTypes::ShowNone;
    }
    return (ShowTypes::ShowType)value;
}",1,1,gui/showtypes.cpp,ShowTypes.VariantToShowType:ShowTypes.ShowType(QVariant&),<empty>,,false,86,93,VariantToShowType,,,1,ShowTypes.ShowType(QVariant&)
111669150814,METHOD,gui/showtypes.cpp:<global>,TYPE_DECL,"void ShowTypes::load()
{
    QSettings settings;
    mVisible[ShowStyle] = settings.value(SETTINGS_SHOW_STYLE, true).toBool();
    mVisible[ShowErrors] = settings.value(SETTINGS_SHOW_ERRORS, true).toBool();
    mVisible[ShowWarnings] = settings.value(SETTINGS_SHOW_WARNINGS, true).toBool();
    mVisible[ShowPortability] = settings.value(SETTINGS_SHOW_PORTABILITY, true).toBool();
    mVisible[ShowPerformance] = settings.value(SETTINGS_SHOW_PERFORMANCE, true).toBool();
    mVisible[ShowInformation] = settings.value(SETTINGS_SHOW_INFORMATION, true).toBool();
}",1,41,gui/showtypes.cpp,ShowTypes.load:void(),<empty>,,false,95,104,load,,,1,void()
111669150815,METHOD,gui/showtypes.cpp:<global>,TYPE_DECL,"void ShowTypes::save() const
{
    QSettings settings;
    settings.setValue(SETTINGS_SHOW_STYLE, mVisible[ShowStyle]);
    settings.setValue(SETTINGS_SHOW_ERRORS, mVisible[ShowErrors]);
    settings.setValue(SETTINGS_SHOW_WARNINGS, mVisible[ShowWarnings]);
    settings.setValue(SETTINGS_SHOW_PORTABILITY, mVisible[ShowPortability]);
    settings.setValue(SETTINGS_SHOW_PERFORMANCE, mVisible[ShowPerformance]);
    settings.setValue(SETTINGS_SHOW_INFORMATION, mVisible[ShowInformation]);
}",1,22,gui/showtypes.cpp,ShowTypes.save<const>:void(),<empty>,,false,106,115,save,,,1,void()
111669150816,METHOD,gui/showtypes.cpp:<global>,TYPE_DECL,"bool ShowTypes::isShown(ShowTypes::ShowType category) const
{
    return mVisible[category];
}",1,1,gui/showtypes.cpp,ShowTypes.isShown<const>:bool(ShowTypes.ShowType),<empty>,,false,117,120,isShown,,,1,bool(ShowTypes.ShowType)
111669150817,METHOD,gui/showtypes.cpp:<global>,TYPE_DECL,"bool ShowTypes::isShown(Severity severity) const
{
    return isShown(ShowTypes::SeverityToShowType(severity));
}",1,1,gui/showtypes.cpp,ShowTypes.isShown<const>:bool(Severity),<empty>,,false,122,125,isShown,,,1,bool(Severity)
111669150818,METHOD,gui/showtypes.cpp:<global>,TYPE_DECL,"void ShowTypes::show(ShowTypes::ShowType category, bool showing)
{
    mVisible[category] = showing;
}",1,1,gui/showtypes.cpp,"ShowTypes.show:void(ShowTypes.ShowType,bool)",<empty>,,false,127,130,show,,,1,"void(ShowTypes.ShowType,bool)"
111669150819,METHOD,gui/showtypes.h:<global>,TYPE_DECL,<global>,1,21,gui/showtypes.h,gui/showtypes.h:<global>,<empty>,,false,1,127,<global>,,,1,
111669150820,METHOD,gui/statsdialog.cpp:<global>,TYPE_DECL,"StatsDialog::StatsDialog(QWidget *parent)
    : QDialog(parent),
    mUI(new Ui::StatsDialog)
{
    mUI->setupUi(this);

    QFont font(""courier"");
    font.setStyleHint(QFont::Monospace);
    mUI->mCheckersReport->setFont(font);

    setWindowFlags(Qt::Window);

    connect(mUI->mCopyToClipboard, &QPushButton::pressed, this, &StatsDialog::copyToClipboard);
    connect(mUI->mPDFexport, &QPushButton::pressed, this, &StatsDialog::pdfExport);
}",1,1,gui/statsdialog.cpp,StatsDialog.StatsDialog:ANY(QWidget*),<empty>,,false,76,90,StatsDialog,,,1,StatsDialog.StatsDialog:ANY(QWidget*)(QWidget*)
111669150821,METHOD,gui/statsdialog.cpp:<global>,TYPE_DECL,<global>,1,1,gui/statsdialog.cpp,gui/statsdialog.cpp:<global>,<empty>,,false,1,460,<global>,,,1,
111669150822,METHOD,gui/statsdialog.cpp:<global>,TYPE_DECL,"StatsDialog::~StatsDialog()
{
    delete mUI;
}",1,1,gui/statsdialog.cpp,StatsDialog.~StatsDialog:ANY(),<empty>,,false,92,95,~StatsDialog,,,1,ANY()
111669150823,METHOD,gui/statsdialog.cpp:<global>,TYPE_DECL,"void StatsDialog::setProject(const ProjectFile* projectFile)
{
    if (projectFile) {
        mUI->mProject->setText(projectFile->getRootPath());
        mUI->mPaths->setText(projectFile->getCheckPaths().join("";""));
        mUI->mIncludePaths->setText(projectFile->getIncludeDirs().join("";""));
        mUI->mDefines->setText(projectFile->getDefines().join("";""));
        mUI->mUndefines->setText(projectFile->getUndefines().join("";""));
#ifndef QT_CHARTS_LIB
        mUI->mTabHistory->setVisible(false);
#else
        QString statsFile;
        if (!projectFile->getBuildDir().isEmpty()) {
            const QString prjpath = QFileInfo(projectFile->getFilename()).absolutePath();
            const QString buildDir = prjpath + '/' + projectFile->getBuildDir();
            if (QDir(buildDir).exists()) {
                statsFile = buildDir + ""/statistics.txt"";
            }
        }
        mUI->mLblHistoryFile->setText(tr(""File: "") + (statsFile.isEmpty() ? tr(""No cppcheck build dir"") : statsF...",1,1,gui/statsdialog.cpp,StatsDialog.setProject:void(ProjectFile*),<empty>,,false,97,137,setProject,,,1,void(ProjectFile*)
111669150824,METHOD,gui/statsdialog.cpp:<global>,TYPE_DECL,"void StatsDialog::setPathSelected(const QString& path)
{
    mUI->mPath->setText(path);
}",1,1,gui/statsdialog.cpp,StatsDialog.setPathSelected:void(QString&),<empty>,,false,139,142,setPathSelected,,,1,void(QString&)
111669150825,METHOD,gui/statsdialog.cpp:<global>,TYPE_DECL,"void StatsDialog::setNumberOfFilesScanned(int num)
{
    mUI->mNumberOfFilesScanned->setText(QString::number(num));
}",1,1,gui/statsdialog.cpp,StatsDialog.setNumberOfFilesScanned:void(int),<empty>,,false,144,147,setNumberOfFilesScanned,,,1,void(int)
111669150826,METHOD,gui/statsdialog.cpp:<global>,TYPE_DECL,"void StatsDialog::setScanDuration(double seconds)
{
    // Factor the duration into units (days/hours/minutes/seconds)
    int secs = static_cast<int>(seconds);
    const int days = secs / (24 * 60 * 60);
    secs -= days * (24 * 60 * 60);
    const int hours = secs / (60 * 60);
    secs -= hours * (60 * 60);
    const int mins = secs / 60;
    secs -= mins * 60;

    // Concatenate the two most significant units (e.g. ""1 day and 3 hours"")
    QStringList parts;
    if (days)
        parts << ((days == 1) ? tr(""1 day"") : tr(""%1 days"").arg(days));
    if (hours)
        parts << ((hours == 1) ? tr(""1 hour"") : tr(""%1 hours"").arg(hours));
    if (mins && parts.size() < 2)
        parts << ((mins == 1) ? tr(""1 minute"") : tr(""%1 minutes"").arg(mins));
    if (secs && parts.size() < 2)
        parts << ((secs == 1) ? tr(""1 second"") : tr(""%1 seconds"").arg(secs));

    // For durations < 1s, show the fraction of a second (e.g. ""0.7 seconds"")
    if (parts.isEmpty())
        parts << tr(""0.%1...",1,1,gui/statsdialog.cpp,StatsDialog.setScanDuration:void(double),<empty>,,false,149,176,setScanDuration,,,1,void(double)
111669150827,METHOD,gui/statsdialog.cpp:<global>,TYPE_DECL,"void StatsDialog::pdfExport()
{
    const QString Stat = QString(
        ""<center><h1>%1   %2</h1></center>\\n""
        ""<font color=\\""red\\""><h3>%3   :   %4</h3></font>\\n""
        ""<font color=\\""green\\""><h3>%5   :   %6</h3></font>\\n""
        ""<font color=\\""orange\\""><h3>%7   :   %8</h3></font>\\n""
        ""<font color=\\""blue\\""><h3>%9   :   %10</h3></font>\\n""
        ""<font color=\\""blue\\""><h3>%11  :   %12</h3></font>\\n""
        ""<font color=\\""purple\\""><h3>%13  :   %14</h3></font>\\n"")
                         .arg(tr(""Statistics""))
                         .arg(QDate::currentDate().toString(""dd.MM.yyyy""))
                         .arg(tr(""Errors""))
                         .arg(mStatistics->getCount(CPPCHECK,ShowTypes::ShowErrors))
                         .arg(tr(""Warnings""))
                         .arg(mStatistics->getCount(CPPCHECK,ShowTypes::ShowWarnings))
                         .arg(tr(""Style warnings""))
                         .arg(mStatistics->getCount(CPPCHECK,ShowTypes::Sh...",1,1,gui/statsdialog.cpp,StatsDialog.pdfExport:void(),<empty>,,false,177,216,pdfExport,,,1,void()
111669150828,METHOD,gui/statsdialog.cpp:<global>,TYPE_DECL,"void StatsDialog::copyToClipboard()
{
    QClipboard *clipboard = QApplication::clipboard();
    if (!clipboard)
        return;

    const QString projSettings(tr(""Project Settings""));
    const QString project(tr(""Project""));
    const QString paths(tr(""Paths""));
    const QString incPaths(tr(""Include paths""));
    const QString defines(tr(""Defines""));
    const QString undefines(tr(""Undefines""));
    const QString prevScan(tr(""Previous Scan""));
    const QString selPath(tr(""Path selected""));
    const QString numFiles(tr(""Number of files scanned""));
    const QString duration(tr(""Scan duration""));
    const QString stats(tr(""Statistics""));
    const QString errors(tr(""Errors""));
    const QString warnings(tr(""Warnings""));
    const QString style(tr(""Style warnings""));
    const QString portability(tr(""Portability warnings""));
    const QString performance(tr(""Performance warnings""));
    const QString information(tr(""Information messages""));

    // Plain text summary
    const Q...",1,1,gui/statsdialog.cpp,StatsDialog.copyToClipboard:void(),<empty>,,false,218,371,copyToClipboard,,,1,void()
111669150829,METHOD,gui/statsdialog.cpp:<global>,TYPE_DECL,"void StatsDialog::setStatistics(const CheckStatistics *stats)
{
    mStatistics = stats;
    mUI->mLblErrors->setText(QString::number(stats->getCount(CPPCHECK,ShowTypes::ShowErrors)));
    mUI->mLblWarnings->setText(QString::number(stats->getCount(CPPCHECK,ShowTypes::ShowWarnings)));
    mUI->mLblStyle->setText(QString::number(stats->getCount(CPPCHECK,ShowTypes::ShowStyle)));
    mUI->mLblPortability->setText(QString::number(stats->getCount(CPPCHECK,ShowTypes::ShowPortability)));
    mUI->mLblPerformance->setText(QString::number(stats->getCount(CPPCHECK,ShowTypes::ShowPerformance)));
    mUI->mLblInformation->setText(QString::number(stats->getCount(CPPCHECK,ShowTypes::ShowInformation)));
    mUI->mLblActiveCheckers->setText(QString::number(stats->getNumberOfActiveCheckers()));
    mUI->mCheckersReport->setPlainText(stats->getCheckersReport());
}",1,1,gui/statsdialog.cpp,StatsDialog.setStatistics:void(CheckStatistics*),<empty>,,false,373,384,setStatistics,,,1,void(CheckStatistics*)
111669150830,METHOD,gui/statsdialog.cpp:<global>,TYPE_DECL,"QChartView *createChart(const QString &statsFile, const QString &tool)
{
    auto *chart = new QChart;
    chart->addSeries(numberOfReports(statsFile, tool + ""-error""));
    chart->addSeries(numberOfReports(statsFile, tool + ""-warning""));
    chart->addSeries(numberOfReports(statsFile, tool + ""-style""));
    chart->addSeries(numberOfReports(statsFile, tool + ""-performance""));
    chart->addSeries(numberOfReports(statsFile, tool + ""-portability""));

    auto *axisX = new QDateTimeAxis;
    axisX->setTitleText(""Date"");
    chart->addAxis(axisX, Qt::AlignBottom);

    for (QAbstractSeries *s : chart->series()) {
        s->attachAxis(axisX);
    }

    auto *axisY = new QValueAxis;
    axisY->setLabelFormat(""%i"");
    axisY->setTitleText(""Count"");
    chart->addAxis(axisY, Qt::AlignLeft);

    qreal maxY = 0;
    for (QAbstractSeries *s : chart->series()) {
        s->attachAxis(axisY);
        if (const auto *ls = dynamic_cast<const QLineSeries*>(s)) {
            for (QPointF p : ls-...",1,1,gui/statsdialog.cpp,"createChart:QChartView(QString&,QString&)",<empty>,,false,387,427,createChart,,,1,"QChartView(QString&,QString&)"
111669150831,METHOD,gui/statsdialog.cpp:<global>,TYPE_DECL,"QLineSeries *numberOfReports(const QString &fileName, const QString &severity)
{
    auto *series = new QLineSeries();
    series->setName(severity);
    QFile f(fileName);
    if (f.open(QIODevice::ReadOnly | QIODevice::Text)) {
        quint64 t = 0;
        QTextStream in(&f);
        while (!in.atEnd()) {
            QString line = in.readLine();
            static const QRegularExpression rxdate(""^\\\\[(\\\\d\\\\d)\\\\.(\\\\d\\\\d)\\\\.(\\\\d\\\\d\\\\d\\\\d)\\\\]$"");
            const QRegularExpressionMatch matchRes = rxdate.match(line);
            if (matchRes.hasMatch()) {
                const int y = matchRes.captured(3).toInt();
                const int m = matchRes.captured(2).toInt();
                const int d = matchRes.captured(1).toInt();
                QDateTime dt;
                dt.setDate(QDate(y,m,d));
                if (t == dt.toMSecsSinceEpoch())
                    t += 1000;
                else
                    t = dt.toMSecsSinceEpoch();
            }
            if (l...",1,1,gui/statsdialog.cpp,"numberOfReports:QLineSeries(QString&,QString&)",<empty>,,false,429,459,numberOfReports,,,1,"QLineSeries(QString&,QString&)"
111669150832,METHOD,gui/statsdialog.h:<global>,TYPE_DECL,<global>,1,23,gui/statsdialog.h,gui/statsdialog.h:<global>,<empty>,,false,1,81,<global>,,,1,
111669150833,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"ThreadHandler::ThreadHandler(QObject *parent) :
    QObject(parent)
{
    setThreadCount(1);
}",1,1,gui/threadhandler.cpp,ThreadHandler.ThreadHandler:ANY(QObject*),<empty>,,false,39,43,ThreadHandler,,,1,ThreadHandler.ThreadHandler:ANY(QObject*)(QObject*)
111669150834,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,<global>,1,1,gui/threadhandler.cpp,gui/threadhandler.cpp:<global>,<empty>,,false,1,305,<global>,,,1,
111669150835,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"ThreadHandler::~ThreadHandler()
{
    removeThreads();
}",1,1,gui/threadhandler.cpp,ThreadHandler.~ThreadHandler:ANY(),<empty>,,false,45,48,~ThreadHandler,,,1,ANY()
111669150836,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"void ThreadHandler::clearFiles()
{
    mLastFiles.clear();
    mResults.clearFiles();
    mAnalyseWholeProgram = false;
    mCtuInfo.clear();
    mAddonsAndTools.clear();
    mSuppressions.clear();
}",1,1,gui/threadhandler.cpp,ThreadHandler.clearFiles:void(),<empty>,,false,50,58,clearFiles,,,1,void()
111669150837,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"void ThreadHandler::setFiles(const QStringList &files)
{
    mResults.setFiles(files);
    mLastFiles = files;
}",1,1,gui/threadhandler.cpp,ThreadHandler.setFiles:void(QStringList&),<empty>,,false,60,64,setFiles,,,1,void(QStringList&)
111669150838,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"void ThreadHandler::setProject(const ImportProject &prj)
{
    mResults.setProject(prj);
    mLastFiles.clear();
}",1,1,gui/threadhandler.cpp,ThreadHandler.setProject:void(ImportProject&),<empty>,,false,66,70,setProject,,,1,void(ImportProject&)
111669150839,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"void ThreadHandler::setCheckFiles(bool all)
{
    if (mRunningThreadCount == 0) {
        mResults.setFiles(getReCheckFiles(all));
    }
}",1,1,gui/threadhandler.cpp,ThreadHandler.setCheckFiles:void(bool),<empty>,,false,72,77,setCheckFiles,,,1,void(bool)
111669150840,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"void ThreadHandler::setCheckFiles(const QStringList& files)
{
    if (mRunningThreadCount == 0) {
        mResults.setFiles(files);
    }
}",1,1,gui/threadhandler.cpp,ThreadHandler.setCheckFiles:void(QStringList&),<empty>,,false,79,84,setCheckFiles,,,1,void(QStringList&)
111669150841,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"void ThreadHandler::check(const Settings &settings, const std::shared_ptr<Suppressions>& supprs)
{
    if (mResults.getFileCount() == 0 || mRunningThreadCount > 0 || settings.jobs == 0) {
        qDebug() << ""Can't start checking if there's no files to check or if check is in progress."";
        emit done();
        return;
    }

    setThreadCount(settings.jobs);

    mRunningThreadCount = mThreads.size();
    mRunningThreadCount = std::min(mResults.getFileCount(), mRunningThreadCount);

    QStringList addonsAndTools = mAddonsAndTools;
    for (const std::string& addon: settings.addons) {
        QString s = QString::fromStdString(addon);
        if (!addonsAndTools.contains(s))
            addonsAndTools << s;
    }

    mCtuInfo.clear();

    for (int i = 0; i < mRunningThreadCount; i++) {
        mThreads[i]->setAddonsAndTools(addonsAndTools);
        mThreads[i]->setSuppressions(mSuppressions);
        mThreads[i]->setClangIncludePaths(mClangIncludePaths);
        mThreads[i]...",1,1,gui/threadhandler.cpp,"ThreadHandler.check:void(Settings&,std.shared_ptr<Suppressions>&)",<empty>,,false,86,122,check,,,1,"void(Settings&,std.shared_ptr<Suppressions>&)"
111669150842,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"bool ThreadHandler::isChecking() const
{
    return mRunningThreadCount > 0;
}",1,1,gui/threadhandler.cpp,ThreadHandler.isChecking<const>:bool(),<empty>,,false,124,127,isChecking,,,1,bool()
111669150843,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"void ThreadHandler::setThreadCount(const int count)
{
    if (mRunningThreadCount > 0 ||
        count == mThreads.size() ||
        count <= 0) {
        return;
    }

    //Remove unused old threads
    removeThreads();
    //Create new threads
    for (int i = mThreads.size(); i < count; i++) {
        mThreads << new CheckThread(mResults);
        connect(mThreads.last(), &CheckThread::done,
                this, &ThreadHandler::threadDone);
        connect(mThreads.last(), &CheckThread::fileChecked,
                &mResults, &ThreadResult::fileChecked);
    }
}",1,1,gui/threadhandler.cpp,ThreadHandler.setThreadCount:void(int),<empty>,,false,129,147,setThreadCount,,,1,void(int)
111669150844,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"void ThreadHandler::removeThreads()
{
    for (CheckThread* thread : mThreads) {
        if (thread->isRunning()) {
            thread->terminate();
            thread->wait();
        }
        disconnect(thread, &CheckThread::done,
                   this, &ThreadHandler::threadDone);
        disconnect(thread, &CheckThread::fileChecked,
                   &mResults, &ThreadResult::fileChecked);
        delete thread;
    }

    mThreads.clear();
    mAnalyseWholeProgram = false;
}",1,1,gui/threadhandler.cpp,ThreadHandler.removeThreads:void(),<empty>,,false,150,166,removeThreads,,,1,void()
111669150845,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"void ThreadHandler::threadDone()
{
    if (mRunningThreadCount == 1 && mAnalyseWholeProgram) {
        mThreads[0]->analyseWholeProgram(mLastFiles, mCtuInfo);
        mAnalyseWholeProgram = false;
        mCtuInfo.clear();
        return;
    }

    mRunningThreadCount--;
    if (mRunningThreadCount == 0) {
        emit done();

        mScanDuration = mTimer.elapsed();

        // Set date/time used by the recheck
        if (!mCheckStartTime.isNull()) {
            mLastCheckTime = mCheckStartTime;
            mCheckStartTime = QDateTime();
        }
    }
}",1,1,gui/threadhandler.cpp,ThreadHandler.threadDone:void(),<empty>,,false,168,189,threadDone,,,1,void()
111669150846,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"void ThreadHandler::stop()
{
    mCheckStartTime = QDateTime();
    mAnalyseWholeProgram = false;
    mCtuInfo.clear();
    for (CheckThread* thread : mThreads) {
        thread->stop();
    }
}",1,1,gui/threadhandler.cpp,ThreadHandler.stop:void(),<empty>,,false,191,199,stop,,,1,void()
111669150847,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"void ThreadHandler::initialize(const ResultsView *view)
{
    connect(&mResults, &ThreadResult::progress,
            view, &ResultsView::progress);

    connect(&mResults, &ThreadResult::error,
            view, &ResultsView::error);

    connect(&mResults, &ThreadResult::log,
            this, &ThreadHandler::log);

    connect(&mResults, &ThreadResult::debugError,
            this, &ThreadHandler::debugError);
}",1,1,gui/threadhandler.cpp,ThreadHandler.initialize:void(ResultsView*),<empty>,,false,201,214,initialize,,,1,void(ResultsView*)
111669150848,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"void ThreadHandler::loadSettings(const QSettings &settings)
{
    setThreadCount(settings.value(SETTINGS_CHECK_THREADS, 1).toInt());
}",1,34,gui/threadhandler.cpp,ThreadHandler.loadSettings:void(QSettings&),<empty>,,false,216,219,loadSettings,,,1,void(QSettings&)
111669150849,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"void ThreadHandler::saveSettings(QSettings &settings) const
{
    settings.setValue(SETTINGS_CHECK_THREADS, mThreads.size());
}",1,22,gui/threadhandler.cpp,ThreadHandler.saveSettings<const>:void(QSettings&),<empty>,,false,221,224,saveSettings,,,1,void(QSettings&)
111669150850,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"bool ThreadHandler::hasPreviousFiles() const
{
    return !mLastFiles.isEmpty();
}",1,1,gui/threadhandler.cpp,ThreadHandler.hasPreviousFiles<const>:bool(),<empty>,,false,226,229,hasPreviousFiles,,,1,bool()
111669150851,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"int ThreadHandler::getPreviousFilesCount() const
{
    return mLastFiles.size();
}",1,1,gui/threadhandler.cpp,ThreadHandler.getPreviousFilesCount<const>:int(),<empty>,,false,231,234,getPreviousFilesCount,,,1,int()
111669150852,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"int ThreadHandler::getPreviousScanDuration() const
{
    return mScanDuration;
}",1,1,gui/threadhandler.cpp,ThreadHandler.getPreviousScanDuration<const>:int(),<empty>,,false,236,239,getPreviousScanDuration,,,1,int()
111669150853,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"QStringList ThreadHandler::getReCheckFiles(bool all) const
{
    if (mLastCheckTime.isNull() || all)
        return mLastFiles;

    std::set<QString> modified;
    std::set<QString> unmodified;

    QStringList files;
    for (int i = 0; i < mLastFiles.size(); ++i) {
        if (needsReCheck(mLastFiles[i], modified, unmodified))
            files.push_back(mLastFiles[i]);
    }
    return files;
}",1,1,gui/threadhandler.cpp,ThreadHandler.getReCheckFiles<const>:QStringList(bool),<empty>,,false,241,255,getReCheckFiles,,,1,QStringList(bool)
111669150854,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"bool ThreadHandler::needsReCheck(const QString &filename, std::set<QString> &modified, std::set<QString> &unmodified) const
{
    if (modified.find(filename) != modified.end())
        return true;

    if (unmodified.find(filename) != unmodified.end())
        return false;

    if (QFileInfo(filename).lastModified() > mLastCheckTime) {
        return true;
    }

    // Parse included files recursively
    QFile f(filename);
    if (!f.open(QIODevice::ReadOnly | QIODevice::Text))
        return false;

    // prevent recursion..
    unmodified.insert(filename);

    QTextStream in(&f);
    while (!in.atEnd()) {
        QString line = in.readLine();
        if (line.startsWith(""#include \\"""")) {
            line.remove(0,10);
            const int i = line.indexOf(""\\"""");
            if (i > 0) {
                line.remove(i,line.length());
                line = QFileInfo(filename).absolutePath() + ""/"" + line;
                if (needsReCheck(line, modified, unmodified)) {
        ...",1,1,gui/threadhandler.cpp,"ThreadHandler.needsReCheck<const>:bool(QString&,std.set<QString>&,std.set<QString>&)",<empty>,,false,257,295,needsReCheck,,,1,"bool(QString&,std.set<QString>&,std.set<QString>&)"
111669150855,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"QDateTime ThreadHandler::getCheckStartTime() const
{
    return mCheckStartTime;
}",1,1,gui/threadhandler.cpp,ThreadHandler.getCheckStartTime<const>:QDateTime(),<empty>,,false,297,300,getCheckStartTime,,,1,QDateTime()
111669150856,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,"void ThreadHandler::setCheckStartTime(QDateTime checkStartTime)
{
    mCheckStartTime = std::move(checkStartTime);
}",1,1,gui/threadhandler.cpp,ThreadHandler.setCheckStartTime:void(QDateTime),<empty>,,false,302,305,setCheckStartTime,,,1,void(QDateTime)
111669150857,METHOD,gui/threadhandler.h:<global>,TYPE_DECL,<global>,1,1,gui/threadhandler.h,gui/threadhandler.h:<global>,<empty>,,false,1,277,<global>,,,1,
111669150858,METHOD,gui/threadresult.cpp:<global>,TYPE_DECL,"void ThreadResult::reportOut(const std::string &outmsg, Color /*c*/)
{
    emit log(QString::fromStdString(outmsg));
}",1,1,gui/threadresult.cpp,"ThreadResult.reportOut:void(std.string&,Color)",<empty>,,false,31,34,reportOut,,,1,"void(std.string&,Color)"
111669150859,METHOD,gui/threadresult.cpp:<global>,TYPE_DECL,<global>,1,1,gui/threadresult.cpp,gui/threadresult.cpp:<global>,<empty>,,false,1,129,<global>,,,1,
111669150860,METHOD,gui/threadresult.cpp:<global>,TYPE_DECL,"void ThreadResult::fileChecked(const QString &file)
{
    std::lock_guard<std::mutex> locker(mutex);

    mProgress += QFile(file).size();
    mFilesChecked++;

    if (mMaxProgress > 0) {
        const int value = static_cast<int>(PROGRESS_MAX * mProgress / mMaxProgress);
        const QString description = tr(""%1 of %2 files checked"").arg(mFilesChecked).arg(mTotalFiles);

        emit progress(value, description);
    }
}",1,43,gui/threadresult.cpp,ThreadResult.fileChecked:void(QString&),<empty>,,false,36,49,fileChecked,,,1,void(QString&)
111669150861,METHOD,gui/threadresult.cpp:<global>,TYPE_DECL,"void ThreadResult::reportErr(const ErrorMessage &msg)
{
    std::lock_guard<std::mutex> locker(mutex);
    const ErrorItem item(msg);
    if (msg.severity != Severity::debug)
        emit error(item);
    else
        emit debugError(item);
}",1,1,gui/threadresult.cpp,ThreadResult.reportErr:void(ErrorMessage&),<empty>,,false,51,59,reportErr,,,1,void(ErrorMessage&)
111669150862,METHOD,gui/threadresult.cpp:<global>,TYPE_DECL,"QString ThreadResult::getNextFile()
{
    std::lock_guard<std::mutex> locker(mutex);
    if (mFiles.isEmpty()) {
        return QString();
    }

    return mFiles.takeFirst();
}",1,1,gui/threadresult.cpp,ThreadResult.getNextFile:QString(),<empty>,,false,61,69,getNextFile,,,1,QString()
111669150863,METHOD,gui/threadresult.cpp:<global>,TYPE_DECL,"void ThreadResult::getNextFileSettings(const FileSettings*& fs)
{
    std::lock_guard<std::mutex> locker(mutex);
    fs = nullptr;
    if (mItNextFileSettings == mFileSettings.cend()) {
        return;
    }
    fs = &(*mItNextFileSettings);
    ++mItNextFileSettings;
}",1,1,gui/threadresult.cpp,ThreadResult.getNextFileSettings:void(FileSettings*&),<empty>,,false,71,80,getNextFileSettings,,,1,void(FileSettings*&)
111669150864,METHOD,<empty>,<empty>,"[](quint64 total, const QString& file) {
        return total + QFile(file).size();
    }",74,5,gui/threadresult.cpp,"gui/threadresult.cpp:<global>.ThreadResult.setFiles.<lambda>0:ANY(quint64,QString&)",<empty>,,false,92,94,<lambda>0,,,1,"ANY(quint64,QString&)"
111669150865,METHOD,gui/threadresult.cpp:<global>,TYPE_DECL,"void ThreadResult::setFiles(const QStringList &files)
{
    std::lock_guard<std::mutex> locker(mutex);
    mFiles = files;
    mProgress = 0;
    mFilesChecked = 0;
    mTotalFiles = files.size();

    // Determine the total size of all of the files to check, so that we can
    // show an accurate progress estimate
    quint64 sizeOfFiles = std::accumulate(files.begin(), files.end(), 0, [](quint64 total, const QString& file) {
        return total + QFile(file).size();
    });
    mMaxProgress = sizeOfFiles;
}",1,1,gui/threadresult.cpp,ThreadResult.setFiles:void(QStringList&),<empty>,,false,82,96,setFiles,,,1,void(QStringList&)
111669150866,METHOD,<empty>,<empty>,"[](quint64 v, const FileSettings& fs) {
        return v + QFile(QString::fromStdString(fs.filename())).size();
    }",100,5,gui/threadresult.cpp,"gui/threadresult.cpp:<global>.ThreadResult.setProject.<lambda>1:ANY(quint64,FileSettings&)",<empty>,,false,110,112,<lambda>1,,,1,"ANY(quint64,FileSettings&)"
111669150867,METHOD,gui/threadresult.cpp:<global>,TYPE_DECL,"void ThreadResult::setProject(const ImportProject &prj)
{
    std::lock_guard<std::mutex> locker(mutex);
    mFiles.clear();
    mFileSettings = prj.fileSettings;
    mItNextFileSettings = mFileSettings.cbegin();
    mProgress = 0;
    mFilesChecked = 0;
    mTotalFiles = prj.fileSettings.size();

    // Determine the total size of all of the files to check, so that we can
    // show an accurate progress estimate
    mMaxProgress = std::accumulate(prj.fileSettings.begin(), prj.fileSettings.end(), quint64{ 0 }, [](quint64 v, const FileSettings& fs) {
        return v + QFile(QString::fromStdString(fs.filename())).size();
    });
}",1,1,gui/threadresult.cpp,ThreadResult.setProject:void(ImportProject&),<empty>,,false,98,113,setProject,,,1,void(ImportProject&)
111669150868,METHOD,gui/threadresult.cpp:<global>,TYPE_DECL,"void ThreadResult::clearFiles()
{
    std::lock_guard<std::mutex> locker(mutex);
    mFiles.clear();
    mFileSettings.clear();
    mItNextFileSettings = mFileSettings.cend();
    mFilesChecked = 0;
    mTotalFiles = 0;
}",1,1,gui/threadresult.cpp,ThreadResult.clearFiles:void(),<empty>,,false,115,123,clearFiles,,,1,void()
111669150869,METHOD,gui/threadresult.cpp:<global>,TYPE_DECL,"int ThreadResult::getFileCount() const
{
    std::lock_guard<std::mutex> locker(mutex);
    return mFiles.size() + mFileSettings.size();
}",1,1,gui/threadresult.cpp,ThreadResult.getFileCount<const>:int(),<empty>,,false,125,129,getFileCount,,,1,int()
111669150870,METHOD,gui/threadresult.h:<global>,TYPE_DECL,<global>,1,1,gui/threadresult.h,gui/threadresult.h:<global>,<empty>,,false,1,167,<global>,,,1,
111669150871,METHOD,gui/translationhandler.cpp:<global>,TYPE_DECL,"static void unused()
{
    Q_UNUSED(QT_TRANSLATE_NOOP(""QPlatformTheme"", ""OK""))
    Q_UNUSED(QT_TRANSLATE_NOOP(""QPlatformTheme"", ""Cancel""))
    Q_UNUSED(QT_TRANSLATE_NOOP(""QPlatformTheme"", ""Close""))
    Q_UNUSED(QT_TRANSLATE_NOOP(""QPlatformTheme"", ""Save""))
}",8,1,gui/translationhandler.cpp,unused:void(),<empty>,,false,35,41,unused,,,1,void()
111669150872,METHOD,gui/translationhandler.cpp:<global>,TYPE_DECL,<global>,1,1,gui/translationhandler.cpp,gui/translationhandler.cpp:<global>,<empty>,,false,1,184,<global>,,,1,
111669150873,METHOD,gui/translationhandler.cpp:<global>,TYPE_DECL,"TranslationHandler::TranslationHandler(QObject *parent) :
    QObject(parent),
    mCurrentLanguage(""en"")
{
    // Add our available languages
    // Keep this list sorted
    addTranslation(""Chinese (Simplified)"", ""cppcheck_zh_CN"");
    addTranslation(""Chinese (Traditional)"", ""cppcheck_zh_TW"");
    addTranslation(""Dutch"", ""cppcheck_nl"");
    addTranslation(""English"", ""cppcheck_en"");
    addTranslation(""Finnish"", ""cppcheck_fi"");
    addTranslation(""French"", ""cppcheck_fr"");
    addTranslation(""German"", ""cppcheck_de"");
    addTranslation(""Italian"", ""cppcheck_it"");
    addTranslation(""Japanese"", ""cppcheck_ja"");
    addTranslation(""Georgian"", ""cppcheck_ka"");
    addTranslation(""Korean"", ""cppcheck_ko"");
    addTranslation(""Russian"", ""cppcheck_ru"");
    addTranslation(""Serbian"", ""cppcheck_sr"");
    addTranslation(""Spanish"", ""cppcheck_es"");
    addTranslation(""Swedish"", ""cppcheck_sv"");
}",1,1,gui/translationhandler.cpp,TranslationHandler.TranslationHandler:ANY(QObject*),<empty>,,false,43,64,TranslationHandler,,,1,TranslationHandler.TranslationHandler:ANY(QObject*)(QObject*)
111669150874,METHOD,gui/translationhandler.cpp:<global>,TYPE_DECL,"bool TranslationHandler::setLanguage(const QString &code)
{
    bool failure = false;
    QString error;

    //If English is the language. Code can be e.g. en_US
    if (code.indexOf(""en"") == 0) {
        //Just remove all extra translators
        if (mTranslator) {
            qApp->removeTranslator(mTranslator);
            delete mTranslator;
            mTranslator = nullptr;
        }

        mCurrentLanguage = code;
        return true;
    }

    //Make sure the translator is otherwise valid
    const int index = getLanguageIndexByCode(code);
    if (index == -1) {
        error = QObject::tr(""Unknown language specified!"");
        failure = true;
    } else {
        // Make sure there is a translator
        if (!mTranslator)
            mTranslator = new QTranslator(this);

        //Load the new language
        const QString appPath = QFileInfo(QCoreApplication::applicationFilePath()).canonicalPath();

        QString datadir = getDataDir();

        QString translati...",1,1,gui/translationhandler.cpp,TranslationHandler.setLanguage:bool(QString&),<empty>,,false,66,144,setLanguage,,,1,bool(QString&)
111669150875,METHOD,gui/translationhandler.cpp:<global>,TYPE_DECL,"const QString& TranslationHandler::getCurrentLanguage() const
{
    return mCurrentLanguage;
}",1,1,gui/translationhandler.cpp,TranslationHandler.getCurrentLanguage<const>:ANY(),<empty>,,false,146,149,getCurrentLanguage,,,1,ANY()
111669150876,METHOD,gui/translationhandler.cpp:<global>,TYPE_DECL,"QString TranslationHandler::suggestLanguage() const
{
    //Get language from system locale's name ie sv_SE or zh_CN
    QString language = QLocale::system().name();
    //qDebug()<<""Your language is""<<language;

    //And see if we can find it from our list of language files
    const int index = getLanguageIndexByCode(language);

    //If nothing found, return English
    if (index < 0) {
        return ""en"";
    }

    return language;
}",1,1,gui/translationhandler.cpp,TranslationHandler.suggestLanguage<const>:QString(),<empty>,,false,151,166,suggestLanguage,,,1,QString()
111669150877,METHOD,gui/translationhandler.cpp:<global>,TYPE_DECL,"void TranslationHandler::addTranslation(const char *name, const char *filename)
{
    TranslationInfo info;
    info.mName = name;
    info.mFilename = filename;
    const int codeLength = QString(filename).length() - QString(filename).indexOf('_') - 1;
    info.mCode = QString(filename).right(codeLength);
    mTranslations.append(info);
}",1,1,gui/translationhandler.cpp,"TranslationHandler.addTranslation:void(char*,char*)",<empty>,,false,168,176,addTranslation,,,1,"void(char*,char*)"
111669150878,METHOD,<empty>,<empty>,"[&](const TranslationInfo& ti) {
        return ti.mCode == code || ti.mCode == code.left(2);
    }",74,5,gui/translationhandler.cpp,gui/translationhandler.cpp:<global>.TranslationHandler.getLanguageIndexByCode<const>.<lambda>0:bool(TranslationInfo&),<empty>,,false,180,182,<lambda>0,,,1,bool(TranslationInfo&)
111669150879,METHOD,gui/translationhandler.cpp:<global>,TYPE_DECL,"int TranslationHandler::getLanguageIndexByCode(const QString &code) const
{
    auto it = std::find_if(mTranslations.cbegin(), mTranslations.cend(), [&](const TranslationInfo& ti) {
        return ti.mCode == code || ti.mCode == code.left(2);
    });
    return it == mTranslations.cend() ? -1 : static_cast<int>(std::distance(mTranslations.cbegin(), it));
}",1,1,gui/translationhandler.cpp,TranslationHandler.getLanguageIndexByCode<const>:int(QString&),<empty>,,false,178,184,getLanguageIndexByCode,,,1,int(QString&)
111669150880,METHOD,gui/translationhandler.h:<global>,TYPE_DECL,<global>,1,30,gui/translationhandler.h,gui/translationhandler.h:<global>,<empty>,,false,1,141,<global>,,,1,
111669150881,METHOD,gui/txtreport.cpp:<global>,TYPE_DECL,"TxtReport::TxtReport(const QString &filename) :
    Report(filename)
{}",1,2,gui/txtreport.cpp,TxtReport.TxtReport:ANY(QString&),<empty>,,false,28,30,TxtReport,,,1,TxtReport.TxtReport:ANY(QString&)(QString&)
111669150882,METHOD,gui/txtreport.cpp:<global>,TYPE_DECL,<global>,1,1,gui/txtreport.cpp,gui/txtreport.cpp:<global>,<empty>,,false,1,85,<global>,,,1,
111669150883,METHOD,gui/txtreport.cpp:<global>,TYPE_DECL,"bool TxtReport::create()
{
    if (Report::create()) {
        mTxtWriter.setDevice(Report::getFile());
        return true;
    }
    return false;
}",1,1,gui/txtreport.cpp,TxtReport.create:bool(),<empty>,,false,32,39,create,,,1,bool()
111669150884,METHOD,gui/txtreport.cpp:<global>,TYPE_DECL,"void TxtReport::writeHeader()
{
    // No header for txt report
}",1,1,gui/txtreport.cpp,TxtReport.writeHeader:void(),<empty>,,false,41,44,writeHeader,,,1,void()
111669150885,METHOD,gui/txtreport.cpp:<global>,TYPE_DECL,"void TxtReport::writeFooter()
{
    // No footer for txt report
}",1,1,gui/txtreport.cpp,TxtReport.writeFooter:void(),<empty>,,false,46,49,writeFooter,,,1,void()
111669150886,METHOD,gui/txtreport.cpp:<global>,TYPE_DECL,"void TxtReport::writeError(const ErrorItem &error)
{
    /*
       Error example from the core program in text
       [gui/test.cpp:23] -> [gui/test.cpp:14]: (error) Mismatching allocation and deallocation: k
     */

    QString line;

    for (int i = 0; i < error.errorPath.size(); i++) {
        const QString file = QDir::toNativeSeparators(error.errorPath[i].file);
        line += QString(""[%1:%2]"").arg(file).arg(error.errorPath[i].line);
        if (i < error.errorPath.size() - 1) {
            line += "" -> "";
        }

        if (i == error.errorPath.size() - 1) {
            line += "": "";
        }
    }
    QString temp = ""(%1"";
    if (error.inconclusive) {
        temp += "", "";
        temp += tr(""inconclusive"");
    }
    temp += "") "";
    line += temp.arg(GuiSeverity::toString(error.severity));
    line += error.summary;

#if (QT_VERSION >= QT_VERSION_CHECK(5, 14, 0))
    mTxtWriter << line << Qt::endl;
#else
    mTxtWriter << line << endl;
#endif
}",1,1,gui/txtreport.cpp,TxtReport.writeError:void(ErrorItem&),<empty>,,false,51,85,writeError,,,1,void(ErrorItem&)
111669150887,METHOD,gui/txtreport.h:<global>,TYPE_DECL,<global>,1,1,gui/txtreport.h,gui/txtreport.h:<global>,<empty>,,false,1,72,<global>,,,1,
111669150888,METHOD,gui/xmlreport.cpp:<global>,TYPE_DECL,"XmlReport::XmlReport(const QString &filename) :
    Report(filename)
{}",1,2,gui/xmlreport.cpp,XmlReport.XmlReport:ANY(QString&),<empty>,,false,35,37,XmlReport,,,1,XmlReport.XmlReport:ANY(QString&)(QString&)
111669150889,METHOD,gui/xmlreport.cpp:<global>,TYPE_DECL,<global>,1,1,gui/xmlreport.cpp,gui/xmlreport.cpp:<global>,<empty>,,false,1,98,<global>,,,1,
111669150890,METHOD,gui/xmlreport.cpp:<global>,TYPE_DECL,"QString XmlReport::quoteMessage(const QString &message)
{
    QString quotedMessage(message);
    quotedMessage.replace(""&"", ""&amp;"");
    quotedMessage.replace(""\\"""", ""&quot;"");
    quotedMessage.replace(""'"", ""&#039;"");
    quotedMessage.replace(""<"", ""&lt;"");
    quotedMessage.replace("">"", ""&gt;"");
    return quotedMessage;
}",1,1,gui/xmlreport.cpp,XmlReport.quoteMessage:QString(QString&),<empty>,,false,39,48,quoteMessage,,,1,QString(QString&)
111669150891,METHOD,gui/xmlreport.cpp:<global>,TYPE_DECL,"QString XmlReport::unquoteMessage(const QString &message)
{
    QString quotedMessage(message);
    quotedMessage.replace(""&amp;"", ""&"");
    quotedMessage.replace(""&quot;"", ""\\"""");
    quotedMessage.replace(""&#039;"", ""'"");
    quotedMessage.replace(""&lt;"", ""<"");
    quotedMessage.replace(""&gt;"", "">"");
    return quotedMessage;
}",1,1,gui/xmlreport.cpp,XmlReport.unquoteMessage:QString(QString&),<empty>,,false,50,59,unquoteMessage,,,1,QString(QString&)
111669150892,METHOD,gui/xmlreport.cpp:<global>,TYPE_DECL,"int XmlReport::determineVersion(const QString &filename)
{
    QFile file;
    file.setFileName(filename);
    const bool succeed = file.open(QIODevice::ReadOnly | QIODevice::Text);
    if (!succeed)
        return 0;

    QXmlStreamReader reader(&file);
    while (!reader.atEnd()) {
        switch (reader.readNext()) {
        case QXmlStreamReader::StartElement:
            if (reader.name() == QString(ResultElementName)) {
                QXmlStreamAttributes attribs = reader.attributes();
                if (attribs.hasAttribute(QString(VersionAttribute))) {
                    const int ver = attribs.value(QString(), VersionAttribute).toString().toInt();
                    return ver;
                }
                return 1;
            }
            break;

        // Not handled
        case QXmlStreamReader::EndElement:
        case QXmlStreamReader::NoToken:
        case QXmlStreamReader::Invalid:
        case QXmlStreamReader::StartDocument:
        case QXmlStreamRead...",1,1,gui/xmlreport.cpp,XmlReport.determineVersion:int(QString&),<empty>,,false,61,98,determineVersion,,,1,int(QString&)
111669150893,METHOD,gui/xmlreport.h:<global>,TYPE_DECL,<global>,1,1,gui/xmlreport.h,gui/xmlreport.h:<global>,<empty>,,false,1,68,<global>,,,1,
111669150894,METHOD,gui/xmlreportv2.cpp:<global>,TYPE_DECL,"XmlReportV2::XmlReportV2(const QString &filename, QString productName) :
    XmlReport(filename),
    mProductName(std::move(productName)),
    mXmlReader(nullptr),
    mXmlWriter(nullptr)
{}",1,2,gui/xmlreportv2.cpp,"XmlReportV2.XmlReportV2:ANY(QString&,QString)",<empty>,,false,63,68,XmlReportV2,,,1,"XmlReportV2.XmlReportV2:ANY(QString&,QString)(QString&,QString)"
111669150895,METHOD,gui/xmlreportv2.cpp:<global>,TYPE_DECL,<global>,1,1,gui/xmlreportv2.cpp,gui/xmlreportv2.cpp:<global>,<empty>,,false,1,296,<global>,,,1,
111669150896,METHOD,gui/xmlreportv2.cpp:<global>,TYPE_DECL,"XmlReportV2::~XmlReportV2()
{
    delete mXmlReader;
    delete mXmlWriter;
}",1,1,gui/xmlreportv2.cpp,XmlReportV2.~XmlReportV2:ANY(),<empty>,,false,70,74,~XmlReportV2,,,1,ANY()
111669150897,METHOD,gui/xmlreportv2.cpp:<global>,TYPE_DECL,"bool XmlReportV2::create()
{
    if (Report::create()) {
        mXmlWriter = new QXmlStreamWriter(Report::getFile());
        return true;
    }
    return false;
}",1,1,gui/xmlreportv2.cpp,XmlReportV2.create:bool(),<empty>,,false,76,83,create,,,1,bool()
111669150898,METHOD,gui/xmlreportv2.cpp:<global>,TYPE_DECL,"bool XmlReportV2::open()
{
    if (Report::open()) {
        mXmlReader = new QXmlStreamReader(Report::getFile());
        return true;
    }
    return false;
}",1,1,gui/xmlreportv2.cpp,XmlReportV2.open:bool(),<empty>,,false,85,92,open,,,1,bool()
111669150899,METHOD,gui/xmlreportv2.cpp:<global>,TYPE_DECL,"void XmlReportV2::writeHeader()
{
    const auto nameAndVersion = Settings::getNameAndVersion(mProductName.toStdString());
    const QString name = QString::fromStdString(nameAndVersion.first);
    const QString version = nameAndVersion.first.empty() ? CppCheck::version() : QString::fromStdString(nameAndVersion.second);

    mXmlWriter->setAutoFormatting(true);
    mXmlWriter->writeStartDocument();
    mXmlWriter->writeStartElement(ResultElementName);
    mXmlWriter->writeAttribute(VersionAttribute, QString::number(2));
    mXmlWriter->writeStartElement(CppcheckElementName);
    if (!name.isEmpty())
        mXmlWriter->writeAttribute(ProductNameAttribute, name);
    mXmlWriter->writeAttribute(VersionAttribute, version);
    mXmlWriter->writeEndElement();
    mXmlWriter->writeStartElement(ErrorsElementName);
}",1,1,gui/xmlreportv2.cpp,XmlReportV2.writeHeader:void(),<empty>,,false,94,110,writeHeader,,,1,void()
111669150900,METHOD,gui/xmlreportv2.cpp:<global>,TYPE_DECL,"void XmlReportV2::writeFooter()
{
    mXmlWriter->writeEndElement(); // errors
    mXmlWriter->writeEndElement(); // results
    mXmlWriter->writeEndDocument();
}",1,1,gui/xmlreportv2.cpp,XmlReportV2.writeFooter:void(),<empty>,,false,112,117,writeFooter,,,1,void()
111669150901,METHOD,gui/xmlreportv2.cpp:<global>,TYPE_DECL,"void XmlReportV2::writeError(const ErrorItem &error)
{
    /*
       Error example from the core program in xml
       <error id=""mismatchAllocDealloc"" severity=""error"" msg=""Mismatching allocation and deallocation: k""
              verbose=""Mismatching allocation and deallocation: k"">
       <location file=""..\\..\\test\\test.cxx"" line=""16""/>
       <location file=""..\\..\\test\\test.cxx"" line=""32""/>
       </error>
     */

    mXmlWriter->writeStartElement(ErrorElementName);
    mXmlWriter->writeAttribute(IdAttribute, error.errorId);

    // Don't localize severity so we can read these files
    mXmlWriter->writeAttribute(SeverityAttribute, GuiSeverity::toString(error.severity));
    const QString summary = XmlReport::quoteMessage(error.summary);
    mXmlWriter->writeAttribute(MsgAttribute, summary);
    const QString message = XmlReport::quoteMessage(error.message);
    mXmlWriter->writeAttribute(VerboseAttribute, message);
    if (error.inconclusive)
        mXmlWriter->writeAttribute...",1,1,gui/xmlreportv2.cpp,XmlReportV2.writeError:void(ErrorItem&),<empty>,,false,119,169,writeError,,,1,void(ErrorItem&)
111669150902,METHOD,gui/xmlreportv2.cpp:<global>,TYPE_DECL,"QList<ErrorItem> XmlReportV2::read()
{
    QList<ErrorItem> errors;
    bool insideResults = false;
    if (!mXmlReader) {
        qDebug() << ""You must Open() the file before reading it!"";
        return errors;
    }
    while (!mXmlReader->atEnd()) {
        switch (mXmlReader->readNext()) {
        case QXmlStreamReader::StartElement:
            if (mXmlReader->name() == ResultElementName)
                insideResults = true;

            // Read error element from inside result element
            if (insideResults && mXmlReader->name() == ErrorElementName) {
                ErrorItem item = readError(mXmlReader);
                errors.append(item);
            }
            break;

        case QXmlStreamReader::EndElement:
            if (mXmlReader->name() == ResultElementName)
                insideResults = false;
            break;

        // Not handled
        case QXmlStreamReader::NoToken:
        case QXmlStreamReader::Invalid:
        case QXmlStreamReader::Star...",1,1,gui/xmlreportv2.cpp,XmlReportV2.read:QList<ErrorItem>(),<empty>,,false,171,211,read,,,1,QList<ErrorItem>()
111669150903,METHOD,gui/xmlreportv2.cpp:<global>,TYPE_DECL,"ErrorItem XmlReportV2::readError(const QXmlStreamReader *reader)
{
    /*
       Error example from the core program in xml
       <error id=""mismatchAllocDealloc"" severity=""error"" msg=""Mismatching allocation and deallocation: k""
              verbose=""Mismatching allocation and deallocation: k"">
       <location file=""..\\..\\test\\test.cxx"" line=""16""/>
       <location file=""..\\..\\test\\test.cxx"" line=""32""/>
       </error>
     */

    ErrorItem item;

    // Read error element from inside errors element
    if (mXmlReader->name() == ErrorElementName) {
        QXmlStreamAttributes attribs = reader->attributes();
        item.errorId = attribs.value(QString(), IdAttribute).toString();
        item.severity = GuiSeverity::fromString(attribs.value(QString(), SeverityAttribute).toString());
        const QString summary = attribs.value(QString(), MsgAttribute).toString();
        item.summary = XmlReport::unquoteMessage(summary);
        const QString message = attribs.value(QString(), ...",1,1,gui/xmlreportv2.cpp,XmlReportV2.readError:ErrorItem(QXmlStreamReader*),<empty>,,false,213,296,readError,,,1,ErrorItem(QXmlStreamReader*)
111669150904,METHOD,gui/xmlreportv2.h:<global>,TYPE_DECL,<global>,1,1,gui/xmlreportv2.h,gui/xmlreportv2.h:<global>,<empty>,,false,1,99,<global>,,,1,
111669150905,METHOD,lib/addoninfo.cpp:<global>,TYPE_DECL,"static std::string getFullPath(const std::string &fileName, const std::string &exename, bool debug = false) {
    if (debug)
        std::cout << ""looking for addon '"" << fileName << ""'"" << std::endl;
    if (Path::isFile(fileName))
        return fileName;

    const std::string exepath = Path::getPathFromFilename(exename);
    if (debug)
        std::cout << ""looking for addon '"" << (exepath + fileName) << ""'"" << std::endl;
    if (Path::isFile(exepath + fileName))
        return exepath + fileName;
    if (debug)
        std::cout << ""looking for addon '"" << (exepath + ""addons/"" + fileName) << ""'"" << std::endl;
    if (Path::isFile(exepath + ""addons/"" + fileName))
        return exepath + ""addons/"" + fileName;

#ifdef FILESDIR
    if (debug)
        std::cout << ""looking for addon '"" << (FILESDIR + (""/"" + fileName)) << ""'"" << std::endl;
    if (Path::isFile(FILESDIR + (""/"" + fileName)))
        return FILESDIR + (""/"" + fileName);
    if (debug)
        std::cout << ""looking for a...",1,1,lib/addoninfo.cpp,"getFullPath:string(std.string&,std.string&,bool)",<empty>,,false,30,57,getFullPath,,,1,"string(std.string&,std.string&,bool)"
111669150906,METHOD,lib/addoninfo.cpp:<global>,TYPE_DECL,<global>,1,1,lib/addoninfo.cpp,lib/addoninfo.cpp:<global>,<empty>,,false,1,181,<global>,,,1,
111669150907,METHOD,lib/addoninfo.cpp:<global>,TYPE_DECL,"static std::string parseAddonInfo(AddonInfo& addoninfo, const picojson::value &json, const std::string &fileName, const std::string &exename) {
    const std::string& json_error = picojson::get_last_error();
    if (!json_error.empty()) {
        return ""Loading "" + fileName + "" failed. "" + json_error;
    }
    if (!json.is<picojson::object>())
        return ""Loading "" + fileName + "" failed. JSON is not an object."";

    // TODO: remove/complete default value handling for missing fields
    const picojson::object& obj = json.get<picojson::object>();
    {
        const auto it = obj.find(""args"");
        if (it != obj.cend()) {
            const auto& val = it->second;
            if (!val.is<picojson::array>())
                return ""Loading "" + fileName + "" failed. 'args' must be an array."";
            for (const picojson::value &v : val.get<picojson::array>()) {
                if (!v.is<std::string>())
                    return ""Loading "" + fileName + "" failed. 'args' entry...",1,1,lib/addoninfo.cpp,"parseAddonInfo:string(AddonInfo&,picojson.value&,std.string&,std.string&)",<empty>,,false,59,135,parseAddonInfo,,,1,"string(AddonInfo&,picojson.value&,std.string&,std.string&)"
111669150908,METHOD,lib/addoninfo.cpp:<global>,TYPE_DECL,"std::string AddonInfo::getAddonInfo(const std::string &fileName, const std::string &exename, bool debug) {
    if (fileName[0] == '{') {
        picojson::value json;
        const std::string err = picojson::parse(json, fileName);
        (void)err; // TODO: report
        return parseAddonInfo(*this, json, fileName, exename);
    }
    if (fileName.find('.') == std::string::npos)
        return getAddonInfo(fileName + "".py"", exename, debug);

    if (endsWith(fileName, "".py"")) {
        scriptFile = Path::fromNativeSeparators(getFullPath(fileName, exename, debug));
        if (scriptFile.empty())
            return ""Did not find addon "" + fileName;

        std::string::size_type pos1 = scriptFile.rfind('/');
        if (pos1 == std::string::npos)
            pos1 = 0;
        else
            pos1++;
        std::string::size_type pos2 = scriptFile.rfind('.');
        if (pos2 < pos1)
            pos2 = std::string::npos;
        name = scriptFile.substr(pos1, pos2 - pos1);

    ...",1,1,lib/addoninfo.cpp,"AddonInfo.getAddonInfo:string(std.string&,std.string&,bool)",<empty>,,false,137,181,getAddonInfo,,,1,"string(std.string&,std.string&,bool)"
111669150909,METHOD,<empty>,<empty>,<empty>,1,,lib/addoninfo.h,AddonInfo.<clinit>,<empty>,,false,26,,<clinit>,,,9,
111669150910,METHOD,lib/addoninfo.h:<global>,TYPE_DECL,<global>,1,1,lib/addoninfo.h,lib/addoninfo.h:<global>,<empty>,,false,1,38,<global>,,,1,
111669150911,METHOD,Analyzer.Action,TYPE_DECL,"void set(unsigned int f, bool state = true) {
            mFlag = state ? mFlag | f : mFlag & ~f;
        }",9,9,lib/analyzer.h,set,<empty>,,false,61,63,set,,,6,"void(unsigned int,bool)"
111669150912,METHOD,Analyzer.Result,TYPE_DECL,"void update(Result rhs) {
            if (terminate == Terminate::None)
                terminate = rhs.terminate;
            action |= rhs.action;
        }",9,9,lib/analyzer.h,update,<empty>,,false,144,148,update,,,4,void(Result)
111669150913,METHOD,<empty>,<empty>,<empty>,1,,lib/analyzer.h,Analyzer.<clinit>,<empty>,,false,34,,<clinit>,,,33,
111669150914,METHOD,lib/analyzer.h:<global>,TYPE_DECL,<global>,1,1,lib/analyzer.h,lib/analyzer.h:<global>,<empty>,,false,1,199,<global>,,,1,
111669150915,METHOD,lib/analyzerinfo.cpp:<global>,TYPE_DECL,"AnalyzerInformation::~AnalyzerInformation()
{
    close();
}",1,1,lib/analyzerinfo.cpp,AnalyzerInformation.~AnalyzerInformation:ANY(),<empty>,,false,31,34,~AnalyzerInformation,,,1,ANY()
111669150916,METHOD,lib/analyzerinfo.cpp:<global>,TYPE_DECL,<global>,1,1,lib/analyzerinfo.cpp,lib/analyzerinfo.cpp:<global>,<empty>,,false,1,163,<global>,,,1,
111669150917,METHOD,lib/analyzerinfo.cpp:<global>,TYPE_DECL,"static std::string getFilename(const std::string &fullpath)
{
    std::string::size_type pos1 = fullpath.find_last_of(""/\\\\"");
    pos1 = (pos1 == std::string::npos) ? 0U : (pos1 + 1U);
    std::string::size_type pos2 = fullpath.rfind('.');
    if (pos2 < pos1)
        pos2 = std::string::npos;
    if (pos2 != std::string::npos)
        pos2 = pos2 - pos1;
    return fullpath.substr(pos1,pos2);
}",1,1,lib/analyzerinfo.cpp,getFilename:string(std.string&),<empty>,,false,36,46,getFilename,,,1,string(std.string&)
111669150918,METHOD,lib/analyzerinfo.cpp:<global>,TYPE_DECL,"void AnalyzerInformation::writeFilesTxt(const std::string &buildDir, const std::list<std::string> &sourcefiles, const std::string &userDefines, const std::list<FileSettings> &fileSettings)
{
    std::map<std::string, unsigned int> fileCount;

    const std::string filesTxt(buildDir + ""/files.txt"");
    std::ofstream fout(filesTxt);
    for (const std::string &f : sourcefiles) {
        const std::string afile = getFilename(f);
        fout << afile << "".a"" << (++fileCount[afile]) << ""::"" << Path::simplifyPath(f) << '\\n';
        if (!userDefines.empty())
            fout << afile << "".a"" << (++fileCount[afile]) << "":"" << userDefines << "":"" << Path::simplifyPath(f) << '\\n';
    }

    for (const FileSettings &fs : fileSettings) {
        const std::string afile = getFilename(fs.filename());
        fout << afile << "".a"" << (++fileCount[afile]) << "":"" << fs.cfg << "":"" << Path::simplifyPath(fs.filename()) << std::endl;
    }
}",1,1,lib/analyzerinfo.cpp,"AnalyzerInformation.writeFilesTxt:void(std.string&,std.list<std.string>&,std.string&,std.list<FileSettings>&)",<empty>,,false,48,65,writeFilesTxt,,,1,"void(std.string&,std.list<std.string>&,std.string&,std.list<FileSettings>&)"
111669150919,METHOD,lib/analyzerinfo.cpp:<global>,TYPE_DECL,"void AnalyzerInformation::close()
{
    mAnalyzerInfoFile.clear();
    if (mOutputStream.is_open()) {
        mOutputStream << ""</analyzerinfo>\\n"";
        mOutputStream.close();
    }
}",1,1,lib/analyzerinfo.cpp,AnalyzerInformation.close:void(),<empty>,,false,67,74,close,,,1,void()
111669150920,METHOD,lib/analyzerinfo.cpp:<global>,TYPE_DECL,"static bool skipAnalysis(const std::string &analyzerInfoFile, std::size_t hash, std::list<ErrorMessage> &errors)
{
    tinyxml2::XMLDocument doc;
    const tinyxml2::XMLError error = doc.LoadFile(analyzerInfoFile.c_str());
    if (error != tinyxml2::XML_SUCCESS)
        return false;

    const tinyxml2::XMLElement * const rootNode = doc.FirstChildElement();
    if (rootNode == nullptr)
        return false;

    const char *attr = rootNode->Attribute(""hash"");
    if (!attr || attr != std::to_string(hash))
        return false;

    for (const tinyxml2::XMLElement *e = rootNode->FirstChildElement(); e; e = e->NextSiblingElement()) {
        if (std::strcmp(e->Name(), ""error"") == 0)
            errors.emplace_back(e);
    }

    return true;
}",1,1,lib/analyzerinfo.cpp,"skipAnalysis:bool(std.string&,std.size_t,std.list<ErrorMessage>&)",<empty>,,false,76,97,skipAnalysis,,,1,"bool(std.string&,std.size_t,std.list<ErrorMessage>&)"
111669150921,METHOD,lib/analyzerinfo.cpp:<global>,TYPE_DECL,"std::string AnalyzerInformation::getAnalyzerInfoFileFromFilesTxt(std::istream& filesTxt, const std::string &sourcefile, const std::string &cfg)
{
    std::string line;
    const std::string end(':' + cfg + ':' + Path::simplifyPath(sourcefile));
    while (std::getline(filesTxt,line)) {
        if (line.size() <= end.size() + 2U)
            continue;
        if (!endsWith(line, end.c_str(), end.size()))
            continue;
        return line.substr(0,line.find(':'));
    }
    return """";
}",1,1,lib/analyzerinfo.cpp,"AnalyzerInformation.getAnalyzerInfoFileFromFilesTxt:string(std.istream&,std.string&,std.string&)",<empty>,,false,99,111,getAnalyzerInfoFileFromFilesTxt,,,1,"string(std.istream&,std.string&,std.string&)"
111669150922,METHOD,lib/analyzerinfo.cpp:<global>,TYPE_DECL,"std::string AnalyzerInformation::getAnalyzerInfoFile(const std::string &buildDir, const std::string &sourcefile, const std::string &cfg)
{
    std::ifstream fin(Path::join(buildDir, ""files.txt""));
    if (fin.is_open()) {
        const std::string& ret = getAnalyzerInfoFileFromFilesTxt(fin, sourcefile, cfg);
        if (!ret.empty())
            return Path::join(buildDir, ret);
    }

    const std::string::size_type pos = sourcefile.rfind('/');
    std::string filename;
    if (pos == std::string::npos)
        filename = sourcefile;
    else
        filename = sourcefile.substr(pos + 1);
    return Path::join(buildDir, filename) + "".analyzerinfo"";
}",1,1,lib/analyzerinfo.cpp,"AnalyzerInformation.getAnalyzerInfoFile:string(std.string&,std.string&,std.string&)",<empty>,,false,113,129,getAnalyzerInfoFile,,,1,"string(std.string&,std.string&,std.string&)"
111669150923,METHOD,lib/analyzerinfo.cpp:<global>,TYPE_DECL,"bool AnalyzerInformation::analyzeFile(const std::string &buildDir, const std::string &sourcefile, const std::string &cfg, std::size_t hash, std::list<ErrorMessage> &errors)
{
    if (buildDir.empty() || sourcefile.empty())
        return true;
    close();

    mAnalyzerInfoFile = AnalyzerInformation::getAnalyzerInfoFile(buildDir,sourcefile,cfg);

    if (skipAnalysis(mAnalyzerInfoFile, hash, errors))
        return false;

    mOutputStream.open(mAnalyzerInfoFile);
    if (mOutputStream.is_open()) {
        mOutputStream << ""<?xml version=\\""1.0\\""?>\\n"";
        mOutputStream << ""<analyzerinfo hash=\\"""" << hash << ""\\"">\\n"";
    } else {
        mAnalyzerInfoFile.clear();
    }

    return true;
}",1,1,lib/analyzerinfo.cpp,"AnalyzerInformation.analyzeFile:bool(std.string&,std.string&,std.string&,std.size_t,std.list<ErrorMessage>&)",<empty>,,false,131,151,analyzeFile,,,1,"bool(std.string&,std.string&,std.string&,std.size_t,std.list<ErrorMessage>&)"
111669150924,METHOD,lib/analyzerinfo.cpp:<global>,TYPE_DECL,"void AnalyzerInformation::reportErr(const ErrorMessage &msg)
{
    if (mOutputStream.is_open())
        mOutputStream << msg.toXML() << '\\n';
}",1,1,lib/analyzerinfo.cpp,AnalyzerInformation.reportErr:void(ErrorMessage&),<empty>,,false,153,157,reportErr,,,1,void(ErrorMessage&)
111669150925,METHOD,lib/analyzerinfo.cpp:<global>,TYPE_DECL,"void AnalyzerInformation::setFileInfo(const std::string &check, const std::string &fileInfo)
{
    if (mOutputStream.is_open() && !fileInfo.empty())
        mOutputStream << ""  <FileInfo check=\\"""" << check << ""\\"">\\n"" << fileInfo << ""  </FileInfo>\\n"";
}",1,1,lib/analyzerinfo.cpp,"AnalyzerInformation.setFileInfo:void(std.string&,std.string&)",<empty>,,false,159,163,setFileInfo,,,1,"void(std.string&,std.string&)"
111669150926,METHOD,lib/analyzerinfo.h:<global>,TYPE_DECL,<global>,1,1,lib/analyzerinfo.h,lib/analyzerinfo.h:<global>,<empty>,,false,1,71,<global>,,,1,
111669150927,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* findExpression(const nonneg int exprid,
                            const Token* start,
                            const Token* end,
                            const std::function<bool(const Token*)>& pred)
{
    if (exprid == 0)
        return nullptr;
    if (!precedes(start, end))
        return nullptr;
    for (const Token* tok = start; tok != end; tok = tok->next()) {
        if (tok->exprId() != exprid)
            continue;
        if (pred(tok))
            return tok;
    }
    return nullptr;
}",1,34,lib/astutils.cpp,"findExpression:Token*(int,Token*,Token*,std.function<bool(constToken*)>&)",<empty>,,false,51,67,findExpression,,,1,"Token*(int,Token*,Token*,std.function<bool(constToken*)>&)"
111669150928,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,<global>,1,78,lib/astutils.cpp,lib/astutils.cpp:<global>,<empty>,,false,1,3866,<global>,,,1,
111669150929,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static int findArgumentPosRecursive(const Token* tok, const Token* tokToFind,  bool &found, nonneg int depth=0)
{
    ++depth;
    if (!tok || depth >= 100)
        return -1;
    if (tok->str() == "","") {
        int res = findArgumentPosRecursive(tok->astOperand1(), tokToFind, found, depth);
        if (res == -1)
            return -1;
        if (found)
            return res;
        const int argn = res;
        res = findArgumentPosRecursive(tok->astOperand2(), tokToFind, found, depth);
        if (res == -1)
            return -1;
        return argn + res;
    }
    if (tokToFind == tok)
        found = true;
    return 1;
}",1,92,lib/astutils.cpp,"findArgumentPosRecursive:int(Token*,Token*,bool&,int)",<empty>,,false,69,89,findArgumentPosRecursive,,,1,"int(Token*,Token*,bool&,int)"
111669150930,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static int findArgumentPos(const Token* tok, const Token* tokToFind){
    bool found = false;
    const int argn = findArgumentPosRecursive(tok, tokToFind, found, 0);
    if (found)
        return argn - 1;
    return -1;
}",1,1,lib/astutils.cpp,"findArgumentPos:int(Token*,Token*)",<empty>,,false,91,97,findArgumentPos,,,1,"int(Token*,Token*)"
111669150931,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static int getArgumentPos(const Token* ftok, const Token* tokToFind){
    const Token* tok = ftok;
    if (Token::Match(tok, ""%name% (|{""))
        tok = ftok->next();
    if (!Token::Match(tok, ""(|{|[""))
        return -1;
    const Token* startTok = tok->astOperand2();
    if (!startTok && tok->next() != tok->link())
        startTok = tok->astOperand1();
    return findArgumentPos(startTok, tokToFind);
}",1,1,lib/astutils.cpp,"getArgumentPos:int(Token*,Token*)",<empty>,,false,99,109,getArgumentPos,,,1,"int(Token*,Token*)"
111669150932,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static void astFlattenCopy(T* tok, const char* op, OuputIterator out, nonneg int depth = 100)
{
    --depth;
    if (!tok || depth < 0)
        return;
    if (strcmp(tok->str().c_str(), op) == 0) {
        astFlattenCopy(tok->astOperand1(), op, out, depth);
        astFlattenCopy(tok->astOperand2(), op, out, depth);
    } else {
        *out = tok;
        ++out;
    }
}",1,70,lib/astutils.cpp,"astFlattenCopy:void(T*,char*,OuputIterator,int)",<empty>,,false,112,124,astFlattenCopy,,,1,"void(T*,char*,OuputIterator,int)"
111669150933,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"std::vector<const Token*> astFlatten(const Token* tok, const char* op)
{
    std::vector<const Token*> result;
    astFlattenCopy(tok, op, std::back_inserter(result));
    return result;
}",1,1,lib/astutils.cpp,"astFlatten:vector<constToken*>(Token*,char*)",<empty>,,false,126,131,astFlatten,,,1,"vector<const Token*>(Token*,char*)"
111669150934,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"std::vector<Token*> astFlatten(Token* tok, const char* op)
{
    std::vector<Token*> result;
    astFlattenCopy(tok, op, std::back_inserter(result));
    return result;
}",1,1,lib/astutils.cpp,"astFlatten:vector<Token*>(Token*,char*)",<empty>,,false,133,138,astFlatten,,,1,"vector<Token*>(Token*,char*)"
111669150935,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"int astCount(const Token* tok, const char* op, int depth)
{
    --depth;
    if (!tok || depth < 0)
        return 0;
    if (strcmp(tok->str().c_str(), op) == 0)
        return astCount(tok->astOperand1(), op, depth) + astCount(tok->astOperand2(), op, depth);
    return 1;
}",8,1,lib/astutils.cpp,"astCount:int(Token*,char*,int)",<empty>,,false,140,148,astCount,,,1,"int(Token*,char*,int)"
111669150936,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astHasToken(const Token* root, const Token * tok)
{
    if (!root)
        return false;
    while (tok->astParent() && tok != root)
        tok = tok->astParent();
    return root == tok;
}",1,1,lib/astutils.cpp,"astHasToken:bool(Token*,Token*)",<empty>,,false,150,157,astHasToken,,,1,"bool(Token*,Token*)"
111669150937,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astHasVar(const Token * tok, nonneg int varid)
{
    if (!tok)
        return false;
    if (tok->varId() == varid)
        return true;
    return astHasVar(tok->astOperand1(), varid) || astHasVar(tok->astOperand2(), varid);
}",1,34,lib/astutils.cpp,"astHasVar:bool(Token*,int)",<empty>,,false,159,166,astHasVar,,,1,"bool(Token*,int)"
111669150938,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astHasExpr(const Token* tok, nonneg int exprid)
{
    if (!tok)
        return false;
    if (tok->exprId() == exprid)
        return true;
    return astHasExpr(tok->astOperand1(), exprid) || astHasExpr(tok->astOperand2(), exprid);
}",1,34,lib/astutils.cpp,"astHasExpr:bool(Token*,int)",<empty>,,false,168,175,astHasExpr,,,1,"bool(Token*,int)"
111669150939,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool astIsCharWithSign(const Token *tok, ValueType::Sign sign)
{
    if (!tok)
        return false;
    const ValueType *valueType = tok->valueType();
    if (!valueType)
        return false;
    return valueType->type == ValueType::Type::CHAR && valueType->pointer == 0U && valueType->sign == sign;
}",1,1,lib/astutils.cpp,"astIsCharWithSign:bool(Token*,ValueType.Sign)",<empty>,,false,177,185,astIsCharWithSign,,,1,"bool(Token*,ValueType.Sign)"
111669150940,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astIsSignedChar(const Token *tok)
{
    return astIsCharWithSign(tok, ValueType::Sign::SIGNED);
}",1,1,lib/astutils.cpp,astIsSignedChar:bool(Token*),<empty>,,false,187,190,astIsSignedChar,,,1,bool(Token*)
111669150941,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astIsUnknownSignChar(const Token *tok)
{
    return astIsCharWithSign(tok, ValueType::Sign::UNKNOWN_SIGN);
}",1,1,lib/astutils.cpp,astIsUnknownSignChar:bool(Token*),<empty>,,false,192,195,astIsUnknownSignChar,,,1,bool(Token*)
111669150942,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astIsGenericChar(const Token* tok)
{
    return !astIsPointer(tok) && tok && tok->valueType() && (tok->valueType()->type == ValueType::Type::CHAR || tok->valueType()->type == ValueType::Type::WCHAR_T);
}",1,1,lib/astutils.cpp,astIsGenericChar:bool(Token*),<empty>,,false,197,200,astIsGenericChar,,,1,bool(Token*)
111669150943,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astIsPrimitive(const Token* tok)
{
    const ValueType* vt = tok ? tok->valueType() : nullptr;
    if (!vt)
        return false;
    return vt->isPrimitive();
}",1,1,lib/astutils.cpp,astIsPrimitive:bool(Token*),<empty>,,false,202,208,astIsPrimitive,,,1,bool(Token*)
111669150944,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astIsIntegral(const Token *tok, bool unknown)
{
    const ValueType *vt = tok ? tok->valueType() : nullptr;
    if (!vt)
        return unknown;
    return vt->isIntegral() && vt->pointer == 0U;
}",1,1,lib/astutils.cpp,"astIsIntegral:bool(Token*,bool)",<empty>,,false,210,216,astIsIntegral,,,1,"bool(Token*,bool)"
111669150945,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astIsUnsigned(const Token* tok)
{
    return tok && tok->valueType() && tok->valueType()->sign == ValueType::UNSIGNED;
}",1,1,lib/astutils.cpp,astIsUnsigned:bool(Token*),<empty>,,false,218,221,astIsUnsigned,,,1,bool(Token*)
111669150946,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astIsFloat(const Token *tok, bool unknown)
{
    const ValueType *vt = tok ? tok->valueType() : nullptr;
    if (!vt)
        return unknown;
    return vt->type >= ValueType::Type::FLOAT && vt->pointer == 0U;
}",1,1,lib/astutils.cpp,"astIsFloat:bool(Token*,bool)",<empty>,,false,223,229,astIsFloat,,,1,"bool(Token*,bool)"
111669150947,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astIsBool(const Token *tok)
{
    return tok && (tok->isBoolean() || (tok->valueType() && tok->valueType()->type == ValueType::Type::BOOL && !tok->valueType()->pointer));
}",1,1,lib/astutils.cpp,astIsBool:bool(Token*),<empty>,,false,231,234,astIsBool,,,1,bool(Token*)
111669150948,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astIsPointer(const Token *tok)
{
    return tok && tok->valueType() && tok->valueType()->pointer;
}",1,1,lib/astutils.cpp,astIsPointer:bool(Token*),<empty>,,false,236,239,astIsPointer,,,1,bool(Token*)
111669150949,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astIsSmartPointer(const Token* tok)
{
    return tok && tok->valueType() && tok->valueType()->smartPointerTypeToken;
}",1,1,lib/astutils.cpp,astIsSmartPointer:bool(Token*),<empty>,,false,241,244,astIsSmartPointer,,,1,bool(Token*)
111669150950,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astIsUniqueSmartPointer(const Token* tok)
{
    if (!astIsSmartPointer(tok))
        return false;
    if (!tok->valueType()->smartPointer)
        return false;
    return tok->valueType()->smartPointer->unique;
}",1,1,lib/astutils.cpp,astIsUniqueSmartPointer:bool(Token*),<empty>,,false,246,253,astIsUniqueSmartPointer,,,1,bool(Token*)
111669150951,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astIsIterator(const Token *tok)
{
    return tok && tok->valueType() && tok->valueType()->type == ValueType::Type::ITERATOR;
}",1,1,lib/astutils.cpp,astIsIterator:bool(Token*),<empty>,,false,255,258,astIsIterator,,,1,bool(Token*)
111669150952,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astIsContainer(const Token* tok) {
    return getLibraryContainer(tok) != nullptr && !astIsIterator(tok);
}",1,1,lib/astutils.cpp,astIsContainer:bool(Token*),<empty>,,false,260,262,astIsContainer,,,1,bool(Token*)
111669150953,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astIsNonStringContainer(const Token* tok)
{
    const Library::Container* container = getLibraryContainer(tok);
    return container && !container->stdStringLike && !astIsIterator(tok);
}",1,1,lib/astutils.cpp,astIsNonStringContainer:bool(Token*),<empty>,,false,264,268,astIsNonStringContainer,,,1,bool(Token*)
111669150954,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astIsContainerView(const Token* tok)
{
    const Library::Container* container = getLibraryContainer(tok);
    return container && !astIsIterator(tok) && container->view;
}",1,1,lib/astutils.cpp,astIsContainerView:bool(Token*),<empty>,,false,270,274,astIsContainerView,,,1,bool(Token*)
111669150955,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astIsContainerOwned(const Token* tok) {
    return astIsContainer(tok) && !astIsContainerView(tok);
}",1,1,lib/astutils.cpp,astIsContainerOwned:bool(Token*),<empty>,,false,276,278,astIsContainerOwned,,,1,bool(Token*)
111669150956,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astIsContainerString(const Token* tok)
{
    if (!tok)
        return false;
    if (!tok->valueType())
        return false;
    const Library::Container* container = tok->valueType()->container;
    if (!container)
        return false;
    return container->stdStringLike;
}",1,1,lib/astutils.cpp,astIsContainerString:bool(Token*),<empty>,,false,280,290,astIsContainerString,,,1,bool(Token*)
111669150957,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static std::pair<const Token*, const Library::Container*> getContainerFunction(const Token* tok, const Settings* settings)
{
    const Library::Container* cont{};
    if (!tok || !tok->valueType() || (!tok->valueType()->container && (!settings || !(cont = settings->library.detectContainerOrIterator(tok->valueType()->smartPointerTypeToken)))))
        return {};
    const Token* parent = tok->astParent();
    if (Token::Match(parent, "". %name% ("") && astIsLHS(tok)) {
        return { parent->next(), cont ? cont : tok->valueType()->container };
    }
    return {};
}",1,1,lib/astutils.cpp,"getContainerFunction:pair<constToken*,constLibrary.Container*>(Token*,Settings*)",<empty>,,false,292,302,getContainerFunction,,,1,"pair<const Token*,const Library::Container*>(Token*,Settings*)"
111669150958,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"Library::Container::Action astContainerAction(const Token* tok, const Token** ftok, const Settings* settings)
{
    const auto ftokCont = getContainerFunction(tok, settings);
    if (ftok)
        *ftok = ftokCont.first;
    if (!ftokCont.first)
        return Library::Container::Action::NO_ACTION;
    return ftokCont.second->getAction(ftokCont.first->str());
}",1,1,lib/astutils.cpp,"astContainerAction:Library.Container.Action(Token*,Token**,Settings*)",<empty>,,false,304,312,astContainerAction,,,1,"Library.Container.Action(Token*,Token**,Settings*)"
111669150959,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"Library::Container::Yield astContainerYield(const Token* tok, const Token** ftok, const Settings* settings)
{
    const auto ftokCont = getContainerFunction(tok, settings);
    if (ftok)
        *ftok = ftokCont.first;
    if (!ftokCont.first)
        return Library::Container::Yield::NO_YIELD;
    return ftokCont.second->getYield(ftokCont.first->str());
}",1,1,lib/astutils.cpp,"astContainerYield:Library.Container.Yield(Token*,Token**,Settings*)",<empty>,,false,314,322,astContainerYield,,,1,"Library.Container.Yield(Token*,Token**,Settings*)"
111669150960,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"Library::Container::Yield astFunctionYield(const Token* tok, const Settings& settings, const Token** ftok)
{
    if (!tok)
        return Library::Container::Yield::NO_YIELD;

    const auto* function = settings.library.getFunction(tok);
    if (!function)
        return Library::Container::Yield::NO_YIELD;

    if (ftok)
        *ftok = tok;
    return function->containerYield;
}",1,1,lib/astutils.cpp,"astFunctionYield:Library.Container.Yield(Token*,Settings&,Token**)",<empty>,,false,324,336,astFunctionYield,,,1,"Library.Container.Yield(Token*,Settings&,Token**)"
111669150961,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astIsRangeBasedForDecl(const Token* tok)
{
    return Token::simpleMatch(tok->astParent(), "":"") && Token::simpleMatch(tok->astParent()->astParent(), ""("");
}",1,1,lib/astutils.cpp,astIsRangeBasedForDecl:bool(Token*),<empty>,,false,338,341,astIsRangeBasedForDecl,,,1,bool(Token*)
111669150962,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"std::string astCanonicalType(const Token *expr, bool pointedToType)
{
    if (!expr)
        return """";
    std::pair<const Token*, const Token*> decl = Token::typeDecl(expr, pointedToType);
    if (decl.first && decl.second) {
        std::string ret;
        for (const Token *type = decl.first; Token::Match(type,""%name%|::"") && type != decl.second; type = type->next()) {
            if (!Token::Match(type, ""const|static""))
                ret += type->str();
        }
        return ret;
    }
    return """";
}",1,1,lib/astutils.cpp,"astCanonicalType:string(Token*,bool)",<empty>,,false,343,357,astCanonicalType,,,1,"string(Token*,bool)"
111669150963,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool match(const Token *tok, const std::string &rhs)
{
    if (tok->str() == rhs)
        return true;
    if (!tok->varId() && tok->hasKnownIntValue() && MathLib::toString(tok->getKnownIntValue()) == rhs)
        return true;
    return false;
}",1,1,lib/astutils.cpp,"match:bool(Token*,std.string&)",<empty>,,false,359,366,match,,,1,"bool(Token*,std.string&)"
111669150964,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token * astIsVariableComparison(const Token *tok, const std::string &comp, const std::string &rhs, const Token **vartok)
{
    if (!tok)
        return nullptr;

    const Token *ret = nullptr;
    if (tok->isComparisonOp()) {
        if (tok->astOperand1() && match(tok->astOperand1(), rhs)) {
            // Invert comparator
            std::string s = tok->str();
            if (s[0] == '>')
                s[0] = '<';
            else if (s[0] == '<')
                s[0] = '>';
            if (s == comp) {
                ret = tok->astOperand2();
            }
        } else if (tok->str() == comp && tok->astOperand2() && match(tok->astOperand2(), rhs)) {
            ret = tok->astOperand1();
        }
    } else if (comp == ""!="" && rhs == ""0"") {
        if (tok->str() == ""!"") {
            ret = tok->astOperand1();
            // handle (!(x==0)) as (x!=0)
            astIsVariableComparison(ret, ""=="", ""0"", &ret);
        } else
            ret = tok;
    } else if (comp...",1,1,lib/astutils.cpp,"astIsVariableComparison:Token*(Token*,std.string&,std.string&,Token**)",<empty>,,false,368,411,astIsVariableComparison,,,1,"Token*(Token*,std.string&,std.string&,Token**)"
111669150965,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isVariableDecl(const Token* tok)
{
    if (!tok)
        return false;
    const Variable* var = tok->variable();
    if (!var)
        return false;
    if (var->nameToken() == tok)
        return true;
    const Token * const varDeclEndToken = var->declEndToken();
    return Token::Match(varDeclEndToken, ""; %var%"") && varDeclEndToken->next() == tok;
}",1,1,lib/astutils.cpp,isVariableDecl:bool(Token*),<empty>,,false,413,424,isVariableDecl,,,1,bool(Token*)
111669150966,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isStlStringType(const Token* tok)
{
    return Token::Match(tok, ""std :: string|wstring|u16string|u32string !!::"") ||
           (Token::simpleMatch(tok, ""std :: basic_string <"") && !Token::simpleMatch(tok->linkAt(3), ""> ::""));
}",1,1,lib/astutils.cpp,isStlStringType:bool(Token*),<empty>,,false,426,430,isStlStringType,,,1,bool(Token*)
111669150967,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isTemporary(const Token* tok, const Library* library, bool unknown)
{
    if (!tok)
        return false;
    if (Token::simpleMatch(tok, "".""))
        return (tok->originalName() != ""->"" && isTemporary(tok->astOperand1(), library)) ||
               isTemporary(tok->astOperand2(), library);
    if (Token::Match(tok, "",|::""))
        return isTemporary(tok->astOperand2(), library);
    if (tok->isCast() || (tok->isCpp() && isCPPCast(tok)))
        return isTemporary(tok->astOperand2(), library);
    if (Token::Match(tok, "".|[|++|--|%name%|%assign%""))
        return false;
    if (tok->isUnaryOp(""*""))
        return false;
    if (Token::Match(tok, ""&|<<|>>"") && isLikelyStream(tok->astOperand1()))
        return false;
    if (Token::simpleMatch(tok, ""?"")) {
        const Token* branchTok = tok->astOperand2();
        if (!branchTok->astOperand1() || !branchTok->astOperand1()->valueType())
            return false;
        if (!branchTok->astOperand2()->valueType())
            ...",1,1,lib/astutils.cpp,"isTemporary:bool(Token*,Library*,bool)",<empty>,,false,432,498,isTemporary,,,1,"bool(Token*,Library*,bool)"
111669150968,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool isFunctionCall(const Token* tok)
{
    if (Token::Match(tok, ""%name% (""))
        return true;
    if (Token::Match(tok, ""%name% <"") && Token::simpleMatch(tok->linkAt(1), ""> (""))
        return true;
    if (Token::Match(tok, ""%name% ::""))
        return isFunctionCall(tok->tokAt(2));
    return false;
}",1,1,lib/astutils.cpp,isFunctionCall:bool(Token*),<empty>,,false,500,509,isFunctionCall,,,1,bool(Token*)
111669150969,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool hasToken(const Token * startTok, const Token * stopTok, const Token * tok)
{
    for (const Token * tok2 = startTok; tok2 != stopTok; tok2 = tok2->next()) {
        if (tok2 == tok)
            return true;
    }
    return false;
}",1,1,lib/astutils.cpp,"hasToken:bool(Token*,Token*,Token*)",<empty>,,false,511,518,hasToken,,,1,"bool(Token*,Token*,Token*)"
111669150970,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static T* previousBeforeAstLeftmostLeafGeneric(T* tok)
{
    if (!tok)
        return nullptr;
    T* leftmostLeaf = tok;
    while (leftmostLeaf->astOperand1())
        leftmostLeaf = leftmostLeaf->astOperand1();
    return leftmostLeaf->previous();
}",1,1,lib/astutils.cpp,previousBeforeAstLeftmostLeafGeneric:T(T*),<empty>,,false,521,529,previousBeforeAstLeftmostLeafGeneric,,,1,T(T*)
111669150971,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* previousBeforeAstLeftmostLeaf(const Token* tok)
{
    return previousBeforeAstLeftmostLeafGeneric(tok);
}",1,1,lib/astutils.cpp,previousBeforeAstLeftmostLeaf:Token*(Token*),<empty>,,false,531,534,previousBeforeAstLeftmostLeaf,,,1,Token*(Token*)
111669150972,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"Token* previousBeforeAstLeftmostLeaf(Token* tok)
{
    return previousBeforeAstLeftmostLeafGeneric(tok);
}",1,1,lib/astutils.cpp,previousBeforeAstLeftmostLeaf<duplicate>0:Token*(Token*),<empty>,,false,535,538,previousBeforeAstLeftmostLeaf,,,1,Token*(Token*)
111669150973,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static T* nextAfterAstRightmostLeafGeneric(T* tok)
{
    T * rightmostLeaf = tok;
    if (!rightmostLeaf || !rightmostLeaf->astOperand1())
        return nullptr;
    do {
        if (T* lam = findLambdaEndToken(rightmostLeaf)) {
            rightmostLeaf = lam;
            break;
        }
        if (rightmostLeaf->astOperand2() && precedes(rightmostLeaf, rightmostLeaf->astOperand2()))
            rightmostLeaf = rightmostLeaf->astOperand2();
        else if (rightmostLeaf->astOperand1() && precedes(rightmostLeaf, rightmostLeaf->astOperand1()))
            rightmostLeaf = rightmostLeaf->astOperand1();
        else
            break;
    } while (rightmostLeaf->astOperand1() || rightmostLeaf->astOperand2());
    while (Token::Match(rightmostLeaf->next(), ""]|)"") && !hasToken(rightmostLeaf->linkAt(1), rightmostLeaf->next(), tok))
        rightmostLeaf = rightmostLeaf->next();
    if (Token::Match(rightmostLeaf, ""{|(|["") && rightmostLeaf->link())
        rightmostLeaf = rightmostLeaf-...",1,1,lib/astutils.cpp,nextAfterAstRightmostLeafGeneric:T(T*),<empty>,,false,541,563,nextAfterAstRightmostLeafGeneric,,,1,T(T*)
111669150974,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* nextAfterAstRightmostLeaf(const Token* tok)
{
    return nextAfterAstRightmostLeafGeneric(tok);
}",1,1,lib/astutils.cpp,nextAfterAstRightmostLeaf:Token*(Token*),<empty>,,false,565,568,nextAfterAstRightmostLeaf,,,1,Token*(Token*)
111669150975,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"Token* nextAfterAstRightmostLeaf(Token* tok)
{
    return nextAfterAstRightmostLeafGeneric(tok);
}",1,1,lib/astutils.cpp,nextAfterAstRightmostLeaf<duplicate>0:Token*(Token*),<empty>,,false,569,572,nextAfterAstRightmostLeaf,,,1,Token*(Token*)
111669150976,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* astParentSkipParens(const Token* tok)
{
    return astParentSkipParens(const_cast<Token*>(tok));
}",1,1,lib/astutils.cpp,astParentSkipParens:Token*(Token*),<empty>,,false,574,577,astParentSkipParens,,,1,Token*(Token*)
111669150977,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"Token* astParentSkipParens(Token* tok)
{
    if (!tok)
        return nullptr;
    Token * parent = tok->astParent();
    if (!Token::simpleMatch(parent, ""(""))
        return parent;
    if (parent->link() != nextAfterAstRightmostLeaf(tok))
        return parent;
    if (Token::Match(parent->previous(), ""%name% ("") ||
        (Token::simpleMatch(parent->previous(), ""> ("") && parent->linkAt(-1)))
        return parent;
    return astParentSkipParens(parent);
}",1,1,lib/astutils.cpp,astParentSkipParens<duplicate>0:Token*(Token*),<empty>,,false,578,591,astParentSkipParens,,,1,Token*(Token*)
111669150978,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* getParentMember(const Token * tok)
{
    if (!tok)
        return tok;
    const Token * parent = tok->astParent();
    if (!Token::simpleMatch(parent, "".""))
        return tok;
    if (astIsRHS(tok)) {
        if (Token::simpleMatch(parent->astOperand1(), "".""))
            return parent->astOperand1()->astOperand2();
        return parent->astOperand1();
    }
    const Token * gparent = parent->astParent();
    if (!Token::simpleMatch(gparent, ""."") || gparent->astOperand2() != parent)
        return tok;
    if (gparent->astOperand1())
        return gparent->astOperand1();
    return tok;
}",1,1,lib/astutils.cpp,getParentMember:Token*(Token*),<empty>,,false,593,611,getParentMember,,,1,Token*(Token*)
111669150979,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* getParentLifetime(const Token* tok)
{
    if (!tok)
        return tok;
    // Skipping checking for variable if its a pointer-to-member
    if (!Token::simpleMatch(tok->previous(), "". *"")) {
        const Variable* var = tok->variable();
        // TODO: Call getLifetimeVariable for deeper analysis
        if (!var)
            return tok;
        if (var->isLocal() || var->isArgument())
            return tok;
    }
    const Token* parent = getParentMember(tok);
    if (parent != tok)
        return getParentLifetime(parent);
    return tok;
}",1,1,lib/astutils.cpp,getParentLifetime:Token*(Token*),<empty>,,false,613,630,getParentLifetime,,,1,Token*(Token*)
111669150980,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static std::vector<const Token*> getParentMembers(const Token* tok)
{
    if (!tok)
        return {};
    if (!Token::simpleMatch(tok->astParent(), "".""))
        return {tok};
    const Token* parent = tok->astParent();
    while (Token::simpleMatch(parent->astParent(), "".""))
        parent = parent->astParent();
    std::vector<const Token*> result;
    for (const Token* tok2 : astFlatten(parent, ""."")) {
        if (Token::simpleMatch(tok2, ""("") && Token::simpleMatch(tok2->astOperand1(), ""."")) {
            std::vector<const Token*> sub = getParentMembers(tok2->astOperand1());
            result.insert(result.end(), sub.cbegin(), sub.cend());
        }
        result.push_back(tok2);
    }
    return result;
}",1,1,lib/astutils.cpp,getParentMembers:vector<constToken*>(Token*),<empty>,,false,632,650,getParentMembers,,,1,vector<const Token*>(Token*)
111669150981,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static const Token* getParentLifetimeObject(const Token* tok)
{
    while (Token::simpleMatch(tok, ""[""))
        tok = tok->astOperand1();
    return tok;
}",1,1,lib/astutils.cpp,getParentLifetimeObject:Token*(Token*),<empty>,,false,652,657,getParentLifetimeObject,,,1,Token*(Token*)
111669150982,METHOD,<empty>,<empty>,"[&](const Token* tok2) {
        const Variable* var = tok2->variable();
        if (var)
            return var->isLocal() || var->isArgument();
        if (Token::simpleMatch(tok2, ""[""))
            return true;
        return isTemporary(tok2, &library);
    }",64,5,lib/astutils.cpp,lib/astutils.cpp:<global>.getParentLifetime.<lambda>0:bool(Token*),<empty>,,false,665,672,<lambda>0,,,1,bool(Token*)
111669150983,METHOD,<empty>,<empty>,"[&](const Token* tok2) {
        const Token* obj = getParentLifetimeObject(tok2);
        if (!obj)
            return false;
        const Variable* var = obj->variable();
        // Check for arrays first since astIsPointer will return true, but an array is not a borrowed type
        if (var && var->isArray())
            return false;
        if (astIsPointer(obj) || astIsContainerView(obj) || astIsIterator(obj))
            return true;
        if (!astIsUniqueSmartPointer(obj)) {
            if (astIsSmartPointer(obj))
                return true;
            const Token* dotTok = obj->next();
            if (!Token::simpleMatch(dotTok, ""."")) {
                const Token* endTok = nextAfterAstRightmostLeaf(obj);
                if (!endTok)
                    dotTok = obj->next();
                else if (Token::simpleMatch(endTok, "".""))
                    dotTok = endTok;
                else if (Token::simpleMatch(endTok->next(), "".""))
                    dotTok = endTok...",56,5,lib/astutils.cpp,lib/astutils.cpp:<global>.getParentLifetime.<lambda>1:bool(Token*),<empty>,,false,676,704,<lambda>1,,,1,bool(Token*)
111669150984,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* getParentLifetime(const Token* tok, const Library& library)
{
    std::vector<const Token*> members = getParentMembers(tok);
    if (members.size() < 2)
        return tok;
    // Find the first local variable, temporary, or array
    auto it = std::find_if(members.crbegin(), members.crend(), [&](const Token* tok2) {
        const Variable* var = tok2->variable();
        if (var)
            return var->isLocal() || var->isArgument();
        if (Token::simpleMatch(tok2, ""[""))
            return true;
        return isTemporary(tok2, &library);
    });
    if (it == members.rend())
        return tok;
    // If any of the submembers are borrowed types then stop
    if (std::any_of(it.base() - 1, members.cend() - 1, [&](const Token* tok2) {
        const Token* obj = getParentLifetimeObject(tok2);
        if (!obj)
            return false;
        const Variable* var = obj->variable();
        // Check for arrays first since astIsPointer will return true, but an array ...",1,1,lib/astutils.cpp,"getParentLifetime:Token*(Token*,Library&)",<empty>,,false,659,710,getParentLifetime,,,1,"Token*(Token*,Library&)"
111669150985,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool isInConstructorList(const Token* tok)
{
    if (!tok)
        return false;
    if (!astIsRHS(tok))
        return false;
    const Token* parent = tok->astParent();
    if (!Token::Match(parent, ""{|(""))
        return false;
    if (!Token::Match(parent->previous(), ""%var% {|(""))
        return false;
    if (!parent->astOperand1() || !parent->astOperand2())
        return false;
    do {
        parent = parent->astParent();
    } while (Token::simpleMatch(parent, "",""));
    return Token::simpleMatch(parent, "":"") && !Token::simpleMatch(parent->astParent(), ""?"");
}",1,1,lib/astutils.cpp,isInConstructorList:bool(Token*),<empty>,,false,712,729,isInConstructorList,,,1,bool(Token*)
111669150986,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"std::vector<ValueType> getParentValueTypes(const Token* tok, const Settings& settings, const Token** parent)
{
    if (!tok)
        return {};
    if (!tok->astParent())
        return {};
    if (isInConstructorList(tok)) {
        if (parent)
            *parent = tok->astParent()->astOperand1();
        if (tok->astParent()->astOperand1()->valueType())
            return {*tok->astParent()->astOperand1()->valueType()};
        return {};
    }
    const Token* ftok = nullptr;
    if (Token::Match(tok->astParent(), ""(|{|,"")) {
        int argn = -1;
        ftok = getTokenArgumentFunction(tok, argn);
        const Token* typeTok = nullptr;
        if (ftok && argn >= 0) {
            if (ftok->function()) {
                std::vector<ValueType> result;
                const Token* nameTok = nullptr;
                for (const Variable* var : getArgumentVars(ftok, argn)) {
                    if (!var)
                        continue;
                    if (!var->valueType())
 ...",1,1,lib/astutils.cpp,"getParentValueTypes:vector<ValueType>(Token*,Settings&,Token**)",<empty>,,false,731,803,getParentValueTypes,,,1,"vector<ValueType>(Token*,Settings&,Token**)"
111669150987,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astIsLHS(const Token* tok)
{
    if (!tok)
        return false;
    const Token* parent = tok->astParent();
    if (!parent)
        return false;
    if (!parent->astOperand1())
        return false;
    if (!parent->astOperand2())
        return false;
    return parent->astOperand1() == tok;
}",1,1,lib/astutils.cpp,astIsLHS:bool(Token*),<empty>,,false,805,817,astIsLHS,,,1,bool(Token*)
111669150988,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool astIsRHS(const Token* tok)
{
    if (!tok)
        return false;
    const Token* parent = tok->astParent();
    if (!parent)
        return false;
    if (!parent->astOperand1())
        return false;
    if (!parent->astOperand2())
        return false;
    return parent->astOperand2() == tok;
}",1,1,lib/astutils.cpp,astIsRHS:bool(Token*),<empty>,,false,818,830,astIsRHS,,,1,bool(Token*)
111669150989,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static T* getCondTokImpl(T* tok)
{
    if (!tok)
        return nullptr;
    if (Token::simpleMatch(tok, ""(""))
        return getCondTok(tok->previous());
    if (Token::simpleMatch(tok, ""do {"")) {
        T* endTok = tok->linkAt(1);
        if (Token::simpleMatch(endTok, ""} while (""))
            return endTok->tokAt(2)->astOperand2();
    }
    if (Token::simpleMatch(tok, ""for"") && Token::simpleMatch(tok->next()->astOperand2(), "";"") &&
        tok->next()->astOperand2()->astOperand2())
        return tok->next()->astOperand2()->astOperand2()->astOperand1();
    if (Token::simpleMatch(tok->next()->astOperand2(), "";""))
        return tok->next()->astOperand2()->astOperand1();
    if (tok->isName() && !tok->isControlFlowKeyword())
        return nullptr;
    return tok->next()->astOperand2();
}",1,1,lib/astutils.cpp,getCondTokImpl:T(T*),<empty>,,false,833,852,getCondTokImpl,,,1,T(T*)
111669150990,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static T* getCondTokFromEndImpl(T* endBlock)
{
    if (!Token::simpleMatch(endBlock, ""}""))
        return nullptr;
    T* startBlock = endBlock->link();
    if (!Token::simpleMatch(startBlock, ""{""))
        return nullptr;
    if (Token::simpleMatch(startBlock->previous(), ""do""))
        return getCondTok(startBlock->previous());
    if (Token::simpleMatch(startBlock->previous(), "")""))
        return getCondTok(startBlock->linkAt(-1));
    if (Token::simpleMatch(startBlock->tokAt(-2), ""} else {""))
        return getCondTokFromEnd(startBlock->tokAt(-2));
    return nullptr;
}",1,1,lib/astutils.cpp,getCondTokFromEndImpl:T(T*),<empty>,,false,855,869,getCondTokFromEndImpl,,,1,T(T*)
111669150991,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static T* getInitTokImpl(T* tok)
{
    if (!tok)
        return nullptr;
    if (Token::Match(tok, ""%name% (""))
        return getInitTokImpl(tok->next());
    if (tok->str() != ""("")
        return nullptr;
    if (!Token::simpleMatch(tok->astOperand2(), "";""))
        return nullptr;
    if (Token::simpleMatch(tok->astOperand2()->astOperand1(), "";""))
        return nullptr;
    return tok->astOperand2()->astOperand1();
}",1,1,lib/astutils.cpp,getInitTokImpl:T(T*),<empty>,,false,872,885,getInitTokImpl,,,1,T(T*)
111669150992,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static T* getStepTokImpl(T* tok)
{
    if (!tok)
        return nullptr;
    if (Token::Match(tok, ""%name% (""))
        return getStepTokImpl(tok->next());
    if (tok->str() != ""("")
        return nullptr;
    if (!Token::simpleMatch(tok->astOperand2(), "";""))
        return nullptr;
    if (!Token::simpleMatch(tok->astOperand2()->astOperand2(), "";""))
        return nullptr;
    return tok->astOperand2()->astOperand2()->astOperand2();
}",1,1,lib/astutils.cpp,getStepTokImpl:T(T*),<empty>,,false,888,901,getStepTokImpl,,,1,T(T*)
111669150993,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"Token* getCondTok(Token* tok)
{
    return getCondTokImpl(tok);
}",1,1,lib/astutils.cpp,getCondTok:Token*(Token*),<empty>,,false,903,906,getCondTok,,,1,Token*(Token*)
111669150994,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* getCondTok(const Token* tok)
{
    return getCondTokImpl(tok);
}",1,1,lib/astutils.cpp,getCondTok<duplicate>0:Token*(Token*),<empty>,,false,907,910,getCondTok,,,1,Token*(Token*)
111669150995,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"Token* getCondTokFromEnd(Token* endBlock)
{
    return getCondTokFromEndImpl(endBlock);
}",1,1,lib/astutils.cpp,getCondTokFromEnd:Token*(Token*),<empty>,,false,912,915,getCondTokFromEnd,,,1,Token*(Token*)
111669150996,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* getCondTokFromEnd(const Token* endBlock)
{
    return getCondTokFromEndImpl(endBlock);
}",1,1,lib/astutils.cpp,getCondTokFromEnd<duplicate>0:Token*(Token*),<empty>,,false,916,919,getCondTokFromEnd,,,1,Token*(Token*)
111669150997,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"Token* getInitTok(Token* tok) {
    return getInitTokImpl(tok);
}",1,1,lib/astutils.cpp,getInitTok:Token*(Token*),<empty>,,false,921,923,getInitTok,,,1,Token*(Token*)
111669150998,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* getInitTok(const Token* tok) {
    return getInitTokImpl(tok);
}",1,1,lib/astutils.cpp,getInitTok<duplicate>0:Token*(Token*),<empty>,,false,924,926,getInitTok,,,1,Token*(Token*)
111669150999,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"Token* getStepTok(Token* tok) {
    return getStepTokImpl(tok);
}",1,1,lib/astutils.cpp,getStepTok:Token*(Token*),<empty>,,false,928,930,getStepTok,,,1,Token*(Token*)
111669151000,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* getStepTok(const Token* tok) {
    return getStepTokImpl(tok);
}",1,1,lib/astutils.cpp,getStepTok<duplicate>0:Token*(Token*),<empty>,,false,931,933,getStepTok,,,1,Token*(Token*)
111669151001,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token *findNextTokenFromBreak(const Token *breakToken)
{
    const Scope *scope = breakToken->scope();
    while (scope) {
        if (scope->isLoopScope() || scope->type == ScopeType::eSwitch) {
            if (scope->type == ScopeType::eDo && Token::simpleMatch(scope->bodyEnd, ""} while (""))
                return scope->bodyEnd->linkAt(2)->next();
            return scope->bodyEnd;
        }
        scope = scope->nestedIn;
    }
    return nullptr;
}",1,1,lib/astutils.cpp,findNextTokenFromBreak:Token*(Token*),<empty>,,false,935,947,findNextTokenFromBreak,,,1,Token*(Token*)
111669151002,METHOD,<empty>,<empty>,"[varid, &condExpr](const Token *tok) {
        if (Token::Match(tok, ""%oror%|&&""))
            return ChildrenToVisit::op1_and_op2;
        if (Token::Match(tok, ""<|<="") && tok->isBinaryOp() && tok->astOperand1()->varId() == varid && tok->astOperand2()->hasKnownIntValue()) {
            if (Token::Match(condExpr, ""%oror%|&&"") || tok->astOperand2()->getKnownIntValue() < condExpr->astOperand2()->getKnownIntValue())
                condExpr = tok;
        }
        return ChildrenToVisit::none;
    }",29,5,lib/astutils.cpp,lib/astutils.cpp:<global>.extractForLoopValues.<lambda>2:ChildrenToVisit(Token*),<empty>,,false,977,985,<lambda>2,,,1,ChildrenToVisit(Token*)
111669151003,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool extractForLoopValues(const Token *forToken,
                          nonneg int &varid,
                          bool &knownInitValue,
                          MathLib::bigint &initValue,
                          bool &partialCond,
                          MathLib::bigint &stepValue,
                          MathLib::bigint &lastValue)
{
    if (!Token::simpleMatch(forToken, ""for ("") || !Token::simpleMatch(forToken->next()->astOperand2(), "";""))
        return false;
    const Token *initExpr = forToken->next()->astOperand2()->astOperand1();
    const Token *condExpr = forToken->next()->astOperand2()->astOperand2()->astOperand1();
    const Token *incExpr  = forToken->next()->astOperand2()->astOperand2()->astOperand2();
    if (!initExpr || !initExpr->isBinaryOp() || initExpr->str() != ""="" || !Token::Match(initExpr->astOperand1(), ""%var%""))
        return false;
    std::vector<MathLib::bigint> minInitValue =
        getMinValue(makeIntegralInferModel(), initExpr->astOpera...",1,26,lib/astutils.cpp,"extractForLoopValues:bool(Token*,int&,bool&,MathLib.bigint&,bool&,MathLib.bigint&,MathLib.bigint&)",<empty>,,false,949,996,extractForLoopValues,,,1,"bool(Token*,int&,bool&,MathLib.bigint&,bool&,MathLib.bigint&,MathLib.bigint&)"
111669151004,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static const Token * getVariableInitExpression(const Variable * var)
{
    if (!var)
        return nullptr;
    const Token *varDeclEndToken = var->declEndToken();
    if (!varDeclEndToken)
        return nullptr;
    if (Token::Match(varDeclEndToken, ""; %varid% ="", var->declarationId()))
        return varDeclEndToken->tokAt(2)->astOperand2();
    return varDeclEndToken->astOperand2();
}",1,1,lib/astutils.cpp,getVariableInitExpression:Token*(Variable*),<empty>,,false,999,1009,getVariableInitExpression,,,1,Token*(Variable*)
111669151005,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* isInLoopCondition(const Token* tok)
{
    const Token* top = tok->astTop();
    return Token::Match(top->previous(), ""for|while ("") ? top : nullptr;
}",1,1,lib/astutils.cpp,isInLoopCondition:Token*(Token*),<empty>,,false,1011,1015,isInLoopCondition,,,1,Token*(Token*)
111669151006,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool precedes(const Token * tok1, const Token * tok2)
{
    if (tok1 == tok2)
        return false;
    if (!tok1)
        return false;
    if (!tok2)
        return true;
    return tok1->index() < tok2->index();
}",1,1,lib/astutils.cpp,"precedes:bool(Token*,Token*)",<empty>,,false,1018,1027,precedes,,,1,"bool(Token*,Token*)"
111669151007,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool succeeds(const Token* tok1, const Token* tok2)
{
    if (tok1 == tok2)
        return false;
    if (!tok1)
        return false;
    if (!tok2)
        return true;
    return tok1->index() > tok2->index();
}",1,1,lib/astutils.cpp,"succeeds:bool(Token*,Token*)",<empty>,,false,1030,1039,succeeds,,,1,"bool(Token*,Token*)"
111669151008,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isAliasOf(const Token *tok, nonneg int varid, bool* inconclusive)
{
    if (tok->varId() == varid)
        return false;
    // NOLINTNEXTLINE(readability-use-anyofallof) - TODO: fix this / also Cppcheck false negative
    for (const ValueFlow::Value &val : tok->values()) {
        if (!val.isLocalLifetimeValue())
            continue;
        if (val.tokvalue->varId() == varid) {
            if (val.isInconclusive()) {
                if (inconclusive)
                    *inconclusive = true;
                else
                    continue;
            }
            return true;
        }
    }
    return false;
}",1,33,lib/astutils.cpp,"isAliasOf:bool(Token*,int,bool*)",<empty>,,false,1041,1060,isAliasOf,,,1,"bool(Token*,int,bool*)"
111669151009,METHOD,<empty>,<empty>,"[&](const Token* aliasTok) {
                        return aliasTok != childTok && aliasTok->exprId() == childTok->exprId();
                    }",37,21,lib/astutils.cpp,lib/astutils.cpp:<global>.isAliasOf.<lambda>3.<lambda>4:bool(Token*),<empty>,,false,1082,1084,<lambda>4,,,1,bool(Token*)
111669151010,METHOD,<empty>,<empty>,"[&](const Token* childTok) {
            if (childTok->exprId() == 0)
                return false;
            if (ref.token != tok && expr->exprId() == childTok->exprId()) {
                if (indirect)
                    *indirect = 0;
                return true;
            }
            for (const ValueFlow::Value& val : ref.token->values()) {
                if (val.isImpossible())
                    continue;
                if (val.isLocalLifetimeValue() || (pointer && val.isSymbolicValue() && val.intvalue == 0)) {
                    if (findAstNode(val.tokvalue,
                                    [&](const Token* aliasTok) {
                        return aliasTok != childTok && aliasTok->exprId() == childTok->exprId();
                    })) {
                        return true;
                    }
                }
            }
            return false;
        }",31,9,lib/astutils.cpp,lib/astutils.cpp:<global>.isAliasOf.<lambda>3:bool(Token*),<empty>,,false,1069,1090,<lambda>3,,,1,bool(Token*)
111669151011,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isAliasOf(const Token* tok, const Token* expr, int* indirect)
{
    const Token* r = nullptr;
    if (indirect)
        *indirect = 1;
    for (const ReferenceToken& ref : followAllReferences(tok)) {
        const bool pointer = astIsPointer(ref.token);
        r = findAstNode(expr, [&](const Token* childTok) {
            if (childTok->exprId() == 0)
                return false;
            if (ref.token != tok && expr->exprId() == childTok->exprId()) {
                if (indirect)
                    *indirect = 0;
                return true;
            }
            for (const ValueFlow::Value& val : ref.token->values()) {
                if (val.isImpossible())
                    continue;
                if (val.isLocalLifetimeValue() || (pointer && val.isSymbolicValue() && val.intvalue == 0)) {
                    if (findAstNode(val.tokvalue,
                                    [&](const Token* aliasTok) {
                        return aliasTok != childTok && alias...",1,1,lib/astutils.cpp,"isAliasOf:bool(Token*,Token*,int*)",<empty>,,false,1062,1095,isAliasOf,,,1,"bool(Token*,Token*,int*)"
111669151012,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool isAliased(const Token *startTok, const Token *endTok, nonneg int varid)
{
    if (!precedes(startTok, endTok))
        return false;
    for (const Token *tok = startTok; tok != endTok; tok = tok->next()) {
        if (Token::Match(tok, ""= & %varid% ;"", varid))
            return true;
        if (isAliasOf(tok, varid))
            return true;
    }
    return false;
}",1,66,lib/astutils.cpp,"isAliased:bool(Token*,Token*,int)",<empty>,,false,1097,1108,isAliased,,,1,"bool(Token*,Token*,int)"
111669151013,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool exprDependsOnThis(const Token* expr, bool onVar, nonneg int depth)
{
    if (!expr)
        return false;
    if (expr->str() == ""this"")
        return true;
    if (depth >= 1000)
        // Abort recursion to avoid stack overflow
        return true;
    ++depth;

    // calling nonstatic method?
    if (Token::Match(expr, ""%name% ("")) {
        if (expr->function() && expr->function()->nestedIn && expr->function()->nestedIn->isClassOrStruct() && !expr->function()->isStatic()) {
            // is it a method of this?
            const Scope* fScope = expr->scope();
            while (!fScope->functionOf && fScope->nestedIn)
                fScope = fScope->nestedIn;

            const Scope* classScope = fScope->functionOf;
            if (classScope && classScope->function)
                classScope = classScope->function->token->scope();

            if (classScope && classScope->isClassOrStruct())
                return contains(classScope->findAssociatedScopes(), expr->f...",1,54,lib/astutils.cpp,"exprDependsOnThis:bool(Token*,bool,int)",<empty>,,false,1110,1147,exprDependsOnThis,,,1,"bool(Token*,bool,int)"
111669151014,METHOD,<empty>,<empty>,"[&](const Token* tok) {
        if (tok->varId() > 0 && !tok->variable()) {
            result = true;
            return ChildrenToVisit::done;
        }
        return ChildrenToVisit::op1_and_op2;
    }",29,5,lib/astutils.cpp,lib/astutils.cpp:<global>.hasUnknownVars.<lambda>5:ChildrenToVisit(Token*),<empty>,,false,1152,1158,<lambda>5,,,1,ChildrenToVisit(Token*)
111669151015,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool hasUnknownVars(const Token* startTok)
{
    bool result = false;
    visitAstNodes(startTok, [&](const Token* tok) {
        if (tok->varId() > 0 && !tok->variable()) {
            result = true;
            return ChildrenToVisit::done;
        }
        return ChildrenToVisit::op1_and_op2;
    });
    return result;
}",1,1,lib/astutils.cpp,hasUnknownVars:bool(Token*),<empty>,,false,1149,1160,hasUnknownVars,,,1,bool(Token*)
111669151016,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isStructuredBindingVariable(const Variable* var)
{
    if (!var)
        return false;
    const Token* tok = var->nameToken();
    while (tok && Token::Match(tok->astParent(), ""[|,|:""))
        tok = tok->astParent();
    return tok && (tok->str() == ""["" || Token::simpleMatch(tok->previous(), ""] :"")); // TODO: remove workaround when #11105 is fixed
}",1,1,lib/astutils.cpp,isStructuredBindingVariable:bool(Variable*),<empty>,,false,1162,1170,isStructuredBindingVariable,,,1,bool(Variable*)
111669151017,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static const Token * followVariableExpression(const Settings& settings, const Token * tok, const Token * end = nullptr)
{
    if (!tok)
        return tok;
    // Skip following variables that is across multiple files
    if (end && end->fileIndex() != tok->fileIndex())
        return tok;
    // Skip array access
    if (Token::Match(tok, ""%var% [""))
        return tok;
    // Skip pointer indirection
    if (tok->astParent() && tok->isUnaryOp(""*""))
        return tok;
    // Skip following variables if it is used in an assignment
    if (Token::Match(tok->next(), ""%assign%""))
        return tok;
    const Variable * var = tok->variable();
    const Token * varTok = getVariableInitExpression(var);
    if (!varTok)
        return tok;
    if (hasUnknownVars(varTok))
        return tok;
    if (var->isVolatile())
        return tok;
    if (!var->isLocal() && !var->isConst())
        return tok;
    if (var->isStatic() && !var->isConst())
        return tok;
    if (var->isArgument()...",1,1,lib/astutils.cpp,"followVariableExpression:Token*(Settings&,Token*,Token*)",<empty>,,false,1175,1229,followVariableExpression,,,1,"Token*(Settings&,Token*,Token*)"
111669151018,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static void followVariableExpressionError(const Token *tok1, const Token *tok2, ErrorPath* errors)
{
    if (!errors)
        return;
    if (!tok1)
        return;
    if (!tok2)
        return;
    ErrorPathItem item = std::make_pair(tok2, ""'"" + tok1->str() + ""' is assigned value '"" + tok2->expressionString() + ""' here."");
    if (std::find(errors->cbegin(), errors->cend(), item) != errors->cend())
        return;
    errors->push_back(std::move(item));
}",1,1,lib/astutils.cpp,"followVariableExpressionError:void(Token*,Token*,ErrorPath*)",<empty>,,false,1231,1243,followVariableExpressionError,,,1,"void(Token*,Token*,ErrorPath*)"
111669151019,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"SmallVector<ReferenceToken> followAllReferences(const Token* tok,
                                                bool temporary,
                                                bool inconclusive,
                                                ErrorPath errors,
                                                int depth)
{
    struct ReferenceTokenLess {
        bool operator()(const ReferenceToken& x, const ReferenceToken& y) const {
            return x.token < y.token;
        }
    };
    if (!tok)
        return {};
    if (depth < 0) {
        SmallVector<ReferenceToken> refs_result;
        refs_result.emplace_back(tok, std::move(errors));
        return refs_result;
    }
    const Variable *var = tok->variable();
    if (var && var->declarationId() == tok->varId()) {
        if (var->nameToken() == tok || isStructuredBindingVariable(var)) {
            SmallVector<ReferenceToken> refs_result;
            refs_result.emplace_back(tok, std::move(errors));
            return re...",1,1,lib/astutils.cpp,"followAllReferences:SmallVector<ReferenceToken>(Token*,bool,bool,ErrorPath,int)",<empty>,,false,1245,1376,followAllReferences,,,1,"SmallVector<ReferenceToken>(Token*,bool,bool,ErrorPath,int)"
111669151020,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* followReferences(const Token* tok, ErrorPath* errors)
{
    if (!tok)
        return nullptr;
    auto refs = followAllReferences(tok, true, false);
    if (refs.size() == 1) {
        if (errors)
            *errors = std::move(refs.front().errors);
        return refs.front().token;
    }
    return nullptr;
}",1,1,lib/astutils.cpp,"followReferences:Token*(Token*,ErrorPath*)",<empty>,,false,1378,1389,followReferences,,,1,"Token*(Token*,ErrorPath*)"
111669151021,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool isSameLifetime(const Token * const tok1, const Token * const tok2)
{
    ValueFlow::Value v1 = ValueFlow::getLifetimeObjValue(tok1);
    if (!v1.isLifetimeValue())
        return false;
    ValueFlow::Value v2 = ValueFlow::getLifetimeObjValue(tok2);
    if (!v2.isLifetimeValue())
        return false;
    return v1.tokvalue == v2.tokvalue;
}",1,1,lib/astutils.cpp,"isSameLifetime:bool(Token*,Token*)",<empty>,,false,1391,1400,isSameLifetime,,,1,"bool(Token*,Token*)"
111669151022,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool compareKnownValue(const Token * const tok1, const Token * const tok2, const std::function<bool(const ValueFlow::Value&, const ValueFlow::Value&, bool)> &compare)
{
    static const auto isKnownFn = std::mem_fn(&ValueFlow::Value::isKnown);

    const auto v1 = std::find_if(tok1->values().cbegin(), tok1->values().cend(), isKnownFn);
    if (v1 == tok1->values().end()) {
        return false;
    }
    if (v1->isNonValue() || v1->isContainerSizeValue() || v1->isSymbolicValue())
        return false;
    const auto v2 = std::find_if(tok2->values().cbegin(), tok2->values().cend(), isKnownFn);
    if (v2 == tok2->values().end()) {
        return false;
    }
    if (v1->valueType != v2->valueType) {
        return false;
    }
    const bool sameLifetime = isSameLifetime(tok1, tok2);
    return compare(*v1, *v2, sameLifetime);
}",1,1,lib/astutils.cpp,"compareKnownValue:bool(Token*,Token*,std.function<bool(constValueFlow.Value&,ValueFlow.Value&,bool)>&)",<empty>,,false,1402,1421,compareKnownValue,,,1,"bool(Token*,Token*,std.function<bool(constValueFlow.Value&,ValueFlow.Value&,bool)>&)"
111669151023,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v1, const ValueFlow::Value& v2, bool sameLifetime) {
        bool r = v1.equalValue(v2);
        if (v1.isIteratorValue()) {
            r &= sameLifetime;
        }
        return r;
    }",42,5,lib/astutils.cpp,"lib/astutils.cpp:<global>.isEqualKnownValue.<lambda>6:bool(ValueFlow.Value&,ValueFlow.Value&,bool)",<empty>,,false,1425,1431,<lambda>6,,,1,"bool(ValueFlow.Value&,ValueFlow.Value&,bool)"
111669151024,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isEqualKnownValue(const Token * const tok1, const Token * const tok2)
{
    return compareKnownValue(tok1, tok2, [&](const ValueFlow::Value& v1, const ValueFlow::Value& v2, bool sameLifetime) {
        bool r = v1.equalValue(v2);
        if (v1.isIteratorValue()) {
            r &= sameLifetime;
        }
        return r;
    });
}",1,1,lib/astutils.cpp,"isEqualKnownValue:bool(Token*,Token*)",<empty>,,false,1423,1432,isEqualKnownValue,,,1,"bool(Token*,Token*)"
111669151025,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v1, const ValueFlow::Value& v2, bool sameLifetime) {
        bool r = v1.equalValue(v2);
        if (v1.isIteratorValue()) {
            r &= sameLifetime;
        }
        return !r;
    }",42,5,lib/astutils.cpp,"lib/astutils.cpp:<global>.isDifferentKnownValues.<lambda>7:bool(ValueFlow.Value&,ValueFlow.Value&,bool)",<empty>,,false,1436,1442,<lambda>7,,,1,"bool(ValueFlow.Value&,ValueFlow.Value&,bool)"
111669151026,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static inline bool isDifferentKnownValues(const Token * const tok1, const Token * const tok2)
{
    return compareKnownValue(tok1, tok2, [&](const ValueFlow::Value& v1, const ValueFlow::Value& v2, bool sameLifetime) {
        bool r = v1.equalValue(v2);
        if (v1.isIteratorValue()) {
            r &= sameLifetime;
        }
        return !r;
    });
}",1,1,lib/astutils.cpp,"isDifferentKnownValues:bool(Token*,Token*)",<empty>,,false,1434,1443,isDifferentKnownValues,,,1,"bool(Token*,Token*)"
111669151027,METHOD,<empty>,<empty>,"[](const Token* tok) {
        if (tok->astOperand2() && Token::Match(tok->previous(), ""%type% (|{"") && tok->previous()->isStandardType())
            return tok->astOperand2();
        return tok;
    }",26,5,lib/astutils.cpp,lib/astutils.cpp:<global>.isSameConstantValue.<lambda>8:Token*(Token*),<empty>,,false,1450,1454,<lambda>8,,,1,Token*(Token*)
111669151028,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static inline bool isSameConstantValue(bool macro, const Token* tok1, const Token* tok2)
{
    if (tok1 == nullptr || tok2 == nullptr)
        return false;

    auto adjustForCast = [](const Token* tok) {
        if (tok->astOperand2() && Token::Match(tok->previous(), ""%type% (|{"") && tok->previous()->isStandardType())
            return tok->astOperand2();
        return tok;
    };

    tok1 = adjustForCast(tok1);
    if (!tok1->isNumber() && !tok1->enumerator())
        return false;
    tok2 = adjustForCast(tok2);
    if (!tok2->isNumber() && !tok2->enumerator())
        return false;

    if (macro && (tok1->isExpandedMacro() || tok2->isExpandedMacro() || tok1->isTemplateArg() || tok2->isTemplateArg()))
        return false;

    const ValueType * v1 = tok1->valueType();
    const ValueType * v2 = tok2->valueType();

    if (!v1 || !v2 || v1->sign != v2->sign || v1->type != v2->type || v1->pointer != v2->pointer)
        return false;

    return isEqualKnownValue(tok1, tok2);
}",1,1,lib/astutils.cpp,"isSameConstantValue:bool(bool,Token*,Token*)",<empty>,,false,1445,1473,isSameConstantValue,,,1,"bool(bool,Token*,Token*)"
111669151029,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool isForLoopCondition(const Token * const tok)
{
    if (!tok)
        return false;
    const Token *const parent = tok->astParent();
    return Token::simpleMatch(parent, "";"") && parent->astOperand1() == tok &&
           Token::simpleMatch(parent->astParent(), "";"") &&
           Token::simpleMatch(parent->astParent()->astParent(), ""("") &&
           parent->astParent()->astParent()->astOperand1()->str() == ""for"";
}",1,1,lib/astutils.cpp,isForLoopCondition:bool(Token*),<empty>,,false,1476,1485,isForLoopCondition,,,1,bool(Token*)
111669151030,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool isForLoopIncrement(const Token* const tok)
{
    if (!tok)
        return false;
    const Token *const parent = tok->astParent();
    return Token::simpleMatch(parent, "";"") && parent->astOperand2() == tok &&
           Token::simpleMatch(parent->astParent(), "";"") &&
           Token::simpleMatch(parent->astParent()->astParent(), ""("") &&
           parent->astParent()->astParent()->astOperand1()->str() == ""for"";
}",1,1,lib/astutils.cpp,isForLoopIncrement:bool(Token*),<empty>,,false,1487,1496,isForLoopIncrement,,,1,bool(Token*)
111669151031,METHOD,<empty>,<empty>,"[&](const ValueType& vt) {
            return vt.pointer == 0 && vt.type == ValueType::BOOL;
        }",66,9,lib/astutils.cpp,lib/astutils.cpp:<global>.isUsedAsBool.<lambda>9:bool(ValueType&),<empty>,,false,1539,1541,<lambda>9,,,1,bool(ValueType&)
111669151032,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isUsedAsBool(const Token* const tok, const Settings& settings)
{
    if (!tok)
        return false;
    if (isForLoopIncrement(tok))
        return false;
    if (astIsBool(tok))
        return true;
    if (Token::Match(tok, ""!|&&|%oror%|%comp%""))
        return true;
    const Token* parent = tok->astParent();
    if (!parent)
        return false;
    if (Token::simpleMatch(parent, ""[""))
        return false;
    if (parent->isUnaryOp(""*""))
        return false;
    if (Token::simpleMatch(parent, ""."")) {
        if (astIsRHS(tok))
            return isUsedAsBool(parent, settings);
        return false;
    }
    if (Token::Match(parent, ""&&|!|%oror%""))
        return true;
    if (parent->isCast())
        return !Token::simpleMatch(parent->astOperand1(), ""dynamic_cast"") && isUsedAsBool(parent, settings);
    if (parent->isUnaryOp(""*""))
        return isUsedAsBool(parent, settings);
    if (Token::Match(parent, ""==|!="") && (tok->astSibling()->isNumber() || tok->astSibling()...",1,1,lib/astutils.cpp,"isUsedAsBool:bool(Token*,Settings&)",<empty>,,false,1498,1544,isUsedAsBool,,,1,"bool(Token*,Settings&)"
111669151033,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool compareTokenFlags(const Token* tok1, const Token* tok2, bool macro) {
    if (macro) {
        if (tok1->isExpandedMacro() != tok2->isExpandedMacro())
            return false;
        if (tok1->isExpandedMacro()) { // both are macros
            if (tok1->getMacroName() != tok2->getMacroName())
                return false;
            if (tok1->astParent() && tok2->astParent() && tok1->astParent()->isExpandedMacro() && tok1->astParent()->getMacroName() == tok2->astParent()->getMacroName())
                return false;
        }
        if (tok1->isTemplateArg() || tok2->isTemplateArg())
            return false;
    }
    if (tok1->isComplex() != tok2->isComplex())
        return false;
    if (tok1->isLong() != tok2->isLong())
        return false;
    if (tok1->isUnsigned() != tok2->isUnsigned())
        return false;
    if (tok1->isSigned() != tok2->isSigned())
        return false;
    return true;
}",1,1,lib/astutils.cpp,"compareTokenFlags:bool(Token*,Token*,bool)",<empty>,,false,1546,1568,compareTokenFlags,,,1,"bool(Token*,Token*,bool)"
111669151034,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool astIsBoolLike(const Token* tok, const Settings& settings)
{
    return astIsBool(tok) || isUsedAsBool(tok, settings);
}",1,1,lib/astutils.cpp,"astIsBoolLike:bool(Token*,Settings&)",<empty>,,false,1570,1573,astIsBoolLike,,,1,"bool(Token*,Settings&)"
111669151035,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isSameExpression(bool macro, const Token *tok1, const Token *tok2, const Settings& settings, bool pure, bool followVar, ErrorPath* errors)
{
    if (tok1 == tok2)
        return true;
    if (tok1 == nullptr || tok2 == nullptr)
        return false;
    // tokens needs to be from the same TokenList so no need check standard on both of them
    if (tok1->isCpp()) {
        if (tok1->str() == ""."" && tok1->astOperand1() && tok1->astOperand1()->str() == ""this"")
            tok1 = tok1->astOperand2();
        if (tok2->str() == ""."" && tok2->astOperand1() && tok2->astOperand1()->str() == ""this"")
            tok2 = tok2->astOperand2();
    }
    // Skip double not
    if (Token::simpleMatch(tok1, ""!"") && Token::simpleMatch(tok1->astOperand1(), ""!"") && !Token::simpleMatch(tok1->astParent(), ""="") && astIsBoolLike(tok2, settings)) {
        return isSameExpression(macro, tok1->astOperand1()->astOperand1(), tok2, settings, pure, followVar, errors);
    }
    if (Token::simpleMatch(tok2, ""...",1,1,lib/astutils.cpp,"isSameExpression:bool(bool,Token*,Token*,Settings&,bool,bool,ErrorPath*)",<empty>,,false,1575,1784,isSameExpression,,,1,"bool(bool,Token*,Token*,Settings&,bool,bool,ErrorPath*)"
111669151036,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool isZeroBoundCond(const Token * const cond)
{
    if (cond == nullptr)
        return false;
    // Assume unsigned
    // TODO: Handle reverse conditions
    const bool isZero = cond->astOperand2()->getValue(0);
    if (cond->str() == ""=="" || cond->str() == "">="")
        return isZero;
    if (cond->str() == ""<="")
        return true;
    if (cond->str() == ""<"")
        return !isZero;
    if (cond->str() == "">"")
        return false;
    return false;
}",1,1,lib/astutils.cpp,isZeroBoundCond:bool(Token*),<empty>,,false,1786,1802,isZeroBoundCond,,,1,bool(Token*)
111669151037,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isOppositeCond(bool isNot, const Token * const cond1, const Token * const cond2, const Settings& settings, bool pure, bool followVar, ErrorPath* errors)
{
    if (!cond1 || !cond2)
        return false;

    if (isSameExpression(true, cond1, cond2, settings, pure, followVar, errors))
        return false;

    if (!isNot && cond1->str() == ""&&"" && cond2->str() == ""&&"") {
        for (const Token* tok1: {
            cond1->astOperand1(), cond1->astOperand2()
        }) {
            for (const Token* tok2: {
                cond2->astOperand1(), cond2->astOperand2()
            }) {
                if (isSameExpression(true, tok1, tok2, settings, pure, followVar, errors)) {
                    if (isOppositeCond(isNot, tok1->astSibling(), tok2->astSibling(), settings, pure, followVar, errors))
                        return true;
                }
            }
        }
    }

    if (cond1->str() != cond2->str() && (cond1->str() == ""||"" || cond2->str() == ""||"")) {
        con...",1,1,lib/astutils.cpp,"isOppositeCond:bool(bool,Token*,Token*,Settings&,bool,bool,ErrorPath*)",<empty>,,false,1804,1964,isOppositeCond,,,1,"bool(bool,Token*,Token*,Settings&,bool,bool,ErrorPath*)"
111669151038,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isOppositeExpression(const Token * const tok1, const Token * const tok2, const Settings& settings, bool pure, bool followVar, ErrorPath* errors)
{
    if (!tok1 || !tok2)
        return false;
    if (isOppositeCond(true, tok1, tok2, settings, pure, followVar, errors))
        return true;
    if (tok1->isUnaryOp(""-"") && !(tok2->astParent() && tok2->astParent()->tokType() == Token::eBitOp))
        return isSameExpression(true, tok1->astOperand1(), tok2, settings, pure, followVar, errors);
    if (tok2->isUnaryOp(""-"") && !(tok2->astParent() && tok2->astParent()->tokType() == Token::eBitOp))
        return isSameExpression(true, tok2->astOperand1(), tok1, settings, pure, followVar, errors);
    return false;
}",1,1,lib/astutils.cpp,"isOppositeExpression:bool(Token*,Token*,Settings&,bool,bool,ErrorPath*)",<empty>,,false,1966,1977,isOppositeExpression,,,1,"bool(Token*,Token*,Settings&,bool,bool,ErrorPath*)"
111669151039,METHOD,<empty>,<empty>,"[](const Variable& var) {
        if (var.isReference() || var.isPointer())
            return !var.isConst();
        return true;
    }",74,5,lib/astutils.cpp,lib/astutils.cpp:<global>.functionModifiesArguments.<lambda>10:bool(Variable&),<empty>,,false,1981,1985,<lambda>10,,,1,bool(Variable&)
111669151040,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool functionModifiesArguments(const Function* f)
{
    return std::any_of(f->argumentList.cbegin(), f->argumentList.cend(), [](const Variable& var) {
        if (var.isReference() || var.isPointer())
            return !var.isConst();
        return true;
    });
}",1,1,lib/astutils.cpp,functionModifiesArguments:bool(Function*),<empty>,,false,1979,1986,functionModifiesArguments,,,1,bool(Function*)
111669151041,METHOD,<empty>,<empty>,"[&](const Function* g) {
                    if (f == g)
                        return false;
                    if (f->argumentList.size() != g->argumentList.size())
                        return false;
                    if (functionModifiesArguments(g))
                        return false;
                    if (g->isConst() && Function::returnsConst(g))
                        return true;
                    return false;
                }",57,17,lib/astutils.cpp,lib/astutils.cpp:<global>.isConstFunctionCall.<lambda>11:bool(Function*),<empty>,,false,2009,2019,<lambda>11,,,1,bool(Function*)
111669151042,METHOD,<empty>,<empty>,"[](const Token* tok) {
            const Variable* var = tok->variable();
            if (var)
                return var->isConst();
            return false;
        }",71,9,lib/astutils.cpp,lib/astutils.cpp:<global>.isConstFunctionCall.<lambda>12:bool(Token*),<empty>,,false,2058,2063,<lambda>12,,,1,bool(Token*)
111669151043,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isConstFunctionCall(const Token* ftok, const Library& library)
{
    if (isUnevaluated(ftok))
        return true;
    if (!Token::Match(ftok, ""%name% (""))
        return false;
    if (const Function* f = ftok->function()) {
        if (f->isAttributePure() || f->isAttributeConst())
            return true;
        // Any modified arguments
        if (functionModifiesArguments(f))
            return false;
        if (Function::returnsVoid(f))
            return false;
        // Member function call
        if (Token::simpleMatch(ftok->previous(), ""."") || exprDependsOnThis(ftok->next())) {
            if (f->isConst())
                return true;
            // Check for const overloaded function that just return the const version
            if (!Function::returnsConst(f)) {
                std::vector<const Function*> fs = f->getOverloadedFunctions();
                if (std::any_of(fs.cbegin(), fs.cend(), [&](const Function* g) {
                    if (f == g)
         ...",1,1,lib/astutils.cpp,"isConstFunctionCall:bool(Token*,Library&)",<empty>,,false,1988,2066,isConstFunctionCall,,,1,"bool(Token*,Library&)"
111669151044,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isConstExpression(const Token *tok, const Library& library)
{
    if (!tok)
        return true;
    if (tok->variable() && tok->variable()->isVolatile())
        return false;
    if (tok->isName() && tok->strAt(1) == ""("") {
        if (!isConstFunctionCall(tok, library))
            return false;
    }
    if (tok->tokType() == Token::eIncDecOp)
        return false;
    if (tok->isAssignmentOp())
        return false;
    if (isLikelyStreamRead(tok))
        return false;
    // bailout when we see ({..})
    if (tok->str() == ""{"")
        return false;
    return isConstExpression(tok->astOperand1(), library) && isConstExpression(tok->astOperand2(), library);
}",1,1,lib/astutils.cpp,"isConstExpression:bool(Token*,Library&)",<empty>,,false,2068,2088,isConstExpression,,,1,"bool(Token*,Library&)"
111669151045,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isWithoutSideEffects(const Token* tok, bool checkArrayAccess, bool checkReference)
{
    if (!tok)
        return true;
    if (!tok->isCpp())
        return true;

    while (tok && tok->astOperand2() && tok->astOperand2()->str() != ""("")
        tok = tok->astOperand2();
    if (tok && tok->varId()) {
        const Variable* var = tok->variable();
        return var && ((!var->isClass() && (checkReference || !var->isReference())) || var->isPointer() || (checkArrayAccess ? var->isStlType() && !var->isStlType(CheckClass::stl_containers_not_const) : var->isStlType()));
    }
    return true;
}",1,1,lib/astutils.cpp,"isWithoutSideEffects:bool(Token*,bool,bool)",<empty>,,false,2090,2104,isWithoutSideEffects,,,1,"bool(Token*,bool,bool)"
111669151046,METHOD,<empty>,<empty>,"[&](const Function& f) {
            if (f.type != FunctionType::eFunction)
                return true;

            const std::string freturnType = f.retType ? f.retType->name() : f.retDef->stringifyList(f.returnDefEnd());
            return f.argumentList.size() != fun->argumentList.size() || returnType != freturnType || f.name() == fun->name();
        }",82,9,lib/astutils.cpp,lib/astutils.cpp:<global>.isUniqueExpression.<lambda>13:bool(Function&),<empty>,,false,2116,2122,<lambda>13,,,1,bool(Function&)
111669151047,METHOD,<empty>,<empty>,"[=](const Variable& v) {
            if (varType)
                return v.type() && v.type()->name() == varType->name() && v.name() != var->name();
            return v.isFloatingType() == var->isFloatingType() &&
                   v.isEnumType() == var->isEnumType() &&
                   v.isClass() == var->isClass() &&
                   v.isArray() == var->isArray() &&
                   v.isPointer() == var->isPointer() &&
                   v.name() != var->name();
        }",21,9,lib/astutils.cpp,lib/astutils.cpp:<global>.isUniqueExpression.<lambda>14:bool(Variable&),<empty>,,false,2133,2142,<lambda>14,,,1,bool(Variable&)
111669151048,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isUniqueExpression(const Token* tok)
{
    if (!tok)
        return true;
    if (tok->function()) {
        const Function * fun = tok->function();
        const Scope * scope = fun->nestedIn;
        if (!scope)
            return true;
        const std::string returnType = fun->retType ? fun->retType->name() : fun->retDef->stringifyList(fun->tokenDef);
        if (!std::all_of(scope->functionList.begin(), scope->functionList.end(), [&](const Function& f) {
            if (f.type != FunctionType::eFunction)
                return true;

            const std::string freturnType = f.retType ? f.retType->name() : f.retDef->stringifyList(f.returnDefEnd());
            return f.argumentList.size() != fun->argumentList.size() || returnType != freturnType || f.name() == fun->name();
        }))
            return false;
    } else if (tok->variable()) {
        const Variable * var = tok->variable();
        const Scope * scope = var->scope();
        if (!scope)
            retur...",1,1,lib/astutils.cpp,isUniqueExpression:bool(Token*),<empty>,,false,2106,2154,isUniqueExpression,,,1,bool(Token*)
111669151049,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool isEscaped(const Token* tok, bool functionsScope, const Library& library)
{
    if (library.isnoreturn(tok))
        return true;
    if (functionsScope)
        return Token::simpleMatch(tok, ""throw"");
    return Token::Match(tok, ""return|throw"");
}",1,1,lib/astutils.cpp,"isEscaped:bool(Token*,bool,Library&)",<empty>,,false,2156,2163,isEscaped,,,1,"bool(Token*,bool,Library&)"
111669151050,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool isEscapedOrJump(const Token* tok, bool functionsScope, const Library& library)
{
    if (library.isnoreturn(tok))
        return true;
    if (functionsScope)
        return Token::simpleMatch(tok, ""throw"");
    return Token::Match(tok, ""return|goto|throw|continue|break"");
}",1,1,lib/astutils.cpp,"isEscapedOrJump:bool(Token*,bool,Library&)",<empty>,,false,2165,2172,isEscapedOrJump,,,1,"bool(Token*,bool,Library&)"
111669151051,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isEscapeFunction(const Token* ftok, const Library* library)
{
    if (!Token::Match(ftok, ""%name% (""))
        return false;
    const Function* function = ftok->function();
    if (function) {
        if (function->isEscapeFunction())
            return true;
        if (function->isAttributeNoreturn())
            return true;
    } else if (library) {
        if (library->isnoreturn(ftok))
            return true;
    }
    return false;
}",1,1,lib/astutils.cpp,"isEscapeFunction:bool(Token*,Library*)",<empty>,,false,2174,2189,isEscapeFunction,,,1,"bool(Token*,Library*)"
111669151052,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool hasNoreturnFunction(const Token* tok, const Library& library, const Token** unknownFunc)
{
    if (!tok)
        return false;
    const Token* ftok = tok->str() == ""("" ? tok->previous() : nullptr;
    while (Token::simpleMatch(ftok, ""(""))
        ftok = ftok->astOperand1();
    if (ftok) {
        const Function * function = ftok->function();
        if (function) {
            if (function->isEscapeFunction())
                return true;
            if (function->isAttributeNoreturn())
                return true;
        } else if (library.isnoreturn(ftok)) {
            return true;
        } else if (Token::Match(ftok, ""exit|abort"")) {
            return true;
        }
        if (unknownFunc && !function && library.functions().count(library.getFunctionName(ftok)) == 0)
            *unknownFunc = ftok;
        return false;
    }
    if (tok->isConstOp()) {
        return hasNoreturnFunction(tok->astOperand1(), library, unknownFunc) || hasNoreturnFunction(tok->ast...",1,1,lib/astutils.cpp,"hasNoreturnFunction:bool(Token*,Library&,Token**)",<empty>,,false,2191,2219,hasNoreturnFunction,,,1,"bool(Token*,Library&,Token**)"
111669151053,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isReturnScope(const Token* const endToken, const Library& library, const Token** unknownFunc, bool functionScope)
{
    if (!endToken || endToken->str() != ""}"")
        return false;

    const Token *prev = endToken->previous();
    while (prev && Token::simpleMatch(prev->previous(), ""; ;""))
        prev = prev->previous();
    if (prev && Token::simpleMatch(prev->previous(), ""} ;""))
        prev = prev->previous();

    if (Token::simpleMatch(prev, ""}"")) {
        if (Token::simpleMatch(prev->link()->tokAt(-2), ""} else {""))
            return isReturnScope(prev, library, unknownFunc, functionScope) &&
                   isReturnScope(prev->link()->tokAt(-2), library, unknownFunc, functionScope);
        // TODO: Check all cases
        if (!functionScope && Token::simpleMatch(prev->link()->previous(), "") {"") &&
            Token::simpleMatch(prev->link()->linkAt(-1)->previous(), ""switch ("") &&
            !Token::findsimplematch(prev->link(), ""break"", prev)) {
            ret...",1,1,lib/astutils.cpp,"isReturnScope:bool(Token*,Library&,Token**,bool)",<empty>,,false,2221,2267,isReturnScope,,,1,"bool(Token*,Library&,Token**,bool)"
111669151054,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isWithinScope(const Token* tok, const Variable* var, ScopeType type)
{
    if (!tok || !var)
        return false;
    const Scope* scope = tok->scope();
    while (scope && scope != var->scope()) {
        if (scope->type == type)
            return true;
        scope = scope->nestedIn;
    }
    return false;
}",1,1,lib/astutils.cpp,"isWithinScope:bool(Token*,Variable*,ScopeType)",<empty>,,false,2269,2280,isWithinScope,,,1,"bool(Token*,Variable*,ScopeType)"
111669151055,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isVariableChangedByFunctionCall(const Token *tok, int indirect, nonneg int varid, const Settings &settings, bool *inconclusive)
{
    if (!tok)
        return false;
    if (tok->varId() == varid)
        return isVariableChangedByFunctionCall(tok, indirect, settings, inconclusive);
    return isVariableChangedByFunctionCall(tok->astOperand1(), indirect, varid, settings, inconclusive) ||
           isVariableChangedByFunctionCall(tok->astOperand2(), indirect, varid, settings, inconclusive);
}",1,69,lib/astutils.cpp,"isVariableChangedByFunctionCall:bool(Token*,int,int,Settings&,bool*)",<empty>,,false,2282,2290,isVariableChangedByFunctionCall,,,1,"bool(Token*,int,int,Settings&,bool*)"
111669151056,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isScopeBracket(const Token* tok)
{
    if (!Token::Match(tok, ""{|}""))
        return false;
    if (!tok->scope())
        return false;
    if (tok->str() == ""{"")
        return tok->scope()->bodyStart == tok;
    if (tok->str() == ""}"")
        return tok->scope()->bodyEnd == tok;
    return false;
}",1,1,lib/astutils.cpp,isScopeBracket:bool(Token*),<empty>,,false,2292,2303,isScopeBracket,,,1,bool(Token*)
111669151057,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static T* getTokenArgumentFunctionImpl(T* tok, int& argn)
{
    argn = -1;
    {
        T* parent = tok->astParent();
        if (parent && (parent->isUnaryOp(""&"") || parent->isIncDecOp()))
            parent = parent->astParent();
        while (parent && parent->isCast())
            parent = parent->astParent();
        if (Token::Match(parent, ""[+-]"") && parent->valueType() && parent->valueType()->pointer)
            parent = parent->astParent();

        // passing variable to subfunction?
        if (Token::Match(parent, ""[[(,{.]"") || Token::Match(parent, ""%oror%|&&"") || (parent && parent->isUnaryOp(""*"")))
            ;
        else if (Token::simpleMatch(parent, "":"")) {
            while (Token::Match(parent, ""[?:]""))
                parent = parent->astParent();
            while (Token::simpleMatch(parent, "",""))
                parent = parent->astParent();
            if (!parent || parent->str() != ""("")
                return nullptr;
        } else
            return n...",1,1,lib/astutils.cpp,"getTokenArgumentFunctionImpl:T(T*,int&)",<empty>,,false,2306,2377,getTokenArgumentFunctionImpl,,,1,"T(T*,int&)"
111669151058,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* getTokenArgumentFunction(const Token* tok, int& argn) {
    return getTokenArgumentFunctionImpl(tok, argn);
}",1,1,lib/astutils.cpp,"getTokenArgumentFunction:Token*(Token*,int&)",<empty>,,false,2379,2381,getTokenArgumentFunction,,,1,"Token*(Token*,int&)"
111669151059,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"Token* getTokenArgumentFunction(Token* tok, int& argn) {
    return getTokenArgumentFunctionImpl(tok, argn);
}",1,1,lib/astutils.cpp,"getTokenArgumentFunction<duplicate>0:Token*(Token*,int&)",<empty>,,false,2383,2385,getTokenArgumentFunction,,,1,"Token*(Token*,int&)"
111669151060,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"std::vector<const Variable*> getArgumentVars(const Token* tok, int argnr)
{
    std::vector<const Variable*> result;
    if (!tok)
        return result;
    if (tok->function()) {
        const Variable* argvar = tok->function()->getArgumentVar(argnr);
        if (argvar)
            return {argvar};
        return result;
    }
    if (tok->variable() || Token::simpleMatch(tok, ""{"") || Token::Match(tok->previous(), ""%type% (|{"")) {
        const Type* type = Token::typeOf(tok);
        if (!type)
            return result;
        const Scope* typeScope = type->classScope;
        if (!typeScope)
            return result;
        const bool tokIsBrace = Token::simpleMatch(tok, ""{"");
        // Aggregate constructor
        if (tokIsBrace && typeScope->numConstructors == 0 && argnr < typeScope->varlist.size()) {
            auto it = std::next(typeScope->varlist.cbegin(), argnr);
            return {&*it};
        }
        const int argCount = numberOfArguments(tok);
        cons...",1,1,lib/astutils.cpp,"getArgumentVars:vector<constVariable*>(Token*,int)",<empty>,,false,2387,2426,getArgumentVars,,,1,"vector<const Variable*>(Token*,int)"
111669151061,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool isCPPCastKeyword(const Token* tok)
{
    if (!tok)
        return false;
    return endsWith(tok->str(), ""_cast"");
}",1,1,lib/astutils.cpp,isCPPCastKeyword:bool(Token*),<empty>,,false,2428,2433,isCPPCastKeyword,,,1,bool(Token*)
111669151062,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool isTrivialConstructor(const Token* tok)
{
    const Token* typeTok = nullptr;
    const Type* t = Token::typeOf(tok, &typeTok);
    if (t)
        return false;
    if (typeTok->valueType() && typeTok->valueType()->isPrimitive())
        return true;
    return false;
}",1,1,lib/astutils.cpp,isTrivialConstructor:bool(Token*),<empty>,,false,2435,2444,isTrivialConstructor,,,1,bool(Token*)
111669151063,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool isArray(const Token* tok)
{
    if (!tok)
        return false;
    if (tok->variable())
        return tok->variable()->isArray();
    if (Token::simpleMatch(tok, "".""))
        return isArray(tok->astOperand2());
    return false;
}",1,1,lib/astutils.cpp,isArray:bool(Token*),<empty>,,false,2446,2455,isArray,,,1,bool(Token*)
111669151064,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static inline
// limit it to CLang as compiling with GCC might fail with
// error: inlining failed in call to always_inline 'bool isMutableExpression(const Token*)': function not considered for inlining
// error: inlining failed in call to always_inline bool isMutableExpression(const Token*): recursive inlining
#if defined(__clang__)
__attribute__((always_inline))
#endif
bool isMutableExpression(const Token* tok)
{
    if (!tok)
        return false;
    if (tok->isLiteral() || tok->isKeyword() || tok->isStandardType() || tok->isEnumerator())
        return false;
    if (Token::Match(tok, "",|;|:|]|)|}""))
        return false;
    if (Token::simpleMatch(tok, ""[ ]""))
        return false;
    if (tok->previous() && tok->previous()->isKeyword() && Token::Match(tok->previous(), ""%name% (""))
        return false;
    if (tok->link() && Token::Match(tok, ""<|>""))
        return false;
    if (tok->astOperand1() && Token::simpleMatch(tok, ""[""))
        return isMutableExpression(tok->a...",1,1,lib/astutils.cpp,isMutableExpression:bool(Token*),<empty>,,false,2457,2487,isMutableExpression,,,1,bool(Token*)
111669151065,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isVariableChangedByFunctionCall(const Token *tok, int indirect, const Settings &settings, bool *inconclusive)
{
    if (!tok)
        return false;

    if (Token::simpleMatch(tok, "",""))
        return false;

    const Token * const tok1 = tok;

    // address of variable
    const bool addressOf = tok->astParent() && tok->astParent()->isUnaryOp(""&"");
    if (addressOf)
        indirect++;

    const bool deref = tok->astParent() && tok->astParent()->isUnaryOp(""*"");
    if (deref && indirect > 0)
        indirect--;

    if (indirect == 1 && tok->isCpp() && tok->tokAt(-1) && Token::simpleMatch(tok->tokAt(-2), ""new ("")) // placement new TODO: fix AST
        return true;

    int argnr;
    tok = getTokenArgumentFunction(tok, argnr);
    if (!tok)
        return false; // not a function => variable not changed
    if (Token::simpleMatch(tok, ""{"") && isTrivialConstructor(tok))
        return false;
    if (tok->isKeyword() && !isCPPCastKeyword(tok) && !startsWith(tok->str(),""ope...",1,1,lib/astutils.cpp,"isVariableChangedByFunctionCall:bool(Token*,int,Settings&,bool*)",<empty>,,false,2489,2595,isVariableChangedByFunctionCall,,,1,"bool(Token*,int,Settings&,bool*)"
111669151066,METHOD,<empty>,<empty>,"[](const Token* tok, const Token* parent) {
        const Token* gparent = parent ? parent->astParent() : nullptr;
        while (parent && gparent && ((parent->isUnaryOp(""*"") && gparent->isUnaryOp(""&"")) || (parent->isUnaryOp(""&"") && gparent->isUnaryOp(""*"")))) {
            tok = gparent;
            parent = gparent->astParent();
            if (parent)
                gparent = parent->astParent();
        }
        return tok;
    }",31,5,lib/astutils.cpp,"lib/astutils.cpp:<global>.isVariableChanged.<lambda>15:Token*(Token*,Token*)",<empty>,,false,2635,2644,<lambda>15,,,1,"Token*(Token*,Token*)"
111669151067,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isVariableChanged(const Token *tok, int indirect, const Settings &settings, int depth)
{
    if (!isMutableExpression(tok))
        return false;

    if (indirect == 0 && isConstVarExpression(tok))
        return false;

    const Token *tok2 = tok;
    int derefs = 0;
    while ((tok2->astParent() && tok2->astParent()->isUnaryOp(""*"")) ||
           (Token::simpleMatch(tok2->astParent(), ""."") && !Token::Match(tok2->astParent()->astParent(), ""[(,]"")) ||
           (tok2->astParent() && tok2->astParent()->isUnaryOp(""&"") && Token::simpleMatch(tok2->astParent()->astParent(), ""."") && tok2->astParent()->astParent()->originalName()==""->"") ||
           (Token::simpleMatch(tok2->astParent(), ""["") && tok2 == tok2->astParent()->astOperand1())) {
        if (tok2->astParent() && (tok2->astParent()->isUnaryOp(""*"") || (astIsLHS(tok2) && tok2->astParent()->originalName() == ""->"")))
            derefs++;
        if (derefs > indirect)
            break;
        if (tok2->astParent() && tok2-...",1,1,lib/astutils.cpp,"isVariableChanged:bool(Token*,int,Settings&,int)",<empty>,,false,2597,2815,isVariableChanged,,,1,"bool(Token*,int,Settings&,int)"
111669151068,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isVariableChanged(const Token *start, const Token *end, const nonneg int exprid, bool globalvar, const Settings &settings, int depth)
{
    return findVariableChanged(start, end, 0, exprid, globalvar, settings, depth) != nullptr;
}",1,67,lib/astutils.cpp,"isVariableChanged:bool(Token*,Token*,int,bool,Settings&,int)",<empty>,,false,2817,2820,isVariableChanged,,,1,"bool(Token*,Token*,int,bool,Settings&,int)"
111669151069,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isVariableChanged(const Token *start, const Token *end, int indirect, const nonneg int exprid, bool globalvar, const Settings &settings, int depth)
{
    return findVariableChanged(start, end, indirect, exprid, globalvar, settings, depth) != nullptr;
}",1,81,lib/astutils.cpp,"isVariableChanged:bool(Token*,Token*,int,int,bool,Settings&,int)",<empty>,,false,2822,2825,isVariableChanged,,,1,"bool(Token*,Token*,int,int,bool,Settings&,int)"
111669151070,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* findExpression(const Token* start, const nonneg int exprid)
{
    const Function* f = Scope::nestedInFunction(start->scope());
    if (!f)
        return nullptr;
    const Scope* scope = f->functionScope;
    if (!scope)
        return nullptr;
    for (const Token *tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
        if (tok->exprId() != exprid)
            continue;
        return tok;
    }
    return nullptr;
}",1,54,lib/astutils.cpp,"findExpression:Token*(Token*,int)",<empty>,,false,2827,2841,findExpression,,,1,"Token*(Token*,int)"
111669151071,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* findEscapeStatement(const Scope* scope, const Library* library)
{
    if (!scope)
        return nullptr;
    for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
        const Scope* escapeScope = tok->scope();
        if (!escapeScope->isExecutable()) { // skip type definitions
            tok = escapeScope->bodyEnd;
            continue;
        }
        if (const Token* lambdaEnd = findLambdaEndToken(tok)) { // skip lambdas
            tok = lambdaEnd;
            continue;
        }
        if (!tok->isName())
            continue;
        if (isEscapeFunction(tok, library))
            return tok;
        if (!tok->isKeyword())
            continue;
        if (Token::Match(tok, ""goto|return|throw"")) // TODO: check try/catch, labels?
            return tok;
        if (!Token::Match(tok, ""break|continue""))
            continue;
        const bool isBreak = tok->str()[0] == 'b';
        while (escapeScope && escapeScope != scope) {...",1,1,lib/astutils.cpp,"findEscapeStatement:Token*(Scope*,Library*)",<empty>,,false,2843,2876,findEscapeStatement,,,1,"Token*(Scope*,Library*)"
111669151072,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool isExpressionChangedAt(const F& getExprTok,
                                  const Token* tok,
                                  int indirect,
                                  const nonneg int exprid,
                                  bool globalvar,
                                  const Settings& settings,
                                  int depth)
{
    if (depth < 0)
        return true;
    if (!isMutableExpression(tok))
        return false;
    if (tok->exprId() != exprid || (!tok->varId() && !tok->isName())) {
        if (globalvar && Token::Match(tok, ""%name% ("") &&
            (!(tok->function() && (tok->function()->isAttributePure() || tok->function()->isAttributeConst())))) {
            if (!Token::simpleMatch(tok->astParent(), "".""))
                return true;
            const auto yield = astContainerYield(tok->astParent()->astOperand1());
            if (yield != Library::Container::Yield::SIZE && yield != Library::Container::Yield::EMPTY &&
       ...",1,40,lib/astutils.cpp,"isExpressionChangedAt:bool(F&,Token*,int,int,bool,Settings&,int)",<empty>,,false,2881,2922,isExpressionChangedAt,,,1,"bool(F&,Token*,int,int,bool,Settings&,int)"
111669151073,METHOD,<empty>,<empty>,"[&] {
        return expr;
    }",34,5,lib/astutils.cpp,lib/astutils.cpp:<global>.isExpressionChangedAt.<lambda>16:Token*(),<empty>,,false,2931,2933,<lambda>16,,,1,Token*()
111669151074,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isExpressionChangedAt(const Token* expr,
                           const Token* tok,
                           int indirect,
                           bool globalvar,
                           const Settings& settings,
                           int depth)
{
    return isExpressionChangedAt([&] {
        return expr;
    }, tok, indirect, expr->exprId(), globalvar, settings, depth);
}",1,1,lib/astutils.cpp,"isExpressionChangedAt:bool(Token*,Token*,int,bool,Settings&,int)",<empty>,,false,2924,2934,isExpressionChangedAt,,,1,"bool(Token*,Token*,int,bool,Settings&,int)"
111669151075,METHOD,<empty>,<empty>,"[&] {
        return findExpression(start, exprid);
    }",38,5,lib/astutils.cpp,lib/astutils.cpp:<global>.findVariableChanged.<lambda>17:Token*(),<empty>,,false,2942,2944,<lambda>17,,,1,Token*()
111669151076,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"Token* findVariableChanged(Token *start, const Token *end, int indirect, const nonneg int exprid, bool globalvar, const Settings &settings, int depth)
{
    if (!precedes(start, end))
        return nullptr;
    if (depth < 0)
        return start;
    auto getExprTok = utils::memoize([&] {
        return findExpression(start, exprid);
    });
    for (Token *tok = start; tok != end; tok = tok->next()) {
        if (isExpressionChangedAt(getExprTok, tok, indirect, exprid, globalvar, settings, depth))
            return tok;
    }
    return nullptr;
}",1,79,lib/astutils.cpp,"findVariableChanged:Token*(Token*,Token*,int,int,bool,Settings&,int)",<empty>,,false,2936,2950,findVariableChanged,,,1,"Token*(Token*,Token*,int,int,bool,Settings&,int)"
111669151077,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* findVariableChanged(const Token *start, const Token *end, int indirect, const nonneg int exprid, bool globalvar, const Settings &settings, int depth)
{
    return findVariableChanged(const_cast<Token*>(start), end, indirect, exprid, globalvar, settings, depth);
}",1,91,lib/astutils.cpp,"findVariableChanged<duplicate>0:Token*(Token*,Token*,int,int,bool,Settings&,int)",<empty>,,false,2952,2955,findVariableChanged,,,1,"Token*(Token*,Token*,int,int,bool,Settings&,int)"
111669151078,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isVariableChanged(const Variable * var, const Settings &settings, int depth)
{
    if (!var)
        return false;
    if (!var->scope())
        return false;
    const Token * start = var->declEndToken();
    if (!start)
        return false;
    if (Token::Match(start, ""; %varid% ="", var->declarationId()))
        start = start->tokAt(2);
    if (Token::simpleMatch(start, ""="")) {
        const Token* next = nextAfterAstRightmostLeafGeneric(start);
        if (next)
            start = next;
    }
    return findExpressionChanged(var->nameToken(), start->next(), var->scope()->bodyEnd, settings, depth);
}",1,1,lib/astutils.cpp,"isVariableChanged:bool(Variable*,Settings&,int)",<empty>,,false,2957,2974,isVariableChanged,,,1,"bool(Variable*,Settings&,int)"
111669151079,METHOD,<empty>,<empty>,"[](const Variable* var) {
        return var->declarationId();
    }",87,5,lib/astutils.cpp,lib/astutils.cpp:<global>.isVariablesChanged.<lambda>18:int(Variable*),<empty>,,false,2983,2985,<lambda>18,,,1,int(Variable*)
111669151080,METHOD,<empty>,<empty>,"[](const Variable* var) {
        return var->isGlobal();
    }",68,5,lib/astutils.cpp,lib/astutils.cpp:<global>.isVariablesChanged.<lambda>19:bool(Variable*),<empty>,,false,2986,2988,<lambda>19,,,1,bool(Variable*)
111669151081,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isVariablesChanged(const Token* start,
                        const Token* end,
                        int indirect,
                        const std::vector<const Variable*> &vars,
                        const Settings& settings)
{
    std::set<int> varids;
    std::transform(vars.cbegin(), vars.cend(), std::inserter(varids, varids.begin()), [](const Variable* var) {
        return var->declarationId();
    });
    const bool globalvar = std::any_of(vars.cbegin(), vars.cend(), [](const Variable* var) {
        return var->isGlobal();
    });
    for (const Token* tok = start; tok && tok != end; tok = tok->next()) {
        if (tok->varId() == 0 || varids.count(tok->varId()) == 0) {
            if (globalvar && Token::Match(tok, ""%name% (""))
                // TODO: Is global variable really changed by function call?
                return true;
            continue;
        }
        if (isVariableChanged(tok, indirect, settings))
            return true;
    }
    return ...",1,1,lib/astutils.cpp,"isVariablesChanged:bool(Token*,Token*,int,std.vector<constVariable*>&,Settings&)",<empty>,,false,2976,3000,isVariablesChanged,,,1,"bool(Token*,Token*,int,std.vector<constVariable*>&,Settings&)"
111669151082,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isThisChanged(const Token* tok, int indirect, const Settings& settings)
{
    if ((Token::Match(tok->previous(), ""%name% ("") && !Token::simpleMatch(tok->astOperand1(), ""."")) ||
        Token::Match(tok->tokAt(-3), ""this . %name% ("")) {
        if (tok->previous()->function()) {
            return (!tok->previous()->function()->isConst() && !tok->previous()->function()->isStatic());
        }
        if (!tok->previous()->isKeyword() || tok->previous()->isOperatorKeyword()) {
            return true;
        }
    }
    if (isVariableChanged(tok, indirect, settings))
        return true;
    return false;
}",1,1,lib/astutils.cpp,"isThisChanged:bool(Token*,int,Settings&)",<empty>,,false,3002,3016,isThisChanged,,,1,"bool(Token*,int,Settings&)"
111669151083,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static const Token* findThisChanged(const Token* start, const Token* end, int indirect, const Settings& settings)
{
    if (!precedes(start, end))
        return nullptr;
    for (const Token* tok = start; tok != end; tok = tok->next()) {
        if (!exprDependsOnThis(tok))
            continue;
        if (isThisChanged(tok, indirect, settings))
            return tok;
    }
    return nullptr;
}",1,1,lib/astutils.cpp,"findThisChanged:Token*(Token*,Token*,int,Settings&)",<empty>,,false,3018,3029,findThisChanged,,,1,"Token*(Token*,Token*,int,Settings&)"
111669151084,METHOD,<empty>,<empty>,"[&](const Token* tok2) {
                int indirect = 0;
                if (const ValueType* vt = tok->valueType()) {
                    indirect = vt->pointer;
                    if (vt->type == ValueType::ITERATOR)
                        ++indirect;
                }
                for (int i = 0; i <= indirect; ++i) {
                    if (isExpressionChangedAt(tok, tok2, i, global, settings, depth))
                        return true;
                }
                return false;
            }",56,13,lib/astutils.cpp,lib/astutils.cpp:<global>.findExpressionChangedImpl.<lambda>20.<lambda>21:bool(Token*),<empty>,,false,3061,3073,<lambda>21,,,1,bool(Token*)
111669151085,METHOD,<empty>,<empty>,"[&](const Token* tok) {
        if (exprDependsOnThis(tok)) {
            result = findThisChanged(start, end, /*indirect*/ 0, settings);
            if (result)
                return true;
        }
        bool global = false;
        if (tok->variable()) {
            if (tok->variable()->isConst())
                return false;
            global = !tok->variable()->isLocal() && !tok->variable()->isArgument() &&
                     !(tok->variable()->isMember() && !tok->variable()->isStatic());
        } else if (tok->isIncompleteVar() && !tok->isIncompleteConstant()) {
            global = true;
        }

        if (tok->exprId() > 0 || global) {
            const Token* modifedTok = find(start, end, [&](const Token* tok2) {
                int indirect = 0;
                if (const ValueType* vt = tok->valueType()) {
                    indirect = vt->pointer;
                    if (vt->type == ValueType::ITERATOR)
                        ++indirect;
                }
  ...",23,5,lib/astutils.cpp,lib/astutils.cpp:<global>.findExpressionChangedImpl.<lambda>20:bool(Token*),<empty>,,false,3044,3080,<lambda>20,,,1,bool(Token*)
111669151086,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static const Token* findExpressionChangedImpl(const Token* expr,
                                              const Token* start,
                                              const Token* end,
                                              const Settings& settings,
                                              int depth,
                                              Find find)
{
    if (depth < 0)
        return start;
    if (!precedes(start, end))
        return nullptr;
    const Token* result = nullptr;
    findAstNode(expr, [&](const Token* tok) {
        if (exprDependsOnThis(tok)) {
            result = findThisChanged(start, end, /*indirect*/ 0, settings);
            if (result)
                return true;
        }
        bool global = false;
        if (tok->variable()) {
            if (tok->variable()->isConst())
                return false;
            global = !tok->variable()->isLocal() && !tok->variable()->isArgument() &&
                     !(tok->variable()->...",1,1,lib/astutils.cpp,"findExpressionChangedImpl:Token(Token*,Token*,Token*,Settings&,int,Find)",<empty>,,false,3032,3082,findExpressionChangedImpl,,,1,"Token(Token*,Token*,Token*,Settings&,int,Find)"
111669151087,METHOD,ExpressionChangedSimpleFind,TYPE_DECL,"const Token* operator()(const Token* start, const Token* end, F f) const
        {
            return findToken(start, end, f);
        }",9,9,lib/astutils.cpp,"ExpressionChangedSimpleFind.()<const>:Token(Token*,Token*,F)",<empty>,,false,3087,3090,(),,,1,"Token(Token*,Token*,F)"
111669151088,METHOD,ExpressionChangedSkipDeadCode,TYPE_DECL,"ExpressionChangedSkipDeadCode(const Library& library,
                                      const std::function<std::vector<MathLib::bigint>(const Token* tok)>& evaluate)
            : library(library), evaluate(&evaluate)
        {}",9,10,lib/astutils.cpp,"ExpressionChangedSkipDeadCode.ExpressionChangedSkipDeadCode:ANY(Library&,std.function<std.vector<MathLib.bigint>(constToken*)>&)",<empty>,,false,3096,3099,ExpressionChangedSkipDeadCode,,,3,"ExpressionChangedSkipDeadCode.ExpressionChangedSkipDeadCode:ANY(Library&,std.function<std.vector<MathLib.bigint>(constToken*)>&)(Library&,std.function<std.vector<MathLib.bigint>(constToken*)>&)"
111669151089,METHOD,ExpressionChangedSkipDeadCode,TYPE_DECL,"const Token* operator()(const Token* start, const Token* end, F f) const
        {
            return findTokenSkipDeadCode(library, start, end, std::move(f), *evaluate);
        }",9,9,lib/astutils.cpp,"ExpressionChangedSkipDeadCode.()<const>:Token(Token*,Token*,F)",<empty>,,false,3101,3104,(),,,4,"Token(Token*,Token*,F)"
111669151090,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* findExpressionChanged(const Token* expr,
                                   const Token* start,
                                   const Token* end,
                                   const Settings& settings,
                                   int depth)
{
    return findExpressionChangedImpl(expr, start, end, settings, depth, ExpressionChangedSimpleFind{});
}",1,1,lib/astutils.cpp,"findExpressionChanged:Token*(Token*,Token*,Token*,Settings&,int)",<empty>,,false,3108,3115,findExpressionChanged,,,1,"Token*(Token*,Token*,Token*,Settings&,int)"
111669151091,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* findExpressionChangedSkipDeadCode(const Token* expr,
                                               const Token* start,
                                               const Token* end,
                                               const Settings& settings,
                                               const std::function<std::vector<MathLib::bigint>(const Token* tok)>& evaluate,
                                               int depth)
{
    return findExpressionChangedImpl(
        expr, start, end, settings, depth, ExpressionChangedSkipDeadCode{settings.library, evaluate});
}",1,1,lib/astutils.cpp,"findExpressionChangedSkipDeadCode:Token*(Token*,Token*,Token*,Settings&,std.function<std.vector<MathLib.bigint>(constToken*)>&,int)",<empty>,,false,3117,3126,findExpressionChangedSkipDeadCode,,,1,"Token*(Token*,Token*,Token*,Settings&,std.function<std.vector<MathLib.bigint>(constToken*)>&,int)"
111669151092,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* getArgumentStart(const Token* ftok)
{
    const Token* tok = ftok;
    if (Token::Match(tok, ""%name% (|{|)""))
        tok = ftok->next();
    while (Token::simpleMatch(tok, "")""))
        tok = tok->next();
    if (!Token::Match(tok, ""(|{|[""))
        return nullptr;
    const Token* startTok = tok->astOperand2();
    if (!startTok && tok->next() != tok->link())
        startTok = tok->astOperand1();
    return startTok;
}",1,1,lib/astutils.cpp,getArgumentStart:Token*(Token*),<empty>,,false,3128,3141,getArgumentStart,,,1,Token*(Token*)
111669151093,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"int numberOfArguments(const Token* ftok) {
    return astCount(getArgumentStart(ftok), "","");
}",1,1,lib/astutils.cpp,numberOfArguments:int(Token*),<empty>,,false,3143,3145,numberOfArguments,,,1,int(Token*)
111669151094,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"int numberOfArgumentsWithoutAst(const Token* start)
{
    int arguments = 0;
    const Token* openBracket = start->next();
    while (Token::simpleMatch(openBracket, "")""))
        openBracket = openBracket->next();
    if (openBracket && openBracket->str()==""("" && openBracket->next() && openBracket->strAt(1)!="")"") {
        const Token* argument=openBracket->next();
        while (argument) {
            ++arguments;
            argument = argument->nextArgument();
        }
    }
    return arguments;
}",1,1,lib/astutils.cpp,numberOfArgumentsWithoutAst:int(Token*),<empty>,,false,3147,3161,numberOfArgumentsWithoutAst,,,1,int(Token*)
111669151095,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"std::vector<const Token*> getArguments(const Token* ftok) {
    return astFlatten(getArgumentStart(ftok), "","");
}",1,1,lib/astutils.cpp,getArguments:vector<constToken*>(Token*),<empty>,,false,3163,3165,getArguments,,,1,vector<const Token*>(Token*)
111669151096,METHOD,<empty>,<empty>,"[&](const Variable& v) {
        return v.nameToken() == var->nameToken();
    }",82,5,lib/astutils.cpp,lib/astutils.cpp:<global>.getArgumentPos.<lambda>22:bool(Variable&),<empty>,,false,3169,3171,<lambda>22,,,1,bool(Variable&)
111669151097,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"int getArgumentPos(const Variable* var, const Function* f)
{
    auto arg_it = std::find_if(f->argumentList.cbegin(), f->argumentList.cend(), [&](const Variable& v) {
        return v.nameToken() == var->nameToken();
    });
    if (arg_it == f->argumentList.end())
        return -1;
    return std::distance(f->argumentList.cbegin(), arg_it);
}",1,1,lib/astutils.cpp,"getArgumentPos:int(Variable*,Function*)",<empty>,,false,3167,3175,getArgumentPos,,,1,"int(Variable*,Function*)"
111669151098,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* getIteratorExpression(const Token* tok)
{
    if (!tok)
        return nullptr;
    if (tok->isUnaryOp(""*""))
        return nullptr;
    if (!tok->isName()) {
        const Token* iter1 = getIteratorExpression(tok->astOperand1());
        if (iter1)
            return iter1;
        if (tok->str() == ""("")
            return nullptr;
        const Token* iter2 = getIteratorExpression(tok->astOperand2());
        if (iter2)
            return iter2;
    } else if (Token::Match(tok, ""begin|cbegin|rbegin|crbegin|end|cend|rend|crend ("")) {
        if (Token::Match(tok->previous(), "". %name% ( ) !!.""))
            return tok->previous()->astOperand1();
        if (!Token::simpleMatch(tok->previous(), ""."") && Token::Match(tok, ""%name% ( !!)"") &&
            !Token::simpleMatch(tok->linkAt(1), "") .""))
            return tok->next()->astOperand2();
    }
    return nullptr;
}",1,1,lib/astutils.cpp,getIteratorExpression:Token*(Token*),<empty>,,false,3177,3200,getIteratorExpression,,,1,Token*(Token*)
111669151099,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isIteratorPair(const std::vector<const Token*>& args)
{
    if (args.size() != 2)
        return false;
    if (astIsPointer(args[0]) && astIsPointer(args[1]))
        return true;
    // Check if iterator is from same container
    const Token* tok1 = nullptr;
    const Token* tok2 = nullptr;
    if (astIsIterator(args[0]) && astIsIterator(args[1])) {
        tok1 = ValueFlow::getLifetimeObjValue(args[0]).tokvalue;
        tok2 = ValueFlow::getLifetimeObjValue(args[1]).tokvalue;
        if (!tok1 || !tok2)
            return true;
    } else {
        tok1 = getIteratorExpression(args[0]);
        tok2 = getIteratorExpression(args[1]);
    }
    if (tok1 && tok2)
        return tok1->exprId() == tok2->exprId();
    return tok1 || tok2;
}",1,1,lib/astutils.cpp,isIteratorPair:bool(std.vector<constToken*>&),<empty>,,false,3202,3223,isIteratorPair,,,1,bool(std.vector<constToken*>&)
111669151100,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token *findLambdaStartToken(const Token *last)
{
    if (!last || !last->isCpp() || last->str() != ""}"")
        return nullptr;
    const Token* tok = last->link();
    if (Token::simpleMatch(tok->astParent(), ""(""))
        tok = tok->astParent();
    if (Token::simpleMatch(tok->astParent(), ""[""))
        return tok->astParent();
    return nullptr;
}",1,1,lib/astutils.cpp,findLambdaStartToken:Token*(Token*),<empty>,,false,3225,3235,findLambdaStartToken,,,1,Token*(Token*)
111669151101,METHOD,<empty>,<empty>,"[](T* tok) -> bool {
        while (Token::Match(tok, ""*|%name%|::|>"")) {
            if (tok->link())
                tok = tok->link()->previous();
            else {
                if (tok->str() == "">"")
                    return true;
                if (tok->str() == ""new"")
                    return false;
                tok = tok->previous();
            }
        }
        return true;
    }",24,5,lib/astutils.cpp,lib/astutils.cpp:<global>.findLambdaEndTokenGeneric.<lambda>23:bool(T*),<empty>,,false,3240,3253,<lambda>23,,,1,bool(T*)
111669151102,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static T* findLambdaEndTokenGeneric(T* first)
{
    auto maybeLambda = [](T* tok) -> bool {
        while (Token::Match(tok, ""*|%name%|::|>"")) {
            if (tok->link())
                tok = tok->link()->previous();
            else {
                if (tok->str() == "">"")
                    return true;
                if (tok->str() == ""new"")
                    return false;
                tok = tok->previous();
            }
        }
        return true;
    };

    if (!first || !first->isCpp() || first->str() != ""["")
        return nullptr;
    if (!maybeLambda(first->previous()))
        return nullptr;
    if (!Token::Match(first->link(), ""] (|{|<""))
        return nullptr;
    const Token* roundOrCurly = first->link()->next();
    if (roundOrCurly->link() && roundOrCurly->str() == ""<"")
        roundOrCurly = roundOrCurly->link()->next();
    if (first->astOperand1() != roundOrCurly)
        return nullptr;
    T * tok = first;

    if (tok->astOperand1() && tok->ast...",1,1,lib/astutils.cpp,findLambdaEndTokenGeneric:T(T*),<empty>,,false,3238,3273,findLambdaEndTokenGeneric,,,1,T(T*)
111669151103,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* findLambdaEndToken(const Token* first)
{
    return findLambdaEndTokenGeneric(first);
}",1,1,lib/astutils.cpp,findLambdaEndToken:Token*(Token*),<empty>,,false,3275,3278,findLambdaEndToken,,,1,Token*(Token*)
111669151104,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"Token* findLambdaEndToken(Token* first)
{
    return findLambdaEndTokenGeneric(first);
}",1,1,lib/astutils.cpp,findLambdaEndToken<duplicate>0:Token*(Token*),<empty>,,false,3279,3282,findLambdaEndToken,,,1,Token*(Token*)
111669151105,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isLikelyStream(const Token *stream)
{
    if (!stream)
        return false;

    if (!stream->isCpp())
        return false;

    if (!Token::Match(stream->astParent(), ""&|<<|>>"") || !stream->astParent()->isBinaryOp())
        return false;

    if (stream->astParent()->astOperand1() != stream)
        return false;

    return !astIsIntegral(stream, false);
}",1,1,lib/astutils.cpp,isLikelyStream:bool(Token*),<empty>,,false,3284,3299,isLikelyStream,,,1,bool(Token*)
111669151106,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isLikelyStreamRead(const Token *op)
{
    if (!op)
        return false;

    if (!op->isCpp())
        return false;

    if (!Token::Match(op, ""&|>>"") || !op->isBinaryOp())
        return false;

    if (!Token::Match(op->astOperand2(), ""%name%|.|*|["") && op->str() != op->astOperand2()->str())
        return false;

    const Token *parent = op;
    while (parent->astParent() && parent->astParent()->str() == op->str())
        parent = parent->astParent();
    if (parent->astParent() && !Token::Match(parent->astParent(), ""%oror%|&&|(|,|.|!|;|return""))
        return false;
    if (op->str() == ""&"" && parent->astParent())
        return false;
    if (!parent->astOperand1() || !parent->astOperand2())
        return false;
    return (!parent->astOperand1()->valueType() || !parent->astOperand1()->valueType()->isIntegral());
}",1,1,lib/astutils.cpp,isLikelyStreamRead:bool(Token*),<empty>,,false,3301,3325,isLikelyStreamRead,,,1,bool(Token*)
111669151107,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isCPPCast(const Token* tok)
{
    return tok && Token::simpleMatch(tok->previous(), ""> ("") && tok->astOperand2() && tok->astOperand1() && isCPPCastKeyword(tok->astOperand1());
}",1,1,lib/astutils.cpp,isCPPCast:bool(Token*),<empty>,,false,3327,3330,isCPPCast,,,1,bool(Token*)
111669151108,METHOD,<empty>,<empty>,"[&](const Token* t) {
            return isConstVarExpression(t, skipPredicate);
        }",73,9,lib/astutils.cpp,lib/astutils.cpp:<global>.isConstVarExpression.<lambda>24:bool(Token*),<empty>,,false,3348,3350,<lambda>24,,,1,bool(Token*)
111669151109,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isConstVarExpression(const Token *tok, const std::function<bool(const Token*)>& skipPredicate)
{
    if (!tok)
        return false;
    if (tok->str() == ""?"" && tok->astOperand2() && tok->astOperand2()->str() == "":"") // ternary operator
        return isConstVarExpression(tok->astOperand2()->astOperand1()) && isConstVarExpression(tok->astOperand2()->astOperand2()); // left and right of "":""
    if (skipPredicate && skipPredicate(tok))
        return false;
    if (Token::simpleMatch(tok->previous(), ""sizeof (""))
        return true;
    if (Token::Match(tok->previous(), ""%name% ("")) {
        if (Token::simpleMatch(tok->astOperand1(), ""."") && !isConstVarExpression(tok->astOperand1(), skipPredicate))
            return false;
        std::vector<const Token *> args = getArguments(tok);
        if (args.empty() && tok->previous()->function() && tok->previous()->function()->isConstexpr())
            return true;
        return !args.empty() && std::all_of(args.cbegin(), args.cend...",1,1,lib/astutils.cpp,"isConstVarExpression:bool(Token*,std.function<bool(constToken*)>&)",<empty>,,false,3332,3373,isConstVarExpression,,,1,"bool(Token*,std.function<bool(constToken*)>&)"
111669151110,METHOD,<empty>,<empty>,"[](const Function& f) {
                    return f.isConstructor();
                }",96,17,lib/astutils.cpp,lib/astutils.cpp:<global>.getFunctionUsage.<lambda>25:bool(Function&),<empty>,,false,3396,3398,<lambda>25,,,1,bool(Function&)
111669151111,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static ExprUsage getFunctionUsage(const Token* tok, int indirect, const Settings& settings)
{
    const bool addressOf = tok->astParent() && tok->astParent()->isUnaryOp(""&"");

    int argnr;
    const Token* ftok = getTokenArgumentFunction(tok, argnr);
    if (!ftok)
        return ExprUsage::None;
    const Function* func = ftok->function();
    // variable init/constructor call?
    if (!func && ftok->variable() && ftok == ftok->variable()->nameToken()) {
        // STL types or containers don't initialize external variables
        if (ftok->variable()->isStlType() || (ftok->variable()->valueType() && ftok->variable()->valueType()->container))
            return ExprUsage::Used;
        // TODO: resolve multiple constructors
        if (ftok->variable()->type() && ftok->variable()->type()->classScope) {
            const int nCtor = ftok->variable()->type()->classScope->numConstructors;
            if (nCtor == 0)
                return ExprUsage::Used;
            if (nCtor == 1...",1,1,lib/astutils.cpp,"getFunctionUsage:ExprUsage(Token*,int,Settings&)",<empty>,,false,3375,3440,getFunctionUsage,,,1,"ExprUsage(Token*,int,Settings&)"
111669151112,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isLeafDot(const Token* tok)
{
    if (!tok)
        return false;
    const Token * parent = tok->astParent();
    if (!Token::simpleMatch(parent, "".""))
        return false;
    if (parent->astOperand2() == tok && !Token::simpleMatch(parent->astParent(), "".""))
        return true;
    return isLeafDot(parent);
}",1,1,lib/astutils.cpp,isLeafDot:bool(Token*),<empty>,,false,3442,3452,isLeafDot,,,1,bool(Token*)
111669151113,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"ExprUsage getExprUsage(const Token* tok, int indirect, const Settings& settings)
{
    const Token* parent = tok->astParent();
    if (indirect > 0 && parent) {
        while (Token::simpleMatch(parent, ""["") && parent->astParent())
            parent = parent->astParent();
        if (Token::Match(parent, ""%assign%"") && (astIsRHS(tok) || astIsLHS(parent->astOperand1())))
            return ExprUsage::NotUsed;
        if (Token::Match(parent, ""++|--""))
            return ExprUsage::NotUsed;
        if (parent->isConstOp())
            return ExprUsage::NotUsed;
        if (parent->isCast())
            return ExprUsage::NotUsed;
        if (Token::simpleMatch(parent, "":"") && Token::simpleMatch(parent->astParent(), ""?""))
            return getExprUsage(parent->astParent(), indirect, settings);
        if (isUsedAsBool(tok, settings))
            return ExprUsage::NotUsed;
    }
    if (tok->isUnaryOp(""&"") && !parent)
        return ExprUsage::NotUsed;
    if (indirect == 0) {
        ...",1,1,lib/astutils.cpp,"getExprUsage:ExprUsage(Token*,int,Settings&)",<empty>,,false,3454,3504,getExprUsage,,,1,"ExprUsage(Token*,int,Settings&)"
111669151114,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static void getLHSVariablesRecursive(std::vector<const Variable*>& vars, const Token* tok)
{
    if (!tok)
        return;
    if (vars.empty() && Token::Match(tok, ""*|&|&&|["")) {
        getLHSVariablesRecursive(vars, tok->astOperand1());
        if (!vars.empty() || Token::simpleMatch(tok, ""[""))
            return;
        getLHSVariablesRecursive(vars, tok->astOperand2());
    } else if (Token::Match(tok->previous(), ""this . %var%"")) {
        getLHSVariablesRecursive(vars, tok->next());
    } else if (Token::simpleMatch(tok, ""."")) {
        getLHSVariablesRecursive(vars, tok->astOperand1());
        getLHSVariablesRecursive(vars, tok->astOperand2());
    } else if (Token::simpleMatch(tok, ""::"")) {
        getLHSVariablesRecursive(vars, tok->astOperand2());
    } else if (tok->variable()) {
        vars.push_back(tok->variable());
    }
}",1,1,lib/astutils.cpp,"getLHSVariablesRecursive:void(std.vector<constVariable*>&,Token*)",<empty>,,false,3506,3525,getLHSVariablesRecursive,,,1,"void(std.vector<constVariable*>&,Token*)"
111669151115,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"std::vector<const Variable*> getLHSVariables(const Token* tok)
{
    std::vector<const Variable*> result;
    if (!Token::Match(tok, ""%assign%|(|{""))
        return result;
    if (!tok->astOperand1())
        return result;
    if (tok->astOperand1()->varId() > 0 && tok->astOperand1()->variable())
        return {tok->astOperand1()->variable()};
    getLHSVariablesRecursive(result, tok->astOperand1());
    return result;
}",1,1,lib/astutils.cpp,getLHSVariables:vector<constVariable*>(Token*),<empty>,,false,3527,3538,getLHSVariables,,,1,vector<const Variable*>(Token*)
111669151116,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static const Token* getLHSVariableRecursive(const Token* tok)
{
    if (!tok)
        return nullptr;
    if (Token::Match(tok, ""*|&|&&|["")) {
        const Token* vartok = getLHSVariableRecursive(tok->astOperand1());
        if ((vartok && vartok->variable()) || Token::simpleMatch(tok, ""[""))
            return vartok;
        return getLHSVariableRecursive(tok->astOperand2());
    }
    if (Token::Match(tok->previous(), ""this . %var%""))
        return tok->next();
    return tok;
}",1,1,lib/astutils.cpp,getLHSVariableRecursive:Token*(Token*),<empty>,,false,3540,3553,getLHSVariableRecursive,,,1,Token*(Token*)
111669151117,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Variable *getLHSVariable(const Token *tok)
{
    if (!tok || !tok->isAssignmentOp())
        return nullptr;
    if (!tok->astOperand1())
        return nullptr;
    if (tok->astOperand1()->varId() > 0 && tok->astOperand1()->variable())
        return tok->astOperand1()->variable();
    const Token* vartok = getLHSVariableRecursive(tok->astOperand1());
    if (!vartok)
        return nullptr;
    return vartok->variable();
}",1,1,lib/astutils.cpp,getLHSVariable:Variable*(Token*),<empty>,,false,3555,3567,getLHSVariable,,,1,Variable*(Token*)
111669151118,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* getLHSVariableToken(const Token* tok)
{
    if (!Token::Match(tok, ""%assign%""))
        return nullptr;
    if (!tok->astOperand1())
        return nullptr;
    if (tok->astOperand1()->varId() > 0)
        return tok->astOperand1();
    const Token* vartok = getLHSVariableRecursive(tok->astOperand1());
    if (vartok && vartok->variable() && vartok->variable()->nameToken() == vartok)
        return vartok;
    return tok->astOperand1();
}",1,1,lib/astutils.cpp,getLHSVariableToken:Token*(Token*),<empty>,,false,3569,3581,getLHSVariableToken,,,1,Token*(Token*)
111669151119,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token* findAllocFuncCallToken(const Token *expr, const Library &library)
{
    if (!expr)
        return nullptr;
    if (Token::Match(expr, ""[+-]"")) {
        const Token *tok1 = findAllocFuncCallToken(expr->astOperand1(), library);
        return tok1 ? tok1 : findAllocFuncCallToken(expr->astOperand2(), library);
    }
    if (expr->isCast())
        return findAllocFuncCallToken(expr->astOperand2() ? expr->astOperand2() : expr->astOperand1(), library);
    if (Token::Match(expr->previous(), ""%name% ("") && library.getAllocFuncInfo(expr->astOperand1()))
        return expr->astOperand1();
    return (Token::simpleMatch(expr, ""new"") && expr->astOperand1()) ? expr : nullptr;
}",1,1,lib/astutils.cpp,"findAllocFuncCallToken:Token*(Token*,Library&)",<empty>,,false,3583,3596,findAllocFuncCallToken,,,1,"Token*(Token*,Library&)"
111669151120,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isNullOperand(const Token *expr)
{
    if (!expr)
        return false;
    if (expr->isCpp() && Token::Match(expr, ""static_cast|const_cast|dynamic_cast|reinterpret_cast <""))
        expr = expr->astParent();
    else if (!expr->isCast())
        return Token::Match(expr, ""NULL|nullptr"");
    if (expr->valueType() && expr->valueType()->pointer == 0)
        return false;
    const Token *castOp = expr->astOperand2() ? expr->astOperand2() : expr->astOperand1();
    return Token::Match(castOp, ""NULL|nullptr"") || (MathLib::isInt(castOp->str()) && MathLib::isNullValue(castOp->str()));
}",1,1,lib/astutils.cpp,isNullOperand:bool(Token*),<empty>,,false,3598,3610,isNullOperand,,,1,bool(Token*)
111669151121,METHOD,<empty>,<empty>,"[expr, &globalData, &var](const Token *tok) {
        if (tok->varId())
            var = true;
        if (tok->varId() && !tok->variable()) {
            // Bailout, this is probably global
            globalData = true;
            return ChildrenToVisit::none;
        }
        if (tok->originalName() == ""->"") {
            // TODO check if pointer points at local data
            globalData = true;
            return ChildrenToVisit::none;
        }
        if (Token::Match(tok, ""[*[]"") && tok->astOperand1() && tok->astOperand1()->variable()) {
            // TODO check if pointer points at local data
            const Variable *lhsvar = tok->astOperand1()->variable();
            const ValueType *lhstype = tok->astOperand1()->valueType();
            if (lhsvar->isPointer()) {
                globalData = true;
                return ChildrenToVisit::none;
            }
            if (lhsvar->isArgument() && lhsvar->isArray()) {
                globalData = true;
            ...",19,5,lib/astutils.cpp,lib/astutils.cpp:<global>.isGlobalData.<lambda>26:ChildrenToVisit(Token*),<empty>,,false,3625,3690,<lambda>26,,,1,ChildrenToVisit(Token*)
111669151122,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isGlobalData(const Token *expr)
{
    // function call that returns reference => assume global data
    if (expr && expr->str() == ""("" && expr->valueType() && expr->valueType()->reference != Reference::None) {
        if (expr->isBinaryOp())
            return true;
        if (expr->astOperand1() && precedes(expr->astOperand1(), expr))
            return true;
    }

    bool globalData = false;
    bool var = false;
    visitAstNodes(expr,
                  [expr, &globalData, &var](const Token *tok) {
        if (tok->varId())
            var = true;
        if (tok->varId() && !tok->variable()) {
            // Bailout, this is probably global
            globalData = true;
            return ChildrenToVisit::none;
        }
        if (tok->originalName() == ""->"") {
            // TODO check if pointer points at local data
            globalData = true;
            return ChildrenToVisit::none;
        }
        if (Token::Match(tok, ""[*[]"") && tok->astOperand1() && tok->a...",1,1,lib/astutils.cpp,isGlobalData:bool(Token*),<empty>,,false,3612,3692,isGlobalData,,,1,bool(Token*)
111669151123,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isUnevaluated(const Token *tok)
{
    return Token::Match(tok, ""alignof|_Alignof|_alignof|__alignof|__alignof__|decltype|offsetof|sizeof|typeid|typeof|__typeof__ ("");
}",1,1,lib/astutils.cpp,isUnevaluated:bool(Token*),<empty>,,false,3694,3697,isUnevaluated,,,1,bool(Token*)
111669151124,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static std::set<MathLib::bigint> getSwitchValues(const Token *startbrace, bool &hasDefault)
{
    std::set<MathLib::bigint> values;
    const Token *endbrace = startbrace->link();
    if (!endbrace)
        return values;

    hasDefault = false;
    for (const Token *tok = startbrace->next(); tok && tok != endbrace; tok = tok->next()) {
        if (Token::simpleMatch(tok, ""{"") && tok->scope()->type == ScopeType::eSwitch) {
            tok = tok->link();
            continue;
        }
        if (Token::simpleMatch(tok, ""default"")) {
            hasDefault = true;
            break;
        }
        if (Token::simpleMatch(tok, ""case"")) {
            const Token *valueTok = tok->astOperand1();
            if (const ValueFlow::Value* v = valueTok->getKnownValue(ValueFlow::Value::ValueType::INT))
                values.insert(v->intvalue);
            continue;
        }
    }

    return values;
}",1,1,lib/astutils.cpp,"getSwitchValues:set<MathLib.bigint>(Token*,bool&)",<empty>,,false,3699,3725,getSwitchValues,,,1,"set<MathLib::bigint>(Token*,bool&)"
111669151125,METHOD,<empty>,<empty>,"[&](const Enumerator &e) {
            return !e.value_known || switchValues.count(e.value);
        }",64,9,lib/astutils.cpp,lib/astutils.cpp:<global>.isExhaustiveSwitch.<lambda>27:bool(Enumerator&),<empty>,,false,3749,3751,<lambda>27,,,1,bool(Enumerator&)
111669151126,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isExhaustiveSwitch(const Token *startbrace)
{
    if (!startbrace || !Token::simpleMatch(startbrace->previous(), "") {"") || startbrace->scope()->type != ScopeType::eSwitch)
        return false;
    const Token *rpar = startbrace->previous();
    const Token *lpar = rpar->link();

    const Token *condition = lpar->astOperand2();
    if (!condition->valueType())
        return true;

    bool hasDefault = false;
    const std::set<MathLib::bigint> switchValues = getSwitchValues(startbrace, hasDefault);

    if (hasDefault)
        return true;

    if (condition->valueType()->type == ValueType::Type::BOOL)
        return switchValues.count(0) && switchValues.count(1);

    if (condition->valueType()->isEnum()) {
        const std::vector<Enumerator> &enumList = condition->valueType()->typeScope->enumeratorList;
        return std::all_of(enumList.cbegin(), enumList.cend(), [&](const Enumerator &e) {
            return !e.value_known || switchValues.count(e.value);
        });
  ...",1,1,lib/astutils.cpp,isExhaustiveSwitch:bool(Token*),<empty>,,false,3727,3755,isExhaustiveSwitch,,,1,bool(Token*)
111669151127,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"bool isUnreachableOperand(const Token *tok)
{
    for (;;)
    {
        const Token *parent = tok->astParent();
        if (!parent)
            break;

        if (parent->isBinaryOp()) {
            const bool left = tok == parent->astOperand1();
            const Token *sibling = left ? parent->astOperand2() : parent->astOperand1();

            // logical and
            if (Token::simpleMatch(parent, ""&&"") && !left && sibling->hasKnownIntValue()
                && !sibling->getKnownIntValue())
                return true;

            // logical or
            if (Token::simpleMatch(parent, ""||"") && !left && sibling->hasKnownIntValue()
                && sibling->getKnownIntValue())
                return true;

            // ternary
            if (Token::simpleMatch(parent, "":"") && Token::simpleMatch(parent->astParent(), ""?"")) {
                const Token *condTok = parent->astParent()->astOperand1();
                if (condTok->hasKnownIntValue() && static_cast<bool>(con...",1,1,lib/astutils.cpp,isUnreachableOperand:bool(Token*),<empty>,,false,3757,3791,isUnreachableOperand,,,1,bool(Token*)
111669151128,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static bool unknownLeafValuesAreTemplateArgs(const Token *tok)
{
    if (!tok)
        return true;

    if (!tok->astOperand1() && !tok->astOperand2())
        return tok->isTemplateArg() || tok->hasKnownIntValue();

    return unknownLeafValuesAreTemplateArgs(tok->astOperand1())
           && unknownLeafValuesAreTemplateArgs(tok->astOperand2());
}",1,1,lib/astutils.cpp,unknownLeafValuesAreTemplateArgs:bool(Token*),<empty>,,false,3793,3803,unknownLeafValuesAreTemplateArgs,,,1,bool(Token*)
111669151129,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static const Token *skipUnreachableIfBranch(const Token *tok)
{
    const Token *condTok = tok->linkAt(-1);
    if (!condTok)
        return tok;

    if (!Token::simpleMatch(condTok->tokAt(-1), ""if"") && !Token::simpleMatch(condTok->tokAt(-2), ""if constexpr""))
        return tok;

    condTok = condTok->astOperand2();
    if (!condTok)
        return tok;

    if ((condTok->hasKnownIntValue() && condTok->getKnownIntValue() == 0)
        || (unknownLeafValuesAreTemplateArgs(condTok) && condTok->getValue(0))) {
        tok = tok->link();
    }

    return tok;
}",1,1,lib/astutils.cpp,skipUnreachableIfBranch:Token*(Token*),<empty>,,false,3805,3824,skipUnreachableIfBranch,,,1,Token*(Token*)
111669151130,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"static const Token *skipUnreachableElseBranch(const Token *tok)
{
    if (!Token::simpleMatch(tok->tokAt(-2), ""} else {""))
        return tok;

    const Token *condTok = tok->linkAt(-2);
    if (!condTok)
        return tok;

    condTok = condTok->linkAt(-1);
    if (!condTok)
        return tok;

    if (!Token::simpleMatch(condTok->tokAt(-1), ""if ("") && !Token::simpleMatch(condTok->tokAt(-2), ""if constexpr (""))
        return tok;

    condTok = condTok->astOperand2();

    if ((condTok->hasKnownIntValue() && condTok->getKnownIntValue() != 0)
        || (unknownLeafValuesAreTemplateArgs(condTok) && condTok->getValueNE(0))) {
        tok = tok->link();
    }

    return tok;
}",1,1,lib/astutils.cpp,skipUnreachableElseBranch:Token*(Token*),<empty>,,false,3826,3850,skipUnreachableElseBranch,,,1,Token*(Token*)
111669151131,METHOD,lib/astutils.cpp:<global>,TYPE_DECL,"const Token *skipUnreachableBranch(const Token *tok)
{
    if (!Token::simpleMatch(tok, ""{""))
        return tok;

    if (tok->scope()->type == ScopeType::eIf) {
        return skipUnreachableIfBranch(tok);
    }

    if (tok->scope()->type == ScopeType::eElse) {
        return skipUnreachableElseBranch(tok);
    }

    return tok;
}",1,1,lib/astutils.cpp,skipUnreachableBranch:Token*(Token*),<empty>,,false,3852,3866,skipUnreachableBranch,,,1,Token*(Token*)
111669151132,METHOD,lib/astutils.h:<global>,TYPE_DECL,<global>,1,1,lib/astutils.h,lib/astutils.h:<global>,<empty>,,false,1,462,<global>,,,1,
111669151133,METHOD,lib/calculate.h:<global>,TYPE_DECL,"inline bool isEqual(double x, double y)
{
    const double diff = (x > y) ? x - y : y - x;
    return !((diff / 2) < diff);
}",1,1,lib/calculate.h,isEqual,<empty>,,false,33,37,isEqual,,,1,"bool(double,double)"
111669151134,METHOD,lib/calculate.h:<global>,TYPE_DECL,<global>,1,1,lib/calculate.h,lib/calculate.h:<global>,<empty>,,false,1,127,<global>,,,1,
111669151135,METHOD,lib/calculate.h:<global>,TYPE_DECL,"inline bool isEqual(float x, float y)
{
    return isEqual(double(x), double(y));
}",1,1,lib/calculate.h,isEqual<duplicate>0,<empty>,,false,38,41,isEqual,,,1,"bool(float,float)"
111669151136,METHOD,<empty>,<empty>,"[&](const Check *i) {
            return i->name() == aname;
        }",78,9,lib/check.cpp,lib/check.cpp:<global>.Check.Check:ANY(std.string&).<lambda>0:bool(Check*),<empty>,,false,41,43,<lambda>0,,,1,bool(Check*)
111669151137,METHOD,<empty>,<empty>,"[&](const Check* i) {
        return i->name() > aname;
    }",74,5,lib/check.cpp,lib/check.cpp:<global>.Check.Check:ANY(std.string&).<lambda>1:bool(Check*),<empty>,,false,49,51,<lambda>1,,,1,bool(Check*)
111669151138,METHOD,lib/check.cpp:<global>,TYPE_DECL,"Check::Check(const std::string &aname)
    : mName(aname)
{
    {
        const auto it = std::find_if(instances().begin(), instances().end(), [&](const Check *i) {
            return i->name() == aname;
        });
        if (it != instances().end())
            throw std::runtime_error(""'"" + aname + ""' instance already exists"");
    }

    // make sure the instances are sorted
    const auto it = std::find_if(instances().begin(), instances().end(), [&](const Check* i) {
        return i->name() > aname;
    });
    if (it == instances().end())
        instances().push_back(this);
    else
        instances().insert(it, this);
}",1,1,lib/check.cpp,Check.Check:ANY(std.string&),<empty>,,false,37,56,Check,,,1,Check.Check:ANY(std.string&)(std.string&)
111669151139,METHOD,lib/check.cpp:<global>,TYPE_DECL,<global>,1,1,lib/check.cpp,lib/check.cpp:<global>,<empty>,,false,1,134,<global>,,,1,
111669151140,METHOD,lib/check.cpp:<global>,TYPE_DECL,"void Check::writeToErrorList(const ErrorMessage &errmsg)
{
    std::cout << errmsg.toXML() << std::endl;
}",1,1,lib/check.cpp,Check.writeToErrorList:void(ErrorMessage&),<empty>,,false,58,61,writeToErrorList,,,1,void(ErrorMessage&)
111669151141,METHOD,lib/check.cpp:<global>,TYPE_DECL,"void Check::reportError(const std::list<const Token *> &callstack, Severity severity, const std::string &id, const std::string &msg, const CWE &cwe, Certainty certainty)
{
    // TODO: report debug warning when error is for a disabled severity
    const ErrorMessage errmsg(callstack, mTokenizer ? &mTokenizer->list : nullptr, severity, id, msg, cwe, certainty);
    if (mErrorLogger)
        mErrorLogger->reportErr(errmsg);
    else
        writeToErrorList(errmsg);
}",1,1,lib/check.cpp,"Check.reportError:void(std.list<constToken*>&,Severity,std.string&,std.string&,CWE&,Certainty)",<empty>,,false,64,72,reportError,,,1,"void(std.list<constToken*>&,Severity,std.string&,std.string&,CWE&,Certainty)"
111669151142,METHOD,lib/check.cpp:<global>,TYPE_DECL,"void Check::reportError(const ErrorPath &errorPath, Severity severity, const char id[], const std::string &msg, const CWE &cwe, Certainty certainty)
{
    // TODO: report debug warning when error is for a disabled severity
    const ErrorMessage errmsg(errorPath, mTokenizer ? &mTokenizer->list : nullptr, severity, id, msg, cwe, certainty);
    if (mErrorLogger)
        mErrorLogger->reportErr(errmsg);
    else
        writeToErrorList(errmsg);
}",1,1,lib/check.cpp,"Check.reportError:void(ErrorPath&,Severity,char[],std.string&,CWE&,Certainty)",<empty>,,false,74,82,reportError,,,1,"void(ErrorPath&,Severity,char[],std.string&,CWE&,Certainty)"
111669151143,METHOD,lib/check.cpp:<global>,TYPE_DECL,"bool Check::wrongData(const Token *tok, const char *str)
{
    if (mSettings->daca)
        reportError(tok, Severity::debug, ""DacaWrongData"", ""Wrong data detected by condition "" + std::string(str));
    return true;
}",1,1,lib/check.cpp,"Check.wrongData:bool(Token*,char*)",<empty>,,false,84,89,wrongData,,,1,"bool(Token*,char*)"
111669151144,METHOD,lib/check.cpp:<global>,TYPE_DECL,"std::list<Check *> &Check::instances()
{
#ifdef __SVR4
    // Under Solaris, destructors are called in wrong order which causes a segmentation fault.
    // This fix ensures pointer remains valid and reachable until program terminates.
    static std::list<Check *> *_instances= new std::list<Check *>;
    return *_instances;
#else
    static std::list<Check *> _instances;
    return _instances;
#endif
}",1,1,lib/check.cpp,Check.instances:list<Check*>(),<empty>,,false,91,102,instances,,,1,list<Check*>()
111669151145,METHOD,lib/check.cpp:<global>,TYPE_DECL,"std::string Check::getMessageId(const ValueFlow::Value &value, const char id[])
{
    if (value.condition != nullptr)
        return id + std::string(""Cond"");
    if (value.safe)
        return std::string(""safe"") + (char)std::toupper(id[0]) + (id + 1);
    return id;
}",1,1,lib/check.cpp,"Check.getMessageId:string(ValueFlow.Value&,char[])",<empty>,,false,104,111,getMessageId,,,1,"string(ValueFlow.Value&,char[])"
111669151146,METHOD,lib/check.cpp:<global>,TYPE_DECL,"ErrorPath Check::getErrorPath(const Token* errtok, const ValueFlow::Value* value, std::string bug) const
{
    ErrorPath errorPath;
    if (!value) {
        errorPath.emplace_back(errtok, std::move(bug));
    } else if (mSettings->verbose || mSettings->outputFormat == Settings::OutputFormat::xml || !mSettings->templateLocation.empty()) {
        errorPath = value->errorPath;
        errorPath.emplace_back(errtok, std::move(bug));
    } else {
        if (value->condition)
            errorPath.emplace_back(value->condition, ""condition '"" + value->condition->expressionString() + ""'"");
        //else if (!value->isKnown() || value->defaultArg)
        //    errorPath = value->callstack;
        errorPath.emplace_back(errtok, std::move(bug));
    }
    return errorPath;
}",1,1,lib/check.cpp,"Check.getErrorPath<const>:ErrorPath(Token*,ValueFlow.Value*,std.string)",<empty>,,false,113,129,getErrorPath,,,1,"ErrorPath(Token*,ValueFlow.Value*,std.string)"
111669151147,METHOD,lib/check.cpp:<global>,TYPE_DECL,"void Check::logChecker(const char id[])
{
    reportError(nullptr, Severity::internal, ""logChecker"", id);
}",1,1,lib/check.cpp,Check.logChecker:void(char[]),<empty>,,false,131,134,logChecker,,,1,void(char[])
111669151148,METHOD,lib/check.h:<global>,TYPE_DECL,<global>,1,1,lib/check.h,lib/check.h:<global>,<empty>,,false,1,172,<global>,,,1,
111669151149,METHOD,lib/check64bit.cpp:<global>,TYPE_DECL,"void Check64BitPortability::pointerassignment()
{
    if (!mSettings->severity.isEnabled(Severity::portability))
        return;

    logChecker(""Check64BitPortability::pointerassignment""); // portability

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    // Check return values
    for (const Scope * scope : symbolDatabase->functionScopes) {
        if (scope->function == nullptr || !scope->function->hasBody()) // We only look for functions with a body
            continue;

        bool retPointer = false;
        if (scope->function->token->strAt(-1) == ""*"") // Function returns a pointer
            retPointer = true;
        else if (Token::Match(scope->function->token->previous(), ""int|long|DWORD"")) // Function returns an integer
            ;
        else
            continue;

        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            // skip nested functions
            if (tok->str() == ""{""...",1,1,lib/check64bit.cpp,Check64BitPortability.pointerassignment:void(),<empty>,,false,43,119,pointerassignment,,,1,void()
111669151150,METHOD,lib/check64bit.cpp:<global>,TYPE_DECL,<global>,1,1,lib/check64bit.cpp,lib/check64bit.cpp:<global>,<empty>,,false,1,178,<global>,,,1,
111669151151,METHOD,lib/check64bit.cpp:<global>,TYPE_DECL,"void Check64BitPortability::assignmentAddressToIntegerError(const Token *tok)
{
    reportError(tok, Severity::portability,
                ""AssignmentAddressToInteger"",
                ""Assigning a pointer to an integer is not portable.\\n""
                ""Assigning a pointer to an integer (int/long/etc) is not portable across different platforms and ""
                ""compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux ""
                ""they are of different width. In worst case you end up assigning 64-bit address to 32-bit integer. The safe ""
                ""way is to store addresses only in pointer types (or typedefs like uintptr_t)."", CWE758, Certainty::normal);
}",1,1,lib/check64bit.cpp,Check64BitPortability.assignmentAddressToIntegerError:void(Token*),<empty>,,false,121,130,assignmentAddressToIntegerError,,,1,void(Token*)
111669151152,METHOD,lib/check64bit.cpp:<global>,TYPE_DECL,"void Check64BitPortability::assignmentIntegerToAddressError(const Token *tok)
{
    reportError(tok, Severity::portability,
                ""AssignmentIntegerToAddress"",
                ""Assigning an integer to a pointer is not portable.\\n""
                ""Assigning an integer (int/long/etc) to a pointer is not portable across different platforms and ""
                ""compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux ""
                ""they are of different width. In worst case you end up assigning 64-bit integer to 32-bit pointer. The safe ""
                ""way is to store addresses only in pointer types (or typedefs like uintptr_t)."", CWE758, Certainty::normal);
}",1,1,lib/check64bit.cpp,Check64BitPortability.assignmentIntegerToAddressError:void(Token*),<empty>,,false,132,141,assignmentIntegerToAddressError,,,1,void(Token*)
111669151153,METHOD,lib/check64bit.cpp:<global>,TYPE_DECL,"void Check64BitPortability::returnPointerError(const Token *tok)
{
    reportError(tok, Severity::portability,
                ""CastAddressToIntegerAtReturn"",
                ""Returning an address value in a function with integer return type is not portable.\\n""
                ""Returning an address value in a function with integer (int/long/etc) return type is not portable across ""
                ""different platforms and compilers. For example in 32-bit Windows and Linux they are same width, but in ""
                ""64-bit Windows and Linux they are of different width. In worst case you end up casting 64-bit address down ""
                ""to 32-bit integer. The safe way is to always return an integer."", CWE758, Certainty::normal);
}",1,1,lib/check64bit.cpp,Check64BitPortability.returnPointerError:void(Token*),<empty>,,false,143,152,returnPointerError,,,1,void(Token*)
111669151154,METHOD,lib/check64bit.cpp:<global>,TYPE_DECL,"void Check64BitPortability::returnIntegerError(const Token *tok)
{
    reportError(tok, Severity::portability,
                ""CastIntegerToAddressAtReturn"",
                ""Returning an integer in a function with pointer return type is not portable.\\n""
                ""Returning an integer (int/long/etc) in a function with pointer return type is not portable across different ""
                ""platforms and compilers. For example in 32-bit Windows and Linux they are same width, but in 64-bit Windows ""
                ""and Linux they are of different width. In worst case you end up casting 64-bit integer down to 32-bit pointer. ""
                ""The safe way is to always return a pointer."", CWE758, Certainty::normal);
}",1,1,lib/check64bit.cpp,Check64BitPortability.returnIntegerError:void(Token*),<empty>,,false,154,163,returnIntegerError,,,1,void(Token*)
111669151155,METHOD,lib/check64bit.cpp:<global>,TYPE_DECL,"void Check64BitPortability::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    Check64BitPortability check64BitPortability(&tokenizer, &tokenizer.getSettings(), errorLogger);
    check64BitPortability.pointerassignment();
}",1,1,lib/check64bit.cpp,"Check64BitPortability.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,165,169,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669151156,METHOD,lib/check64bit.cpp:<global>,TYPE_DECL,"void Check64BitPortability::getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const
{
    Check64BitPortability c(nullptr, settings, errorLogger);
    c.assignmentAddressToIntegerError(nullptr);
    c.assignmentIntegerToAddressError(nullptr);
    c.returnIntegerError(nullptr);
    c.returnPointerError(nullptr);
}",1,1,lib/check64bit.cpp,"Check64BitPortability.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,171,178,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669151157,METHOD,lib/check64bit.h:<global>,TYPE_DECL,<global>,1,1,lib/check64bit.h,lib/check64bit.h:<global>,<empty>,,false,1,79,<global>,,,1,
111669151158,METHOD,<empty>,<empty>,"[](const std::pair<int, Library::ArgumentChecks>& ac) {
                        return ac.second.iteratorInfo.container > 0; // bailout, takes iterators -> assume read access
                    }",89,21,lib/checkassert.cpp,"lib/checkassert.cpp:<global>.CheckAssert.assertWithSideEffects.<lambda>0:bool(std.pair<int,Library.ArgumentChecks>&)",<empty>,,false,71,73,<lambda>0,,,1,"bool(std.pair<int,Library.ArgumentChecks>&)"
111669151159,METHOD,lib/checkassert.cpp:<global>,TYPE_DECL,"void CheckAssert::assertWithSideEffects()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckAssert::assertWithSideEffects""); // warning

    for (const Token* tok = mTokenizer->list.front(); tok; tok = tok->next()) {
        if (!Token::simpleMatch(tok, ""assert (""))
            continue;

        const Token *endTok = tok->linkAt(1);
        for (const Token* tmp = tok->next(); tmp != endTok; tmp = tmp->next()) {
            if (Token::simpleMatch(tmp, ""sizeof (""))
                tmp = tmp->linkAt(1);

            checkVariableAssignment(tmp, tok->scope());

            if (tmp->tokType() != Token::eFunction) {
                if (const Library::Function* f = mSettings->library.getFunction(tmp)) {
                    if (f->isconst || f->ispure)
                        continue;
                    if (Library::getContainerYield(tmp->next()) != Library::Container::Yield::NO_YIELD) // bailout, assume read access
                      ...",1,1,lib/checkassert.cpp,CheckAssert.assertWithSideEffects:void(),<empty>,,false,47,121,assertWithSideEffects,,,1,void()
111669151160,METHOD,lib/checkassert.cpp:<global>,TYPE_DECL,<global>,1,1,lib/checkassert.cpp,lib/checkassert.cpp:<global>,<empty>,,false,1,197,<global>,,,1,
111669151161,METHOD,lib/checkassert.cpp:<global>,TYPE_DECL,"void CheckAssert::sideEffectInAssertError(const Token *tok, const std::string& functionName)
{
    reportError(tok, Severity::warning,
                ""assertWithSideEffect"",
                ""$symbol:"" + functionName + ""\\n""
                ""Assert statement calls a function which may have desired side effects: '$symbol'.\\n""
                ""Non-pure function: '$symbol' is called inside assert statement. ""
                ""Assert statements are removed from release builds so the code inside ""
                ""assert statement is not executed. If the code is needed also in release ""
                ""builds, this is a bug."", CWE398, Certainty::normal);
}",1,1,lib/checkassert.cpp,"CheckAssert.sideEffectInAssertError:void(Token*,std.string&)",<empty>,,false,125,135,sideEffectInAssertError,,,1,"void(Token*,std.string&)"
111669151162,METHOD,lib/checkassert.cpp:<global>,TYPE_DECL,"void CheckAssert::assignmentInAssertError(const Token *tok, const std::string& varname)
{
    reportError(tok, Severity::warning,
                ""assignmentInAssert"",
                ""$symbol:"" + varname + ""\\n""
                ""Assert statement modifies '$symbol'.\\n""
                ""Variable '$symbol' is modified inside assert statement. ""
                ""Assert statements are removed from release builds so the code inside ""
                ""assert statement is not executed. If the code is needed also in release ""
                ""builds, this is a bug."", CWE398, Certainty::normal);
}",1,1,lib/checkassert.cpp,"CheckAssert.assignmentInAssertError:void(Token*,std.string&)",<empty>,,false,137,147,assignmentInAssertError,,,1,"void(Token*,std.string&)"
111669151163,METHOD,lib/checkassert.cpp:<global>,TYPE_DECL,"void CheckAssert::checkVariableAssignment(const Token* assignTok, const Scope *assertionScope)
{
    if (!assignTok->isAssignmentOp() && assignTok->tokType() != Token::eIncDecOp)
        return;

    if (!assignTok->astOperand1())
        return;
    const Variable* var = assignTok->astOperand1()->variable();
    if (!var)
        return;

    // Variable declared in inner scope in assert => don't warn
    if (assertionScope != var->scope()) {
        const Scope *s = var->scope();
        while (s && s != assertionScope)
            s = s->nestedIn;
        if (s == assertionScope)
            return;
    }

    // assignment
    if (assignTok->isAssignmentOp() || assignTok->tokType() == Token::eIncDecOp) {
        if (var->isConst()) {
            return;
        }
        assignmentInAssertError(assignTok, var->name());
    }
    // TODO: function calls on var
}",1,1,lib/checkassert.cpp,"CheckAssert.checkVariableAssignment:void(Token*,Scope*)",<empty>,,false,150,178,checkVariableAssignment,,,1,"void(Token*,Scope*)"
111669151164,METHOD,lib/checkassert.cpp:<global>,TYPE_DECL,"bool CheckAssert::inSameScope(const Token* returnTok, const Token* assignTok)
{
    // TODO: even if a return is in the same scope, the assignment might not affect it.
    return returnTok->scope() == assignTok->scope();
}",1,1,lib/checkassert.cpp,"CheckAssert.inSameScope:bool(Token*,Token*)",<empty>,,false,180,184,inSameScope,,,1,"bool(Token*,Token*)"
111669151165,METHOD,lib/checkassert.cpp:<global>,TYPE_DECL,"void CheckAssert::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    CheckAssert checkAssert(&tokenizer, &tokenizer.getSettings(), errorLogger);
    checkAssert.assertWithSideEffects();
}",1,1,lib/checkassert.cpp,"CheckAssert.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,186,190,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669151166,METHOD,lib/checkassert.cpp:<global>,TYPE_DECL,"void CheckAssert::getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const
{
    CheckAssert c(nullptr, settings, errorLogger);
    c.sideEffectInAssertError(nullptr, ""function"");
    c.assignmentInAssertError(nullptr, ""var"");
}",1,1,lib/checkassert.cpp,"CheckAssert.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,192,197,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669151167,METHOD,lib/checkassert.h:<global>,TYPE_DECL,<global>,1,1,lib/checkassert.h,lib/checkassert.h:<global>,<empty>,,false,1,74,<global>,,,1,
111669151168,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"static bool isPtrArg(const Token *tok)
{
    const Variable *var = tok->variable();
    return (var && var->isArgument() && var->isPointer());
}",1,1,lib/checkautovariables.cpp,isPtrArg:bool(Token*),<empty>,,false,52,56,isPtrArg,,,1,bool(Token*)
111669151169,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,<global>,1,1,lib/checkautovariables.cpp,lib/checkautovariables.cpp:<global>,<empty>,,false,1,816,<global>,,,1,
111669151170,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"static bool isArrayArg(const Token *tok, const Settings& settings)
{
    const Variable *var = tok->variable();
    return (var && var->isArgument() && var->isArray() && !settings.library.isentrypoint(var->scope()->className));
}",1,1,lib/checkautovariables.cpp,"isArrayArg:bool(Token*,Settings&)",<empty>,,false,58,62,isArrayArg,,,1,"bool(Token*,Settings&)"
111669151171,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"static bool isArrayVar(const Token *tok)
{
    const Variable *var = tok->variable();
    return (var && var->isArray() && !var->isArgument());
}",1,1,lib/checkautovariables.cpp,isArrayVar:bool(Token*),<empty>,,false,64,68,isArrayVar,,,1,bool(Token*)
111669151172,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"static bool isRefPtrArg(const Token *tok)
{
    const Variable *var = tok->variable();
    return (var && var->isArgument() && var->isReference() && var->isPointer());
}",1,1,lib/checkautovariables.cpp,isRefPtrArg:bool(Token*),<empty>,,false,70,74,isRefPtrArg,,,1,bool(Token*)
111669151173,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"static bool isNonReferenceArg(const Token *tok)
{
    const Variable *var = tok->variable();
    return (var && var->isArgument() && !var->isReference() && (var->isPointer() || (var->valueType() && var->valueType()->type >= ValueType::Type::CONTAINER) || var->type()));
}",1,1,lib/checkautovariables.cpp,isNonReferenceArg:bool(Token*),<empty>,,false,76,80,isNonReferenceArg,,,1,bool(Token*)
111669151174,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"static bool isAutoVar(const Token *tok)
{
    const Variable *var = tok->variable();

    if (!var || !var->isLocal() || var->isStatic())
        return false;

    if (var->isReference()) {
        // address of reference variable can be taken if the address
        // of the variable it points at is not a auto-var
        // TODO: check what the reference variable references.
        return false;
    }

    if (Token::Match(tok, ""%name% .|::"")) {
        do {
            tok = tok->tokAt(2);
        } while (Token::Match(tok, ""%name% .|::""));
        if (Token::Match(tok, ""%name% (""))
            return false;
    }
    return true;
}",1,1,lib/checkautovariables.cpp,isAutoVar:bool(Token*),<empty>,,false,82,104,isAutoVar,,,1,bool(Token*)
111669151175,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"static bool isAutoVarArray(const Token *tok)
{
    if (!tok)
        return false;

    // &x[..]
    if (tok->isUnaryOp(""&"") && Token::simpleMatch(tok->astOperand1(), ""[""))
        return isAutoVarArray(tok->astOperand1()->astOperand1());

    // x+y
    if (tok->str() == ""+"")
        return isAutoVarArray(tok->astOperand1()) || isAutoVarArray(tok->astOperand2());

    // x-intexpr
    if (tok->str() == ""-"")
        return isAutoVarArray(tok->astOperand1()) &&
               tok->astOperand2() &&
               tok->astOperand2()->valueType() &&
               tok->astOperand2()->valueType()->isIntegral();

    const Variable *var = tok->variable();
    if (!var)
        return false;

    // Variable
    if (var->isLocal() && !var->isStatic() && var->isArray() && !var->isPointer())
        return true;

    // ValueFlow
    if (var->isPointer() && !var->isArgument()) {
        for (auto it = tok->values().cbegin(); it != tok->values().cend(); ++it) {
            const ValueFlow::V...",1,1,lib/checkautovariables.cpp,isAutoVarArray:bool(Token*),<empty>,,false,106,144,isAutoVarArray,,,1,bool(Token*)
111669151176,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"static bool isLocalContainerBuffer(const Token* tok)
{
    if (!tok)
        return false;

    // x+y
    if (tok->str() == ""+"")
        return isLocalContainerBuffer(tok->astOperand1()) || isLocalContainerBuffer(tok->astOperand2());

    if (tok->str() != ""("" || !Token::simpleMatch(tok->astOperand1(), "".""))
        return false;

    tok = tok->astOperand1()->astOperand1();

    const Variable* var = tok->variable();
    if (!var || !var->isLocal() || var->isStatic())
        return false;

    const Library::Container::Yield yield = astContainerYield(tok);

    return yield == Library::Container::Yield::BUFFER || yield == Library::Container::Yield::BUFFER_NT;
}",1,1,lib/checkautovariables.cpp,isLocalContainerBuffer:bool(Token*),<empty>,,false,146,167,isLocalContainerBuffer,,,1,bool(Token*)
111669151177,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"static bool isAddressOfLocalVariable(const Token *expr)
{
    if (!expr)
        return false;
    if (Token::Match(expr, ""+|-""))
        return isAddressOfLocalVariable(expr->astOperand1()) || isAddressOfLocalVariable(expr->astOperand2());
    if (expr->isCast())
        return isAddressOfLocalVariable(expr->astOperand2() ? expr->astOperand2() : expr->astOperand1());
    if (expr->isUnaryOp(""&"")) {
        const Token *op = expr->astOperand1();
        bool deref = false;
        while (Token::Match(op, "".|["")) {
            if (op->originalName() == ""->"")
                return false;
            if (op->str() == ""["")
                deref = true;
            op = op->astOperand1();
        }
        return op && isAutoVar(op) && (!deref || !op->variable()->isPointer());
    }
    return false;
}",1,1,lib/checkautovariables.cpp,isAddressOfLocalVariable:bool(Token*),<empty>,,false,169,190,isAddressOfLocalVariable,,,1,bool(Token*)
111669151178,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"static bool variableIsUsedInScope(const Token* start, nonneg int varId, const Scope *scope)
{
    if (!start) // Ticket #5024
        return false;

    for (const Token *tok = start; tok && tok != scope->bodyEnd; tok = tok->next()) {
        if (tok->varId() == varId)
            return true;
        const ScopeType scopeType = tok->scope()->type;
        if (scopeType == ScopeType::eFor || scopeType == ScopeType::eDo || scopeType == ScopeType::eWhile) // In case of loops, better checking would be necessary
            return true;
        if (Token::simpleMatch(tok, ""asm (""))
            return true;
    }
    return false;
}",1,54,lib/checkautovariables.cpp,"variableIsUsedInScope:bool(Token*,int,Scope*)",<empty>,,false,192,207,variableIsUsedInScope,,,1,"bool(Token*,int,Scope*)"
111669151179,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"void CheckAutoVariables::assignFunctionArg()
{
    const bool printStyle = mSettings->severity.isEnabled(Severity::style);
    const bool printWarning = mSettings->severity.isEnabled(Severity::warning);
    if (!printStyle && !printWarning && !mSettings->isPremiumEnabled(""uselessAssignmentPtrArg""))
        return;

    logChecker(""CheckAutoVariables::assignFunctionArg""); // style,warning

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token *tok = scope->bodyStart; tok && tok != scope->bodyEnd; tok = tok->next()) {
            // TODO: What happens if this is removed?
            if (tok->astParent())
                continue;
            if (!(tok->isAssignmentOp() || tok->tokType() == Token::eIncDecOp) || !Token::Match(tok->astOperand1(), ""%var%""))
                continue;
            const Token* const vartok = tok->astOperand1();
            if (isNonReferenceArg(var...",1,1,lib/checkautovariables.cpp,CheckAutoVariables.assignFunctionArg:void(),<empty>,,false,209,238,assignFunctionArg,,,1,void()
111669151180,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"static bool isAutoVariableRHS(const Token* tok) {
    return isAddressOfLocalVariable(tok) || isAutoVarArray(tok) || isLocalContainerBuffer(tok);
}",1,1,lib/checkautovariables.cpp,isAutoVariableRHS:bool(Token*),<empty>,,false,240,242,isAutoVariableRHS,,,1,bool(Token*)
111669151181,METHOD,<empty>,<empty>,"[](const Function& f) { // TODO: compare argument type
                return f.name() == ""operator="";
            }",104,13,lib/checkautovariables.cpp,lib/checkautovariables.cpp:<global>.hasOverloadedAssignment.<lambda>0:bool(Function&),<empty>,,false,255,257,<lambda>0,,,1,bool(Function&)
111669151182,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"static bool hasOverloadedAssignment(const Token* tok, bool& inconclusive)
{
    inconclusive = false;
    if (tok->isC())
        return false;
    if (const ValueType* vt = tok->valueType()) {
        if (vt->pointer && !Token::simpleMatch(tok->astParent(), ""*""))
            return false;
        if (vt->container && vt->container->stdStringLike)
            return true;
        if (vt->typeScope)
            return std::any_of(vt->typeScope->functionList.begin(), vt->typeScope->functionList.end(), [](const Function& f) { // TODO: compare argument type
                return f.name() == ""operator="";
            });
        return false;
    }
    inconclusive = true;
    return true;
}",1,1,lib/checkautovariables.cpp,"hasOverloadedAssignment:bool(Token*,bool&)",<empty>,,false,244,262,hasOverloadedAssignment,,,1,"bool(Token*,bool&)"
111669151183,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"void CheckAutoVariables::autoVariables()
{
    logChecker(""CheckAutoVariables::autoVariables"");

    const bool printInconclusive = mSettings->certainty.isEnabled(Certainty::inconclusive);
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token *tok = scope->bodyStart; tok && tok != scope->bodyEnd; tok = tok->next()) {
            // Skip lambda..
            if (const Token *lambdaEndToken = findLambdaEndToken(tok)) {
                tok = lambdaEndToken;
                continue;
            }
            // Critical assignment
            if (Token::Match(tok, ""[;{}] %var% ="") && isRefPtrArg(tok->next()) && isAutoVariableRHS(tok->tokAt(2)->astOperand2())) {
                checkAutoVariableAssignment(tok->next(), false);
            } else if (Token::Match(tok, ""[;{}] * %var% ="") && isPtrArg(tok->tokAt(2)) && isAutoVariableRHS(tok->tokAt(3)->astOperand2())) {
            ...",1,1,lib/checkautovariables.cpp,CheckAutoVariables.autoVariables:void(),<empty>,,false,264,324,autoVariables,,,1,void()
111669151184,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"bool CheckAutoVariables::checkAutoVariableAssignment(const Token *expr, bool inconclusive, const Token *startToken)
{
    if (!startToken)
        startToken = Token::findsimplematch(expr, ""="")->next();
    for (const Token *tok = startToken; tok; tok = tok->next()) {
        if (tok->str() == ""}"" && tok->scope()->type == ScopeType::eFunction)
            errorAutoVariableAssignment(expr, inconclusive);

        if (Token::Match(tok, ""return|throw|break|continue"")) {
            errorAutoVariableAssignment(expr, inconclusive);
            return true;
        }
        if (Token::simpleMatch(tok, ""="")) {
            const Token *lhs = tok;
            while (Token::Match(lhs->previous(), ""%name%|.|*|]"")) {
                if (lhs->linkAt(-1))
                    lhs = lhs->linkAt(-1);
                else
                    lhs = lhs->previous();
            }
            const Token *e = expr;
            while (e->str() != ""="" && lhs->str() == e->str()) {
                e = e->n...",1,1,lib/checkautovariables.cpp,"CheckAutoVariables.checkAutoVariableAssignment:bool(Token*,bool,Token*)",<empty>,,false,326,363,checkAutoVariableAssignment,,,1,"bool(Token*,bool,Token*)"
111669151185,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"void CheckAutoVariables::errorAutoVariableAssignment(const Token *tok, bool inconclusive)
{
    if (!inconclusive) {
        reportError(tok, Severity::error, ""autoVariables"",
                    ""Address of local auto-variable assigned to a function parameter.\\n""
                    ""Dangerous assignment - the function parameter is assigned the address of a local ""
                    ""auto-variable. Local auto-variables are reserved from the stack which ""
                    ""is freed when the function ends. So the pointer to a local variable ""
                    ""is invalid after the function ends."", CWE562, Certainty::normal);
    } else {
        reportError(tok, Severity::error, ""autoVariables"",
                    ""Address of local auto-variable assigned to a function parameter.\\n""
                    ""Function parameter is assigned the address of a local auto-variable. ""
                    ""Local auto-variables are reserved from the stack which is freed when ""
            ...",1,1,lib/checkautovariables.cpp,"CheckAutoVariables.errorAutoVariableAssignment:void(Token*,bool)",<empty>,,false,367,386,errorAutoVariableAssignment,,,1,"void(Token*,bool)"
111669151186,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"void CheckAutoVariables::errorUselessAssignmentArg(const Token *tok)
{
    reportError(tok,
                Severity::style,
                ""uselessAssignmentArg"",
                ""Assignment of function parameter has no effect outside the function."", CWE398, Certainty::normal);
}",1,1,lib/checkautovariables.cpp,CheckAutoVariables.errorUselessAssignmentArg:void(Token*),<empty>,,false,388,394,errorUselessAssignmentArg,,,1,void(Token*)
111669151187,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"void CheckAutoVariables::errorUselessAssignmentPtrArg(const Token *tok)
{
    reportError(tok,
                Severity::warning,
                ""uselessAssignmentPtrArg"",
                ""Assignment of function parameter has no effect outside the function. Did you forget dereferencing it?"", CWE398, Certainty::normal);
}",1,1,lib/checkautovariables.cpp,CheckAutoVariables.errorUselessAssignmentPtrArg:void(Token*),<empty>,,false,396,402,errorUselessAssignmentPtrArg,,,1,void(Token*)
111669151188,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"bool CheckAutoVariables::diag(const Token* tokvalue)
{
    if (!tokvalue)
        return true;
    return !mDiagDanglingTemp.insert(tokvalue).second;
}",1,1,lib/checkautovariables.cpp,CheckAutoVariables.diag:bool(Token*),<empty>,,false,404,409,diag,,,1,bool(Token*)
111669151189,METHOD,<empty>,<empty>,"[&](const Scope* argScope) {
            return argScope && argScope->isNestedIn(scope);
        }",85,9,lib/checkautovariables.cpp,lib/checkautovariables.cpp:<global>.isInScope.<lambda>1:bool(Scope*),<empty>,,false,430,432,<lambda>1,,,1,bool(Scope*)
111669151190,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"static bool isInScope(const Token * tok, const Scope * scope)
{
    if (!tok)
        return false;
    if (!scope)
        return false;
    const Variable * var = tok->variable();
    if (var && (var->isGlobal() || var->isStatic() || var->isExtern()))
        return false;
    if (tok->scope() && !tok->scope()->isClassOrStructOrUnion() && tok->scope()->isNestedIn(scope))
        return true;
    if (!var)
        return false;
    if (var->isArgument() && !var->isReference()) {
        const Scope * tokScope = tok->scope();
        if (!tokScope)
            return false;
        if (std::any_of(tokScope->nestedList.cbegin(), tokScope->nestedList.cend(), [&](const Scope* argScope) {
            return argScope && argScope->isNestedIn(scope);
        }))
            return true;
    }
    return false;
}",1,1,lib/checkautovariables.cpp,"isInScope:bool(Token*,Scope*)",<empty>,,false,413,436,isInScope,,,1,"bool(Token*,Scope*)"
111669151191,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"static bool isDeadScope(const Token * tok, const Scope * scope)
{
    if (!tok)
        return false;
    if (!scope)
        return false;
    const Variable * var = tok->variable();
    if (var && (!var->isLocal() || var->isStatic() || var->isExtern()))
        return false;
    if (tok->scope() && tok->scope()->bodyEnd != scope->bodyEnd && precedes(tok->scope()->bodyEnd, scope->bodyEnd))
        return true;
    return false;
}",1,1,lib/checkautovariables.cpp,"isDeadScope:bool(Token*,Scope*)",<empty>,,false,438,450,isDeadScope,,,1,"bool(Token*,Scope*)"
111669151192,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"static int getPointerDepth(const Token *tok)
{
    if (!tok)
        return 0;
    if (tok->valueType())
        return tok->valueType()->pointer;
    int n = 0;
    std::pair<const Token*, const Token*> decl = Token::typeDecl(tok);
    for (const Token* tok2 = decl.first; tok2 != decl.second; tok2 = tok2->next())
        if (Token::simpleMatch(tok2, ""*""))
            n++;
    return n;
}",1,1,lib/checkautovariables.cpp,getPointerDepth:int(Token*),<empty>,,false,452,464,getPointerDepth,,,1,int(Token*)
111669151193,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"static bool isDeadTemporary(const Token* tok, const Token* expr, const Library* library)
{
    if (!isTemporary(tok, library))
        return false;
    if (expr) {
        if (!precedes(nextAfterAstRightmostLeaf(tok->astTop()), nextAfterAstRightmostLeaf(expr->astTop())))
            return false;
        const Token* parent = tok->astParent();
        if (Token::simpleMatch(parent, ""{"") && Token::simpleMatch(parent->astParent(), "":""))
            parent = parent->astParent();
        // Is in a for loop
        if (astIsRHS(tok) && Token::simpleMatch(parent, "":"") && Token::simpleMatch(parent->astParent(), ""("") && Token::simpleMatch(parent->astParent()->previous(), ""for ("")) {
            const Token* braces = parent->astParent()->link()->next();
            if (precedes(braces, expr) && precedes(expr, braces->link()))
                return false;
        }
    }
    return true;
}",1,1,lib/checkautovariables.cpp,"isDeadTemporary:bool(Token*,Token*,Library*)",<empty>,,false,466,484,isDeadTemporary,,,1,"bool(Token*,Token*,Library*)"
111669151194,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"static bool isEscapedReference(const Variable* var)
{
    if (!var)
        return false;
    if (!var->isReference())
        return false;
    const Token * const varDeclEndToken = var->declEndToken();
    if (!varDeclEndToken)
        return false;
    if (!Token::simpleMatch(varDeclEndToken, ""=""))
        return false;
    const Token* vartok = varDeclEndToken->astOperand2();
    return !isTemporary(vartok, nullptr, false);
}",1,1,lib/checkautovariables.cpp,isEscapedReference:bool(Variable*),<empty>,,false,486,499,isEscapedReference,,,1,bool(Variable*)
111669151195,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"static bool isDanglingSubFunction(const Token* tokvalue, const Token* tok)
{
    if (!tokvalue)
        return false;
    const Variable* var = tokvalue->variable();
    if (!var->isLocal())
        return false;
    const Function* f = Scope::nestedInFunction(tok->scope());
    if (!f)
        return false;
    const Token* parent = tokvalue->astParent();
    while (parent && !Token::Match(parent->previous(), ""%name% ("")) {
        parent = parent->astParent();
    }
    if (!Token::simpleMatch(parent, ""(""))
        return false;
    return exprDependsOnThis(parent);
}",1,1,lib/checkautovariables.cpp,"isDanglingSubFunction:bool(Token*,Token*)",<empty>,,false,501,518,isDanglingSubFunction,,,1,"bool(Token*,Token*)"
111669151196,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"static const Variable* getParentVar(const Token* tok)
{
    if (!tok)
        return nullptr;
    if (Token::simpleMatch(tok, "".""))
        return getParentVar(tok->astOperand1());
    return tok->variable();
}",1,1,lib/checkautovariables.cpp,getParentVar:Variable*(Token*),<empty>,,false,520,527,getParentVar,,,1,Variable*(Token*)
111669151197,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"static bool isAssignedToNonLocal(const Token* tok)
{
    if (!Token::simpleMatch(tok->astParent(), ""=""))
        return false;
    if (!astIsRHS(tok))
        return false;
    const Variable* var = getParentVar(tok->astParent()->astOperand1());
    if (!var)
        return false;
    return !var->isLocal() || var->isStatic();
}",1,1,lib/checkautovariables.cpp,isAssignedToNonLocal:bool(Token*),<empty>,,false,529,539,isAssignedToNonLocal,,,1,bool(Token*)
111669151198,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"void CheckAutoVariables::checkVarLifetimeScope(const Token * start, const Token * end)
{
    const bool printInconclusive = mSettings->certainty.isEnabled(Certainty::inconclusive);
    if (!start)
        return;
    const Scope * scope = start->scope();
    if (!scope)
        return;
    // If the scope is not set correctly then skip checking it
    if (scope->bodyStart != start)
        return;
    const bool returnRef = Function::returnsReference(scope->function);
    for (const Token *tok = start; tok && tok != end; tok = tok->next()) {
        // Return reference from function
        if (returnRef && Token::simpleMatch(tok->astParent(), ""return"")) {
            for (const ValueFlow::LifetimeToken& lt : ValueFlow::getLifetimeTokens(tok, *mSettings, true)) {
                if (!printInconclusive && lt.inconclusive)
                    continue;
                const Variable* var = lt.token->variable();
                if (var && !var->isGlobal() && !var->isStatic() && !var->i...",1,1,lib/checkautovariables.cpp,"CheckAutoVariables.checkVarLifetimeScope:void(Token*,Token*)",<empty>,,false,541,679,checkVarLifetimeScope,,,1,"void(Token*,Token*)"
111669151199,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"void CheckAutoVariables::checkVarLifetime()
{
    logChecker(""CheckAutoVariables::checkVarLifetime"");
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        if (!scope->function)
            continue;
        checkVarLifetimeScope(scope->bodyStart, scope->bodyEnd);
    }
}",1,1,lib/checkautovariables.cpp,CheckAutoVariables.checkVarLifetime:void(),<empty>,,false,681,690,checkVarLifetime,,,1,void()
111669151200,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"void CheckAutoVariables::errorReturnDanglingLifetime(const Token *tok, const ValueFlow::Value *val)
{
    const bool inconclusive = val ? val->isInconclusive() : false;
    ErrorPath errorPath = val ? val->errorPath : ErrorPath();
    std::string msg = ""Returning "" + lifetimeMessage(tok, val, errorPath);
    errorPath.emplace_back(tok, """");
    reportError(errorPath, Severity::error, ""returnDanglingLifetime"", msg + "" that will be invalid when returning."", CWE562, inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checkautovariables.cpp,"CheckAutoVariables.errorReturnDanglingLifetime:void(Token*,ValueFlow.Value*)",<empty>,,false,692,699,errorReturnDanglingLifetime,,,1,"void(Token*,ValueFlow.Value*)"
111669151201,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"void CheckAutoVariables::errorInvalidLifetime(const Token *tok, const ValueFlow::Value* val)
{
    const bool inconclusive = val ? val->isInconclusive() : false;
    ErrorPath errorPath = val ? val->errorPath : ErrorPath();
    std::string msg = ""Using "" + lifetimeMessage(tok, val, errorPath);
    errorPath.emplace_back(tok, """");
    reportError(errorPath, Severity::error, ""invalidLifetime"", msg + "" that is out of scope."", CWE562, inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checkautovariables.cpp,"CheckAutoVariables.errorInvalidLifetime:void(Token*,ValueFlow.Value*)",<empty>,,false,701,708,errorInvalidLifetime,,,1,"void(Token*,ValueFlow.Value*)"
111669151202,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"void CheckAutoVariables::errorDanglingTemporaryLifetime(const Token* tok, const ValueFlow::Value* val, const Token* tempTok)
{
    const bool inconclusive = val ? val->isInconclusive() : false;
    ErrorPath errorPath = val ? val->errorPath : ErrorPath();
    std::string msg = ""Using "" + lifetimeMessage(tok, val, errorPath);
    errorPath.emplace_back(tempTok, ""Temporary created here."");
    errorPath.emplace_back(tok, """");
    reportError(errorPath,
                Severity::error,
                ""danglingTemporaryLifetime"",
                msg + "" that is a temporary."",
                CWE562,
                inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checkautovariables.cpp,"CheckAutoVariables.errorDanglingTemporaryLifetime:void(Token*,ValueFlow.Value*,Token*)",<empty>,,false,710,723,errorDanglingTemporaryLifetime,,,1,"void(Token*,ValueFlow.Value*,Token*)"
111669151203,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"void CheckAutoVariables::errorDanglngLifetime(const Token *tok, const ValueFlow::Value *val, bool isStatic)
{
    const bool inconclusive = val ? val->isInconclusive() : false;
    ErrorPath errorPath = val ? val->errorPath : ErrorPath();
    std::string tokName = tok ? tok->expressionString() : ""x"";
    std::string msg = isStatic ? ""Static"" : ""Non-local"";
    msg += "" variable '"" + tokName + ""' will use "" + lifetimeMessage(tok, val, errorPath);
    errorPath.emplace_back(tok, """");
    reportError(errorPath, Severity::error, ""danglingLifetime"", msg + ""."", CWE562, inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checkautovariables.cpp,"CheckAutoVariables.errorDanglngLifetime:void(Token*,ValueFlow.Value*,bool)",<empty>,,false,725,734,errorDanglngLifetime,,,1,"void(Token*,ValueFlow.Value*,bool)"
111669151204,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"void CheckAutoVariables::errorDanglingTempReference(const Token* tok, ErrorPath errorPath, bool inconclusive)
{
    errorPath.emplace_back(tok, """");
    reportError(
        errorPath, Severity::error, ""danglingTempReference"", ""Using reference to dangling temporary."", CWE562, inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checkautovariables.cpp,"CheckAutoVariables.errorDanglingTempReference:void(Token*,ErrorPath,bool)",<empty>,,false,736,741,errorDanglingTempReference,,,1,"void(Token*,ErrorPath,bool)"
111669151205,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"void CheckAutoVariables::errorReturnReference(const Token* tok, ErrorPath errorPath, bool inconclusive)
{
    errorPath.emplace_back(tok, """");
    reportError(
        errorPath, Severity::error, ""returnReference"", ""Reference to local variable returned."", CWE562, inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checkautovariables.cpp,"CheckAutoVariables.errorReturnReference:void(Token*,ErrorPath,bool)",<empty>,,false,743,748,errorReturnReference,,,1,"void(Token*,ErrorPath,bool)"
111669151206,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"void CheckAutoVariables::errorDanglingReference(const Token *tok, const Variable *var, ErrorPath errorPath)
{
    std::string tokName = tok ? tok->str() : ""x"";
    std::string varName = var ? var->name() : ""y"";
    std::string msg = ""Non-local reference variable '"" + tokName + ""' to local variable '"" + varName + ""'"";
    errorPath.emplace_back(tok, """");
    reportError(errorPath, Severity::error, ""danglingReference"", msg, CWE562, Certainty::normal);
}",1,1,lib/checkautovariables.cpp,"CheckAutoVariables.errorDanglingReference:void(Token*,Variable*,ErrorPath)",<empty>,,false,750,757,errorDanglingReference,,,1,"void(Token*,Variable*,ErrorPath)"
111669151207,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"void CheckAutoVariables::errorReturnTempReference(const Token* tok, ErrorPath errorPath, bool inconclusive)
{
    errorPath.emplace_back(tok, """");
    reportError(
        errorPath, Severity::error, ""returnTempReference"", ""Reference to temporary returned."", CWE562, inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checkautovariables.cpp,"CheckAutoVariables.errorReturnTempReference:void(Token*,ErrorPath,bool)",<empty>,,false,759,764,errorReturnTempReference,,,1,"void(Token*,ErrorPath,bool)"
111669151208,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"void CheckAutoVariables::errorInvalidDeallocation(const Token *tok, const ValueFlow::Value *val)
{
    const Variable *var = val ? val->tokvalue->variable() : (tok ? tok->variable() : nullptr);

    std::string type = ""an auto-variable"";
    if (tok && tok->tokType() == Token::eString)
        type = ""a string literal"";
    else if (val && val->tokvalue->tokType() == Token::eString)
        type = ""a pointer pointing to a string literal"";
    else if (var) {
        if (var->isGlobal())
            type = ""a global variable"";
        else if (var->isStatic())
            type = ""a static variable"";
    }

    if (val)
        type += "" ("" + val->tokvalue->str() + "")"";

    reportError(getErrorPath(tok, val, ""Deallocating memory that was not dynamically allocated""),
                Severity::error,
                ""autovarInvalidDeallocation"",
                ""Deallocation of "" + type + "" results in undefined behaviour.\\n""
                ""The deallocation of "" + type + "" results in ...",1,1,lib/checkautovariables.cpp,"CheckAutoVariables.errorInvalidDeallocation:void(Token*,ValueFlow.Value*)",<empty>,,false,766,791,errorInvalidDeallocation,,,1,"void(Token*,ValueFlow.Value*)"
111669151209,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"void CheckAutoVariables::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    CheckAutoVariables checkAutoVariables(&tokenizer, &tokenizer.getSettings(), errorLogger);
    checkAutoVariables.assignFunctionArg();
    checkAutoVariables.checkVarLifetime();
    checkAutoVariables.autoVariables();
}",1,1,lib/checkautovariables.cpp,"CheckAutoVariables.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,793,799,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669151210,METHOD,lib/checkautovariables.cpp:<global>,TYPE_DECL,"void CheckAutoVariables::getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const
{
    CheckAutoVariables c(nullptr,settings,errorLogger);
    c.errorAutoVariableAssignment(nullptr, false);
    c.errorReturnReference(nullptr, ErrorPath{}, false);
    c.errorDanglingReference(nullptr, nullptr, ErrorPath{});
    c.errorReturnTempReference(nullptr, ErrorPath{}, false);
    c.errorDanglingTempReference(nullptr, ErrorPath{}, false);
    c.errorInvalidDeallocation(nullptr, nullptr);
    c.errorUselessAssignmentArg(nullptr);
    c.errorUselessAssignmentPtrArg(nullptr);
    c.errorReturnDanglingLifetime(nullptr, nullptr);
    c.errorInvalidLifetime(nullptr, nullptr);
    c.errorDanglngLifetime(nullptr, nullptr);
    c.errorDanglingTemporaryLifetime(nullptr, nullptr, nullptr);
}",1,1,lib/checkautovariables.cpp,"CheckAutoVariables.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,801,816,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669151211,METHOD,lib/checkautovariables.h:<global>,TYPE_DECL,<global>,1,1,lib/checkautovariables.h,lib/checkautovariables.h:<global>,<empty>,,false,1,112,<global>,,,1,
111669151212,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"static bool isBool(const Variable* var)
{
    return (var && Token::Match(var->typeEndToken(), ""bool|_Bool""));
}",1,1,lib/checkbool.cpp,isBool:bool(Variable*),<empty>,,false,45,48,isBool,,,1,bool(Variable*)
111669151213,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,<global>,1,78,lib/checkbool.cpp,lib/checkbool.cpp:<global>,<empty>,,false,1,552,<global>,,,1,
111669151214,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::checkIncrementBoolean()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""incrementboolean""))
        return;

    logChecker(""CheckBool::checkIncrementBoolean""); // style

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (astIsBool(tok) && tok->astParent() && tok->astParent()->str() == ""++"") {
                incrementBooleanError(tok);
            }
        }
    }
}",1,1,lib/checkbool.cpp,CheckBool.checkIncrementBoolean:void(),<empty>,,false,51,66,checkIncrementBoolean,,,1,void()
111669151215,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::incrementBooleanError(const Token *tok)
{
    reportError(
        tok,
        Severity::style,
        ""incrementboolean"",
        ""Incrementing a variable of type 'bool' with postfix operator++ is deprecated by the C++ Standard. You should assign it the value 'true' instead.\\n""
        ""The operand of a postfix increment operator may be of type bool but it is deprecated by C++ Standard (Annex D-1) and the operand is always set to true. You should assign it the value 'true' instead."",
        CWE398, Certainty::normal
        );
}",1,1,lib/checkbool.cpp,CheckBool.incrementBooleanError:void(Token*),<empty>,,false,68,78,incrementBooleanError,,,1,void(Token*)
111669151216,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"static bool isConvertedToBool(const Token* tok)
{
    if (!tok->astParent())
        return false;
    return astIsBool(tok->astParent()) || Token::Match(tok->astParent()->previous(), ""if|while ("");
}",1,1,lib/checkbool.cpp,isConvertedToBool:bool(Token*),<empty>,,false,80,85,isConvertedToBool,,,1,bool(Token*)
111669151217,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::checkBitwiseOnBoolean()
{
    if (!mSettings->severity.isEnabled(Severity::style))
        return;

    // danmar: this is inconclusive because I don't like that there are
    //         warnings for calculations. Example: set_flag(a & b);
    if (!mSettings->certainty.isEnabled(Certainty::inconclusive))
        return;

    logChecker(""CheckBool::checkBitwiseOnBoolean""); // style,inconclusive

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (tok->isBinaryOp()) {
                bool isCompound{};
                if (tok->str() == ""&"" || tok->str() == ""|"")
                    isCompound = false;
                else if (tok->str() == ""&="" || tok->str() == ""|="")
                    isCompound = true;
                else
                    continue;
           ...",1,1,lib/checkbool.cpp,CheckBool.checkBitwiseOnBoolean:void(),<empty>,,false,91,134,checkBitwiseOnBoolean,,,1,void()
111669151218,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::bitwiseOnBooleanError(const Token* tok, const std::string& expression, const std::string& op, bool isCompound)
{
    std::string msg = ""Boolean expression '"" + expression + ""' is used in bitwise operation."";
    if (!isCompound)
        msg += "" Did you mean '"" + op + ""'?"";
    reportError(tok,
                Severity::style,
                ""bitwiseOnBoolean"",
                msg,
                CWE398,
                Certainty::inconclusive);
}",1,1,lib/checkbool.cpp,"CheckBool.bitwiseOnBooleanError:void(Token*,std.string&,std.string&,bool)",<empty>,,false,136,147,bitwiseOnBooleanError,,,1,"void(Token*,std.string&,std.string&,bool)"
111669151219,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::checkComparisonOfBoolWithInt()
{
    if (!mSettings->severity.isEnabled(Severity::warning) || !mTokenizer->isCPP())
        return;

    logChecker(""CheckBool::checkComparisonOfBoolWithInt""); // warning,c++

    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!tok->isComparisonOp() || !tok->isBinaryOp())
                continue;
            const Token* const left = tok->astOperand1();
            const Token* const right = tok->astOperand2();
            if (left->isBoolean() && right->varId()) { // Comparing boolean constant with variable
                if (tok->str() != ""=="" && tok->str() != ""!="") {
                    comparisonOfBoolWithInvalidComparator(right, left->str());
                }
            } else if (left->varId() && right->isBoolean())...",1,1,lib/checkbool.cpp,CheckBool.checkComparisonOfBoolWithInt:void(),<empty>,,false,153,178,checkComparisonOfBoolWithInt,,,1,void()
111669151220,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::comparisonOfBoolWithInvalidComparator(const Token *tok, const std::string &expression)
{
    reportError(tok, Severity::warning, ""comparisonOfBoolWithInvalidComparator"",
                ""Comparison of a boolean value using relational operator (<, >, <= or >=).\\n""
                ""The result of the expression '"" + expression + ""' is of type 'bool'. ""
                ""Comparing 'bool' value using relational (<, >, <= or >=)""
                "" operator could cause unexpected results."");
}",1,1,lib/checkbool.cpp,"CheckBool.comparisonOfBoolWithInvalidComparator:void(Token*,std.string&)",<empty>,,false,180,187,comparisonOfBoolWithInvalidComparator,,,1,"void(Token*,std.string&)"
111669151221,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"static bool tokenIsFunctionReturningBool(const Token* tok)
{
    const Function* func = tok ? tok->function() : nullptr;
    if (func && Token::Match(tok, ""%name% ("")) {
        if (func->tokenDef && Token::Match(func->tokenDef->previous(), ""bool|_Bool"")) {
            return true;
        }
    }
    return false;
}",1,1,lib/checkbool.cpp,tokenIsFunctionReturningBool:bool(Token*),<empty>,,false,193,202,tokenIsFunctionReturningBool,,,1,bool(Token*)
111669151222,METHOD,<empty>,<empty>,"[](const Token* tok) -> const Token* {
        while (Token::simpleMatch(tok, ""!"") || (tok && tok->isCast() && !isCPPCast(tok)))
            tok = tok->astOperand1();
        if (isCPPCast(tok))
            tok = tok->astOperand2();
        if (tok)
            return tok->previous();
        return nullptr;
    }",27,5,lib/checkbool.cpp,lib/checkbool.cpp:<global>.CheckBool.checkComparisonOfFuncReturningBool.<lambda>0:Token(Token*),<empty>,,false,215,223,<lambda>0,,,1,Token(Token*)
111669151223,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::checkComparisonOfFuncReturningBool()
{
    if (!mSettings->severity.isEnabled(Severity::style))
        return;

    if (!mTokenizer->isCPP())
        return;

    logChecker(""CheckBool::checkComparisonOfFuncReturningBool""); // style,c++

    const SymbolDatabase * const symbolDatabase = mTokenizer->getSymbolDatabase();
    auto getFunctionTok = [](const Token* tok) -> const Token* {
        while (Token::simpleMatch(tok, ""!"") || (tok && tok->isCast() && !isCPPCast(tok)))
            tok = tok->astOperand1();
        if (isCPPCast(tok))
            tok = tok->astOperand2();
        if (tok)
            return tok->previous();
        return nullptr;
    };

    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!tok->isComparisonOp() || tok->str() == ""=="" || tok->str() == ""!="")
                continue;

            const Token* firstToken =...",1,1,lib/checkbool.cpp,CheckBool.checkComparisonOfFuncReturningBool:void(),<empty>,,false,204,246,checkComparisonOfFuncReturningBool,,,1,void()
111669151224,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::comparisonOfFuncReturningBoolError(const Token *tok, const std::string &expression)
{
    reportError(tok, Severity::style, ""comparisonOfFuncReturningBoolError"",
                ""Comparison of a function returning boolean value using relational (<, >, <= or >=) operator.\\n""
                ""The return type of function '"" + expression + ""' is 'bool' ""
                ""and result is of type 'bool'. Comparing 'bool' value using relational (<, >, <= or >=)""
                "" operator could cause unexpected results."", CWE398, Certainty::normal);
}",1,1,lib/checkbool.cpp,"CheckBool.comparisonOfFuncReturningBoolError:void(Token*,std.string&)",<empty>,,false,248,255,comparisonOfFuncReturningBoolError,,,1,"void(Token*,std.string&)"
111669151225,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::comparisonOfTwoFuncsReturningBoolError(const Token *tok, const std::string &expression1, const std::string &expression2)
{
    reportError(tok, Severity::style, ""comparisonOfTwoFuncsReturningBoolError"",
                ""Comparison of two functions returning boolean value using relational (<, >, <= or >=) operator.\\n""
                ""The return type of function '"" + expression1 + ""' and function '"" + expression2 + ""' is 'bool' ""
                ""and result is of type 'bool'. Comparing 'bool' value using relational (<, >, <= or >=)""
                "" operator could cause unexpected results."", CWE398, Certainty::normal);
}",1,1,lib/checkbool.cpp,"CheckBool.comparisonOfTwoFuncsReturningBoolError:void(Token*,std.string&,std.string&)",<empty>,,false,257,264,comparisonOfTwoFuncsReturningBoolError,,,1,"void(Token*,std.string&,std.string&)"
111669151226,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::checkComparisonOfBoolWithBool()
{
    if (!mSettings->severity.isEnabled(Severity::style))
        return;

    if (!mTokenizer->isCPP())
        return;

    logChecker(""CheckBool::checkComparisonOfBoolWithBool""); // style,c++

    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!tok->isComparisonOp() || tok->str() == ""=="" || tok->str() == ""!="")
                continue;
            bool firstTokenBool = false;

            const Token *firstToken = tok->previous();
            if (firstToken->varId()) {
                if (isBool(firstToken->variable())) {
                    firstTokenBool = true;
                }
            }
            if (!firstTokenBool)
                continue;

            bool secondTokenBool = false;
            const Token *...",1,1,lib/checkbool.cpp,CheckBool.checkComparisonOfBoolWithBool:void(),<empty>,,false,270,309,checkComparisonOfBoolWithBool,,,1,void()
111669151227,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::comparisonOfBoolWithBoolError(const Token *tok, const std::string &expression)
{
    reportError(tok, Severity::style, ""comparisonOfBoolWithBoolError"",
                ""Comparison of a variable having boolean value using relational (<, >, <= or >=) operator.\\n""
                ""The variable '"" + expression + ""' is of type 'bool' ""
                ""and comparing 'bool' value using relational (<, >, <= or >=)""
                "" operator could cause unexpected results."", CWE398, Certainty::normal);
}",1,1,lib/checkbool.cpp,"CheckBool.comparisonOfBoolWithBoolError:void(Token*,std.string&)",<empty>,,false,311,318,comparisonOfBoolWithBoolError,,,1,"void(Token*,std.string&)"
111669151228,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::checkAssignBoolToPointer()
{
    logChecker(""CheckBool::checkAssignBoolToPointer"");
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
            if (tok->str() == ""="" && astIsPointer(tok->astOperand1()) && astIsBool(tok->astOperand2())) {
                assignBoolToPointerError(tok);
            }
        }
    }
}",1,1,lib/checkbool.cpp,CheckBool.checkAssignBoolToPointer:void(),<empty>,,false,321,332,checkAssignBoolToPointer,,,1,void()
111669151229,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::assignBoolToPointerError(const Token *tok)
{
    reportError(tok, Severity::error, ""assignBoolToPointer"",
                ""Boolean value assigned to pointer."", CWE587, Certainty::normal);
}",1,1,lib/checkbool.cpp,CheckBool.assignBoolToPointerError:void(Token*),<empty>,,false,334,338,assignBoolToPointerError,,,1,void(Token*)
111669151230,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::checkComparisonOfBoolExpressionWithInt()
{
    if (!mSettings->severity.isEnabled(Severity::warning) && !mSettings->isPremiumEnabled(""compareBoolExpressionWithInt""))
        return;

    logChecker(""CheckBool::checkComparisonOfBoolExpressionWithInt""); // warning

    const SymbolDatabase* symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!tok->isComparisonOp())
                continue;

            const Token* numTok = nullptr;
            const Token* boolExpr = nullptr;
            bool numInRhs;
            if (astIsBool(tok->astOperand1())) {
                boolExpr = tok->astOperand1();
                numTok = tok->astOperand2();
                numInRhs = true;
            } else if (astIsBool(tok->astOperand2())) {
                boolExpr = tok->astOperand2();
              ...",1,1,lib/checkbool.cpp,CheckBool.checkComparisonOfBoolExpressionWithInt:void(),<empty>,,false,342,400,checkComparisonOfBoolExpressionWithInt,,,1,void()
111669151231,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::comparisonOfBoolExpressionWithIntError(const Token *tok, bool not0or1)
{
    if (not0or1)
        reportError(tok, Severity::warning, ""compareBoolExpressionWithInt"",
                    ""Comparison of a boolean expression with an integer other than 0 or 1."", CWE398, Certainty::normal);
    else
        reportError(tok, Severity::warning, ""compareBoolExpressionWithInt"",
                    ""Comparison of a boolean expression with an integer."", CWE398, Certainty::normal);
}",1,1,lib/checkbool.cpp,"CheckBool.comparisonOfBoolExpressionWithIntError:void(Token*,bool)",<empty>,,false,402,410,comparisonOfBoolExpressionWithIntError,,,1,"void(Token*,bool)"
111669151232,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::pointerArithBool()
{
    logChecker(""CheckBool::pointerArithBool"");

    const SymbolDatabase* symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope &scope : symbolDatabase->scopeList) {
        if (scope.type != ScopeType::eIf && !scope.isLoopScope())
            continue;
        const Token* tok = scope.classDef->next()->astOperand2();
        if (scope.type == ScopeType::eFor) {
            tok = Token::findsimplematch(scope.classDef->tokAt(2), "";"");
            if (tok)
                tok = tok->astOperand2();
            if (tok)
                tok = tok->astOperand1();
        } else if (scope.type == ScopeType::eDo)
            tok = (scope.bodyEnd->tokAt(2)) ? scope.bodyEnd->tokAt(2)->astOperand2() : nullptr;

        pointerArithBoolCond(tok);
    }
}",1,1,lib/checkbool.cpp,CheckBool.pointerArithBool:void(),<empty>,,false,413,434,pointerArithBool,,,1,void()
111669151233,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::pointerArithBoolCond(const Token *tok)
{
    if (!tok)
        return;
    if (Token::Match(tok, ""&&|%oror%"")) {
        pointerArithBoolCond(tok->astOperand1());
        pointerArithBoolCond(tok->astOperand2());
        return;
    }
    if (tok->str() != ""+"" && tok->str() != ""-"")
        return;

    if (tok->isBinaryOp() &&
        tok->astOperand1()->isName() &&
        tok->astOperand1()->variable() &&
        tok->astOperand1()->variable()->isPointer() &&
        tok->astOperand2()->isNumber())
        pointerArithBoolError(tok);
}",1,1,lib/checkbool.cpp,CheckBool.pointerArithBoolCond:void(Token*),<empty>,,false,436,454,pointerArithBoolCond,,,1,void(Token*)
111669151234,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::pointerArithBoolError(const Token *tok)
{
    reportError(tok,
                Severity::error,
                ""pointerArithBool"",
                ""Converting pointer arithmetic result to bool. The bool is always true unless there is undefined behaviour.\\n""
                ""Converting pointer arithmetic result to bool. The boolean result is always true unless there is pointer arithmetic overflow, and overflow is undefined behaviour. Probably a dereference is forgotten."", CWE571, Certainty::normal);
}",1,1,lib/checkbool.cpp,CheckBool.pointerArithBoolError:void(Token*),<empty>,,false,456,463,pointerArithBoolError,,,1,void(Token*)
111669151235,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::checkAssignBoolToFloat()
{
    if (!mTokenizer->isCPP())
        return;
    if (!mSettings->severity.isEnabled(Severity::style))
        return;
    logChecker(""CheckBool::checkAssignBoolToFloat""); // style,c++
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
            if (tok->str() == ""="" && astIsFloat(tok->astOperand1(), false) && astIsBool(tok->astOperand2())) {
                assignBoolToFloatError(tok);
            }
        }
    }
}",1,1,lib/checkbool.cpp,CheckBool.checkAssignBoolToFloat:void(),<empty>,,false,465,480,checkAssignBoolToFloat,,,1,void()
111669151236,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::assignBoolToFloatError(const Token *tok)
{
    reportError(tok, Severity::style, ""assignBoolToFloat"",
                ""Boolean value assigned to floating point variable."", CWE704, Certainty::normal);
}",1,1,lib/checkbool.cpp,CheckBool.assignBoolToFloatError:void(Token*),<empty>,,false,482,486,assignBoolToFloatError,,,1,void(Token*)
111669151237,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::returnValueOfFunctionReturningBool()
{
    if (!mSettings->severity.isEnabled(Severity::style))
        return;

    logChecker(""CheckBool::returnValueOfFunctionReturningBool""); // style

    const SymbolDatabase * const symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope * scope : symbolDatabase->functionScopes) {
        if (!(scope->function && Token::Match(scope->function->retDef, ""bool|_Bool"")))
            continue;

        for (const Token* tok = scope->bodyStart->next(); tok && (tok != scope->bodyEnd); tok = tok->next()) {
            // Skip lambdas
            const Token* tok2 = findLambdaEndToken(tok);
            if (tok2)
                tok = tok2;
            else if (tok->scope() && tok->scope()->isClassOrStruct())
                tok = tok->scope()->bodyEnd;
            else if (Token::simpleMatch(tok, ""return"") && tok->astOperand1() &&
                     (tok->astOperand1()->getValueGE(2, *mSettings) || tok->astOperand1()->ge...",1,1,lib/checkbool.cpp,CheckBool.returnValueOfFunctionReturningBool:void(),<empty>,,false,488,514,returnValueOfFunctionReturningBool,,,1,void()
111669151238,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::returnValueBoolError(const Token *tok)
{
    reportError(tok, Severity::style, ""returnNonBoolInBooleanFunction"", ""Non-boolean value returned from function returning bool"");
}",1,1,lib/checkbool.cpp,CheckBool.returnValueBoolError:void(Token*),<empty>,,false,516,519,returnValueBoolError,,,1,void(Token*)
111669151239,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    CheckBool checkBool(&tokenizer, &tokenizer.getSettings(), errorLogger);

    // Checks
    checkBool.checkComparisonOfBoolExpressionWithInt();
    checkBool.checkComparisonOfBoolWithInt();
    checkBool.checkAssignBoolToFloat();
    checkBool.pointerArithBool();
    checkBool.returnValueOfFunctionReturningBool();
    checkBool.checkComparisonOfFuncReturningBool();
    checkBool.checkComparisonOfBoolWithBool();
    checkBool.checkIncrementBoolean();
    checkBool.checkAssignBoolToPointer();
    checkBool.checkBitwiseOnBoolean();
}",1,1,lib/checkbool.cpp,"CheckBool.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,521,536,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669151240,METHOD,lib/checkbool.cpp:<global>,TYPE_DECL,"void CheckBool::getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const
{
    CheckBool c(nullptr, settings, errorLogger);
    c.assignBoolToPointerError(nullptr);
    c.assignBoolToFloatError(nullptr);
    c.comparisonOfFuncReturningBoolError(nullptr, ""func_name"");
    c.comparisonOfTwoFuncsReturningBoolError(nullptr, ""func_name1"", ""func_name2"");
    c.comparisonOfBoolWithBoolError(nullptr, ""var_name"");
    c.incrementBooleanError(nullptr);
    c.bitwiseOnBooleanError(nullptr, ""expression"", ""&&"");
    c.comparisonOfBoolExpressionWithIntError(nullptr, true);
    c.pointerArithBoolError(nullptr);
    c.comparisonOfBoolWithInvalidComparator(nullptr, ""expression"");
    c.returnValueBoolError(nullptr);
}",1,1,lib/checkbool.cpp,"CheckBool.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,538,552,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669151241,METHOD,lib/checkbool.h:<global>,TYPE_DECL,<global>,1,1,lib/checkbool.h,lib/checkbool.h:<global>,<empty>,,false,1,118,<global>,,,1,
111669151242,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"static const ValueFlow::Value *getBufferSizeValue(const Token *tok)
{
    const std::list<ValueFlow::Value> &tokenValues = tok->values();
    const auto it = std::find_if(tokenValues.cbegin(), tokenValues.cend(), std::mem_fn(&ValueFlow::Value::isBufferSizeValue));
    return it == tokenValues.cend() ? nullptr : &*it;
}",1,1,lib/checkbufferoverrun.cpp,getBufferSizeValue:ValueFlow.Value*(Token*),<empty>,,false,71,76,getBufferSizeValue,,,1,ValueFlow.Value*(Token*)
111669151243,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,<global>,1,1,lib/checkbufferoverrun.cpp,lib/checkbufferoverrun.cpp:<global>,<empty>,,false,1,1238,<global>,,,1,
111669151244,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"static int getMinFormatStringOutputLength(const std::vector<const Token*> &parameters, nonneg int formatStringArgNr)
{
    if (formatStringArgNr <= 0 || formatStringArgNr > parameters.size())
        return 0;
    if (parameters[formatStringArgNr - 1]->tokType() != Token::eString)
        return 0;
    const std::string &formatString = parameters[formatStringArgNr - 1]->str();
    bool percentCharFound = false;
    int outputStringSize = 0;
    bool handleNextParameter = false;
    std::string digits_string;
    bool i_d_x_f_found = false;
    int parameterLength = 0;
    int inputArgNr = formatStringArgNr;
    for (std::size_t i = 1; i + 1 < formatString.length(); ++i) {
        if (formatString[i] == '\\\\') {
            if (i < formatString.length() - 1 && formatString[i + 1] == '0')
                break;

            ++outputStringSize;
            ++i;
            continue;
        }

        if (percentCharFound) {
            switch (formatString[i]) {
            case 'f':
 ...",1,87,lib/checkbufferoverrun.cpp,"getMinFormatStringOutputLength:int(std.vector<constToken*>&,int)",<empty>,,false,78,187,getMinFormatStringOutputLength,,,1,"int(std.vector<constToken*>&,int)"
111669151245,METHOD,<empty>,<empty>,"[&](const Token *child) {
                if (child->originalName() == ""->"") {
                    mightBeLarger = true;
                    return ChildrenToVisit::none;
                }
                return ChildrenToVisit::op1_and_op2;
            }",27,13,lib/checkbufferoverrun.cpp,lib/checkbufferoverrun.cpp:<global>.getDimensionsEtc.<lambda>0:ChildrenToVisit(Token*),<empty>,,false,201,207,<lambda>0,,,1,ChildrenToVisit(Token*)
111669151246,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"static bool getDimensionsEtc(const Token * const arrayToken, const Settings &settings, std::vector<Dimension> &dimensions, ErrorPath &errorPath, bool &mightBeLarger, MathLib::bigint &path)
{
    const Token *array = arrayToken;
    while (Token::Match(array, "".|::""))
        array = array->astOperand2();

    if (array->variable() && array->variable()->isArray() && !array->variable()->dimensions().empty()) {
        dimensions = array->variable()->dimensions();
        if (dimensions[0].num <= 1 || !dimensions[0].tok) {
            visitAstNodes(arrayToken,
                          [&](const Token *child) {
                if (child->originalName() == ""->"") {
                    mightBeLarger = true;
                    return ChildrenToVisit::none;
                }
                return ChildrenToVisit::op1_and_op2;
            });
        }
    } else if (const Token *stringLiteral = array->getValueTokenMinStrSize(settings, &path)) {
        Dimension dim;
        dim.tok = nul...",1,1,lib/checkbufferoverrun.cpp,"getDimensionsEtc:bool(Token*,Settings&,std.vector<Dimension>&,ErrorPath&,bool&,MathLib.bigint&)",<empty>,,false,191,231,getDimensionsEtc,,,1,"bool(Token*,Settings&,std.vector<Dimension>&,ErrorPath&,bool&,MathLib.bigint&)"
111669151247,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"static ValueFlow::Value makeSizeValue(MathLib::bigint size, MathLib::bigint path)
{
    ValueFlow::Value v(size);
    v.path = path;
    return v;
}",1,1,lib/checkbufferoverrun.cpp,"makeSizeValue:ValueFlow.Value(MathLib.bigint,MathLib.bigint)",<empty>,,false,233,238,makeSizeValue,,,1,"ValueFlow.Value(MathLib.bigint,MathLib.bigint)"
111669151248,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"static std::vector<ValueFlow::Value> getOverrunIndexValues(const Token* tok,
                                                           const Token* arrayToken,
                                                           const std::vector<Dimension>& dimensions,
                                                           const std::vector<const Token*>& indexTokens,
                                                           MathLib::bigint path)
{
    const Token *array = arrayToken;
    while (Token::Match(array, "".|::""))
        array = array->astOperand2();

    bool isArrayIndex = tok->str() == ""["";
    if (isArrayIndex) {
        const Token* parent = tok;
        while (Token::simpleMatch(parent, ""[""))
            parent = parent->astParent();
        if (!parent || parent->isUnaryOp(""&""))
            isArrayIndex = false;
    }

    bool overflow = false;
    std::vector<ValueFlow::Value> indexValues;
    for (std::size_t i = 0; i < dimensions.size() && i < indexTokens.size(); ...",1,1,lib/checkbufferoverrun.cpp,"getOverrunIndexValues:vector<ValueFlow.Value>(Token*,Token*,std.vector<Dimension>&,std.vector<constToken*>&,MathLib.bigint)",<empty>,,false,240,282,getOverrunIndexValues,,,1,"vector<ValueFlow::Value>(Token*,Token*,std.vector<Dimension>&,std.vector<constToken*>&,MathLib.bigint)"
111669151249,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"void CheckBufferOverrun::arrayIndex()
{
    logChecker(""CheckBufferOverrun::arrayIndex"");

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (tok->str() != ""["")
            continue;
        const Token *array = tok->astOperand1();
        while (Token::Match(array, "".|::""))
            array = array->astOperand2();
        if (!array || ((!array->variable() || array->variable()->nameToken() == array) && array->tokType() != Token::eString))
            continue;
        if (!array->scope()->isExecutable()) {
            // LHS in non-executable scope => This is just a definition
            const Token *parent = tok;
            while (parent && !Token::simpleMatch(parent->astParent(), ""=""))
                parent = parent->astParent();
            if (!parent || parent == parent->astParent()->astOperand1())
                continue;
        }

        if (astIsContainer(array))
            continue;

        std::vector<const Token *> indexToken...",1,1,lib/checkbufferoverrun.cpp,CheckBufferOverrun.arrayIndex:void(),<empty>,,false,284,365,arrayIndex,,,1,void()
111669151250,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"static std::string stringifyIndexes(const std::string& array, const std::vector<ValueFlow::Value>& indexValues)
{
    if (indexValues.size() == 1)
        return MathLib::toString(indexValues[0].intvalue);

    std::ostringstream ret;
    ret << array;
    for (const ValueFlow::Value& index : indexValues) {
        ret << ""["";
        if (index.isNonValue())
            ret << ""*"";
        else
            ret << index.intvalue;
        ret << ""]"";
    }
    return ret.str();
}",1,1,lib/checkbufferoverrun.cpp,"stringifyIndexes:string(std.string&,std.vector<ValueFlow.Value>&)",<empty>,,false,367,383,stringifyIndexes,,,1,"string(std.string&,std.vector<ValueFlow.Value>&)"
111669151251,METHOD,<empty>,<empty>,"[](const std::string &s, const Dimension &dim) {
        return s + ""["" + MathLib::toString(dim.num) + ""]"";
    }",20,5,lib/checkbufferoverrun.cpp,"lib/checkbufferoverrun.cpp:<global>.arrayIndexMessage.<lambda>1:ANY(std.string&,Dimension&)",<empty>,,false,390,392,<lambda>1,,,1,"ANY(std.string&,Dimension&)"
111669151252,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"static std::string arrayIndexMessage(const Token* tok,
                                     const std::vector<Dimension>& dimensions,
                                     const std::vector<ValueFlow::Value>& indexValues,
                                     const Token* condition)
{
    auto add_dim = [](const std::string &s, const Dimension &dim) {
        return s + ""["" + MathLib::toString(dim.num) + ""]"";
    };
    const std::string array = std::accumulate(dimensions.cbegin(), dimensions.cend(), tok->astOperand1()->expressionString(), std::move(add_dim));

    std::ostringstream errmsg;
    if (condition)
        errmsg << ValueFlow::eitherTheConditionIsRedundant(condition)
               << "" or the array '"" << array << ""' is accessed at index "" << stringifyIndexes(tok->astOperand1()->expressionString(), indexValues) << "", which is out of bounds."";
    else
        errmsg << ""Array '"" << array << ""' accessed at index "" << stringifyIndexes(tok->astOperand1()->expressionString(), ...",1,1,lib/checkbufferoverrun.cpp,"arrayIndexMessage:string(Token*,std.vector<Dimension>&,std.vector<ValueFlow.Value>&,Token*)",<empty>,,false,385,403,arrayIndexMessage,,,1,"string(Token*,std.vector<Dimension>&,std.vector<ValueFlow.Value>&,Token*)"
111669151253,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"void CheckBufferOverrun::arrayIndexError(const Token* tok,
                                         const std::vector<Dimension>& dimensions,
                                         const std::vector<ValueFlow::Value>& indexes)
{
    if (!tok) {
        reportError(tok, Severity::error, ""arrayIndexOutOfBounds"", ""Array 'arr[16]' accessed at index 16, which is out of bounds."", CWE_BUFFER_OVERRUN, Certainty::normal);
        reportError(tok, Severity::warning, ""arrayIndexOutOfBoundsCond"", ""Array 'arr[16]' accessed at index 16, which is out of bounds."", CWE_BUFFER_OVERRUN, Certainty::normal);
        return;
    }

    const Token *condition = nullptr;
    const ValueFlow::Value *index = nullptr;
    for (const ValueFlow::Value& indexValue : indexes) {
        if (!indexValue.errorSeverity() && !mSettings->severity.isEnabled(Severity::warning))
            return;
        if (indexValue.condition)
            condition = indexValue.condition;
        if (!index || !indexValue.errorPath...",1,1,lib/checkbufferoverrun.cpp,"CheckBufferOverrun.arrayIndexError:void(Token*,std.vector<Dimension>&,std.vector<ValueFlow.Value>&)",<empty>,,false,405,432,arrayIndexError,,,1,"void(Token*,std.vector<Dimension>&,std.vector<ValueFlow.Value>&)"
111669151254,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"void CheckBufferOverrun::negativeIndexError(const Token* tok,
                                            const std::vector<Dimension>& dimensions,
                                            const std::vector<ValueFlow::Value>& indexes)
{
    if (!tok) {
        reportError(tok, Severity::error, ""negativeIndex"", ""Negative array index"", CWE_BUFFER_UNDERRUN, Certainty::normal);
        return;
    }

    const Token *condition = nullptr;
    const ValueFlow::Value *negativeValue = nullptr;
    for (const ValueFlow::Value& indexValue : indexes) {
        if (!indexValue.errorSeverity() && !mSettings->severity.isEnabled(Severity::warning))
            return;
        if (indexValue.condition)
            condition = indexValue.condition;
        if (!negativeValue || !indexValue.errorPath.empty())
            negativeValue = &indexValue;
    }

    reportError(getErrorPath(tok, negativeValue, ""Negative array index""),
                negativeValue->errorSeverity() ? Severity::error : Se...",1,1,lib/checkbufferoverrun.cpp,"CheckBufferOverrun.negativeIndexError:void(Token*,std.vector<Dimension>&,std.vector<ValueFlow.Value>&)",<empty>,,false,434,460,negativeIndexError,,,1,"void(Token*,std.vector<Dimension>&,std.vector<ValueFlow.Value>&)"
111669151255,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"void CheckBufferOverrun::pointerArithmetic()
{
    if (!mSettings->severity.isEnabled(Severity::portability) && !mSettings->isPremiumEnabled(""pointerOutOfBounds""))
        return;

    logChecker(""CheckBufferOverrun::pointerArithmetic""); // portability

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (!Token::Match(tok, ""+|-""))
            continue;
        if (!tok->valueType() || tok->valueType()->pointer == 0)
            continue;
        if (!tok->isBinaryOp())
            continue;
        if (!tok->astOperand1()->valueType() || !tok->astOperand2()->valueType())
            continue;

        const Token *arrayToken, *indexToken;
        if (tok->astOperand1()->valueType()->pointer > 0) {
            arrayToken = tok->astOperand1();
            indexToken = tok->astOperand2();
        } else {
            arrayToken = tok->astOperand2();
            indexToken = tok->astOperand1();
        }

        if (!indexToken || !indexToken->valueT...",1,1,lib/checkbufferoverrun.cpp,CheckBufferOverrun.pointerArithmetic:void(),<empty>,,false,464,526,pointerArithmetic,,,1,void()
111669151256,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"void CheckBufferOverrun::pointerArithmeticError(const Token *tok, const Token *indexToken, const ValueFlow::Value *indexValue)
{
    if (!tok) {
        reportError(tok, Severity::portability, ""pointerOutOfBounds"", ""Pointer arithmetic overflow."", CWE_POINTER_ARITHMETIC_OVERFLOW, Certainty::normal);
        reportError(tok, Severity::portability, ""pointerOutOfBoundsCond"", ""Pointer arithmetic overflow."", CWE_POINTER_ARITHMETIC_OVERFLOW, Certainty::normal);
        return;
    }

    std::string errmsg;
    if (indexValue->condition)
        errmsg = ""Undefined behaviour, when '"" + indexToken->expressionString() + ""' is "" + MathLib::toString(indexValue->intvalue) + "" the pointer arithmetic '"" + tok->expressionString() + ""' is out of bounds."";
    else
        errmsg = ""Undefined behaviour, pointer arithmetic '"" + tok->expressionString() + ""' is out of bounds."";

    reportError(getErrorPath(tok, indexValue, ""Pointer arithmetic overflow""),
                Severity::portability,
        ...",1,1,lib/checkbufferoverrun.cpp,"CheckBufferOverrun.pointerArithmeticError:void(Token*,Token*,ValueFlow.Value*)",<empty>,,false,528,548,pointerArithmeticError,,,1,"void(Token*,Token*,ValueFlow.Value*)"
111669151257,METHOD,<empty>,<empty>,"[](MathLib::bigint i1, const Dimension &dim) {
        return i1 * dim.num;
    }",108,5,lib/checkbufferoverrun.cpp,"lib/checkbufferoverrun.cpp:<global>.CheckBufferOverrun.getBufferSize<const>.<lambda>2:longlongint(MathLib.bigint,Dimension&)",<empty>,,false,567,569,<lambda>2,,,1,"longlongint(MathLib.bigint,Dimension&)"
111669151258,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"ValueFlow::Value CheckBufferOverrun::getBufferSize(const Token *bufTok) const
{
    if (!bufTok->valueType())
        return ValueFlow::Value(-1);
    const Variable *var = bufTok->variable();

    if (!var || var->dimensions().empty()) {
        const ValueFlow::Value *value = getBufferSizeValue(bufTok);
        if (value)
            return *value;
    }

    if (!var || var->isPointer())
        return ValueFlow::Value(-1);

    const MathLib::bigint dim = std::accumulate(var->dimensions().cbegin(), var->dimensions().cend(), 1LL, [](MathLib::bigint i1, const Dimension &dim) {
        return i1 * dim.num;
    });

    ValueFlow::Value v;
    v.setKnown();
    v.valueType = ValueFlow::Value::ValueType::BUFFER_SIZE;

    if (var->isPointerArray())
        v.intvalue = dim * mSettings->platform.sizeof_pointer;
    else {
        const MathLib::bigint typeSize = bufTok->valueType()->typeSize(mSettings->platform);
        v.intvalue = dim * typeSize;
    }

    return v;
}",1,1,lib/checkbufferoverrun.cpp,CheckBufferOverrun.getBufferSize<const>:ValueFlow.Value(Token*),<empty>,,false,552,583,getBufferSize,,,1,ValueFlow.Value(Token*)
111669151259,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"static bool checkBufferSize(const Token *ftok, const Library::ArgumentChecks::MinSize &minsize, const std::vector<const Token *> &args, const MathLib::bigint bufferSize, const Settings &settings, const Tokenizer* tokenizer)
{
    const Token * const arg = (minsize.arg > 0 && minsize.arg - 1 < args.size()) ? args[minsize.arg - 1] : nullptr;
    const Token * const arg2 = (minsize.arg2 > 0 && minsize.arg2 - 1 < args.size()) ? args[minsize.arg2 - 1] : nullptr;

    switch (minsize.type) {
    case Library::ArgumentChecks::MinSize::Type::STRLEN:
        if (settings.library.isargformatstr(ftok, minsize.arg)) {
            return getMinFormatStringOutputLength(args, minsize.arg) < bufferSize;
        } else if (arg) {
            const Token *strtoken = arg->getValueTokenMaxStrLength();
            if (strtoken)
                return Token::getStrLength(strtoken) < bufferSize;
        }
        break;
    case Library::ArgumentChecks::MinSize::Type::ARGVALUE: {
        if (arg && arg->h...",1,1,lib/checkbufferoverrun.cpp,"checkBufferSize:bool(Token*,Library.ArgumentChecks.MinSize&,std.vector<constToken*>&,MathLib.bigint,Settings&,Tokenizer*)",<empty>,,false,586,629,checkBufferSize,,,1,"bool(Token*,Library.ArgumentChecks.MinSize&,std.vector<constToken*>&,MathLib.bigint,Settings&,Tokenizer*)"
111669151260,METHOD,<empty>,<empty>,"[&](const Library::ArgumentChecks::MinSize &minsize) {
                    return checkBufferSize(tok, minsize, args, bufferSize.intvalue, *mSettings, mTokenizer);
                }",85,17,lib/checkbufferoverrun.cpp,lib/checkbufferoverrun.cpp:<global>.CheckBufferOverrun.bufferOverflow.<lambda>3:bool(Library.ArgumentChecks.MinSize&),<empty>,,false,679,681,<lambda>3,,,1,bool(Library.ArgumentChecks.MinSize&)
111669151261,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"void CheckBufferOverrun::bufferOverflow()
{
    logChecker(""CheckBufferOverrun::bufferOverflow"");

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token *tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
            if (!Token::Match(tok, ""%name% ("") || Token::simpleMatch(tok, "") {""))
                continue;
            if (!mSettings->library.hasminsize(tok))
                continue;
            const std::vector<const Token *> args = getArguments(tok);
            for (int argnr = 0; argnr < args.size(); ++argnr) {
                if (!args[argnr]->valueType() || args[argnr]->valueType()->pointer == 0)
                    continue;
                const std::vector<Library::ArgumentChecks::MinSize> *minsizes = mSettings->library.argminsizes(tok, argnr + 1);
                if (!minsizes || minsizes->empty())
                    continue;
            ...",1,1,lib/checkbufferoverrun.cpp,CheckBufferOverrun.bufferOverflow:void(),<empty>,,false,632,687,bufferOverflow,,,1,void()
111669151262,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"void CheckBufferOverrun::bufferOverflowError(const Token *tok, const ValueFlow::Value *value, Certainty certainty)
{
    reportError(getErrorPath(tok, value, ""Buffer overrun""), Severity::error, ""bufferAccessOutOfBounds"", ""Buffer is accessed out of bounds: "" + (tok ? tok->expressionString() : ""buf""), CWE_BUFFER_OVERRUN, certainty);
}",1,1,lib/checkbufferoverrun.cpp,"CheckBufferOverrun.bufferOverflowError:void(Token*,ValueFlow.Value*,Certainty)",<empty>,,false,689,692,bufferOverflowError,,,1,"void(Token*,ValueFlow.Value*,Certainty)"
111669151263,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"void CheckBufferOverrun::arrayIndexThenCheck()
{
    if (!mSettings->severity.isEnabled(Severity::portability))
        return;

    logChecker(""CheckBufferOverrun::arrayIndexThenCheck"");

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * const scope : symbolDatabase->functionScopes) {
        for (const Token *tok = scope->bodyStart; tok && tok != scope->bodyEnd; tok = tok->next()) {
            if (Token::simpleMatch(tok, ""sizeof ("")) {
                tok = tok->linkAt(1);
                continue;
            }

            if (Token::Match(tok, ""%name% [ %var% ]"")) {
                tok = tok->next();

                const int indexID = tok->next()->varId();
                const std::string& indexName(tok->strAt(1));

                // Iterate AST upwards
                const Token* tok2 = tok;
                const Token* tok3 = tok2;
                while (tok2->astParent() && tok2->tokType() != Token::eLogicalOp && tok2->s...",1,1,lib/checkbufferoverrun.cpp,CheckBufferOverrun.arrayIndexThenCheck:void(),<empty>,,false,696,738,arrayIndexThenCheck,,,1,void()
111669151264,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"void CheckBufferOverrun::arrayIndexThenCheckError(const Token *tok, const std::string &indexName)
{
    reportError(tok, Severity::style, ""arrayIndexThenCheck"",
                ""$symbol:"" + indexName + ""\\n""
                ""Array index '$symbol' is used before limits check.\\n""
                ""Defensive programming: The variable '$symbol' is used as an array index before it ""
                ""is checked that is within limits. This can mean that the array might be accessed out of bounds. ""
                ""Reorder conditions such as '(a[i] && i < 10)' to '(i < 10 && a[i])'. That way the array will ""
                ""not be accessed if the index is out of limits."", CWE_ARRAY_INDEX_THEN_CHECK, Certainty::normal);
}",1,1,lib/checkbufferoverrun.cpp,"CheckBufferOverrun.arrayIndexThenCheckError:void(Token*,std.string&)",<empty>,,false,740,749,arrayIndexThenCheckError,,,1,"void(Token*,std.string&)"
111669151265,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& value) {
                    return value.isContainerSizeValue() && !value.isImpossible();
                }",80,17,lib/checkbufferoverrun.cpp,lib/checkbufferoverrun.cpp:<global>.CheckBufferOverrun.stringNotZeroTerminated.<lambda>4:bool(ValueFlow.Value&),<empty>,,false,777,779,<lambda>4,,,1,bool(ValueFlow.Value&)
111669151266,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"void CheckBufferOverrun::stringNotZeroTerminated()
{
    // this is currently 'inconclusive'. See TestBufferOverrun::terminateStrncpy3
    if (!mSettings->severity.isEnabled(Severity::warning) || !mSettings->certainty.isEnabled(Certainty::inconclusive))
        return;

    logChecker(""CheckBufferOverrun::stringNotZeroTerminated""); // warning,inconclusive

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * const scope : symbolDatabase->functionScopes) {
        for (const Token *tok = scope->bodyStart; tok && tok != scope->bodyEnd; tok = tok->next()) {
            if (!Token::simpleMatch(tok, ""strncpy (""))
                continue;
            const std::vector<const Token *> args = getArguments(tok);
            if (args.size() != 3)
                continue;
            const Token *sizeToken = args[2];
            if (!sizeToken->hasKnownIntValue())
                continue;
            const ValueFlow::Value &bufferSize = getBuffer...",1,1,lib/checkbufferoverrun.cpp,CheckBufferOverrun.stringNotZeroTerminated:void(),<empty>,,false,753,804,stringNotZeroTerminated,,,1,void()
111669151267,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"void CheckBufferOverrun::terminateStrncpyError(const Token *tok, const std::string &varname)
{
    const std::string shortMessage = ""The buffer '$symbol' may not be null-terminated after the call to strncpy()."";
    reportError(tok, Severity::warning, ""terminateStrncpy"",
                ""$symbol:"" + varname + '\\n' +
                shortMessage + '\\n' +
                shortMessage + ' ' +
                ""If the source string's size fits or exceeds the given size, strncpy() does not add a ""
                ""zero at the end of the buffer. This causes bugs later in the code if the code ""
                ""assumes buffer is null-terminated."", CWE170, Certainty::inconclusive);
}",1,1,lib/checkbufferoverrun.cpp,"CheckBufferOverrun.terminateStrncpyError:void(Token*,std.string&)",<empty>,,false,806,816,terminateStrncpyError,,,1,"void(Token*,std.string&)"
111669151268,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"void CheckBufferOverrun::argumentSize()
{
    // Check '%type% x[10]' arguments
    if (!mSettings->severity.isEnabled(Severity::warning) && !mSettings->isPremiumEnabled(""argumentSize""))
        return;

    logChecker(""CheckBufferOverrun::argumentSize""); // warning

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * const scope : symbolDatabase->functionScopes) {
        for (const Token *tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
            if (!tok->function() || !Token::Match(tok, ""%name% (""))
                continue;

            // If argument is '%type% a[num]' then check bounds against num
            const Function *callfunc = tok->function();
            const std::vector<const Token *> callargs = getArguments(tok);
            for (nonneg int paramIndex = 0; paramIndex < callargs.size() && paramIndex < callfunc->argCount(); ++paramIndex) {
                const Variable* const argument = callfunc->...",1,17,lib/checkbufferoverrun.cpp,CheckBufferOverrun.argumentSize:void(),<empty>,,false,819,865,argumentSize,,,1,void()
111669151269,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"void CheckBufferOverrun::argumentSizeError(const Token *tok, const std::string &functionName, nonneg int paramIndex, const std::string &paramExpression, const Variable *paramVar, const Variable *functionArg)
{
    const std::string strParamNum = std::to_string(paramIndex + 1) + getOrdinalText(paramIndex + 1);
    ErrorPath errorPath;
    errorPath.emplace_back(tok, ""Function '"" + functionName + ""' is called"");
    if (functionArg)
        errorPath.emplace_back(functionArg->nameToken(), ""Declaration of "" + strParamNum + "" function argument."");
    if (paramVar)
        errorPath.emplace_back(paramVar->nameToken(), ""Passing buffer '"" + paramVar->name() + ""' to function that is declared here"");
    errorPath.emplace_back(tok, """");

    reportError(errorPath, Severity::warning, ""argumentSize"",
                ""$symbol:"" + functionName + '\\n' +
                ""Buffer '"" + paramExpression + ""' is too small, the function '"" + functionName + ""' expects a bigger buffer in "" + strParamNum +...",1,94,lib/checkbufferoverrun.cpp,"CheckBufferOverrun.argumentSizeError:void(Token*,std.string&,int,std.string&,Variable*,Variable*)",<empty>,,false,867,881,argumentSizeError,,,1,"void(Token*,std.string&,int,std.string&,Variable*,Variable*)"
111669151270,METHOD,MyFileInfo,TYPE_DECL,"std::string toString() const override
        {
            std::string xml;
            if (!unsafeArrayIndex.empty())
                xml = ""    <array-index>\\n"" + CTU::toString(unsafeArrayIndex) + ""    </array-index>\\n"";
            if (!unsafePointerArith.empty())
                xml += ""    <pointer-arith>\\n"" + CTU::toString(unsafePointerArith) + ""    </pointer-arith>\\n"";
            return xml;
        }",9,9,lib/checkbufferoverrun.cpp,MyFileInfo.toString<const>:string(),<empty>,,false,906,914,toString,,,3,string()
111669151271,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"bool CheckBufferOverrun::isCtuUnsafeBufferUsage(const Settings &settings, const Token *argtok, CTU::FileInfo::Value *offset, int type)
{
    if (!offset)
        return false;
    if (!argtok->valueType() || argtok->valueType()->typeSize(settings.platform) == 0)
        return false;
    const Token *indexTok = nullptr;
    if (type == 1 && Token::Match(argtok, ""%name% ["") && argtok->astParent() == argtok->next() && !Token::simpleMatch(argtok->linkAt(1), ""] [""))
        indexTok = argtok->next()->astOperand2();
    else if (type == 2 && Token::simpleMatch(argtok->astParent(), ""+""))
        indexTok = (argtok == argtok->astParent()->astOperand1()) ?
                   argtok->astParent()->astOperand2() :
                   argtok->astParent()->astOperand1();
    if (!indexTok)
        return false;
    if (!indexTok->hasKnownIntValue())
        return false;
    offset->value = indexTok->getKnownIntValue() * argtok->valueType()->typeSize(settings.platform);
    return true;
}",1,1,lib/checkbufferoverrun.cpp,"CheckBufferOverrun.isCtuUnsafeBufferUsage:bool(Settings&,Token*,CTU.FileInfo.Value*,int)",<empty>,,false,918,937,isCtuUnsafeBufferUsage,,,1,"bool(Settings&,Token*,CTU.FileInfo.Value*,int)"
111669151272,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"bool CheckBufferOverrun::isCtuUnsafeArrayIndex(const Settings &settings, const Token *argtok, CTU::FileInfo::Value *offset)
{
    return isCtuUnsafeBufferUsage(settings, argtok, offset, 1);
}",1,1,lib/checkbufferoverrun.cpp,"CheckBufferOverrun.isCtuUnsafeArrayIndex:bool(Settings&,Token*,CTU.FileInfo.Value*)",<empty>,,false,939,942,isCtuUnsafeArrayIndex,,,1,"bool(Settings&,Token*,CTU.FileInfo.Value*)"
111669151273,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"bool CheckBufferOverrun::isCtuUnsafePointerArith(const Settings &settings, const Token *argtok, CTU::FileInfo::Value* offset)
{
    return isCtuUnsafeBufferUsage(settings, argtok, offset, 2);
}",1,1,lib/checkbufferoverrun.cpp,"CheckBufferOverrun.isCtuUnsafePointerArith:bool(Settings&,Token*,CTU.FileInfo.Value*)",<empty>,,false,944,947,isCtuUnsafePointerArith,,,1,"bool(Settings&,Token*,CTU.FileInfo.Value*)"
111669151274,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"Check::FileInfo *CheckBufferOverrun::getFileInfo(const Tokenizer &tokenizer, const Settings &settings) const
{
    const std::list<CTU::FileInfo::UnsafeUsage> &unsafeArrayIndex = CTU::getUnsafeUsage(tokenizer, settings, isCtuUnsafeArrayIndex);
    const std::list<CTU::FileInfo::UnsafeUsage> &unsafePointerArith = CTU::getUnsafeUsage(tokenizer, settings, isCtuUnsafePointerArith);
    if (unsafeArrayIndex.empty() && unsafePointerArith.empty()) {
        return nullptr;
    }
    auto *fileInfo = new MyFileInfo(tokenizer.list.getFiles()[0]);
    fileInfo->unsafeArrayIndex = unsafeArrayIndex;
    fileInfo->unsafePointerArith = unsafePointerArith;
    return fileInfo;
}",1,1,lib/checkbufferoverrun.cpp,"CheckBufferOverrun.getFileInfo<const>:Check.FileInfo*(Tokenizer&,Settings&)",<empty>,,false,950,961,getFileInfo,,,1,"Check.FileInfo*(Tokenizer&,Settings&)"
111669151275,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"Check::FileInfo * CheckBufferOverrun::loadFileInfoFromXml(const tinyxml2::XMLElement *xmlElement) const
{
    // cppcheck-suppress shadowFunction - TODO: fix this
    const std::string arrayIndex(""array-index"");
    const std::string pointerArith(""pointer-arith"");

    auto *fileInfo = new MyFileInfo;
    for (const tinyxml2::XMLElement *e = xmlElement->FirstChildElement(); e; e = e->NextSiblingElement()) {
        const char* name = e->Name();
        if (name == arrayIndex)
            fileInfo->unsafeArrayIndex = CTU::loadUnsafeUsageListFromXml(e);
        else if (name == pointerArith)
            fileInfo->unsafePointerArith = CTU::loadUnsafeUsageListFromXml(e);
    }

    if (fileInfo->unsafeArrayIndex.empty() && fileInfo->unsafePointerArith.empty()) {
        delete fileInfo;
        return nullptr;
    }

    return fileInfo;
}",1,1,lib/checkbufferoverrun.cpp,CheckBufferOverrun.loadFileInfoFromXml<const>:Check.FileInfo*(tinyxml2.XMLElement*),<empty>,,false,963,984,loadFileInfoFromXml,,,1,Check.FileInfo*(tinyxml2.XMLElement*)
111669151276,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"bool CheckBufferOverrun::analyseWholeProgram(const CTU::FileInfo &ctu, const std::list<Check::FileInfo*> &fileInfo, const Settings& settings, ErrorLogger &errorLogger)
{
    CheckBufferOverrun dummy(nullptr, &settings, &errorLogger);
    dummy.
    logChecker(""CheckBufferOverrun::analyseWholeProgram"");

    if (fileInfo.empty())
        return false;

    const std::map<std::string, std::list<const CTU::FileInfo::CallBase *>> callsMap = ctu.getCallsMap();

    bool foundErrors = false;

    for (const Check::FileInfo* fi1 : fileInfo) {
        const auto *fi = dynamic_cast<const MyFileInfo*>(fi1);
        if (!fi)
            continue;
        for (const CTU::FileInfo::UnsafeUsage &unsafeUsage : fi->unsafeArrayIndex)
            foundErrors |= analyseWholeProgram1(callsMap, unsafeUsage, 1, errorLogger, settings.maxCtuDepth, fi->file0);
        for (const CTU::FileInfo::UnsafeUsage &unsafeUsage : fi->unsafePointerArith)
            foundErrors |= analyseWholeProgram1(callsMap, unsafe...",1,1,lib/checkbufferoverrun.cpp,"CheckBufferOverrun.analyseWholeProgram:bool(CTU.FileInfo&,std.list<Check.FileInfo*>&,Settings&,ErrorLogger&)",<empty>,,false,987,1010,analyseWholeProgram,,,1,"bool(CTU.FileInfo&,std.list<Check.FileInfo*>&,Settings&,ErrorLogger&)"
111669151277,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"bool CheckBufferOverrun::analyseWholeProgram1(const std::map<std::string, std::list<const CTU::FileInfo::CallBase *>> &callsMap, const CTU::FileInfo::UnsafeUsage &unsafeUsage,
                                              int type, ErrorLogger &errorLogger, int maxCtuDepth, const std::string& file0)
{
    const CTU::FileInfo::FunctionCall *functionCall = nullptr;

    const std::list<ErrorMessage::FileLocation> &locationList =
        CTU::FileInfo::getErrorPath(CTU::FileInfo::InvalidValueType::bufferOverflow,
                                    unsafeUsage,
                                    callsMap,
                                    ""Using argument ARG"",
                                    &functionCall,
                                    false,
                                    maxCtuDepth);
    if (locationList.empty())
        return false;

    const char *errorId = nullptr;
    std::string errmsg;
    CWE cwe(0);

    if (type == 1) {
        errorId = ""ctuArrayIndex"";...",1,1,lib/checkbufferoverrun.cpp,"CheckBufferOverrun.analyseWholeProgram1:bool(std.map<std.string,std.list<constCTU.FileInfo.CallBase*>>&,CTU.FileInfo.UnsafeUsage&,int,ErrorLogger&,int,std.string&)",<empty>,,false,1012,1054,analyseWholeProgram1,,,1,"bool(std.map<std.string,std.list<constCTU.FileInfo.CallBase*>>&,CTU.FileInfo.UnsafeUsage&,int,ErrorLogger&,int,std.string&)"
111669151278,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& vidx) {
                        if (!vidx.isIntValue())
                            return false;
                        return vidx.path == v.path || vidx.path == 0;
                    }",34,21,lib/checkbufferoverrun.cpp,lib/checkbufferoverrun.cpp:<global>.CheckBufferOverrun.objectIndex.<lambda>5:bool(ValueFlow.Value&),<empty>,,false,1108,1112,<lambda>5,,,1,bool(ValueFlow.Value&)
111669151279,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& vidx) {
                        if (vidx.isImpossible())
                            return (vidx.intvalue == 0);
                        return (vidx.intvalue != 0);
                    }",75,21,lib/checkbufferoverrun.cpp,lib/checkbufferoverrun.cpp:<global>.CheckBufferOverrun.objectIndex.<lambda>6:bool(ValueFlow.Value&),<empty>,,false,1113,1117,<lambda>6,,,1,bool(ValueFlow.Value&)
111669151280,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"void CheckBufferOverrun::objectIndex()
{
    logChecker(""CheckBufferOverrun::objectIndex"");
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope *functionScope : symbolDatabase->functionScopes) {
        for (const Token *tok = functionScope->bodyStart; tok != functionScope->bodyEnd; tok = tok->next()) {
            if (!Token::simpleMatch(tok, ""[""))
                continue;
            const Token *obj = tok->astOperand1();
            const Token *idx = tok->astOperand2();
            if (!idx || !obj)
                continue;
            if (const ValueFlow::Value* v = idx->getKnownValue(ValueFlow::Value::ValueType::INT)) {
                if (v->intvalue == 0)
                    continue;
            }

            std::vector<ValueFlow::Value> values = ValueFlow::getLifetimeObjValues(obj, false, -1);
            for (const ValueFlow::Value& v:values) {
                if (v.lifetimeKind != ValueFlow::Value::LifetimeKind::Address)
 ...",1,1,lib/checkbufferoverrun.cpp,CheckBufferOverrun.objectIndex:void(),<empty>,,false,1056,1126,objectIndex,,,1,void()
111669151281,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"void CheckBufferOverrun::objectIndexError(const Token *tok, const ValueFlow::Value *v, bool known)
{
    ErrorPath errorPath;
    std::string name;
    if (v) {
        const Token* expr = v->tokvalue;
        while (Token::simpleMatch(expr->astParent(), "".""))
            expr = expr->astParent();
        name = expr->expressionString();
        errorPath = v->errorPath;
    }
    errorPath.emplace_back(tok, """");
    std::string verb = known ? ""is"" : ""might be"";
    reportError(errorPath,
                known ? Severity::error : Severity::warning,
                ""objectIndex"",
                ""The address of variable '"" + name + ""' "" + verb + "" accessed at non-zero index."",
                CWE758,
                Certainty::normal);
}",1,1,lib/checkbufferoverrun.cpp,"CheckBufferOverrun.objectIndexError:void(Token*,ValueFlow.Value*,bool)",<empty>,,false,1128,1147,objectIndexError,,,1,"void(Token*,ValueFlow.Value*,bool)"
111669151282,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"static bool isVLAIndex(const Token* tok)
{
    if (!tok)
        return false;
    if (tok->varId() != 0U)
        return true;
    if (tok->str() == ""?"") {
        // this is a VLA index if both expressions around the "":"" is VLA index
        return tok->astOperand2() &&
               tok->astOperand2()->str() == "":"" &&
               isVLAIndex(tok->astOperand2()->astOperand1()) &&
               isVLAIndex(tok->astOperand2()->astOperand2());
    }
    return isVLAIndex(tok->astOperand1()) || isVLAIndex(tok->astOperand2());
}",1,1,lib/checkbufferoverrun.cpp,isVLAIndex:bool(Token*),<empty>,,false,1149,1163,isVLAIndex,,,1,bool(Token*)
111669151283,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"void CheckBufferOverrun::negativeArraySize()
{
    logChecker(""CheckBufferOverrun::negativeArraySize"");
    const SymbolDatabase* symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Variable* var : symbolDatabase->variableList()) {
        if (!var || !var->isArray())
            continue;
        const Token* const nameToken = var->nameToken();
        if (!Token::Match(nameToken, ""%var% ["") || !nameToken->next()->astOperand2())
            continue;
        const ValueFlow::Value* sz = nameToken->next()->astOperand2()->getValueLE(-1, *mSettings);
        // don't warn about constant negative index because that is a compiler error
        if (sz && isVLAIndex(nameToken->next()->astOperand2()))
            negativeArraySizeError(nameToken);
    }

    for (const Scope* functionScope : symbolDatabase->functionScopes) {
        for (const Token* tok = functionScope->bodyStart; tok != functionScope->bodyEnd; tok = tok->next()) {
            if (!tok->isKeyword() || tok->st...",1,1,lib/checkbufferoverrun.cpp,CheckBufferOverrun.negativeArraySize:void(),<empty>,,false,1165,1193,negativeArraySize,,,1,void()
111669151284,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"void CheckBufferOverrun::negativeArraySizeError(const Token* tok)
{
    const std::string arrayName = tok ? tok->expressionString() : std::string();
    const std::string line1 = arrayName.empty() ? std::string() : (""$symbol:"" + arrayName + '\\n');
    reportError(tok, Severity::error, ""negativeArraySize"",
                line1 +
                ""Declaration of array '"" + arrayName + ""' with negative size is undefined behaviour"", CWE758, Certainty::normal);
}",1,1,lib/checkbufferoverrun.cpp,CheckBufferOverrun.negativeArraySizeError:void(Token*),<empty>,,false,1195,1202,negativeArraySizeError,,,1,void(Token*)
111669151285,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"void CheckBufferOverrun::negativeMemoryAllocationSizeError(const Token* tok, const ValueFlow::Value* value)
{
    const std::string msg = ""Memory allocation size is negative."";
    const ErrorPath errorPath = getErrorPath(tok, value, msg);
    const bool inconclusive = value != nullptr && !value->isKnown();
    reportError(errorPath, inconclusive ? Severity::warning : Severity::error, ""negativeMemoryAllocationSize"",
                msg, CWE131, inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checkbufferoverrun.cpp,"CheckBufferOverrun.negativeMemoryAllocationSizeError:void(Token*,ValueFlow.Value*)",<empty>,,false,1204,1211,negativeMemoryAllocationSizeError,,,1,"void(Token*,ValueFlow.Value*)"
111669151286,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"void CheckBufferOverrun::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    CheckBufferOverrun checkBufferOverrun(&tokenizer, &tokenizer.getSettings(), errorLogger);
    checkBufferOverrun.arrayIndex();
    checkBufferOverrun.pointerArithmetic();
    checkBufferOverrun.bufferOverflow();
    checkBufferOverrun.arrayIndexThenCheck();
    checkBufferOverrun.stringNotZeroTerminated();
    checkBufferOverrun.objectIndex();
    checkBufferOverrun.argumentSize();
    checkBufferOverrun.negativeArraySize();
}",1,1,lib/checkbufferoverrun.cpp,"CheckBufferOverrun.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,1213,1224,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669151287,METHOD,lib/checkbufferoverrun.cpp:<global>,TYPE_DECL,"void CheckBufferOverrun::getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const
{
    CheckBufferOverrun c(nullptr, settings, errorLogger);
    c.arrayIndexError(nullptr, std::vector<Dimension>(), std::vector<ValueFlow::Value>());
    c.pointerArithmeticError(nullptr, nullptr, nullptr);
    c.negativeIndexError(nullptr, std::vector<Dimension>(), std::vector<ValueFlow::Value>());
    c.arrayIndexThenCheckError(nullptr, ""i"");
    c.bufferOverflowError(nullptr, nullptr, Certainty::normal);
    c.objectIndexError(nullptr, nullptr, true);
    c.argumentSizeError(nullptr, ""function"", 1, ""buffer"", nullptr, nullptr);
    c.negativeMemoryAllocationSizeError(nullptr, nullptr);
    c.negativeArraySizeError(nullptr);
}",1,1,lib/checkbufferoverrun.cpp,"CheckBufferOverrun.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,1226,1238,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669151288,METHOD,lib/checkbufferoverrun.h:<global>,TYPE_DECL,<global>,1,1,lib/checkbufferoverrun.h,lib/checkbufferoverrun.h:<global>,<empty>,,false,1,140,<global>,,,1,
111669151289,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"static const char * getFunctionTypeName(FunctionType type)
{
    switch (type) {
    case FunctionType::eConstructor:
        return ""constructor"";
    case FunctionType::eCopyConstructor:
        return ""copy constructor"";
    case FunctionType::eMoveConstructor:
        return ""move constructor"";
    case FunctionType::eDestructor:
        return ""destructor"";
    case FunctionType::eFunction:
        return ""function"";
    case FunctionType::eOperatorEqual:
        return ""operator="";
    case FunctionType::eLambda:
        return ""lambda"";
    }
    return """";
}",1,1,lib/checkclass.cpp,getFunctionTypeName:char*(FunctionType),<empty>,,false,60,79,getFunctionTypeName,,,1,char*(FunctionType)
111669151290,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,<global>,1,78,lib/checkclass.cpp,lib/checkclass.cpp:<global>,<empty>,,false,1,3825,<global>,,,1,
111669151291,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"static bool isVariableCopyNeeded(const Variable &var, FunctionType type)
{
    bool isOpEqual = false;
    switch (type) {
    case FunctionType::eOperatorEqual:
        isOpEqual = true;
        break;
    case FunctionType::eCopyConstructor:
    case FunctionType::eMoveConstructor:
        break;
    default:
        return true;
    }

    return (!var.hasDefault() || isOpEqual) && // default init does not matter for operator=
           (var.isPointer() ||
            (var.type() && var.type()->needInitialization == Type::NeedInitialization::True) ||
            (var.valueType() && var.valueType()->type >= ValueType::Type::CHAR));
}",1,1,lib/checkclass.cpp,"isVariableCopyNeeded:bool(Variable&,FunctionType)",<empty>,,false,81,99,isVariableCopyNeeded,,,1,"bool(Variable&,FunctionType)"
111669151292,METHOD,<empty>,<empty>,"[&](const Type::BaseInfo& baseInfo) {
        if (!baseInfo.type)
            return true;
        if (isVclTypeInit(baseInfo.type))
            return true;
        return false;
    }",76,5,lib/checkclass.cpp,lib/checkclass.cpp:<global>.isVclTypeInit.<lambda>0:bool(Type.BaseInfo&),<empty>,,false,105,111,<lambda>0,,,1,bool(Type.BaseInfo&)
111669151293,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"static bool isVclTypeInit(const Type *type)
{
    if (!type)
        return false;
    return std::any_of(type->derivedFrom.begin(), type->derivedFrom.end(), [&](const Type::BaseInfo& baseInfo) {
        if (!baseInfo.type)
            return true;
        if (isVclTypeInit(baseInfo.type))
            return true;
        return false;
    });
}",1,1,lib/checkclass.cpp,isVclTypeInit:bool(Type*),<empty>,,false,101,112,isVclTypeInit,,,1,bool(Type*)
111669151294,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"CheckClass::CheckClass(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
    : Check(myName(), tokenizer, settings, errorLogger),
    mSymbolDatabase(tokenizer?tokenizer->getSymbolDatabase():nullptr)
{}",1,2,lib/checkclass.cpp,"CheckClass.CheckClass:ANY(Tokenizer*,Settings*,ErrorLogger*)",<empty>,,false,115,118,CheckClass,,,1,"CheckClass.CheckClass:ANY(Tokenizer*,Settings*,ErrorLogger*)(Tokenizer*,Settings*,ErrorLogger*)"
111669151295,METHOD,<empty>,<empty>,"[&](const Variable& var) {
                return var.type() && var.type()->classScope == scope;
            }",88,13,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.constructors.<lambda>1.<lambda>2:bool(Variable&),<empty>,,false,143,145,<lambda>2,,,1,bool(Variable&)
111669151296,METHOD,<empty>,<empty>,"[&](const Scope& unionScope) {
            if (unionScope.type != ScopeType::eUnion)
                return false;
            return std::any_of(unionScope.varlist.cbegin(), unionScope.varlist.cend(), [&](const Variable& var) {
                return var.type() && var.type()->classScope == scope;
            });
        }",118,9,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.constructors.<lambda>1:bool(Scope&),<empty>,,false,140,146,<lambda>1,,,1,bool(Scope&)
111669151297,METHOD,<empty>,<empty>,"[](const Scope* nestedScope) {
                return nestedScope->type == ScopeType::eUnion;
            }",100,13,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.constructors.<lambda>3:bool(Scope*),<empty>,,false,178,180,<lambda>3,,,1,bool(Scope*)
111669151298,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::constructors()
{
    const bool printStyle = mSettings->severity.isEnabled(Severity::style);
    const bool printWarnings = mSettings->severity.isEnabled(Severity::warning);
    if (!printStyle && !printWarnings && !mSettings->isPremiumEnabled(""uninitMemberVar""))
        return;

    logChecker(""CheckClass::checkConstructors""); // style,warning

    const bool printInconclusive = mSettings->certainty.isEnabled(Certainty::inconclusive);
    for (const Scope * scope : mSymbolDatabase->classAndStructScopes) {
        if (mSettings->hasLib(""vcl"") && isVclTypeInit(scope->definedType))
            continue;

        const bool unusedTemplate = Token::simpleMatch(scope->classDef->previous(), "">"");

        const bool usedInUnion = std::any_of(mSymbolDatabase->scopeList.cbegin(), mSymbolDatabase->scopeList.cend(), [&](const Scope& unionScope) {
            if (unionScope.type != ScopeType::eUnion)
                return false;
            return std::any_of(unionScope.varli...",1,1,lib/checkclass.cpp,CheckClass.constructors:void(),<empty>,,false,124,333,constructors,,,1,void()
111669151299,METHOD,<empty>,<empty>,"[](const Function& func) {
            return func.isPure();
        }",108,9,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.checkExplicitConstructors.<lambda>4:bool(Function&),<empty>,,false,349,351,<lambda>4,,,1,bool(Function&)
111669151300,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::checkExplicitConstructors()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""noExplicitConstructor""))
        return;

    logChecker(""CheckClass::checkExplicitConstructors""); // style

    for (const Scope * scope : mSymbolDatabase->classAndStructScopes) {
        // Do not perform check, if the class/struct has not any constructors
        if (scope->numConstructors == 0)
            continue;

        // Is class abstract? Maybe this test is over-simplification, but it will suffice for simple cases,
        // and it will avoid false positives.
        const bool isAbstractClass = std::any_of(scope->functionList.cbegin(), scope->functionList.cend(), [](const Function& func) {
            return func.isPure();
        });

        // Abstract classes can't be instantiated. But if there is C++11
        // ""misuse"" by derived classes then these constructors must be explicit.
        if (isAbstractClass && mSettings->standar...",1,1,lib/checkclass.cpp,CheckClass.checkExplicitConstructors:void(),<empty>,,false,335,378,checkExplicitConstructors,,,1,void()
111669151301,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"static bool hasNonCopyableBase(const Scope *scope, bool *unknown)
{
    // check if there is base class that is not copyable
    for (const Type::BaseInfo &baseInfo : scope->definedType->derivedFrom) {
        if (!baseInfo.type || !baseInfo.type->classScope) {
            *unknown = true;
            continue;
        }

        if (hasNonCopyableBase(baseInfo.type->classScope, unknown))
            return true;

        for (const Function &func : baseInfo.type->classScope->functionList) {
            if (func.type != FunctionType::eCopyConstructor)
                continue;
            if (func.access == AccessControl::Private || func.isDelete()) {
                *unknown = false;
                return true;
            }
        }
    }
    return false;
}",1,1,lib/checkclass.cpp,"hasNonCopyableBase:bool(Scope*,bool*)",<empty>,,false,380,402,hasNonCopyableBase,,,1,"bool(Scope*,bool*)"
111669151302,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::copyconstructors()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckClass::checkCopyConstructors""); // warning

    for (const Scope * scope : mSymbolDatabase->classAndStructScopes) {
        std::map<int, const Token*> allocatedVars;

        for (const Function &func : scope->functionList) {
            if (func.type != FunctionType::eConstructor || !func.functionScope)
                continue;
            const Token* tok = func.token->linkAt(1);
            for (const Token* const end = func.functionScope->bodyStart; tok != end; tok = tok->next()) {
                if (Token::Match(tok, ""%var% ( new"") ||
                    (Token::Match(tok, ""%var% ( %name% ("") && mSettings->library.getAllocFuncInfo(tok->tokAt(2)))) {
                    const Variable* var = tok->variable();
                    if (var && var->isPointer() && var->scope() == scope)
                        allocatedVars[tok->varId()] = tok;
    ...",1,1,lib/checkclass.cpp,CheckClass.copyconstructors:void(),<empty>,,false,404,524,copyconstructors,,,1,void()
111669151303,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::copyConstructorShallowCopyError(const Token *tok, const std::string& varname)
{
    reportError(tok, Severity::warning, ""copyCtorPointerCopying"",
                ""$symbol:"" + varname + ""\\nValue of pointer '$symbol', which points to allocated memory, is copied in copy constructor instead of allocating new memory."", CWE398, Certainty::normal);
}",1,1,lib/checkclass.cpp,"CheckClass.copyConstructorShallowCopyError:void(Token*,std.string&)",<empty>,,false,536,540,copyConstructorShallowCopyError,,,1,"void(Token*,std.string&)"
111669151304,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"static std::string noMemberErrorMessage(const Scope *scope, const char function[], bool isdefault)
{
    const std::string &classname = scope ? scope->className : ""class"";
    const std::string type = (scope && scope->type == ScopeType::eStruct) ? ""Struct"" : ""Class"";
    const bool isDestructor = (function[0] == 'd');
    std::string errmsg = ""$symbol:"" + classname + '\\n';

    if (isdefault) {
        errmsg += type + "" '$symbol' has dynamic memory/resource allocation(s). The "" + function + "" is explicitly defaulted but the default "" + function + "" does not work well."";
        if (isDestructor)
            errmsg += "" It is recommended to define the "" + std::string(function) + '.';
        else
            errmsg += "" It is recommended to define or delete the "" + std::string(function) + '.';
    } else {
        errmsg += type + "" '$symbol' does not have a "" + function + "" which is recommended since it has dynamic memory/resource allocation(s)."";
    }

    return errmsg;
}",1,1,lib/checkclass.cpp,"noMemberErrorMessage:string(Scope*,char[],bool)",<empty>,,false,542,560,noMemberErrorMessage,,,1,"string(Scope*,char[],bool)"
111669151305,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::noCopyConstructorError(const Scope *scope, bool isdefault, const Token *alloc, bool inconclusive)
{
    reportError(alloc, Severity::warning, ""noCopyConstructor"", noMemberErrorMessage(scope, ""copy constructor"", isdefault), CWE398, inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checkclass.cpp,"CheckClass.noCopyConstructorError:void(Scope*,bool,Token*,bool)",<empty>,,false,562,565,noCopyConstructorError,,,1,"void(Scope*,bool,Token*,bool)"
111669151306,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::noOperatorEqError(const Scope *scope, bool isdefault, const Token *alloc, bool inconclusive)
{
    reportError(alloc, Severity::warning, ""noOperatorEq"", noMemberErrorMessage(scope, ""operator="", isdefault), CWE398, inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checkclass.cpp,"CheckClass.noOperatorEqError:void(Scope*,bool,Token*,bool)",<empty>,,false,567,570,noOperatorEqError,,,1,"void(Scope*,bool,Token*,bool)"
111669151307,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::noDestructorError(const Scope *scope, bool isdefault, const Token *alloc)
{
    reportError(alloc, Severity::warning, ""noDestructor"", noMemberErrorMessage(scope, ""destructor"", isdefault), CWE398, Certainty::normal);
}",1,1,lib/checkclass.cpp,"CheckClass.noDestructorError:void(Scope*,bool,Token*)",<empty>,,false,572,575,noDestructorError,,,1,"void(Scope*,bool,Token*)"
111669151308,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"bool CheckClass::canNotCopy(const Scope *scope)
{
    bool constructor = false;
    bool publicAssign = false;
    bool publicCopy = false;

    for (const Function &func : scope->functionList) {
        if (func.isConstructor())
            constructor = true;
        if (func.access != AccessControl::Public)
            continue;
        if (func.type == FunctionType::eCopyConstructor) {
            publicCopy = true;
            break;
        }
        if (func.type == FunctionType::eOperatorEqual) {
            publicAssign = true;
            break;
        }
    }

    return constructor && !(publicAssign || publicCopy);
}",1,1,lib/checkclass.cpp,CheckClass.canNotCopy:bool(Scope*),<empty>,,false,577,599,canNotCopy,,,1,bool(Scope*)
111669151309,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"bool CheckClass::canNotMove(const Scope *scope)
{
    bool constructor = false;
    bool publicAssign = false;
    bool publicCopy = false;
    bool publicMove = false;

    for (const Function &func : scope->functionList) {
        if (func.isConstructor())
            constructor = true;
        if (func.access != AccessControl::Public)
            continue;
        if (func.type == FunctionType::eCopyConstructor) {
            publicCopy = true;
            break;
        }
        if (func.type == FunctionType::eMoveConstructor) {
            publicMove = true;
            break;
        }
        if (func.type == FunctionType::eOperatorEqual) {
            publicAssign = true;
            break;
        }
    }

    return constructor && !(publicAssign || publicCopy || publicMove);
}",1,1,lib/checkclass.cpp,CheckClass.canNotMove:bool(Scope*),<empty>,,false,601,628,canNotMove,,,1,bool(Scope*)
111669151310,METHOD,<empty>,<empty>,"[](const Variable& var) {
        return &var;
    }",97,5,lib/checkclass.cpp,lib/checkclass.cpp:<global>.getAllVariableMembers.<lambda>5:Variable*(Variable&),<empty>,,false,632,634,<lambda>5,,,1,Variable*(Variable&)
111669151311,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"static void getAllVariableMembers(const Scope *scope, std::vector<const Variable *>& varList)
{
    std::transform(scope->varlist.cbegin(), scope->varlist.cend(), std::back_inserter(varList), [](const Variable& var) {
        return &var;
    });
    if (scope->definedType) {
        for (const Type::BaseInfo& baseInfo: scope->definedType->derivedFrom) {
            if (scope->definedType == baseInfo.type)
                continue;
            const Scope *baseClass = baseInfo.type ? baseInfo.type->classScope : nullptr;
            if (baseClass && baseClass->isClassOrStruct() && baseClass->numConstructors == 0)
                getAllVariableMembers(baseClass, varList);
        }
    }
}",1,1,lib/checkclass.cpp,"getAllVariableMembers:void(Scope*,std.vector<constVariable*>&)",<empty>,,false,630,644,getAllVariableMembers,,,1,"void(Scope*,std.vector<constVariable*>&)"
111669151312,METHOD,<empty>,<empty>,"[](const Variable* var) {
        return Usage(var);
    }",79,5,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.createUsageList:vector<CheckClass.Usage>(Scope*).<lambda>6:CheckClass.Usage(Variable*),<empty>,,false,652,654,<lambda>6,,,1,CheckClass.Usage(Variable*)
111669151313,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"std::vector<CheckClass::Usage> CheckClass::createUsageList(const Scope *scope)
{
    std::vector<Usage> ret;
    std::vector<const Variable *> varlist;
    getAllVariableMembers(scope, varlist);
    ret.reserve(varlist.size());
    std::transform(varlist.cbegin(), varlist.cend(), std::back_inserter(ret), [](const Variable* var) {
        return Usage(var);
    });
    return ret;
}",1,1,lib/checkclass.cpp,CheckClass.createUsageList:vector<CheckClass.Usage>(Scope*),<empty>,,false,646,656,createUsageList,,,1,vector<CheckClass::Usage>(Scope*)
111669151314,METHOD,<empty>,<empty>,"[varid](const Usage& usage) {
        return usage.var->declarationId() == varid;
    }",64,5,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.assignVar.<lambda>7:bool(CheckClass.Usage&),<empty>,,false,660,662,<lambda>7,,,1,bool(CheckClass.Usage&)
111669151315,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::assignVar(std::vector<Usage> &usageList, nonneg int varid)
{
    auto it = std::find_if(usageList.begin(), usageList.end(), [varid](const Usage& usage) {
        return usage.var->declarationId() == varid;
    });
    if (it != usageList.end())
        it->assign = true;
}",1,58,lib/checkclass.cpp,"CheckClass.assignVar:void(std.vector<Usage>&,int)",<empty>,,false,658,665,assignVar,,,1,"void(std.vector<Usage>&,int)"
111669151316,METHOD,<empty>,<empty>,"[vartok](const Usage& usage) {
        // FIXME: This is a workaround when varid is not set for a derived member
        return usage.var->name() == vartok->str();
    }",64,5,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.assignVar.<lambda>8:bool(CheckClass.Usage&),<empty>,,false,673,676,<lambda>8,,,1,bool(CheckClass.Usage&)
111669151317,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::assignVar(std::vector<Usage> &usageList, const Token* vartok)
{
    if (vartok->varId() > 0) {
        assignVar(usageList, vartok->varId());
        return;
    }
    auto it = std::find_if(usageList.begin(), usageList.end(), [vartok](const Usage& usage) {
        // FIXME: This is a workaround when varid is not set for a derived member
        return usage.var->name() == vartok->str();
    });
    if (it != usageList.end())
        it->assign = true;
}",1,1,lib/checkclass.cpp,"CheckClass.assignVar:void(std.vector<Usage>&,Token*)",<empty>,,false,667,679,assignVar,,,1,"void(std.vector<Usage>&,Token*)"
111669151318,METHOD,<empty>,<empty>,"[varid](const Usage& usage) {
        return usage.var->declarationId() == varid;
    }",64,5,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.initVar.<lambda>9:bool(CheckClass.Usage&),<empty>,,false,683,685,<lambda>9,,,1,bool(CheckClass.Usage&)
111669151319,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::initVar(std::vector<Usage> &usageList, nonneg int varid)
{
    auto it = std::find_if(usageList.begin(), usageList.end(), [varid](const Usage& usage) {
        return usage.var->declarationId() == varid;
    });
    if (it != usageList.end())
        it->init = true;
}",1,56,lib/checkclass.cpp,"CheckClass.initVar:void(std.vector<Usage>&,int)",<empty>,,false,681,688,initVar,,,1,"void(std.vector<Usage>&,int)"
111669151320,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::assignAllVar(std::vector<Usage> &usageList)
{
    for (Usage & i : usageList)
        i.assign = true;
}",1,1,lib/checkclass.cpp,CheckClass.assignAllVar:void(std.vector<Usage>&),<empty>,,false,690,694,assignAllVar,,,1,void(std.vector<Usage>&)
111669151321,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::assignAllVarsVisibleFromScope(std::vector<Usage>& usageList, const Scope* scope)
{
    for (Usage& usage : usageList) {
        if (usage.var->scope() == scope)
            usage.assign = true;
    }

    // Iterate through each base class...
    for (const Type::BaseInfo& i : scope->definedType->derivedFrom) {
        const Type *derivedFrom = i.type;

        if (derivedFrom && derivedFrom->classScope)
            assignAllVarsVisibleFromScope(usageList, derivedFrom->classScope);
    }
}",1,1,lib/checkclass.cpp,"CheckClass.assignAllVarsVisibleFromScope:void(std.vector<Usage>&,Scope*)",<empty>,,false,696,710,assignAllVarsVisibleFromScope,,,1,"void(std.vector<Usage>&,Scope*)"
111669151322,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::clearAllVar(std::vector<Usage> &usageList)
{
    for (Usage & i : usageList) {
        i.assign = false;
        i.init = false;
    }
}",1,1,lib/checkclass.cpp,CheckClass.clearAllVar:void(std.vector<Usage>&),<empty>,,false,712,718,clearAllVar,,,1,void(std.vector<Usage>&)
111669151323,METHOD,<empty>,<empty>,"[&](const Function& func) {
                return func.tokenDef->str() == tok->str() && !func.isStatic() && !func.isConst();
            }",73,13,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.isBaseClassMutableMemberFunc.<lambda>10:bool(Function&),<empty>,,false,730,732,<lambda>10,,,1,bool(Function&)
111669151324,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"bool CheckClass::isBaseClassMutableMemberFunc(const Token *tok, const Scope *scope)
{
    // Iterate through each base class...
    for (const Type::BaseInfo & i : scope->definedType->derivedFrom) {
        const Type *derivedFrom = i.type;

        // Check if base class exists in database
        if (derivedFrom && derivedFrom->classScope) {
            const std::list<Function>& functionList = derivedFrom->classScope->functionList;

            if (std::any_of(functionList.cbegin(), functionList.cend(), [&](const Function& func) {
                return func.tokenDef->str() == tok->str() && !func.isStatic() && !func.isConst();
            }))
                return true;

            if (isBaseClassMutableMemberFunc(tok, derivedFrom->classScope))
                return true;
        }

        // Base class not found so assume it is in it.
        else
            return true;
    }

    return false;
}",1,1,lib/checkclass.cpp,"CheckClass.isBaseClassMutableMemberFunc:bool(Token*,Scope*)",<empty>,,false,720,745,isBaseClassMutableMemberFunc,,,1,"bool(Token*,Scope*)"
111669151325,METHOD,<empty>,<empty>,"[&](const Variable& var) {
                return var.declarationId() == ftok->next()->varId();
            }",77,13,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.initializeVarList<const>.<lambda>11:bool(Variable&),<empty>,,false,843,845,<lambda>11,,,1,bool(Variable&)
111669151326,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::initializeVarList(const Function &func, std::list<const Function *> &callstack, const Scope *scope, std::vector<Usage> &usage) const
{
    if (!func.functionScope)
        return;

    bool initList = func.isConstructor();
    const Token *ftok = func.arg->link()->next();
    int level = 0;
    for (; ftok && ftok != func.functionScope->bodyEnd; ftok = ftok->next()) {
        // Class constructor.. initializing variables like this
        // clKalle::clKalle() : var(value) { }
        if (initList) {
            if (level == 0 && Token::Match(ftok, ""%name% {|("") && Token::Match(ftok->linkAt(1), ""}|) ,|{"")) {
                if (ftok->str() != func.name()) {
                    if (ftok->varId())
                        initVar(usage, ftok->varId());
                    else { // base class constructor
                        for (Usage& u : usage) {
                            if (u.var->scope() != scope) // assume that all variables are initialized in base class
  ...",1,1,lib/checkclass.cpp,"CheckClass.initializeVarList<const>:void(Function&,std.list<constFunction*>&,Scope*,std.vector<Usage>&)",<empty>,,false,747,1079,initializeVarList,,,1,"void(Function&,std.list<constFunction*>&,Scope*,std.vector<Usage>&)"
111669151327,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::noConstructorError(const Token *tok, const std::string &classname, bool isStruct)
{
    // For performance reasons the constructor might be intentionally missing. Therefore this is not a ""warning""
    const std::string message {""The "" + std::string(isStruct ? ""struct"" : ""class"") + "" '$symbol' does not declare a constructor although it has private member variables which likely require initialization.""};
    const std::string verbose {message + "" Member variables of native types, pointers, or references are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior.""};
    reportError(tok, Severity::style, ""noConstructor"", ""$symbol:"" + classname + '\\n' + message + '\\n' + verbose, CWE398, Certainty::normal);
}",1,1,lib/checkclass.cpp,"CheckClass.noConstructorError:void(Token*,std.string&,bool)",<empty>,,false,1081,1087,noConstructorError,,,1,"void(Token*,std.string&,bool)"
111669151328,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::noExplicitConstructorError(const Token *tok, const std::string &classname, bool isStruct)
{
    const std::string message(std::string(isStruct ? ""Struct"" : ""Class"") + "" '$symbol' has a constructor with 1 argument that is not explicit."");
    const std::string verbose(message + "" Such, so called \\""Converting constructors\\"", should in general be explicit for type safety reasons as that prevents unintended implicit conversions."");
    reportError(tok, Severity::style, ""noExplicitConstructor"", ""$symbol:"" + classname + '\\n' + message + '\\n' + verbose, CWE398, Certainty::normal);
}",1,1,lib/checkclass.cpp,"CheckClass.noExplicitConstructorError:void(Token*,std.string&,bool)",<empty>,,false,1089,1094,noExplicitConstructorError,,,1,"void(Token*,std.string&,bool)"
111669151329,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::uninitVarError(const Token *tok, bool isprivate, FunctionType functionType, const std::string &classname, const std::string &varname, bool derived, bool inconclusive)
{
    std::string ctor;
    if (functionType == FunctionType::eCopyConstructor)
        ctor = ""copy "";
    else if (functionType == FunctionType::eMoveConstructor)
        ctor = ""move "";
    std::string message(""Member variable '$symbol' is not initialized in the "" + ctor + ""constructor."");
    if (derived)
        message += "" Maybe it should be initialized directly in the class "" + classname + ""?"";
    std::string id = std::string(""uninit"") + (derived ? ""Derived"" : """") + ""MemberVar"" + (isprivate ? ""Private"" : """");
    const std::string verbose {message + "" Member variables of native types, pointers, or references are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior.""};
    reportError(tok, Severity::warning, id, ""$symbol:"" + classname + ""::"" + varname + '...",1,1,lib/checkclass.cpp,"CheckClass.uninitVarError:void(Token*,bool,FunctionType,std.string&,std.string&,bool,bool)",<empty>,,false,1096,1109,uninitVarError,,,1,"void(Token*,bool,FunctionType,std.string&,std.string&,bool,bool)"
111669151330,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::uninitVarError(const Token *tok, const std::string &classname, const std::string &varname)
{
    const std::string message(""Member variable '$symbol' is not initialized.""); // report missing in-class initializer
    const std::string verbose {message + "" Member variables of native types, pointers, or references are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior.""};
    const std::string id = std::string(""uninitMemberVarPrivate"");
    reportError(tok, Severity::warning, id, ""$symbol:"" + classname + ""::"" + varname + '\\n' + message + '\\n' + verbose, CWE398, Certainty::normal);
}",1,1,lib/checkclass.cpp,"CheckClass.uninitVarError:void(Token*,std.string&,std.string&)",<empty>,,false,1111,1117,uninitVarError,,,1,"void(Token*,std.string&,std.string&)"
111669151331,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::missingMemberCopyError(const Token *tok, FunctionType functionType, const std::string& classname, const std::string& varname)
{
    const std::string ctor(functionType == FunctionType::eCopyConstructor ? ""copy"" : ""move"");
    const std::string action(functionType == FunctionType::eCopyConstructor ? ""copied?"" : ""moved?"");
    const std::string message =
        ""$symbol:"" + classname + ""::"" + varname + ""\\n"" +
        ""Member variable '$symbol' is not assigned in the "" + ctor + "" constructor. Should it be "" + action;
    reportError(tok, Severity::warning, ""missingMemberCopy"", message, CWE398, Certainty::inconclusive);
}",1,1,lib/checkclass.cpp,"CheckClass.missingMemberCopyError:void(Token*,FunctionType,std.string&,std.string&)",<empty>,,false,1119,1127,missingMemberCopyError,,,1,"void(Token*,FunctionType,std.string&,std.string&)"
111669151332,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::operatorEqVarError(const Token *tok, const std::string &classname, const std::string &varname, bool inconclusive)
{
    reportError(tok, Severity::warning, ""operatorEqVarError"", ""$symbol:"" + classname + ""::"" + varname + ""\\nMember variable '$symbol' is not assigned a value in '"" + classname + ""::operator='."", CWE398, inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checkclass.cpp,"CheckClass.operatorEqVarError:void(Token*,std.string&,std.string&,bool)",<empty>,,false,1129,1132,operatorEqVarError,,,1,"void(Token*,std.string&,std.string&,bool)"
111669151333,METHOD,<empty>,<empty>,"[&](const Token *rhs) {
                if (rhs->str() == ""."" && rhs->astOperand1() && rhs->astOperand1()->variable() && rhs->astOperand1()->variable()->isLocal())
                    localmember = true;
                return ChildrenToVisit::op1_and_op2;
            }",27,13,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.initializationListUsage.<lambda>12:ChildrenToVisit(Token*),<empty>,,false,1180,1184,<lambda>12,,,1,ChildrenToVisit(Token*)
111669151334,METHOD,<empty>,<empty>,"[&](const Token *tok2) {
                const Variable* var2 = tok2->variable();
                if (var2) {
                    if (var2->scope() == owner && tok2->strAt(-1)!=""."") { // Is there a dependency between two member variables?
                        allowed = false;
                        return ChildrenToVisit::done;
                    }
                    if (var2->isArray() && var2->isLocal()) { // Can't initialize with a local array
                        allowed = false;
                        return ChildrenToVisit::done;
                    }
                } else if (tok2->str() == ""this"") { // 'this' instance is not completely constructed in initialization list
                    allowed = false;
                    return ChildrenToVisit::done;
                } else if (Token::Match(tok2, ""%name% ("") && tok2->strAt(-1) != ""."" && isMemberFunc(owner, tok2)) { // Member function called?
                    allowed = false;
                    return Child...",27,13,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.initializationListUsage.<lambda>13:ChildrenToVisit(Token*),<empty>,,false,1190,1209,<lambda>13,,,1,ChildrenToVisit(Token*)
111669151335,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::initializationListUsage()
{
    if (!mSettings->severity.isEnabled(Severity::performance))
        return;

    logChecker(""CheckClass::initializationListUsage""); // performance

    for (const Scope *scope : mSymbolDatabase->functionScopes) {
        // Check every constructor
        if (!scope->function || !scope->function->isConstructor())
            continue;

        // Do not warn when a delegate constructor is called
        if (const Token *initList = scope->function->constructorMemberInitialization()) {
            if (Token::Match(initList, "": %name% {|("") && initList->strAt(1) == scope->className)
                continue;
        }

        const Scope* owner = scope->functionOf;
        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
            if (Token::Match(tok, ""%name% ("")) // Assignments might depend on this function call or if/for/while/switch statement from now on.
                break;
            if (T...",1,17,lib/checkclass.cpp,CheckClass.initializationListUsage:void(),<empty>,,false,1138,1216,initializationListUsage,,,1,void()
111669151336,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::suggestInitializationList(const Token* tok, const std::string& varname)
{
    reportError(tok, Severity::performance, ""useInitializationList"", ""$symbol:"" + varname + ""\\nVariable '$symbol' is assigned in constructor body. Consider performing initialization in initialization list.\\n""
                ""When an object of a class is created, the constructors of all member variables are called consecutively ""
                ""in the order the variables are declared, even if you don't explicitly write them to the initialization list. You ""
                ""could avoid assigning '$symbol' a value by passing the value to the constructor in the initialization list."", CWE398, Certainty::normal);
}",1,1,lib/checkclass.cpp,"CheckClass.suggestInitializationList:void(Token*,std.string&)",<empty>,,false,1218,1224,suggestInitializationList,,,1,"void(Token*,std.string&)"
111669151337,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"static bool checkFunctionUsage(const Function *privfunc, const Scope* scope)
{
    if (!scope)
        return true; // Assume it is used, if scope is not seen

    for (auto func = scope->functionList.cbegin(); func != scope->functionList.cend(); ++func) {
        if (func->functionScope) {
            if (Token::Match(func->tokenDef, ""%name% ("")) {
                for (const Token *ftok = func->tokenDef->tokAt(2); ftok && ftok->str() != "")""; ftok = ftok->next()) {
                    if (Token::Match(ftok, ""= %name% [(,)]"") && ftok->strAt(1) == privfunc->name())
                        return true;
                    if (ftok->str() == ""("")
                        ftok = ftok->link();
                }
            }
            for (const Token *ftok = func->functionScope->classDef->linkAt(1); ftok != func->functionScope->bodyEnd; ftok = ftok->next()) {
                if (ftok->function() == privfunc)
                    return true;
                if (ftok->varId() == 0U && fto...",1,1,lib/checkclass.cpp,"checkFunctionUsage:bool(Function*,Scope*)",<empty>,,false,1230,1277,checkFunctionUsage,,,1,"bool(Function*,Scope*)"
111669151338,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::privateFunctions()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""unusedPrivateFunction""))
        return;

    logChecker(""CheckClass::privateFunctions""); // style

    for (const Scope * scope : mSymbolDatabase->classAndStructScopes) {

        // do not check borland classes with properties..
        if (Token::findsimplematch(scope->bodyStart, ""; __property ;"", scope->bodyEnd))
            continue;

        std::list<const Function*> privateFuncs;
        for (const Function &func : scope->functionList) {
            // Get private functions..
            if (func.type == FunctionType::eFunction && func.access == AccessControl::Private && !func.isOperator()) // TODO: There are smarter ways to check private operator usage
                privateFuncs.push_back(&func);
        }

        // Bailout for overridden virtual functions of base classes
        if (!scope->definedType->derivedFrom.empty()) {
            // Che...",1,1,lib/checkclass.cpp,CheckClass.privateFunctions:void(),<empty>,,false,1279,1333,privateFunctions,,,1,void()
111669151339,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::unusedPrivateFunctionError(const Token *tok, const std::string &classname, const std::string &funcname)
{
    reportError(tok, Severity::style, ""unusedPrivateFunction"", ""$symbol:"" + classname + ""::"" + funcname + ""\\nUnused private function: '$symbol'"", CWE398, Certainty::normal);
}",1,1,lib/checkclass.cpp,"CheckClass.unusedPrivateFunctionError:void(Token*,std.string&,std.string&)",<empty>,,false,1335,1338,unusedPrivateFunctionError,,,1,"void(Token*,std.string&,std.string&)"
111669151340,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"static const Scope* findFunctionOf(const Scope* scope)
{
    while (scope) {
        if (scope->type == ScopeType::eFunction)
            return scope->functionOf;
        scope = scope->nestedIn;
    }
    return nullptr;
}",1,1,lib/checkclass.cpp,findFunctionOf:Scope*(Scope*),<empty>,,false,1344,1352,findFunctionOf,,,1,Scope*(Scope*)
111669151341,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::checkMemset()
{
    logChecker(""CheckClass::checkMemset"");
    const bool printWarnings = mSettings->severity.isEnabled(Severity::warning);
    for (const Scope *scope : mSymbolDatabase->functionScopes) {
        for (const Token *tok = scope->bodyStart; tok && tok != scope->bodyEnd; tok = tok->next()) {
            if (Token::Match(tok, ""memset|memcpy|memmove ("")) {
                const Token* arg1 = tok->tokAt(2);
                const Token* arg3 = arg1->nextArgument();
                if (arg3)
                    arg3 = arg3->nextArgument();
                if (!arg3)
                    // weird, shouldn't happen: memset etc should have
                    // 3 arguments.
                    continue;

                const Token *typeTok = nullptr;
                const Scope *type = nullptr;
                const Token* sizeofTok = arg3->previous()->astOperand2(); // try to find sizeof() in argument expression
                if (sizeofTok && sizeofTok->ast...",1,1,lib/checkclass.cpp,CheckClass.checkMemset:void(),<empty>,,false,1354,1449,checkMemset,,,1,void()
111669151342,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::checkMemsetType(const Scope *start, const Token *tok, const Scope *type, bool allocation, std::set<const Scope *> parsedTypes)
{
    // If type has been checked there is no need to check it again
    if (parsedTypes.find(type) != parsedTypes.end())
        return;
    parsedTypes.insert(type);

    const bool printPortability = mSettings->severity.isEnabled(Severity::portability);

    // recursively check all parent classes
    for (const Type::BaseInfo & i : type->definedType->derivedFrom) {
        const Type* derivedFrom = i.type;
        if (derivedFrom && derivedFrom->classScope)
            checkMemsetType(start, tok, derivedFrom->classScope, allocation, parsedTypes);
    }

    // Warn if type is a class that contains any virtual functions
    for (const Function &func : type->functionList) {
        if (func.hasVirtualSpecifier()) {
            if (allocation)
                mallocOnClassError(tok, tok->str(), type->classDef, ""virtual function"");
         ...",1,1,lib/checkclass.cpp,"CheckClass.checkMemsetType:void(Scope*,Token*,Scope*,bool,std.set<constScope*>)",<empty>,,false,1451,1515,checkMemsetType,,,1,"void(Scope*,Token*,Scope*,bool,std.set<constScope*>)"
111669151343,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::mallocOnClassWarning(const Token* tok, const std::string &memfunc, const Token* classTok)
{
    std::list<const Token *> toks = { tok, classTok };
    reportError(toks, Severity::warning, ""mallocOnClassWarning"",
                ""$symbol:"" + memfunc +""\\n""
                ""Memory for class instance allocated with $symbol(), but class provides constructors.\\n""
                ""Memory for class instance allocated with $symbol(), but class provides constructors. This is unsafe, ""
                ""since no constructor is called and class members remain uninitialized. Consider using 'new' instead."", CWE762, Certainty::normal);
}",1,1,lib/checkclass.cpp,"CheckClass.mallocOnClassWarning:void(Token*,std.string&,Token*)",<empty>,,false,1517,1525,mallocOnClassWarning,,,1,"void(Token*,std.string&,Token*)"
111669151344,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::mallocOnClassError(const Token* tok, const std::string &memfunc, const Token* classTok, const std::string &classname)
{
    std::list<const Token *> toks = { tok, classTok };
    reportError(toks, Severity::error, ""mallocOnClassError"",
                ""$symbol:"" + memfunc +""\\n""
                ""$symbol:"" + classname +""\\n""
                ""Memory for class instance allocated with "" + memfunc + ""(), but class contains a "" + classname + "".\\n""
                ""Memory for class instance allocated with "" + memfunc + ""(), but class a "" + classname + "". This is unsafe, ""
                ""since no constructor is called and class members remain uninitialized. Consider using 'new' instead."", CWE665, Certainty::normal);
}",1,1,lib/checkclass.cpp,"CheckClass.mallocOnClassError:void(Token*,std.string&,Token*,std.string&)",<empty>,,false,1527,1536,mallocOnClassError,,,1,"void(Token*,std.string&,Token*,std.string&)"
111669151345,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::memsetError(const Token *tok, const std::string &memfunc, const std::string &classname, const std::string &type, bool isContainer)
{
    const std::string typeStr = isContainer ? std::string() : (type + "" that contains a "");
    const std::string msg = ""$symbol:"" + memfunc + ""\\n""
                            ""$symbol:"" + classname + ""\\n""
                            ""Using '"" + memfunc + ""' on "" + typeStr + classname + "".\\n""
                            ""Using '"" + memfunc + ""' on "" + typeStr + classname + "" is unsafe, because constructor, destructor ""
                            ""and copy operator calls are omitted. These are necessary for this non-POD type to ensure that a valid object ""
                            ""is created."";
    reportError(tok, Severity::error, ""memsetClass"", msg, CWE762, Certainty::normal);
}",1,1,lib/checkclass.cpp,"CheckClass.memsetError:void(Token*,std.string&,std.string&,std.string&,bool)",<empty>,,false,1538,1548,memsetError,,,1,"void(Token*,std.string&,std.string&,std.string&,bool)"
111669151346,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::memsetErrorReference(const Token *tok, const std::string &memfunc, const std::string &type)
{
    reportError(tok, Severity::error, ""memsetClassReference"",
                ""$symbol:"" + memfunc +""\\n""
                ""Using '"" + memfunc + ""' on "" + type + "" that contains a reference."", CWE665, Certainty::normal);
}",1,1,lib/checkclass.cpp,"CheckClass.memsetErrorReference:void(Token*,std.string&,std.string&)",<empty>,,false,1550,1555,memsetErrorReference,,,1,"void(Token*,std.string&,std.string&)"
111669151347,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::memsetErrorFloat(const Token *tok, const std::string &type)
{
    reportError(tok, Severity::portability, ""memsetClassFloat"", ""Using memset() on "" + type + "" which contains a floating point number.\\n""
                ""Using memset() on "" + type + "" which contains a floating point number.""
                "" This is not portable because memset() sets each byte of a block of memory to a specific value and""
                "" the actual representation of a floating-point value is implementation defined.""
                "" Note: In case of an IEEE754-1985 compatible implementation setting all bits to zero results in the value 0.0."", CWE758, Certainty::normal);
}",1,1,lib/checkclass.cpp,"CheckClass.memsetErrorFloat:void(Token*,std.string&)",<empty>,,false,1557,1564,memsetErrorFloat,,,1,"void(Token*,std.string&)"
111669151348,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::operatorEqRetRefThis()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""operatorEqRetRefThis""))
        return;

    logChecker(""CheckClass::operatorEqRetRefThis""); // style

    for (const Scope * scope : mSymbolDatabase->classAndStructScopes) {
        for (auto func = scope->functionList.cbegin(); func != scope->functionList.cend(); ++func) {
            if (func->type == FunctionType::eOperatorEqual && func->hasBody()) {
                // make sure return signature is correct
                if (func->retType == func->nestedIn->definedType && func->tokenDef->strAt(-1) == ""&"") {
                    checkReturnPtrThis(scope, &(*func), func->functionScope->bodyStart, func->functionScope->bodyEnd);
                }
            }
        }
    }
}",1,1,lib/checkclass.cpp,CheckClass.operatorEqRetRefThis:void(),<empty>,,false,1572,1589,operatorEqRetRefThis,,,1,void()
111669151349,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::checkReturnPtrThis(const Scope *scope, const Function *func, const Token *tok, const Token *last)
{
    std::set<const Function*> analyzedFunctions;
    checkReturnPtrThis(scope, func, tok, last, analyzedFunctions);
}",1,1,lib/checkclass.cpp,"CheckClass.checkReturnPtrThis:void(Scope*,Function*,Token*,Token*)",<empty>,,false,1591,1595,checkReturnPtrThis,,,1,"void(Scope*,Function*,Token*,Token*)"
111669151350,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::checkReturnPtrThis(const Scope *scope, const Function *func, const Token *tok, const Token *last, std::set<const Function*>& analyzedFunctions)
{
    bool foundReturn = false;

    const Token* const startTok = tok;

    for (; tok && tok != last; tok = tok->next()) {
        // check for return of reference to this

        if (const Token* lScope = isLambdaCaptureList(tok)) // skip lambda
            tok = lScope->link();

        if (tok->str() != ""return"")
            continue;

        foundReturn = true;

        const Token *retExpr = tok->astOperand1();
        if (retExpr && retExpr->str() == ""="")
            retExpr = retExpr->astOperand1();
        if (retExpr && retExpr->isUnaryOp(""*"") && Token::simpleMatch(retExpr->astOperand1(), ""this""))
            continue;

        std::string cast(""( "" + scope->className + "" & )"");
        if (Token::simpleMatch(tok->next(), cast.c_str(), cast.size()))
            tok = tok->tokAt(4);

        // check if a functio...",1,1,lib/checkclass.cpp,"CheckClass.checkReturnPtrThis:void(Scope*,Function*,Token*,Token*,std.set<constFunction*>&)",<empty>,,false,1597,1681,checkReturnPtrThis,,,1,"void(Scope*,Function*,Token*,Token*,std.set<constFunction*>&)"
111669151351,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::operatorEqRetRefThisError(const Token *tok)
{
    reportError(tok, Severity::style, ""operatorEqRetRefThis"", ""'operator=' should return reference to 'this' instance."", CWE398, Certainty::normal);
}",1,1,lib/checkclass.cpp,CheckClass.operatorEqRetRefThisError:void(Token*),<empty>,,false,1683,1686,operatorEqRetRefThisError,,,1,void(Token*)
111669151352,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::operatorEqShouldBeLeftUnimplementedError(const Token *tok)
{
    reportError(tok, Severity::style, ""operatorEqShouldBeLeftUnimplemented"", ""'operator=' should either return reference to 'this' instance or be declared private and left unimplemented."", CWE398, Certainty::normal);
}",1,1,lib/checkclass.cpp,CheckClass.operatorEqShouldBeLeftUnimplementedError:void(Token*),<empty>,,false,1688,1691,operatorEqShouldBeLeftUnimplementedError,,,1,void(Token*)
111669151353,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::operatorEqMissingReturnStatementError(const Token *tok, bool error)
{
    if (error) {
        reportError(tok, Severity::error, ""operatorEqMissingReturnStatement"", ""No 'return' statement in non-void function causes undefined behavior."", CWE398, Certainty::normal);
    } else {
        operatorEqRetRefThisError(tok);
    }
}",1,1,lib/checkclass.cpp,"CheckClass.operatorEqMissingReturnStatementError:void(Token*,bool)",<empty>,,false,1693,1700,operatorEqMissingReturnStatementError,,,1,"void(Token*,bool)"
111669151354,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::operatorEqToSelf()
{
    if (!mSettings->severity.isEnabled(Severity::warning) && !mSettings->isPremiumEnabled(""operatorEqToSelf""))
        return;

    logChecker(""CheckClass::operatorEqToSelf""); // warning

    for (const Scope * scope : mSymbolDatabase->classAndStructScopes) {
        // skip classes with multiple inheritance
        if (scope->definedType->derivedFrom.size() > 1)
            continue;

        for (const Function &func : scope->functionList) {
            if (func.type == FunctionType::eOperatorEqual && func.hasBody()) {
                // make sure that the operator takes an object of the same type as *this, otherwise we can't detect self-assignment checks
                if (func.argumentList.empty())
                    continue;
                const Token* typeTok = func.argumentList.front().typeEndToken();
                while (typeTok->str() == ""const"" || typeTok->str() == ""&"" || typeTok->str() == ""*"")
                    typeTok = typeT...",1,1,lib/checkclass.cpp,CheckClass.operatorEqToSelf:void(),<empty>,,false,1716,1755,operatorEqToSelf,,,1,void()
111669151355,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"bool CheckClass::hasAllocationInIfScope(const Function *func, const Scope* scope, const Token *ifStatementScopeStart) const
{
    const Token *end;
    if (ifStatementScopeStart->str() == ""{"")
        end = ifStatementScopeStart->link();
    else
        end = func->functionScope->bodyEnd;
    return hasAllocation(func, scope, ifStatementScopeStart, end);
}",1,1,lib/checkclass.cpp,"CheckClass.hasAllocationInIfScope<const>:bool(Function*,Scope*,Token*)",<empty>,,false,1757,1765,hasAllocationInIfScope,,,1,"bool(Function*,Scope*,Token*)"
111669151356,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"bool CheckClass::hasAllocation(const Function *func, const Scope* scope) const
{
    return hasAllocation(func, scope, func->functionScope->bodyStart, func->functionScope->bodyEnd);
}",1,1,lib/checkclass.cpp,"CheckClass.hasAllocation<const>:bool(Function*,Scope*)",<empty>,,false,1767,1770,hasAllocation,,,1,"bool(Function*,Scope*)"
111669151357,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"bool CheckClass::hasAllocation(const Function *func, const Scope* scope, const Token *start, const Token *end) const
{
    if (!end)
        end = func->functionScope->bodyEnd;
    for (const Token *tok = start; tok && (tok != end); tok = tok->next()) {
        if (((tok->isCpp() && Token::Match(tok, ""%var% = new"")) ||
             (Token::Match(tok, ""%var% = %name% ("") && mSettings->library.getAllocFuncInfo(tok->tokAt(2)))) &&
            isMemberVar(scope, tok))
            return true;

        // check for deallocating memory
        const Token *var;
        if (Token::Match(tok, ""%name% ( %var%"") && mSettings->library.getDeallocFuncInfo(tok))
            var = tok->tokAt(2);
        else if (tok->isCpp() && Token::Match(tok, ""delete [ ] %var%""))
            var = tok->tokAt(3);
        else if (tok->isCpp() && Token::Match(tok, ""delete %var%""))
            var = tok->next();
        else
            continue;
        // Check for assignment to the deleted pointer (only if its ...",1,1,lib/checkclass.cpp,"CheckClass.hasAllocation<const>:bool(Function*,Scope*,Token*,Token*)",<empty>,,false,1772,1802,hasAllocation,,,1,"bool(Function*,Scope*,Token*,Token*)"
111669151358,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"static bool isTrueKeyword(const Token* tok)
{
    return tok->hasKnownIntValue() && tok->getKnownIntValue() == 1;
}",1,1,lib/checkclass.cpp,isTrueKeyword:bool(Token*),<empty>,,false,1804,1807,isTrueKeyword,,,1,bool(Token*)
111669151359,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"static bool isFalseKeyword(const Token* tok)
{
    return tok->hasKnownIntValue() && tok->getKnownIntValue() == 0;
}",1,1,lib/checkclass.cpp,isFalseKeyword:bool(Token*),<empty>,,false,1809,1812,isFalseKeyword,,,1,bool(Token*)
111669151360,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"CheckClass::Bool CheckClass::isInverted(const Token *tok, const Token *rhs)
{
    bool res = true;
    for (const Token *itr = tok; itr && itr->str()!=""(""; itr=itr->astParent()) {
        if (Token::simpleMatch(itr, ""!="") && (isTrueKeyword(itr->astOperand1()) || isTrueKeyword(itr->astOperand2()))) {
            res = !res;
        } else if (Token::simpleMatch(itr, ""!="") && ((Token::simpleMatch(itr->astOperand1(), ""this"") && Token::simpleMatch(itr->astOperand2(), ""&"") && Token::simpleMatch(itr->astOperand2()->next(), rhs->str().c_str(), rhs->str().size()))
                                                     || (Token::simpleMatch(itr->astOperand2(), ""this"") && Token::simpleMatch(itr->astOperand1(), ""&"") && Token::simpleMatch(itr->astOperand1()->next(), rhs->str().c_str(), rhs->str().size())))) {
            res = !res;
        } else if (Token::simpleMatch(itr, ""!="") && (isFalseKeyword(itr->astOperand1()) || isFalseKeyword(itr->astOperand2()))) {
            //Do nothing
        } ...",1,1,lib/checkclass.cpp,"CheckClass.isInverted:CheckClass.Bool(Token*,Token*)",<empty>,,false,1818,1845,isInverted,,,1,"CheckClass.Bool(Token*,Token*)"
111669151361,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"const Token * CheckClass::getIfStmtBodyStart(const Token *tok, const Token *rhs)
{
    const Token *top = tok->astTop();
    if (Token::simpleMatch(top->link(), "") {"")) {
        switch (isInverted(tok->astParent(), rhs)) {
        case Bool::BAILOUT:
            return nullptr;
        case Bool::TRUE:
            return top->link()->next();
        case Bool::FALSE:
            return top->link()->linkAt(1);
        }
    }
    return nullptr;
}",1,1,lib/checkclass.cpp,"CheckClass.getIfStmtBodyStart:Token*(Token*,Token*)",<empty>,,false,1847,1861,getIfStmtBodyStart,,,1,"Token*(Token*,Token*)"
111669151362,METHOD,<empty>,<empty>,"[&](const Token *tok2) {
            if (!Token::Match(tok2, ""==|!=""))
                return ChildrenToVisit::op1_and_op2;
            if (Token::simpleMatch(tok2->astOperand1(), ""this""))
                tok2 = tok2->astOperand2();
            else if (Token::simpleMatch(tok2->astOperand2(), ""this""))
                tok2 = tok2->astOperand1();
            else
                return ChildrenToVisit::op1_and_op2;
            if (tok2 && tok2->isUnaryOp(""&"") && tok2->astOperand1()->str() == rhs->str())
                ret = true;
            if (ret) {
                out_ifStatementScopeStart = getIfStmtBodyStart(tok2, rhs);
            }
            return ret ? ChildrenToVisit::done : ChildrenToVisit::op1_and_op2;
        }",23,9,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.hasAssignSelf.<lambda>14:ChildrenToVisit(Token*),<empty>,,false,1874,1889,<lambda>14,,,1,ChildrenToVisit(Token*)
111669151363,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"bool CheckClass::hasAssignSelf(const Function *func, const Token *rhs, const Token *&out_ifStatementScopeStart)
{
    if (!rhs)
        return false;
    const Token *last = func->functionScope->bodyEnd;
    for (const Token *tok = func->functionScope->bodyStart; tok && tok != last; tok = tok->next()) {
        if (!Token::simpleMatch(tok, ""if (""))
            continue;

        bool ret = false;
        visitAstNodes(tok->next()->astOperand2(),
                      [&](const Token *tok2) {
            if (!Token::Match(tok2, ""==|!=""))
                return ChildrenToVisit::op1_and_op2;
            if (Token::simpleMatch(tok2->astOperand1(), ""this""))
                tok2 = tok2->astOperand2();
            else if (Token::simpleMatch(tok2->astOperand2(), ""this""))
                tok2 = tok2->astOperand1();
            else
                return ChildrenToVisit::op1_and_op2;
            if (tok2 && tok2->isUnaryOp(""&"") && tok2->astOperand1()->str() == rhs->str())
                re...",1,1,lib/checkclass.cpp,"CheckClass.hasAssignSelf:bool(Function*,Token*,Token*&)",<empty>,,false,1863,1895,hasAssignSelf,,,1,"bool(Function*,Token*,Token*&)"
111669151364,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::operatorEqToSelfError(const Token *tok)
{
    reportError(tok, Severity::warning, ""operatorEqToSelf"",
                ""'operator=' should check for assignment to self to avoid problems with dynamic memory.\\n""
                ""'operator=' should check for assignment to self to ensure that each block of dynamically ""
                ""allocated memory is owned and managed by only one instance of the class."", CWE398, Certainty::normal);
}",1,1,lib/checkclass.cpp,CheckClass.operatorEqToSelfError:void(Token*),<empty>,,false,1897,1903,operatorEqToSelfError,,,1,void(Token*)
111669151365,METHOD,<empty>,<empty>,"[](const Function& func) {
                        return func.hasVirtualSpecifier();
                    }",95,21,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.virtualDestructor.<lambda>15:bool(Function&),<empty>,,false,1930,1932,<lambda>15,,,1,bool(Function&)
111669151366,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::virtualDestructor()
{
    // This error should only be given if:
    // * base class doesn't have virtual destructor
    // * derived class has non-empty destructor (only c++03, in c++11 it's UB see paragraph 3 in [expr.delete])
    // * base class is deleted
    // unless inconclusive in which case:
    // * A class with any virtual functions should have a destructor that is either public and virtual or protected
    const bool printInconclusive = mSettings->certainty.isEnabled(Certainty::inconclusive);

    std::list<const Function *> inconclusiveErrors;

    logChecker(""CheckClass::virtualDestructor"");

    for (const Scope * scope : mSymbolDatabase->classAndStructScopes) {

        // Skip base classes (unless inconclusive)
        if (scope->definedType->derivedFrom.empty()) {
            if (printInconclusive) {
                const Function *destructor = scope->getDestructor();
                if (destructor && !destructor->hasVirtualSpecifier() && destructo...",1,1,lib/checkclass.cpp,CheckClass.virtualDestructor:void(),<empty>,,false,1909,2042,virtualDestructor,,,1,void()
111669151367,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::virtualDestructorError(const Token *tok, const std::string &Base, const std::string &Derived, bool inconclusive)
{
    if (inconclusive) {
        if (mSettings->severity.isEnabled(Severity::warning))
            reportError(tok, Severity::warning, ""virtualDestructor"", ""$symbol:"" + Base + ""\\nClass '$symbol' which has virtual members does not have a virtual destructor."", CWE404, Certainty::inconclusive);
    } else {
        reportError(tok, Severity::error, ""virtualDestructor"",
                    ""$symbol:"" + Base +""\\n""
                    ""$symbol:"" + Derived +""\\n""
                    ""Class '"" + Base + ""' which is inherited by class '"" + Derived + ""' does not have a virtual destructor.\\n""
                    ""Class '"" + Base + ""' which is inherited by class '"" + Derived + ""' does not have a virtual destructor. ""
                    ""If you destroy instances of the derived class by deleting a pointer that points to the base class, only ""
                    ""the d...",1,1,lib/checkclass.cpp,"CheckClass.virtualDestructorError:void(Token*,std.string&,std.string&,bool)",<empty>,,false,2044,2059,virtualDestructorError,,,1,"void(Token*,std.string&,std.string&,bool)"
111669151368,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::thisSubtraction()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckClass::thisSubtraction""); // warning

    const Token *tok = mTokenizer->tokens();
    for (;;) {
        tok = Token::findmatch(tok, ""this - %name%"");
        if (!tok)
            break;

        if (tok->strAt(-1) != ""*"")
            thisSubtractionError(tok);

        tok = tok->next();
    }
}",1,1,lib/checkclass.cpp,CheckClass.thisSubtraction:void(),<empty>,,false,2065,2083,thisSubtraction,,,1,void()
111669151369,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::thisSubtractionError(const Token *tok)
{
    reportError(tok, Severity::warning, ""thisSubtraction"", ""Suspicious pointer subtraction. Did you intend to write '->'?"", CWE398, Certainty::normal);
}",1,1,lib/checkclass.cpp,CheckClass.thisSubtractionError:void(Token*),<empty>,,false,2085,2088,thisSubtractionError,,,1,void(Token*)
111669151370,METHOD,<empty>,<empty>,"[this](const Token* start, const Token* end) -> bool {
                bool inTemplArgList = false, isConstTemplArg = false;
                for (const Token* tok = start; tok != end; tok = tok->next()) {
                    if (tok->str() == ""{"") // end of trailing return type
                        return false;
                    if (tok->str() == ""<"") {
                        if (!tok->link())
                            mSymbolDatabase->debugMessage(tok, ""debug"", ""CheckClass::checkConst found unlinked template argument list '"" + tok->expressionString() + ""'."");
                        inTemplArgList = true;
                    }
                    else if (tok->str() == "">"") {
                        inTemplArgList = false;
                        isConstTemplArg = false;
                    }
                    else if (tok->str() == ""const"") {
                        if (!inTemplArgList)
                            return false;
                        isConstTemplArg = ...",41,13,lib/checkclass.cpp,"lib/checkclass.cpp:<global>.CheckClass.checkConst.<lambda>16:bool(Token*,Token*)",<empty>,,false,2121,2144,<lambda>16,,,1,"bool(Token*,Token*)"
111669151371,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::checkConst()
{
    // This is an inconclusive check. False positives: #3322.
    if (!mSettings->certainty.isEnabled(Certainty::inconclusive))
        return;

    if (!mSettings->severity.isEnabled(Severity::style) &&
        !mSettings->isPremiumEnabled(""functionConst"") &&
        !mSettings->isPremiumEnabled(""functionStatic""))
        return;

    logChecker(""CheckClass::checkConst""); // style,inconclusive

    for (const Scope * scope : mSymbolDatabase->classAndStructScopes) {
        for (const Function &func : scope->functionList) {
            // does the function have a body?
            if (func.type != FunctionType::eFunction || !func.hasBody())
                continue;
            // don't warn for friend/static/virtual functions
            if (func.isFriend() || func.isStatic() || func.hasVirtualSpecifier())
                continue;
            if (func.functionPointerUsage)
                continue;
            if (func.hasRvalRefQualifier())
       ...",1,1,lib/checkclass.cpp,CheckClass.checkConst:void(),<empty>,,false,2094,2208,checkConst,,,1,void()
111669151372,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"static const Token* getFuncTokFromThis(const Token* tok) {
    if (!Token::simpleMatch(tok->next(), "".""))
        return nullptr;
    tok = tok->tokAt(2);
    while (Token::Match(tok, ""%name% ::""))
        tok = tok->tokAt(2);
    return Token::Match(tok, ""%name% ("") ? tok : nullptr;
}",1,1,lib/checkclass.cpp,getFuncTokFromThis:Token*(Token*),<empty>,,false,2211,2218,getFuncTokFromThis,,,1,Token*(Token*)
111669151373,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"bool CheckClass::isMemberVar(const Scope *scope, const Token *tok) const
{
    bool again = false;

    // try to find the member variable
    do {
        again = false;

        if (tok->str() == ""this"")
            return !getFuncTokFromThis(tok); // function calls are handled elsewhere
        if (Token::simpleMatch(tok->tokAt(-3), ""( * this )""))
            return true;
        if (Token::Match(tok->tokAt(-3), ""%name% ) . %name%"")) {
            tok = tok->tokAt(-3);
            again = true;
        } else if (Token::Match(tok->tokAt(-2), ""%name% . %name%"")) {
            tok = tok->tokAt(-2);
            again = true;
        } else if (Token::Match(tok->tokAt(-2), ""] . %name%"")) {
            tok = tok->linkAt(-2)->previous();
            again = true;
        } else if (tok->str() == ""]"") {
            tok = tok->link()->previous();
            again = true;
        }
    } while (again);

    if (tok->isKeyword() || tok->isStandardType())
        return false;

    for (co...",1,1,lib/checkclass.cpp,"CheckClass.isMemberVar<const>:bool(Scope*,Token*)",<empty>,,false,2220,2298,isMemberVar,,,1,"bool(Scope*,Token*)"
111669151374,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"bool CheckClass::isMemberFunc(const Scope *scope, const Token *tok)
{
    if (!tok->function()) {
        for (const Function &func : scope->functionList) {
            if (func.name() == tok->str()) {
                const Token* tok2 = tok->tokAt(2);
                int argsPassed = tok2->str() == "")"" ? 0 : 1;
                for (;;) {
                    tok2 = tok2->nextArgument();
                    if (tok2)
                        argsPassed++;
                    else
                        break;
                }
                if (argsPassed == func.argCount() ||
                    (func.isVariadic() && argsPassed >= (func.argCount() - 1)) ||
                    (argsPassed < func.argCount() && argsPassed >= func.minArgCount()))
                    return true;
            }
        }
    } else if (tok->function()->nestedIn == scope)
        return !tok->function()->isStatic();

    // not found in this class
    if (!scope->definedType->derivedFrom.empty()) {
     ...",1,1,lib/checkclass.cpp,"CheckClass.isMemberFunc:bool(Scope*,Token*)",<empty>,,false,2300,2339,isMemberFunc,,,1,"bool(Scope*,Token*)"
111669151375,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"bool CheckClass::isConstMemberFunc(const Scope *scope, const Token *tok)
{
    if (!tok->function())
        return false;
    if (tok->function()->nestedIn == scope)
        return tok->function()->isConst();

    // not found in this class
    if (!scope->definedType->derivedFrom.empty()) {
        // check each base class
        for (const Type::BaseInfo & i : scope->definedType->derivedFrom) {
            // find the base class
            const Type *derivedFrom = i.type;

            // find the function in the base class
            if (derivedFrom && derivedFrom->classScope) {
                if (isConstMemberFunc(derivedFrom->classScope, tok))
                    return true;
            }
        }
    }

    return false;
}",1,1,lib/checkclass.cpp,"CheckClass.isConstMemberFunc:bool(Scope*,Token*)",<empty>,,false,2341,2364,isConstMemberFunc,,,1,"bool(Scope*,Token*)"
111669151376,METHOD,<empty>,<empty>,"[](const Token* tok) -> const Token* {
        if (Token::simpleMatch(tok, ""this""))
            tok = getFuncTokFromThis(tok);
        bool isReturn = false;
        if ((Token::Match(tok, ""%name% (|{"") || (isReturn = Token::simpleMatch(tok->astParent(), ""return {""))) && !tok->isStandardType() && !tok->isKeyword()) {
            if (isReturn)
                tok = tok->astParent();
            return tok;
        }
        return nullptr;
    }",23,5,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.checkConstFunc<const>.<lambda>17:Token(Token*),<empty>,,false,2373,2383,<lambda>17,,,1,Token(Token*)
111669151377,METHOD,<empty>,<empty>,"[this, &memberAccessed](const Token* funcTok, const Scope* scope, const Function* func) {
        if (isMemberFunc(scope, funcTok) && (funcTok->strAt(-1) != ""."" || Token::simpleMatch(funcTok->tokAt(-2), ""this .""))) {
            const bool isSelf = func == funcTok->function();
            if (!isConstMemberFunc(scope, funcTok) && !isSelf)
                return false;
            memberAccessed = (isSelf && memberAccessed != MemberAccess::MEMBER) ? MemberAccess::SELF : MemberAccess::MEMBER;
        }

        if (const Function* f = funcTok->function()) { // check known function
            const std::vector<const Token*> args = getArguments(funcTok);
            const auto argMax = std::min<nonneg int>(args.size(), f->argCount());

            for (nonneg int argIndex = 0; argIndex < argMax; ++argIndex) {
                const Variable* const argVar = f->getArgumentVar(argIndex);
                if (!argVar || ((argVar->isArrayOrPointer() || argVar->isReference()) &&
              ...",26,41,lib/checkclass.cpp,"lib/checkclass.cpp:<global>.CheckClass.checkConstFunc<const>.<lambda>18:bool(Token*,Scope*,Function*)",<empty>,,false,2385,2437,<lambda>18,,,1,"bool(Token*,Scope*,Function*)"
111669151378,METHOD,<empty>,<empty>,"[](const std::pair<std::string, const Function*>& fm) {
                                    return fm.second->isConst() && fm.first == ""operator[]"" && !Function::returnsConst(fm.second);
                                }",84,33,lib/checkclass.cpp,"lib/checkclass.cpp:<global>.CheckClass.checkConstFunc<const>.<lambda>19:bool(std.pair<std.string,constFunction*>&)",<empty>,,false,2512,2514,<lambda>19,,,1,"bool(std.pair<std.string,constFunction*>&)"
111669151379,METHOD,<empty>,<empty>,"[&op](const Function& f) {
                    return f.isConst() && f.name() == op;
                }",96,17,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.checkConstFunc<const>.<lambda>20.<lambda>21:bool(Function&),<empty>,,false,2532,2534,<lambda>21,,,1,bool(Function&)
111669151380,METHOD,<empty>,<empty>,"[](const Token* end, const Scope* scope) -> bool {
                if (!end || !scope || !Token::simpleMatch(end->astParent(), "".""))
                    return false;
                const std::string op = ""operator"" + end->astParent()->originalName();
                auto it = std::find_if(scope->functionList.begin(), scope->functionList.end(), [&op](const Function& f) {
                    return f.isConst() && f.name() == op;
                });
                if (it == scope->functionList.end() || !it->retType || !it->retType->classScope)
                    return false;
                const Function* func = it->retType->classScope->findFunction(end, /*requireConst*/ true);
                return func && func->isConst();
            }",46,13,lib/checkclass.cpp,"lib/checkclass.cpp:<global>.CheckClass.checkConstFunc<const>.<lambda>20:bool(Token*,Scope*)",<empty>,,false,2528,2539,<lambda>20,,,1,"bool(Token*,Scope*)"
111669151381,METHOD,<empty>,<empty>,"[&](const ValueType* vt) -> bool {
                if (!vt || !vt->container)
                    return false;
                const auto yield = vt->container->getYield(end->str());
                if (yield == Library::Container::Yield::START_ITERATOR || yield == Library::Container::Yield::END_ITERATOR) {
                    const Token* parent = tok1->astParent();
                    while (Token::Match(parent, ""(|.|::""))
                        parent = parent->astParent();
                    if (parent && parent->isComparisonOp())
                        return true;
                    // TODO: use AST
                    if (parent && parent->isAssignmentOp() && tok1->tokAt(-2)->variable() && Token::Match(tok1->tokAt(-2)->variable()->typeEndToken(), ""const_iterator|const_reverse_iterator""))
                        return true;
                }
                if ((yield == Library::Container::Yield::ITEM || yield == Library::Container::Yield::AT_INDEX) &&
                 ...",42,13,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.checkConstFunc<const>.<lambda>22:bool(ValueType*),<empty>,,false,2541,2559,<lambda>22,,,1,bool(ValueType*)
111669151382,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"bool CheckClass::checkConstFunc(const Scope *scope, const Function *func, MemberAccess& memberAccessed) const
{
    if (mTokenizer->hasIfdef(func->functionScope->bodyStart, func->functionScope->bodyEnd))
        return false;

    auto getFuncTok = [](const Token* tok) -> const Token* {
        if (Token::simpleMatch(tok, ""this""))
            tok = getFuncTokFromThis(tok);
        bool isReturn = false;
        if ((Token::Match(tok, ""%name% (|{"") || (isReturn = Token::simpleMatch(tok->astParent(), ""return {""))) && !tok->isStandardType() && !tok->isKeyword()) {
            if (isReturn)
                tok = tok->astParent();
            return tok;
        }
        return nullptr;
    };

    auto checkFuncCall = [this, &memberAccessed](const Token* funcTok, const Scope* scope, const Function* func) {
        if (isMemberFunc(scope, funcTok) && (funcTok->strAt(-1) != ""."" || Token::simpleMatch(funcTok->tokAt(-2), ""this .""))) {
            const bool isSelf = func == funcTok->functi...",1,41,lib/checkclass.cpp,"CheckClass.checkConstFunc<const>:bool(Scope*,Function*,CheckClass.MemberAccess&)",<empty>,,false,2368,2634,checkConstFunc,,,1,"bool(Scope*,Function*,CheckClass.MemberAccess&)"
111669151383,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::checkConstError(const Token *tok, const std::string &classname, const std::string &funcname, bool suggestStatic, bool foundAllBaseClasses)
{
    checkConstError2(tok, nullptr, classname, funcname, suggestStatic, foundAllBaseClasses);
}",1,1,lib/checkclass.cpp,"CheckClass.checkConstError:void(Token*,std.string&,std.string&,bool,bool)",<empty>,,false,2636,2639,checkConstError,,,1,"void(Token*,std.string&,std.string&,bool,bool)"
111669151384,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::checkConstError2(const Token *tok1, const Token *tok2, const std::string &classname, const std::string &funcname, bool suggestStatic, bool foundAllBaseClasses)
{
    std::list<const Token *> toks{ tok1 };
    if (tok2)
        toks.push_back(tok2);
    if (!suggestStatic) {
        const std::string msg = foundAllBaseClasses ?
                                ""Technically the member function '$symbol' can be const.\\nThe member function '$symbol' can be made a const "" :
                                ""Either there is a missing 'override', or the member function '$symbol' can be const.\\nUnless it overrides a base class member, the member function '$symbol' can be made a const "";
        reportError(toks, Severity::style, ""functionConst"",
                    ""$symbol:"" + classname + ""::"" + funcname +""\\n""
                    + msg +
                    ""function. Making this function 'const' should not cause compiler errors. ""
                    ""Even though the functi...",1,1,lib/checkclass.cpp,"CheckClass.checkConstError2:void(Token*,Token*,std.string&,std.string&,bool,bool)",<empty>,,false,2641,2671,checkConstError2,,,1,"void(Token*,Token*,std.string&,std.string&,bool,bool)"
111669151385,METHOD,VarInfo,TYPE_DECL,"VarInfo(const Variable *_var, const Token *_tok)
            : var(_var), tok(_tok) {}",9,37,lib/checkclass.cpp,"VarInfo.VarInfo:ANY(Variable*,Token*)",<empty>,,false,2679,2680,VarInfo,,,1,"VarInfo.VarInfo:ANY(Variable*,Token*)(Variable*,Token*)"
111669151386,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::initializerListOrder()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""initializerList""))
        return;

    // This check is not inconclusive.  However it only determines if the initialization
    // order is incorrect.  It does not determine if being out of order causes
    // a real error.  Out of order is not necessarily an error but you can never
    // have an error if the list is in order so this enforces defensive programming.
    if (!mSettings->certainty.isEnabled(Certainty::inconclusive))
        return;

    logChecker(""CheckClass::initializerListOrder""); // style,inconclusive

    for (const Scope * scope : mSymbolDatabase->classAndStructScopes) {

        // iterate through all member functions looking for constructors
        for (auto func = scope->functionList.cbegin(); func != scope->functionList.cend(); ++func) {
            if (func->isConstructor() && func->hasBody()) {
                // check for in...",1,1,lib/checkclass.cpp,CheckClass.initializerListOrder:void(),<empty>,,false,2688,2763,initializerListOrder,,,1,void()
111669151387,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::initializerListError(const Token *tok1, const Token *tok2, const std::string &classname, const std::string &varname, const std::string& argname)
{
    std::list<const Token *> toks = { tok1, tok2 };
    const std::string msg = argname.empty() ?
                            ""Member variable '$symbol' is in the wrong place in the initializer list."" :
                            ""Member variable '$symbol' uses an uninitialized argument '"" + argname + ""' due to the order of declarations."";
    reportError(toks, Severity::style, ""initializerList"",
                ""$symbol:"" + classname + ""::"" + varname + '\\n' +
                msg + '\\n' +
                msg + ' ' +
                ""Members are initialized in the order they are declared, not in the ""
                ""order they are in the initializer list. Keeping the initializer list ""
                ""in the same order that the members were declared prevents order dependent ""
                ""initialization errors."", C...",1,1,lib/checkclass.cpp,"CheckClass.initializerListError:void(Token*,Token*,std.string&,std.string&,std.string&)",<empty>,,false,2765,2779,initializerListError,,,1,"void(Token*,Token*,std.string&,std.string&,std.string&)"
111669151388,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::checkSelfInitialization()
{
    logChecker(""CheckClass::checkSelfInitialization"");

    for (const Scope *scope : mSymbolDatabase->functionScopes) {
        const Function* function = scope->function;
        if (!function || !function->isConstructor())
            continue;

        const Token* tok = function->arg->link()->next();
        if (tok->str() != "":"")
            continue;

        for (; tok != scope->bodyStart; tok = tok->next()) {
            if (Token::Match(tok, ""[:,] %var% (|{"")) {
                const Token* varTok = tok->next();
                if (Token::Match(varTok->astParent(), ""(|{"")) {
                    if (const Token* initTok = varTok->astParent()->astOperand2()) {
                        if (initTok->varId() == varTok->varId())
                            selfInitializationError(tok, varTok->str());
                        else if (initTok->isCast() && ((initTok->astOperand1() && initTok->astOperand1()->varId() == varTok->varId()) || ...",1,1,lib/checkclass.cpp,CheckClass.checkSelfInitialization:void(),<empty>,,false,2786,2813,checkSelfInitialization,,,1,void()
111669151389,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::selfInitializationError(const Token* tok, const std::string& varname)
{
    reportError(tok, Severity::error, ""selfInitialization"", ""$symbol:"" + varname + ""\\nMember variable '$symbol' is initialized by itself."", CWE665, Certainty::normal);
}",1,1,lib/checkclass.cpp,"CheckClass.selfInitializationError:void(Token*,std.string&)",<empty>,,false,2815,2818,selfInitializationError,,,1,"void(Token*,std.string&)"
111669151390,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::checkVirtualFunctionCallInConstructor()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;
    logChecker(""CheckClass::checkVirtualFunctionCallInConstructor""); // warning
    std::map<const Function *, std::list<const Token *>> virtualFunctionCallsMap;
    for (const Scope *scope : mSymbolDatabase->functionScopes) {
        if (scope->function == nullptr || !scope->function->hasBody() ||
            !(scope->function->isConstructor() ||
              scope->function->isDestructor()))
            continue;

        const std::list<const Token *> & virtualFunctionCalls = getVirtualFunctionCalls(*scope->function, virtualFunctionCallsMap);
        for (const Token *callToken : virtualFunctionCalls) {
            std::list<const Token *> callstack(1, callToken);
            getFirstVirtualFunctionCallStack(virtualFunctionCallsMap, callToken, callstack);
            if (callstack.empty())
                continue;
            const Function* cons...",1,1,lib/checkclass.cpp,CheckClass.checkVirtualFunctionCallInConstructor:void(),<empty>,,false,2825,2853,checkVirtualFunctionCallInConstructor,,,1,void()
111669151391,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"const std::list<const Token *> & CheckClass::getVirtualFunctionCalls(const Function & function,
                                                                     std::map<const Function *, std::list<const Token *>> & virtualFunctionCallsMap)
{
    const auto found = utils::as_const(virtualFunctionCallsMap).find(&function);
    if (found != virtualFunctionCallsMap.end())
        return found->second;

    virtualFunctionCallsMap[&function] = std::list<const Token *>();
    std::list<const Token *> & virtualFunctionCalls = virtualFunctionCallsMap.find(&function)->second;

    if (!function.hasBody() || !function.functionScope)
        return virtualFunctionCalls;

    for (const Token *tok = function.arg->link(); tok != function.functionScope->bodyEnd; tok = tok->next()) {
        if (function.type != FunctionType::eConstructor &&
            function.type != FunctionType::eCopyConstructor &&
            function.type != FunctionType::eMoveConstructor &&
            function.type !...",1,1,lib/checkclass.cpp,"CheckClass.getVirtualFunctionCalls:ANY(Function&,std.map<constFunction*,std.list<constToken*>>&)",<empty>,,false,2855,2911,getVirtualFunctionCalls,,,1,"ANY(Function&,std.map<constFunction*,std.list<constToken*>>&)"
111669151392,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::getFirstVirtualFunctionCallStack(
    std::map<const Function *, std::list<const Token *>> & virtualFunctionCallsMap,
    const Token * callToken,
    std::list<const Token *> & pureFuncStack)
{
    const Function *callFunction = callToken->function();
    if (callFunction->isImplicitlyVirtual() && (!callFunction->isPure() || !callFunction->hasBody())) {
        pureFuncStack.push_back(callFunction->tokenDef);
        return;
    }
    auto found = utils::as_const(virtualFunctionCallsMap).find(callFunction);
    if (found == virtualFunctionCallsMap.cend() || found->second.empty()) {
        pureFuncStack.clear();
        return;
    }
    const Token * firstCall = *found->second.cbegin();
    pureFuncStack.push_back(firstCall);
    getFirstVirtualFunctionCallStack(virtualFunctionCallsMap, firstCall, pureFuncStack);
}",1,1,lib/checkclass.cpp,"CheckClass.getFirstVirtualFunctionCallStack:void(std.map<constFunction*,std.list<constToken*>>&,Token*,std.list<constToken*>&)",<empty>,,false,2913,2931,getFirstVirtualFunctionCallStack,,,1,"void(std.map<constFunction*,std.list<constToken*>>&,Token*,std.list<constToken*>&)"
111669151393,METHOD,<empty>,<empty>,"[](const Token* tok) {
        return ErrorPathItem(tok, ""Calling "" + tok->str());
    }",87,5,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.virtualFunctionCallInConstructorError.<lambda>23:ANY(Token*),<empty>,,false,2944,2946,<lambda>23,,,1,ANY(Token*)
111669151394,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::virtualFunctionCallInConstructorError(
    const Function * scopeFunction,
    const std::list<const Token *> & tokStack,
    const std::string &funcname)
{
    if (scopeFunction && !mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""virtualCallInConstructor""))
        return;

    const char * scopeFunctionTypeName = scopeFunction ? getFunctionTypeName(scopeFunction->type) : ""constructor"";

    ErrorPath errorPath;
    std::transform(tokStack.cbegin(), tokStack.cend(), std::back_inserter(errorPath), [](const Token* tok) {
        return ErrorPathItem(tok, ""Calling "" + tok->str());
    });
    int lineNumber = 1;
    if (!errorPath.empty()) {
        lineNumber = errorPath.front().first->linenr();
        errorPath.back().second = funcname + "" is a virtual function"";
    }

    std::string constructorName;
    if (scopeFunction) {
        const Token *endToken = scopeFunction->argDef->link()->next();
        if (scopeFunction->type == Fu...",1,1,lib/checkclass.cpp,"CheckClass.virtualFunctionCallInConstructorError:void(Function*,std.list<constToken*>&,std.string&)",<empty>,,false,2933,2969,virtualFunctionCallInConstructorError,,,1,"void(Function*,std.list<constToken*>&,std.string&)"
111669151395,METHOD,<empty>,<empty>,"[](const Token* tok) {
        return ErrorPathItem(tok, ""Calling "" + tok->str());
    }",87,5,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.pureVirtualFunctionCallInConstructorError.<lambda>24:ANY(Token*),<empty>,,false,2979,2981,<lambda>24,,,1,ANY(Token*)
111669151396,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::pureVirtualFunctionCallInConstructorError(
    const Function * scopeFunction,
    const std::list<const Token *> & tokStack,
    const std::string &purefuncname)
{
    const char * scopeFunctionTypeName = scopeFunction ? getFunctionTypeName(scopeFunction->type) : ""constructor"";

    ErrorPath errorPath;
    std::transform(tokStack.cbegin(), tokStack.cend(), std::back_inserter(errorPath), [](const Token* tok) {
        return ErrorPathItem(tok, ""Calling "" + tok->str());
    });
    if (!errorPath.empty())
        errorPath.back().second = purefuncname + "" is a pure virtual function without body"";

    reportError(errorPath, Severity::warning, ""pureVirtualCall"",
                ""$symbol:"" + purefuncname +""\\n""
                ""Call of pure virtual function '$symbol' in "" + scopeFunctionTypeName + "".\\n""
                ""Call of pure virtual function '$symbol' in "" + scopeFunctionTypeName + "". The call will fail during runtime."", CWE(0U), Certainty::normal);
}",1,1,lib/checkclass.cpp,"CheckClass.pureVirtualFunctionCallInConstructorError:void(Function*,std.list<constToken*>&,std.string&)",<empty>,,false,2971,2989,pureVirtualFunctionCallInConstructorError,,,1,"void(Function*,std.list<constToken*>&,std.string&)"
111669151397,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::checkDuplInheritedMembers()
{
    if (!mSettings->severity.isEnabled(Severity::warning) && !mSettings->isPremiumEnabled(""duplInheritedMember""))
        return;

    logChecker(""CheckClass::checkDuplInheritedMembers""); // warning

    // Iterate over all classes
    for (const Type &classIt : mSymbolDatabase->typeList) {
        // Iterate over the parent classes
        checkDuplInheritedMembersRecursive(&classIt, &classIt);
    }
}",1,1,lib/checkclass.cpp,CheckClass.checkDuplInheritedMembers:void(),<empty>,,false,2996,3008,checkDuplInheritedMembers,,,1,void()
111669151398,METHOD,DuplMemberInfo,TYPE_DECL,"DuplMemberInfo(const Variable* cv, const Variable* pcv, const Type::BaseInfo* pc) : classVar(cv), parentClassVar(pcv), parentClass(pc) {}",9,145,lib/checkclass.cpp,"DuplMemberInfo.DuplMemberInfo:ANY(Variable*,Variable*,Type.BaseInfo*)",<empty>,,false,3012,3012,DuplMemberInfo,,,1,"DuplMemberInfo.DuplMemberInfo:ANY(Variable*,Variable*,Type.BaseInfo*)(Variable*,Variable*,Type.BaseInfo*)"
111669151399,METHOD,DuplMemberFuncInfo,TYPE_DECL,"DuplMemberFuncInfo(const Function* cf, const Function* pcf, const Type::BaseInfo* pc) : classFunc(cf), parentClassFunc(pcf), parentClass(pc) {}",9,151,lib/checkclass.cpp,"DuplMemberFuncInfo.DuplMemberFuncInfo:ANY(Function*,Function*,Type.BaseInfo*)",<empty>,,false,3018,3018,DuplMemberFuncInfo,,,1,"DuplMemberFuncInfo.DuplMemberFuncInfo:ANY(Function*,Function*,Type.BaseInfo*)(Function*,Function*,Type.BaseInfo*)"
111669151400,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"static std::vector<DuplMemberInfo> getDuplInheritedMembersRecursive(const Type* typeCurrent, const Type* typeBase, bool skipPrivate = true)
{
    std::vector<DuplMemberInfo> results;
    for (const Type::BaseInfo &parentClassIt : typeBase->derivedFrom) {
        // Check if there is info about the 'Base' class
        if (!parentClassIt.type || !parentClassIt.type->classScope)
            continue;
        // Don't crash on recursive templates
        if (parentClassIt.type == typeBase)
            continue;
        // Check if they have a member variable in common
        for (const Variable &classVarIt : typeCurrent->classScope->varlist) {
            for (const Variable &parentClassVarIt : parentClassIt.type->classScope->varlist) {
                if (classVarIt.name() == parentClassVarIt.name() && (!parentClassVarIt.isPrivate() || !skipPrivate)) // Check if the class and its parent have a common variable
                    results.emplace_back(&classVarIt, &parentClassVarIt, &p...",1,1,lib/checkclass.cpp,"getDuplInheritedMembersRecursive:vector<DuplMemberInfo>(Type*,Type*,bool)",<empty>,,false,3025,3048,getDuplInheritedMembersRecursive,,,1,"vector<DuplMemberInfo>(Type*,Type*,bool)"
111669151401,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"static std::vector<DuplMemberFuncInfo> getDuplInheritedMemberFunctionsRecursive(const Type* typeCurrent, const Type* typeBase, bool skipPrivate = true)
{
    std::vector<DuplMemberFuncInfo> results;
    for (const Type::BaseInfo &parentClassIt : typeBase->derivedFrom) {
        // Check if there is info about the 'Base' class
        if (!parentClassIt.type || !parentClassIt.type->classScope)
            continue;
        // Don't crash on recursive templates
        if (parentClassIt.type == typeBase)
            continue;
        for (const Function& classFuncIt : typeCurrent->classScope->functionList) {
            if (classFuncIt.isImplicitlyVirtual())
                continue;
            if (classFuncIt.tokenDef->isExpandedMacro())
                continue;
            for (const Function& parentClassFuncIt : parentClassIt.type->classScope->functionList) {
                if (classFuncIt.name() == parentClassFuncIt.name() &&
                    (parentClassFuncIt.access != Acc...",1,1,lib/checkclass.cpp,"getDuplInheritedMemberFunctionsRecursive:vector<DuplMemberFuncInfo>(Type*,Type*,bool)",<empty>,,false,3050,3081,getDuplInheritedMemberFunctionsRecursive,,,1,"vector<DuplMemberFuncInfo>(Type*,Type*,bool)"
111669151402,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::checkDuplInheritedMembersRecursive(const Type* typeCurrent, const Type* typeBase)
{
    const auto resultsVar = getDuplInheritedMembersRecursive(typeCurrent, typeBase);
    for (const auto& r : resultsVar) {
        duplInheritedMembersError(r.classVar->nameToken(), r.parentClassVar->nameToken(),
                                  typeCurrent->name(), r.parentClass->type->name(), r.classVar->name(),
                                  typeCurrent->classScope->type == ScopeType::eStruct,
                                  r.parentClass->type->classScope->type == ScopeType::eStruct);
    }

    const auto resultsFunc = getDuplInheritedMemberFunctionsRecursive(typeCurrent, typeBase);
    for (const auto& r : resultsFunc) {
        duplInheritedMembersError(r.classFunc->token, r.parentClassFunc->token,
                                  typeCurrent->name(), r.parentClass->type->name(), r.classFunc->name(),
                                  typeCurrent->classScope->type == Sc...",1,1,lib/checkclass.cpp,"CheckClass.checkDuplInheritedMembersRecursive:void(Type*,Type*)",<empty>,,false,3083,3100,checkDuplInheritedMembersRecursive,,,1,"void(Type*,Type*)"
111669151403,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::duplInheritedMembersError(const Token *tok1, const Token* tok2,
                                           const std::string &derivedName, const std::string &baseName,
                                           const std::string &memberName, bool derivedIsStruct, bool baseIsStruct, bool isFunction)
{
    ErrorPath errorPath;
    const std::string member = isFunction ? ""function"" : ""variable"";
    errorPath.emplace_back(tok2, ""Parent "" + member + "" '"" + baseName + ""::"" + memberName + ""'"");
    errorPath.emplace_back(tok1, ""Derived "" + member + "" '"" + derivedName + ""::"" + memberName + ""'"");

    const std::string symbols = ""$symbol:"" + derivedName + ""\\n$symbol:"" + memberName + ""\\n$symbol:"" + baseName;

    const std::string message = ""The "" + std::string(derivedIsStruct ? ""struct"" : ""class"") + "" '"" + derivedName +
                                ""' defines member "" + member + "" with name '"" + memberName + ""' also defined in its parent "" +
                             ...",1,1,lib/checkclass.cpp,"CheckClass.duplInheritedMembersError:void(Token*,Token*,std.string&,std.string&,std.string&,bool,bool,bool)",<empty>,,false,3102,3117,duplInheritedMembersError,,,1,"void(Token*,Token*,std.string&,std.string&,std.string&,bool,bool,bool)"
111669151404,METHOD,<empty>,<empty>,"[](const Variable& var) {
            return !var.isStatic();
        }",97,9,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.checkCopyCtorAndEqOperator.<lambda>25:bool(Variable&),<empty>,,false,3142,3144,<lambda>25,,,1,bool(Variable&)
111669151405,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::checkCopyCtorAndEqOperator()
{
    // This is disabled because of #8388
    // The message must be clarified. How is the behaviour different?
    // cppcheck-suppress unreachableCode - remove when code is enabled again
    if ((true) || !mSettings->severity.isEnabled(Severity::warning)) // NOLINT(readability-simplify-boolean-expr)
        return;

    // logChecker

    for (const Scope * scope : mSymbolDatabase->classAndStructScopes) {

        const bool hasNonStaticVars = std::any_of(scope->varlist.begin(), scope->varlist.end(), [](const Variable& var) {
            return !var.isStatic();
        });
        if (!hasNonStaticVars)
            continue;

        CtorType copyCtors = CtorType::NO;
        bool moveCtor = false;
        CtorType assignmentOperators = CtorType::NO;

        for (const Function &func : scope->functionList) {
            if (copyCtors == CtorType::NO && func.type == FunctionType::eCopyConstructor) {
                copyCtors = func.ha...",1,1,lib/checkclass.cpp,CheckClass.checkCopyCtorAndEqOperator:void(),<empty>,,false,3130,3181,checkCopyCtorAndEqOperator,,,1,void()
111669151406,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::copyCtorAndEqOperatorError(const Token *tok, const std::string &classname, bool isStruct, bool hasCopyCtor)
{
    const std::string message = ""$symbol:"" + classname + ""\\n""
                                ""The "" + std::string(isStruct ? ""struct"" : ""class"") + "" '$symbol' has '"" +
                                getFunctionTypeName(hasCopyCtor ? FunctionType::eCopyConstructor : FunctionType::eOperatorEqual) +
                                ""' but lack of '"" + getFunctionTypeName(hasCopyCtor ? FunctionType::eOperatorEqual : FunctionType::eCopyConstructor) +
                                ""'."";
    reportError(tok, Severity::warning, ""copyCtorAndEqOperator"", message);
}",1,1,lib/checkclass.cpp,"CheckClass.copyCtorAndEqOperatorError:void(Token*,std.string&,bool,bool)",<empty>,,false,3183,3191,copyCtorAndEqOperatorError,,,1,"void(Token*,std.string&,bool,bool)"
111669151407,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::checkOverride()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""missingOverride""))
        return;
    if (mSettings->standards.cpp < Standards::CPP11)
        return;
    logChecker(""CheckClass::checkMissingOverride""); // style,c++03
    for (const Scope * classScope : mSymbolDatabase->classAndStructScopes) {
        if (!classScope->definedType || classScope->definedType->derivedFrom.empty())
            continue;
        for (const Function &func : classScope->functionList) {
            if (func.hasOverrideSpecifier() || func.hasFinalSpecifier())
                continue;
            if (func.tokenDef->isExpandedMacro())
                continue;
            const Function *baseFunc = func.getOverriddenFunction();
            if (baseFunc)
                overrideError(baseFunc, &func);
        }
    }
}",1,1,lib/checkclass.cpp,CheckClass.checkOverride:void(),<empty>,,false,3193,3213,checkOverride,,,1,void()
111669151408,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::overrideError(const Function *funcInBase, const Function *funcInDerived)
{
    const std::string functionName = funcInDerived ? ((funcInDerived->isDestructor() ? ""~"" : """") + funcInDerived->name()) : """";
    const std::string funcType = (funcInDerived && funcInDerived->isDestructor()) ? ""destructor"" : ""function"";

    ErrorPath errorPath;
    if (funcInBase && funcInDerived) {
        errorPath.emplace_back(funcInBase->tokenDef, ""Virtual "" + funcType + "" in base class"");
        errorPath.emplace_back(funcInDerived->tokenDef, char(std::toupper(funcType[0])) + funcType.substr(1) + "" in derived class"");
    }

    reportError(errorPath, Severity::style, ""missingOverride"",
                ""$symbol:"" + functionName + ""\\n""
                ""The "" + funcType + "" '$symbol' overrides a "" + funcType + "" in a base class but is not marked with a 'override' specifier."",
                CWE(0U) /* Unknown CWE! */,
                Certainty::normal);
}",1,1,lib/checkclass.cpp,"CheckClass.overrideError:void(Function*,Function*)",<empty>,,false,3215,3231,overrideError,,,1,"void(Function*,Function*)"
111669151409,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::uselessOverrideError(const Function *funcInBase, const Function *funcInDerived, bool isSameCode)
{
    const std::string functionName = funcInDerived ? ((funcInDerived->isDestructor() ? ""~"" : """") + funcInDerived->name()) : """";
    const std::string funcType = (funcInDerived && funcInDerived->isDestructor()) ? ""destructor"" : ""function"";

    ErrorPath errorPath;
    if (funcInBase && funcInDerived) {
        errorPath.emplace_back(funcInBase->tokenDef, ""Virtual "" + funcType + "" in base class"");
        errorPath.emplace_back(funcInDerived->tokenDef, char(std::toupper(funcType[0])) + funcType.substr(1) + "" in derived class"");
    }

    std::string errStr = ""\\nThe "" + funcType + "" '$symbol' overrides a "" + funcType + "" in a base class but "";
    if (isSameCode) {
        errStr += ""is identical to the overridden function"";
    }
    else
        errStr += ""just delegates back to the base class."";
    reportError(errorPath, Severity::style, ""uselessOverride"",
         ...",1,1,lib/checkclass.cpp,"CheckClass.uselessOverrideError:void(Function*,Function*,bool)",<empty>,,false,3233,3255,uselessOverrideError,,,1,"void(Function*,Function*,bool)"
111669151410,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"static const Token* getSingleFunctionCall(const Scope* scope) {
    const Token* const start = scope->bodyStart->next();
    const Token* const end = Token::findsimplematch(start, "";"", 1, scope->bodyEnd);
    if (!end || end->next() != scope->bodyEnd)
        return nullptr;
    const Token* ftok = start;
    if (ftok->str() == ""return"")
        ftok = ftok->astOperand1();
    else {
        while (Token::Match(ftok, ""%name%|::""))
            ftok = ftok->next();
    }
    if (Token::simpleMatch(ftok, ""("") && ftok->previous()->function())
        return ftok->previous();
    return nullptr;
}",1,1,lib/checkclass.cpp,getSingleFunctionCall:Token*(Scope*),<empty>,,false,3257,3272,getSingleFunctionCall,,,1,Token*(Scope*)
111669151411,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"static bool compareTokenRanges(const Token* start1, const Token* end1, const Token* start2, const Token* end2) {
    const Token* tok1 = start1;
    const Token* tok2 = start2;
    bool isEqual = false;
    while (tok1 && tok2) {
        if (tok1->function() != tok2->function())
            break;
        if (tok1->str() != tok2->str())
            break;
        if (tok1->str() == ""this"")
            break;
        if (tok1->isExpandedMacro() || tok2->isExpandedMacro())
            break;
        if (tok1 == end1 && tok2 == end2) {
            isEqual = true;
            break;
        }
        tok1 = tok1->next();
        tok2 = tok2->next();
    }
    return isEqual;
}",1,1,lib/checkclass.cpp,"compareTokenRanges:bool(Token*,Token*,Token*,Token*)",<empty>,,false,3274,3295,compareTokenRanges,,,1,"bool(Token*,Token*,Token*,Token*)"
111669151412,METHOD,<empty>,<empty>,"[&func](const Function& f) { // check for overloads
                if (&f == &func)
                    return false;
                return f.name() == func.name();
            }",95,13,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.checkUselessOverride.<lambda>26:bool(Function&),<empty>,,false,3315,3319,<lambda>26,,,1,bool(Function&)
111669151413,METHOD,<empty>,<empty>,"[](const Variable& v, const Token* t) {
                    return v.nameToken() && v.nameToken()->str() == t->str();
                }",103,17,lib/checkclass.cpp,"lib/checkclass.cpp:<global>.CheckClass.checkUselessOverride.<lambda>27:bool(Variable&,Token*)",<empty>,,false,3347,3349,<lambda>27,,,1,"bool(Variable&,Token*)"
111669151414,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::checkUselessOverride()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""uselessOverride""))
        return;

    logChecker(""CheckClass::checkUselessOverride""); // style

    for (const Scope* classScope : mSymbolDatabase->classAndStructScopes) {
        if (!classScope->definedType || classScope->definedType->derivedFrom.size() != 1)
            continue;
        for (const Function& func : classScope->functionList) {
            if (!func.functionScope)
                continue;
            if (func.hasFinalSpecifier())
                continue;
            const Function* baseFunc = func.getOverriddenFunction();
            if (!baseFunc || baseFunc->isPure() || baseFunc->access != func.access)
                continue;
            if (std::any_of(classScope->functionList.begin(), classScope->functionList.end(), [&func](const Function& f) { // check for overloads
                if (&f == &func)
                    return ...",1,1,lib/checkclass.cpp,CheckClass.checkUselessOverride:void(),<empty>,,false,3297,3355,checkUselessOverride,,,1,void()
111669151415,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"static const Variable* getSingleReturnVar(const Scope* scope) {
    if (!scope || !scope->bodyStart)
        return nullptr;
    const Token* const start = scope->bodyStart->next();
    const Token* const end = Token::findsimplematch(start, "";"", 1, scope->bodyEnd);
    if (!end || end->next() != scope->bodyEnd)
        return nullptr;
    if (!start->astOperand1() || start->str() != ""return"")
        return nullptr;
    const Token* tok = start->astOperand1();
    if (tok->str() == ""."") {
        const Token* top = tok->astOperand1();
        while (Token::Match(top, ""[[.]""))
            top = top->astOperand1();
        if (!Token::Match(top, ""%var%""))
            return nullptr;
        tok = tok->astOperand2();
    }
    return tok->variable();
}",1,1,lib/checkclass.cpp,getSingleReturnVar:Variable*(Scope*),<empty>,,false,3357,3376,getSingleReturnVar,,,1,Variable*(Scope*)
111669151416,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::checkReturnByReference()
{
    if (!mSettings->severity.isEnabled(Severity::performance) && !mSettings->isPremiumEnabled(""returnByReference""))
        return;

    logChecker(""CheckClass::checkReturnByReference""); // performance

    for (const Scope* classScope : mSymbolDatabase->classAndStructScopes) {
        for (const Function& func : classScope->functionList) {
            if (Function::returnsPointer(&func) || Function::returnsReference(&func) || Function::returnsStandardType(&func))
                continue;
            if (func.isImplicitlyVirtual())
                continue;
            if (func.isOperator())
                continue;
            if (const Library::Container* container = mSettings->library.detectContainer(func.retDef))
                if (container->view)
                    continue;
            if (!func.isConst() && func.hasRvalRefQualifier())
                // this method could be used by temporary objects, return by value can be dang...",1,1,lib/checkclass.cpp,CheckClass.checkReturnByReference:void(),<empty>,,false,3378,3417,checkReturnByReference,,,1,void()
111669151417,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::returnByReferenceError(const Function* func, const Variable* var)
{
    const Token* tok = func ? func->tokenDef : nullptr;
    const std::string message = ""Function '"" + (func ? func->name() : ""func"") + ""()' should return member '"" + (var ? var->name() : ""var"") + ""' by const reference."";
    reportError(tok, Severity::performance, ""returnByReference"", message);
}",1,1,lib/checkclass.cpp,"CheckClass.returnByReferenceError:void(Function*,Variable*)",<empty>,,false,3419,3424,returnByReferenceError,,,1,"void(Function*,Variable*)"
111669151418,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::checkThisUseAfterFree()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckClass::checkThisUseAfterFree""); // warning

    for (const Scope * classScope : mSymbolDatabase->classAndStructScopes) {

        for (const Variable &var : classScope->varlist) {
            // Find possible ""self pointer"".. pointer/smartpointer member variable of ""self"" type.
            if (var.valueType() && var.valueType()->smartPointerType != classScope->definedType && var.valueType()->typeScope != classScope) {
                const ValueType valueType = ValueType::parseDecl(var.typeStartToken(), *mSettings);
                if (valueType.smartPointerType != classScope->definedType)
                    continue;
            }

            // If variable is not static, check that ""this"" is assigned
            if (!var.isStatic()) {
                bool hasAssign = false;
                for (const Function &func : classScope->functionList...",1,1,lib/checkclass.cpp,CheckClass.checkThisUseAfterFree:void(),<empty>,,false,3426,3473,checkThisUseAfterFree,,,1,void()
111669151419,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"bool CheckClass::checkThisUseAfterFreeRecursive(const Scope *classScope, const Function *func, const Variable *selfPointer, std::set<const Function *> callstack, const Token *&freeToken)
{
    if (!func || !func->functionScope)
        return false;

    // avoid recursion
    if (callstack.count(func))
        return false;
    callstack.insert(func);

    const Token * const bodyStart = func->functionScope->bodyStart;
    const Token * const bodyEnd = func->functionScope->bodyEnd;
    for (const Token *tok = bodyStart; tok != bodyEnd; tok = tok->next()) {
        const bool isDestroyed = freeToken != nullptr && !func->isStatic();
        if (Token::Match(tok, ""delete %var% ;"") && selfPointer == tok->next()->variable()) {
            freeToken = tok;
            tok = tok->tokAt(2);
        } else if (Token::Match(tok, ""%var% . reset ( )"") && selfPointer == tok->variable())
            freeToken = tok;
        else if (Token::Match(tok->previous(), ""!!. %name% ("") && tok->function(...",1,1,lib/checkclass.cpp,"CheckClass.checkThisUseAfterFreeRecursive:bool(Scope*,Function*,Variable*,std.set<constFunction*>,Token*&)",<empty>,,false,3475,3512,checkThisUseAfterFreeRecursive,,,1,"bool(Scope*,Function*,Variable*,std.set<constFunction*>,Token*&)"
111669151420,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::thisUseAfterFree(const Token *self, const Token *free, const Token *use)
{
    std::string selfPointer = self ? self->str() : ""ptr"";
    const ErrorPath errorPath = { ErrorPathItem(self, ""Assuming '"" + selfPointer + ""' is used as 'this'""), ErrorPathItem(free, ""Delete '"" + selfPointer + ""', invalidating 'this'""), ErrorPathItem(use, ""Call method when 'this' is invalid"") };
    const std::string usestr = use ? use->str() : ""x"";
    const std::string usemsg = use && use->function() ? (""Calling method '"" + usestr + ""()'"") : (""Using member '"" + usestr + ""'"");
    reportError(errorPath, Severity::warning, ""thisUseAfterFree"",
                ""$symbol:"" + selfPointer + ""\\n"" +
                usemsg + "" when 'this' might be invalid"",
                CWE(0), Certainty::normal);
}",1,1,lib/checkclass.cpp,"CheckClass.thisUseAfterFree:void(Token*,Token*,Token*)",<empty>,,false,3514,3524,thisUseAfterFree,,,1,"void(Token*,Token*,Token*)"
111669151421,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::checkUnsafeClassRefMember()
{
    if (!mSettings->safeChecks.classes || !mSettings->severity.isEnabled(Severity::warning))
        return;
    logChecker(""CheckClass::checkUnsafeClassRefMember""); // warning,safeChecks
    for (const Scope * classScope : mSymbolDatabase->classAndStructScopes) {
        for (const Function &func : classScope->functionList) {
            if (!func.hasBody() || !func.isConstructor())
                continue;

            const Token *initList = func.constructorMemberInitialization();
            while (Token::Match(initList, ""[:,] %name% ("")) {
                if (Token::Match(initList->tokAt(2), ""( %var% )"")) {
                    const Variable * const memberVar = initList->next()->variable();
                    const Variable * const argVar = initList->tokAt(3)->variable();
                    if (memberVar && argVar && memberVar->isConst() && memberVar->isReference() && argVar->isArgument() && argVar->isConst() && argVar->isRefere...",1,1,lib/checkclass.cpp,CheckClass.checkUnsafeClassRefMember:void(),<empty>,,false,3526,3548,checkUnsafeClassRefMember,,,1,void()
111669151422,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::unsafeClassRefMemberError(const Token *tok, const std::string &varname)
{
    reportError(tok, Severity::warning, ""unsafeClassRefMember"",
                ""$symbol:"" + varname + ""\\n""
                ""Unsafe class: The const reference member '$symbol' is initialized by a const reference constructor argument. You need to be careful about lifetime issues.\\n""
                ""Unsafe class checking: The const reference member '$symbol' is initialized by a const reference constructor argument. You need to be careful about lifetime issues. If you pass a local variable or temporary value in this constructor argument, be extra careful. If the argument is always some global object that is never destroyed then this is safe usage. However it would be defensive to make the member '$symbol' a non-reference variable or a smart pointer."",
                CWE(0), Certainty::normal);
}",1,1,lib/checkclass.cpp,"CheckClass.unsafeClassRefMemberError:void(Token*,std.string&)",<empty>,,false,3550,3557,unsafeClassRefMemberError,,,1,"void(Token*,std.string&)"
111669151423,METHOD,MyFileInfo.NameLoc,TYPE_DECL,"bool isSameLocation(const NameLoc& other) const {
                return fileName == other.fileName &&
                       lineNumber == other.lineNumber &&
                       column == other.column;
            }",13,13,lib/checkclass.cpp,MyFileInfo.NameLoc.isSameLocation<const>:bool(MyFileInfo.NameLoc&),<empty>,,false,3578,3582,isSameLocation,,,6,bool(MyFileInfo.NameLoc&)
111669151424,METHOD,MyFileInfo,TYPE_DECL,"std::string toString() const override
        {
            std::string ret;
            for (const NameLoc &nameLoc: classDefinitions) {
                ret += ""<class name=\\"""" + ErrorLogger::toxml(nameLoc.className) +
                       ""\\"" file=\\"""" + ErrorLogger::toxml(nameLoc.fileName) +
                       ""\\"" line=\\"""" + std::to_string(nameLoc.lineNumber) +
                       ""\\"" col=\\"""" + std::to_string(nameLoc.column) +
                       ""\\"" hash=\\"""" + std::to_string(nameLoc.hash) +
                       ""\\""/>\\n"";
            }
            return ret;
        }",9,9,lib/checkclass.cpp,MyFileInfo.toString<const><duplicate>0:string(),<empty>,,false,3587,3599,toString,,,3,string()
111669151425,METHOD,<empty>,<empty>,"[](const Function& f) {
            return f.hasBody();
        }",49,9,lib/checkclass.cpp,lib/checkclass.cpp:<global>.CheckClass.getFileInfo<const>.<lambda>28:bool(Function&),<empty>,,false,3620,3622,<lambda>28,,,1,bool(Function&)
111669151426,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"Check::FileInfo *CheckClass::getFileInfo(const Tokenizer &tokenizer, const Settings& /*settings*/) const
{
    if (!tokenizer.isCPP())
        return nullptr;

    // One definition rule
    std::vector<MyFileInfo::NameLoc> classDefinitions;
    for (const Scope * classScope : tokenizer.getSymbolDatabase()->classAndStructScopes) {
        if (classScope->isAnonymous())
            continue;

        if (classScope->classDef && Token::simpleMatch(classScope->classDef->previous(), "">""))
            continue;

        // the full definition must be compared
        const bool fullDefinition = std::all_of(classScope->functionList.cbegin(),
                                                classScope->functionList.cend(),
                                                [](const Function& f) {
            return f.hasBody();
        });
        if (!fullDefinition)
            continue;

        std::string name;
        const Scope *scope = classScope;
        while (scope->isClassOrStruct...",1,1,lib/checkclass.cpp,"CheckClass.getFileInfo<const>:Check.FileInfo*(Tokenizer&,Settings&)",<empty>,,false,3603,3670,getFileInfo,,,1,"Check.FileInfo*(Tokenizer&,Settings&)"
111669151427,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"Check::FileInfo * CheckClass::loadFileInfoFromXml(const tinyxml2::XMLElement *xmlElement) const
{
    auto *fileInfo = new MyFileInfo;
    for (const tinyxml2::XMLElement *e = xmlElement->FirstChildElement(); e; e = e->NextSiblingElement()) {
        if (std::strcmp(e->Name(), ""class"") != 0)
            continue;
        const char *name = e->Attribute(""name"");
        const char *file = e->Attribute(""file"");
        const char *line = e->Attribute(""line"");
        const char *col = e->Attribute(""col"");
        const char *hash = e->Attribute(""hash"");
        if (name && file && line && col && hash) {
            MyFileInfo::NameLoc nameLoc;
            nameLoc.className = name;
            nameLoc.fileName = file;
            nameLoc.lineNumber = strToInt<int>(line);
            nameLoc.column = strToInt<int>(col);
            nameLoc.hash = strToInt<std::size_t>(hash);
            fileInfo->classDefinitions.push_back(std::move(nameLoc));
        }
    }
    if (fileInfo->classDefi...",1,1,lib/checkclass.cpp,CheckClass.loadFileInfoFromXml<const>:Check.FileInfo*(tinyxml2.XMLElement*),<empty>,,false,3672,3698,loadFileInfoFromXml,,,1,Check.FileInfo*(tinyxml2.XMLElement*)
111669151428,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"bool CheckClass::analyseWholeProgram(const CTU::FileInfo &ctu, const std::list<Check::FileInfo*> &fileInfo, const Settings& settings, ErrorLogger &errorLogger)
{
    (void)ctu;
    (void)settings;

    CheckClass dummy(nullptr, &settings, &errorLogger);
    dummy.
    logChecker(""CheckClass::analyseWholeProgram"");

    if (fileInfo.empty())
        return false;

    bool foundErrors = false;

    std::unordered_map<std::string, MyFileInfo::NameLoc> all;

    for (const Check::FileInfo* fi1 : fileInfo) {
        const auto *fi = dynamic_cast<const MyFileInfo*>(fi1);
        if (!fi)
            continue;
        for (const MyFileInfo::NameLoc &nameLoc : fi->classDefinitions) {
            auto it = all.find(nameLoc.className);
            if (it == all.end()) {
                all[nameLoc.className] = nameLoc;
                continue;
            }
            if (it->second.hash == nameLoc.hash)
                continue;
            // Same location, sometimes the hash is differen...",1,1,lib/checkclass.cpp,"CheckClass.analyseWholeProgram:bool(CTU.FileInfo&,std.list<Check.FileInfo*>&,Settings&,ErrorLogger&)",<empty>,,false,3700,3750,analyseWholeProgram,,,1,"bool(CTU.FileInfo&,std.list<Check.FileInfo*>&,Settings&,ErrorLogger&)"
111669151429,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    if (tokenizer.isC())
        return;

    CheckClass checkClass(&tokenizer, &tokenizer.getSettings(), errorLogger);

    // can't be a simplified check .. the 'sizeof' is used.
    checkClass.checkMemset();
    checkClass.constructors();
    checkClass.privateFunctions();
    checkClass.operatorEqRetRefThis();
    checkClass.thisSubtraction();
    checkClass.operatorEqToSelf();
    checkClass.initializerListOrder();
    checkClass.initializationListUsage();
    checkClass.checkSelfInitialization();
    checkClass.virtualDestructor();
    checkClass.checkConst();
    checkClass.copyconstructors();
    checkClass.checkVirtualFunctionCallInConstructor();
    checkClass.checkDuplInheritedMembers();
    checkClass.checkExplicitConstructors();
    checkClass.checkCopyCtorAndEqOperator();
    checkClass.checkOverride();
    checkClass.checkUselessOverride();
    checkClass.checkReturnByReference();
    c...",1,1,lib/checkclass.cpp,"CheckClass.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,3752,3781,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669151430,METHOD,lib/checkclass.cpp:<global>,TYPE_DECL,"void CheckClass::getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const
{
    CheckClass c(nullptr, settings, errorLogger);
    c.noConstructorError(nullptr, ""classname"", false);
    c.noExplicitConstructorError(nullptr, ""classname"", false);
    //c.copyConstructorMallocError(nullptr, 0, ""var"");
    c.copyConstructorShallowCopyError(nullptr, ""var"");
    c.noCopyConstructorError(nullptr, false, nullptr, false);
    c.noOperatorEqError(nullptr, false, nullptr, false);
    c.noDestructorError(nullptr, false, nullptr);
    c.uninitVarError(nullptr, false, FunctionType::eConstructor, ""classname"", ""varname"", false, false);
    c.uninitVarError(nullptr, true, FunctionType::eConstructor, ""classname"", ""varnamepriv"", false, false);
    c.uninitVarError(nullptr, false, FunctionType::eConstructor, ""classname"", ""varname"", true, false);
    c.uninitVarError(nullptr, true, FunctionType::eConstructor, ""classname"", ""varnamepriv"", true, false);
    c.missingMemberCopyError(nullptr...",1,1,lib/checkclass.cpp,"CheckClass.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,3783,3825,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669151431,METHOD,lib/checkclass.h:<global>,TYPE_DECL,<global>,1,1,lib/checkclass.h,lib/checkclass.h:<global>,<empty>,,false,1,347,<global>,,,1,
111669151432,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"bool CheckCondition::diag(const Token* tok, bool insert)
{
    if (!tok)
        return false;
    const Token* parent = tok->astParent();
    bool hasParent = false;
    while (Token::Match(parent, ""!|&&|%oror%"")) {
        if (mCondDiags.count(parent) != 0) {
            hasParent = true;
            break;
        }
        parent = parent->astParent();
    }
    if (mCondDiags.count(tok) == 0 && !hasParent) {
        if (insert)
            mCondDiags.insert(tok);
        return false;
    }
    return true;
}",1,1,lib/checkcondition.cpp,"CheckCondition.diag:bool(Token*,bool)",<empty>,,false,60,79,diag,,,1,"bool(Token*,bool)"
111669151433,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,<global>,1,1,lib/checkcondition.cpp,lib/checkcondition.cpp:<global>,<empty>,,false,1,2095,<global>,,,1,
111669151434,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"bool CheckCondition::isAliased(const std::set<int> &vars) const
{
    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""= & %var% ;"") && vars.find(tok->tokAt(2)->varId()) != vars.end())
            return true;
    }
    return false;
}",1,1,lib/checkcondition.cpp,CheckCondition.isAliased<const>:bool(std.set<int>&),<empty>,,false,81,88,isAliased,,,1,bool(std.set<int>&)
111669151435,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::assignIf()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""assignIfError""))
        return;

    logChecker(""CheckCondition::assignIf""); // style

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (tok->str() != ""="")
            continue;

        if (Token::Match(tok->tokAt(-2), ""[;{}] %var% ="")) {
            const Variable *var = tok->previous()->variable();
            if (var == nullptr)
                continue;

            char bitop = '\\0';
            MathLib::bigint num = 0;

            if (Token::Match(tok->next(), ""%num% [&|]"")) {
                bitop = tok->strAt(2).at(0);
                num = MathLib::toBigNumber(tok->tokAt(1));
            } else {
                const Token *endToken = Token::findsimplematch(tok, "";"");

                // Casting address
                if (endToken && Token::Match(endToken->tokAt(-4), ""* ) & %any% ;""))
                    endTok...",1,1,lib/checkcondition.cpp,CheckCondition.assignIf:void(),<empty>,,false,90,134,assignIf,,,1,void()
111669151436,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"static bool isParameterChanged(const Token *partok)
{
    bool addressOf = Token::Match(partok, ""[(,] &"");
    int argumentNumber = 0;
    const Token *ftok;
    for (ftok = partok; ftok && ftok->str() != ""(""; ftok = ftok->previous()) {
        if (ftok->str() == "")"")
            ftok = ftok->link();
        else if (argumentNumber == 0U && ftok->str() == ""&"")
            addressOf = true;
        else if (ftok->str() == "","")
            argumentNumber++;
    }
    ftok = ftok ? ftok->previous() : nullptr;
    if (!(ftok && ftok->function()))
        return true;
    const Variable *par = ftok->function()->getArgumentVar(argumentNumber);
    if (!par)
        return true;
    if (par->isConst())
        return false;
    if (addressOf || par->isReference() || par->isPointer())
        return true;
    return false;
}",1,1,lib/checkcondition.cpp,isParameterChanged:bool(Token*),<empty>,,false,136,160,isParameterChanged,,,1,bool(Token*)
111669151437,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"bool CheckCondition::assignIfParseScope(const Token * const assignTok,
                                        const Token * const startTok,
                                        const nonneg int varid,
                                        const bool islocal,
                                        const char bitop,
                                        const MathLib::bigint num)
{
    bool ret = false;

    for (const Token *tok2 = startTok; tok2; tok2 = tok2->next()) {
        if ((bitop == '&') && Token::Match(tok2->tokAt(2), ""%varid% %cop% %num% ;"", varid) && tok2->strAt(3) == std::string(1U, bitop)) {
            const MathLib::bigint num2 = MathLib::toBigNumber(tok2->tokAt(4));
            if (0 == (num & num2))
                mismatchingBitAndError(assignTok, num, tok2, num2);
        }
        if (Token::Match(tok2, ""%varid% ="", varid)) {
            return true;
        }
        if (bitop == '&' && Token::Match(tok2, ""%varid% &= %num% ;"", varid)) {
            cons...",1,46,lib/checkcondition.cpp,"CheckCondition.assignIfParseScope:bool(Token*,Token*,int,bool,char,MathLib.bigint)",<empty>,,false,163,239,assignIfParseScope,,,1,"bool(Token*,Token*,int,bool,char,MathLib.bigint)"
111669151438,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::assignIfError(const Token *tok1, const Token *tok2, const std::string &condition, bool result)
{
    if (tok2 && diag(tok2->tokAt(2)))
        return;
    std::list<const Token *> locations = { tok1, tok2 };
    reportError(locations,
                Severity::style,
                ""assignIfError"",
                ""Mismatching assignment and comparison, comparison '"" + condition + ""' is always "" + std::string(bool_to_string(result)) + ""."", CWE398, Certainty::normal);
}",1,1,lib/checkcondition.cpp,"CheckCondition.assignIfError:void(Token*,Token*,std.string&,bool)",<empty>,,false,241,250,assignIfError,,,1,"void(Token*,Token*,std.string&,bool)"
111669151439,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::mismatchingBitAndError(const Token *tok1, const MathLib::bigint num1, const Token *tok2, const MathLib::bigint num2)
{
    std::list<const Token *> locations = { tok1, tok2 };

    std::ostringstream msg;
    msg << ""Mismatching bitmasks. Result is always 0 (""
        << ""X = Y & 0x"" << std::hex << num1 << ""; Z = X & 0x"" << std::hex << num2 << ""; => Z=0)."";

    reportError(locations,
                Severity::style,
                ""mismatchingBitAnd"",
                msg.str(), CWE398, Certainty::normal);
}",1,1,lib/checkcondition.cpp,"CheckCondition.mismatchingBitAndError:void(Token*,MathLib.bigint,Token*,MathLib.bigint)",<empty>,,false,253,265,mismatchingBitAndError,,,1,"void(Token*,MathLib.bigint,Token*,MathLib.bigint)"
111669151440,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"static void getnumchildren(const Token *tok, std::list<MathLib::bigint> &numchildren)
{
    if (tok->astOperand1() && tok->astOperand1()->isNumber())
        numchildren.push_back(MathLib::toBigNumber(tok->astOperand1()));
    else if (tok->astOperand1() && tok->str() == tok->astOperand1()->str())
        getnumchildren(tok->astOperand1(), numchildren);
    if (tok->astOperand2() && tok->astOperand2()->isNumber())
        numchildren.push_back(MathLib::toBigNumber(tok->astOperand2()));
    else if (tok->astOperand2() && tok->str() == tok->astOperand2()->str())
        getnumchildren(tok->astOperand2(), numchildren);
}",1,1,lib/checkcondition.cpp,"getnumchildren:void(Token*,std.list<MathLib.bigint>&)",<empty>,,false,268,278,getnumchildren,,,1,"void(Token*,std.list<MathLib.bigint>&)"
111669151441,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"static bool inBooleanFunction(const Token *tok)
{
    const Scope *scope = tok ? tok->scope() : nullptr;
    while (scope && scope->isLocal())
        scope = scope->nestedIn;
    if (scope && scope->type == ScopeType::eFunction) {
        const Function *func = scope->function;
        if (func) {
            const Token *ret = func->retDef;
            while (Token::Match(ret, ""static|const""))
                ret = ret->next();
            return Token::Match(ret, ""bool|_Bool"");
        }
    }
    return false;
}",1,1,lib/checkcondition.cpp,inBooleanFunction:bool(Token*),<empty>,,false,281,296,inBooleanFunction,,,1,bool(Token*)
111669151442,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"static bool isOperandExpanded(const Token *tok)
{
    if (tok->isExpandedMacro() || tok->isEnumerator())
        return true;
    if (tok->astOperand1() && isOperandExpanded(tok->astOperand1()))
        return true;
    if (tok->astOperand2() && isOperandExpanded(tok->astOperand2()))
        return true;
    return false;
}",1,1,lib/checkcondition.cpp,isOperandExpanded:bool(Token*),<empty>,,false,298,307,isOperandExpanded,,,1,bool(Token*)
111669151443,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::checkBadBitmaskCheck()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""badBitmaskCheck""))
        return;

    logChecker(""CheckCondition::checkBadBitmaskCheck""); // style

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (tok->str() == ""|"" && tok->astOperand1() && tok->astOperand2() && tok->astParent()) {
            const Token* parent = tok->astParent();
            const bool isBoolean = Token::Match(parent, ""&&|%oror%"") ||
                                   (parent->str() == ""?"" && parent->astOperand1() == tok) ||
                                   (parent->str() == ""="" && parent->astOperand2() == tok && parent->astOperand1() && parent->astOperand1()->variable() && Token::Match(parent->astOperand1()->variable()->typeStartToken(), ""bool|_Bool"")) ||
                                   (parent->str() == ""("" && Token::Match(parent->astOperand1(), ""if|while"")) ||
                    ...",1,1,lib/checkcondition.cpp,CheckCondition.checkBadBitmaskCheck:void(),<empty>,,false,309,347,checkBadBitmaskCheck,,,1,void()
111669151444,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::badBitmaskCheckError(const Token *tok, bool isNoOp)
{
    if (isNoOp)
        reportError(tok, Severity::style, ""badBitmaskCheck"", ""Operator '|' with one operand equal to zero is redundant."", CWE571, Certainty::normal);
    else
        reportError(tok, Severity::warning, ""badBitmaskCheck"", ""Result of operator '|' is always true if one operand is non-zero. Did you intend to use '&'?"", CWE571, Certainty::normal);
}",1,1,lib/checkcondition.cpp,"CheckCondition.badBitmaskCheckError:void(Token*,bool)",<empty>,,false,349,355,badBitmaskCheckError,,,1,"void(Token*,bool)"
111669151445,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::comparison()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""comparisonError""))
        return;

    logChecker(""CheckCondition::comparison""); // style

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (!tok->isComparisonOp())
            continue;

        const Token *expr1 = tok->astOperand1();
        const Token *expr2 = tok->astOperand2();
        if (!expr1 || !expr2)
            continue;
        if (expr1->hasKnownIntValue())
            std::swap(expr1,expr2);
        if (!expr2->hasKnownIntValue())
            continue;
        if (!compareTokenFlags(expr1, expr2, /*macro*/ true))
            continue;
        const MathLib::bigint num2 = expr2->getKnownIntValue();
        if (num2 < 0)
            continue;
        if (!Token::Match(expr1,""[&|]""))
            continue;
        std::list<MathLib::bigint> numbers;
        getnumchildren(expr1, numbers);
        for (const ...",1,1,lib/checkcondition.cpp,CheckCondition.comparison:void(),<empty>,,false,357,420,comparison,,,1,void()
111669151446,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::comparisonError(const Token *tok, const std::string &bitop, MathLib::bigint value1, const std::string &op, MathLib::bigint value2, bool result)
{
    std::ostringstream expression;
    expression << std::hex << ""(X "" << bitop << "" 0x"" << value1 << "") "" << op << "" 0x"" << value2;

    const std::string errmsg(""Expression '"" + expression.str() + ""' is always "" + bool_to_string(result) + "".\\n""
                             ""The expression '"" + expression.str() + ""' is always "" + bool_to_string(result) +
                             "". Check carefully constants and operators used, these errors might be hard to ""
                             ""spot sometimes. In case of complex expression it might help to split it to ""
                             ""separate expressions."");

    reportError(tok, Severity::style, ""comparisonError"", errmsg, CWE398, Certainty::normal);
}",1,1,lib/checkcondition.cpp,"CheckCondition.comparisonError:void(Token*,std.string&,MathLib.bigint,std.string&,MathLib.bigint,bool)",<empty>,,false,422,434,comparisonError,,,1,"void(Token*,std.string&,MathLib.bigint,std.string&,MathLib.bigint,bool)"
111669151447,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"bool CheckCondition::isOverlappingCond(const Token * const cond1, const Token * const cond2, bool pure) const
{
    if (!cond1 || !cond2)
        return false;

    // same expressions
    if (isSameExpression(true, cond1, cond2, *mSettings, pure, false))
        return true;

    // bitwise overlap for example 'x&7' and 'x==1'
    if (cond1->str() == ""&"" && cond1->astOperand1() && cond2->astOperand2()) {
        const Token *expr1 = cond1->astOperand1();
        const Token *num1  = cond1->astOperand2();
        if (!num1) // unary operator&
            return false;
        if (!num1->isNumber())
            std::swap(expr1,num1);
        if (!num1->isNumber() || MathLib::isNegative(num1->str()))
            return false;

        if (!Token::Match(cond2, ""&|=="") || !cond2->astOperand1() || !cond2->astOperand2())
            return false;
        const Token *expr2 = cond2->astOperand1();
        const Token *num2  = cond2->astOperand2();
        if (!num2->isNumber())
           ...",1,1,lib/checkcondition.cpp,"CheckCondition.isOverlappingCond<const>:bool(Token*,Token*,bool)",<empty>,,false,436,475,isOverlappingCond,,,1,"bool(Token*,Token*,bool)"
111669151448,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::duplicateCondition()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""duplicateCondition""))
        return;

    logChecker(""CheckCondition::duplicateCondition""); // style

    const SymbolDatabase *const symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope &scope : symbolDatabase->scopeList) {
        if (scope.type != ScopeType::eIf)
            continue;

        const Token* tok2 = scope.classDef->next();
        if (!tok2)
            continue;
        const Token* cond1 = tok2->astOperand2();
        if (!cond1)
            continue;
        if (cond1->hasKnownIntValue())
            continue;

        tok2 = tok2->link();
        if (!Token::simpleMatch(tok2, "") {""))
            continue;
        tok2 = tok2->linkAt(1);
        if (!Token::simpleMatch(tok2, ""} if (""))
            continue;
        const Token *cond2 = tok2->tokAt(2)->astOperand2();
        if (!cond2)
            continue;

    ...",1,1,lib/checkcondition.cpp,CheckCondition.duplicateCondition:void(),<empty>,,false,477,514,duplicateCondition,,,1,void()
111669151449,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::duplicateConditionError(const Token *tok1, const Token *tok2, ErrorPath errorPath)
{
    if (diag(tok1) & diag(tok2))
        return;
    errorPath.emplace_back(tok1, ""First condition"");
    errorPath.emplace_back(tok2, ""Second condition"");

    std::string msg = ""The if condition is the same as the previous if condition"";

    reportError(errorPath, Severity::style, ""duplicateCondition"", msg, CWE398, Certainty::normal);
}",1,1,lib/checkcondition.cpp,"CheckCondition.duplicateConditionError:void(Token*,Token*,ErrorPath)",<empty>,,false,516,526,duplicateConditionError,,,1,"void(Token*,Token*,ErrorPath)"
111669151450,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::multiCondition()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""multiCondition""))
        return;

    logChecker(""CheckCondition::multiCondition""); // style

    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope &scope : symbolDatabase->scopeList) {
        if (scope.type != ScopeType::eIf)
            continue;

        const Token * const cond1 = scope.classDef->next()->astOperand2();
        if (!cond1)
            continue;

        const Token * tok2 = scope.classDef->next();

        // Check each 'else if'
        for (;;) {
            tok2 = tok2->link();
            if (!Token::simpleMatch(tok2, "") {""))
                break;
            tok2 = tok2->linkAt(1);
            if (!Token::simpleMatch(tok2, ""} else { if (""))
                break;
            tok2 = tok2->tokAt(4);

            if (tok2->astOperand2()) {
                ErrorPath errorPath;
      ...",1,1,lib/checkcondition.cpp,CheckCondition.multiCondition:void(),<empty>,,false,528,569,multiCondition,,,1,void()
111669151451,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::overlappingElseIfConditionError(const Token *tok, nonneg int line1)
{
    if (diag(tok))
        return;
    std::ostringstream errmsg;
    errmsg << ""Expression is always false because 'else if' condition matches previous condition at line ""
           << line1 << ""."";

    reportError(tok, Severity::style, ""multiCondition"", errmsg.str(), CWE398, Certainty::normal);
}",1,71,lib/checkcondition.cpp,"CheckCondition.overlappingElseIfConditionError:void(Token*,int)",<empty>,,false,571,580,overlappingElseIfConditionError,,,1,"void(Token*,int)"
111669151452,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::oppositeElseIfConditionError(const Token *ifCond, const Token *elseIfCond, ErrorPath errorPath)
{
    if (diag(ifCond) & diag(elseIfCond))
        return;
    std::ostringstream errmsg;
    errmsg << ""Expression is always true because 'else if' condition is opposite to previous condition at line ""
           << ifCond->linenr() << ""."";

    errorPath.emplace_back(ifCond, ""first condition"");
    errorPath.emplace_back(elseIfCond, ""else if condition is opposite to first condition"");

    reportError(errorPath, Severity::style, ""multiCondition"", errmsg.str(), CWE398, Certainty::normal);
}",1,1,lib/checkcondition.cpp,"CheckCondition.oppositeElseIfConditionError:void(Token*,Token*,ErrorPath)",<empty>,,false,582,594,oppositeElseIfConditionError,,,1,"void(Token*,Token*,ErrorPath)"
111669151453,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"static bool isNonConstFunctionCall(const Token *ftok, const Library &library)
{
    if (library.isFunctionConst(ftok))
        return false;
    const Token *obj = ftok->next()->astOperand1();
    while (obj && obj->str() == ""."")
        obj = obj->astOperand1();
    if (!obj)
        return true;
    if (obj->variable() && obj->variable()->isConst())
        return false;
    if (ftok->function() && ftok->function()->isConst())
        return false;
    return true;
}",1,1,lib/checkcondition.cpp,"isNonConstFunctionCall:bool(Token*,Library&)",<empty>,,false,602,616,isNonConstFunctionCall,,,1,"bool(Token*,Library&)"
111669151454,METHOD,<empty>,<empty>,"[&](const Token *cond) {
            if (Token::Match(cond, ""%name% ("")) {
                functionCall = true;
                nonConstFunctionCall = isNonConstFunctionCall(cond, mSettings->library);
                if (nonConstFunctionCall)
                    return ChildrenToVisit::done;
            }

            if (cond->varId()) {
                vars.insert(cond->varId());
                const Variable *var = cond->variable();
                if (!nonlocal && var) {
                    if (!(var->isLocal() || var->isArgument()))
                        nonlocal = true;
                    else if ((var->isPointer() || var->isReference()) && !Token::Match(cond->astParent(), ""%oror%|&&|!""))
                        // TODO: if var is pointer check what it points at
                        nonlocal = true;
                }
            } else if (!nonlocal && cond->isName()) {
                // varid is 0. this is possibly a nonlocal variable..
                nonlocal = Toke...",23,9,lib/checkcondition.cpp,lib/checkcondition.cpp:<global>.CheckCondition.multiCondition2.<lambda>0:ChildrenToVisit(Token*),<empty>,,false,654,679,<lambda>0,,,1,ChildrenToVisit(Token*)
111669151455,METHOD,<empty>,<empty>,"[&varsInCond](const Token *cond) {
            if (cond->variable()) {
                const Variable *var = cond->variable();
                if (std::find(varsInCond.cbegin(), varsInCond.cend(), var) == varsInCond.cend())
                    varsInCond.push_back(var);
            }
            return ChildrenToVisit::op1_and_op2;
        }",23,9,lib/checkcondition.cpp,lib/checkcondition.cpp:<global>.CheckCondition.multiCondition2.<lambda>1:ChildrenToVisit(Token*),<empty>,,false,686,693,<lambda>1,,,1,ChildrenToVisit(Token*)
111669151456,METHOD,<empty>,<empty>,"[&](const Token* firstCondition) {
                            if (!firstCondition)
                                return ChildrenToVisit::none;
                            if (firstCondition->str() == ""&&"") {
                                if (!isOppositeCond(false, firstCondition, cond2, *mSettings, true, true))
                                    return ChildrenToVisit::op1_and_op2;
                            }
                            if (!firstCondition->hasKnownIntValue()) {
                                if (!isReturnVar && isOppositeCond(false, firstCondition, cond2, *mSettings, true, true, &errorPath)) {
                                    if (!isAliased(vars))
                                        oppositeInnerConditionError(firstCondition, cond2, errorPath);
                                } else if (!isReturnVar && isSameExpression(true, firstCondition, cond2, *mSettings, true, true, &errorPath)) {
                                    identicalInnerConditionError...",46,25,lib/checkcondition.cpp,lib/checkcondition.cpp:<global>.CheckCondition.multiCondition2.<lambda>2:ChildrenToVisit(Token*),<empty>,,false,728,744,<lambda>2,,,1,ChildrenToVisit(Token*)
111669151457,METHOD,<empty>,<empty>,"[&](const Token *secondCondition) {
                            if (secondCondition->str() == ""||"" || secondCondition->str() == ""&&"")
                                return ChildrenToVisit::op1_and_op2;

                            if ((!cond1->hasKnownIntValue() || !secondCondition->hasKnownIntValue()) &&
                                isSameExpression(true, cond1, secondCondition, *mSettings, true, true, &errorPath)) {
                                if (!isAliased(vars) && !mTokenizer->hasIfdef(cond1, secondCondition)) {
                                    identicalConditionAfterEarlyExitError(cond1, secondCondition, errorPath);
                                    return ChildrenToVisit::done;
                                }
                            }
                            return ChildrenToVisit::none;
                        }",46,25,lib/checkcondition.cpp,lib/checkcondition.cpp:<global>.CheckCondition.multiCondition2.<lambda>3:ChildrenToVisit(Token*),<empty>,,false,746,758,<lambda>3,,,1,ChildrenToVisit(Token*)
111669151458,METHOD,<empty>,<empty>,"[&](int varid) {
                        return isVariableChanged(tok1, tok2, varid, nonlocal, *mSettings);
                    }",82,21,lib/checkcondition.cpp,lib/checkcondition.cpp:<global>.CheckCondition.multiCondition2.<lambda>4:bool(int),<empty>,,false,790,792,<lambda>4,,,1,bool(int)
111669151459,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::multiCondition2()
{
    if (!mSettings->severity.isEnabled(Severity::warning) &&
        !mSettings->isPremiumEnabled(""identicalConditionAfterEarlyExit"") &&
        !mSettings->isPremiumEnabled(""identicalInnerCondition""))
        return;

    logChecker(""CheckCondition::multiCondition2""); // warning

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope &scope : symbolDatabase->scopeList) {
        const Token *condTok = nullptr;
        if (scope.type == ScopeType::eIf || scope.type == ScopeType::eWhile)
            condTok = scope.classDef->next()->astOperand2();
        else if (scope.type == ScopeType::eFor) {
            condTok = scope.classDef->next()->astOperand2();
            if (!condTok || condTok->str() != "";"")
                continue;
            condTok = condTok->astOperand2();
            if (!condTok || condTok->str() != "";"")
                continue;
            condTok = condTok->astOperand1();
   ...",1,1,lib/checkcondition.cpp,CheckCondition.multiCondition2:void(),<empty>,,false,618,834,multiCondition2,,,1,void()
111669151460,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"static std::string innerSmtString(const Token * tok)
{
    if (!tok)
        return ""if"";
    const Token * top = tok->astTop();
    if (top->str() == ""("" && top->astOperand1())
        return top->astOperand1()->str();
    return top->str();
}",1,1,lib/checkcondition.cpp,innerSmtString:string(Token*),<empty>,,false,836,844,innerSmtString,,,1,string(Token*)
111669151461,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::oppositeInnerConditionError(const Token *tok1, const Token* tok2, ErrorPath errorPath)
{
    if (diag(tok1) & diag(tok2))
        return;
    const std::string s1(tok1 ? tok1->expressionString() : ""x"");
    const std::string s2(tok2 ? tok2->expressionString() : ""!x"");
    const std::string innerSmt = innerSmtString(tok2);
    errorPath.emplace_back(tok1, ""outer condition: "" + s1);
    errorPath.emplace_back(tok2, ""opposite inner condition: "" + s2);

    const std::string msg(""Opposite inner '"" + innerSmt + ""' condition leads to a dead code block.\\n""
                          ""Opposite inner '"" + innerSmt + ""' condition leads to a dead code block (outer condition is '"" + s1 + ""' and inner condition is '"" + s2 + ""')."");
    reportError(errorPath, Severity::warning, ""oppositeInnerCondition"", msg, CWE398, Certainty::normal);
}",1,1,lib/checkcondition.cpp,"CheckCondition.oppositeInnerConditionError:void(Token*,Token*,ErrorPath)",<empty>,,false,846,859,oppositeInnerConditionError,,,1,"void(Token*,Token*,ErrorPath)"
111669151462,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::identicalInnerConditionError(const Token *tok1, const Token* tok2, ErrorPath errorPath)
{
    if (diag(tok1) & diag(tok2))
        return;
    const std::string s1(tok1 ? tok1->expressionString() : ""x"");
    const std::string s2(tok2 ? tok2->expressionString() : ""x"");
    const std::string innerSmt = innerSmtString(tok2);
    errorPath.emplace_back(tok1, ""outer condition: "" + s1);
    errorPath.emplace_back(tok2, ""identical inner condition: "" + s2);

    const std::string msg(""Identical inner '"" + innerSmt + ""' condition is always true.\\n""
                          ""Identical inner '"" + innerSmt + ""' condition is always true (outer condition is '"" + s1 + ""' and inner condition is '"" + s2 + ""')."");
    reportError(errorPath, Severity::warning, ""identicalInnerCondition"", msg, CWE398, Certainty::normal);
}",1,1,lib/checkcondition.cpp,"CheckCondition.identicalInnerConditionError:void(Token*,Token*,ErrorPath)",<empty>,,false,861,874,identicalInnerConditionError,,,1,"void(Token*,Token*,ErrorPath)"
111669151463,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::identicalConditionAfterEarlyExitError(const Token *cond1, const Token* cond2, ErrorPath errorPath)
{
    if (diag(cond1) & diag(cond2))
        return;

    const bool isReturnValue = cond2 && Token::simpleMatch(cond2->astParent(), ""return"");

    const std::string cond(cond1 ? cond1->expressionString() : ""x"");
    const std::string value = (cond2 && cond2->valueType() && cond2->valueType()->type == ValueType::Type::BOOL) ? ""false"" : ""0"";

    errorPath.emplace_back(cond1, ""If condition '"" + cond + ""' is true, the function will return/exit"");
    errorPath.emplace_back(cond2, (isReturnValue ? ""Returning identical expression '"" : ""Testing identical condition '"") + cond + ""'"");

    reportError(errorPath,
                Severity::warning,
                ""identicalConditionAfterEarlyExit"",
                isReturnValue
                ? (""Identical condition and return expression '"" + cond + ""', return value is always "" + value)
                : (""Identical cond...",1,1,lib/checkcondition.cpp,"CheckCondition.identicalConditionAfterEarlyExitError:void(Token*,Token*,ErrorPath)",<empty>,,false,876,897,identicalConditionAfterEarlyExitError,,,1,"void(Token*,Token*,ErrorPath)"
111669151464,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"static std::string invertOperatorForOperandSwap(std::string s)
{
    if (s[0] == '<')
        s[0] = '>';
    else if (s[0] == '>')
        s[0] = '<';
    return s;
}",1,1,lib/checkcondition.cpp,invertOperatorForOperandSwap:string(std.string),<empty>,,false,916,923,invertOperatorForOperandSwap,,,1,string(std.string)
111669151465,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"static int sign(const T v) {
    return static_cast<int>(v > 0) - static_cast<int>(v < 0);
}",1,1,lib/checkcondition.cpp,sign:int(T),<empty>,,false,926,928,sign,,,1,int(T)
111669151466,METHOD,<empty>,<empty>,"[](std::string& op, const bool invert) {
        if (invert) {
            if (op == ""=="")
                op = ""!="";
            else if (op == ""!="")
                op = ""=="";
            else if (op == ""<"")
                op = "">="";
            else if (op == "">"")
                op = ""<="";
            else if (op == ""<="")
                op = "">"";
            else if (op == "">="")
                op = ""<"";
        }
    }",24,5,lib/checkcondition.cpp,"lib/checkcondition.cpp:<global>.sufficientCondition.<lambda>5:void(std.string&,bool)",<empty>,,false,933,948,<lambda>5,,,1,"void(std.string&,bool)"
111669151467,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"static int sufficientCondition(std::string op1, const bool not1, const T value1, std::string op2, const bool not2, const T value2, const bool isAnd) {
    auto transformOp = [](std::string& op, const bool invert) {
        if (invert) {
            if (op == ""=="")
                op = ""!="";
            else if (op == ""!="")
                op = ""=="";
            else if (op == ""<"")
                op = "">="";
            else if (op == "">"")
                op = ""<="";
            else if (op == ""<="")
                op = "">"";
            else if (op == "">="")
                op = ""<"";
        }
    };
    transformOp(op1, not1);
    transformOp(op2, not2);
    int res = 0;
    bool equal = false;
    if (op1 == op2) {
        equal = true;
        if (op1 == "">"" || op1 == "">="")
            res = sign(value1 - value2);
        else if (op1 == ""<"" || op1 == ""<="")
            res = -sign(value1 - value2);
    } else { // not equal
        if (op1 == ""!="")
            res = 1;
        else ...",1,1,lib/checkcondition.cpp,"sufficientCondition:int(std.string,bool,T,std.string,bool,T,bool)",<empty>,,false,932,978,sufficientCondition,,,1,"int(std.string,bool,T,std.string,bool,T,bool)"
111669151468,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"static bool checkIntRelation(const std::string &op, const T value1, const T value2)
{
    return (op == ""=="" && value1 == value2) ||
           (op == ""!="" && value1 != value2) ||
           (op == "">"" && value1 >  value2) ||
           (op == "">="" && value1 >= value2) ||
           (op == ""<"" && value1 <  value2) ||
           (op == ""<="" && value1 <= value2);
}",1,1,lib/checkcondition.cpp,"checkIntRelation:bool(std.string&,T,T)",<empty>,,false,981,989,checkIntRelation,,,1,"bool(std.string&,T,T)"
111669151469,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"static bool checkFloatRelation(const std::string &op, const double value1, const double value2)
{
    return (op == "">"" && value1 >  value2) ||
           (op == "">="" && value1 >= value2) ||
           (op == ""<"" && value1 <  value2) ||
           (op == ""<="" && value1 <= value2);
}",1,1,lib/checkcondition.cpp,"checkFloatRelation:bool(std.string&,double,double)",<empty>,,false,991,997,checkFloatRelation,,,1,"bool(std.string&,double,double)"
111669151470,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"static T getvalue3(const T value1, const T value2)
{
    const T min = std::min(value1, value2);
    if (min== std::numeric_limits<T>::max())
        return min;
    return min + 1; // see #5895
}",1,1,lib/checkcondition.cpp,"getvalue3:T(T,T)",<empty>,,false,1000,1006,getvalue3,,,1,"T(T,T)"
111669151471,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"double getvalue3(const double value1, const double value2)
{
    return (value1 + value2) / 2.0;
}",1,1,lib/checkcondition.cpp,"getvalue3:double(double,double)",<empty>,,false,1009,1012,getvalue3,,,1,"double(double,double)"
111669151472,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"static inline T getvalue(const int test, const T value1, const T value2)
{
    // test:
    // 1 => return value that is less than both value1 and value2
    // 2 => return value1
    // 3 => return value that is between value1 and value2
    // 4 => return value2
    // 5 => return value that is larger than both value1 and value2
    switch (test) {
    case 1:
        return std::numeric_limits<T>::lowest();
    case 2:
        return value1;
    case 3:
        return getvalue3<T>(value1, value2);
    case 4:
        return value2;
    case 5:
        return std::numeric_limits<T>::max();
    }
    return 0;
}",1,1,lib/checkcondition.cpp,"getvalue:T(int,T,T)",<empty>,,false,1016,1037,getvalue,,,1,"T(int,T,T)"
111669151473,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"static bool parseComparison(const Token *comp, bool &not1, std::string &op, std::string &value, const Token *&expr, bool &inconclusive)
{
    not1 = false;
    while (comp && comp->str() == ""!"") {
        not1 = !(not1);
        comp = comp->astOperand1();
    }

    if (!comp)
        return false;

    const Token* op1 = comp->astOperand1();
    const Token* op2 = comp->astOperand2();
    if (!comp->isComparisonOp() || !op1 || !op2) {
        op = ""!="";
        value = ""0"";
        expr = comp;
    } else if (op1->isLiteral()) {
        if (op1->isExpandedMacro())
            return false;
        op = invertOperatorForOperandSwap(comp->str());
        if (op1->enumerator() && op1->enumerator()->value_known)
            value = MathLib::toString(op1->enumerator()->value);
        else
            value = op1->str();
        expr = op2;
    } else if (comp->astOperand2()->isLiteral()) {
        if (op2->isExpandedMacro())
            return false;
        op = comp->str();
        ...",1,1,lib/checkcondition.cpp,"parseComparison:bool(Token*,bool&,std.string&,std.string&,Token*&,bool&)",<empty>,,false,1039,1084,parseComparison,,,1,"bool(Token*,bool&,std.string&,std.string&,Token*&,bool&)"
111669151474,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"static std::string conditionString(bool not1, const Token *expr1, const std::string &op, const std::string &value1)
{
    if (expr1->astParent()->isComparisonOp())
        return std::string(not1 ? ""!("" : """") + expr1->expressionString() +
               "" "" +
               op +
               "" "" +
               value1 +
               (not1 ? "")"" : """");

    return std::string(not1 ? ""!"" : """") + expr1->expressionString();
}",1,1,lib/checkcondition.cpp,"conditionString:string(bool,Token*,std.string&,std.string&)",<empty>,,false,1086,1097,conditionString,,,1,"string(bool,Token*,std.string&,std.string&)"
111669151475,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"static std::string conditionString(const Token * tok)
{
    if (!tok)
        return """";
    if (tok->isComparisonOp()) {
        bool inconclusive = false;
        bool not_;
        std::string op, value;
        const Token *expr;
        if (parseComparison(tok, not_, op, value, expr, inconclusive) && expr->isName()) {
            return conditionString(not_, expr, op, value);
        }
    }
    if (Token::Match(tok, ""%cop%|&&|%oror%"")) {
        if (tok->astOperand2())
            return conditionString(tok->astOperand1()) + "" "" + tok->str() + "" "" + conditionString(tok->astOperand2());
        return tok->str() + ""("" + conditionString(tok->astOperand1()) + "")"";

    }
    return tok->expressionString();
}",1,1,lib/checkcondition.cpp,conditionString:string(Token*),<empty>,,false,1099,1119,conditionString,,,1,string(Token*)
111669151476,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"static bool isIfConstexpr(const Token* tok) {
    const Token* const top = tok->astTop();
    return Token::simpleMatch(top->astOperand1(), ""if"") && top->astOperand1()->isConstexpr();
}",1,1,lib/checkcondition.cpp,isIfConstexpr:bool(Token*),<empty>,,false,1121,1124,isIfConstexpr,,,1,bool(Token*)
111669151477,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::checkIncorrectLogicOperator()
{
    const bool printStyle = mSettings->severity.isEnabled(Severity::style);
    const bool printWarning = mSettings->severity.isEnabled(Severity::warning);
    if (!printWarning && !printStyle && !mSettings->isPremiumEnabled(""incorrectLogicOperator""))
        return;
    const bool printInconclusive = mSettings->certainty.isEnabled(Certainty::inconclusive);

    logChecker(""CheckCondition::checkIncorrectLogicOperator""); // style,warning

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {

        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!Token::Match(tok, ""%oror%|&&"") || !tok->astOperand1() || !tok->astOperand2())
                continue;


            // 'A && (!A || B)' is equivalent to 'A && B'
            // 'A || (!A && B)' is equivalent to 'A || B'
            // 'A &...",1,1,lib/checkcondition.cpp,CheckCondition.checkIncorrectLogicOperator:void(),<empty>,,false,1126,1336,checkIncorrectLogicOperator,,,1,void()
111669151478,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::incorrectLogicOperatorError(const Token *tok, const std::string &condition, bool always, bool inconclusive, ErrorPath errors)
{
    if (diag(tok))
        return;
    errors.emplace_back(tok, """");
    if (always)
        reportError(errors, Severity::warning, ""incorrectLogicOperator"",
                    ""Logical disjunction always evaluates to true: "" + condition + "".\\n""
                    ""Logical disjunction always evaluates to true: "" + condition + "". ""
                    ""Are these conditions necessary? Did you intend to use && instead? Are the numbers correct? Are you comparing the correct variables?"", CWE571, inconclusive ? Certainty::inconclusive : Certainty::normal);
    else
        reportError(errors, Severity::warning, ""incorrectLogicOperator"",
                    ""Logical conjunction always evaluates to false: "" + condition + "".\\n""
                    ""Logical conjunction always evaluates to false: "" + condition + "". ""
                    ""Are the...",1,1,lib/checkcondition.cpp,"CheckCondition.incorrectLogicOperatorError:void(Token*,std.string&,bool,bool,ErrorPath)",<empty>,,false,1338,1353,incorrectLogicOperatorError,,,1,"void(Token*,std.string&,bool,bool,ErrorPath)"
111669151479,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::redundantConditionError(const Token *tok, const std::string &text, bool inconclusive)
{
    if (diag(tok))
        return;
    reportError(tok, Severity::style, ""redundantCondition"", ""Redundant condition: "" + text, CWE398, inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checkcondition.cpp,"CheckCondition.redundantConditionError:void(Token*,std.string&,bool)",<empty>,,false,1355,1360,redundantConditionError,,,1,"void(Token*,std.string&,bool)"
111669151480,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::checkModuloAlwaysTrueFalse()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckCondition::checkModuloAlwaysTrueFalse""); // warning

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!tok->isComparisonOp())
                continue;
            const Token *num, *modulo;
            if (Token::simpleMatch(tok->astOperand1(), ""%"") && Token::Match(tok->astOperand2(), ""%num%"")) {
                modulo = tok->astOperand1();
                num = tok->astOperand2();
            } else if (Token::Match(tok->astOperand1(), ""%num%"") && Token::simpleMatch(tok->astOperand2(), ""%"")) {
                num = tok->astOperand1();
                modulo = tok->astOperand2();
            } else {
                continue;
   ...",1,1,lib/checkcondition.cpp,CheckCondition.checkModuloAlwaysTrueFalse:void(),<empty>,,false,1365,1393,checkModuloAlwaysTrueFalse,,,1,void()
111669151481,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::moduloAlwaysTrueFalseError(const Token* tok, const std::string& maxVal)
{
    if (diag(tok))
        return;
    reportError(tok, Severity::warning, ""moduloAlwaysTrueFalse"",
                ""Comparison of modulo result is predetermined, because it is always less than "" + maxVal + ""."", CWE398, Certainty::normal);
}",1,1,lib/checkcondition.cpp,"CheckCondition.moduloAlwaysTrueFalseError:void(Token*,std.string&)",<empty>,,false,1395,1401,moduloAlwaysTrueFalseError,,,1,"void(Token*,std.string&)"
111669151482,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"static int countPar(const Token *tok1, const Token *tok2)
{
    int par = 0;
    for (const Token *tok = tok1; tok && tok != tok2; tok = tok->next()) {
        if (tok->str() == ""("")
            ++par;
        else if (tok->str() == "")"")
            --par;
        else if (tok->str() == "";"")
            return -1;
    }
    return par;
}",1,1,lib/checkcondition.cpp,"countPar:int(Token*,Token*)",<empty>,,false,1403,1415,countPar,,,1,"int(Token*,Token*)"
111669151483,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::clarifyCondition()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""clarifyCondition""))
        return;

    logChecker(""CheckCondition::clarifyCondition""); // style

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (Token::Match(tok, ""( %name% [=&|^]"")) {
                for (const Token *tok2 = tok->tokAt(3); tok2; tok2 = tok2->next()) {
                    if (tok2->str() == ""("" || tok2->str() == ""["")
                        tok2 = tok2->link();
                    else if (tok2->isComparisonOp()) {
                        // This might be a template
                        if (!tok2->isC() && tok2->link())
                            break;
                        if (Token::simpleMatch(tok2->astParent(), ""?""))
...",1,1,lib/checkcondition.cpp,CheckCondition.clarifyCondition:void(),<empty>,,false,1421,1460,clarifyCondition,,,1,void()
111669151484,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::clarifyConditionError(const Token *tok, bool assign, bool boolop)
{
    std::string errmsg;

    if (assign)
        errmsg = ""Suspicious condition (assignment + comparison); Clarify expression with parentheses."";

    else if (boolop)
        errmsg = ""Boolean result is used in bitwise operation. Clarify expression with parentheses.\\n""
                 ""Suspicious expression. Boolean result is used in bitwise operation. The operator '!' ""
                 ""and the comparison operators have higher precedence than bitwise operators. ""
                 ""It is recommended that the expression is clarified with parentheses."";
    else
        errmsg = ""Suspicious condition (bitwise operator + comparison); Clarify expression with parentheses.\\n""
                 ""Suspicious condition. Comparison operators have higher precedence than bitwise operators. ""
                 ""Please clarify the condition with parentheses."";

    reportError(tok,
                Severity::s...",1,1,lib/checkcondition.cpp,"CheckCondition.clarifyConditionError:void(Token*,bool,bool)",<empty>,,false,1462,1483,clarifyConditionError,,,1,"void(Token*,bool,bool)"
111669151485,METHOD,<empty>,<empty>,"[](const Token* tok) {
                return Token::Match(tok, ""[|(|&|+|-|*|/|%|^|>>|<<"") && !Token::simpleMatch(tok, ""( )"");
            }",43,13,lib/checkcondition.cpp,lib/checkcondition.cpp:<global>.CheckCondition.alwaysTrueFalse.<lambda>6:bool(Token*),<empty>,,false,1571,1573,<lambda>6,,,1,bool(Token*)
111669151486,METHOD,<empty>,<empty>,"[&](const Token * tok2) {
                if (!tok2)
                    return ChildrenToVisit::none;
                if (tok2->isExpandedMacro()) {
                    isExpandedMacro = true;
                    return ChildrenToVisit::done;
                }
                return ChildrenToVisit::op1_and_op2;
            }",32,13,lib/checkcondition.cpp,lib/checkcondition.cpp:<global>.CheckCondition.alwaysTrueFalse.<lambda>7:ChildrenToVisit(Token*),<empty>,,false,1588,1596,<lambda>7,,,1,ChildrenToVisit(Token*)
111669151487,METHOD,<empty>,<empty>,"[&](const Token * tok2) {
                if (!tok2)
                    return ChildrenToVisit::none;
                if (tok2->isNumber())
                    return ChildrenToVisit::none;
                if (Token::simpleMatch(tok2->previous(), ""sizeof ("")) {
                    hasSizeof = true;
                    return ChildrenToVisit::none;
                }
                if (tok2->isComparisonOp() || tok2->isArithmeticalOp()) {
                    return ChildrenToVisit::op1_and_op2;
                }
                return ChildrenToVisit::none;
            }",32,13,lib/checkcondition.cpp,lib/checkcondition.cpp:<global>.CheckCondition.alwaysTrueFalse.<lambda>8:ChildrenToVisit(Token*),<empty>,,false,1610,1623,<lambda>8,,,1,ChildrenToVisit(Token*)
111669151488,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::alwaysTrueFalse()
{
    if (!mSettings->severity.isEnabled(Severity::style) &&
        !mSettings->isPremiumEnabled(""alwaysTrue"") &&
        !mSettings->isPremiumEnabled(""alwaysFalse"") &&
        !mSettings->isPremiumEnabled(""knownConditionTrueFalse""))
        return;

    logChecker(""CheckCondition::alwaysTrueFalse""); // style

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            // don't write false positives when templates are used or inside of asserts or non-evaluated contexts
            if (tok->link() && (Token::simpleMatch(tok, ""<"") ||
                                Token::Match(tok->previous(), ""static_assert|assert|ASSERT|sizeof|decltype (""))) {
                tok = tok->link();
                continue;
            }
            if (!tok->hasKnownIntV...",1,1,lib/checkcondition.cpp,CheckCondition.alwaysTrueFalse:void(),<empty>,,false,1485,1630,alwaysTrueFalse,,,1,void()
111669151489,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::alwaysTrueFalseError(const Token* tok, const Token* condition, const ValueFlow::Value* value)
{
    const bool alwaysTrue = value && (value->intvalue != 0 || value->isImpossible());
    const std::string expr = tok ? tok->expressionString() : std::string(""x"");
    const std::string conditionStr = (Token::simpleMatch(condition, ""return"") ? ""Return value"" : ""Condition"");
    const std::string errmsg = conditionStr + "" '"" + expr + ""' is always "" + bool_to_string(alwaysTrue);
    const ErrorPath errorPath = getErrorPath(tok, value, errmsg);
    reportError(errorPath,
                Severity::style,
                ""knownConditionTrueFalse"",
                errmsg,
                (alwaysTrue ? CWE571 : CWE570), Certainty::normal);
}",1,1,lib/checkcondition.cpp,"CheckCondition.alwaysTrueFalseError:void(Token*,Token*,ValueFlow.Value*)",<empty>,,false,1632,1644,alwaysTrueFalseError,,,1,"void(Token*,Token*,ValueFlow.Value*)"
111669151490,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::checkInvalidTestForOverflow()
{
    // Interesting blogs:
    // https://www.airs.com/blog/archives/120
    // https://kristerw.blogspot.com/2016/02/how-undefined-signed-overflow-enables.html
    // https://research.checkpoint.com/2020/optout-compiler-undefined-behavior-optimizations/

    // x + c < x       ->   false
    // x + c <= x      ->   false
    // x + c > x       ->   true
    // x + c >= x      ->   true

    // x + y < x       ->   y < 0


    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckCondition::checkInvalidTestForOverflow""); // warning

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (!Token::Match(tok, ""<|<=|>=|>"") || !tok->isBinaryOp())
            continue;

        const Token *lhsTokens[2] = {tok->astOperand1(), tok->astOperand2()};
        for (const Token *lhs: lhsTokens) {
            std::string cmp = tok->str();
            if (lhs == tok->astOperan...",1,1,lib/checkcondition.cpp,CheckCondition.checkInvalidTestForOverflow:void(),<empty>,,false,1646,1732,checkInvalidTestForOverflow,,,1,void()
111669151491,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::invalidTestForOverflow(const Token* tok, const ValueType *valueType, const std::string &replace)
{
    const std::string expr = (tok ? tok->expressionString() : std::string(""x + c < x""));
    const std::string overflow = (valueType && valueType->pointer) ? ""pointer overflow"" : ""signed integer overflow"";

    std::string errmsg =
        ""Invalid test for overflow '"" +  expr + ""'; "" + overflow + "" is undefined behavior."";
    if (replace == ""false"" || replace == ""true"")
        errmsg += "" Some mainstream compilers remove such overflow tests when optimising the code and assume it's always "" + replace + ""."";
    else
        errmsg += "" Some mainstream compilers removes handling of overflows when optimising the code and change the code to '"" + replace + ""'."";
    reportError(tok, Severity::warning, ""invalidTestForOverflow"", errmsg, uncheckedErrorConditionCWE, Certainty::normal);
}",1,1,lib/checkcondition.cpp,"CheckCondition.invalidTestForOverflow:void(Token*,ValueType*,std.string&)",<empty>,,false,1734,1746,invalidTestForOverflow,,,1,"void(Token*,ValueType*,std.string&)"
111669151492,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::checkPointerAdditionResultNotNull()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckCondition::checkPointerAdditionResultNotNull""); // warning

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {

        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
            if (!tok->isComparisonOp() || !tok->astOperand1() || !tok->astOperand2())
                continue;

            // Macros might have pointless safety checks
            if (tok->isExpandedMacro())
                continue;

            const Token *calcToken, *exprToken;
            if (tok->astOperand1()->str() == ""+"") {
                calcToken = tok->astOperand1();
                exprToken = tok->astOperand2();
            } else if (tok->astOperand2()->str() == ""+"") {
                calcToken = tok->astOperand2();
     ...",1,1,lib/checkcondition.cpp,CheckCondition.checkPointerAdditionResultNotNull:void(),<empty>,,false,1749,1788,checkPointerAdditionResultNotNull,,,1,void()
111669151493,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::pointerAdditionResultNotNullError(const Token *tok, const Token *calc)
{
    const std::string s = calc ? calc->expressionString() : ""ptr+1"";
    reportError(tok, Severity::warning, ""pointerAdditionResultNotNull"", ""Comparison is wrong. Result of '"" + s + ""' can't be 0 unless there is pointer overflow, and pointer overflow is undefined behaviour."");
}",1,1,lib/checkcondition.cpp,"CheckCondition.pointerAdditionResultNotNullError:void(Token*,Token*)",<empty>,,false,1790,1794,pointerAdditionResultNotNullError,,,1,"void(Token*,Token*)"
111669151494,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::checkDuplicateConditionalAssign()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""duplicateConditionalAssign""))
        return;

    logChecker(""CheckCondition::checkDuplicateConditionalAssign""); // style

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope *scope : symbolDatabase->functionScopes) {
        for (const Token *tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
            if (!Token::simpleMatch(tok, ""if (""))
                continue;
            if (!Token::simpleMatch(tok->linkAt(1), "") {""))
                continue;
            const Token *blockTok = tok->linkAt(1)->next();
            const Token *condTok = tok->next()->astOperand2();
            const bool isBoolVar = Token::Match(condTok, ""!| %var%"");
            if (!isBoolVar && !Token::Match(condTok, ""==|!=""))
                continue;
            if ((isBoolVar || condTok->str() == ""...",1,1,lib/checkcondition.cpp,CheckCondition.checkDuplicateConditionalAssign:void(),<empty>,,false,1796,1851,checkDuplicateConditionalAssign,,,1,void()
111669151495,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::duplicateConditionalAssignError(const Token *condTok, const Token* assignTok, bool isRedundant)
{
    ErrorPath errors;
    std::string msg = ""Duplicate expression for the condition and assignment."";
    if (condTok && assignTok) {
        if (condTok->str() == ""=="") {
            msg = ""Assignment '"" + assignTok->expressionString() + ""' is redundant with condition '"" + condTok->expressionString() + ""'."";
            errors.emplace_back(condTok, ""Condition '"" + condTok->expressionString() + ""'"");
            errors.emplace_back(assignTok, ""Assignment '"" + assignTok->expressionString() + ""' is redundant"");
        } else {
            msg = ""The statement 'if ("" + condTok->expressionString() + "") "" + assignTok->expressionString();
            msg += isRedundant ? ""' is redundant."" : ""' is logically equivalent to '"" + assignTok->expressionString() + ""'."";
            errors.emplace_back(assignTok, ""Assignment '"" + assignTok->expressionString() + ""'"");
            ...",1,1,lib/checkcondition.cpp,"CheckCondition.duplicateConditionalAssignError:void(Token*,Token*,bool)",<empty>,,false,1853,1872,duplicateConditionalAssignError,,,1,"void(Token*,Token*,bool)"
111669151496,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::checkAssignmentInCondition()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""assignmentInCondition""))
        return;

    logChecker(""CheckCondition::checkAssignmentInCondition""); // style

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
            if (tok->str() != ""="")
                continue;
            if (!tok->astParent())
                continue;

            // Is this assignment of container/iterator?
            if (!tok->valueType())
                continue;
            if (tok->valueType()->pointer > 0)
                continue;
            if (tok->valueType()->type != ValueType::Type::CONTAINER && tok->valueType()->type != ValueType::Type::ITERATOR)
                continue;

            // warn if this is a conditio...",1,1,lib/checkcondition.cpp,CheckCondition.checkAssignmentInCondition:void(),<empty>,,false,1875,1907,checkAssignmentInCondition,,,1,void()
111669151497,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::assignmentInCondition(const Token *eq)
{
    std::string expr = eq ? eq->expressionString() : ""x=y"";

    reportError(
        eq,
        Severity::style,
        ""assignmentInCondition"",
        ""Suspicious assignment in condition. Condition '"" + expr + ""' is always true."",
        CWE571,
        Certainty::normal);
}",1,1,lib/checkcondition.cpp,CheckCondition.assignmentInCondition:void(Token*),<empty>,,false,1909,1920,assignmentInCondition,,,1,void(Token*)
111669151498,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::checkCompareValueOutOfTypeRange()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""compareValueOutOfTypeRangeError""))
        return;

    if (mSettings->platform.type == Platform::Type::Native ||
        mSettings->platform.type == Platform::Type::Unspecified)
        return;

    logChecker(""CheckCondition::checkCompareValueOutOfTypeRange""); // style,platform

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
            if (!tok->isComparisonOp() || !tok->isBinaryOp())
                continue;

            for (int i = 0; i < 2; ++i) {
                const Token * const valueTok = (i == 0) ? tok->astOperand1() : tok->astOperand2();
                const Token * const typeTok = valueTok->astSibling();
                if (!valueTok->has...",1,1,lib/checkcondition.cpp,CheckCondition.checkCompareValueOutOfTypeRange:void(),<empty>,,false,1922,2039,checkCompareValueOutOfTypeRange,,,1,void()
111669151499,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::compareValueOutOfTypeRangeError(const Token *comparison, const std::string &type, MathLib::bigint value, bool result)
{
    reportError(
        comparison,
        Severity::style,
        ""compareValueOutOfTypeRangeError"",
        ""Comparing expression of type '"" + type + ""' against value "" + MathLib::toString(value) + "". Condition is always "" + bool_to_string(result) + ""."",
        CWE398,
        Certainty::normal);
}",1,1,lib/checkcondition.cpp,"CheckCondition.compareValueOutOfTypeRangeError:void(Token*,std.string&,MathLib.bigint,bool)",<empty>,,false,2041,2050,compareValueOutOfTypeRangeError,,,1,"void(Token*,std.string&,MathLib.bigint,bool)"
111669151500,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    CheckCondition checkCondition(&tokenizer, &tokenizer.getSettings(), errorLogger);
    checkCondition.multiCondition();
    checkCondition.clarifyCondition();   // not simplified because ifAssign
    checkCondition.multiCondition2();
    checkCondition.checkIncorrectLogicOperator();
    checkCondition.checkInvalidTestForOverflow();
    checkCondition.duplicateCondition();
    checkCondition.checkPointerAdditionResultNotNull();
    checkCondition.checkDuplicateConditionalAssign();
    checkCondition.assignIf();
    checkCondition.checkBadBitmaskCheck();
    checkCondition.comparison();
    checkCondition.checkModuloAlwaysTrueFalse();
    checkCondition.checkAssignmentInCondition();
    checkCondition.checkCompareValueOutOfTypeRange();
    checkCondition.alwaysTrueFalse();
}",1,1,lib/checkcondition.cpp,"CheckCondition.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,2052,2070,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669151501,METHOD,lib/checkcondition.cpp:<global>,TYPE_DECL,"void CheckCondition::getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const
{
    CheckCondition c(nullptr, settings, errorLogger);

    c.assignIfError(nullptr, nullptr, """", false);
    c.badBitmaskCheckError(nullptr);
    c.comparisonError(nullptr, ""&"", 6, ""=="", 1, false);
    c.duplicateConditionError(nullptr, nullptr, ErrorPath{});
    c.overlappingElseIfConditionError(nullptr, 1);
    c.mismatchingBitAndError(nullptr, 0xf0, nullptr, 1);
    c.oppositeInnerConditionError(nullptr, nullptr, ErrorPath{});
    c.identicalInnerConditionError(nullptr, nullptr, ErrorPath{});
    c.identicalConditionAfterEarlyExitError(nullptr, nullptr, ErrorPath{});
    c.incorrectLogicOperatorError(nullptr, ""foo > 3 && foo < 4"", true, false, ErrorPath{});
    c.redundantConditionError(nullptr, ""If x > 11 the condition x > 10 is always true."", false);
    c.moduloAlwaysTrueFalseError(nullptr, ""1"");
    c.clarifyConditionError(nullptr, true, false);
    c.alwaysTrueFalseError(nullptr...",1,1,lib/checkcondition.cpp,"CheckCondition.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,2072,2095,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669151502,METHOD,lib/checkcondition.h:<global>,TYPE_DECL,<global>,1,1,lib/checkcondition.h,lib/checkcondition.h:<global>,<empty>,,false,1,184,<global>,,,1,
111669151503,METHOD,lib/checkers.cpp:<global>,TYPE_DECL,<global>,1,1,lib/checkers.cpp,lib/checkers.cpp:<global>,<empty>,,false,1,2119,<global>,,,1,
111669151504,METHOD,lib/checkers.h:<global>,TYPE_DECL,<global>,1,1,lib/checkers.h,lib/checkers.h:<global>,<empty>,,false,1,89,<global>,,,1,
111669151505,METHOD,lib/checkersidmapping.cpp:<global>,TYPE_DECL,<global>,1,50,lib/checkersidmapping.cpp,lib/checkersidmapping.cpp:<global>,<empty>,,false,1,217,<global>,,,1,
111669151506,METHOD,lib/checkersreport.cpp:<global>,TYPE_DECL,"static bool isCppcheckPremium(const Settings& settings) {
    return (settings.cppcheckCfgProductName.compare(0, 16, ""Cppcheck Premium"") == 0);
}",1,1,lib/checkersreport.cpp,isCppcheckPremium:bool(Settings&),<empty>,,false,33,35,isCppcheckPremium,,,1,bool(Settings&)
111669151507,METHOD,lib/checkersreport.cpp:<global>,TYPE_DECL,<global>,1,1,lib/checkersreport.cpp,lib/checkersreport.cpp:<global>,<empty>,,false,1,310,<global>,,,1,
111669151508,METHOD,<empty>,<empty>,"[](const AddonInfo& addonInfo) {
        return addonInfo.name == ""misra"";
    }",103,5,lib/checkersreport.cpp,lib/checkersreport.cpp:<global>.getMisraCVersion.<lambda>0:bool(AddonInfo&),<empty>,,false,44,46,<lambda>0,,,1,bool(AddonInfo&)
111669151509,METHOD,lib/checkersreport.cpp:<global>,TYPE_DECL,"static int getMisraCVersion(const Settings& settings) {
    if (settings.premiumArgs.find(""misra-c-2012"") != std::string::npos)
        return 2012;
    if (settings.premiumArgs.find(""misra-c-2023"") != std::string::npos)
        return 2023;
    if (settings.addons.count(""misra""))
        return 2012;
    const bool misraAddonInfo = std::any_of(settings.addonInfos.cbegin(), settings.addonInfos.cend(), [](const AddonInfo& addonInfo) {
        return addonInfo.name == ""misra"";
    });
    if (misraAddonInfo)
        return 2012;
    return 0;
}",1,1,lib/checkersreport.cpp,getMisraCVersion:int(Settings&),<empty>,,false,37,50,getMisraCVersion,,,1,int(Settings&)
111669151510,METHOD,lib/checkersreport.cpp:<global>,TYPE_DECL,"static bool isMisraRuleActive(const std::set<std::string>& activeCheckers, const std::string& rule) {
    if (activeCheckers.count(""Misra C: "" + rule))
        return true;
    if (rule == ""1.1"")
        return true; // syntax error
    if (rule == ""1.3"")
        return true; // undefined behavior
    if (rule == ""2.1"")
        return activeCheckers.count(""CheckCondition::alwaysTrueFalse"") != 0;
    if (rule == ""2.6"")
        return activeCheckers.count(""CheckOther::checkUnusedLabel"") != 0;
    if (rule == ""2.8"")
        return activeCheckers.count(""CheckUnusedVar::checkFunctionVariableUsage"") != 0;
    if (rule == ""5.3"")
        return activeCheckers.count(""CheckOther::checkShadowVariables"") != 0;
    if (rule == ""8.13"")
        return activeCheckers.count(""CheckOther::checkConstPointer"") != 0;
    if (rule == ""9.1"")
        return true; // uninitvar
    if (rule == ""12.5"")
        return activeCheckers.count(""CheckOther::checkConstPointer"") != 0;
    if (rule == ""14.3"")
        re...",1,1,lib/checkersreport.cpp,"isMisraRuleActive:bool(std.set<std.string>&,std.string&)",<empty>,,false,52,107,isMisraRuleActive,,,1,"bool(std.set<std.string>&,std.string&)"
111669151511,METHOD,lib/checkersreport.cpp:<global>,TYPE_DECL,"CheckersReport::CheckersReport(const Settings& settings, const std::set<std::string>& activeCheckers)
    : mSettings(settings), mActiveCheckers(activeCheckers)
{}",1,2,lib/checkersreport.cpp,"CheckersReport.CheckersReport:ANY(Settings&,std.set<std.string>&)",<empty>,,false,109,111,CheckersReport,,,1,"CheckersReport.CheckersReport:ANY(Settings&,std.set<std.string>&)(Settings&,std.set<std.string>&)"
111669151512,METHOD,lib/checkersreport.cpp:<global>,TYPE_DECL,"int CheckersReport::getActiveCheckersCount()
{
    if (mAllCheckersCount == 0) {
        countCheckers();
    }
    return mActiveCheckersCount;
}",1,1,lib/checkersreport.cpp,CheckersReport.getActiveCheckersCount:int(),<empty>,,false,113,119,getActiveCheckersCount,,,1,int()
111669151513,METHOD,lib/checkersreport.cpp:<global>,TYPE_DECL,"int CheckersReport::getAllCheckersCount()
{
    if (mAllCheckersCount == 0) {
        countCheckers();
    }
    return mAllCheckersCount;
}",1,1,lib/checkersreport.cpp,CheckersReport.getAllCheckersCount:int(),<empty>,,false,121,127,getAllCheckersCount,,,1,int()
111669151514,METHOD,lib/checkersreport.cpp:<global>,TYPE_DECL,"void CheckersReport::countCheckers()
{
    mActiveCheckersCount = mAllCheckersCount = 0;

    for (const auto& checkReq: checkers::allCheckers) {
        if (mActiveCheckers.count(checkReq.first) > 0)
            ++mActiveCheckersCount;
        ++mAllCheckersCount;
    }
    for (const auto& checkReq: checkers::premiumCheckers) {
        if (mActiveCheckers.count(checkReq.first) > 0)
            ++mActiveCheckersCount;
        ++mAllCheckersCount;
    }
    if (mSettings.premiumArgs.find(""misra-c-"") != std::string::npos || mSettings.addons.count(""misra"")) {
        for (const checkers::MisraInfo& info: checkers::misraC2012Rules) {
            const std::string rule = std::to_string(info.a) + ""."" + std::to_string(info.b);
            const bool active = isMisraRuleActive(mActiveCheckers, rule);
            if (active)
                ++mActiveCheckersCount;
            ++mAllCheckersCount;
        }
    }
}",1,1,lib/checkersreport.cpp,CheckersReport.countCheckers:void(),<empty>,,false,129,152,countCheckers,,,1,void()
111669151515,METHOD,<empty>,<empty>,"[&fout, cppcheckPremium]
                             (const std::string& title,
                             const Settings& settings,
                             const std::set<std::string>& activeCheckers,
                             const std::map<std::string, std::string>& premiumCheckers,
                             const std::string& substring) {
        fout << std::endl << std::endl;
        fout << title << std::endl;
        fout << std::string(title.size(), '-') << std::endl;
        if (!cppcheckPremium) {
            fout << ""Not available, Cppcheck Premium is not used"" << std::endl;
            return;
        }
        int maxCheckerSize = 0;
        for (const auto& checkReq: premiumCheckers) {
            const std::string& checker = checkReq.first;
            if (checker.find(substring) != std::string::npos && checker.size() > maxCheckerSize)
                maxCheckerSize = checker.size();
        }
        for (const auto& checkReq: premiumCheckers) {
      ...",26,5,lib/checkersreport.cpp,"lib/checkersreport.cpp:<global>.CheckersReport.getReport<const>.<lambda>1:void(std.string&,Settings&,std.set<std.string>&,std.map<std.string,std.string>&,std.string&)",<empty>,,false,193,241,<lambda>1,,,1,"void(std.string&,Settings&,std.set<std.string>&,std.map<std.string,std.string>&,std.string&)"
111669151516,METHOD,lib/checkersreport.cpp:<global>,TYPE_DECL,"std::string CheckersReport::getReport(const std::string& criticalErrors) const
{
    std::ostringstream fout;

    fout << ""Critical errors"" << std::endl;
    fout << ""---------------"" << std::endl;
    if (!criticalErrors.empty()) {
        fout << ""There were critical errors ("" << criticalErrors << "")."" << std::endl;
        fout << ""These cause the analysis of the file to end prematurely."" << std::endl;
    } else {
        fout << ""No critical errors encountered."" << std::endl;
        // TODO: mention ""information"" and ""debug"" as source for indications of bailouts
        // TODO: still rephrase this - this message does not provides confidence in the results
        // TODO: document what a bailout is and why it is done - mention it in the upcoming security/tuning guide
        // TODO: make bailouts a seperate group - need to differentiate between user bailouts (missing data like configuration/includes) and internal bailouts (e.g. limitations of ValueFlow)
        fout << ""Not...",1,1,lib/checkersreport.cpp,CheckersReport.getReport<const>:string(std.string&),<empty>,,false,154,292,getReport,,,1,string(std.string&)
111669151517,METHOD,lib/checkersreport.cpp:<global>,TYPE_DECL,"std::string CheckersReport::getXmlReport(const std::string& criticalErrors) const
{
    std::string ret;
    if (!criticalErrors.empty())
        ret += ""    <critical-errors>"" + criticalErrors + ""</critical-errors>\\n"";
    else
        ret += ""    <critical-errors/>\\n"";
    ret += ""    <checkers-report>\\n"";
    const int misraCVersion = getMisraCVersion(mSettings);
    for (std::string checker: mActiveCheckers) {
        if (checker.compare(0,8,""Misra C:"") == 0)
            checker = ""Misra C "" + std::to_string(misraCVersion) + "":"" + checker.substr(8);
        ret += ""        <checker id=\\"""" + checker + ""\\""/>\\n"";
    }
    ret += ""    </checkers-report>"";
    return ret;
}",1,1,lib/checkersreport.cpp,CheckersReport.getXmlReport<const>:string(std.string&),<empty>,,false,294,310,getXmlReport,,,1,string(std.string&)
111669151518,METHOD,lib/checkersreport.h:<global>,TYPE_DECL,<global>,1,1,lib/checkersreport.h,lib/checkersreport.h:<global>,<empty>,,false,1,49,<global>,,,1,
111669151519,METHOD,lib/checkexceptionsafety.cpp:<global>,TYPE_DECL,"void CheckExceptionSafety::destructors()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckExceptionSafety::destructors""); // warning

    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();

    // Perform check..
    for (const Scope * scope : symbolDatabase->functionScopes) {
        const Function * function = scope->function;
        if (!function)
            continue;
        // only looking for destructors
        if (function->type == FunctionType::eDestructor) {
            // Inspect this destructor.
            for (const Token *tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
                // Skip try blocks
                if (Token::simpleMatch(tok, ""try {"")) {
                    tok = tok->linkAt(1);
                }

                // Skip uncaught exceptions
                else if (Token::simpleMatch(tok, ""if ( ! std :: uncaught_exception ( ) ) {"")) {
       ...",1,1,lib/checkexceptionsafety.cpp,CheckExceptionSafety.destructors:void(),<empty>,,false,48,84,destructors,,,1,void()
111669151520,METHOD,lib/checkexceptionsafety.cpp:<global>,TYPE_DECL,<global>,1,78,lib/checkexceptionsafety.cpp,lib/checkexceptionsafety.cpp:<global>,<empty>,,false,1,438,<global>,,,1,
111669151521,METHOD,lib/checkexceptionsafety.cpp:<global>,TYPE_DECL,"void CheckExceptionSafety::destructorsError(const Token * const tok, const std::string &className)
{
    reportError(tok, Severity::warning, ""exceptThrowInDestructor"",
                ""Class "" + className + "" is not safe, destructor throws exception\\n""
                ""The class "" + className + "" is not safe because its destructor ""
                ""throws an exception. If "" + className + "" is used and an exception ""
                ""is thrown that is caught in an outer scope the program will terminate."", CWE398, Certainty::normal);
}",1,1,lib/checkexceptionsafety.cpp,"CheckExceptionSafety.destructorsError:void(Token*,std.string&)",<empty>,,false,86,93,destructorsError,,,1,"void(Token*,std.string&)"
111669151522,METHOD,lib/checkexceptionsafety.cpp:<global>,TYPE_DECL,"void CheckExceptionSafety::deallocThrow()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckExceptionSafety::deallocThrow""); // warning

    const bool printInconclusive = mSettings->certainty.isEnabled(Certainty::inconclusive);
    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();

    // Deallocate a global/member pointer and then throw exception
    // the pointer will be a dead pointer
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token *tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            // only looking for delete now
            if (tok->str() != ""delete"")
                continue;

            // Check if this is something similar with: ""delete p;""
            tok = tok->next();
            if (Token::simpleMatch(tok, ""[ ]""))
                tok = tok->tokAt(2);
            if (!tok || tok == scope->bodyEnd)
                bre...",1,1,lib/checkexceptionsafety.cpp,CheckExceptionSafety.deallocThrow:void(),<empty>,,false,96,157,deallocThrow,,,1,void()
111669151523,METHOD,lib/checkexceptionsafety.cpp:<global>,TYPE_DECL,"void CheckExceptionSafety::deallocThrowError(const Token * const tok, const std::string &varname)
{
    reportError(tok, Severity::warning, ""exceptDeallocThrow"", ""Exception thrown in invalid state, '"" +
                varname + ""' points at deallocated memory."", CWE398, Certainty::normal);
}",1,1,lib/checkexceptionsafety.cpp,"CheckExceptionSafety.deallocThrowError:void(Token*,std.string&)",<empty>,,false,159,163,deallocThrowError,,,1,"void(Token*,std.string&)"
111669151524,METHOD,lib/checkexceptionsafety.cpp:<global>,TYPE_DECL,"void CheckExceptionSafety::checkRethrowCopy()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""exceptRethrowCopy""))
        return;

    logChecker(""CheckExceptionSafety::checkRethrowCopy""); // style

    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope &scope : symbolDatabase->scopeList) {
        if (scope.type != ScopeType::eCatch)
            continue;

        const unsigned int varid = scope.bodyStart->tokAt(-2)->varId();
        if (varid) {
            for (const Token* tok = scope.bodyStart->next(); tok && tok != scope.bodyEnd; tok = tok->next()) {
                if (Token::simpleMatch(tok, ""catch ("") && tok->linkAt(1) && tok->linkAt(1)->next()) { // Don't check inner catch - it is handled in another iteration of outer loop.
                    tok = tok->linkAt(1)->linkAt(1);
                    if (!tok)
                        break;
                } else if (Token::Match(tok, ...",1,1,lib/checkexceptionsafety.cpp,CheckExceptionSafety.checkRethrowCopy:void(),<empty>,,false,171,202,checkRethrowCopy,,,1,void()
111669151525,METHOD,lib/checkexceptionsafety.cpp:<global>,TYPE_DECL,"void CheckExceptionSafety::rethrowCopyError(const Token * const tok, const std::string &varname)
{
    reportError(tok, Severity::style, ""exceptRethrowCopy"",
                ""Throwing a copy of the caught exception instead of rethrowing the original exception.\\n""
                ""Rethrowing an exception with 'throw "" + varname + "";' creates an unnecessary copy of '"" + varname + ""'. ""
                ""To rethrow the caught exception without unnecessary copying or slicing, use a bare 'throw;'."", CWE398, Certainty::normal);
}",1,1,lib/checkexceptionsafety.cpp,"CheckExceptionSafety.rethrowCopyError:void(Token*,std.string&)",<empty>,,false,204,210,rethrowCopyError,,,1,"void(Token*,std.string&)"
111669151526,METHOD,lib/checkexceptionsafety.cpp:<global>,TYPE_DECL,"void CheckExceptionSafety::checkCatchExceptionByValue()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""catchExceptionByValue""))
        return;

    logChecker(""CheckExceptionSafety::checkCatchExceptionByValue""); // style

    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope &scope : symbolDatabase->scopeList) {
        if (scope.type != ScopeType::eCatch)
            continue;

        // Find a pass-by-value declaration in the catch(), excluding basic types
        // e.g. catch (std::exception err)
        const Variable *var = scope.bodyStart->tokAt(-2)->variable();
        if (var && var->isClass() && !var->isPointer() && !var->isReference())
            catchExceptionByValueError(scope.classDef);
    }
}",1,1,lib/checkexceptionsafety.cpp,CheckExceptionSafety.checkCatchExceptionByValue:void(),<empty>,,false,215,234,checkCatchExceptionByValue,,,1,void()
111669151527,METHOD,lib/checkexceptionsafety.cpp:<global>,TYPE_DECL,"void CheckExceptionSafety::catchExceptionByValueError(const Token *tok)
{
    reportError(tok, Severity::style,
                ""catchExceptionByValue"", ""Exception should be caught by reference.\\n""
                ""The exception is caught by value. It could be caught ""
                ""as a (const) reference which is usually recommended in C++."", CWE398, Certainty::normal);
}",1,1,lib/checkexceptionsafety.cpp,CheckExceptionSafety.catchExceptionByValueError:void(Token*),<empty>,,false,236,242,catchExceptionByValueError,,,1,void(Token*)
111669151528,METHOD,lib/checkexceptionsafety.cpp:<global>,TYPE_DECL,"static const Token * functionThrowsRecursive(const Function * function, std::set<const Function *> & recursive)
{
    // check for recursion and bail if found
    if (!recursive.insert(function).second)
        return nullptr;

    if (!function->functionScope)
        return nullptr;

    for (const Token *tok = function->functionScope->bodyStart->next();
         tok != function->functionScope->bodyEnd; tok = tok->next()) {
        tok = skipUnreachableBranch(tok);
        if (Token::simpleMatch(tok, ""try {""))
            tok = tok->linkAt(1);  // skip till start of catch clauses
        if (tok->str() == ""throw"")
            return tok;
        if (tok->function()) {
            const Function * called = tok->function();
            // check if called function has an exception specification
            if (called->isThrow() && called->throwArg)
                return tok;
            if (called->isNoExcept() && called->noexceptArg &&
                called->noexceptArg->str() != ...",1,1,lib/checkexceptionsafety.cpp,"functionThrowsRecursive:Token*(Function*,std.set<constFunction*>&)",<empty>,,false,244,274,functionThrowsRecursive,,,1,"Token*(Function*,std.set<constFunction*>&)"
111669151529,METHOD,lib/checkexceptionsafety.cpp:<global>,TYPE_DECL,"static const Token * functionThrows(const Function * function)
{
    std::set<const Function *> recursive;

    return functionThrowsRecursive(function, recursive);
}",1,1,lib/checkexceptionsafety.cpp,functionThrows:Token*(Function*),<empty>,,false,276,281,functionThrows,,,1,Token*(Function*)
111669151530,METHOD,lib/checkexceptionsafety.cpp:<global>,TYPE_DECL,"void CheckExceptionSafety::nothrowThrows()
{
    logChecker(""CheckExceptionSafety::nothrowThrows"");

    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope * scope : symbolDatabase->functionScopes) {
        const Function* function = scope->function;
        if (!function)
            continue;

        // check noexcept and noexcept(true) functions
        if (function->isNoExcept()) {
            const Token *throws = functionThrows(function);
            if (throws)
                noexceptThrowError(throws);
        }

        // check throw() functions
        else if (function->isThrow() && !function->throwArg) {
            const Token *throws = functionThrows(function);
            if (throws)
                noexceptThrowError(throws);
        }

        // check __attribute__((nothrow)) or __declspec(nothrow) functions
        else if (function->isAttributeNothrow()) {
            const Token *throws = functionThrows(functi...",1,1,lib/checkexceptionsafety.cpp,CheckExceptionSafety.nothrowThrows:void(),<empty>,,false,288,320,nothrowThrows,,,1,void()
111669151531,METHOD,lib/checkexceptionsafety.cpp:<global>,TYPE_DECL,"void CheckExceptionSafety::noexceptThrowError(const Token * const tok)
{
    reportError(tok, Severity::error, ""throwInNoexceptFunction"", ""Exception thrown in function declared not to throw exceptions."", CWE398, Certainty::normal);
}",1,1,lib/checkexceptionsafety.cpp,CheckExceptionSafety.noexceptThrowError:void(Token*),<empty>,,false,322,325,noexceptThrowError,,,1,void(Token*)
111669151532,METHOD,lib/checkexceptionsafety.cpp:<global>,TYPE_DECL,"void CheckExceptionSafety::unhandledExceptionSpecification()
{
    if ((!mSettings->severity.isEnabled(Severity::style) || !mSettings->certainty.isEnabled(Certainty::inconclusive)) &&
        !mSettings->isPremiumEnabled(""unhandledExceptionSpecification""))
        return;

    logChecker(""CheckExceptionSafety::unhandledExceptionSpecification""); // style,inconclusive

    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope * scope : symbolDatabase->functionScopes) {
        // only check functions without exception specification
        if (scope->function && !scope->function->isThrow() && !mSettings->library.isentrypoint(scope->className)) {
            for (const Token *tok = scope->function->functionScope->bodyStart->next();
                 tok != scope->function->functionScope->bodyEnd; tok = tok->next()) {
                if (tok->str() == ""try"")
                    break;
                if (tok->function()) {
                   ...",1,1,lib/checkexceptionsafety.cpp,CheckExceptionSafety.unhandledExceptionSpecification:void(),<empty>,,false,330,358,unhandledExceptionSpecification,,,1,void()
111669151533,METHOD,lib/checkexceptionsafety.cpp:<global>,TYPE_DECL,"void CheckExceptionSafety::unhandledExceptionSpecificationError(const Token * const tok1, const Token * const tok2, const std::string & funcname)
{
    const std::string str1(tok1 ? tok1->str() : ""foo"");
    const std::list<const Token*> locationList = { tok1, tok2 };
    reportError(locationList, Severity::style, ""unhandledExceptionSpecification"",
                ""Unhandled exception specification when calling function "" + str1 + ""().\\n""
                ""Unhandled exception specification when calling function "" + str1 + ""(). ""
                ""Either use a try/catch around the function call, or add a exception specification for "" + funcname + ""() also."", CWE703, Certainty::inconclusive);
}",1,1,lib/checkexceptionsafety.cpp,"CheckExceptionSafety.unhandledExceptionSpecificationError:void(Token*,Token*,std.string&)",<empty>,,false,360,368,unhandledExceptionSpecificationError,,,1,"void(Token*,Token*,std.string&)"
111669151534,METHOD,lib/checkexceptionsafety.cpp:<global>,TYPE_DECL,"void CheckExceptionSafety::rethrowNoCurrentException()
{
    logChecker(""CheckExceptionSafety::rethrowNoCurrentException"");
    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        const Function* function = scope->function;
        if (!function)
            continue;

        // Rethrow can be used in 'exception dispatcher' idiom which is FP in such case
        // https://isocpp.org/wiki/faq/exceptions#throw-without-an-object
        // We check the beginning of the function with idiom pattern
        if (Token::simpleMatch(function->functionScope->bodyStart->next(), ""try { throw ; } catch (""))
            continue;

        for (const Token *tok = function->functionScope->bodyStart->next();
             tok != function->functionScope->bodyEnd; tok = tok->next()) {
            if (Token::simpleMatch(tok, ""catch ("")) {
                tok = tok->linkAt(1);       // skip catch argument...",1,1,lib/checkexceptionsafety.cpp,CheckExceptionSafety.rethrowNoCurrentException:void(),<empty>,,false,373,402,rethrowNoCurrentException,,,1,void()
111669151535,METHOD,lib/checkexceptionsafety.cpp:<global>,TYPE_DECL,"void CheckExceptionSafety::rethrowNoCurrentExceptionError(const Token *tok)
{
    reportError(tok, Severity::error, ""rethrowNoCurrentException"",
                ""Rethrowing current exception with 'throw;', it seems there is no current exception to rethrow.""
                "" If there is no current exception this calls std::terminate().""
                "" More: https://isocpp.org/wiki/faq/exceptions#throw-without-an-object"",
                CWE480, Certainty::normal);
}",1,1,lib/checkexceptionsafety.cpp,CheckExceptionSafety.rethrowNoCurrentExceptionError:void(Token*),<empty>,,false,404,411,rethrowNoCurrentExceptionError,,,1,void(Token*)
111669151536,METHOD,lib/checkexceptionsafety.cpp:<global>,TYPE_DECL,"void CheckExceptionSafety::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    if (tokenizer.isC())
        return;

    CheckExceptionSafety checkExceptionSafety(&tokenizer, &tokenizer.getSettings(), errorLogger);
    checkExceptionSafety.destructors();
    checkExceptionSafety.deallocThrow();
    checkExceptionSafety.checkRethrowCopy();
    checkExceptionSafety.checkCatchExceptionByValue();
    checkExceptionSafety.nothrowThrows();
    checkExceptionSafety.unhandledExceptionSpecification();
    checkExceptionSafety.rethrowNoCurrentException();
}",1,1,lib/checkexceptionsafety.cpp,"CheckExceptionSafety.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,413,426,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669151537,METHOD,lib/checkexceptionsafety.cpp:<global>,TYPE_DECL,"void CheckExceptionSafety::getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const
{
    CheckExceptionSafety c(nullptr, settings, errorLogger);
    c.destructorsError(nullptr, ""Class"");
    c.deallocThrowError(nullptr, ""p"");
    c.rethrowCopyError(nullptr, ""varname"");
    c.catchExceptionByValueError(nullptr);
    c.noexceptThrowError(nullptr);
    c.unhandledExceptionSpecificationError(nullptr, nullptr, ""funcname"");
    c.rethrowNoCurrentExceptionError(nullptr);
}",1,1,lib/checkexceptionsafety.cpp,"CheckExceptionSafety.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,428,438,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669151538,METHOD,lib/checkexceptionsafety.h:<global>,TYPE_DECL,<global>,1,1,lib/checkexceptionsafety.h,lib/checkexceptionsafety.h:<global>,<empty>,,false,1,112,<global>,,,1,
111669151539,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::checkProhibitedFunctions()
{
    const bool checkAlloca = mSettings->severity.isEnabled(Severity::warning) && ((mTokenizer->isC() && mSettings->standards.c >= Standards::C99) || mSettings->standards.cpp >= Standards::CPP11);

    logChecker(""CheckFunctions::checkProhibitedFunctions"");

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope *scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
            if (!Token::Match(tok, ""%name% ("") && tok->varId() == 0)
                continue;
            // alloca() is special as it depends on the code being C or C++, so it is not in Library
            if (checkAlloca && Token::simpleMatch(tok, ""alloca ("") && (!tok->function() || tok->function()->nestedIn->type == ScopeType::eGlobal)) {
                if (tok->isC()) {
                    if (mSettings->standards.c > Standards::C89)
           ...",1,1,lib/checkfunctions.cpp,CheckFunctions.checkProhibitedFunctions:void(),<empty>,,false,61,103,checkProhibitedFunctions,,,1,void()
111669151540,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,<global>,1,1,lib/checkfunctions.cpp,lib/checkfunctions.cpp:<global>,<empty>,,false,1,876,<global>,,,1,
111669151541,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::invalidFunctionUsage()
{
    logChecker(""CheckFunctions::invalidFunctionUsage"");
    const SymbolDatabase* symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope *scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            tok = skipUnreachableBranch(tok);
            if (!Token::Match(tok, ""%name% ( !!)""))
                continue;
            const Token * const functionToken = tok;
            const std::vector<const Token *> arguments = getArguments(tok);
            for (int argnr = 1; argnr <= arguments.size(); ++argnr) {
                const Token * const argtok = arguments[argnr-1];

                // check <valid>...</valid>
                const ValueFlow::Value *invalidValue = argtok->getInvalidValue(functionToken,argnr,*mSettings);
                if (invalidValue) {
                    invalidFunctionArgError(argtok, functionToken->next(...",1,1,lib/checkfunctions.cpp,CheckFunctions.invalidFunctionUsage:void(),<empty>,,false,108,198,invalidFunctionUsage,,,1,void()
111669151542,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::invalidFunctionArgError(const Token *tok, const std::string &functionName, int argnr, const ValueFlow::Value *invalidValue, const std::string &validstr)
{
    std::ostringstream errmsg;
    errmsg << ""$symbol:"" << functionName << '\\n';
    if (invalidValue && invalidValue->condition)
        errmsg << ValueFlow::eitherTheConditionIsRedundant(invalidValue->condition)
               << "" or $symbol() argument nr "" << argnr << "" can have invalid value."";
    else
        errmsg << ""Invalid $symbol() argument nr "" << argnr << '.';
    if (invalidValue)
        errmsg << "" The value is "" << std::setprecision(10) << (invalidValue->isIntValue() ? invalidValue->intvalue : invalidValue->floatValue) << "" but the valid values are '"" << validstr << ""'."";
    else
        errmsg << "" The value is 0 or 1 (boolean) but the valid values are '"" << validstr << ""'."";
    if (invalidValue)
        reportError(getErrorPath(tok, invalidValue, ""Invalid argument""),
                    ...",1,1,lib/checkfunctions.cpp,"CheckFunctions.invalidFunctionArgError:void(Token*,std.string&,int,ValueFlow.Value*,std.string&)",<empty>,,false,200,227,invalidFunctionArgError,,,1,"void(Token*,std.string&,int,ValueFlow.Value*,std.string&)"
111669151543,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::invalidFunctionArgBoolError(const Token *tok, const std::string &functionName, int argnr)
{
    std::ostringstream errmsg;
    errmsg << ""$symbol:"" << functionName << '\\n';
    errmsg << ""Invalid $symbol() argument nr "" << argnr << "". A non-boolean value is required."";
    reportError(tok, Severity::error, ""invalidFunctionArgBool"", errmsg.str(), CWE628, Certainty::normal);
}",1,1,lib/checkfunctions.cpp,"CheckFunctions.invalidFunctionArgBoolError:void(Token*,std.string&,int)",<empty>,,false,229,235,invalidFunctionArgBoolError,,,1,"void(Token*,std.string&,int)"
111669151544,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::invalidFunctionArgStrError(const Token *tok, const std::string &functionName, nonneg int argnr)
{
    std::ostringstream errmsg;
    errmsg << ""$symbol:"" << functionName << '\\n';
    errmsg << ""Invalid $symbol() argument nr "" << argnr << "". A nul-terminated string is required."";
    reportError(tok, Severity::error, ""invalidFunctionArgStr"", errmsg.str(), CWE628, Certainty::normal);
}",1,99,lib/checkfunctions.cpp,"CheckFunctions.invalidFunctionArgStrError:void(Token*,std.string&,int)",<empty>,,false,237,243,invalidFunctionArgStrError,,,1,"void(Token*,std.string&,int)"
111669151545,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::checkIgnoredReturnValue()
{
    if (!mSettings->severity.isEnabled(Severity::warning) &&
        !mSettings->severity.isEnabled(Severity::style) &&
        !mSettings->isPremiumEnabled(""ignoredReturnValue""))
        return;

    logChecker(""CheckFunctions::checkIgnoredReturnValue""); // style,warning

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope *scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            // skip c++11 initialization, ({...})
            if (Token::Match(tok, ""%var%|(|,|return {""))
                tok = tok->linkAt(1);
            else if (Token::Match(tok, ""[(<]"") && tok->link())
                tok = tok->link();

            if (tok->varId() || tok->isKeyword() || tok->isStandardType() || !Token::Match(tok, ""%name% (""))
                continue;

            const Token *parent = tok->next()->astPa...",1,1,lib/checkfunctions.cpp,CheckFunctions.checkIgnoredReturnValue:void(),<empty>,,false,248,297,checkIgnoredReturnValue,,,1,void()
111669151546,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::ignoredReturnValueError(const Token* tok, const std::string& function)
{
    reportError(tok, Severity::warning, ""ignoredReturnValue"",
                ""$symbol:"" + function + ""\\nReturn value of function $symbol() is not used."", CWE252, Certainty::normal);
}",1,1,lib/checkfunctions.cpp,"CheckFunctions.ignoredReturnValueError:void(Token*,std.string&)",<empty>,,false,299,303,ignoredReturnValueError,,,1,"void(Token*,std.string&)"
111669151547,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::ignoredReturnErrorCode(const Token* tok, const std::string& function)
{
    reportError(tok, Severity::style, ""ignoredReturnErrorCode"",
                ""$symbol:"" + function + ""\\nError code from the return value of function $symbol() is not used."", CWE252, Certainty::normal);
}",1,1,lib/checkfunctions.cpp,"CheckFunctions.ignoredReturnErrorCode:void(Token*,std.string&)",<empty>,,false,305,309,ignoredReturnErrorCode,,,1,"void(Token*,std.string&)"
111669151548,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::checkMissingReturn()
{
    logChecker(""CheckFunctions::checkMissingReturn"");
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope *scope : symbolDatabase->functionScopes) {
        const Function *function = scope->function;
        if (!function || !function->hasBody())
            continue;
        if (function->name() == ""main"" && !(mTokenizer->isC() && mSettings->standards.c < Standards::C99))
            continue;
        if (function->type != FunctionType::eFunction && function->type != FunctionType::eOperatorEqual)
            continue;
        if (Token::Match(function->retDef, ""%name% ("") && function->retDef->isUpperCaseName())
            continue;
        if (Function::returnsVoid(function, true))
            continue;
        const Token *errorToken = checkMissingReturnScope(scope->bodyEnd, mSettings->library);
        if (errorToken)
            missingReturnError(errorToken);
    }
}",1,1,lib/checkfunctions.cpp,CheckFunctions.checkMissingReturn:void(),<empty>,,false,316,336,checkMissingReturn,,,1,void()
111669151549,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"static bool isForwardJump(const Token *gotoToken)
{
    if (!Token::Match(gotoToken, ""goto %name% ;""))
        return false;
    for (const Token *prev = gotoToken; gotoToken; gotoToken = gotoToken->previous()) {
        if (Token::Match(prev, ""%name% :"") && prev->str() == gotoToken->strAt(1))
            return true;
        if (prev->str() == ""{"" && prev->scope()->type == ScopeType::eFunction)
            return false;
    }
    return false;
}",1,1,lib/checkfunctions.cpp,isForwardJump:bool(Token*),<empty>,,false,338,349,isForwardJump,,,1,bool(Token*)
111669151550,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"static const Token *checkMissingReturnScope(const Token *tok, const Library &library)
{
    const Token *lastStatement = nullptr;
    while ((tok = tok->previous()) != nullptr) {
        if (tok->str() == "")"")
            tok = tok->link();
        if (tok->str() == ""{"")
            return lastStatement ? lastStatement : tok->next();
        if (tok->str() == ""}"") {
            for (const Token *prev = tok->link()->previous(); prev && prev->scope() == tok->scope() && !Token::Match(prev, ""[;{}]""); prev = prev->previous()) {
                if (prev->isKeyword() && Token::Match(prev, ""return|throw""))
                    return nullptr;
                if (prev->str() == ""goto"" && !isForwardJump(prev))
                    return nullptr;
            }
            if (tok->scope()->type == ScopeType::eSwitch) {
                bool reachable = false;
                for (const Token *switchToken = tok->link()->next(); switchToken != tok; switchToken = switchToken->next()) {
            ...",1,1,lib/checkfunctions.cpp,"checkMissingReturnScope:Token*(Token*,Library&)",<empty>,,false,351,419,checkMissingReturnScope,,,1,"Token*(Token*,Library&)"
111669151551,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::missingReturnError(const Token* tok)
{
    reportError(tok, Severity::error, ""missingReturn"",
                ""Found an exit path from function with non-void return type that has missing return statement"", CWE758, Certainty::normal);
}",1,1,lib/checkfunctions.cpp,CheckFunctions.missingReturnError:void(Token*),<empty>,,false,421,425,missingReturnError,,,1,void(Token*)
111669151552,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::checkMathFunctions()
{
    const bool styleC99 = mSettings->severity.isEnabled(Severity::style) && ((mTokenizer->isC() && mSettings->standards.c != Standards::C89) || (mTokenizer->isCPP() && mSettings->standards.cpp != Standards::CPP03));
    const bool printWarnings = mSettings->severity.isEnabled(Severity::warning);

    if (!styleC99 && !printWarnings && !mSettings->isPremiumEnabled(""wrongmathcall""))
        return;

    logChecker(""CheckFunctions::checkMathFunctions""); // style,warning,c99,c++11

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope *scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (tok->varId())
                continue;
            if (printWarnings && Token::Match(tok, ""%name% ( !!)"")) {
                if (tok->strAt(-1) != "".""
                    && Token::Match(tok, ""log|logf|logl|log1...",1,1,lib/checkfunctions.cpp,CheckFunctions.checkMathFunctions:void(),<empty>,,false,429,488,checkMathFunctions,,,1,void()
111669151553,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::mathfunctionCallWarning(const Token *tok, const nonneg int numParam)
{
    if (tok) {
        if (numParam == 1)
            reportError(tok, Severity::warning, ""wrongmathcall"", ""$symbol:"" + tok->str() + ""\\nPassing value "" + tok->strAt(2) + "" to $symbol() leads to implementation-defined result."", CWE758, Certainty::normal);
        else if (numParam == 2)
            reportError(tok, Severity::warning, ""wrongmathcall"", ""$symbol:"" + tok->str() + ""\\nPassing values "" + tok->strAt(2) + "" and "" + tok->strAt(4) + "" to $symbol() leads to implementation-defined result."", CWE758, Certainty::normal);
    } else
        reportError(tok, Severity::warning, ""wrongmathcall"", ""Passing value '#' to #() leads to implementation-defined result."", CWE758, Certainty::normal);
}",1,69,lib/checkfunctions.cpp,"CheckFunctions.mathfunctionCallWarning:void(Token*,int)",<empty>,,false,490,499,mathfunctionCallWarning,,,1,"void(Token*,int)"
111669151554,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::mathfunctionCallWarning(const Token *tok, const std::string& oldexp, const std::string& newexp)
{
    reportError(tok, Severity::style, ""unpreciseMathCall"", ""Expression '"" + oldexp + ""' can be replaced by '"" + newexp + ""' to avoid loss of precision."", CWE758, Certainty::normal);
}",1,1,lib/checkfunctions.cpp,"CheckFunctions.mathfunctionCallWarning:void(Token*,std.string&,std.string&)",<empty>,,false,501,504,mathfunctionCallWarning,,,1,"void(Token*,std.string&,std.string&)"
111669151555,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::memsetZeroBytes()
{
// FIXME:
//  Replace this with library configuration.
//  For instance:
//     <arg nr=""3"">
//       <warn knownIntValue=""0"" severity=""warning"" msg=""...""/>
//     </arg>

    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckFunctions::memsetZeroBytes""); // warning

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope *scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (Token::Match(tok, ""memset|wmemset ("") && (numberOfArguments(tok)==3)) {
                const std::vector<const Token *> &arguments = getArguments(tok);
                if (WRONG_DATA(arguments.size() != 3U, tok))
                    continue;
                const Token* lastParamTok = arguments[2];
                if (MathLib::isNullValue(lastParamTok->str()))
                    me...",1,20,lib/checkfunctions.cpp,CheckFunctions.memsetZeroBytes:void(),<empty>,,false,509,536,memsetZeroBytes,,,1,void()
111669151556,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::memsetZeroBytesError(const Token *tok)
{
    const std::string summary(""memset() called to fill 0 bytes."");
    const std::string verbose(summary + "" The second and third arguments might be inverted.""
                              "" The function memset ( void * ptr, int value, size_t num ) sets the""
                              "" first num bytes of the block of memory pointed by ptr to the specified value."");
    reportError(tok, Severity::warning, ""memsetZeroBytes"", summary + ""\\n"" + verbose, CWE687, Certainty::normal);
}",1,1,lib/checkfunctions.cpp,CheckFunctions.memsetZeroBytesError:void(Token*),<empty>,,false,538,545,memsetZeroBytesError,,,1,void(Token*)
111669151557,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::memsetInvalid2ndParam()
{
// FIXME:
//  Replace this with library configuration.
//  For instance:
//     <arg nr=""2"">
//       <not-float/>
//       <warn possibleIntValue="":-129,256:"" severity=""warning"" msg=""...""/>
//     </arg>

    const bool printPortability = mSettings->severity.isEnabled(Severity::portability);
    const bool printWarning = mSettings->severity.isEnabled(Severity::warning);
    if (!printWarning && !printPortability)
        return;

    logChecker(""CheckFunctions::memsetInvalid2ndParam""); // warning,portability

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope *scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok && (tok != scope->bodyEnd); tok = tok->next()) {
            if (!Token::simpleMatch(tok, ""memset (""))
                continue;

            const std::vector<const Token *> args = getArguments(tok);
            if (args.size() != ...",1,1,lib/checkfunctions.cpp,CheckFunctions.memsetInvalid2ndParam:void(),<empty>,,false,547,593,memsetInvalid2ndParam,,,1,void()
111669151558,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::memsetFloatError(const Token *tok, const std::string &var_value)
{
    const std::string message(""The 2nd memset() argument '"" + var_value +
                              ""' is a float, its representation is implementation defined."");
    const std::string verbose(message + "" memset() is used to set each byte of a block of memory to a specific value and""
                              "" the actual representation of a floating-point value is implementation defined."");
    reportError(tok, Severity::portability, ""memsetFloat"", message + ""\\n"" + verbose, CWE688, Certainty::normal);
}",1,1,lib/checkfunctions.cpp,"CheckFunctions.memsetFloatError:void(Token*,std.string&)",<empty>,,false,595,602,memsetFloatError,,,1,"void(Token*,std.string&)"
111669151559,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::memsetValueOutOfRangeError(const Token *tok, const std::string &value)
{
    const std::string message(""The 2nd memset() argument '"" + value + ""' doesn't fit into an 'unsigned char'."");
    const std::string verbose(message + "" The 2nd parameter is passed as an 'int', but the function fills the block of memory using the 'unsigned char' conversion of this value."");
    reportError(tok, Severity::warning, ""memsetValueOutOfRange"", message + ""\\n"" + verbose, CWE686, Certainty::normal);
}",1,1,lib/checkfunctions.cpp,"CheckFunctions.memsetValueOutOfRangeError:void(Token*,std.string&)",<empty>,,false,604,609,memsetValueOutOfRangeError,,,1,"void(Token*,std.string&)"
111669151560,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::checkLibraryMatchFunctions()
{
    if (!mSettings->checkLibrary)
        return;

    bool insideNew = false;
    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (!tok->scope() || !tok->scope()->isExecutable())
            continue;

        if (tok->str() == ""new"")
            insideNew = true;
        else if (tok->str() == "";"")
            insideNew = false;
        else if (insideNew)
            continue;

        if (tok->isKeyword() || !Token::Match(tok, ""%name% (""))
            continue;

        if (tok->varId() != 0 || tok->type() || tok->isStandardType())
            continue;

        if (tok->linkAt(1)->strAt(1) == ""("")
            continue;

        if (tok->function())
            continue;

        if (Token::simpleMatch(tok->astTop(), ""throw""))
            continue;

        if (Token::simpleMatch(tok->astParent(), ""."")) {
            const Token* contTok = tok->astParent()->astOperand1();
            if (astCo...",1,1,lib/checkfunctions.cpp,CheckFunctions.checkLibraryMatchFunctions:void(),<empty>,,false,615,682,checkLibraryMatchFunctions,,,1,void()
111669151561,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::returnLocalStdMove()
{
    if (!mTokenizer->isCPP() || mSettings->standards.cpp < Standards::CPP11)
        return;

    if (!mSettings->severity.isEnabled(Severity::performance))
        return;

    logChecker(""CheckFunctions::returnLocalStdMove""); // performance,c++11

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope *scope : symbolDatabase->functionScopes) {
        // Expect return by-value
        if (Function::returnsReference(scope->function, /*unknown*/ true, /*includeRValueRef*/ true))
            continue;
        const auto rets = Function::findReturns(scope->function);
        for (const Token* ret : rets) {
            if (!Token::simpleMatch(ret->tokAt(-3), ""std :: move (""))
                continue;
            const Token* retval = ret->astOperand2();
            // NRVO
            if (retval->variable() && retval->variable()->isLocal() && !retval->variable()->isVolatile())
                copyEli...",1,1,lib/checkfunctions.cpp,CheckFunctions.returnLocalStdMove:void(),<empty>,,false,687,715,returnLocalStdMove,,,1,void()
111669151562,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::copyElisionError(const Token *tok)
{
    reportError(tok,
                Severity::performance,
                ""returnStdMoveLocal"",
                ""Using std::move for returning object by-value from function will affect copy elision optimization.""
                "" More: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-return-move-local"");
}",1,1,lib/checkfunctions.cpp,CheckFunctions.copyElisionError:void(Token*),<empty>,,false,717,724,copyElisionError,,,1,void(Token*)
111669151563,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::useStandardLibrary()
{
    if (!mSettings->severity.isEnabled(Severity::style))
        return;

    logChecker(""CheckFunctions::useStandardLibrary""); // style

    for (const Scope& scope: mTokenizer->getSymbolDatabase()->scopeList) {
        if (scope.type != ScopeType::eFor)
            continue;

        const Token *forToken = scope.classDef;
        // for ( initToken ; condToken ; stepToken )
        const Token* initToken = getInitTok(forToken);
        if (!initToken)
            continue;
        const Token* condToken = getCondTok(forToken);
        if (!condToken)
            continue;
        const Token* stepToken = getStepTok(forToken);
        if (!stepToken)
            continue;

        // 1. we expect that idx variable will be initialized with 0
        const Token* idxToken = initToken->astOperand1();
        const Token* initVal = initToken->astOperand2();
        if (!idxToken || !initVal || !initVal->hasKnownIntValue() || initVal->getKnow...",1,1,lib/checkfunctions.cpp,CheckFunctions.useStandardLibrary:void(),<empty>,,false,726,828,useStandardLibrary,,,1,void()
111669151564,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::useStandardLibraryError(const Token *tok, const std::string& expected)
{
    reportError(tok, Severity::style,
                ""useStandardLibrary"",
                ""Consider using "" + expected + "" instead of loop."");
}",1,1,lib/checkfunctions.cpp,"CheckFunctions.useStandardLibraryError:void(Token*,std.string&)",<empty>,,false,830,835,useStandardLibraryError,,,1,"void(Token*,std.string&)"
111669151565,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    CheckFunctions checkFunctions(&tokenizer, &tokenizer.getSettings(), errorLogger);

    checkFunctions.checkIgnoredReturnValue();
    checkFunctions.checkMissingReturn();  // Missing ""return"" in exit path

    // --check-library : functions with nonmatching configuration
    checkFunctions.checkLibraryMatchFunctions();

    checkFunctions.checkProhibitedFunctions();
    checkFunctions.invalidFunctionUsage();
    checkFunctions.checkMathFunctions();
    checkFunctions.memsetZeroBytes();
    checkFunctions.memsetInvalid2ndParam();
    checkFunctions.returnLocalStdMove();
    checkFunctions.useStandardLibrary();
}",1,1,lib/checkfunctions.cpp,"CheckFunctions.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,837,854,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669151566,METHOD,lib/checkfunctions.cpp:<global>,TYPE_DECL,"void CheckFunctions::getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const
{
    CheckFunctions c(nullptr, settings, errorLogger);

    for (auto i = settings->library.functionwarn().cbegin(); i != settings->library.functionwarn().cend(); ++i) {
        c.reportError(nullptr, Severity::style, i->first+""Called"", i->second.message);
    }

    c.invalidFunctionArgError(nullptr, ""func_name"", 1, nullptr,""1:4"");
    c.invalidFunctionArgBoolError(nullptr, ""func_name"", 1);
    c.invalidFunctionArgStrError(nullptr, ""func_name"", 1);
    c.ignoredReturnValueError(nullptr, ""malloc"");
    c.mathfunctionCallWarning(nullptr);
    c.mathfunctionCallWarning(nullptr, ""1 - erf(x)"", ""erfc(x)"");
    c.memsetZeroBytesError(nullptr);
    c.memsetFloatError(nullptr,  ""varname"");
    c.memsetValueOutOfRangeError(nullptr,  ""varname"");
    c.missingReturnError(nullptr);
    c.copyElisionError(nullptr);
    c.useStandardLibraryError(nullptr, ""memcpy"");
}",1,1,lib/checkfunctions.cpp,"CheckFunctions.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,856,876,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669151567,METHOD,lib/checkfunctions.h:<global>,TYPE_DECL,<global>,1,1,lib/checkfunctions.h,lib/checkfunctions.h:<global>,<empty>,,false,1,131,<global>,,,1,
111669151568,METHOD,lib/checkinternal.cpp:<global>,TYPE_DECL,"void CheckInternal::checkTokenMatchPatterns()
{
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope *scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!Token::simpleMatch(tok, ""Token :: Match ("") && !Token::simpleMatch(tok, ""Token :: findmatch (""))
                continue;

            const std::string& funcname = tok->strAt(2);

            // Get pattern string
            const Token *patternTok = tok->tokAt(4)->nextArgument();
            if (!patternTok || patternTok->tokType() != Token::eString)
                continue;

            const std::string pattern = patternTok->strValue();
            if (pattern.empty()) {
                simplePatternError(tok, pattern, funcname);
                continue;
            }

            if (pattern.find(""||"") != std::string::npos || pattern.find("" | "") != std::string::npos || pat...",1,1,lib/checkinternal.cpp,CheckInternal.checkTokenMatchPatterns:void(),<empty>,,false,40,89,checkTokenMatchPatterns,,,1,void()
111669151569,METHOD,lib/checkinternal.cpp:<global>,TYPE_DECL,<global>,1,31,lib/checkinternal.cpp,lib/checkinternal.cpp:<global>,<empty>,,false,1,423,<global>,,,1,
111669151570,METHOD,lib/checkinternal.cpp:<global>,TYPE_DECL,"void CheckInternal::checkRedundantTokCheck()
{
    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""&& Token :: simpleMatch|Match|findsimplematch|findmatch ("")) {
            // in code like
            // if (tok->previous() && Token::match(tok->previous(), ""bla"")) {}
            // the first tok->previous() check is redundant
            const Token *astOp1 = tok->astOperand1();
            const Token *astOp2 = getArguments(tok->tokAt(3))[0];
            if (Token::simpleMatch(astOp1, ""&&"")) {
                astOp1 = astOp1->astOperand2();
            }
            if (astOp1->expressionString() == astOp2->expressionString()) {
                checkRedundantTokCheckError(astOp2);
            }
            // if (!tok || !Token::match(tok, ""foo""))
        } else if (Token::Match(tok, ""%oror% ! Token :: simpleMatch|Match|findsimplematch|findmatch ("")) {
            const Token *negTok = tok->next()->astParent()->astOperand1();
...",1,1,lib/checkinternal.cpp,CheckInternal.checkRedundantTokCheck:void(),<empty>,,false,91,123,checkRedundantTokCheck,,,1,void()
111669151571,METHOD,lib/checkinternal.cpp:<global>,TYPE_DECL,"void CheckInternal::checkRedundantTokCheckError(const Token* tok)
{
    reportError(tok, Severity::style, ""redundantTokCheck"",
                ""Unnecessary check of \\"""" + (tok? tok->expressionString(): """") + ""\\"", match-function already checks if it is null."");
}",1,1,lib/checkinternal.cpp,CheckInternal.checkRedundantTokCheckError:void(Token*),<empty>,,false,126,130,checkRedundantTokCheckError,,,1,void(Token*)
111669151572,METHOD,lib/checkinternal.cpp:<global>,TYPE_DECL,"void CheckInternal::checkTokenSimpleMatchPatterns()
{
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope* scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!Token::simpleMatch(tok, ""Token :: simpleMatch ("") && !Token::simpleMatch(tok, ""Token :: findsimplematch (""))
                continue;

            const std::string& funcname = tok->strAt(2);

            // Get pattern string
            const Token *patternTok = tok->tokAt(4)->nextArgument();
            if (!patternTok || patternTok->tokType() != Token::eString)
                continue;

            const std::string pattern = patternTok->strValue();
            if (pattern.empty()) {
                complexPatternError(tok, pattern, funcname);
                continue;
            }

            // Check for [xyz] usage - but exclude standalone square brackets
         ...",1,1,lib/checkinternal.cpp,CheckInternal.checkTokenSimpleMatchPatterns:void(),<empty>,,false,132,194,checkTokenSimpleMatchPatterns,,,1,void()
111669151573,METHOD,lib/checkinternal.cpp:<global>,TYPE_DECL,"void CheckInternal::checkMissingPercentCharacter()
{
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope* scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!Token::simpleMatch(tok, ""Token :: Match ("") && !Token::simpleMatch(tok, ""Token :: findmatch (""))
                continue;

            const std::string& funcname = tok->strAt(2);

            // Get pattern string
            const Token *patternTok = tok->tokAt(4)->nextArgument();
            if (!patternTok || patternTok->tokType() != Token::eString)
                continue;

            const std::string pattern = patternTok->strValue();

            for (auto knownPattern = knownPatterns.cbegin(); knownPattern != knownPatterns.cend(); ++knownPattern) {
                const std::string brokenPattern = knownPattern->substr(0, knownPattern->size() - 1);

                s...",1,1,lib/checkinternal.cpp,CheckInternal.checkMissingPercentCharacter:void(),<empty>,,false,216,255,checkMissingPercentCharacter,,,1,void()
111669151574,METHOD,lib/checkinternal.cpp:<global>,TYPE_DECL,"void CheckInternal::checkUnknownPattern()
{
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope* scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!Token::simpleMatch(tok, ""Token :: Match ("") && !Token::simpleMatch(tok, ""Token :: findmatch (""))
                continue;

            // Get pattern string
            const Token *patternTok = tok->tokAt(4)->nextArgument();
            if (!patternTok || patternTok->tokType() != Token::eString)
                continue;

            const std::string pattern = patternTok->strValue();
            bool inBrackets = false;

            for (std::string::size_type j = 0; j < pattern.length() - 1; j++) {
                if (pattern[j] == '[' && (j == 0 || pattern[j - 1] == ' '))
                    inBrackets = true;
                else if (pattern[j] == ']')
                    inBrack...",1,1,lib/checkinternal.cpp,CheckInternal.checkUnknownPattern:void(),<empty>,,false,257,289,checkUnknownPattern,,,1,void()
111669151575,METHOD,lib/checkinternal.cpp:<global>,TYPE_DECL,"void CheckInternal::checkRedundantNextPrevious()
{
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope* scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (tok->str() != ""."")
                continue;
            tok = tok->next();

            if (Token::Match(tok, ""previous ( ) . previous|next|tokAt|str|strAt|link|linkAt ("") || Token::Match(tok, ""next ( ) . previous|next|tokAt|str|strAt|link|linkAt ("") ||
                (Token::simpleMatch(tok, ""tokAt ("") && Token::Match(tok->linkAt(1), "") . previous|next|tokAt|strAt|linkAt|str|link (""))) {
                const std::string& func1 = tok->str();
                const std::string& func2 = tok->linkAt(1)->strAt(2);

                if ((func2 == ""previous"" || func2 == ""next"" || func2 == ""str"" || func2 == ""link"") && tok->linkAt(1)->strAt(4) != "")"")
                    continue;

    ...",1,1,lib/checkinternal.cpp,CheckInternal.checkRedundantNextPrevious:void(),<empty>,,false,291,312,checkRedundantNextPrevious,,,1,void()
111669151576,METHOD,lib/checkinternal.cpp:<global>,TYPE_DECL,"void CheckInternal::checkExtraWhitespace()
{
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope* scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!Token::Match(tok, ""Token :: simpleMatch|findsimplematch|Match|findmatch (""))
                continue;

            const std::string& funcname = tok->strAt(2);

            // Get pattern string
            const Token *patternTok = tok->tokAt(4)->nextArgument();
            if (!patternTok || patternTok->tokType() != Token::eString)
                continue;

            const std::string pattern = patternTok->strValue();
            if (!pattern.empty() && (pattern[0] == ' ' || *pattern.crbegin() == ' '))
                extraWhitespaceError(tok, pattern, funcname);

            // two whitespaces or more
            if (pattern.find(""  "") != std::string::npos)
                extr...",1,1,lib/checkinternal.cpp,CheckInternal.checkExtraWhitespace:void(),<empty>,,false,314,338,checkExtraWhitespace,,,1,void()
111669151577,METHOD,lib/checkinternal.cpp:<global>,TYPE_DECL,"void CheckInternal::multiComparePatternError(const Token* tok, const std::string& pattern, const std::string &funcname)
{
    reportError(tok, Severity::error, ""multiComparePatternError"",
                ""Bad multicompare pattern (a %cmd% must be first unless it is %or%,%op%,%cop%,%name%,%oror%) inside Token::"" + funcname + ""() call: \\"""" + pattern + ""\\""""
                );
}",1,1,lib/checkinternal.cpp,"CheckInternal.multiComparePatternError:void(Token*,std.string&,std.string&)",<empty>,,false,340,345,multiComparePatternError,,,1,"void(Token*,std.string&,std.string&)"
111669151578,METHOD,lib/checkinternal.cpp:<global>,TYPE_DECL,"void CheckInternal::simplePatternError(const Token* tok, const std::string& pattern, const std::string &funcname)
{
    reportError(tok, Severity::warning, ""simplePatternError"",
                ""Found simple pattern inside Token::"" + funcname + ""() call: \\"""" + pattern + ""\\""""
                );
}",1,1,lib/checkinternal.cpp,"CheckInternal.simplePatternError:void(Token*,std.string&,std.string&)",<empty>,,false,347,352,simplePatternError,,,1,"void(Token*,std.string&,std.string&)"
111669151579,METHOD,lib/checkinternal.cpp:<global>,TYPE_DECL,"void CheckInternal::complexPatternError(const Token* tok, const std::string& pattern, const std::string &funcname)
{
    reportError(tok, Severity::error, ""complexPatternError"",
                ""Found complex pattern inside Token::"" + funcname + ""() call: \\"""" + pattern + ""\\""""
                );
}",1,1,lib/checkinternal.cpp,"CheckInternal.complexPatternError:void(Token*,std.string&,std.string&)",<empty>,,false,354,359,complexPatternError,,,1,"void(Token*,std.string&,std.string&)"
111669151580,METHOD,lib/checkinternal.cpp:<global>,TYPE_DECL,"void CheckInternal::missingPercentCharacterError(const Token* tok, const std::string& pattern, const std::string& funcname)
{
    reportError(tok, Severity::error, ""missingPercentCharacter"",
                ""Missing percent end character in Token::"" + funcname + ""() pattern: \\"""" + pattern + ""\\""""
                );
}",1,1,lib/checkinternal.cpp,"CheckInternal.missingPercentCharacterError:void(Token*,std.string&,std.string&)",<empty>,,false,361,366,missingPercentCharacterError,,,1,"void(Token*,std.string&,std.string&)"
111669151581,METHOD,lib/checkinternal.cpp:<global>,TYPE_DECL,"void CheckInternal::unknownPatternError(const Token* tok, const std::string& pattern)
{
    reportError(tok, Severity::error, ""unknownPattern"",
                ""Unknown pattern used: \\"""" + pattern + ""\\"""");
}",1,1,lib/checkinternal.cpp,"CheckInternal.unknownPatternError:void(Token*,std.string&)",<empty>,,false,368,372,unknownPatternError,,,1,"void(Token*,std.string&)"
111669151582,METHOD,lib/checkinternal.cpp:<global>,TYPE_DECL,"void CheckInternal::redundantNextPreviousError(const Token* tok, const std::string& func1, const std::string& func2)
{
    reportError(tok, Severity::style, ""redundantNextPrevious"",
                ""Call to 'Token::"" + func1 + ""()' followed by 'Token::"" + func2 + ""()' can be simplified."");
}",1,1,lib/checkinternal.cpp,"CheckInternal.redundantNextPreviousError:void(Token*,std.string&,std.string&)",<empty>,,false,374,378,redundantNextPreviousError,,,1,"void(Token*,std.string&,std.string&)"
111669151583,METHOD,lib/checkinternal.cpp:<global>,TYPE_DECL,"void CheckInternal::orInComplexPattern(const Token* tok, const std::string& pattern, const std::string &funcname)
{
    reportError(tok, Severity::error, ""orInComplexPattern"",
                ""Token::"" + funcname + ""() pattern \\"""" + pattern + ""\\"" contains \\""||\\"" or \\""|\\"". Replace it by \\""%oror%\\"" or \\""%or%\\""."");
}",1,1,lib/checkinternal.cpp,"CheckInternal.orInComplexPattern:void(Token*,std.string&,std.string&)",<empty>,,false,380,384,orInComplexPattern,,,1,"void(Token*,std.string&,std.string&)"
111669151584,METHOD,lib/checkinternal.cpp:<global>,TYPE_DECL,"void CheckInternal::extraWhitespaceError(const Token* tok, const std::string& pattern, const std::string &funcname)
{
    reportError(tok, Severity::warning, ""extraWhitespaceError"",
                ""Found extra whitespace inside Token::"" + funcname + ""() call: \\"""" + pattern + ""\\""""
                );
}",1,1,lib/checkinternal.cpp,"CheckInternal.extraWhitespaceError:void(Token*,std.string&,std.string&)",<empty>,,false,386,391,extraWhitespaceError,,,1,"void(Token*,std.string&,std.string&)"
111669151585,METHOD,lib/checkinternal.cpp:<global>,TYPE_DECL,"void CheckInternal::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    if (!tokenizer.getSettings().checks.isEnabled(Checks::internalCheck))
        return;

    CheckInternal checkInternal(&tokenizer, &tokenizer.getSettings(), errorLogger);

    checkInternal.checkTokenMatchPatterns();
    checkInternal.checkTokenSimpleMatchPatterns();
    checkInternal.checkMissingPercentCharacter();
    checkInternal.checkUnknownPattern();
    checkInternal.checkRedundantNextPrevious();
    checkInternal.checkExtraWhitespace();
    checkInternal.checkRedundantTokCheck();
}",1,1,lib/checkinternal.cpp,"CheckInternal.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,393,407,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669151586,METHOD,lib/checkinternal.cpp:<global>,TYPE_DECL,"void CheckInternal::getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const
{
    CheckInternal c(nullptr, settings, errorLogger);
    c.multiComparePatternError(nullptr, "";|%type%"", ""Match"");
    c.simplePatternError(nullptr, ""class {"", ""Match"");
    c.complexPatternError(nullptr, ""%type% ( )"", ""Match"");
    c.missingPercentCharacterError(nullptr, ""%num"", ""Match"");
    c.unknownPatternError(nullptr, ""%typ"");
    c.redundantNextPreviousError(nullptr, ""previous"", ""next"");
    c.orInComplexPattern(nullptr, ""||"", ""Match"");
    c.extraWhitespaceError(nullptr, ""%str% "", ""Match"");
    c.checkRedundantTokCheckError(nullptr);
}",1,1,lib/checkinternal.cpp,"CheckInternal.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,409,421,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669151587,METHOD,lib/checkinternal.h:<global>,TYPE_DECL,<global>,1,1,lib/checkinternal.h,lib/checkinternal.h:<global>,<empty>,,false,1,97,<global>,,,1,
111669151588,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::checkCoutCerrMisusage()
{
    if (mTokenizer->isC())
        return;

    logChecker(""CheckIO::checkCoutCerrMisusage""); // c

    const SymbolDatabase * const symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token *tok = scope->bodyStart; tok && tok != scope->bodyEnd; tok = tok->next()) {
            if (Token::Match(tok, ""std :: cout|cerr !!."") && tok->next()->astParent() && tok->next()->astParent()->astOperand1() == tok->next()) {
                const Token* tok2 = tok->next();
                while (tok2->astParent() && tok2->astParent()->str() == ""<<"") {
                    tok2 = tok2->astParent();
                    if (tok2->astOperand2() && Token::Match(tok2->astOperand2()->previous(), ""std :: cout|cerr""))
                        coutCerrMisusageError(tok, tok2->astOperand2()->strAt(1));
                }
            }
        }
    }
}",1,1,lib/checkio.cpp,CheckIO.checkCoutCerrMisusage:void(),<empty>,,false,66,86,checkCoutCerrMisusage,,,1,void()
111669151589,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,<global>,1,78,lib/checkio.cpp,lib/checkio.cpp:<global>,<empty>,,false,1,2063,<global>,,,1,
111669151590,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::coutCerrMisusageError(const Token* tok, const std::string& streamName)
{
    reportError(tok, Severity::error, ""coutCerrMisusage"", ""Invalid usage of output stream: '<< std::"" + streamName + ""'."", CWE398, Certainty::normal);
}",1,1,lib/checkio.cpp,"CheckIO.coutCerrMisusageError:void(Token*,std.string&)",<empty>,,false,88,91,coutCerrMisusageError,,,1,"void(Token*,std.string&)"
111669151591,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"static OpenMode getMode(const std::string& str)
{
    if (str.find('+', 1) != std::string::npos)
        return OpenMode::RW_MODE;
    if (str.find('w') != std::string::npos || str.find('a') != std::string::npos)
        return OpenMode::WRITE_MODE;
    if (str.find('r') != std::string::npos)
        return OpenMode::READ_MODE;
    return OpenMode::UNKNOWN_OM;
}",1,1,lib/checkio.cpp,getMode:OpenMode(std.string&),<empty>,,false,100,109,getMode,,,1,OpenMode(std.string&)
111669151592,METHOD,Filepointer,TYPE_DECL,"explicit Filepointer(OpenMode mode_ = OpenMode::UNKNOWN_OM)
            : mode(mode_) {}",9,28,lib/checkio.cpp,Filepointer.Filepointer:ANY(OpenMode),<empty>,,false,120,121,Filepointer,,,8,Filepointer.Filepointer:ANY(OpenMode)(OpenMode)
111669151593,METHOD,<empty>,<empty>,<empty>,5,,lib/checkio.cpp,Filepointer.<clinit>,<empty>,,false,112,,<clinit>,,,9,
111669151594,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::checkFileUsage()
{
    const bool windows = mSettings->platform.isWindows();
    const bool printPortability = mSettings->severity.isEnabled(Severity::portability);
    const bool printWarnings = mSettings->severity.isEnabled(Severity::warning);

    std::map<int, Filepointer> filepointers;

    logChecker(""CheckIO::checkFileUsage"");

    const SymbolDatabase* symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Variable* var : symbolDatabase->variableList()) {
        if (!var || !var->declarationId() || var->isArray() || !Token::simpleMatch(var->typeStartToken(), ""FILE *""))
            continue;

        if (var->isLocal()) {
            if (var->nameToken()->strAt(1) == ""("") // initialize by calling ""ctor""
                filepointers.emplace(var->declarationId(), Filepointer(OpenMode::UNKNOWN_OM));
            else
                filepointers.emplace(var->declarationId(), Filepointer(OpenMode::CLOSED));
        } else {
            filepointers.emplace...",1,1,lib/checkio.cpp,CheckIO.checkFileUsage:void(),<empty>,,false,127,363,checkFileUsage,,,1,void()
111669151595,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::fflushOnInputStreamError(const Token *tok, const std::string &varname)
{
    reportError(tok, Severity::portability,
                ""fflushOnInputStream"", ""fflush() called on input stream '"" + varname + ""' may result in undefined behaviour on non-linux systems."", CWE398, Certainty::normal);
}",1,1,lib/checkio.cpp,"CheckIO.fflushOnInputStreamError:void(Token*,std.string&)",<empty>,,false,365,369,fflushOnInputStreamError,,,1,"void(Token*,std.string&)"
111669151596,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::ioWithoutPositioningError(const Token *tok)
{
    reportError(tok, Severity::error,
                ""IOWithoutPositioning"", ""Read and write operations without a call to a positioning function (fseek, fsetpos or rewind) or fflush in between result in undefined behaviour."", CWE664, Certainty::normal);
}",1,1,lib/checkio.cpp,CheckIO.ioWithoutPositioningError:void(Token*),<empty>,,false,371,375,ioWithoutPositioningError,,,1,void(Token*)
111669151597,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::readWriteOnlyFileError(const Token *tok)
{
    reportError(tok, Severity::error,
                ""readWriteOnlyFile"", ""Read operation on a file that was opened only for writing."", CWE664, Certainty::normal);
}",1,1,lib/checkio.cpp,CheckIO.readWriteOnlyFileError:void(Token*),<empty>,,false,377,381,readWriteOnlyFileError,,,1,void(Token*)
111669151598,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::writeReadOnlyFileError(const Token *tok)
{
    reportError(tok, Severity::error,
                ""writeReadOnlyFile"", ""Write operation on a file that was opened only for reading."", CWE664, Certainty::normal);
}",1,1,lib/checkio.cpp,CheckIO.writeReadOnlyFileError:void(Token*),<empty>,,false,383,387,writeReadOnlyFileError,,,1,void(Token*)
111669151599,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::useClosedFileError(const Token *tok)
{
    reportError(tok, Severity::error,
                ""useClosedFile"", ""Used file that is not opened."", CWE910, Certainty::normal);
}",1,1,lib/checkio.cpp,CheckIO.useClosedFileError:void(Token*),<empty>,,false,389,393,useClosedFileError,,,1,void(Token*)
111669151600,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::seekOnAppendedFileError(const Token *tok)
{
    reportError(tok, Severity::warning,
                ""seekOnAppendedFile"", ""Repositioning operation performed on a file opened in append mode has no effect."", CWE398, Certainty::normal);
}",1,1,lib/checkio.cpp,CheckIO.seekOnAppendedFileError:void(Token*),<empty>,,false,395,399,seekOnAppendedFileError,,,1,void(Token*)
111669151601,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::incompatibleFileOpenError(const Token *tok, const std::string &filename)
{
    reportError(tok, Severity::warning,
                ""incompatibleFileOpen"", ""The file '"" + filename + ""' is opened for read and write access at the same time on different streams"", CWE664, Certainty::normal);
}",1,1,lib/checkio.cpp,"CheckIO.incompatibleFileOpenError:void(Token*,std.string&)",<empty>,,false,401,405,incompatibleFileOpenError,,,1,"void(Token*,std.string&)"
111669151602,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::invalidScanf()
{
    if (!mSettings->severity.isEnabled(Severity::warning) && !mSettings->isPremiumEnabled(""invalidscanf""))
        return;

    logChecker(""CheckIO::invalidScanf"");

    const SymbolDatabase * const symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token *tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            const Token *formatToken = nullptr;
            if (Token::Match(tok, ""scanf|vscanf ( %str% ,""))
                formatToken = tok->tokAt(2);
            else if (Token::Match(tok, ""sscanf|vsscanf|fscanf|vfscanf ("")) {
                const Token* nextArg = tok->tokAt(2)->nextArgument();
                if (nextArg && nextArg->tokType() == Token::eString)
                    formatToken = nextArg;
                else
                    continue;
            } else
                continue;

            bool format = false;

      ...",1,1,lib/checkio.cpp,CheckIO.invalidScanf:void(),<empty>,,false,411,456,invalidScanf,,,1,void()
111669151603,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::invalidScanfError(const Token *tok)
{
    const std::string fname = (tok ? tok->str() : std::string(""scanf""));
    reportError(tok, Severity::warning,
                ""invalidscanf"", fname + ""() without field width limits can crash with huge input data.\\n"" +
                fname + ""() without field width limits can crash with huge input data. Add a field width ""
                ""specifier to fix this problem.\\n""
                ""\\n""
                ""Sample program that can crash:\\n""
                ""\\n""
                ""#include <stdio.h>\\n""
                ""int main()\\n""
                ""{\\n""
                ""    char c[5];\\n""
                ""    scanf(\\""%s\\"", c);\\n""
                ""    return 0;\\n""
                ""}\\n""
                ""\\n""
                ""Typing in 5 or more characters may make the program crash. The correct usage ""
                ""here is 'scanf(\\""%4s\\"", c);', as the maximum field width does not include the ""
                ""terminating null ...",1,1,lib/checkio.cpp,CheckIO.invalidScanfError:void(Token*),<empty>,,false,458,482,invalidScanfError,,,1,void(Token*)
111669151604,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"static bool findFormat(nonneg int arg, const Token *firstArg,
                       const Token *&formatStringTok, const Token *&formatArgTok)
{
    const Token* argTok = firstArg;

    for (int i = 0; i < arg && argTok; ++i)
        argTok = argTok->nextArgument();

    if (Token::Match(argTok, ""%str% [,)]"")) {
        formatArgTok = argTok->nextArgument();
        formatStringTok = argTok;
        return true;
    }
    if (Token::Match(argTok, ""%var% [,)]"") &&
        argTok->variable() &&
        Token::Match(argTok->variable()->typeStartToken(), ""char|wchar_t"") &&
        (argTok->variable()->isPointer() ||
         (argTok->variable()->dimensions().size() == 1 &&
          argTok->variable()->dimensionKnown(0) &&
          argTok->variable()->dimension(0) != 0))) {
        formatArgTok = argTok->nextArgument();
        if (!argTok->values().empty()) {
            const auto value = std::find_if(
                argTok->values().cbegin(), argTok->values().cend(), std::mem_fn(&...",1,23,lib/checkio.cpp,"findFormat:bool(int,Token*,Token*&,Token*&)",<empty>,,false,490,522,findFormat,,,1,"bool(int,Token*,Token*&,Token*&)"
111669151605,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"static inline bool typesMatch(const std::string& iToTest, const std::string& iTypename, const std::string& iOptionalPrefix = ""std::"")
{
    return (iToTest == iTypename) || (iToTest == iOptionalPrefix + iTypename);
}",1,1,lib/checkio.cpp,"typesMatch:bool(std.string&,std.string&,std.string&)",<empty>,,false,525,528,typesMatch,,,1,"bool(std.string&,std.string&,std.string&)"
111669151606,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::checkWrongPrintfScanfArguments()
{
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    const bool isWindows = mSettings->platform.isWindows();

    logChecker(""CheckIO::checkWrongPrintfScanfArguments"");

    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token *tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!tok->isName()) continue;

            const Token* argListTok = nullptr; // Points to first va_list argument
            const Token* formatStringTok = nullptr; // Points to format string token

            bool scan = false;
            bool scanf_s = false;
            int formatStringArgNo = -1;

            if (tok->strAt(1) == ""("" && mSettings->library.formatstr_function(tok)) {
                formatStringArgNo = mSettings->library.formatstr_argno(tok);
                scan = mSettings->library.formatstr_scan(tok);
                scanf_s = mSettings->lib...",1,1,lib/checkio.cpp,CheckIO.checkWrongPrintfScanfArguments:void(),<empty>,,false,530,600,checkWrongPrintfScanfArguments,,,1,void()
111669151607,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::checkFormatString(const Token * const tok,
                                const Token * const formatStringTok,
                                const Token *       argListTok,
                                const bool scan,
                                const bool scanf_s)
{
    const bool isWindows = mSettings->platform.isWindows();
    const bool printWarning = mSettings->severity.isEnabled(Severity::warning);
    const std::string &formatString = formatStringTok->str();

    // Count format string parameters..
    int numFormat = 0;
    int numSecure = 0;
    bool percent = false;
    const Token* argListTok2 = argListTok;
    std::set<int> parameterPositionsUsed;
    for (auto i = formatString.cbegin(); i != formatString.cend(); ++i) {
        if (*i == '%') {
            percent = !percent;
        } else if (percent && *i == '[') {
            while (i != formatString.cend()) {
                if (*i == ']') {
                    numFormat++;
                 ...",1,32,lib/checkio.cpp,"CheckIO.checkFormatString:void(Token*,Token*,Token*,bool,bool)",<empty>,,false,602,1341,checkFormatString,,,1,"void(Token*,Token*,Token*,bool,bool)"
111669151608,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"CheckIO::ArgumentInfo::ArgumentInfo(const Token * arg, const Settings &settings, bool _isCPP)
    : isCPP(_isCPP)
{
    if (!arg)
        return;

    // Use AST type info
    // TODO: This is a bailout so that old code is used in simple cases. Remove the old code and always use the AST type.
    if (!Token::Match(arg, ""%str% ,|)"") && !(arg->variable() && arg->variable()->isArray())) {
        const Token *top = arg;
        while (top->str() == ""("" && !top->isCast())
            top = top->next();
        while (top->astParent() && top->astParent()->str() != "","" && top->astParent() != arg->previous())
            top = top->astParent();
        const ValueType *valuetype = top->argumentType();
        if (valuetype && valuetype->type >= ValueType::Type::BOOL) {
            typeToken = tempToken = new Token(top);
            if (valuetype->pointer && valuetype->constness & 1) {
                tempToken->str(""const"");
                tempToken->insertToken(""a"");
                temp...",1,1,lib/checkio.cpp,"CheckIO.ArgumentInfo.ArgumentInfo:ANY(Token*,Settings&,bool)",<empty>,,false,1346,1557,ArgumentInfo,,,1,"CheckIO.ArgumentInfo.ArgumentInfo:ANY(Token*,Settings&,bool)(Token*,Settings&,bool)"
111669151609,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"CheckIO::ArgumentInfo::~ArgumentInfo()
{
    if (tempToken) {
        while (tempToken->next())
            tempToken->deleteNext();

        delete tempToken;
    }
}",1,1,lib/checkio.cpp,CheckIO.ArgumentInfo.~ArgumentInfo:ANY(),<empty>,,false,1559,1567,~ArgumentInfo,,,1,ANY()
111669151610,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"bool CheckIO::ArgumentInfo::isStdVectorOrString()
{
    if (!isCPP)
        return false;
    if (variableInfo->isStlType(stl_vector)) {
        typeToken = variableInfo->typeStartToken()->tokAt(4);
        _template = true;
        return true;
    }
    if (variableInfo->isStlType(stl_string)) {
        tempToken = new Token(variableInfo->typeStartToken());
        if (variableInfo->typeStartToken()->strAt(2) == ""string"")
            tempToken->str(""char"");
        else
            tempToken->str(""wchar_t"");
        typeToken = tempToken;
        return true;
    }
    if (variableInfo->type() && !variableInfo->type()->derivedFrom.empty()) {
        const std::vector<Type::BaseInfo>& derivedFrom = variableInfo->type()->derivedFrom;
        for (const Type::BaseInfo & i : derivedFrom) {
            const Token* nameTok = i.nameTok;
            if (Token::Match(nameTok, ""std :: vector|array <"")) {
                typeToken = nameTok->tokAt(4);
                _template = true;
     ...",1,1,lib/checkio.cpp,CheckIO.ArgumentInfo.isStdVectorOrString:bool(),<empty>,,false,1574,1626,isStdVectorOrString,,,1,bool()
111669151611,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"bool CheckIO::ArgumentInfo::isStdContainer(const Token *tok)
{
    if (!isCPP)
        return false;
    if (tok && tok->variable()) {
        const Variable* variable = tok->variable();
        if (variable->isStlType(stl_container)) {
            typeToken = variable->typeStartToken()->tokAt(4);
            return true;
        }
        if (variable->isStlType(stl_string)) {
            typeToken = variable->typeStartToken();
            return true;
        }
        if (variable->type() && !variable->type()->derivedFrom.empty()) {
            for (const Type::BaseInfo &baseInfo : variable->type()->derivedFrom) {
                const Token* nameTok = baseInfo.nameTok;
                if (Token::Match(nameTok, ""std :: vector|array|bitset|deque|list|forward_list|map|multimap|multiset|priority_queue|queue|set|stack|hash_map|hash_multimap|hash_set|unordered_map|unordered_multimap|unordered_set|unordered_multiset <"")) {
                    typeToken = nameTok->tokAt(4);
            ...",1,1,lib/checkio.cpp,CheckIO.ArgumentInfo.isStdContainer:bool(Token*),<empty>,,false,1636,1666,isStdContainer,,,1,bool(Token*)
111669151612,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"bool CheckIO::ArgumentInfo::isArrayOrPointer() const
{
    if (address)
        return true;
    if (variableInfo && !_template)
        return variableInfo->isArrayOrPointer();

    const Token *tok = typeToken;
    while (Token::Match(tok, ""const|struct""))
        tok = tok->next();
    return tok && tok->strAt(1) == ""*"";
}",1,1,lib/checkio.cpp,CheckIO.ArgumentInfo.isArrayOrPointer<const>:bool(),<empty>,,false,1668,1679,isArrayOrPointer,,,1,bool()
111669151613,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"bool CheckIO::ArgumentInfo::isComplexType() const
{
    if (variableInfo->type())
        return (true);

    const Token* varTypeTok = typeToken;
    if (varTypeTok->str() == ""std"")
        varTypeTok = varTypeTok->tokAt(2);

    return ((variableInfo->isStlStringType() || (varTypeTok->strAt(1) == ""<"" && varTypeTok->linkAt(1) && varTypeTok->linkAt(1)->strAt(1) != ""::"")) && !variableInfo->isArrayOrPointer());
}",1,1,lib/checkio.cpp,CheckIO.ArgumentInfo.isComplexType<const>:bool(),<empty>,,false,1681,1691,isComplexType,,,1,bool()
111669151614,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"bool CheckIO::ArgumentInfo::isKnownType() const
{
    if (variableInfo)
        return (typeToken->isStandardType() || typeToken->next()->isStandardType() || isComplexType());
    if (functionInfo)
        return (typeToken->isStandardType() || functionInfo->retType || Token::Match(typeToken, ""std :: string|wstring""));

    return typeToken->isStandardType() || Token::Match(typeToken, ""std :: string|wstring"");
}",1,1,lib/checkio.cpp,CheckIO.ArgumentInfo.isKnownType<const>:bool(),<empty>,,false,1693,1701,isKnownType,,,1,bool()
111669151615,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"bool CheckIO::ArgumentInfo::isLibraryType(const Settings &settings) const
{
    return typeToken && typeToken->isStandardType() && settings.library.podtype(typeToken->str());
}",1,1,lib/checkio.cpp,CheckIO.ArgumentInfo.isLibraryType<const>:bool(Settings&),<empty>,,false,1703,1706,isLibraryType,,,1,bool(Settings&)
111669151616,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::wrongPrintfScanfArgumentsError(const Token* tok,
                                             const std::string &functionName,
                                             nonneg int numFormat,
                                             nonneg int numFunction)
{
    const Severity severity = numFormat > numFunction ? Severity::error : Severity::warning;
    if (severity != Severity::error && !mSettings->severity.isEnabled(Severity::warning) && !mSettings->isPremiumEnabled(""wrongPrintfScanfArgNum""))
        return;

    std::ostringstream errmsg;
    errmsg << functionName
           << "" format string requires ""
           << numFormat
           << "" parameter"" << (numFormat != 1 ? ""s"" : """") << "" but ""
           << (numFormat > numFunction ? ""only "" : """")
           << numFunction
           << (numFunction != 1 ? "" are"" : "" is"")
           << "" given."";

    reportError(tok, severity, ""wrongPrintfScanfArgNum"", errmsg.str(), CWE685, Certainty::normal);
}",1,45,lib/checkio.cpp,"CheckIO.wrongPrintfScanfArgumentsError:void(Token*,std.string&,int,int)",<empty>,,false,1708,1728,wrongPrintfScanfArgumentsError,,,1,"void(Token*,std.string&,int,int)"
111669151617,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::wrongPrintfScanfPosixParameterPositionError(const Token* tok, const std::string& functionName,
                                                          nonneg int index, nonneg int numFunction)
{
    if (!mSettings->severity.isEnabled(Severity::warning) && !mSettings->isPremiumEnabled(""wrongPrintfScanfParameterPositionError""))
        return;
    std::ostringstream errmsg;
    errmsg << functionName << "": "";
    if (index == 0) {
        errmsg << ""parameter positions start at 1, not 0"";
    } else {
        errmsg << ""referencing parameter "" << index << "" while "" << numFunction << "" arguments given"";
    }
    reportError(tok, Severity::warning, ""wrongPrintfScanfParameterPositionError"", errmsg.str(), CWE685, Certainty::normal);
}",1,58,lib/checkio.cpp,"CheckIO.wrongPrintfScanfPosixParameterPositionError:void(Token*,std.string&,int,int)",<empty>,,false,1730,1743,wrongPrintfScanfPosixParameterPositionError,,,1,"void(Token*,std.string&,int,int)"
111669151618,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::invalidScanfArgTypeError_s(const Token* tok, nonneg int numFormat, const std::string& specifier, const ArgumentInfo* argInfo)
{
    const Severity severity = getSeverity(argInfo);
    if (!mSettings->severity.isEnabled(severity))
        return;
    std::ostringstream errmsg;
    errmsg << ""%"" << specifier << "" in format string (no. "" << numFormat << "") requires a \\'"";
    if (specifier[0] == 's')
        errmsg << ""char"";
    else if (specifier[0] == 'S')
        errmsg << ""wchar_t"";
    errmsg << "" *\\' but the argument type is "";
    argumentType(errmsg, argInfo);
    errmsg << ""."";
    reportError(tok, severity, ""invalidScanfArgType_s"", errmsg.str(), CWE686, Certainty::normal);
}",1,59,lib/checkio.cpp,"CheckIO.invalidScanfArgTypeError_s:void(Token*,int,std.string&,CheckIO.ArgumentInfo*)",<empty>,,false,1745,1760,invalidScanfArgTypeError_s,,,1,"void(Token*,int,std.string&,CheckIO.ArgumentInfo*)"
111669151619,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::invalidScanfArgTypeError_int(const Token* tok, nonneg int numFormat, const std::string& specifier, const ArgumentInfo* argInfo, bool isUnsigned)
{
    const Severity severity = getSeverity(argInfo);
    if (!mSettings->severity.isEnabled(severity))
        return;
    std::ostringstream errmsg;
    errmsg << ""%"" << specifier << "" in format string (no. "" << numFormat << "") requires \\'"";
    if (specifier[0] == 'h') {
        if (specifier[1] == 'h')
            errmsg << (isUnsigned ? ""unsigned "" : """") << ""char"";
        else
            errmsg << (isUnsigned ? ""unsigned "" : """") << ""short"";
    } else if (specifier[0] == 'l') {
        if (specifier[1] == 'l')
            errmsg << (isUnsigned ? ""unsigned "" : """") << ""long long"";
        else
            errmsg << (isUnsigned ? ""unsigned "" : """") << ""long"";
    } else if (specifier.find(""I32"") != std::string::npos) {
        errmsg << (isUnsigned ? ""unsigned "" : """") << ""__int32"";
    } else if (specifier.find(""I64"") != st...",1,61,lib/checkio.cpp,"CheckIO.invalidScanfArgTypeError_int:void(Token*,int,std.string&,CheckIO.ArgumentInfo*,bool)",<empty>,,false,1761,1805,invalidScanfArgTypeError_int,,,1,"void(Token*,int,std.string&,CheckIO.ArgumentInfo*,bool)"
111669151620,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::invalidScanfArgTypeError_float(const Token* tok, nonneg int numFormat, const std::string& specifier, const ArgumentInfo* argInfo)
{
    const Severity severity = getSeverity(argInfo);
    if (!mSettings->severity.isEnabled(severity))
        return;
    std::ostringstream errmsg;
    errmsg << ""%"" << specifier << "" in format string (no. "" << numFormat << "") requires \\'"";
    if (specifier[0] == 'l' && specifier[1] != 'l')
        errmsg << ""double"";
    else if (specifier[0] == 'L')
        errmsg << ""long double"";
    else
        errmsg << ""float"";
    errmsg << "" *\\' but the argument type is "";
    argumentType(errmsg, argInfo);
    errmsg << ""."";
    reportError(tok, severity, ""invalidScanfArgType_float"", errmsg.str(), CWE686, Certainty::normal);
}",1,63,lib/checkio.cpp,"CheckIO.invalidScanfArgTypeError_float:void(Token*,int,std.string&,CheckIO.ArgumentInfo*)",<empty>,,false,1806,1823,invalidScanfArgTypeError_float,,,1,"void(Token*,int,std.string&,CheckIO.ArgumentInfo*)"
111669151621,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::invalidPrintfArgTypeError_s(const Token* tok, nonneg int numFormat, const ArgumentInfo* argInfo)
{
    const Severity severity = getSeverity(argInfo);
    if (!mSettings->severity.isEnabled(severity))
        return;
    std::ostringstream errmsg;
    errmsg << ""%s in format string (no. "" << numFormat << "") requires \\'char *\\' but the argument type is "";
    argumentType(errmsg, argInfo);
    errmsg << ""."";
    reportError(tok, severity, ""invalidPrintfArgType_s"", errmsg.str(), CWE686, Certainty::normal);
}",1,60,lib/checkio.cpp,"CheckIO.invalidPrintfArgTypeError_s:void(Token*,int,CheckIO.ArgumentInfo*)",<empty>,,false,1825,1835,invalidPrintfArgTypeError_s,,,1,"void(Token*,int,CheckIO.ArgumentInfo*)"
111669151622,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::invalidPrintfArgTypeError_n(const Token* tok, nonneg int numFormat, const ArgumentInfo* argInfo)
{
    const Severity severity = getSeverity(argInfo);
    if (!mSettings->severity.isEnabled(severity))
        return;
    std::ostringstream errmsg;
    errmsg << ""%n in format string (no. "" << numFormat << "") requires \\'int *\\' but the argument type is "";
    argumentType(errmsg, argInfo);
    errmsg << ""."";
    reportError(tok, severity, ""invalidPrintfArgType_n"", errmsg.str(), CWE686, Certainty::normal);
}",1,60,lib/checkio.cpp,"CheckIO.invalidPrintfArgTypeError_n:void(Token*,int,CheckIO.ArgumentInfo*)",<empty>,,false,1836,1846,invalidPrintfArgTypeError_n,,,1,"void(Token*,int,CheckIO.ArgumentInfo*)"
111669151623,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::invalidPrintfArgTypeError_p(const Token* tok, nonneg int numFormat, const ArgumentInfo* argInfo)
{
    const Severity severity = getSeverity(argInfo);
    if (!mSettings->severity.isEnabled(severity))
        return;
    std::ostringstream errmsg;
    errmsg << ""%p in format string (no. "" << numFormat << "") requires an address but the argument type is "";
    argumentType(errmsg, argInfo);
    errmsg << ""."";
    reportError(tok, severity, ""invalidPrintfArgType_p"", errmsg.str(), CWE686, Certainty::normal);
}",1,60,lib/checkio.cpp,"CheckIO.invalidPrintfArgTypeError_p:void(Token*,int,CheckIO.ArgumentInfo*)",<empty>,,false,1847,1857,invalidPrintfArgTypeError_p,,,1,"void(Token*,int,CheckIO.ArgumentInfo*)"
111669151624,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"static void printfFormatType(std::ostream& os, const std::string& specifier, bool isUnsigned)
{
    os << ""\\'"";
    if (specifier[0] == 'l') {
        if (specifier[1] == 'l')
            os << (isUnsigned ? ""unsigned "" : """") << ""long long"";
        else
            os << (isUnsigned ? ""unsigned "" : """") << ""long"";
    } else if (specifier[0] == 'h') {
        if (specifier[1] == 'h')
            os << (isUnsigned ? ""unsigned "" : """") << ""char"";
        else
            os << (isUnsigned ? ""unsigned "" : """") << ""short"";
    } else if (specifier.find(""I32"") != std::string::npos) {
        os << (isUnsigned ? ""unsigned "" : """") << ""__int32"";
    } else if (specifier.find(""I64"") != std::string::npos) {
        os << (isUnsigned ? ""unsigned "" : """") << ""__int64"";
    } else if (specifier[0] == 'I') {
        os << (isUnsigned ? ""size_t"" : ""ptrdiff_t"");
    } else if (specifier[0] == 'j') {
        if (isUnsigned)
            os << ""uintmax_t"";
        else
            os << ""intmax_t"";
    }...",1,1,lib/checkio.cpp,"printfFormatType:void(std.ostream&,std.string&,bool)",<empty>,,false,1858,1895,printfFormatType,,,1,"void(std.ostream&,std.string&,bool)"
111669151625,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::invalidPrintfArgTypeError_uint(const Token* tok, nonneg int numFormat, const std::string& specifier, const ArgumentInfo* argInfo)
{
    const Severity severity = getSeverity(argInfo);
    if (!mSettings->severity.isEnabled(severity))
        return;
    std::ostringstream errmsg;
    errmsg << ""%"" << specifier << "" in format string (no. "" << numFormat << "") requires "";
    printfFormatType(errmsg, specifier, true);
    errmsg << "" but the argument type is "";
    argumentType(errmsg, argInfo);
    errmsg << ""."";
    reportError(tok, severity, ""invalidPrintfArgType_uint"", errmsg.str(), CWE686, Certainty::normal);
}",1,63,lib/checkio.cpp,"CheckIO.invalidPrintfArgTypeError_uint:void(Token*,int,std.string&,CheckIO.ArgumentInfo*)",<empty>,,false,1897,1909,invalidPrintfArgTypeError_uint,,,1,"void(Token*,int,std.string&,CheckIO.ArgumentInfo*)"
111669151626,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::invalidPrintfArgTypeError_sint(const Token* tok, nonneg int numFormat, const std::string& specifier, const ArgumentInfo* argInfo)
{
    const Severity severity = getSeverity(argInfo);
    if (!mSettings->severity.isEnabled(severity))
        return;
    std::ostringstream errmsg;
    errmsg << ""%"" << specifier << "" in format string (no. "" << numFormat << "") requires "";
    printfFormatType(errmsg, specifier, false);
    errmsg << "" but the argument type is "";
    argumentType(errmsg, argInfo);
    errmsg << ""."";
    reportError(tok, severity, ""invalidPrintfArgType_sint"", errmsg.str(), CWE686, Certainty::normal);
}",1,63,lib/checkio.cpp,"CheckIO.invalidPrintfArgTypeError_sint:void(Token*,int,std.string&,CheckIO.ArgumentInfo*)",<empty>,,false,1911,1923,invalidPrintfArgTypeError_sint,,,1,"void(Token*,int,std.string&,CheckIO.ArgumentInfo*)"
111669151627,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::invalidPrintfArgTypeError_float(const Token* tok, nonneg int numFormat, const std::string& specifier, const ArgumentInfo* argInfo)
{
    const Severity severity = getSeverity(argInfo);
    if (!mSettings->severity.isEnabled(severity))
        return;
    std::ostringstream errmsg;
    errmsg << ""%"" << specifier << "" in format string (no. "" << numFormat << "") requires \\'"";
    if (specifier[0] == 'L')
        errmsg << ""long "";
    errmsg << ""double\\' but the argument type is "";
    argumentType(errmsg, argInfo);
    errmsg << ""."";
    reportError(tok, severity, ""invalidPrintfArgType_float"", errmsg.str(), CWE686, Certainty::normal);
}",1,64,lib/checkio.cpp,"CheckIO.invalidPrintfArgTypeError_float:void(Token*,int,std.string&,CheckIO.ArgumentInfo*)",<empty>,,false,1924,1937,invalidPrintfArgTypeError_float,,,1,"void(Token*,int,std.string&,CheckIO.ArgumentInfo*)"
111669151628,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"Severity CheckIO::getSeverity(const CheckIO::ArgumentInfo *argInfo)
{
    return (argInfo && argInfo->typeToken && !argInfo->typeToken->originalName().empty()) ? Severity::portability : Severity::warning;
}",1,1,lib/checkio.cpp,CheckIO.getSeverity:Severity(CheckIO.ArgumentInfo*),<empty>,,false,1939,1942,getSeverity,,,1,Severity(CheckIO.ArgumentInfo*)
111669151629,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::argumentType(std::ostream& os, const ArgumentInfo * argInfo)
{
    if (argInfo) {
        os << ""\\'"";
        const Token *type = argInfo->typeToken;
        if (type->tokType() == Token::eString) {
            if (type->isLong())
                os << ""const wchar_t *"";
            else
                os << ""const char *"";
        } else {
            if (type->originalName().empty()) {
                if (type->strAt(-1) == ""const"")
                    os << ""const "";
                while (Token::Match(type, ""const|struct"")) {
                    os << type->str() << "" "";
                    type = type->next();
                }
                while (Token::Match(type, ""%any% ::"")) {
                    os << type->str() << ""::"";
                    type = type->tokAt(2);
                }
                os << type->stringify(false, true, false);
                if (type->strAt(1) == ""*"" && !argInfo->element)
                    os << "" *"";
                else ...",1,1,lib/checkio.cpp,"CheckIO.argumentType:void(std.ostream&,CheckIO.ArgumentInfo*)",<empty>,,false,1944,1992,argumentType,,,1,"void(std.ostream&,CheckIO.ArgumentInfo*)"
111669151630,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::invalidLengthModifierError(const Token* tok, nonneg int numFormat, const std::string& modifier)
{
    if (!mSettings->severity.isEnabled(Severity::warning) && !mSettings->isPremiumEnabled(""invalidLengthModifierError""))
        return;
    std::ostringstream errmsg;
    errmsg << ""'"" << modifier << ""' in format string (no. "" << numFormat << "") is a length modifier and cannot be used without a conversion specifier."";
    reportError(tok, Severity::warning, ""invalidLengthModifierError"", errmsg.str(), CWE704, Certainty::normal);
}",1,59,lib/checkio.cpp,"CheckIO.invalidLengthModifierError:void(Token*,int,std.string&)",<empty>,,false,1994,2001,invalidLengthModifierError,,,1,"void(Token*,int,std.string&)"
111669151631,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::invalidScanfFormatWidthError(const Token* tok, nonneg int numFormat, int width, const Variable *var, const std::string& specifier)
{
    MathLib::bigint arrlen = 0;
    std::string varname;

    if (var) {
        arrlen = var->dimension(0);
        varname = var->name();
    }

    std::ostringstream errmsg;
    if (arrlen > width) {
        if (tok != nullptr && (!mSettings->certainty.isEnabled(Certainty::inconclusive) || !mSettings->severity.isEnabled(Severity::warning)))
            return;
        errmsg << ""Width "" << width << "" given in format string (no. "" << numFormat << "") is smaller than destination buffer""
               << "" '"" << varname << ""["" << arrlen << ""]'."";
        reportError(tok, Severity::warning, ""invalidScanfFormatWidth_smaller"", errmsg.str(), CWE(0U), Certainty::inconclusive);
    } else {
        errmsg << ""Width "" << width << "" given in format string (no. "" << numFormat << "") is larger than destination buffer '""
               << varname <<...",1,61,lib/checkio.cpp,"CheckIO.invalidScanfFormatWidthError:void(Token*,int,int,Variable*,std.string&)",<empty>,,false,2003,2025,invalidScanfFormatWidthError,,,1,"void(Token*,int,int,Variable*,std.string&)"
111669151632,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    CheckIO checkIO(&tokenizer, &tokenizer.getSettings(), errorLogger);

    checkIO.checkWrongPrintfScanfArguments();
    checkIO.checkCoutCerrMisusage();
    checkIO.checkFileUsage();
    checkIO.invalidScanf();
}",1,1,lib/checkio.cpp,"CheckIO.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,2027,2035,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669151633,METHOD,lib/checkio.cpp:<global>,TYPE_DECL,"void CheckIO::getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const
{
    CheckIO c(nullptr, settings, errorLogger);
    c.coutCerrMisusageError(nullptr,  ""cout"");
    c.fflushOnInputStreamError(nullptr,  ""stdin"");
    c.ioWithoutPositioningError(nullptr);
    c.readWriteOnlyFileError(nullptr);
    c.writeReadOnlyFileError(nullptr);
    c.useClosedFileError(nullptr);
    c.seekOnAppendedFileError(nullptr);
    c.incompatibleFileOpenError(nullptr, ""tmp"");
    c.invalidScanfError(nullptr);
    c.wrongPrintfScanfArgumentsError(nullptr, ""printf"",3,2);
    c.invalidScanfArgTypeError_s(nullptr,  1, ""s"", nullptr);
    c.invalidScanfArgTypeError_int(nullptr,  1, ""d"", nullptr, false);
    c.invalidScanfArgTypeError_float(nullptr,  1, ""f"", nullptr);
    c.invalidPrintfArgTypeError_s(nullptr,  1, nullptr);
    c.invalidPrintfArgTypeError_n(nullptr,  1, nullptr);
    c.invalidPrintfArgTypeError_p(nullptr,  1, nullptr);
    c.invalidPrintfArgTypeError_uint(nullptr,  1, ""u"", ...",1,1,lib/checkio.cpp,"CheckIO.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,2037,2063,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669151634,METHOD,lib/checkio.h:<global>,TYPE_DECL,<global>,1,1,lib/checkio.h,lib/checkio.h:<global>,<empty>,,false,1,153,<global>,,,1,
111669151635,METHOD,<empty>,<empty>,"[](const Variable& v) {
        return !v.valueType() || (!v.valueType()->isPrimitive() && !v.valueType()->container);
    }",53,5,lib/checkleakautovar.cpp,lib/checkleakautovar.cpp:<global>.isAutoDeallocType.<lambda>0:bool(Variable&),<empty>,,false,68,70,<lambda>0,,,1,bool(Variable&)
111669151636,METHOD,<empty>,<empty>,"[](const Type::BaseInfo& bi) {
        return isAutoDeallocType(bi.type);
    }",76,5,lib/checkleakautovar.cpp,lib/checkleakautovar.cpp:<global>.isAutoDeallocType.<lambda>1:bool(Type.BaseInfo&),<empty>,,false,72,74,<lambda>1,,,1,bool(Type.BaseInfo&)
111669151637,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"static bool isAutoDeallocType(const Type* type) {
    if (!type || !type->classScope)
        return true;
    if (type->classScope->numConstructors > 0)
        return true;
    const std::list<Variable>& varlist = type->classScope->varlist;
    if (std::any_of(varlist.begin(), varlist.end(), [](const Variable& v) {
        return !v.valueType() || (!v.valueType()->isPrimitive() && !v.valueType()->container);
    }))
        return true;
    if (std::none_of(type->derivedFrom.cbegin(), type->derivedFrom.cend(), [](const Type::BaseInfo& bi) {
        return isAutoDeallocType(bi.type);
    }))
        return false;
    return true;
}",1,1,lib/checkleakautovar.cpp,isAutoDeallocType:bool(Type*),<empty>,,false,62,77,isAutoDeallocType,,,1,bool(Type*)
111669151638,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,<global>,1,1,lib/checkleakautovar.cpp,lib/checkleakautovar.cpp:<global>,<empty>,,false,1,1257,<global>,,,1,
111669151639,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"static bool isAutoDealloc(const Variable *var)
{
    if (var->valueType() && var->valueType()->type != ValueType::Type::RECORD && var->valueType()->type != ValueType::Type::UNKNOWN_TYPE)
        return false;

    // return false if the type is a simple record type without side effects
    // a type that has no side effects (no constructors and no members with constructors)
    /** @todo false negative: check constructors for side effects */
    return isAutoDeallocType(var->type());
}",1,1,lib/checkleakautovar.cpp,isAutoDealloc:bool(Variable*),<empty>,,false,84,93,isAutoDealloc,,,1,bool(Variable*)
111669151640,METHOD,<empty>,<empty>,"[&](const std::pair<std::string, std::string>& op) {
        return astIsVariableComparison(tok, op.first, op.second, vartok);
    }",50,5,lib/checkleakautovar.cpp,"lib/checkleakautovar.cpp:<global>.isVarTokComparison.<lambda>2:14astIsVariableComparison435isVarTokComparison00103910004971039100049735isVarTokComparison10(std.pair<std.string,std.string>&)",<empty>,,false,99,101,<lambda>2,,,1,"14astIsVariableComparison435isVarTokComparison00103910004971039100049735isVarTokComparison10(std.pair<std.string,std.string>&)"
111669151641,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"static bool isVarTokComparison(const Token * tok, const Token ** vartok,
                               const std::array<std::pair<std::string, std::string>, N>& ops)
{
    return std::any_of(ops.cbegin(), ops.cend(), [&](const std::pair<std::string, std::string>& op) {
        return astIsVariableComparison(tok, op.first, op.second, vartok);
    });
}",1,1,lib/checkleakautovar.cpp,"isVarTokComparison:bool(Token*,Token**,std.array<std.pair<std.string,std.string>,N>&)",<empty>,,false,96,102,isVarTokComparison,,,1,"bool(Token*,Token**,std.array<std.pair<std.string,std.string>,N>&)"
111669151642,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"void VarInfo::possibleUsageAll(const std::pair<const Token*, Usage>& functionUsage)
{
    possibleUsage.clear();
    for (auto it = alloctype.cbegin(); it != alloctype.cend(); ++it)
        possibleUsage[it->first] = functionUsage;
}",1,1,lib/checkleakautovar.cpp,"VarInfo.possibleUsageAll:void(std.pair<constToken*,Usage>&)",<empty>,,false,106,111,possibleUsageAll,,,1,"void(std.pair<constToken*,Usage>&)"
111669151643,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"void CheckLeakAutoVar::leakError(const Token *tok, const std::string &varname, int type) const
{
    const CheckMemoryLeak checkmemleak(mTokenizer, mErrorLogger, mSettings);
    if (Library::isresource(type))
        checkmemleak.resourceLeakError(tok, varname);
    else
        checkmemleak.memleakError(tok, varname);
}",1,1,lib/checkleakautovar.cpp,"CheckLeakAutoVar.leakError<const>:void(Token*,std.string&,int)",<empty>,,false,114,121,leakError,,,1,"void(Token*,std.string&,int)"
111669151644,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"void CheckLeakAutoVar::mismatchError(const Token *deallocTok, const Token *allocTok, const std::string &varname) const
{
    const CheckMemoryLeak c(mTokenizer, mErrorLogger, mSettings);
    const std::list<const Token *> callstack = { allocTok, deallocTok };
    c.mismatchAllocDealloc(callstack, varname);
}",1,1,lib/checkleakautovar.cpp,"CheckLeakAutoVar.mismatchError<const>:void(Token*,Token*,std.string&)",<empty>,,false,123,128,mismatchError,,,1,"void(Token*,Token*,std.string&)"
111669151645,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"void CheckLeakAutoVar::deallocUseError(const Token *tok, const std::string &varname) const
{
    const CheckMemoryLeak c(mTokenizer, mErrorLogger, mSettings);
    c.deallocuseError(tok, varname);
}",1,1,lib/checkleakautovar.cpp,"CheckLeakAutoVar.deallocUseError<const>:void(Token*,std.string&)",<empty>,,false,130,134,deallocUseError,,,1,"void(Token*,std.string&)"
111669151646,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"void CheckLeakAutoVar::deallocReturnError(const Token *tok, const Token *deallocTok, const std::string &varname)
{
    const std::list<const Token *> locations = { deallocTok, tok };
    reportError(locations, Severity::error, ""deallocret"", ""$symbol:"" + varname + ""\\nReturning/dereferencing '$symbol' after it is deallocated / released"", CWE672, Certainty::normal);
}",1,1,lib/checkleakautovar.cpp,"CheckLeakAutoVar.deallocReturnError:void(Token*,Token*,std.string&)",<empty>,,false,136,140,deallocReturnError,,,1,"void(Token*,Token*,std.string&)"
111669151647,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"void CheckLeakAutoVar::configurationInfo(const Token* tok, const std::pair<const Token*, VarInfo::Usage>& functionUsage)
{
    if (mSettings->checkLibrary && functionUsage.second == VarInfo::USED &&
        (!functionUsage.first || !functionUsage.first->function() || !functionUsage.first->function()->hasBody())) {
        std::string funcStr = functionUsage.first ? mSettings->library.getFunctionName(functionUsage.first) : ""f"";
        if (funcStr.empty())
            funcStr = ""unknown::"" + functionUsage.first->str();
        reportError(tok,
                    Severity::information,
                    ""checkLibraryUseIgnore"",
                    ""--check-library: Function "" + funcStr + ""() should have <use>/<leak-ignore> configuration"");
    }
}",1,1,lib/checkleakautovar.cpp,"CheckLeakAutoVar.configurationInfo:void(Token*,std.pair<constToken*,VarInfo.Usage>&)",<empty>,,false,142,154,configurationInfo,,,1,"void(Token*,std.pair<constToken*,VarInfo.Usage>&)"
111669151648,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"void CheckLeakAutoVar::doubleFreeError(const Token *tok, const Token *prevFreeTok, const std::string &varname, int type)
{
    const std::list<const Token *> locations = { prevFreeTok, tok };

    if (Library::isresource(type))
        reportError(locations, Severity::error, ""doubleFree"", ""$symbol:"" + varname + ""\\nResource handle '$symbol' freed twice."", CWE415, Certainty::normal);
    else
        reportError(locations, Severity::error, ""doubleFree"", ""$symbol:"" + varname + ""\\nMemory pointed to by '$symbol' is freed twice."", CWE415, Certainty::normal);
}",1,1,lib/checkleakautovar.cpp,"CheckLeakAutoVar.doubleFreeError:void(Token*,Token*,std.string&,int)",<empty>,,false,156,164,doubleFreeError,,,1,"void(Token*,Token*,std.string&,int)"
111669151649,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"void CheckLeakAutoVar::check()
{
    if (mSettings->clang)
        return;

    logChecker(""CheckLeakAutoVar::check""); // notclang

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    // Local variables that are known to be non-zero.
    const std::set<int> notzero;

    // Check function scopes
    for (const Scope * scope : symbolDatabase->functionScopes) {
        if (scope->hasInlineOrLambdaFunction())
            continue;

        // Empty variable info
        VarInfo varInfo;

        checkScope(scope->bodyStart, varInfo, notzero, 0);
    }
}",1,1,lib/checkleakautovar.cpp,CheckLeakAutoVar.check:void(),<empty>,,false,167,189,check,,,1,void()
111669151650,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"static bool isVarUsedInTree(const Token *tok, nonneg int varid)
{
    if (!tok)
        return false;
    if (tok->varId() == varid)
        return true;
    if (tok->str() == ""("" && Token::simpleMatch(tok->astOperand1(), ""sizeof""))
        return false;
    return isVarUsedInTree(tok->astOperand1(), varid) || isVarUsedInTree(tok->astOperand2(), varid);
}",1,46,lib/checkleakautovar.cpp,"isVarUsedInTree:bool(Token*,int)",<empty>,,false,191,200,isVarUsedInTree,,,1,"bool(Token*,int)"
111669151651,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"static bool isPointerReleased(const Token *startToken, const Token *endToken, nonneg int varid)
{
    for (const Token *tok = startToken; tok && tok != endToken; tok = tok->next()) {
        if (tok->varId() != varid)
            continue;
        if (Token::Match(tok, ""%var% . release ( )""))
            return true;
        if (Token::Match(tok, ""%var% =""))
            return false;
    }
    return false;
}",1,78,lib/checkleakautovar.cpp,"isPointerReleased:bool(Token*,Token*,int)",<empty>,,false,202,213,isPointerReleased,,,1,"bool(Token*,Token*,int)"
111669151652,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"static bool isLocalVarNoAutoDealloc(const Token *varTok)
{
    // not a local variable nor argument?
    const Variable *var = varTok->variable();
    if (!var)
        return true;
    if (!var->isArgument() && (!var->isLocal() || var->isStatic()))
        return false;

    // Don't check reference variables
    if (var->isReference() && !var->isArgument())
        return false;

    // non-pod variable
    if (varTok->isCpp()) {
        // Possibly automatically deallocated memory
        if (isAutoDealloc(var) && Token::Match(varTok, ""%var% [=({] new""))
            return false;
        if (!var->isPointer() && !var->typeStartToken()->isStandardType())
            return false;
    }
    return true;
}",1,1,lib/checkleakautovar.cpp,isLocalVarNoAutoDealloc:bool(Token*),<empty>,,false,215,237,isLocalVarNoAutoDealloc,,,1,bool(Token*)
111669151653,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"static const Token * isFunctionCall(const Token * nameToken)
{
    if (!nameToken->isStandardType() && nameToken->isName()) {
        nameToken = nameToken->next();
        // check if function is a template
        if (nameToken && nameToken->link() && nameToken->str() == ""<"") {
            // skip template arguments
            nameToken = nameToken->link()->next();
        }
        // check for '('
        if (nameToken && nameToken->link() && !nameToken->isCast() && nameToken->str() == ""("") {
            // returning opening parenthesis pointer
            return nameToken;
        }
    }
    return nullptr;
}",1,1,lib/checkleakautovar.cpp,isFunctionCall:Token*(Token*),<empty>,,false,247,263,isFunctionCall,,,1,Token*(Token*)
111669151654,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"static const Token* getOutparamAllocation(const Token* tok, const Settings& settings)
{
    if (!tok)
        return nullptr;
    int argn{};
    const Token* ftok = getTokenArgumentFunction(tok, argn);
    if (!ftok)
        return nullptr;
    if (const Library::AllocFunc* allocFunc = settings.library.getAllocFuncInfo(ftok)) {
        if (allocFunc->arg == argn + 1)
            return ftok;
    }
    return nullptr;
}",1,1,lib/checkleakautovar.cpp,"getOutparamAllocation:Token*(Token*,Settings&)",<empty>,,false,265,278,getOutparamAllocation,,,1,"Token*(Token*,Settings&)"
111669151655,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"static const Token* getReturnValueFromOutparamAlloc(const Token* alloc, const Settings& settings)
{
    if (const Token* ftok = getOutparamAllocation(alloc, settings)) {
        if (Token::simpleMatch(ftok->astParent()->astParent(), ""=""))
            return ftok->next()->astParent()->astOperand1();
    }
    return nullptr;
}",1,1,lib/checkleakautovar.cpp,"getReturnValueFromOutparamAlloc:Token*(Token*,Settings&)",<empty>,,false,280,287,getReturnValueFromOutparamAlloc,,,1,"Token*(Token*,Settings&)"
111669151656,METHOD,<empty>,<empty>,"[](const Direction dir) {
                    return dir == Direction::DIR_OUT;
                }",98,17,lib/checkleakautovar.cpp,lib/checkleakautovar.cpp:<global>.CheckLeakAutoVar.checkScope.<lambda>3.<lambda>4:bool(Direction),<empty>,,false,373,375,<lambda>4,,,1,bool(Direction)
111669151657,METHOD,<empty>,<empty>,"[](const std::pair<int, ArgumentChecks> &pair) {
                return std::any_of(pair.second.direction.cbegin(), pair.second.direction.cend(), [](const Direction dir) {
                    return dir == Direction::DIR_OUT;
                });
            }",82,13,lib/checkleakautovar.cpp,"lib/checkleakautovar.cpp:<global>.CheckLeakAutoVar.checkScope.<lambda>3:ANY(std.pair<int,ArgumentChecks>&)",<empty>,,false,372,376,<lambda>3,,,1,"ANY(std.pair<int,ArgumentChecks>&)"
111669151658,METHOD,<empty>,<empty>,"[&](const Direction dir) {
                        return dir == Direction::DIR_IN;
                    }",112,21,lib/checkleakautovar.cpp,lib/checkleakautovar.cpp:<global>.CheckLeakAutoVar.checkScope.<lambda>5:bool(Direction),<empty>,,false,382,384,<lambda>5,,,1,bool(Direction)
111669151659,METHOD,<empty>,<empty>,"[](const Token* varTok) -> const Token* {
            if (varTok->varId()) {
                const Token* top = varTok;
                while (top->astParent()) {
                    top = top->astParent();
                    if (!Token::Match(top, ""(|*|&|.""))
                        break;
                }
                if (top->str() == ""="" && succeeds(top, varTok))
                    return top;
            }
            return nullptr;
        }",29,9,lib/checkleakautovar.cpp,lib/checkleakautovar.cpp:<global>.CheckLeakAutoVar.checkScope.<lambda>6:Token(Token*),<empty>,,false,400,412,<lambda>6,,,1,Token(Token*)
111669151660,METHOD,<empty>,<empty>,"[&](const std::pair<int, VarInfo::AllocInfo>& info) {
                            if (info.second.status != VarInfo::ALLOC)
                                return false;
                            const Token* ret = getReturnValueFromOutparamAlloc(info.second.allocTok, *mSettings);
                            return ret && vartok && ret->varId() && ret->varId() == vartok->varId();
                        }",95,25,lib/checkleakautovar.cpp,"lib/checkleakautovar.cpp:<global>.CheckLeakAutoVar.checkScope.<lambda>7.<lambda>8:bool(std.pair<int,VarInfo.AllocInfo>&)",<empty>,,false,597,602,<lambda>8,,,1,"bool(std.pair<int,VarInfo.AllocInfo>&)"
111669151661,METHOD,<empty>,<empty>,"[&](const Token *tok3) {
                    if (!tok3)
                        return ChildrenToVisit::none;
                    if (tok3->str() == ""&&"" || tok3->str() == ""||"") {
                        // FIXME: handle && ! || better
                        return ChildrenToVisit::op1_and_op2;
                    }
                    if (tok3->str() == ""("" && Token::Match(tok3->astOperand1(), ""UNLIKELY|LIKELY"")) {
                        return ChildrenToVisit::op2;
                    }
                    if (tok3->str() == ""("" && tok3->previous()->isName()) {
                        const std::vector<const Token *> params = getArguments(tok3->previous());
                        for (const Token *par : params) {
                            if (!par->isComparisonOp())
                                continue;
                            const Token *vartok = nullptr;
                            if (isVarTokComparison(par, &vartok, alloc_success_conds) ||
                       ...",55,17,lib/checkleakautovar.cpp,lib/checkleakautovar.cpp:<global>.CheckLeakAutoVar.checkScope.<lambda>7:ChildrenToVisit(Token*),<empty>,,false,564,610,<lambda>7,,,1,ChildrenToVisit(Token*)
111669151662,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"bool CheckLeakAutoVar::checkScope(const Token * const startToken,
                                  VarInfo &varInfo,
                                  std::set<int> notzero,
                                  nonneg int recursiveCount)
{
#if ASAN
    static const nonneg int recursiveLimit = 300;
#elif defined(__MINGW32__)
    // testrunner crashes with stack overflow in CI
    static constexpr nonneg int recursiveLimit = 600;
#else
    static constexpr nonneg int recursiveLimit = 1000;
#endif
    if (++recursiveCount > recursiveLimit)    // maximum number of ""else if ()""
        throw InternalError(startToken, ""Internal limit: CheckLeakAutoVar::checkScope() Maximum recursive count of 1000 reached."", InternalError::LIMIT);

    std::map<int, VarInfo::AllocInfo> &alloctype = varInfo.alloctype;
    auto& possibleUsage = varInfo.possibleUsage;
    const std::set<int> conditionalAlloc(varInfo.conditionalAlloc);

    // Parse all tokens
    const Token * const endToken = startToken->link(...",1,34,lib/checkleakautovar.cpp,"CheckLeakAutoVar.checkScope:bool(Token*,VarInfo&,std.set<int>,int)",<empty>,,false,289,860,checkScope,,,1,"bool(Token*,VarInfo&,std.set<int>,int)"
111669151663,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"const Token * CheckLeakAutoVar::checkTokenInsideExpression(const Token * const tok, VarInfo &varInfo, bool inFuncCall)
{
    // Deallocation and then dereferencing pointer..
    if (tok->varId() > 0) {
        // TODO : Write a separate checker for this that uses valueFlowForward.
        const auto var = utils::as_const(varInfo.alloctype).find(tok->varId());
        if (var != varInfo.alloctype.end()) {
            bool unknown = false;
            if (var->second.status == VarInfo::DEALLOC && tok->valueType() && tok->valueType()->pointer &&
                CheckNullPointer::isPointerDeRef(tok, unknown, *mSettings, /*checkNullArg*/ false) && !unknown) {
                deallocUseError(tok, tok->str());
            } else if (Token::simpleMatch(tok->tokAt(-2), ""= &"")) {
                varInfo.erase(tok->varId());
            } else {
                // check if tok is assigned into another variable
                const Token *rhs = tok;
                bool isAssignment = false;
 ...",1,1,lib/checkleakautovar.cpp,"CheckLeakAutoVar.checkTokenInsideExpression:Token*(Token*,VarInfo&,bool)",<empty>,,false,863,929,checkTokenInsideExpression,,,1,"Token*(Token*,VarInfo&,bool)"
111669151664,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"void CheckLeakAutoVar::changeAllocStatusIfRealloc(std::map<int, VarInfo::AllocInfo> &alloctype, const Token *fTok, const Token *retTok) const
{
    const Library::AllocFunc* f = mSettings->library.getReallocFuncInfo(fTok);
    if (f && f->arg == -1 && f->reallocArg > 0 && f->reallocArg <= numberOfArguments(fTok)) {
        const Token* argTok = getArguments(fTok).at(f->reallocArg - 1);
        if (alloctype.find(argTok->varId()) != alloctype.end()) {
            VarInfo::AllocInfo& argAlloc = alloctype[argTok->varId()];
            if (argAlloc.type != 0 && argAlloc.type != f->groupId)
                mismatchError(fTok, argAlloc.allocTok, argTok->str());
            argAlloc.status = VarInfo::REALLOC;
            argAlloc.allocTok = fTok;
        }
        VarInfo::AllocInfo& retAlloc = alloctype[retTok->varId()];
        retAlloc.type = f->groupId;
        retAlloc.status = VarInfo::ALLOC;
        retAlloc.allocTok = fTok;
        retAlloc.reallocedFromType = argTok->varId();
    }
}",1,1,lib/checkleakautovar.cpp,"CheckLeakAutoVar.changeAllocStatusIfRealloc<const>:void(std.map<int,VarInfo.AllocInfo>&,Token*,Token*)",<empty>,,false,932,950,changeAllocStatusIfRealloc,,,1,"void(std.map<int,VarInfo.AllocInfo>&,Token*,Token*)"
111669151665,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"void CheckLeakAutoVar::changeAllocStatus(VarInfo &varInfo, const VarInfo::AllocInfo& allocation, const Token* tok, const Token* arg)
{
    std::map<int, VarInfo::AllocInfo> &alloctype = varInfo.alloctype;
    const auto var = alloctype.find(arg->varId());
    if (var != alloctype.end()) {
        // bailout if function is also allocating, since the argument might be moved
        // to the return value, such as in fdopen
        if (allocation.allocTok && mSettings->library.getAllocFuncInfo(allocation.allocTok)) {
            varInfo.erase(arg->varId());
            return;
        }
        if (allocation.status == VarInfo::NOALLOC) {
            // possible usage
            varInfo.possibleUsage[arg->varId()] = { tok, VarInfo::USED };
            if (var->second.status == VarInfo::DEALLOC && arg->strAt(-1) == ""&"")
                varInfo.erase(arg->varId());
        } else if (var->second.managed()) {
            doubleFreeError(tok, var->second.allocTok, arg->str(), allocation.t...",1,1,lib/checkleakautovar.cpp,"CheckLeakAutoVar.changeAllocStatus:void(VarInfo&,VarInfo.AllocInfo&,Token*,Token*)",<empty>,,false,953,988,changeAllocStatus,,,1,"void(VarInfo&,VarInfo.AllocInfo&,Token*,Token*)"
111669151666,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"void CheckLeakAutoVar::functionCall(const Token *tokName, const Token *tokOpeningPar, VarInfo &varInfo, const VarInfo::AllocInfo& allocation, const Library::AllocFunc* af)
{
    // Ignore function call?
    const bool isLeakIgnore = mSettings->library.isLeakIgnore(mSettings->library.getFunctionName(tokName));
    if (mSettings->library.getReallocFuncInfo(tokName))
        return;
    if (tokName->next()->valueType() && tokName->next()->valueType()->container && tokName->next()->valueType()->container->stdStringLike)
        return;

    const Token * const tokFirstArg = tokOpeningPar->next();
    if (!tokFirstArg || tokFirstArg->str() == "")"") {
        // no arguments
        return;
    }

    int argNr = 1;
    for (const Token *funcArg = tokFirstArg; funcArg; funcArg = funcArg->nextArgument()) {
        const Token* arg = funcArg;
        if (arg->isCpp()) {
            int tokAdvance = 0;
            if (arg->str() == ""new"")
                tokAdvance = 1;
            else if (T...",1,1,lib/checkleakautovar.cpp,"CheckLeakAutoVar.functionCall:void(Token*,Token*,VarInfo&,VarInfo.AllocInfo&,Library.AllocFunc*)",<empty>,,false,990,1123,functionCall,,,1,"void(Token*,Token*,VarInfo&,VarInfo.AllocInfo&,Library.AllocFunc*)"
111669151667,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"void CheckLeakAutoVar::leakIfAllocated(const Token *vartok,
                                       const VarInfo &varInfo)
{
    const std::map<int, VarInfo::AllocInfo> &alloctype = varInfo.alloctype;
    const auto& possibleUsage = varInfo.possibleUsage;

    const auto var = utils::as_const(alloctype).find(vartok->varId());
    if (var != alloctype.cend() && var->second.status == VarInfo::ALLOC) {
        const auto use = possibleUsage.find(vartok->varId());
        if (use == possibleUsage.end()) {
            leakError(vartok, vartok->str(), var->second.type);
        } else {
            configurationInfo(vartok, use->second);
        }
    }
}",1,1,lib/checkleakautovar.cpp,"CheckLeakAutoVar.leakIfAllocated:void(Token*,VarInfo&)",<empty>,,false,1126,1141,leakIfAllocated,,,1,"void(Token*,VarInfo&)"
111669151668,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"void CheckLeakAutoVar::ret(const Token *tok, VarInfo &varInfo, const bool isEndOfScope)
{
    const std::map<int, VarInfo::AllocInfo> &alloctype = varInfo.alloctype;
    const auto& possibleUsage = varInfo.possibleUsage;
    std::vector<int> toRemove;

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (auto it = alloctype.cbegin(); it != alloctype.cend(); ++it) {
        // don't warn if variable is conditionally allocated, unless it leaves the scope
        if (!isEndOfScope && !it->second.managed() && varInfo.conditionalAlloc.find(it->first) != varInfo.conditionalAlloc.end())
            continue;

        // don't warn if there is a reference of the variable
        if (varInfo.referenced.find(it->first) != varInfo.referenced.end())
            continue;

        const int varid = it->first;
        const Variable *var = symbolDatabase->getVariableFromVarId(varid);
        if (var) {
            // don't warn if we leave an inner scope
          ...",1,1,lib/checkleakautovar.cpp,"CheckLeakAutoVar.ret:void(Token*,VarInfo&,bool)",<empty>,,false,1143,1243,ret,,,1,"void(Token*,VarInfo&,bool)"
111669151669,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"void CheckLeakAutoVar::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    CheckLeakAutoVar checkLeakAutoVar(&tokenizer, &tokenizer.getSettings(), errorLogger);
    checkLeakAutoVar.check();
}",1,1,lib/checkleakautovar.cpp,"CheckLeakAutoVar.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,1245,1249,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669151670,METHOD,lib/checkleakautovar.cpp:<global>,TYPE_DECL,"void CheckLeakAutoVar::getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const
{
    CheckLeakAutoVar c(nullptr, settings, errorLogger);
    c.deallocReturnError(nullptr, nullptr, ""p"");
    c.configurationInfo(nullptr, { nullptr, VarInfo::USED });  // user configuration is needed to complete analysis
    c.doubleFreeError(nullptr, nullptr, ""varname"", 0);
}",1,1,lib/checkleakautovar.cpp,"CheckLeakAutoVar.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,1251,1257,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669151671,METHOD,lib/checkleakautovar.h:<global>,TYPE_DECL,<global>,1,1,lib/checkleakautovar.h,lib/checkleakautovar.h:<global>,<empty>,,false,1,171,<global>,,,1,
111669151672,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"CheckMemoryLeak::AllocType CheckMemoryLeak::getAllocationType(const Token *tok2, nonneg int varid, std::list<const Function*> *callstack) const
{
    // What we may have...
    //     * var = (char *)malloc(10);
    //     * var = new char[10];
    //     * var = strdup(""hello"");
    //     * var = strndup(""hello"", 3);
    if (tok2 && tok2->str() == ""("") {
        tok2 = tok2->link();
        tok2 = tok2 ? tok2->next() : nullptr;
    }
    if (!tok2)
        return No;
    if (tok2->str() == ""::"")
        tok2 = tok2->next();
    while (Token::Match(tok2, ""%name% :: %type%""))
        tok2 = tok2->tokAt(2);
    if (!tok2->isName())
        return No;

    if (!Token::Match(tok2, ""%name% . %type%"")) {
        // Using realloc..
        AllocType reallocType = getReallocationType(tok2, varid);
        if (reallocType != No)
            return reallocType;

        if (tok2->isCpp() && tok2->str() == ""new"") {
            if (tok2->strAt(1) == ""("" && !Token::Match(tok2->next(),""( std| ::...",1,81,lib/checkmemoryleak.cpp,"CheckMemoryLeak.getAllocationType<const>:CheckMemoryLeak.AllocType(Token*,int,std.list<constFunction*>*)",<empty>,,false,55,147,getAllocationType,,,1,"CheckMemoryLeak.AllocType(Token*,int,std.list<constFunction*>*)"
111669151673,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,<global>,1,1,lib/checkmemoryleak.cpp,lib/checkmemoryleak.cpp:<global>,<empty>,,false,1,1218,<global>,,,1,
111669151674,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"CheckMemoryLeak::AllocType CheckMemoryLeak::getReallocationType(const Token *tok2, nonneg int varid) const
{
    // What we may have...
    //     * var = (char *)realloc(..;
    if (tok2 && tok2->str() == ""("") {
        tok2 = tok2->link();
        tok2 = tok2 ? tok2->next() : nullptr;
    }
    if (!tok2)
        return No;

    if (!Token::Match(tok2, ""%name% (""))
        return No;

    const Library::AllocFunc *f = mSettings_->library.getReallocFuncInfo(tok2);
    if (!(f && f->reallocArg > 0 && f->reallocArg <= numberOfArguments(tok2)))
        return No;
    const auto args = getArguments(tok2);
    if (args.size() < (f->reallocArg))
        return No;
    const Token* arg = args.at(f->reallocArg - 1);
    while (arg && arg->isCast())
        arg = arg->astOperand1();
    while (arg && arg->isUnaryOp(""*""))
        arg = arg->astOperand1();
    if (varid > 0 && !Token::Match(arg, ""%varid% [,)]"", varid))
        return No;

    const int realloctype = mSettings_->library.getRea...",1,83,lib/checkmemoryleak.cpp,"CheckMemoryLeak.getReallocationType<const>:CheckMemoryLeak.AllocType(Token*,int)",<empty>,,false,150,187,getReallocationType,,,1,"CheckMemoryLeak.AllocType(Token*,int)"
111669151675,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"CheckMemoryLeak::AllocType CheckMemoryLeak::getDeallocationType(const Token *tok, nonneg int varid) const
{
    if (tok->isCpp() && tok->str() == ""delete"" && tok->astOperand1()) {
        const Token* vartok = tok->astOperand1();
        if (Token::Match(vartok, "".|::""))
            vartok = vartok->astOperand2();

        if (vartok && vartok->varId() == varid) {
            if (tok->strAt(1) == ""["")
                return NewArray;
            return New;
        }
    }

    if (tok->str() == ""::"")
        tok = tok->next();

    if (Token::Match(tok, ""%name% ("")) {
        if (Token::simpleMatch(tok, ""fcloseall ( )""))
            return File;

        int argNr = 1;
        for (const Token* tok2 = tok->tokAt(2); tok2; tok2 = tok2->nextArgument()) {
            const Token* vartok = tok2;
            while (Token::Match(vartok, ""%name% .|::""))
                vartok = vartok->tokAt(2);

            if (Token::Match(vartok, ""%varid% )|,|-"", varid)) {
                if (tok->str(...",1,82,lib/checkmemoryleak.cpp,"CheckMemoryLeak.getDeallocationType<const>:CheckMemoryLeak.AllocType(Token*,int)",<empty>,,false,190,243,getDeallocationType,,,1,"CheckMemoryLeak.AllocType(Token*,int)"
111669151676,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"bool CheckMemoryLeak::isReopenStandardStream(const Token *tok) const
{
    if (getReallocationType(tok, 0) == File) {
        const Library::AllocFunc *f = mSettings_->library.getReallocFuncInfo(tok);
        if (f && f->reallocArg > 0 && f->reallocArg <= numberOfArguments(tok)) {
            const Token* arg = getArguments(tok).at(f->reallocArg - 1);
            if (Token::Match(arg, ""stdin|stdout|stderr""))
                return true;
        }
    }
    return false;
}",1,1,lib/checkmemoryleak.cpp,CheckMemoryLeak.isReopenStandardStream<const>:bool(Token*),<empty>,,false,245,256,isReopenStandardStream,,,1,bool(Token*)
111669151677,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"bool CheckMemoryLeak::isOpenDevNull(const Token *tok) const
{
    if (mSettings_->hasLib(""posix"") && tok->str() == ""open"" && numberOfArguments(tok) == 2) {
        const Token* arg = getArguments(tok).at(0);
        if (Token::simpleMatch(arg, ""\\""/dev/null\\""""))
            return true;
    }
    return false;
}",1,1,lib/checkmemoryleak.cpp,CheckMemoryLeak.isOpenDevNull<const>:bool(Token*),<empty>,,false,258,266,isOpenDevNull,,,1,bool(Token*)
111669151678,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeak::memoryLeak(const Token *tok, const std::string &varname, AllocType alloctype) const
{
    if (alloctype == CheckMemoryLeak::File ||
        alloctype == CheckMemoryLeak::Pipe ||
        alloctype == CheckMemoryLeak::Fd ||
        alloctype == CheckMemoryLeak::OtherRes)
        resourceLeakError(tok, varname);
    else
        memleakError(tok, varname);
}",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeak.memoryLeak<const>:void(Token*,std.string&,CheckMemoryLeak.AllocType)",<empty>,,false,273,282,memoryLeak,,,1,"void(Token*,std.string&,CheckMemoryLeak.AllocType)"
111669151679,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeak::reportErr(const Token *tok, Severity severity, const std::string &id, const std::string &msg, const CWE &cwe) const
{
    std::list<const Token *> callstack;

    if (tok)
        callstack.push_back(tok);

    reportErr(callstack, severity, id, msg, cwe);
}",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeak.reportErr<const>:void(Token*,Severity,std.string&,std.string&,CWE&)",<empty>,,false,285,293,reportErr,,,1,"void(Token*,Severity,std.string&,std.string&,CWE&)"
111669151680,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeak::reportErr(const std::list<const Token *> &callstack, Severity severity, const std::string &id, const std::string &msg, const CWE &cwe) const
{
    const ErrorMessage errmsg(callstack, mTokenizer_ ? &mTokenizer_->list : nullptr, severity, id, msg, cwe, Certainty::normal);
    if (mErrorLogger_)
        mErrorLogger_->reportErr(errmsg);
    else
        Check::writeToErrorList(errmsg);
}",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeak.reportErr<const>:void(std.list<constToken*>&,Severity,std.string&,std.string&,CWE&)",<empty>,,false,295,302,reportErr,,,1,"void(std.list<constToken*>&,Severity,std.string&,std.string&,CWE&)"
111669151681,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeak::memleakError(const Token *tok, const std::string &varname) const
{
    reportErr(tok, Severity::error, ""memleak"", ""$symbol:"" + varname + ""\\nMemory leak: $symbol"", CWE(401U));
}",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeak.memleakError<const>:void(Token*,std.string&)",<empty>,,false,304,307,memleakError,,,1,"void(Token*,std.string&)"
111669151682,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeak::memleakUponReallocFailureError(const Token *tok, const std::string &reallocfunction, const std::string &varname) const
{
    reportErr(tok, Severity::error, ""memleakOnRealloc"", ""$symbol:"" + varname + ""\\nCommon "" + reallocfunction + "" mistake: \\'$symbol\\' nulled but not freed upon failure"", CWE(401U));
}",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeak.memleakUponReallocFailureError<const>:void(Token*,std.string&,std.string&)",<empty>,,false,309,312,memleakUponReallocFailureError,,,1,"void(Token*,std.string&,std.string&)"
111669151683,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeak::resourceLeakError(const Token *tok, const std::string &varname) const
{
    std::string errmsg(""Resource leak"");
    if (!varname.empty())
        errmsg = ""$symbol:"" + varname + '\\n' + errmsg + "": $symbol"";
    reportErr(tok, Severity::error, ""resourceLeak"", errmsg, CWE(775U));
}",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeak.resourceLeakError<const>:void(Token*,std.string&)",<empty>,,false,314,320,resourceLeakError,,,1,"void(Token*,std.string&)"
111669151684,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeak::deallocuseError(const Token *tok, const std::string &varname) const
{
    reportErr(tok, Severity::error, ""deallocuse"", ""$symbol:"" + varname + ""\\nDereferencing '$symbol' after it is deallocated / released"", CWE(416U));
}",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeak.deallocuseError<const>:void(Token*,std.string&)",<empty>,,false,322,325,deallocuseError,,,1,"void(Token*,std.string&)"
111669151685,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeak::mismatchAllocDealloc(const std::list<const Token *> &callstack, const std::string &varname) const
{
    reportErr(callstack, Severity::error, ""mismatchAllocDealloc"", ""$symbol:"" + varname + ""\\nMismatching allocation and deallocation: $symbol"", CWE(762U));
}",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeak.mismatchAllocDealloc<const>:void(std.list<constToken*>&,std.string&)",<empty>,,false,327,330,mismatchAllocDealloc,,,1,"void(std.list<constToken*>&,std.string&)"
111669151686,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"CheckMemoryLeak::AllocType CheckMemoryLeak::functionReturnType(const Function* func, std::list<const Function*> *callstack) const
{
    if (!func || !func->hasBody() || !func->functionScope)
        return No;

    // Get return pointer..
    const Variable* var = nullptr;
    for (const Token *tok2 = func->functionScope->bodyStart; tok2 != func->functionScope->bodyEnd; tok2 = tok2->next()) {
        if (const Token *endOfLambda = findLambdaEndToken(tok2))
            tok2 = endOfLambda;
        if (tok2->str() == ""{"" && !tok2->scope()->isExecutable())
            tok2 = tok2->link();
        if (tok2->str() == ""return"") {
            const AllocType allocType = getAllocationType(tok2->next(), 0, callstack);
            if (allocType != No)
                return allocType;

            if (tok2->scope() != func->functionScope || !tok2->astOperand1())
                return No;
            const Token* tok = tok2->astOperand1();
            if (Token::Match(tok, "".|::""))
           ...",1,4,lib/checkmemoryleak.cpp,"CheckMemoryLeak.functionReturnType<const>:CheckMemoryLeak.AllocType(Function*,std.list<constFunction*>*)",<empty>,,false,332,394,functionReturnType,,,1,"CheckMemoryLeak.AllocType(Function*,std.list<constFunction*>*)"
111669151687,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"static bool notvar(const Token *tok, nonneg int varid)
{
    if (!tok)
        return false;
    if (Token::Match(tok, ""&&|;""))
        return notvar(tok->astOperand1(),varid) || notvar(tok->astOperand2(),varid);
    if (tok->str() == ""("" && Token::Match(tok->astOperand1(), ""UNLIKELY|LIKELY""))
        return notvar(tok->astOperand2(), varid);
    const Token *vartok = astIsVariableComparison(tok, ""=="", ""0"");
    return vartok && (vartok->varId() == varid);
}",1,37,lib/checkmemoryleak.cpp,"notvar:bool(Token*,int)",<empty>,,false,397,407,notvar,,,1,"bool(Token*,int)"
111669151688,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"static bool ifvar(const Token *tok, nonneg int varid, const std::string &comp, const std::string &rhs)
{
    if (!Token::simpleMatch(tok, ""if (""))
        return false;
    const Token *condition = tok->next()->astOperand2();
    if (condition && condition->str() == ""("" && Token::Match(condition->astOperand1(), ""UNLIKELY|LIKELY""))
        condition = condition->astOperand2();
    if (!condition || condition->str() == ""&&"")
        return false;

    const Token *vartok = astIsVariableComparison(condition, comp, rhs);
    return (vartok && vartok->varId() == varid);
}",1,36,lib/checkmemoryleak.cpp,"ifvar:bool(Token*,int,std.string&,std.string&)",<empty>,,false,409,421,ifvar,,,1,"bool(Token*,int,std.string&,std.string&)"
111669151689,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakInFunction::checkReallocUsage()
{
    logChecker(""CheckMemoryLeakInFunction::checkReallocUsage"");

    // only check functions
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {

        // Search for the ""var = realloc(var, 100"" pattern within this function
        for (const Token *tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (tok->varId() > 0 && Token::Match(tok, ""%name% ="")) {
                // Get the parenthesis in ""realloc(""
                const Token* parTok = tok->next()->astOperand2();
                // Skip casts
                while (parTok && parTok->isCast())
                    parTok = parTok->astOperand1();
                if (!parTok)
                    continue;

                const Token *const reallocTok = parTok->astOperand1();
                if (!reallocTok)
                    continue;
           ...",1,1,lib/checkmemoryleak.cpp,CheckMemoryLeakInFunction.checkReallocUsage:void(),<empty>,,false,430,497,checkReallocUsage,,,1,void()
111669151690,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakInFunction::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    CheckMemoryLeakInFunction checkMemoryLeak(&tokenizer, &tokenizer.getSettings(), errorLogger);
    checkMemoryLeak.checkReallocUsage();
}",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeakInFunction.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,500,504,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669151691,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakInFunction::getErrorMessages(ErrorLogger *e, const Settings *settings) const
{
    CheckMemoryLeakInFunction c(nullptr, settings, e);
    c.memleakError(nullptr, ""varname"");
    c.resourceLeakError(nullptr, ""varname"");
    c.deallocuseError(nullptr, ""varname"");
    const std::list<const Token *> callstack;
    c.mismatchAllocDealloc(callstack, ""varname"");
    c.memleakUponReallocFailureError(nullptr, ""realloc"", ""varname"");
}",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeakInFunction.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,506,515,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669151692,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakInClass::check()
{
    logChecker(""CheckMemoryLeakInClass::check"");

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    // only check classes and structures
    for (const Scope * scope : symbolDatabase->classAndStructScopes) {
        for (const Variable &var : scope->varlist) {
            if (!var.isStatic() && (var.isPointer() || var.isPointerArray())) {
                // allocation but no deallocation of private variables in public function..
                const Token *tok = var.typeStartToken();
                // Either it is of standard type or a non-derived type
                if (tok->isStandardType() || (var.type() && var.type()->derivedFrom.empty())) {
                    if (var.isPrivate())
                        checkPublicFunctions(scope, var.nameToken());

                    variable(scope, var.nameToken());
                }
            }
        }
    }
}",1,1,lib/checkmemoryleak.cpp,CheckMemoryLeakInClass.check:void(),<empty>,,false,522,544,check,,,1,void()
111669151693,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakInClass::variable(const Scope *scope, const Token *tokVarname)
{
    const std::string& varname = tokVarname->str();
    const int varid = tokVarname->varId();
    const std::string& classname = scope->className;

    // Check if member variable has been allocated and deallocated..
    CheckMemoryLeak::AllocType memberAlloc = CheckMemoryLeak::No;
    CheckMemoryLeak::AllocType memberDealloc = CheckMemoryLeak::No;

    bool allocInConstructor = false;
    bool deallocInDestructor = false;

    // Inspect member functions
    for (const Function &func : scope->functionList) {
        const bool constructor = func.isConstructor();
        const bool destructor = func.isDestructor();
        if (!func.hasBody()) {
            if (destructor && !func.isDefault()) { // implementation for destructor is not seen and not defaulted => assume it deallocates all variables properly
                deallocInDestructor = true;
                memberDealloc = CheckMemoryLeak::Ma...",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeakInClass.variable:void(Scope*,Token*)",<empty>,,false,547,652,variable,,,1,"void(Scope*,Token*)"
111669151694,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakInClass::unsafeClassError(const Token *tok, const std::string &classname, const std::string &varname)
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""unsafeClassCanLeak""))
        return;

    reportError(tok, Severity::style, ""unsafeClassCanLeak"",
                ""$symbol:"" + classname + ""\\n""
                ""$symbol:"" + varname + ""\\n""
                ""Class '"" + classname + ""' is unsafe, '"" + varname + ""' can leak by wrong usage.\\n""
                ""The class '"" + classname + ""' is unsafe, wrong usage can cause memory/resource leaks for '"" + varname + ""'. This can for instance be fixed by adding proper cleanup in the destructor."", CWE398, Certainty::normal);
}",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeakInClass.unsafeClassError:void(Token*,std.string&,std.string&)",<empty>,,false,654,664,unsafeClassError,,,1,"void(Token*,std.string&,std.string&)"
111669151695,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakInClass::checkPublicFunctions(const Scope *scope, const Token *classtok)
{
    // Check that public functions deallocate the pointers that they allocate.
    // There is no checking how these functions are used and therefore it
    // isn't established if there is real leaks or not.
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    const int varid = classtok->varId();

    // Parse public functions..
    // If they allocate member variables, they should also deallocate
    for (const Function &func : scope->functionList) {
        if ((func.type == FunctionType::eFunction || func.type == FunctionType::eOperatorEqual) &&
            func.access == AccessControl::Public && func.hasBody()) {
            const Token *tok2 = func.functionScope->bodyStart->next();
            if (Token::Match(tok2, ""%varid% ="", varid)) {
                const CheckMemoryLeak::AllocType alloc = getAllocationType(tok2->tokAt(2), varid);
                if (a...",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeakInClass.checkPublicFunctions:void(Scope*,Token*)",<empty>,,false,667,695,checkPublicFunctions,,,1,"void(Scope*,Token*)"
111669151696,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakInClass::publicAllocationError(const Token *tok, const std::string &varname)
{
    reportError(tok, Severity::warning, ""publicAllocationError"", ""$symbol:"" + varname + ""\\nPossible leak in public function. The pointer '$symbol' is not deallocated before it is allocated."", CWE398, Certainty::normal);
}",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeakInClass.publicAllocationError:void(Token*,std.string&)",<empty>,,false,697,700,publicAllocationError,,,1,"void(Token*,std.string&)"
111669151697,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakInClass::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    if (!tokenizer.isCPP())
        return;

    CheckMemoryLeakInClass checkMemoryLeak(&tokenizer, &tokenizer.getSettings(), errorLogger);
    checkMemoryLeak.check();
}",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeakInClass.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,702,709,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669151698,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakInClass::getErrorMessages(ErrorLogger *e, const Settings *settings) const
{
    CheckMemoryLeakInClass c(nullptr, settings, e);
    c.publicAllocationError(nullptr, ""varname"");
    c.unsafeClassError(nullptr, ""class"", ""class::varname"");
}",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeakInClass.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,711,716,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669151699,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakStructMember::check()
{
    if (mSettings->clang)
        return;

    logChecker(""CheckMemoryLeakStructMember::check"");

    const SymbolDatabase* symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Variable* var : symbolDatabase->variableList()) {
        if (!var || (!var->isLocal() && !(var->isArgument() && var->scope())) || var->isStatic())
            continue;
        if (var->isReference() || (var->valueType() && var->valueType()->pointer > 1))
            continue;
        if (var->typeEndToken()->isStandardType())
            continue;
        checkStructVariable(var);
    }
}",1,1,lib/checkmemoryleak.cpp,CheckMemoryLeakStructMember.check:void(),<empty>,,false,719,736,check,,,1,void()
111669151700,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"bool CheckMemoryLeakStructMember::isMalloc(const Variable *variable) const
{
    if (!variable)
        return false;
    const int declarationId(variable->declarationId());
    bool alloc = false;
    for (const Token *tok2 = variable->nameToken(); tok2 && tok2 != variable->scope()->bodyEnd; tok2 = tok2->next()) {
        if (Token::Match(tok2, ""= %varid% [;=]"", declarationId))
            return false;
        if (Token::Match(tok2, ""%varid% = %name% ("", declarationId) && mSettings->library.getAllocFuncInfo(tok2->tokAt(2)))
            alloc = true;
    }
    return alloc;
}",1,1,lib/checkmemoryleak.cpp,CheckMemoryLeakStructMember.isMalloc<const>:bool(Variable*),<empty>,,false,738,751,isMalloc,,,1,bool(Variable*)
111669151701,METHOD,<empty>,<empty>,"[this](const Token* tok, int structid) -> bool {
        // Calling non-function / function that doesn't deallocate?
        if (tok->isKeyword() || mSettings->library.isLeakIgnore(tok->str()))
            return false;

        // Check if the struct is used..
        bool deallocated = false;
        const Token* const end = tok->linkAt(1);
        for (const Token* tok2 = tok; tok2 != end; tok2 = tok2->next()) {
            if (Token::Match(tok2, ""[(,] &| %varid% [,)]"", structid)) {
                /** @todo check if the function deallocates the memory */
                deallocated = true;
                break;
            }

            if (Token::Match(tok2, ""[(,] &| %varid% . %name% [,)]"", structid)) {
                /** @todo check if the function deallocates the memory */
                deallocated = true;
                break;
            }
        }

        return deallocated;
    }",30,5,lib/checkmemoryleak.cpp,"lib/checkmemoryleak.cpp:<global>.CheckMemoryLeakStructMember.checkStructVariable<const>.<lambda>0:bool(Token*,int)",<empty>,,false,770,793,<lambda>0,,,1,"bool(Token*,int)"
111669151702,METHOD,<empty>,<empty>,"[](const Token* varTok, int varId) -> std::pair<const Token*, const Token*> {
        if (varTok->varId() != varId)
            return {};
        const Token* top = varTok;
        while (top->astParent()) {
            if (Token::Match(top->astParent(), ""(|[""))
                return {};
            top = top->astParent();
        }
        if (!Token::simpleMatch(top, ""="") || !precedes(varTok, top))
            return {};
        const Token* dot = top->astOperand1();
        while (dot && dot->str() != ""."")
            dot = dot->astOperand1();
        if (!dot)
            return {};
        return { dot->astOperand2(), top->next() };
    }",31,5,lib/checkmemoryleak.cpp,"lib/checkmemoryleak.cpp:<global>.CheckMemoryLeakStructMember.checkStructVariable<const>.<lambda>1:pair<const Token*,const Token*>(Token*,int)",<empty>,,false,796,813,<lambda>1,,,1,"pair<const Token*,const Token*>(Token*,int)"
111669151703,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakStructMember::checkStructVariable(const Variable* const variable) const
{
    if (!variable)
        return;
    // Is struct variable a pointer?
    if (variable->isArrayOrPointer()) {
        // Check that variable is allocated with malloc
        if (!isMalloc(variable))
            return;
    } else if (!mTokenizer->isC() && (!variable->typeScope() || variable->typeScope()->getDestructor())) {
        // For non-C code a destructor might cleanup members
        return;
    }

    // Check struct..
    int indentlevel2 = 0;

    auto deallocInFunction = [this](const Token* tok, int structid) -> bool {
        // Calling non-function / function that doesn't deallocate?
        if (tok->isKeyword() || mSettings->library.isLeakIgnore(tok->str()))
            return false;

        // Check if the struct is used..
        bool deallocated = false;
        const Token* const end = tok->linkAt(1);
        for (const Token* tok2 = tok; tok2 != end; tok2 = tok2->next...",1,1,lib/checkmemoryleak.cpp,CheckMemoryLeakStructMember.checkStructVariable<const>:void(Variable*),<empty>,,false,753,963,checkStructVariable,,,1,void(Variable*)
111669151704,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakStructMember::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    CheckMemoryLeakStructMember checkMemoryLeak(&tokenizer, &tokenizer.getSettings(), errorLogger);
    checkMemoryLeak.check();
}",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeakStructMember.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,965,969,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669151705,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakStructMember::getErrorMessages(ErrorLogger * /*errorLogger*/, const Settings * /*settings*/) const
{}",1,2,lib/checkmemoryleak.cpp,"CheckMemoryLeakStructMember.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,971,972,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669151706,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakNoVar::check()
{
    logChecker(""CheckMemoryLeakNoVar::check"");

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    // only check functions
    for (const Scope * scope : symbolDatabase->functionScopes) {

        // Checks if a call to an allocation function like malloc() is made and its return value is not assigned.
        checkForUnusedReturnValue(scope);

        // Checks to see if a function is called with memory allocated for an argument that
        // could be leaked if a function called for another argument throws.
        checkForUnsafeArgAlloc(scope);

        // Check for leaks where a the return value of an allocation function like malloc() is an input argument,
        // for example f(malloc(1)), where f is known to not release the input argument.
        checkForUnreleasedInputArgument(scope);
    }
}",1,1,lib/checkmemoryleak.cpp,CheckMemoryLeakNoVar.check:void(),<empty>,,false,975,995,check,,,1,void()
111669151707,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakNoVar::checkForUnreleasedInputArgument(const Scope *scope)
{
    // parse the executable scope until tok is reached...
    for (const Token *tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
        // allocating memory in parameter for function call..
        if (tok->varId() || !Token::Match(tok, ""%name% (""))
            continue;

        // check if the output of the function is assigned
        const Token* tok2 = tok->next()->astParent();
        while (tok2 && (tok2->isCast() || Token::Match(tok2, ""?|:"")))
            tok2 = tok2->astParent();
        if (Token::Match(tok2, ""%assign%"")) // TODO: check if function returns allocated resource
            continue;
        if (Token::simpleMatch(tok->astTop(), ""return""))
            continue;

        const std::string& functionName = tok->str();
        if ((tok->isCpp() && functionName == ""delete"") ||
            functionName == ""return"")
            continue;

        if (Token::simpleMatc...",1,1,lib/checkmemoryleak.cpp,CheckMemoryLeakNoVar.checkForUnreleasedInputArgument:void(Scope*),<empty>,,false,1001,1069,checkForUnreleasedInputArgument,,,1,void(Scope*)
111669151708,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakNoVar::checkForUnusedReturnValue(const Scope *scope)
{
    for (const Token *tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
        const bool isNew = tok->isCpp() && tok->str() == ""new"";
        if (!isNew && !Token::Match(tok, ""%name% (""))
            continue;

        if (tok->varId())
            continue;

        const AllocType allocType = getAllocationType(tok, 0);
        if (allocType == No)
            continue;

        if (tok != tok->next()->astOperand1() && !isNew)
            continue;

        if (isReopenStandardStream(tok))
            continue;
        if (isOpenDevNull(tok))
            continue;

        // get ast parent, skip casts
        const Token *parent = isNew ? tok->astParent() : tok->next()->astParent();
        while (parent && parent->isCast())
            parent = parent->astParent();

        bool warn = true;
        if (isNew) {
            const Token* typeTok = tok->next();
            warn = typeTok ...",1,1,lib/checkmemoryleak.cpp,CheckMemoryLeakNoVar.checkForUnusedReturnValue:void(Scope*),<empty>,,false,1074,1123,checkForUnusedReturnValue,,,1,void(Scope*)
111669151709,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakNoVar::checkForUnsafeArgAlloc(const Scope *scope)
{
    // This test only applies to C++ source
    if (!mTokenizer->isCPP())
        return;

    if (!mSettings->isPremiumEnabled(""leakUnsafeArgAlloc"") && (!mSettings->certainty.isEnabled(Certainty::inconclusive) || !mSettings->severity.isEnabled(Severity::warning)))
        return;

    logChecker(""CheckMemoryLeakNoVar::checkForUnsafeArgAlloc"");

    for (const Token *tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
        if (Token::Match(tok, ""%name% ("")) {
            const Token *endParamToken = tok->linkAt(1);
            const Token* pointerType = nullptr;
            const Token* functionCalled = nullptr;

            // Scan through the arguments to the function call
            for (const Token *tok2 = tok->tokAt(2); tok2 && tok2 != endParamToken; tok2 = tok2->nextArgument()) {
                const Function *func = tok2->function();
                const bool isNothrow = func && (fun...",1,1,lib/checkmemoryleak.cpp,CheckMemoryLeakNoVar.checkForUnsafeArgAlloc:void(Scope*),<empty>,,false,1136,1184,checkForUnsafeArgAlloc,,,1,void(Scope*)
111669151710,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakNoVar::functionCallLeak(const Token *loc, const std::string &alloc, const std::string &functionCall)
{
    reportError(loc, Severity::error, ""leakNoVarFunctionCall"", ""Allocation with "" + alloc + "", "" + functionCall + "" doesn't release it."", CWE772, Certainty::normal);
}",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeakNoVar.functionCallLeak:void(Token*,std.string&,std.string&)",<empty>,,false,1186,1189,functionCallLeak,,,1,"void(Token*,std.string&,std.string&)"
111669151711,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakNoVar::returnValueNotUsedError(const Token *tok, const std::string &alloc)
{
    reportError(tok, Severity::error, ""leakReturnValNotUsed"", ""$symbol:"" + alloc + ""\\nReturn value of allocation function '$symbol' is not stored."", CWE771, Certainty::normal);
}",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeakNoVar.returnValueNotUsedError:void(Token*,std.string&)",<empty>,,false,1191,1194,returnValueNotUsedError,,,1,"void(Token*,std.string&)"
111669151712,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakNoVar::unsafeArgAllocError(const Token *tok, const std::string &funcName, const std::string &ptrType, const std::string& objType)
{
    const std::string factoryFunc = ptrType == ""shared_ptr"" ? ""make_shared"" : ""make_unique"";
    reportError(tok, Severity::warning, ""leakUnsafeArgAlloc"",
                ""$symbol:"" + funcName + ""\\n""
                ""Unsafe allocation. If $symbol() throws, memory could be leaked. Use "" + factoryFunc + ""<"" + objType + "">() instead."",
                CWE401,
                Certainty::inconclusive); // Inconclusive because funcName may never throw
}",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeakNoVar.unsafeArgAllocError:void(Token*,std.string&,std.string&,std.string&)",<empty>,,false,1196,1204,unsafeArgAllocError,,,1,"void(Token*,std.string&,std.string&,std.string&)"
111669151713,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakNoVar::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    CheckMemoryLeakNoVar checkMemoryLeak(&tokenizer, &tokenizer.getSettings(), errorLogger);
    checkMemoryLeak.check();
}",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeakNoVar.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,1206,1210,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669151714,METHOD,lib/checkmemoryleak.cpp:<global>,TYPE_DECL,"void CheckMemoryLeakNoVar::getErrorMessages(ErrorLogger *e, const Settings *settings) const
{
    CheckMemoryLeakNoVar c(nullptr, settings, e);
    c.functionCallLeak(nullptr, ""funcName"", ""funcName"");
    c.returnValueNotUsedError(nullptr, ""funcName"");
    c.unsafeArgAllocError(nullptr, ""funcName"", ""shared_ptr"", ""int"");
}",1,1,lib/checkmemoryleak.cpp,"CheckMemoryLeakNoVar.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,1212,1218,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669151715,METHOD,lib/checkmemoryleak.h:<global>,TYPE_DECL,<global>,1,1,lib/checkmemoryleak.h,lib/checkmemoryleak.h:<global>,<empty>,,false,1,333,<global>,,,1,
111669151716,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,"static bool checkNullpointerFunctionCallPlausibility(const Function* func, unsigned int arg)
{
    return !func || (func->argCount() >= arg && func->getArgumentVar(arg - 1) && func->getArgumentVar(arg - 1)->isPointer());
}",1,1,lib/checknullpointer.cpp,"checkNullpointerFunctionCallPlausibility:bool(Function*,unsigned int)",<empty>,,false,56,59,checkNullpointerFunctionCallPlausibility,,,1,"bool(Function*,unsigned int)"
111669151717,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,<global>,1,78,lib/checknullpointer.cpp,lib/checknullpointer.cpp:<global>,<empty>,,false,1,723,<global>,,,1,
111669151718,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,"void CheckNullPointer::parseFunctionCall(const Token &tok, std::list<const Token *> &var, const Library &library, bool checkNullArg)
{
    if (Token::Match(&tok, ""%name% ( )"") || !tok.tokAt(2))
        return;

    const std::vector<const Token *> args = getArguments(&tok);

    for (int argnr = 1; argnr <= args.size(); ++argnr) {
        const Token *param = args[argnr - 1];
        if ((!checkNullArg || library.isnullargbad(&tok, argnr)) && checkNullpointerFunctionCallPlausibility(tok.function(), argnr))
            var.push_back(param);
        else if (tok.function()) {
            const Variable* argVar = tok.function()->getArgumentVar(argnr-1);
            if (argVar && argVar->isStlStringType() && !argVar->isArrayOrPointer())
                var.push_back(param);
        }
    }

    if (library.formatstr_function(&tok)) {
        const int formatStringArgNr = library.formatstr_argno(&tok);
        if (formatStringArgNr < 0 || formatStringArgNr >= args.size())
            ret...",1,1,lib/checknullpointer.cpp,"CheckNullPointer.parseFunctionCall:void(Token&,std.list<constToken*>&,Library&,bool)",<empty>,,false,68,131,parseFunctionCall,,,1,"void(Token&,std.list<constToken*>&,Library&,bool)"
111669151719,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,"bool CheckNullPointer::isPointerDeRef(const Token *tok, bool &unknown) const
{
    return isPointerDeRef(tok, unknown, *mSettings);
}",1,1,lib/checknullpointer.cpp,"CheckNullPointer.isPointerDeRef<const>:bool(Token*,bool&)",<empty>,,false,150,153,isPointerDeRef,,,1,"bool(Token*,bool&)"
111669151720,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,"bool CheckNullPointer::isPointerDeRef(const Token *tok, bool &unknown, const Settings &settings, bool checkNullArg)
{
    unknown = false;

    // Is pointer used as function parameter?
    if (Token::Match(tok->previous(), ""[(,] %name% [,)]"")) {
        const Token *ftok = tok->previous();
        while (ftok && ftok->str() != ""("") {
            if (ftok->str() == "")"")
                ftok = ftok->link();
            ftok = ftok->previous();
        }
        if (ftok && ftok->previous()) {
            std::list<const Token *> varlist;
            parseFunctionCall(*ftok->previous(), varlist, settings.library, checkNullArg);
            if (std::find(varlist.cbegin(), varlist.cend(), tok) != varlist.cend()) {
                return true;
            }
        }
    }

    if (tok->str() == ""("" && !tok->scope()->isExecutable())
        return false;

    const Token* parent = tok->astParent();
    if (!parent)
        return false;
    const bool addressOf = parent->astParent() && p...",1,1,lib/checknullpointer.cpp,"CheckNullPointer.isPointerDeRef:bool(Token*,bool&,Settings&,bool)",<empty>,,false,155,264,isPointerDeRef,,,1,"bool(Token*,bool&,Settings&,bool)"
111669151721,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,"static bool isNullablePointer(const Token* tok)
{
    if (!tok)
        return false;
    if (Token::simpleMatch(tok, ""new"") && tok->varId() == 0)
        return false;
    if (astIsPointer(tok))
        return true;
    if (astIsSmartPointer(tok))
        return true;
    if (Token::simpleMatch(tok, "".""))
        return isNullablePointer(tok->astOperand2());
    if (const Variable* var = tok->variable()) {
        return (var->isPointer() || var->isSmartPointer());
    }
    return false;
}",1,1,lib/checknullpointer.cpp,isNullablePointer:bool(Token*),<empty>,,false,267,283,isNullablePointer,,,1,bool(Token*)
111669151722,METHOD,<empty>,<empty>,"[printInconclusive](const Token* tok) -> bool {
            if (!tok)
                return false;

            if (Token::Match(tok, ""%num%|%char%|%str%""))
                return false;

            if (!isNullablePointer(tok) ||
                (tok->str() == ""."" && isNullablePointer(tok->astOperand2()) && tok->astOperand2()->getValue(0))) // avoid duplicate warning
                return false;

            // Can pointer be NULL?
            const ValueFlow::Value *value = tok->getValue(0);
            if (!value)
                return false;

            if (!printInconclusive && value->isInconclusive())
                return false;

            return true;
        }",21,9,lib/checknullpointer.cpp,lib/checknullpointer.cpp:<global>.CheckNullPointer.nullPointerByDeRefAndCheck.<lambda>0:bool(Token*),<empty>,,false,291,311,<lambda>0,,,1,bool(Token*)
111669151723,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,"void CheckNullPointer::nullPointerByDeRefAndCheck()
{
    const bool printInconclusive = (mSettings->certainty.isEnabled(Certainty::inconclusive));

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        auto pred = [printInconclusive](const Token* tok) -> bool {
            if (!tok)
                return false;

            if (Token::Match(tok, ""%num%|%char%|%str%""))
                return false;

            if (!isNullablePointer(tok) ||
                (tok->str() == ""."" && isNullablePointer(tok->astOperand2()) && tok->astOperand2()->getValue(0))) // avoid duplicate warning
                return false;

            // Can pointer be NULL?
            const ValueFlow::Value *value = tok->getValue(0);
            if (!value)
                return false;

            if (!printInconclusive && value->isInconclusive())
                return false;

            return true;
        };
 ...",1,1,lib/checknullpointer.cpp,CheckNullPointer.nullPointerByDeRefAndCheck:void(),<empty>,,false,285,327,nullPointerByDeRefAndCheck,,,1,void()
111669151724,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,"void CheckNullPointer::nullPointer()
{
    logChecker(""CheckNullPointer::nullPointer"");
    nullPointerByDeRefAndCheck();
}",1,1,lib/checknullpointer.cpp,CheckNullPointer.nullPointer:void(),<empty>,,false,329,333,nullPointer,,,1,void()
111669151725,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,"void CheckNullPointer::nullConstantDereference()
{
    logChecker(""CheckNullPointer::nullConstantDereference"");

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope * scope : symbolDatabase->functionScopes) {
        if (scope->function == nullptr || !scope->function->hasBody()) // We only look for functions with a body
            continue;

        const Token *tok = scope->bodyStart;

        if (scope->function->isConstructor())
            tok = scope->function->token; // Check initialization list

        for (; tok != scope->bodyEnd; tok = tok->next()) {
            if (isUnevaluated(tok))
                tok = tok->linkAt(1);

            else if (Token::simpleMatch(tok, ""* 0"")) {
                if (Token::Match(tok->previous(), ""return|throw|;|{|}|:|[|(|,"") || tok->previous()->isOp()) {
                    nullPointerError(tok);
                }
            }

            else if (Token::Match(tok, ""0 ["") && (tok->strAt(-1) !=...",1,1,lib/checknullpointer.cpp,CheckNullPointer.nullConstantDereference:void(),<empty>,,false,343,435,nullConstantDereference,,,1,void()
111669151726,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,"void CheckNullPointer::nullPointerError(const Token *tok)
{
    ValueFlow::Value v(0);
    v.setKnown();
    nullPointerError(tok, """", &v, false);
}",1,1,lib/checknullpointer.cpp,CheckNullPointer.nullPointerError:void(Token*),<empty>,,false,437,442,nullPointerError,,,1,void(Token*)
111669151727,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,"void CheckNullPointer::nullPointerError(const Token *tok, const std::string &varname, const ValueFlow::Value *value, bool inconclusive)
{
    const std::string errmsgcond(""$symbol:"" + varname + '\\n' + ValueFlow::eitherTheConditionIsRedundant(value ? value->condition : nullptr) + "" or there is possible null pointer dereference: $symbol."");
    const std::string errmsgdefarg(""$symbol:"" + varname + ""\\nPossible null pointer dereference if the default parameter value is used: $symbol"");

    if (!tok) {
        reportError(tok, Severity::error, ""nullPointer"", ""Null pointer dereference"", CWE_NULL_POINTER_DEREFERENCE, Certainty::normal);
        reportError(tok, Severity::warning, ""nullPointerDefaultArg"", errmsgdefarg, CWE_NULL_POINTER_DEREFERENCE, Certainty::normal);
        reportError(tok, Severity::warning, ""nullPointerRedundantCheck"", errmsgcond, CWE_NULL_POINTER_DEREFERENCE, Certainty::normal);
        reportError(tok, Severity::warning, ""nullPointerOutOfMemory"", ""Null pointer derefe...",1,1,lib/checknullpointer.cpp,"CheckNullPointer.nullPointerError:void(Token*,std.string&,ValueFlow.Value*,bool)",<empty>,,false,444,494,nullPointerError,,,1,"void(Token*,std.string&,ValueFlow.Value*,bool)"
111669151728,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,"void CheckNullPointer::arithmetic()
{
    logChecker(""CheckNullPointer::arithmetic"");
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!Token::Match(tok, ""-|+|+=|-=|++|--""))
                continue;
            const Token *pointerOperand;
            const Token *numericOperand;
            if (tok->astOperand1() && tok->astOperand1()->valueType() && tok->astOperand1()->valueType()->pointer != 0) {
                pointerOperand = tok->astOperand1();
                numericOperand = tok->astOperand2();
            } else if (tok->astOperand2() && tok->astOperand2()->valueType() && tok->astOperand2()->valueType()->pointer != 0) {
                pointerOperand = tok->astOperand2();
                numericOperand = tok->astOperand1();
            } else
                continu...",1,1,lib/checknullpointer.cpp,CheckNullPointer.arithmetic:void(),<empty>,,false,496,532,arithmetic,,,1,void()
111669151729,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,"static std::string arithmeticTypeString(const Token *tok)
{
    if (tok && tok->str()[0] == '-')
        return ""subtraction"";
    if (tok && tok->str()[0] == '+')
        return ""addition"";
    return ""arithmetic"";
}",1,1,lib/checknullpointer.cpp,arithmeticTypeString:string(Token*),<empty>,,false,534,541,arithmeticTypeString,,,1,string(Token*)
111669151730,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,"void CheckNullPointer::pointerArithmeticError(const Token* tok, const ValueFlow::Value *value, bool inconclusive)
{
    // cppcheck-suppress shadowFunction - TODO: fix this
    std::string arithmetic = arithmeticTypeString(tok);
    std::string errmsg;
    if (tok && tok->str()[0] == '-') {
        errmsg = ""Overflow in pointer arithmetic, NULL pointer is subtracted."";
    } else {
        errmsg = ""Pointer "" + arithmetic + "" with NULL pointer."";
    }

    std::string id = ""nullPointerArithmetic"";
    if (value && value->unknownFunctionReturn == ValueFlow::Value::UnknownFunctionReturn::outOfMemory) {
        errmsg = ""If memory allocation fails: "" + ((char)std::tolower(errmsg[0]) + errmsg.substr(1));
        id += ""OutOfMemory"";
    }
    else if (value && value->unknownFunctionReturn == ValueFlow::Value::UnknownFunctionReturn::outOfResources) {
        errmsg = ""If resource allocation fails: "" + ((char)std::tolower(errmsg[0]) + errmsg.substr(1));
        id += ""OutOfResources"";
  ...",1,1,lib/checknullpointer.cpp,"CheckNullPointer.pointerArithmeticError:void(Token*,ValueFlow.Value*,bool)",<empty>,,false,543,571,pointerArithmeticError,,,1,"void(Token*,ValueFlow.Value*,bool)"
111669151731,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,"void CheckNullPointer::redundantConditionWarning(const Token* tok, const ValueFlow::Value *value, const Token *condition, bool inconclusive)
{
    // cppcheck-suppress shadowFunction - TODO: fix this
    std::string arithmetic = arithmeticTypeString(tok);
    std::string errmsg;
    if (tok && tok->str()[0] == '-') {
        errmsg = ValueFlow::eitherTheConditionIsRedundant(condition) + "" or there is overflow in pointer "" + arithmetic + ""."";
    } else {
        errmsg = ValueFlow::eitherTheConditionIsRedundant(condition) + "" or there is pointer arithmetic with NULL pointer."";
    }
    const ErrorPath errorPath = getErrorPath(tok, value, ""Null pointer "" + arithmetic);
    reportError(errorPath,
                Severity::warning,
                ""nullPointerArithmeticRedundantCheck"",
                errmsg,
                CWE_INCORRECT_CALCULATION,
                inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checknullpointer.cpp,"CheckNullPointer.redundantConditionWarning:void(Token*,ValueFlow.Value*,Token*,bool)",<empty>,,false,573,590,redundantConditionWarning,,,1,"void(Token*,ValueFlow.Value*,Token*,bool)"
111669151732,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,"static bool isUnsafeUsage(const Settings &settings, const Token *vartok, CTU::FileInfo::Value *value)
{
    (void)value;
    bool unknown = false;
    return CheckNullPointer::isPointerDeRef(vartok, unknown, settings);
}",1,1,lib/checknullpointer.cpp,"isUnsafeUsage:bool(Settings&,Token*,CTU.FileInfo.Value*)",<empty>,,false,593,598,isUnsafeUsage,,,1,"bool(Settings&,Token*,CTU.FileInfo.Value*)"
111669151733,METHOD,MyFileInfo,TYPE_DECL,"std::string toString() const override
        {
            return CTU::toString(unsafeUsage);
        }",9,9,lib/checknullpointer.cpp,MyFileInfo.toString<const><duplicate>1:string(),<empty>,,false,616,619,toString,,,2,string()
111669151734,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,"Check::FileInfo *CheckNullPointer::getFileInfo(const Tokenizer &tokenizer, const Settings &settings) const
{
    const std::list<CTU::FileInfo::UnsafeUsage> &unsafeUsage = CTU::getUnsafeUsage(tokenizer, settings, isUnsafeUsage);
    if (unsafeUsage.empty())
        return nullptr;

    auto *fileInfo = new MyFileInfo(tokenizer.list.getFiles()[0]);
    fileInfo->unsafeUsage = unsafeUsage;
    return fileInfo;
}",1,1,lib/checknullpointer.cpp,"CheckNullPointer.getFileInfo<const>:Check.FileInfo*(Tokenizer&,Settings&)",<empty>,,false,623,632,getFileInfo,,,1,"Check.FileInfo*(Tokenizer&,Settings&)"
111669151735,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,"Check::FileInfo * CheckNullPointer::loadFileInfoFromXml(const tinyxml2::XMLElement *xmlElement) const
{
    const std::list<CTU::FileInfo::UnsafeUsage> &unsafeUsage = CTU::loadUnsafeUsageListFromXml(xmlElement);
    if (unsafeUsage.empty())
        return nullptr;

    auto *fileInfo = new MyFileInfo;
    fileInfo->unsafeUsage = unsafeUsage;
    return fileInfo;
}",1,1,lib/checknullpointer.cpp,CheckNullPointer.loadFileInfoFromXml<const>:Check.FileInfo*(tinyxml2.XMLElement*),<empty>,,false,634,643,loadFileInfoFromXml,,,1,Check.FileInfo*(tinyxml2.XMLElement*)
111669151736,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,"bool CheckNullPointer::analyseWholeProgram(const CTU::FileInfo &ctu, const std::list<Check::FileInfo*> &fileInfo, const Settings& settings, ErrorLogger &errorLogger)
{
    (void)settings;

    CheckNullPointer dummy(nullptr, &settings, &errorLogger);
    dummy.
    logChecker(""CheckNullPointer::analyseWholeProgram""); // unusedfunctions

    if (fileInfo.empty())
        return false;

    const std::map<std::string, std::list<const CTU::FileInfo::CallBase *>> callsMap = ctu.getCallsMap();

    bool foundErrors = false;

    for (const Check::FileInfo* fi1 : fileInfo) {
        const auto *fi = dynamic_cast<const MyFileInfo*>(fi1);
        if (!fi)
            continue;
        for (const CTU::FileInfo::UnsafeUsage &unsafeUsage : fi->unsafeUsage) {
            for (int warning = 0; warning <= 1; warning++) {
                if (warning == 1 && !settings.severity.isEnabled(Severity::warning))
                    break;

                ValueFlow::Value::UnknownFunctionReturn unknownFu...",1,1,lib/checknullpointer.cpp,"CheckNullPointer.analyseWholeProgram:bool(CTU.FileInfo&,std.list<Check.FileInfo*>&,Settings&,ErrorLogger&)",<empty>,,false,645,707,analyseWholeProgram,,,1,"bool(CTU.FileInfo&,std.list<Check.FileInfo*>&,Settings&,ErrorLogger&)"
111669151737,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,"void CheckNullPointer::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    CheckNullPointer checkNullPointer(&tokenizer, &tokenizer.getSettings(), errorLogger);
    checkNullPointer.nullPointer();
    checkNullPointer.arithmetic();
    checkNullPointer.nullConstantDereference();
}",1,1,lib/checknullpointer.cpp,"CheckNullPointer.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,709,715,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669151738,METHOD,lib/checknullpointer.cpp:<global>,TYPE_DECL,"void CheckNullPointer::getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const
{
    CheckNullPointer c(nullptr, settings, errorLogger);
    c.nullPointerError(nullptr, ""pointer"", nullptr, false);
    c.pointerArithmeticError(nullptr, nullptr, false);
    c.redundantConditionWarning(nullptr, nullptr, nullptr, false);
}",1,1,lib/checknullpointer.cpp,"CheckNullPointer.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,717,723,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669151739,METHOD,lib/checknullpointer.h:<global>,TYPE_DECL,<global>,1,1,lib/checknullpointer.h,lib/checknullpointer.h:<global>,<empty>,,false,1,131,<global>,,,1,
111669151740,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkCastIntToCharAndBack()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckOther::checkCastIntToCharAndBack""); // warning

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        std::map<int, std::string> vars;
        for (const Token* tok = scope->bodyStart->next(); tok && tok != scope->bodyEnd; tok = tok->next()) {
            // Quick check to see if any of the matches below have any chances
            if (!Token::Match(tok, ""%var%|EOF %comp%|=""))
                continue;
            if (Token::Match(tok, ""%var% = fclose|fflush|fputc|fputs|fscanf|getchar|getc|fgetc|putchar|putc|puts|scanf|sscanf|ungetc ("")) {
                const Variable *var = tok->variable();
                if (var && var->typeEndToken()->str() == ""char"" && !var->typeEndToken()->isSigned()) {
                    vars[tok->varId()] = tok->strAt(2...",1,1,lib/checkother.cpp,CheckOther.checkCastIntToCharAndBack:void(),<empty>,,false,86,134,checkCastIntToCharAndBack,,,1,void()
111669151741,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,<global>,1,78,lib/checkother.cpp,lib/checkother.cpp:<global>,<empty>,,false,1,4493,<global>,,,1,
111669151742,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkCastIntToCharAndBackError(const Token *tok, const std::string &strFunctionName)
{
    reportError(
        tok,
        Severity::warning,
        ""checkCastIntToCharAndBack"",
        ""$symbol:"" + strFunctionName + ""\\n""
        ""Storing $symbol() return value in char variable and then comparing with EOF.\\n""
        ""When saving $symbol() return value in char variable there is loss of precision. ""
        "" When $symbol() returns EOF this value is truncated. Comparing the char ""
        ""variable with EOF can have unexpected results. For instance a loop \\""while (EOF != (c = $symbol());\\"" ""
        ""loops forever on some compilers/platforms and on other compilers/platforms it will stop ""
        ""when the file contains a matching character."", CWE197, Certainty::normal
        );
}",1,1,lib/checkother.cpp,"CheckOther.checkCastIntToCharAndBackError:void(Token*,std.string&)",<empty>,,false,136,150,checkCastIntToCharAndBackError,,,1,"void(Token*,std.string&)"
111669151743,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::clarifyCalculation()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""clarifyCalculation""))
        return;

    logChecker(""CheckOther::clarifyCalculation""); // style

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            // ? operator where lhs is arithmetical expression
            if (tok->str() != ""?"" || !tok->astOperand1() || !tok->astOperand1()->isCalculation())
                continue;
            if (!tok->astOperand1()->isArithmeticalOp() && tok->astOperand1()->tokType() != Token::eBitOp)
                continue;

            // non-pointer calculation in lhs and pointer in rhs => no clarification is needed
            if (tok->astOperand1()->isBinaryOp() && Token::Match(tok->astOperand1(), ""%or%|&|%|*|/"") && tok->a...",1,1,lib/checkother.cpp,CheckOther.clarifyCalculation:void(),<empty>,,false,156,203,clarifyCalculation,,,1,void()
111669151744,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::clarifyCalculationError(const Token *tok, const std::string &op)
{
    // suspicious calculation
    const std::string calc(""'a"" + op + ""b?c:d'"");

    // recommended calculation #1
    const std::string s1(""'(a"" + op + ""b)?c:d'"");

    // recommended calculation #2
    const std::string s2(""'a"" + op + ""(b?c:d)'"");

    reportError(tok,
                Severity::style,
                ""clarifyCalculation"",
                ""Clarify calculation precedence for '"" + op + ""' and '?'.\\n""
                ""Suspicious calculation. Please use parentheses to clarify the code. ""
                ""The code '"" + calc + ""' should be written as either '"" + s1 + ""' or '"" + s2 + ""'."", CWE783, Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.clarifyCalculationError:void(Token*,std.string&)",<empty>,,false,205,222,clarifyCalculationError,,,1,"void(Token*,std.string&)"
111669151745,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::clarifyStatement()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckOther::clarifyStatement""); // warning

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart; tok && tok != scope->bodyEnd; tok = tok->next()) {
            if (tok->astOperand1() && Token::Match(tok, ""* %name%"")) {
                const Token *tok2 = tok->previous();

                while (tok2 && tok2->str() == ""*"")
                    tok2 = tok2->previous();

                if (tok2 && !tok2->astParent() && Token::Match(tok2, ""[{};]"")) {
                    tok2 = tok->astOperand1();
                    if (Token::Match(tok2, ""++|-- [;,]""))
                        clarifyStatementError(tok2);
                }
            }
        }
    }
}",1,1,lib/checkother.cpp,CheckOther.clarifyStatement:void(),<empty>,,false,227,251,clarifyStatement,,,1,void()
111669151746,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::clarifyStatementError(const Token *tok)
{
    reportError(tok, Severity::warning, ""clarifyStatement"", ""In expression like '*A++' the result of '*' is unused. Did you intend to write '(*A)++;'?\\n""
                ""A statement like '*A++;' might not do what you intended. Postfix 'operator++' is executed before 'operator*'. ""
                ""Thus, the dereference is meaningless. Did you intend to write '(*A)++;'?"", CWE783, Certainty::normal);
}",1,1,lib/checkother.cpp,CheckOther.clarifyStatementError:void(Token*),<empty>,,false,253,258,clarifyStatementError,,,1,void(Token*)
111669151747,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkSuspiciousSemicolon()
{
    if (!mSettings->certainty.isEnabled(Certainty::inconclusive) || !mSettings->severity.isEnabled(Severity::warning))
        return;

    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();

    logChecker(""CheckOther::checkSuspiciousSemicolon""); // warning,inconclusive

    // Look for ""if(); {}"", ""for(); {}"" or ""while(); {}""
    for (const Scope &scope : symbolDatabase->scopeList) {
        if (scope.type == ScopeType::eIf || scope.type == ScopeType::eElse || scope.type == ScopeType::eWhile || scope.type == ScopeType::eFor) {
            // Ensure the semicolon is at the same line number as the if/for/while statement
            // and the {..} block follows it without an extra empty line.
            if (Token::simpleMatch(scope.bodyStart, ""{ ; } {"") &&
                scope.bodyStart->previous()->linenr() == scope.bodyStart->tokAt(2)->linenr() &&
                scope.bodyStart->linenr()+1 >= scope.bodySta...",1,1,lib/checkother.cpp,CheckOther.checkSuspiciousSemicolon:void(),<empty>,,false,263,285,checkSuspiciousSemicolon,,,1,void()
111669151748,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::suspiciousSemicolonError(const Token* tok)
{
    reportError(tok, Severity::warning, ""suspiciousSemicolon"",
                ""Suspicious use of ; at the end of '"" + (tok ? tok->str() : std::string()) + ""' statement."", CWE398, Certainty::normal);
}",1,1,lib/checkother.cpp,CheckOther.suspiciousSemicolonError:void(Token*),<empty>,,false,287,291,suspiciousSemicolonError,,,1,void(Token*)
111669151749,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::warningOldStylePointerCast()
{
    // Only valid on C++ code
    if (!mTokenizer->isCPP())
        return;

    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""cstyleCast""))
        return;

    logChecker(""CheckOther::warningOldStylePointerCast""); // style,c++

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        const Token* tok;
        if (scope->function && scope->function->isConstructor())
            tok = scope->classDef;
        else
            tok = scope->bodyStart;
        for (; tok && tok != scope->bodyEnd; tok = tok->next()) {
            // Old style pointer casting..
            if (tok->str() != ""("")
                continue;
            const Token* castTok = tok->next();
            while (Token::Match(castTok, ""const|volatile|class|struct|union|%type%|::"")) {
                castTok = castTok->next();
            ...",1,1,lib/checkother.cpp,CheckOther.warningOldStylePointerCast:void(),<empty>,,false,297,357,warningOldStylePointerCast,,,1,void()
111669151750,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::cstyleCastError(const Token *tok, bool isPtr)
{
    const std::string type = isPtr ? ""pointer"" : ""reference"";
    reportError(tok, Severity::style, ""cstyleCast"",
                ""C-style "" + type + "" casting\\n""
                ""C-style "" + type + "" casting detected. C++ offers four different kinds of casts as replacements: ""
                ""static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to ""
                ""any of those automatically, thus it is considered safer if the programmer explicitly states ""
                ""which kind of cast is expected."", CWE398, Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.cstyleCastError:void(Token*,bool)",<empty>,,false,359,368,cstyleCastError,,,1,"void(Token*,bool)"
111669151751,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::suspiciousFloatingPointCast()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""suspiciousFloatingPointCast""))
        return;

    logChecker(""CheckOther::suspiciousFloatingPointCast""); // style

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        const Token* tok = scope->bodyStart;
        if (scope->function && scope->function->isConstructor())
            tok = scope->classDef;
        for (; tok && tok != scope->bodyEnd; tok = tok->next()) {

            if (!tok->isCast())
                continue;

            const ValueType* vt = tok->valueType();
            if (!vt || vt->pointer || vt->reference != Reference::None || (vt->type != ValueType::FLOAT && vt->type != ValueType::DOUBLE))
                continue;

            using VTT = std::vector<ValueType::Type>;
            const VTT sourceTypes = vt->type == ValueType:...",1,1,lib/checkother.cpp,CheckOther.suspiciousFloatingPointCast:void(),<empty>,,false,370,418,suspiciousFloatingPointCast,,,1,void()
111669151752,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::suspiciousFloatingPointCastError(const Token* tok)
{
    reportError(tok, Severity::style, ""suspiciousFloatingPointCast"",
                ""Floating-point cast causes loss of precision.\\n""
                ""If this cast is not intentional, remove it to avoid loss of precision"", CWE398, Certainty::normal);
}",1,1,lib/checkother.cpp,CheckOther.suspiciousFloatingPointCastError:void(Token*),<empty>,,false,420,425,suspiciousFloatingPointCastError,,,1,void(Token*)
111669151753,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::invalidPointerCast()
{
    if (!mSettings->severity.isEnabled(Severity::portability))
        return;

    logChecker(""CheckOther::invalidPointerCast""); // portability

    const bool printInconclusive = mSettings->certainty.isEnabled(Certainty::inconclusive);
    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            const Token* toTok = nullptr;
            const Token* fromTok = nullptr;
            // Find cast
            if (Token::Match(tok, ""( const|volatile| const|volatile| %type% %type%| const| * )"")) {
                toTok = tok;
                fromTok = tok->astOperand1();
            } else if (Token::simpleMatch(tok, ""reinterpret_cast <"") && tok->linkAt(1)) {
                toTok = tok->linkAt(1)->next();
                fromTok = toTok->astOperand2()...",1,1,lib/checkother.cpp,CheckOther.invalidPointerCast:void(),<empty>,,false,431,468,invalidPointerCast,,,1,void()
111669151754,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::invalidPointerCastError(const Token* tok, const std::string& from, const std::string& to, bool inconclusive, bool toIsInt)
{
    if (toIsInt) { // If we cast something to int*, this can be useful to play with its binary data representation
        reportError(tok, Severity::portability, ""invalidPointerCast"", ""Casting from "" + from + "" to "" + to + "" is not portable due to different binary data representations on different platforms."", CWE704, inconclusive ? Certainty::inconclusive : Certainty::normal);
    } else
        reportError(tok, Severity::portability, ""invalidPointerCast"", ""Casting between "" + from + "" and "" + to + "" which have an incompatible binary data representation."", CWE704, Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.invalidPointerCastError:void(Token*,std.string&,std.string&,bool,bool)",<empty>,,false,471,477,invalidPointerCastError,,,1,"void(Token*,std.string&,std.string&,bool,bool)"
111669151755,METHOD,<empty>,<empty>,"[&](const Token *rhs) {
                        if (Token::simpleMatch(rhs, ""{ 0 }""))
                            return ChildrenToVisit::none;
                        if (Token::Match(rhs, ""%str%|%num%|%name%"") && !rhs->varId())
                            return ChildrenToVisit::none;
                        if (Token::Match(rhs, "":: %name%"") && rhs->hasKnownIntValue())
                            return ChildrenToVisit::none;
                        if (rhs->isCast())
                            return ChildrenToVisit::op2;
                        trivial = false;
                        return ChildrenToVisit::done;
                    }",35,21,lib/checkother.cpp,lib/checkother.cpp:<global>.CheckOther.checkRedundantAssignment.<lambda>0:ChildrenToVisit(Token*),<empty>,,false,515,526,<lambda>0,,,1,ChildrenToVisit(Token*)
111669151756,METHOD,<empty>,<empty>,"[&](const Function& f) {
                            return f.name() == op;
                        }",82,25,lib/checkother.cpp,lib/checkother.cpp:<global>.CheckOther.checkRedundantAssignment.<lambda>1:bool(Function&),<empty>,,false,550,552,<lambda>1,,,1,bool(Function&)
111669151757,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkRedundantAssignment()
{
    if (!mSettings->severity.isEnabled(Severity::style) &&
        !mSettings->isPremiumEnabled(""redundantAssignment"") &&
        !mSettings->isPremiumEnabled(""redundantAssignInSwitch""))
        return;

    logChecker(""CheckOther::checkRedundantAssignment""); // style

    const SymbolDatabase* symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope *scope : symbolDatabase->functionScopes) {
        if (!scope->bodyStart)
            continue;
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (Token::simpleMatch(tok, ""] (""))
                // todo: handle lambdas
                break;
            if (Token::simpleMatch(tok, ""try {""))
                // todo: check try blocks
                tok = tok->linkAt(1);
            if ((tok->isAssignmentOp() || tok->tokType() == Token::eIncDecOp) && tok->astOperand1()) {
                if (tok->astParent())
    ...",1,1,lib/checkother.cpp,CheckOther.checkRedundantAssignment:void(),<empty>,,false,484,619,checkRedundantAssignment,,,1,void()
111669151758,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::redundantCopyError(const Token *tok1, const Token* tok2, const std::string& var)
{
    const std::list<const Token *> callstack = { tok1, tok2 };
    reportError(callstack, Severity::performance, ""redundantCopy"",
                ""$symbol:"" + var + ""\\n""
                ""Buffer '$symbol' is being written before its old content has been used."", CWE563, Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.redundantCopyError:void(Token*,Token*,std.string&)",<empty>,,false,621,627,redundantCopyError,,,1,"void(Token*,Token*,std.string&)"
111669151759,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::redundantAssignmentError(const Token *tok1, const Token* tok2, const std::string& var, bool inconclusive)
{
    const ErrorPath errorPath = { ErrorPathItem(tok1, var + "" is assigned""), ErrorPathItem(tok2, var + "" is overwritten"") };
    if (inconclusive)
        reportError(errorPath, Severity::style, ""redundantAssignment"",
                    ""$symbol:"" + var + ""\\n""
                    ""Variable '$symbol' is reassigned a value before the old one has been used if variable is no semaphore variable.\\n""
                    ""Variable '$symbol' is reassigned a value before the old one has been used. Make sure that this variable is not used like a semaphore in a threading environment before simplifying this code."", CWE563, Certainty::inconclusive);
    else
        reportError(errorPath, Severity::style, ""redundantAssignment"",
                    ""$symbol:"" + var + ""\\n""
                    ""Variable '$symbol' is reassigned a value before the old one has been used."", CWE56...",1,1,lib/checkother.cpp,"CheckOther.redundantAssignmentError:void(Token*,Token*,std.string&,bool)",<empty>,,false,629,641,redundantAssignmentError,,,1,"void(Token*,Token*,std.string&,bool)"
111669151760,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::redundantInitializationError(const Token *tok1, const Token* tok2, const std::string& var, bool inconclusive)
{
    const ErrorPath errorPath = { ErrorPathItem(tok1, var + "" is initialized""), ErrorPathItem(tok2, var + "" is overwritten"") };
    reportError(errorPath, Severity::style, ""redundantInitialization"",
                ""$symbol:"" + var + ""\\nRedundant initialization for '$symbol'. The initialized value is overwritten before it is read."",
                CWE563,
                inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.redundantInitializationError:void(Token*,Token*,std.string&,bool)",<empty>,,false,643,650,redundantInitializationError,,,1,"void(Token*,Token*,std.string&,bool)"
111669151761,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::redundantAssignmentInSwitchError(const Token *tok1, const Token* tok2, const std::string &var)
{
    const ErrorPath errorPath = { ErrorPathItem(tok1, ""$symbol is assigned""), ErrorPathItem(tok2, ""$symbol is overwritten"") };
    reportError(errorPath, Severity::style, ""redundantAssignInSwitch"",
                ""$symbol:"" + var + ""\\n""
                ""Variable '$symbol' is reassigned a value before the old one has been used. 'break;' missing?"", CWE563, Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.redundantAssignmentInSwitchError:void(Token*,Token*,std.string&)",<empty>,,false,652,658,redundantAssignmentInSwitchError,,,1,"void(Token*,Token*,std.string&)"
111669151762,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::redundantAssignmentSameValueError(const Token *tok, const ValueFlow::Value* val, const std::string &var)
{
    auto errorPath = val->errorPath;
    errorPath.emplace_back(tok, """");
    reportError(errorPath, Severity::style, ""redundantAssignment"",
                ""$symbol:"" + var + ""\\n""
                ""Variable '$symbol' is assigned an expression that holds the same value."", CWE563, Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.redundantAssignmentSameValueError:void(Token*,ValueFlow.Value*,std.string&)",<empty>,,false,660,667,redundantAssignmentSameValueError,,,1,"void(Token*,ValueFlow.Value*,std.string&)"
111669151763,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static inline bool isFunctionOrBreakPattern(const Token *tok)
{
    return Token::Match(tok, ""%name% ("") || Token::Match(tok, ""break|continue|return|exit|goto|throw"");
}",1,1,lib/checkother.cpp,isFunctionOrBreakPattern:bool(Token*),<empty>,,false,679,682,isFunctionOrBreakPattern,,,1,bool(Token*)
111669151764,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::redundantBitwiseOperationInSwitchError()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckOther::redundantBitwiseOperationInSwitch""); // warning

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    // Find the beginning of a switch. E.g.:
    //   switch (var) { ...
    for (const Scope &switchScope : symbolDatabase->scopeList) {
        if (switchScope.type != ScopeType::eSwitch || !switchScope.bodyStart)
            continue;

        // Check the contents of the switch statement
        std::map<int, const Token*> varsWithBitsSet;
        std::map<int, std::string> bitOperations;

        for (const Token *tok2 = switchScope.bodyStart->next(); tok2 != switchScope.bodyEnd; tok2 = tok2->next()) {
            if (tok2->str() == ""{"") {
                // Inside a conditional or loop. Don't mark variable accesses as being redundant. E.g.:
                //   case 3: b = 1;
                ...",1,1,lib/checkother.cpp,CheckOther.redundantBitwiseOperationInSwitchError:void(),<empty>,,false,684,799,redundantBitwiseOperationInSwitchError,,,1,void()
111669151765,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::redundantBitwiseOperationInSwitchError(const Token *tok, const std::string &varname)
{
    reportError(tok, Severity::style,
                ""redundantBitwiseOperationInSwitch"",
                ""$symbol:"" + varname + ""\\n""
                ""Redundant bitwise operation on '$symbol' in 'switch' statement. 'break;' missing?"");
}",1,1,lib/checkother.cpp,"CheckOther.redundantBitwiseOperationInSwitchError:void(Token*,std.string&)",<empty>,,false,801,807,redundantBitwiseOperationInSwitchError,,,1,"void(Token*,std.string&)"
111669151766,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkSuspiciousCaseInSwitch()
{
    if (!mSettings->certainty.isEnabled(Certainty::inconclusive) || !mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckOther::checkSuspiciousCaseInSwitch""); // warning,inconclusive

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope & scope : symbolDatabase->scopeList) {
        if (scope.type != ScopeType::eSwitch)
            continue;

        for (const Token* tok = scope.bodyStart->next(); tok != scope.bodyEnd; tok = tok->next()) {
            if (tok->str() == ""case"") {
                const Token* finding = nullptr;
                for (const Token* tok2 = tok->next(); tok2; tok2 = tok2->next()) {
                    if (tok2->str() == "":"")
                        break;
                    if (Token::Match(tok2, ""[;}{]""))
                        break;

                    if (tok2->str() == ""?"")
                        finding = nullptr;
    ...",1,1,lib/checkother.cpp,CheckOther.checkSuspiciousCaseInSwitch:void(),<empty>,,false,813,845,checkSuspiciousCaseInSwitch,,,1,void()
111669151767,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::suspiciousCaseInSwitchError(const Token* tok, const std::string& operatorString)
{
    reportError(tok, Severity::warning, ""suspiciousCase"",
                ""Found suspicious case label in switch(). Operator '"" + operatorString + ""' probably doesn't work as intended.\\n""
                ""Using an operator like '"" + operatorString + ""' in a case label is suspicious. Did you intend to use a bitwise operator, multiple case labels or if/else instead?"", CWE398, Certainty::inconclusive);
}",1,1,lib/checkother.cpp,"CheckOther.suspiciousCaseInSwitchError:void(Token*,std.string&)",<empty>,,false,847,852,suspiciousCaseInSwitchError,,,1,"void(Token*,std.string&)"
111669151768,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool isNestedInSwitch(const Scope* scope)
{
    while (scope) {
        if (scope->type == ScopeType::eSwitch)
            return true;
        if (scope->type == ScopeType::eUnconditional) {
            scope = scope->nestedIn;
            continue;
        }
        break;
    }
    return false;
}",1,1,lib/checkother.cpp,isNestedInSwitch:bool(Scope*),<empty>,,false,854,866,isNestedInSwitch,,,1,bool(Scope*)
111669151769,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool isVardeclInSwitch(const Token* tok)
{
    if (!tok)
        return false;
    if (!isNestedInSwitch(tok->scope()))
        return false;
    if (const Token* end = Token::findsimplematch(tok, "";"")) {
        for (const Token* tok2 = tok; tok2 != end; tok2 = tok2->next()) {
            if (tok2->isKeyword() && tok2->str() == ""case"")
                return false;
            if (tok2->variable() && tok2->variable()->nameToken() == tok2) {
                end = tok2->scope()->bodyEnd;
                for (const Token* tok3 = tok2; tok3 != end; tok3 = tok3->next()) {
                    if (tok3->isKeyword())
                        return tok3->str() == ""case"";
                }
                return false;
            }
        }
    }
    return false;
}",1,1,lib/checkother.cpp,isVardeclInSwitch:bool(Token*),<empty>,,false,868,889,isVardeclInSwitch,,,1,bool(Token*)
111669151770,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkUnreachableCode()
{
    // misra-c-2012-2.1
    // misra-c-2023-2.1
    // misra-cpp-2008-0-1-1
    // autosar
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""duplicateBreak"") && !mSettings->isPremiumEnabled(""unreachableCode""))
        return;

    logChecker(""CheckOther::checkUnreachableCode""); // style

    const bool printInconclusive = mSettings->certainty.isEnabled(Certainty::inconclusive);
    const SymbolDatabase* symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        if (scope->hasInlineOrLambdaFunction(nullptr, /*onlyInline*/ true))
            continue;
        for (const Token* tok = scope->bodyStart; tok && tok != scope->bodyEnd; tok = tok->next()) {
            const Token* secondBreak = nullptr;
            const Token* labelName = nullptr;
            if (tok->link() && Token::Match(tok, ""(|[|<""))
                tok = tok->link();
       ...",1,1,lib/checkother.cpp,CheckOther.checkUnreachableCode:void(),<empty>,,false,897,1015,checkUnreachableCode,,,1,void()
111669151771,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::duplicateBreakError(const Token *tok, bool inconclusive)
{
    reportError(tok, Severity::style, ""duplicateBreak"",
                ""Consecutive return, break, continue, goto or throw statements are unnecessary.\\n""
                ""Consecutive return, break, continue, goto or throw statements are unnecessary. ""
                ""The second statement can never be executed, and so should be removed."", CWE561, inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.duplicateBreakError:void(Token*,bool)",<empty>,,false,1017,1023,duplicateBreakError,,,1,"void(Token*,bool)"
111669151772,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::unreachableCodeError(const Token *tok, const Token* noreturn, bool inconclusive)
{
    std::string msg = ""Statements following "";
    if (noreturn && (noreturn->function() || mSettings->library.isnoreturn(noreturn)))
        msg += ""noreturn function '"" + noreturn->str() + ""()'"";
    else if (noreturn && noreturn->isKeyword())
        msg += ""'"" + noreturn->str() + ""'"";
    else
        msg += ""return, break, continue, goto or throw"";
    msg += "" will never be executed."";
    reportError(tok, Severity::style, ""unreachableCode"",
                msg, CWE561, inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.unreachableCodeError:void(Token*,Token*,bool)",<empty>,,false,1025,1037,unreachableCodeError,,,1,"void(Token*,Token*,bool)"
111669151773,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::redundantContinueError(const Token *tok)
{
    reportError(tok, Severity::style, ""redundantContinue"",
                ""'continue' is redundant since it is the last statement in a loop."", CWE561, Certainty::normal);
}",1,1,lib/checkother.cpp,CheckOther.redundantContinueError:void(Token*),<empty>,,false,1039,1043,redundantContinueError,,,1,void(Token*)
111669151774,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool isSimpleExpr(const Token* tok, const Variable* var, const Settings& settings) {
    if (!tok)
        return false;
    if (tok->isNumber() || tok->tokType() == Token::eString || tok->tokType() == Token::eChar || tok->isBoolean())
        return true;
    bool needsCheck = tok->varId() > 0;
    if (!needsCheck) {
        if (tok->isArithmeticalOp())
            return isSimpleExpr(tok->astOperand1(), var, settings) && (!tok->astOperand2() || isSimpleExpr(tok->astOperand2(), var, settings));
        const Token* ftok = tok->previous();
        if (Token::Match(ftok, ""%name% ("") &&
            ((ftok->function() && ftok->function()->isConst()) || settings.library.isFunctionConst(ftok->str(), /*pure*/ true)))
            needsCheck = true;
        else if (tok->str() == ""["") {
            needsCheck = tok->astOperand1() && tok->astOperand1()->varId() > 0;
            tok = tok->astOperand1();
        }
        else if (isLeafDot(tok->astOperand2())) {
            needsCheck...",1,1,lib/checkother.cpp,"isSimpleExpr:bool(Token*,Variable*,Settings&)",<empty>,,false,1045,1068,isSimpleExpr,,,1,"bool(Token*,Variable*,Settings&)"
111669151775,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkVariableScope()
{
    if (mSettings->clang)
        return;

    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""variableScope""))
        return;

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    // In C it is common practice to declare local variables at the
    // start of functions.
    if (mSettings->daca && mTokenizer->isC())
        return;

    logChecker(""CheckOther::checkVariableScope""); // style,notclang

    for (const Variable* var : symbolDatabase->variableList()) {
        if (!var || !var->isLocal() || var->isConst())
            continue;

        if (var->nameToken()->isExpandedMacro())
            continue;

        const bool isPtrOrRef = var->isPointer() || var->isReference();
        const bool isSimpleType = var->typeStartToken()->isStandardType() || var->typeStartToken()->isEnumType() || (var->typeStartToken()->isC() && var->type() && var->type()->isStructType());
      ...",1,1,lib/checkother.cpp,CheckOther.checkVariableScope:void(),<empty>,,false,1073,1185,checkVariableScope,,,1,void()
111669151776,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool mayDependOn(const ValueType *other, const ValueType *original)
{
    if (!other || !original)
        return false;

    // other must be pointer
    if (!other->pointer)
        return false;

    // must be same underlying type
    if (other->type != original->type)
        return false;

    const int otherPtr = other->pointer + (other->reference == Reference::LValue ? 1 : 0);
    const int originalPtr = original->pointer;

    if (otherPtr == originalPtr) {
        // if other is not const than original may be copied to other
        return !other->isConst(otherPtr);
    }

    // other may be reassigned to original
    return otherPtr > originalPtr;
}",1,1,lib/checkother.cpp,"mayDependOn:bool(ValueType*,ValueType*)",<empty>,,false,1188,1211,mayDependOn,,,1,"bool(ValueType*,ValueType*)"
111669151777,METHOD,<empty>,<empty>,"[&](const Token* tok2) {
                return tok2->varId() == var->declarationId();
            }",106,13,lib/checkother.cpp,lib/checkother.cpp:<global>.CheckOther.checkInnerScope<const>.<lambda>2:bool(Token*),<empty>,,false,1257,1259,<lambda>2,,,1,bool(Token*)
111669151778,METHOD,<empty>,<empty>,"[&](const Variable& other) {
                                return &other == argvar || !mayDependOn(other.valueType(), argvar->valueType());
                            }",80,29,lib/checkother.cpp,lib/checkother.cpp:<global>.CheckOther.checkInnerScope<const>.<lambda>3:bool(Variable&),<empty>,,false,1306,1308,<lambda>3,,,1,bool(Variable&)
111669151779,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"bool CheckOther::checkInnerScope(const Token *tok, const Variable* var, bool& used) const
{
    const Scope* scope = tok->next()->scope();
    bool loopVariable = scope->isLoopScope();
    bool noContinue = true;
    const Token* forHeadEnd = nullptr;
    const Token* end = tok->link();
    if (scope->type == ScopeType::eUnconditional && (tok->strAt(-1) == "")"" || tok->previous()->isName())) // Might be an unknown macro like BOOST_FOREACH
        loopVariable = true;

    if (scope->type == ScopeType::eDo) {
        end = end->linkAt(2);
    } else if (loopVariable && tok->strAt(-1) == "")"") {
        tok = tok->linkAt(-1); // Jump to opening ( of for/while statement
    } else if (scope->type == ScopeType::eSwitch) {
        for (const Scope* innerScope : scope->nestedList) {
            if (used) {
                bool used2 = false;
                if (!checkInnerScope(innerScope->bodyStart, var, used2) || used2) {
                    return false;
                }
            } e...",1,1,lib/checkother.cpp,"CheckOther.checkInnerScope<const>:bool(Token*,Variable*,bool&)",<empty>,,false,1213,1321,checkInnerScope,,,1,"bool(Token*,Variable*,bool&)"
111669151780,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::variableScopeError(const Token *tok, const std::string &varname)
{
    reportError(tok,
                Severity::style,
                ""variableScope"",
                ""$symbol:"" + varname + ""\\n""
                ""The scope of the variable '$symbol' can be reduced.\\n""
                ""The scope of the variable '$symbol' can be reduced. Warning: Be careful ""
                ""when fixing this message, especially when there are inner loops. Here is an ""
                ""example where cppcheck will write that the scope for 'i' can be reduced:\\n""
                ""void f(int x)\\n""
                ""{\\n""
                ""    int i = 0;\\n""
                ""    if (x) {\\n""
                ""        // it's safe to move 'int i = 0;' here\\n""
                ""        for (int n = 0; n < 10; ++n) {\\n""
                ""            // it is possible but not safe to move 'int i = 0;' here\\n""
                ""            do_something(&i);\\n""
                ""        }\\n""
            ...",1,1,lib/checkother.cpp,"CheckOther.variableScopeError:void(Token*,std.string&)",<empty>,,false,1323,1345,variableScopeError,,,1,"void(Token*,std.string&)"
111669151781,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkCommaSeparatedReturn()
{
    // This is experimental for now. See #5076
    if ((true) || !mSettings->severity.isEnabled(Severity::style)) // NOLINT(readability-simplify-boolean-expr)
        return;

    // logChecker

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (tok->str() == ""return"") {
            tok = tok->next();
            while (tok && tok->str() != "";"") {
                if (tok->link() && Token::Match(tok, ""[([{<]""))
                    tok = tok->link();

                if (!tok->isExpandedMacro() && tok->str() == "","" && tok->linenr() != tok->next()->linenr())
                    commaSeparatedReturnError(tok);

                tok = tok->next();
            }
            // bailout: missing semicolon (invalid code / bad tokenizer)
            if (!tok)
                break;
        }
    }
}",1,1,lib/checkother.cpp,CheckOther.checkCommaSeparatedReturn:void(),<empty>,,false,1350,1375,checkCommaSeparatedReturn,,,1,void()
111669151782,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::commaSeparatedReturnError(const Token *tok)
{
    reportError(tok,
                Severity::style,
                ""commaSeparatedReturn"",
                ""Comma is used in return statement. The comma can easily be misread as a ';'.\\n""
                ""Comma is used in return statement. When comma is used in a return statement it can ""
                ""easily be misread as a semicolon. For example in the code below the value ""
                ""of 'b' is returned if the condition is true, but it is easy to think that 'a+1' is ""
                ""returned:\\n""
                ""    if (x)\\n""
                ""        return a + 1,\\n""
                ""    b++;\\n""
                ""However it can be useful to use comma in macros. Cppcheck does not warn when such a ""
                ""macro is then used in a return statement, it is less likely such code is misunderstood."", CWE398, Certainty::normal);
}",1,1,lib/checkother.cpp,CheckOther.commaSeparatedReturnError:void(Token*),<empty>,,false,1377,1392,commaSeparatedReturnError,,,1,void(Token*)
111669151783,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool isLargeContainer(const Variable* var, const Settings* settings)
{
    const ValueType* vt = var->valueType();
    if (vt->container->size_templateArgNo < 0)
        return true;
    const std::size_t maxByValueSize = 2 * settings->platform.sizeof_pointer;
    if (var->dimensions().empty()) {
        if (vt->container->startPattern == ""std :: bitset <"") {
            if (const ValueFlow::Value* v = vt->containerTypeToken->getKnownValue(ValueFlow::Value::ValueType::INT))
                return v->intvalue / 8 > maxByValueSize;
        }
        return false;
    }
    const ValueType vtElem = ValueType::parseDecl(vt->containerTypeToken, *settings);
    const auto elemSize = std::max<std::size_t>(ValueFlow::getSizeOf(vtElem, *settings), 1);
    const auto arraySize = var->dimension(0) * elemSize;
    return arraySize > maxByValueSize;
}",1,1,lib/checkother.cpp,"isLargeContainer:bool(Variable*,Settings*)",<empty>,,false,1394,1411,isLargeContainer,,,1,"bool(Variable*,Settings*)"
111669151784,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkPassByReference()
{
    if (!mSettings->severity.isEnabled(Severity::performance) || mTokenizer->isC())
        return;

    logChecker(""CheckOther::checkPassByReference""); // performance,c++

    const SymbolDatabase * const symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Variable* var : symbolDatabase->variableList()) {
        if (!var || !var->isClass() || var->isPointer() || (var->isArray() && !var->isStlType()) || var->isReference() || var->isEnumType())
            continue;

        const bool isRangeBasedFor = astIsRangeBasedForDecl(var->nameToken());
        if (!var->isArgument() && !isRangeBasedFor)
            continue;

        if (!isRangeBasedFor && var->scope() && var->scope()->function->arg->link()->strAt(-1) == ""..."")
            continue; // references could not be used as va_start parameters (#5824)

        const Token * const varDeclEndToken = var->declEndToken();
        if ((varDeclEndToken && varDeclEndToken->isExtern...",1,1,lib/checkother.cpp,CheckOther.checkPassByReference:void(),<empty>,,false,1413,1475,checkPassByReference,,,1,void()
111669151785,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::passedByValueError(const Variable* var, bool inconclusive, bool isRangeBasedFor)
{
    std::string id = isRangeBasedFor ? ""iterateByValue"" : ""passedByValue"";
    const std::string action = isRangeBasedFor ? ""declared as"": ""passed by"";
    const std::string type = isRangeBasedFor ? ""Range variable"" : ""Function parameter"";
    std::string msg = ""$symbol:"" + (var ? var->name() : """") + ""\\n"" +
                      type + "" '$symbol' should be "" + action + "" const reference."";
    ErrorPath errorPath;
    if (var && var->scope() && var->scope()->function && var->scope()->function->functionPointerUsage) {
        id += ""Callback"";
        errorPath.emplace_front(var->scope()->function->functionPointerUsage, ""Function pointer used here."");
        msg += "" However it seems that '"" + var->scope()->function->name() + ""' is a callback function."";
    }
    if (var)
        errorPath.emplace_back(var->nameToken(), msg);
    if (isRangeBasedFor)
        msg += ""\\nVariable '$sym...",1,1,lib/checkother.cpp,"CheckOther.passedByValueError:void(Variable*,bool,bool)",<empty>,,false,1477,1497,passedByValueError,,,1,"void(Variable*,bool,bool)"
111669151786,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool isVariableMutableInInitializer(const Token* start, const Token * end, nonneg int varid)
{
    if (!start)
        return false;
    if (!end)
        return false;
    for (const Token *tok = start; tok != end; tok = tok->next()) {
        if (tok->varId() != varid)
            continue;
        if (tok->astParent()) {
            const Token * memberTok = tok->astParent()->previous();
            if (Token::Match(memberTok, ""%var% ("") && memberTok->variable()) {
                const Variable * memberVar = memberTok->variable();
                if (memberVar->isClass())
                    //TODO: check if the called constructor could live with a const variable
                    // pending that, assume the worst (that it can't)
                    return true;
                if (!memberVar->isReference())
                    continue;
                if (memberVar->isConst())
                    continue;
            }
        }
        return true;
    }
    return ...",1,82,lib/checkother.cpp,"isVariableMutableInInitializer:bool(Token*,Token*,int)",<empty>,,false,1499,1525,isVariableMutableInInitializer,,,1,"bool(Token*,Token*,int)"
111669151787,METHOD,<empty>,<empty>,"[&](const Token* retTok) {
                if (retTok->varId() == var->declarationId())
                    return true;
                while (retTok && retTok->isCast())
                    retTok = retTok->astOperand2();
                while (Token::simpleMatch(retTok, "".""))
                    retTok = retTok->astOperand2();
                if (Token::simpleMatch(retTok, ""&""))
                    retTok = retTok->astOperand1();
                return ValueFlow::hasLifetimeToken(getParentLifetime(retTok), var->nameToken(), *mSettings);
            }",63,13,lib/checkother.cpp,lib/checkother.cpp:<global>.CheckOther.checkConstVariable.<lambda>4:bool(Token*),<empty>,,false,1586,1596,<lambda>4,,,1,bool(Token*)
111669151788,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkConstVariable()
{
    if ((!mSettings->severity.isEnabled(Severity::style) || mTokenizer->isC()) && !mSettings->isPremiumEnabled(""constVariable""))
        return;

    logChecker(""CheckOther::checkConstVariable""); // style,c++

    const SymbolDatabase *const symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Variable *var : symbolDatabase->variableList()) {
        if (!var)
            continue;
        if (!var->isReference())
            continue;
        if (var->isRValueReference())
            continue;
        if (var->isPointer())
            continue;
        if (var->isConst())
            continue;
        const Scope* scope = var->scope();
        if (!scope)
            continue;
        const Function* function = scope->function;
        if (!function && !scope->isLocal())
            continue;
        if (function && var->isArgument()) {
            if (function->isImplicitlyVirtual() || function->templateDef)
                cont...",1,1,lib/checkother.cpp,CheckOther.checkConstVariable:void(),<empty>,,false,1527,1647,checkConstVariable,,,1,void()
111669151789,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static const Token* getVariableChangedStart(const Variable* p)
{
    if (p->isArgument())
        return p->scope()->bodyStart;
    const Token* start = p->nameToken()->next();
    if (start->isSplittedVarDeclEq())
        start = start->tokAt(3);
    return start;
}",1,1,lib/checkother.cpp,getVariableChangedStart:Token*(Variable*),<empty>,,false,1649,1657,getVariableChangedStart,,,1,Token*(Variable*)
111669151790,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool isConstPointerVariable(const Variable* p, const Settings& settings)
{
    const int indirect = p->isArray() ? p->dimensions().size() : 1;
    const Token* start = getVariableChangedStart(p);
    while (const Token* tok =
               findVariableChanged(start, p->scope()->bodyEnd, indirect, p->declarationId(), false, settings)) {
        if (p->isReference())
            return false;
        // Assigning a pointer through another pointer may still be const
        if (!Token::simpleMatch(tok->astParent(), ""=""))
            return false;
        if (!astIsLHS(tok))
            return false;
        start = tok->next();
    }
    return true;
}",1,1,lib/checkother.cpp,"isConstPointerVariable:bool(Variable*,Settings&)",<empty>,,false,1659,1675,isConstPointerVariable,,,1,"bool(Variable*,Settings&)"
111669151791,METHOD,CompareVariables,TYPE_DECL,"bool operator()(const Variable* a, const Variable* b) const {
            const int fileA = a->nameToken()->fileIndex();
            const int fileB = b->nameToken()->fileIndex();
            if (fileA != fileB)
                return fileA < fileB;
            const int lineA = a->nameToken()->linenr();
            const int lineB = b->nameToken()->linenr();
            if (lineA != lineB)
                return lineA < lineB;
            const int columnA = a->nameToken()->column();
            const int columnB = b->nameToken()->column();
            return columnA < columnB;
        }",9,9,lib/checkother.cpp,"CompareVariables.()<const>:bool(Variable*,Variable*)",<empty>,,false,1679,1691,(),,,1,"bool(Variable*,Variable*)"
111669151792,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkConstPointer()
{
    if (!mSettings->severity.isEnabled(Severity::style) &&
        !mSettings->isPremiumEnabled(""constParameter"") &&
        !mSettings->isPremiumEnabled(""constParameterPointer"") &&
        !mSettings->isPremiumEnabled(""constParameterReference"") &&
        !mSettings->isPremiumEnabled(""constVariablePointer""))
        return;

    logChecker(""CheckOther::checkConstPointer""); // style

    std::set<const Variable*, CompareVariables> pointers, nonConstPointers;
    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        const Variable* const var = tok->variable();
        if (!var)
            continue;
        if (!var->isLocal() && !var->isArgument())
            continue;
        const Token* const nameTok = var->nameToken();
        if (tok == nameTok) {
            // declarations of (static) pointers are (not) split up, array declarations are never split up
            if (var->isLocal() && (!var->isStatic() || Token:...",1,1,lib/checkother.cpp,CheckOther.checkConstPointer:void(),<empty>,,false,1695,1851,checkConstPointer,,,1,void()
111669151793,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::constVariableError(const Variable *var, const Function *function)
{
    if (!var) {
        reportError(nullptr, Severity::style, ""constParameter"", ""Parameter 'x' can be declared with const"");
        reportError(nullptr, Severity::style, ""constVariable"",  ""Variable 'x' can be declared with const"");
        reportError(nullptr, Severity::style, ""constParameterReference"", ""Parameter 'x' can be declared with const"");
        reportError(nullptr, Severity::style, ""constVariableReference"", ""Variable 'x' can be declared with const"");
        reportError(nullptr, Severity::style, ""constParameterPointer"", ""Parameter 'x' can be declared with const"");
        reportError(nullptr, Severity::style, ""constVariablePointer"", ""Variable 'x' can be declared with const"");
        reportError(nullptr, Severity::style, ""constParameterCallback"", ""Parameter 'x' can be declared with const, however it seems that 'f' is a callback function."");
        return;
    }

    const std::string va...",1,1,lib/checkother.cpp,"CheckOther.constVariableError:void(Variable*,Function*)",<empty>,,false,1853,1885,constVariableError,,,1,"void(Variable*,Function*)"
111669151794,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkCharVariable()
{
    const bool warning = mSettings->severity.isEnabled(Severity::warning);
    const bool portability = mSettings->severity.isEnabled(Severity::portability);
    if (!warning && !portability)
        return;

    logChecker(""CheckOther::checkCharVariable""); // warning,portability

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
            if (Token::Match(tok, ""%var% ["")) {
                if (!tok->variable())
                    continue;
                if (!tok->variable()->isArray() && !tok->variable()->isPointer())
                    continue;
                const Token *index = tok->next()->astOperand2();
                if (warning && tok->variable()->isArray() && astIsSignedChar(index) && index->getValueGE(0x80, *mSettings))
                    sign...",1,1,lib/checkother.cpp,CheckOther.checkCharVariable:void(),<empty>,,false,1891,1940,checkCharVariable,,,1,void()
111669151795,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::signedCharArrayIndexError(const Token *tok)
{
    reportError(tok,
                Severity::warning,
                ""signedCharArrayIndex"",
                ""Signed 'char' type used as array index.\\n""
                ""Signed 'char' type used as array index. If the value ""
                ""can be greater than 127 there will be a buffer underflow ""
                ""because of sign extension."", CWE128, Certainty::normal);
}",1,1,lib/checkother.cpp,CheckOther.signedCharArrayIndexError:void(Token*),<empty>,,false,1942,1951,signedCharArrayIndexError,,,1,void(Token*)
111669151796,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::unknownSignCharArrayIndexError(const Token *tok)
{
    reportError(tok,
                Severity::portability,
                ""unknownSignCharArrayIndex"",
                ""'char' type used as array index.\\n""
                ""'char' type used as array index. Values greater than 127 will be ""
                ""treated depending on whether 'char' is signed or unsigned on target platform."", CWE758, Certainty::normal);
}",1,1,lib/checkother.cpp,CheckOther.unknownSignCharArrayIndexError:void(Token*),<empty>,,false,1953,1961,unknownSignCharArrayIndexError,,,1,void(Token*)
111669151797,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::charBitOpError(const Token *tok)
{
    reportError(tok,
                Severity::warning,
                ""charBitOp"",
                ""When using 'char' variables in bit operations, sign extension can generate unexpected results.\\n""
                ""When using 'char' variables in bit operations, sign extension can generate unexpected results. For example:\\n""
                ""    char c = 0x80;\\n""
                ""    int i = 0 | c;\\n""
                ""    if (i & 0x8000)\\n""
                ""        printf(\\""not expected\\"");\\n""
                ""The \\""not expected\\"" will be printed on the screen."", CWE398, Certainty::normal);
}",1,1,lib/checkother.cpp,CheckOther.charBitOpError:void(Token*),<empty>,,false,1963,1975,charBitOpError,,,1,void(Token*)
111669151798,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool isType(const Token * tok, bool unknown)
{
    if (tok && (tok->isStandardType() || (!tok->isKeyword() && Token::Match(tok, ""%type%"")) || tok->str() == ""auto""))
        return true;
    if (tok && tok->varId())
        return false;
    if (Token::simpleMatch(tok, ""::""))
        return isType(tok->astOperand2(), unknown);
    if (Token::simpleMatch(tok, ""<"") && tok->link())
        return true;
    if (unknown && Token::Match(tok, ""%name% !!(""))
        return true;
    return false;
}",1,1,lib/checkother.cpp,"isType:bool(Token*,bool)",<empty>,,false,1981,1994,isType,,,1,"bool(Token*,bool)"
111669151799,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool isVarDeclOp(const Token* tok)
{
    if (!tok)
        return false;
    const Token * vartok = tok->astOperand2();
    if (vartok && vartok->variable() && vartok->variable()->nameToken() == vartok)
        return true;
    const Token * typetok = tok->astOperand1();
    return isType(typetok, vartok && vartok->varId() != 0);
}",1,1,lib/checkother.cpp,isVarDeclOp:bool(Token*),<empty>,,false,1996,2005,isVarDeclOp,,,1,bool(Token*)
111669151800,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool isBracketAccess(const Token* tok)
{
    if (!Token::simpleMatch(tok, ""["") || !tok->astOperand1())
        return false;
    tok = tok->astOperand1();
    if (tok->str() == ""."")
        tok = tok->astOperand2();
    while (Token::simpleMatch(tok, ""[""))
        tok = tok->astOperand1();
    if (!tok || !tok->variable())
        return false;
    return tok->variable()->nameToken() != tok;
}",1,1,lib/checkother.cpp,isBracketAccess:bool(Token*),<empty>,,false,2007,2019,isBracketAccess,,,1,bool(Token*)
111669151801,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool isConstant(const Token* tok) {
    return tok && (tok->isEnumerator() || Token::Match(tok, ""%bool%|%num%|%str%|%char%|nullptr|NULL""));
}",1,1,lib/checkother.cpp,isConstant:bool(Token*),<empty>,,false,2021,2023,isConstant,,,1,bool(Token*)
111669151802,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool isConstStatement(const Token *tok, bool isNestedBracket = false)
{
    if (!tok)
        return false;
    if (tok->isExpandedMacro())
        return false;
    if (tok->varId() != 0)
        return true;
    if (isConstant(tok))
        return true;
    if (Token::Match(tok, ""*|&|&&"") &&
        (Token::Match(tok->previous(), ""::|.|const|volatile|restrict"") || isVarDeclOp(tok)))
        return false;
    if (Token::Match(tok, ""<<|>>"") && !astIsIntegral(tok, false))
        return false;
    const Token* tok2 = tok;
    while (tok2) {
        if (Token::simpleMatch(tok2->astOperand1(), ""delete""))
            return false;
        tok2 = tok2->astParent();
    }
    if (Token::Match(tok, ""&&|%oror%""))
        return isConstStatement(tok->astOperand1()) && isConstStatement(tok->astOperand2());
    if (Token::Match(tok, ""!|~|%cop%"") && (tok->astOperand1() || tok->astOperand2()))
        return true;
    if (Token::simpleMatch(tok->previous(), ""sizeof (""))
        return tru...",1,1,lib/checkother.cpp,"isConstStatement:bool(Token*,bool)",<empty>,,false,2025,2087,isConstStatement,,,1,"bool(Token*,bool)"
111669151803,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool isVoidStmt(const Token *tok)
{
    if (Token::simpleMatch(tok, ""( void""))
        return true;
    if (isCPPCast(tok) && tok->astOperand1() && Token::Match(tok->astOperand1()->next(), ""< void *| >""))
        return true;
    const Token *tok2 = tok;
    while (tok2->astOperand1())
        tok2 = tok2->astOperand1();
    if (Token::simpleMatch(tok2->previous(), "")"") && Token::simpleMatch(tok2->linkAt(-1), ""( void""))
        return true;
    if (Token::simpleMatch(tok2, ""( void""))
        return true;
    return Token::Match(tok2->previous(), ""delete|throw|return"");
}",1,1,lib/checkother.cpp,isVoidStmt:bool(Token*),<empty>,,false,2089,2103,isVoidStmt,,,1,bool(Token*)
111669151804,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool isConstTop(const Token *tok)
{
    if (!tok)
        return false;
    if (!tok->astParent())
        return true;
    if (Token::simpleMatch(tok->astParent(), "";"") &&
        Token::Match(tok->astTop()->previous(), ""for|if ("") && Token::simpleMatch(tok->astTop()->astOperand2(), "";"")) {
        if (Token::simpleMatch(tok->astParent()->astParent(), "";""))
            return tok->astParent()->astOperand2() == tok;
        return tok->astParent()->astOperand1() == tok;
    }
    if (Token::simpleMatch(tok, ""["")) {
        const Token* bracTok = tok;
        while (Token::simpleMatch(bracTok->astParent(), ""[""))
            bracTok = bracTok->astParent();
        if (!bracTok->astParent())
            return true;
    }
    if (tok->str() == "","" && tok->astParent()->isAssignmentOp())
        return true;
    return false;
}",1,1,lib/checkother.cpp,isConstTop:bool(Token*),<empty>,,false,2105,2127,isConstTop,,,1,bool(Token*)
111669151805,METHOD,<empty>,<empty>,"[&warn](const Token *child) {
                if (Token::Match(child, ""%oror%|&&""))
                    return ChildrenToVisit::op1_and_op2;
                if (child->isAssignmentOp())
                    return ChildrenToVisit::none;
                if (child->tokType() == Token::Type::eIncDecOp)
                    return ChildrenToVisit::none;
                if (Token::Match(child->previous(), ""%name% (""))
                    return ChildrenToVisit::none;
                warn = true;
                return ChildrenToVisit::done;
            }",32,13,lib/checkother.cpp,lib/checkother.cpp:<global>.CheckOther.checkIncompleteStatement.<lambda>5:ChildrenToVisit(Token*),<empty>,,false,2150,2161,<lambda>5,,,1,ChildrenToVisit(Token*)
111669151806,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkIncompleteStatement()
{
    if (!mSettings->severity.isEnabled(Severity::warning) &&
        !mSettings->isPremiumEnabled(""constStatement""))
        return;

    logChecker(""CheckOther::checkIncompleteStatement""); // warning

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        const Scope *scope = tok->scope();
        if (scope && !scope->isExecutable())
            continue;
        if (!isConstTop(tok))
            continue;
        if (tok->str() == "","" && Token::simpleMatch(tok->astTop()->previous(), ""for (""))
            continue;

        // Do not warn for statement when both lhs and rhs has side effects:
        //   dostuff() || x=213;
        if (Token::Match(tok, ""%oror%|&&"")) {
            bool warn = false;
            visitAstNodes(tok, [&warn](const Token *child) {
                if (Token::Match(child, ""%oror%|&&""))
                    return ChildrenToVisit::op1_and_op2;
                if (child->isAssignmentO...",1,1,lib/checkother.cpp,CheckOther.checkIncompleteStatement:void(),<empty>,,false,2129,2188,checkIncompleteStatement,,,1,void()
111669151807,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::constStatementError(const Token *tok, const std::string &type, bool inconclusive)
{
    const Token *valueTok = tok;
    while (valueTok && valueTok->isCast())
        valueTok = valueTok->astOperand2() ? valueTok->astOperand2() : valueTok->astOperand1();

    std::string msg;
    if (Token::simpleMatch(tok, ""==""))
        msg = ""Found suspicious equality comparison. Did you intend to assign a value instead?"";
    else if (Token::Match(tok, "",|!|~|%cop%""))
        msg = ""Found suspicious operator '"" + tok->str() + ""', result is not used."";
    else if (Token::Match(tok, ""%var%""))
        msg = ""Unused variable value '"" + tok->str() + ""'"";
    else if (isConstant(valueTok)) {
        std::string typeStr(""string"");
        if (valueTok->isNumber())
            typeStr = ""numeric"";
        else if (valueTok->isBoolean())
            typeStr = ""bool"";
        else if (valueTok->tokType() == Token::eChar)
            typeStr = ""character"";
        else if (isNullOperand(...",1,1,lib/checkother.cpp,"CheckOther.constStatementError:void(Token*,std.string&,bool)",<empty>,,false,2190,2236,constStatementError,,,1,"void(Token*,std.string&,bool)"
111669151808,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkZeroDivision()
{
    logChecker(""CheckOther::checkZeroDivision"");

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (!tok->astOperand2() || !tok->astOperand1())
            continue;
        if (tok->str() != ""%"" && tok->str() != ""/"" && tok->str() != ""%="" && tok->str() != ""/="")
            continue;
        if (!tok->valueType() || !tok->valueType()->isIntegral())
            continue;
        if (tok->scope() && tok->scope()->type == ScopeType::eEnum) // don't warn for compile-time error
            continue;

        // Value flow..
        const ValueFlow::Value *value = tok->astOperand2()->getValue(0LL);
        if (value && mSettings->isEnabled(value, false))
            zerodivError(tok, value);
    }
}",1,1,lib/checkother.cpp,CheckOther.checkZeroDivision:void(),<empty>,,false,2241,2260,checkZeroDivision,,,1,void()
111669151809,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::zerodivError(const Token *tok, const ValueFlow::Value *value)
{
    if (!tok && !value) {
        reportError(tok, Severity::error, ""zerodiv"", ""Division by zero."", CWE369, Certainty::normal);
        reportError(tok, Severity::warning, ""zerodivcond"", ValueFlow::eitherTheConditionIsRedundant(nullptr) + "" or there is division by zero."", CWE369, Certainty::normal);
        return;
    }

    const ErrorPath errorPath = getErrorPath(tok, value, ""Division by zero"");

    std::ostringstream errmsg;
    if (value->condition) {
        const int line = tok ? tok->linenr() : 0;
        errmsg << ValueFlow::eitherTheConditionIsRedundant(value->condition)
               << "" or there is division by zero at line "" << line << ""."";
    } else
        errmsg << ""Division by zero."";

    reportError(errorPath,
                value->errorSeverity() ? Severity::error : Severity::warning,
                value->condition ? ""zerodivcond"" : ""zerodiv"",
                errmsg.str(), CWE3...",1,1,lib/checkother.cpp,"CheckOther.zerodivError:void(Token*,ValueFlow.Value*)",<empty>,,false,2262,2284,zerodivError,,,1,"void(Token*,ValueFlow.Value*)"
111669151810,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkNanInArithmeticExpression()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""nanInArithmeticExpression""))
        return;
    logChecker(""CheckOther::checkNanInArithmeticExpression""); // style
    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (tok->str() != ""/"")
            continue;
        if (!Token::Match(tok->astParent(), ""[+-]""))
            continue;
        if (Token::simpleMatch(tok->astOperand2(), ""0.0""))
            nanInArithmeticExpressionError(tok);
    }
}",1,1,lib/checkother.cpp,CheckOther.checkNanInArithmeticExpression:void(),<empty>,,false,2291,2304,checkNanInArithmeticExpression,,,1,void()
111669151811,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::nanInArithmeticExpressionError(const Token *tok)
{
    reportError(tok, Severity::style, ""nanInArithmeticExpression"",
                ""Using NaN/Inf in a computation.\\n""
                ""Using NaN/Inf in a computation. ""
                ""Although nothing bad really happens, it is suspicious."", CWE369, Certainty::normal);
}",1,1,lib/checkother.cpp,CheckOther.nanInArithmeticExpressionError:void(Token*),<empty>,,false,2306,2312,nanInArithmeticExpressionError,,,1,void(Token*)
111669151812,METHOD,<empty>,<empty>,"[](const Token* tok, std::string& typeStr) -> const Token* {
        if (!Token::Match(tok, ""[;{}] %name%"") || tok->next()->isKeyword())
            return nullptr;
        tok = tok->next();
        typeStr.clear();
        while (Token::Match(tok, ""%name% ::"")) {
            typeStr += tok->str();
            typeStr += ""::"";
            tok = tok->tokAt(2);
        }
        typeStr += tok->str();
        const Token* endTok = tok;
        if (Token::Match(endTok, ""%name% <""))
            endTok = endTok->linkAt(1);
        if (Token::Match(endTok, ""%name%|> (|{"") && Token::Match(endTok->linkAt(1), "")|} ;"") &&
            !Token::simpleMatch(endTok->next()->astParent(), "";"")) { // for loop condition
            return tok;
        }
        return nullptr;
    }",30,5,lib/checkother.cpp,"lib/checkother.cpp:<global>.CheckOther.checkMisusedScopedObject.<lambda>6:Token(Token*,std.string&)",<empty>,,false,2328,2347,<lambda>6,,,1,"Token(Token*,std.string&)"
111669151813,METHOD,<empty>,<empty>,"[&](const Token* tok, const std::string& typeStr) -> bool {
        const Library::TypeCheck typeCheck = mSettings->library.getTypeCheck(""unusedvar"", typeStr);
        if (typeCheck == Library::TypeCheck::check || typeCheck == Library::TypeCheck::checkFiniteLifetime)
            return true;
        return mSettings->library.detectContainerOrIterator(tok);
    }",33,5,lib/checkother.cpp,"lib/checkother.cpp:<global>.CheckOther.checkMisusedScopedObject.<lambda>7:bool(Token*,std.string&)",<empty>,,false,2349,2354,<lambda>7,,,1,"bool(Token*,std.string&)"
111669151814,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkMisusedScopedObject()
{
    // Skip this check for .c files
    if (mTokenizer->isC())
        return;

    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""unusedScopedObject""))
        return;

    logChecker(""CheckOther::checkMisusedScopedObject""); // style,c++

    auto getConstructorTok = [](const Token* tok, std::string& typeStr) -> const Token* {
        if (!Token::Match(tok, ""[;{}] %name%"") || tok->next()->isKeyword())
            return nullptr;
        tok = tok->next();
        typeStr.clear();
        while (Token::Match(tok, ""%name% ::"")) {
            typeStr += tok->str();
            typeStr += ""::"";
            tok = tok->tokAt(2);
        }
        typeStr += tok->str();
        const Token* endTok = tok;
        if (Token::Match(endTok, ""%name% <""))
            endTok = endTok->linkAt(1);
        if (Token::Match(endTok, ""%name%|> (|{"") && Token::Match(endTok->linkAt(1), "")|} ;"") &&
            !Token::sim...",1,1,lib/checkother.cpp,CheckOther.checkMisusedScopedObject:void(),<empty>,,false,2317,2390,checkMisusedScopedObject,,,1,void()
111669151815,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::misusedScopeObjectError(const Token *tok, const std::string& varname, bool isAssignment)
{
    std::string msg = ""Instance of '$symbol' object is destroyed immediately"";
    msg += isAssignment ? "", assignment has no effect."" : ""."";
    reportError(tok, Severity::style,
                ""unusedScopedObject"",
                ""$symbol:"" + varname + ""\\n"" +
                msg, CWE563, Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.misusedScopeObjectError:void(Token*,std.string&,bool)",<empty>,,false,2392,2400,misusedScopeObjectError,,,1,"void(Token*,std.string&,bool)"
111669151816,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static const Token * getSingleExpressionInBlock(const Token * tok)
{
    if (!tok)
        return nullptr;
    const Token * top = tok->astTop();
    const Token * nextExpression = nextAfterAstRightmostLeaf(top);
    if (!Token::simpleMatch(nextExpression, ""; }""))
        return nullptr;
    return top;
}",1,1,lib/checkother.cpp,getSingleExpressionInBlock:Token*(Token*),<empty>,,false,2402,2411,getSingleExpressionInBlock,,,1,Token*(Token*)
111669151817,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkDuplicateBranch()
{
    // This is inconclusive since in practice most warnings are noise:
    // * There can be unfixed low-priority todos. The code is fine as it
    //   is but it could be possible to enhance it. Writing a warning
    //   here is noise since the code is fine (see cppcheck, abiword, ..)
    // * There can be overspecified code so some conditions can't be true
    //   and their conditional code is a duplicate of the condition that
    //   is always true just in case it would be false. See for instance
    //   abiword.
    if (!mSettings->severity.isEnabled(Severity::style) || !mSettings->certainty.isEnabled(Certainty::inconclusive))
        return;

    logChecker(""CheckOther::checkDuplicateBranch""); // style,inconclusive

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope & scope : symbolDatabase->scopeList) {
        if (scope.type != ScopeType::eIf)
            continue;

        // check a...",1,1,lib/checkother.cpp,CheckOther.checkDuplicateBranch:void(),<empty>,,false,2417,2494,checkDuplicateBranch,,,1,void()
111669151818,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::duplicateBranchError(const Token *tok1, const Token *tok2, ErrorPath errors)
{
    errors.emplace_back(tok2, """");
    errors.emplace_back(tok1, """");

    reportError(errors, Severity::style, ""duplicateBranch"", ""Found duplicate branches for 'if' and 'else'.\\n""
                ""Finding the same code in an 'if' and related 'else' branch is suspicious and ""
                ""might indicate a cut and paste or logic error. Please examine this code ""
                ""carefully to determine if it is correct."", CWE398, Certainty::inconclusive);
}",1,1,lib/checkother.cpp,"CheckOther.duplicateBranchError:void(Token*,Token*,ErrorPath)",<empty>,,false,2496,2505,duplicateBranchError,,,1,"void(Token*,Token*,ErrorPath)"
111669151819,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkInvalidFree()
{
    std::map<int, bool> inconclusive;
    std::map<int, std::string> allocation;

    logChecker(""CheckOther::checkInvalidFree"");

    const bool printInconclusive = mSettings->certainty.isEnabled(Certainty::inconclusive);
    const SymbolDatabase* symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok && tok != scope->bodyEnd; tok = tok->next()) {

            // Keep track of which variables were assigned addresses to newly-allocated memory
            if ((tok->isCpp() && Token::Match(tok, ""%var% = new"")) ||
                (Token::Match(tok, ""%var% = %name% ("") && mSettings->library.getAllocFuncInfo(tok->tokAt(2)))) {
                allocation.emplace(tok->varId(), tok->strAt(2));
                inconclusive.emplace(tok->varId(), false);
            }

            // If a previously-allocated pointer is incremented or d...",1,1,lib/checkother.cpp,CheckOther.checkInvalidFree:void(),<empty>,,false,2513,2585,checkInvalidFree,,,1,void()
111669151820,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::invalidFreeError(const Token *tok, const std::string &allocation, bool inconclusive)
{
    std::string alloc = allocation;
    if (alloc != ""new"")
        alloc += ""()"";
    std::string deallocated = (alloc == ""new"") ? ""deleted"" : ""freed"";
    reportError(tok, Severity::error, ""invalidFree"", ""Mismatching address is "" + deallocated + "". The address you get from "" + alloc + "" must be "" + deallocated + "" without offset."", CWE(0U), inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.invalidFreeError:void(Token*,std.string&,bool)",<empty>,,false,2587,2594,invalidFreeError,,,1,"void(Token*,std.string&,bool)"
111669151821,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"bool notconst(const Function* func)
    {
        return !func->isConst();
    }",5,5,lib/checkother.cpp,notconst:bool(Function*),<empty>,,false,2604,2607,notconst,,,1,bool(Function*)
111669151822,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void getConstFunctions(const SymbolDatabase *symbolDatabase, std::list<const Function*> &constFunctions)
    {
        for (const Scope &scope : symbolDatabase->scopeList) {
            // only add const functions that do not have a non-const overloaded version
            // since it is pretty much impossible to tell which is being called.
            using StringFunctionMap = std::map<std::string, std::list<const Function*>>;
            StringFunctionMap functionsByName;
            for (const Function &func : scope.functionList) {
                functionsByName[func.tokenDef->str()].push_back(&func);
            }
            for (std::pair<const std::string, std::list<const Function*>>& it : functionsByName) {
                const auto nc = std::find_if(it.second.cbegin(), it.second.cend(), notconst);
                if (nc == it.second.cend()) {
                    // ok to add all of them
                    constFunctions.splice(constFunctions.end(), it.second);
          ...",5,5,lib/checkother.cpp,"getConstFunctions:void(SymbolDatabase*,std.list<constFunction*>&)",<empty>,,false,2609,2627,getConstFunctions,,,1,"void(SymbolDatabase*,std.list<constFunction*>&)"
111669151823,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool
isStaticAssert(const Settings &settings, const Token *tok)
{
    if (tok->isCpp() && settings.standards.cpp >= Standards::CPP11 &&
        Token::simpleMatch(tok, ""static_assert"")) {
        return true;
    }

    if (tok->isC() && settings.standards.c >= Standards::C11 &&
        Token::simpleMatch(tok, ""_Static_assert"")) {
        return true;
    }

    return false;
}",1,1,lib/checkother.cpp,"isStaticAssert:bool(Settings&,Token*)",<empty>,,false,2630,2644,isStaticAssert,,,1,"bool(Settings&,Token*)"
111669151824,METHOD,<empty>,<empty>,"[](const Token* tok) {
                const Token* parent = tok->astParent();
                while (Token::simpleMatch(parent, "",""))
                    parent = parent->astParent();
                return isLambdaCaptureList(parent);
            }",46,13,lib/checkother.cpp,lib/checkother.cpp:<global>.CheckOther.checkDuplicateExpression.<lambda>8:Token*(Token*),<empty>,,false,2738,2743,<lambda>8,,,1,Token*(Token*)
111669151825,METHOD,<empty>,<empty>,"[&](const Token* exp1, const Token* exp2, const Token* ast1) {
                            if (isSameExpression(true, exp1, exp2, *mSettings, true, true, &errorPath) &&
                                isWithoutSideEffects(exp1) &&
                                isWithoutSideEffects(ast1->astOperand2()))
                                duplicateExpressionError(exp1, exp2, tok, errorPath, /*hasMultipleExpr*/ true);
                        }",47,25,lib/checkother.cpp,"lib/checkother.cpp:<global>.CheckOther.checkDuplicateExpression.<lambda>9:void(Token*,Token*,Token*)",<empty>,,false,2811,2816,<lambda>9,,,1,"void(Token*,Token*,Token*)"
111669151826,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkDuplicateExpression()
{
    {
        const bool styleEnabled = mSettings->severity.isEnabled(Severity::style);
        const bool premiumEnabled = mSettings->isPremiumEnabled(""oppositeExpression"") ||
                                    mSettings->isPremiumEnabled(""duplicateExpression"") ||
                                    mSettings->isPremiumEnabled(""duplicateAssignExpression"") ||
                                    mSettings->isPremiumEnabled(""duplicateExpressionTernary"") ||
                                    mSettings->isPremiumEnabled(""duplicateValueTernary"") ||
                                    mSettings->isPremiumEnabled(""selfAssignment"") ||
                                    mSettings->isPremiumEnabled(""knownConditionTrueFalse"");

        if (!styleEnabled && !premiumEnabled)
            return;
    }

    logChecker(""CheckOther::checkDuplicateExpression""); // style,warning

    // Parse all executing scopes..
    const SymbolDatabase *symbolDataba...",1,1,lib/checkother.cpp,CheckOther.checkDuplicateExpression:void(),<empty>,,false,2646,2836,checkDuplicateExpression,,,1,void()
111669151827,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::oppositeExpressionError(const Token *opTok, ErrorPath errors)
{
    errors.emplace_back(opTok, """");

    const std::string& op = opTok ? opTok->str() : ""&&"";

    reportError(errors, Severity::style, ""oppositeExpression"", ""Opposite expression on both sides of \\'"" + op + ""\\'.\\n""
                ""Finding the opposite expression on both sides of an operator is suspicious and might ""
                ""indicate a cut and paste or logic error. Please examine this code carefully to ""
                ""determine if it is correct."", CWE398, Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.oppositeExpressionError:void(Token*,ErrorPath)",<empty>,,false,2838,2848,oppositeExpressionError,,,1,"void(Token*,ErrorPath)"
111669151828,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::duplicateExpressionError(const Token *tok1, const Token *tok2, const Token *opTok, ErrorPath errors, bool hasMultipleExpr)
{
    errors.emplace_back(opTok, """");

    const std::string& expr1 = tok1 ? tok1->expressionString() : ""x"";
    const std::string& expr2 = tok2 ? tok2->expressionString() : ""x"";

    const std::string& op = opTok ? opTok->str() : ""&&"";
    std::string msg = ""Same expression "" + (hasMultipleExpr ? ""\\'"" + expr1 + ""\\'"" + "" found multiple times in chain of \\'"" + op + ""\\' operators"" : ""on both sides of \\'"" + op + ""\\'"");
    const char *id = ""duplicateExpression"";
    if (expr1 != expr2 && (!opTok || Token::Match(opTok, ""%oror%|%comp%|&&|?|!""))) {
        id = ""knownConditionTrueFalse"";
        std::string exprMsg = ""The comparison \\'"" + expr1 + "" "" + op +  "" "" + expr2 + ""\\' is always "";
        if (Token::Match(opTok, ""==|>=|<=""))
            msg = exprMsg + ""true"";
        else if (Token::Match(opTok, ""!=|>|<""))
            msg = exprMsg + ""false"";...",1,1,lib/checkother.cpp,"CheckOther.duplicateExpressionError:void(Token*,Token*,Token*,ErrorPath,bool)",<empty>,,false,2850,2876,duplicateExpressionError,,,1,"void(Token*,Token*,Token*,ErrorPath,bool)"
111669151829,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::duplicateAssignExpressionError(const Token *tok1, const Token *tok2, bool inconclusive)
{
    const std::list<const Token *> toks = { tok2, tok1 };

    const std::string& var1 = tok1 ? tok1->str() : ""x"";
    const std::string& var2 = tok2 ? tok2->str() : ""x"";

    reportError(toks, Severity::style, ""duplicateAssignExpression"",
                ""Same expression used in consecutive assignments of '"" + var1 + ""' and '"" + var2 + ""'.\\n""
                ""Finding variables '"" + var1 + ""' and '"" + var2 + ""' that are assigned the same expression ""
                ""is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to ""
                ""determine if it is correct."", CWE398, inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.duplicateAssignExpressionError:void(Token*,Token*,bool)",<empty>,,false,2878,2890,duplicateAssignExpressionError,,,1,"void(Token*,Token*,bool)"
111669151830,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::duplicateExpressionTernaryError(const Token *tok, ErrorPath errors)
{
    errors.emplace_back(tok, """");
    reportError(errors, Severity::style, ""duplicateExpressionTernary"", ""Same expression in both branches of ternary operator.\\n""
                ""Finding the same expression in both branches of ternary operator is suspicious as ""
                ""the same code is executed regardless of the condition."", CWE398, Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.duplicateExpressionTernaryError:void(Token*,ErrorPath)",<empty>,,false,2892,2898,duplicateExpressionTernaryError,,,1,"void(Token*,ErrorPath)"
111669151831,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::duplicateValueTernaryError(const Token *tok)
{
    reportError(tok, Severity::style, ""duplicateValueTernary"", ""Same value in both branches of ternary operator.\\n""
                ""Finding the same value in both branches of ternary operator is suspicious as ""
                ""the same code is executed regardless of the condition."", CWE398, Certainty::normal);
}",1,1,lib/checkother.cpp,CheckOther.duplicateValueTernaryError:void(Token*),<empty>,,false,2900,2905,duplicateValueTernaryError,,,1,void(Token*)
111669151832,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::selfAssignmentError(const Token *tok, const std::string &varname)
{
    reportError(tok, Severity::style,
                ""selfAssignment"",
                ""$symbol:"" + varname + ""\\n""
                ""Redundant assignment of '$symbol' to itself."", CWE398, Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.selfAssignmentError:void(Token*,std.string&)",<empty>,,false,2907,2913,selfAssignmentError,,,1,"void(Token*,std.string&)"
111669151833,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkComparisonFunctionIsAlwaysTrueOrFalse()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckOther::checkComparisonFunctionIsAlwaysTrueOrFalse""); // warning

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (tok->isName() && Token::Match(tok, ""isgreater|isless|islessgreater|isgreaterequal|islessequal ( %var% , %var% )"")) {
                const int varidLeft = tok->tokAt(2)->varId();// get the left varid
                const int varidRight = tok->tokAt(4)->varId();// get the right varid
                // compare varids: if they are not zero but equal
                // --> the comparison function is called with the same variables
                if (varidLeft == varidRight) {
                    const std::st...",1,1,lib/checkother.cpp,CheckOther.checkComparisonFunctionIsAlwaysTrueOrFalse:void(),<empty>,,false,2924,2953,checkComparisonFunctionIsAlwaysTrueOrFalse,,,1,void()
111669151834,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkComparisonFunctionIsAlwaysTrueOrFalseError(const Token* tok, const std::string &functionName, const std::string &varName, const bool result)
{
    const std::string strResult = bool_to_string(result);
    const CWE cweResult = result ? CWE571 : CWE570;

    reportError(tok, Severity::warning, ""comparisonFunctionIsAlwaysTrueOrFalse"",
                ""$symbol:"" + functionName + ""\\n""
                ""Comparison of two identical variables with $symbol("" + varName + "","" + varName + "") always evaluates to "" + strResult + "".\\n""
                ""The function $symbol is designed to compare two variables. Calling this function with one variable ("" + varName + "") ""
                ""for both parameters leads to a statement which is always "" + strResult + ""."", cweResult, Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.checkComparisonFunctionIsAlwaysTrueOrFalseError:void(Token*,std.string&,std.string&,bool)",<empty>,,false,2954,2964,checkComparisonFunctionIsAlwaysTrueOrFalseError,,,1,"void(Token*,std.string&,std.string&,bool)"
111669151835,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkSignOfUnsignedVariable()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""unsignedLessThanZero""))
        return;

    logChecker(""CheckOther::checkSignOfUnsignedVariable""); // style

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope * scope : symbolDatabase->functionScopes) {
        // check all the code in the function
        for (const Token *tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            const ValueFlow::Value *zeroValue = nullptr;
            const Token *nonZeroExpr = nullptr;
            if (comparisonNonZeroExpressionLessThanZero(tok, zeroValue, nonZeroExpr)) {
                const ValueType* vt = nonZeroExpr->valueType();
                if (vt->pointer)
                    pointerLessThanZeroError(tok, zeroValue);
                else
                    unsignedLessThanZeroError(tok, zeroValue, nonZeroExpr->expressionS...",1,1,lib/checkother.cpp,CheckOther.checkSignOfUnsignedVariable:void(),<empty>,,false,2969,2998,checkSignOfUnsignedVariable,,,1,void()
111669151836,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"bool CheckOther::comparisonNonZeroExpressionLessThanZero(const Token *tok, const ValueFlow::Value *&zeroValue, const Token *&nonZeroExpr, bool suppress)
{
    if (!tok->isComparisonOp() || !tok->astOperand1() || !tok->astOperand2())
        return false;

    const ValueFlow::Value *v1 = tok->astOperand1()->getValue(0);
    const ValueFlow::Value *v2 = tok->astOperand2()->getValue(0);

    if (Token::Match(tok, ""<|<="") && v2 && v2->isKnown()) {
        zeroValue = v2;
        nonZeroExpr = tok->astOperand1();
    } else if (Token::Match(tok, "">|>="") && v1 && v1->isKnown()) {
        zeroValue = v1;
        nonZeroExpr = tok->astOperand2();
    } else {
        return false;
    }

    if (const Variable* var = nonZeroExpr->variable())
        if (var->typeStartToken()->isTemplateArg())
            return suppress;

    const ValueType* vt = nonZeroExpr->valueType();
    return vt && (vt->pointer || vt->sign == ValueType::UNSIGNED);
}",1,1,lib/checkother.cpp,"CheckOther.comparisonNonZeroExpressionLessThanZero:bool(Token*,ValueFlow.Value*&,Token*&,bool)",<empty>,,false,3000,3024,comparisonNonZeroExpressionLessThanZero,,,1,"bool(Token*,ValueFlow.Value*&,Token*&,bool)"
111669151837,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"bool CheckOther::testIfNonZeroExpressionIsPositive(const Token *tok, const ValueFlow::Value *&zeroValue, const Token *&nonZeroExpr)
{
    if (!tok->isComparisonOp() || !tok->astOperand1() || !tok->astOperand2())
        return false;

    const ValueFlow::Value *v1 = tok->astOperand1()->getValue(0);
    const ValueFlow::Value *v2 = tok->astOperand2()->getValue(0);

    if (Token::simpleMatch(tok, "">="") && v2 && v2->isKnown()) {
        zeroValue = v2;
        nonZeroExpr = tok->astOperand1();
    } else if (Token::simpleMatch(tok, ""<="") && v1 && v1->isKnown()) {
        zeroValue = v1;
        nonZeroExpr = tok->astOperand2();
    } else {
        return false;
    }

    const ValueType* vt = nonZeroExpr->valueType();
    return vt && (vt->pointer || vt->sign == ValueType::UNSIGNED);
}",1,1,lib/checkother.cpp,"CheckOther.testIfNonZeroExpressionIsPositive:bool(Token*,ValueFlow.Value*&,Token*&)",<empty>,,false,3026,3046,testIfNonZeroExpressionIsPositive,,,1,"bool(Token*,ValueFlow.Value*&,Token*&)"
111669151838,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::unsignedLessThanZeroError(const Token *tok, const ValueFlow::Value * v, const std::string &varname)
{
    reportError(getErrorPath(tok, v, ""Unsigned less than zero""), Severity::style, ""unsignedLessThanZero"",
                ""$symbol:"" + varname + ""\\n""
                ""Checking if unsigned expression '$symbol' is less than zero.\\n""
                ""The unsigned expression '$symbol' will never be negative so it ""
                ""is either pointless or an error to check if it is."", CWE570, Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.unsignedLessThanZeroError:void(Token*,ValueFlow.Value*,std.string&)",<empty>,,false,3048,3055,unsignedLessThanZeroError,,,1,"void(Token*,ValueFlow.Value*,std.string&)"
111669151839,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::pointerLessThanZeroError(const Token *tok, const ValueFlow::Value *v)
{
    reportError(getErrorPath(tok, v, ""Pointer less than zero""), Severity::style, ""pointerLessThanZero"",
                ""A pointer can not be negative so it is either pointless or an error to check if it is."", CWE570, Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.pointerLessThanZeroError:void(Token*,ValueFlow.Value*)",<empty>,,false,3057,3061,pointerLessThanZeroError,,,1,"void(Token*,ValueFlow.Value*)"
111669151840,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::unsignedPositiveError(const Token *tok, const ValueFlow::Value * v, const std::string &varname)
{
    reportError(getErrorPath(tok, v, ""Unsigned positive""), Severity::style, ""unsignedPositive"",
                ""$symbol:"" + varname + ""\\n""
                ""Unsigned expression '$symbol' can't be negative so it is unnecessary to test it."", CWE570, Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.unsignedPositiveError:void(Token*,ValueFlow.Value*,std.string&)",<empty>,,false,3063,3068,unsignedPositiveError,,,1,"void(Token*,ValueFlow.Value*,std.string&)"
111669151841,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::pointerPositiveError(const Token *tok, const ValueFlow::Value * v)
{
    reportError(getErrorPath(tok, v, ""Pointer positive""), Severity::style, ""pointerPositive"",
                ""A pointer can not be negative so it is either pointless or an error to check if it is not."", CWE570, Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.pointerPositiveError:void(Token*,ValueFlow.Value*)",<empty>,,false,3070,3074,pointerPositiveError,,,1,"void(Token*,ValueFlow.Value*)"
111669151842,METHOD,<empty>,<empty>,"[&](const Function& constructor) {
        if (constructor.isConstructor()) {
            for (int argnr = 0U; argnr < constructor.argCount(); argnr++) {
                const Variable * const argVar = constructor.getArgumentVar(argnr);
                if (argVar && argVar->isReference()) {
                    return true;
                }
            }
        }
        return false;
    }",90,5,lib/checkother.cpp,lib/checkother.cpp:<global>.constructorTakesReference.<lambda>10:bool(Function&),<empty>,,false,3079,3089,<lambda>10,,,1,bool(Function&)
111669151843,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool constructorTakesReference(const Scope * const classScope)
{
    return std::any_of(classScope->functionList.begin(), classScope->functionList.end(), [&](const Function& constructor) {
        if (constructor.isConstructor()) {
            for (int argnr = 0U; argnr < constructor.argCount(); argnr++) {
                const Variable * const argVar = constructor.getArgumentVar(argnr);
                if (argVar && argVar->isReference()) {
                    return true;
                }
            }
        }
        return false;
    });
}",1,1,lib/checkother.cpp,constructorTakesReference:bool(Scope*),<empty>,,false,3077,3090,constructorTakesReference,,,1,bool(Scope*)
111669151844,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkRedundantCopy()
{
    if (!mSettings->severity.isEnabled(Severity::performance) || mTokenizer->isC() || !mSettings->certainty.isEnabled(Certainty::inconclusive))
        return;

    logChecker(""CheckOther::checkRedundantCopy""); // c++,performance,inconclusive

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Variable* var : symbolDatabase->variableList()) {
        if (!var || var->isReference() || var->isPointer() ||
            (!var->type() && !var->isStlType() && !(var->valueType() && var->valueType()->container)) || // bailout if var is of standard type, if it is a pointer or non-const
            (!var->isConst() && isVariableChanged(var, *mSettings)))
            continue;

        const Token* startTok = var->nameToken();
        if (startTok->strAt(1) == ""="") // %type% %name% = ... ;
            ;
        else if (Token::Match(startTok->next(), ""(|{"") && var->isClass()) {
            if (!var->typeScope() && ...",1,1,lib/checkother.cpp,CheckOther.checkRedundantCopy:void(),<empty>,,false,3096,3157,checkRedundantCopy,,,1,void()
111669151845,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::redundantCopyError(const Token *tok,const std::string& varname)
{
    reportError(tok, Severity::performance, ""redundantCopyLocalConst"",
                ""$symbol:"" + varname + ""\\n""
                ""Use const reference for '$symbol' to avoid unnecessary data copying.\\n""
                ""The const variable '$symbol' is assigned a copy of the data. You can avoid ""
                ""the unnecessary data copying by converting '$symbol' to const reference."",
                CWE398,
                Certainty::inconclusive); // since #5618 that check became inconclusive
}",1,1,lib/checkother.cpp,"CheckOther.redundantCopyError:void(Token*,std.string&)",<empty>,,false,3159,3168,redundantCopyError,,,1,"void(Token*,std.string&)"
111669151846,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool isNegative(const Token *tok, const Settings &settings)
{
    return tok->valueType() && tok->valueType()->sign == ValueType::SIGNED && tok->getValueLE(-1LL, settings);
}",1,1,lib/checkother.cpp,"isNegative:bool(Token*,Settings&)",<empty>,,false,3174,3177,isNegative,,,1,"bool(Token*,Settings&)"
111669151847,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkNegativeBitwiseShift()
{
    const bool portability = mSettings->severity.isEnabled(Severity::portability);

    logChecker(""CheckOther::checkNegativeBitwiseShift"");

    for (const Token* tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        tok = skipUnreachableBranch(tok);

        if (!tok->astOperand1() || !tok->astOperand2())
            continue;

        if (!Token::Match(tok, ""<<|>>|<<=|>>=""))
            continue;

        // don't warn if lhs is a class. this is an overloaded operator then
        if (tok->isCpp()) {
            const ValueType * lhsType = tok->astOperand1()->valueType();
            if (!lhsType || !lhsType->isIntegral() || lhsType->pointer)
                continue;
        }

        // bailout if operation is protected by ?:
        bool ternary = false;
        for (const Token *parent = tok; parent; parent = parent->astParent()) {
            if (Token::Match(parent, ""?|:"")) {
                ternary = true;
           ...",1,1,lib/checkother.cpp,CheckOther.checkNegativeBitwiseShift:void(),<empty>,,false,3179,3218,checkNegativeBitwiseShift,,,1,void()
111669151848,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::negativeBitwiseShiftError(const Token *tok, int op)
{
    if (op == 1)
        // LHS - this is used by intention in various software, if it
        // is used often in a project and works as expected then this is
        // a portability issue
        reportError(tok, Severity::portability, ""shiftNegativeLHS"", ""Shifting a negative value is technically undefined behaviour"", CWE758, Certainty::normal);
    else // RHS
        reportError(tok, Severity::error, ""shiftNegative"", ""Shifting by a negative value is undefined behaviour"", CWE758, Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.negativeBitwiseShiftError:void(Token*,int)",<empty>,,false,3221,3230,negativeBitwiseShiftError,,,1,"void(Token*,int)"
111669151849,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkIncompleteArrayFill()
{
    if (!mSettings->certainty.isEnabled(Certainty::inconclusive))
        return;
    const bool printWarning = mSettings->severity.isEnabled(Severity::warning);
    const bool printPortability = mSettings->severity.isEnabled(Severity::portability);
    if (!printPortability && !printWarning)
        return;

    logChecker(""CheckOther::checkIncompleteArrayFill""); // warning,portability,inconclusive

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (Token::Match(tok, ""memset|memcpy|memmove ("")) {
                std::vector<const Token*> args = getArguments(tok);
                if (args.size() != 3)
                    continue;
                const Token* tok2 = args[0];
                if (tok2->str() == ""::"")
                 ...",1,1,lib/checkother.cpp,CheckOther.checkIncompleteArrayFill:void(),<empty>,,false,3235,3282,checkIncompleteArrayFill,,,1,void()
111669151850,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::incompleteArrayFillError(const Token* tok, const std::string& buffer, const std::string& function, bool boolean)
{
    if (boolean)
        reportError(tok, Severity::portability, ""incompleteArrayFill"",
                    ""$symbol:"" + buffer + ""\\n""
                    ""$symbol:"" + function + ""\\n""
                    ""Array '"" + buffer + ""' might be filled incompletely. Did you forget to multiply the size given to '"" + function + ""()' with 'sizeof(*"" + buffer + "")'?\\n""
                    ""The array '"" + buffer + ""' is filled incompletely. The function '"" + function + ""()' needs the size given in bytes, but the type 'bool' is larger than 1 on some platforms. Did you forget to multiply the size with 'sizeof(*"" + buffer + "")'?"", CWE131, Certainty::inconclusive);
    else
        reportError(tok, Severity::warning, ""incompleteArrayFill"",
                    ""$symbol:"" + buffer + ""\\n""
                    ""$symbol:"" + function + ""\\n""
                    ""Array '"" + buffe...",1,1,lib/checkother.cpp,"CheckOther.incompleteArrayFillError:void(Token*,std.string&,std.string&,bool)",<empty>,,false,3284,3298,incompleteArrayFillError,,,1,"void(Token*,std.string&,std.string&,bool)"
111669151851,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkVarFuncNullUB()
{
    if (!mSettings->severity.isEnabled(Severity::portability))
        return;

    logChecker(""CheckOther::checkVarFuncNullUB""); // portability

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
            // Is NULL passed to a function?
            if (Token::Match(tok,""[(,] NULL [,)]"")) {
                // Locate function name in this function call.
                const Token *ftok = tok;
                int argnr = 1;
                while (ftok && ftok->str() != ""("") {
                    if (ftok->str() == "")"")
                        ftok = ftok->link();
                    else if (ftok->str() == "","")
                        ++argnr;
                    ftok = ftok->previous();
                }
                ftok = ftok ? ftok->previous() : nullpt...",1,1,lib/checkother.cpp,CheckOther.checkVarFuncNullUB:void(),<empty>,,false,3304,3340,checkVarFuncNullUB,,,1,void()
111669151852,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::varFuncNullUBError(const Token *tok)
{
    reportError(tok,
                Severity::portability,
                ""varFuncNullUB"",
                ""Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.\\n""
                ""Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.\\n""
                ""The C99 standard, in section 7.15.1.1, states that if the type used by va_arg() is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined.\\n""
                ""The value of the NULL macro is an implementation-defined null pointer constant (7.17), which can be any integer constant expression with the value 0, or such an expression casted to (void*) (6.3.2.3). This includes values like 0, 0L, or even 0LL.\\n""
                ""In practice on common architectures, this will cause real crashes if sizeof(int) != s...",1,1,lib/checkother.cpp,CheckOther.varFuncNullUBError:void(Token*),<empty>,,false,3342,3387,varFuncNullUBError,,,1,void(Token*)
111669151853,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkRedundantPointerOp()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""redundantPointerOp""))
        return;

    logChecker(""CheckOther::checkRedundantPointerOp""); // style

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (tok->isExpandedMacro() && tok->str() == ""("")
            tok = tok->link();

        bool addressOfDeref{};
        if (tok->isUnaryOp(""&"") && tok->astOperand1()->isUnaryOp(""*""))
            addressOfDeref = true;
        else if (tok->isUnaryOp(""*"") && tok->astOperand1()->isUnaryOp(""&""))
            addressOfDeref = false;
        else
            continue;

        // variable
        const Token *varTok = tok->astOperand1()->astOperand1();
        if (!varTok || varTok->isExpandedMacro())
            continue;

        if (!addressOfDeref) { // dereference of address
            if (tok->isExpandedMacro())
                continue;
            if (varTok->valu...",1,1,lib/checkother.cpp,CheckOther.checkRedundantPointerOp:void(),<empty>,,false,3389,3426,checkRedundantPointerOp,,,1,void()
111669151854,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::redundantPointerOpError(const Token* tok, const std::string &varname, bool inconclusive, bool addressOfDeref)
{
    std::string msg = ""$symbol:"" + varname + ""\\nRedundant pointer operation on '$symbol' - it's already a "";
    msg += addressOfDeref ? ""pointer."" : ""variable."";
    reportError(tok, Severity::style, ""redundantPointerOp"", msg, CWE398, inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.redundantPointerOpError:void(Token*,std.string&,bool,bool)",<empty>,,false,3428,3433,redundantPointerOpError,,,1,"void(Token*,std.string&,bool,bool)"
111669151855,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkInterlockedDecrement()
{
    if (!mSettings->platform.isWindows()) {
        return;
    }

    logChecker(""CheckOther::checkInterlockedDecrement""); // windows-platform

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (tok->isName() && Token::Match(tok, ""InterlockedDecrement ( & %name% ) ; if ( %name%|!|0"")) {
            const Token* interlockedVarTok = tok->tokAt(3);
            const Token* checkStartTok =  interlockedVarTok->tokAt(5);
            if ((Token::Match(checkStartTok, ""0 %comp% %name% )"") && checkStartTok->strAt(2) == interlockedVarTok->str()) ||
                (Token::Match(checkStartTok, ""! %name% )"") && checkStartTok->strAt(1) == interlockedVarTok->str()) ||
                (Token::Match(checkStartTok, ""%name% )"") && checkStartTok->str() == interlockedVarTok->str()) ||
                (Token::Match(checkStartTok, ""%name% %comp% 0 )"") && checkStartTok->str() == interlockedVarTok->str())) {
               ...",1,1,lib/checkother.cpp,CheckOther.checkInterlockedDecrement:void(),<empty>,,false,3435,3473,checkInterlockedDecrement,,,1,void()
111669151856,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::raceAfterInterlockedDecrementError(const Token* tok)
{
    reportError(tok, Severity::error, ""raceAfterInterlockedDecrement"",
                ""Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead."", CWE362, Certainty::normal);
}",1,1,lib/checkother.cpp,CheckOther.raceAfterInterlockedDecrementError:void(Token*),<empty>,,false,3475,3479,raceAfterInterlockedDecrementError,,,1,void(Token*)
111669151857,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkUnusedLabel()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->severity.isEnabled(Severity::warning) && !mSettings->isPremiumEnabled(""unusedLabel""))
        return;

    logChecker(""CheckOther::checkUnusedLabel""); // style,warning

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        const bool hasIfdef = mTokenizer->hasIfdef(scope->bodyStart, scope->bodyEnd);
        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
            if (!tok->scope()->isExecutable())
                tok = tok->scope()->bodyEnd;

            if (Token::Match(tok, ""{|}|; %name% :"") && !tok->tokAt(1)->isKeyword()) {
                const std::string tmp(""goto "" + tok->strAt(1));
                if (!Token::findsimplematch(scope->bodyStart->next(), tmp.c_str(), tmp.size(), scope->bodyEnd->previous()) && !tok->next()->isExpandedMacro...",1,1,lib/checkother.cpp,CheckOther.checkUnusedLabel:void(),<empty>,,false,3481,3502,checkUnusedLabel,,,1,void()
111669151858,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::unusedLabelError(const Token* tok, bool inSwitch, bool hasIfdef)
{
    if (tok && !mSettings->severity.isEnabled(inSwitch ? Severity::warning : Severity::style))
        return;

    std::string id = ""unusedLabel"";
    if (inSwitch)
        id += ""Switch"";
    if (hasIfdef)
        id += ""Configuration"";

    std::string msg = ""$symbol:"" + (tok ? tok->str() : """") + ""\\nLabel '$symbol' is not used."";
    if (hasIfdef)
        msg += "" There is #if in function body so the label might be used in code that is removed by the preprocessor."";
    if (inSwitch)
        msg += "" Should this be a 'case' of the enclosing switch()?"";

    reportError(tok,
                inSwitch ? Severity::warning : Severity::style,
                id,
                msg,
                CWE398,
                Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.unusedLabelError:void(Token*,bool,bool)",<empty>,,false,3504,3527,unusedLabelError,,,1,"void(Token*,bool,bool)"
111669151859,METHOD,<empty>,<empty>,"[&](const Token *tok3) {
        if (tok3->str() == ""&"" && !tok3->astOperand2())
            return ChildrenToVisit::none; // don't handle address-of for now
        if (tok3->str() == ""("" && Token::simpleMatch(tok3->previous(), ""sizeof""))
            return ChildrenToVisit::none; // don't care about sizeof usage
        if (isSameExpression(false, tok->astOperand1(), tok3, settings, true, false))
            foundError = true;
        return foundError ? ChildrenToVisit::done : ChildrenToVisit::op1_and_op2;
    }",100,5,lib/checkother.cpp,lib/checkother.cpp:<global>.checkEvaluationOrderC.<lambda>11:ChildrenToVisit(Token*),<empty>,,false,3539,3547,<lambda>11,,,1,ChildrenToVisit(Token*)
111669151860,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool checkEvaluationOrderC(const Token * tok, const Token * tok2, const Token * parent, const Settings & settings, bool & selfAssignmentError)
{
    // self assignment..
    if (tok2 == tok && tok->str() == ""="" && parent->str() == ""="" && isSameExpression(false, tok->astOperand1(), parent->astOperand1(), settings, true, false)) {
        if (settings.severity.isEnabled(Severity::warning) && isSameExpression(true, tok->astOperand1(), parent->astOperand1(), settings, true, false))
            selfAssignmentError = true;
        return false;
    }
    // Is expression used?
    bool foundError = false;
    visitAstNodes((parent->astOperand1() != tok2) ? parent->astOperand1() : parent->astOperand2(), [&](const Token *tok3) {
        if (tok3->str() == ""&"" && !tok3->astOperand2())
            return ChildrenToVisit::none; // don't handle address-of for now
        if (tok3->str() == ""("" && Token::simpleMatch(tok3->previous(), ""sizeof""))
            return ChildrenToVisit::none; //...",1,1,lib/checkother.cpp,"checkEvaluationOrderC:bool(Token*,Token*,Token*,Settings&,bool&)",<empty>,,false,3529,3550,checkEvaluationOrderC,,,1,"bool(Token*,Token*,Token*,Settings&,bool&)"
111669151861,METHOD,<empty>,<empty>,"[&](const Token *tok3) {
        if (tok3->str() == ""&"" && !tok3->astOperand2())
            return ChildrenToVisit::none; // don't handle address-of for now
        if (tok3->str() == ""("" && Token::simpleMatch(tok3->previous(), ""sizeof""))
            return ChildrenToVisit::none; // don't care about sizeof usage
        if (isSameExpression(false, tok->astOperand1(), tok3, settings, true, false))
            foundUndefined = true;
        return foundUndefined ? ChildrenToVisit::done : ChildrenToVisit::op1_and_op2;
    }",100,5,lib/checkother.cpp,lib/checkother.cpp:<global>.checkEvaluationOrderCpp11.<lambda>12:ChildrenToVisit(Token*),<empty>,,false,3561,3569,<lambda>12,,,1,ChildrenToVisit(Token*)
111669151862,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool checkEvaluationOrderCpp11(const Token * tok, const Token * tok2, const Token * parent, const Settings & settings)
{
    if (tok->isAssignmentOp()) // TODO check assignment
        return false;
    if (tok->previous() == tok->astOperand1() && parent->isArithmeticalOp() && parent->isBinaryOp()) {
        if (parent->astParent() && parent->astParent()->isAssignmentOp() && isSameExpression(false, tok->astOperand1(), parent->astParent()->astOperand1(), settings, true, false))
            return true;
    }
    bool foundUndefined{false};
    visitAstNodes((parent->astOperand1() != tok2) ? parent->astOperand1() : parent->astOperand2(), [&](const Token *tok3) {
        if (tok3->str() == ""&"" && !tok3->astOperand2())
            return ChildrenToVisit::none; // don't handle address-of for now
        if (tok3->str() == ""("" && Token::simpleMatch(tok3->previous(), ""sizeof""))
            return ChildrenToVisit::none; // don't care about sizeof usage
        if (isSameExpression(fa...",1,1,lib/checkother.cpp,"checkEvaluationOrderCpp11:bool(Token*,Token*,Token*,Settings&)",<empty>,,false,3552,3572,checkEvaluationOrderCpp11,,,1,"bool(Token*,Token*,Token*,Settings&)"
111669151863,METHOD,<empty>,<empty>,"[&](const Token *tok3) {
        if (tok3->str() == ""&"" && !tok3->astOperand2())
            return ChildrenToVisit::none; // don't handle address-of for now
        if (tok3->str() == ""("" && Token::simpleMatch(tok3->previous(), ""sizeof""))
            return ChildrenToVisit::none; // don't care about sizeof usage
        if (isSameExpression(false, tok->astOperand1(), tok3, settings, true, false) && parent->isArithmeticalOp() && parent->isBinaryOp())
            foundUndefined = true;
        if (tok3->tokType() == Token::eIncDecOp && isSameExpression(false, tok->astOperand1(), tok3->astOperand1(), settings, true, false)) {
            if (parent->isArithmeticalOp() && parent->isBinaryOp())
                foundUndefined = true;
            else
                foundUnspecified = true;
        }
        return (foundUndefined || foundUnspecified) ? ChildrenToVisit::done : ChildrenToVisit::op1_and_op2;
    }",100,5,lib/checkother.cpp,lib/checkother.cpp:<global>.checkEvaluationOrderCpp17.<lambda>13:ChildrenToVisit(Token*),<empty>,,false,3579,3593,<lambda>13,,,1,ChildrenToVisit(Token*)
111669151864,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool checkEvaluationOrderCpp17(const Token * tok, const Token * tok2, const Token * parent, const Settings & settings, bool & foundUnspecified)
{
    if (tok->isAssignmentOp())
        return false;
    bool foundUndefined{false};
    visitAstNodes((parent->astOperand1() != tok2) ? parent->astOperand1() : parent->astOperand2(), [&](const Token *tok3) {
        if (tok3->str() == ""&"" && !tok3->astOperand2())
            return ChildrenToVisit::none; // don't handle address-of for now
        if (tok3->str() == ""("" && Token::simpleMatch(tok3->previous(), ""sizeof""))
            return ChildrenToVisit::none; // don't care about sizeof usage
        if (isSameExpression(false, tok->astOperand1(), tok3, settings, true, false) && parent->isArithmeticalOp() && parent->isBinaryOp())
            foundUndefined = true;
        if (tok3->tokType() == Token::eIncDecOp && isSameExpression(false, tok->astOperand1(), tok3->astOperand1(), settings, true, false)) {
            if (parent->isAr...",1,1,lib/checkother.cpp,"checkEvaluationOrderCpp17:bool(Token*,Token*,Token*,Settings&,bool&)",<empty>,,false,3574,3596,checkEvaluationOrderCpp17,,,1,"bool(Token*,Token*,Token*,Settings&,bool&)"
111669151865,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkEvaluationOrder()
{
    logChecker(""CheckOther::checkEvaluationOrder"");
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * functionScope : symbolDatabase->functionScopes) {
        for (const Token* tok = functionScope->bodyStart; tok != functionScope->bodyEnd; tok = tok->next()) {
            if (!tok->isIncDecOp() && !tok->isAssignmentOp())
                continue;
            if (!tok->astOperand1())
                continue;
            for (const Token *tok2 = tok;; tok2 = tok2->astParent()) {
                // If ast parent is a sequence point then break
                const Token * const parent = tok2->astParent();
                if (!parent)
                    break;
                if (Token::Match(parent, ""%oror%|&&|?|:|;""))
                    break;
                if (parent->str() == "","") {
                    const Token *par = parent;
                    while (Token::simpleMatch(par,"",""))
   ...",1,1,lib/checkother.cpp,CheckOther.checkEvaluationOrder:void(),<empty>,,false,3598,3656,checkEvaluationOrder,,,1,void()
111669151866,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::unknownEvaluationOrder(const Token* tok, bool isUnspecifiedBehavior)
{
    isUnspecifiedBehavior ?
    reportError(tok, Severity::portability, ""unknownEvaluationOrder"",
                ""Expression '"" + (tok ? tok->expressionString() : std::string(""x++, x++"")) + ""' depends on order of evaluation of side effects. Behavior is Unspecified according to c++17"", CWE768, Certainty::normal)
    :   reportError(tok, Severity::error, ""unknownEvaluationOrder"",
                    ""Expression '"" + (tok ? tok->expressionString() : std::string(""x = x++;"")) + ""' depends on order of evaluation of side effects"", CWE768, Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.unknownEvaluationOrder:void(Token*,bool)",<empty>,,false,3658,3665,unknownEvaluationOrder,,,1,"void(Token*,bool)"
111669151867,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkAccessOfMovedVariable()
{
    if (!mTokenizer->isCPP() || mSettings->standards.cpp < Standards::CPP11)
        return;
    if (!mSettings->isPremiumEnabled(""accessMoved"") && !mSettings->severity.isEnabled(Severity::warning))
        return;
    logChecker(""CheckOther::checkAccessOfMovedVariable""); // c++11,warning
    const bool reportInconclusive = mSettings->certainty.isEnabled(Certainty::inconclusive);
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        const Token * scopeStart = scope->bodyStart;
        if (scope->function) {
            const Token * memberInitializationStart = scope->function->constructorMemberInitialization();
            if (memberInitializationStart)
                scopeStart = memberInitializationStart;
        }
        for (const Token* tok = scopeStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!tok->astParen...",1,1,lib/checkother.cpp,CheckOther.checkAccessOfMovedVariable:void(),<empty>,,false,3667,3712,checkAccessOfMovedVariable,,,1,void()
111669151868,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::accessMovedError(const Token *tok, const std::string &varname, const ValueFlow::Value *value, bool inconclusive)
{
    if (!tok) {
        reportError(tok, Severity::warning, ""accessMoved"", ""Access of moved variable 'v'."", CWE672, Certainty::normal);
        reportError(tok, Severity::warning, ""accessForwarded"", ""Access of forwarded variable 'v'."", CWE672, Certainty::normal);
        return;
    }

    const char * errorId = nullptr;
    std::string kindString;
    switch (value->moveKind) {
    case ValueFlow::Value::MoveKind::MovedVariable:
        errorId = ""accessMoved"";
        kindString = ""moved"";
        break;
    case ValueFlow::Value::MoveKind::ForwardedVariable:
        errorId = ""accessForwarded"";
        kindString = ""forwarded"";
        break;
    default:
        return;
    }
    const std::string errmsg(""$symbol:"" + varname + ""\\nAccess of "" + kindString + "" variable '$symbol'."");
    const ErrorPath errorPath = getErrorPath(tok, value, errmsg);
   ...",1,1,lib/checkother.cpp,"CheckOther.accessMovedError:void(Token*,std.string&,ValueFlow.Value*,bool)",<empty>,,false,3714,3739,accessMovedError,,,1,"void(Token*,std.string&,ValueFlow.Value*,bool)"
111669151869,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkFuncArgNamesDifferent()
{
    const bool style = mSettings->severity.isEnabled(Severity::style);
    const bool inconclusive = mSettings->certainty.isEnabled(Certainty::inconclusive);
    const bool warning = mSettings->severity.isEnabled(Severity::warning);

    if (!(warning || (style && inconclusive)) && !mSettings->isPremiumEnabled(""funcArgNamesDifferent""))
        return;

    logChecker(""CheckOther::checkFuncArgNamesDifferent""); // style,warning,inconclusive

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    // check every function
    for (const Scope *scope : symbolDatabase->functionScopes) {
        const Function * function = scope->function;
        // only check functions with arguments
        if (!function || function->argCount() == 0)
            continue;

        // only check functions with separate declarations and definitions
        if (function->argDef == function->arg)
            continue;

        // get th...",1,1,lib/checkother.cpp,CheckOther.checkFuncArgNamesDifferent:void(),<empty>,,false,3743,3824,checkFuncArgNamesDifferent,,,1,void()
111669151870,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::funcArgNamesDifferent(const std::string & functionName, nonneg int index,
                                       const Token* declaration, const Token* definition)
{
    std::list<const Token *> tokens = { declaration,definition };
    reportError(tokens, Severity::style, ""funcArgNamesDifferent"",
                ""$symbol:"" + functionName + ""\\n""
                ""Function '$symbol' argument "" + std::to_string(index + 1) + "" names different: declaration '"" +
                (declaration ? declaration->str() : std::string(""A"")) + ""' definition '"" +
                (definition ? definition->str() : std::string(""B"")) + ""'."", CWE628, Certainty::inconclusive);
}",1,73,lib/checkother.cpp,"CheckOther.funcArgNamesDifferent:void(std.string&,int,Token*,Token*)",<empty>,,false,3826,3835,funcArgNamesDifferent,,,1,"void(std.string&,int,Token*,Token*)"
111669151871,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::funcArgOrderDifferent(const std::string & functionName,
                                       const Token* declaration, const Token* definition,
                                       const std::vector<const Token *> & declarations,
                                       const std::vector<const Token *> & definitions)
{
    std::list<const Token *> tokens = {
        !declarations.empty() ? declarations[0] ? declarations[0] : declaration : nullptr,
        !definitions.empty() ? definitions[0] ? definitions[0] : definition : nullptr
    };
    std::string msg = ""$symbol:"" + functionName + ""\\nFunction '$symbol' argument order different: declaration '"";
    for (std::size_t i = 0; i < declarations.size(); ++i) {
        if (i != 0)
            msg += "", "";
        if (declarations[i])
            msg += declarations[i]->str();
    }
    msg += ""' definition '"";
    for (std::size_t i = 0; i < definitions.size(); ++i) {
        if (i != 0)
            msg += "", "";
   ...",1,1,lib/checkother.cpp,"CheckOther.funcArgOrderDifferent:void(std.string&,Token*,Token*,std.vector<constToken*>&,std.vector<constToken*>&)",<empty>,,false,3837,3862,funcArgOrderDifferent,,,1,"void(std.string&,Token*,Token*,std.vector<constToken*>&,std.vector<constToken*>&)"
111669151872,METHOD,<empty>,<empty>,"[&](const Function& f) {
        return f.type == FunctionType::eFunction && f.name() == var.name() && precedes(f.tokenDef, var.nameToken());
    }",86,5,lib/checkother.cpp,lib/checkother.cpp:<global>.findShadowed.<lambda>14:bool(Function&),<empty>,,false,3874,3876,<lambda>14,,,1,bool(Function&)
111669151873,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static const Token *findShadowed(const Scope *scope, const Variable& var, int linenr)
{
    if (!scope)
        return nullptr;
    for (const Variable &v : scope->varlist) {
        if (scope->isExecutable() && v.nameToken()->linenr() > linenr)
            continue;
        if (v.name() == var.name())
            return v.nameToken();
    }
    auto it = std::find_if(scope->functionList.cbegin(), scope->functionList.cend(), [&](const Function& f) {
        return f.type == FunctionType::eFunction && f.name() == var.name() && precedes(f.tokenDef, var.nameToken());
    });
    if (it != scope->functionList.end())
        return it->tokenDef;

    if (scope->type == ScopeType::eLambda)
        return nullptr;
    const Token* shadowed = findShadowed(scope->nestedIn, var, linenr);
    if (!shadowed)
        shadowed = findShadowed(scope->functionOf, var, linenr);
    return shadowed;
}",1,1,lib/checkother.cpp,"findShadowed:Token*(Scope*,Variable&,int)",<empty>,,false,3864,3886,findShadowed,,,1,"Token*(Scope*,Variable&,int)"
111669151874,METHOD,<empty>,<empty>,"[&](const Variable& arg) {
                    return arg.nameToken() && var.name() == arg.name();
                }",74,17,lib/checkother.cpp,lib/checkother.cpp:<global>.CheckOther.checkShadowVariables.<lambda>15:bool(Variable&),<empty>,,false,3906,3908,<lambda>15,,,1,bool(Variable&)
111669151875,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkShadowVariables()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""shadowVariable""))
        return;
    logChecker(""CheckOther::checkShadowVariables""); // style
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope & scope : symbolDatabase->scopeList) {
        if (!scope.isExecutable() || scope.type == ScopeType::eLambda)
            continue;
        const Scope *functionScope = &scope;
        while (functionScope && functionScope->type != ScopeType::eFunction && functionScope->type != ScopeType::eLambda)
            functionScope = functionScope->nestedIn;
        for (const Variable &var : scope.varlist) {
            if (var.nameToken() && var.nameToken()->isExpandedMacro()) // #8903
                continue;

            if (functionScope && functionScope->type == ScopeType::eFunction && functionScope->function) {
                const auto & argList = functionScope->fu...",1,1,lib/checkother.cpp,CheckOther.checkShadowVariables:void(),<empty>,,false,3888,3928,checkShadowVariables,,,1,void()
111669151876,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::shadowError(const Token *var, const Token *shadowed, const std::string& type)
{
    ErrorPath errorPath;
    errorPath.emplace_back(shadowed, ""Shadowed declaration"");
    errorPath.emplace_back(var, ""Shadow variable"");
    const std::string &varname = var ? var->str() : type;
    const std::string Type = char(std::toupper(type[0])) + type.substr(1);
    const std::string id = ""shadow"" + Type;
    const std::string message = ""$symbol:"" + varname + ""\\nLocal variable \\'$symbol\\' shadows outer "" + type;
    reportError(errorPath, Severity::style, id.c_str(), message, CWE398, Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.shadowError:void(Token*,Token*,std.string&)",<empty>,,false,3930,3940,shadowError,,,1,"void(Token*,Token*,std.string&)"
111669151877,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool isVariableExpression(const Token* tok)
{
    if (tok->varId() != 0)
        return true;
    if (Token::simpleMatch(tok, "".""))
        return isVariableExpression(tok->astOperand1()) &&
               isVariableExpression(tok->astOperand2());
    if (Token::simpleMatch(tok, ""[""))
        return isVariableExpression(tok->astOperand1());
    return false;
}",1,1,lib/checkother.cpp,isVariableExpression:bool(Token*),<empty>,,false,3942,3952,isVariableExpression,,,1,bool(Token*)
111669151878,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool isVariableExprHidden(const Token* tok)
{
    if (!tok)
        return false;
    if (!tok->astParent())
        return false;
    if (Token::simpleMatch(tok->astParent(), ""*"") && Token::simpleMatch(tok->astSibling(), ""0""))
        return true;
    if (Token::simpleMatch(tok->astParent(), ""&&"") && Token::simpleMatch(tok->astSibling(), ""false""))
        return true;
    if (Token::simpleMatch(tok->astParent(), ""||"") && Token::simpleMatch(tok->astSibling(), ""true""))
        return true;
    return false;
}",1,1,lib/checkother.cpp,isVariableExprHidden:bool(Token*),<empty>,,false,3954,3967,isVariableExprHidden,,,1,bool(Token*)
111669151879,METHOD,<empty>,<empty>,"[&](const Token* child) {
                if (Token::Match(child, ""%var%|.|["")) {
                    if (child->hasKnownIntValue())
                        return ChildrenToVisit::none;
                    if (astIsIntegral(child, false) && !astIsPointer(child) && child->values().empty()) {
                        vartok = child;
                        return ChildrenToVisit::done;
                    }
                }
                return ChildrenToVisit::op1_and_op2;
            }",32,13,lib/checkother.cpp,lib/checkother.cpp:<global>.CheckOther.checkKnownArgument.<lambda>16:ChildrenToVisit(Token*),<empty>,,false,4010,4020,<lambda>16,,,1,ChildrenToVisit(Token*)
111669151880,METHOD,<empty>,<empty>,"[](const Token* child) {
                return Token::simpleMatch(child, ""sizeof"");
            }",51,13,lib/checkother.cpp,lib/checkother.cpp:<global>.CheckOther.checkKnownArgument.<lambda>17:ANY(Token*),<empty>,,false,4024,4026,<lambda>17,,,1,ANY(Token*)
111669151881,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkKnownArgument()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""knownArgument""))
        return;
    logChecker(""CheckOther::checkKnownArgument""); // style
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope *functionScope : symbolDatabase->functionScopes) {
        for (const Token *tok = functionScope->bodyStart; tok != functionScope->bodyEnd; tok = tok->next()) {
            if (!tok->hasKnownIntValue() || tok->isExpandedMacro())
                continue;
            if (Token::Match(tok, ""++|--|%assign%""))
                continue;
            if (!Token::Match(tok->astParent(), ""(|{|,""))
                continue;
            if (tok->astParent()->isCast() || (tok->isCast() && Token::Match(tok->astOperand2(), ""++|--|%assign%"")))
                continue;
            int argn = -1;
            const Token* ftok = getTokenArgumentFunction(tok, argn);
            if (!ftok)...",1,1,lib/checkother.cpp,CheckOther.checkKnownArgument:void(),<empty>,,false,3969,4036,checkKnownArgument,,,1,void()
111669151882,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::knownArgumentError(const Token *tok, const Token *ftok, const ValueFlow::Value *value, const std::string &varexpr, bool isVariableExpressionHidden)
{
    if (!tok) {
        reportError(tok, Severity::style, ""knownArgument"", ""Argument 'x-x' to function 'func' is always 0. It does not matter what value 'x' has."");
        reportError(tok, Severity::style, ""knownArgumentHiddenVariableExpression"", ""Argument 'x*0' to function 'func' is always 0. Constant literal calculation disable/hide variable expression 'x'."");
        return;
    }

    const MathLib::bigint intvalue = value->intvalue;
    const std::string &expr = tok->expressionString();
    const std::string &fun = ftok->str();

    std::string ftype = ""function "";
    if (ftok->type())
        ftype = ""constructor "";
    else if (fun == ""{"")
        ftype = ""init list "";

    const char *id;
    std::string errmsg = ""Argument '"" + expr + ""' to "" + ftype + fun + "" is always "" + MathLib::toString(intvalue) + "". "";...",1,1,lib/checkother.cpp,"CheckOther.knownArgumentError:void(Token*,Token*,ValueFlow.Value*,std.string&,bool)",<empty>,,false,4038,4068,knownArgumentError,,,1,"void(Token*,Token*,ValueFlow.Value*,std.string&,bool)"
111669151883,METHOD,<empty>,<empty>,"[](const Token* parent) {
                return parent->isExpandedMacro();
            }",33,13,lib/checkother.cpp,lib/checkother.cpp:<global>.CheckOther.checkKnownPointerToBool.<lambda>18:bool(Token*),<empty>,,false,4088,4090,<lambda>18,,,1,bool(Token*)
111669151884,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkKnownPointerToBool()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""knownPointerToBool""))
        return;
    logChecker(""CheckOther::checkKnownPointerToBool""); // style
    const SymbolDatabase* symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope* functionScope : symbolDatabase->functionScopes) {
        for (const Token* tok = functionScope->bodyStart; tok != functionScope->bodyEnd; tok = tok->next()) {
            if (!tok->hasKnownIntValue())
                continue;
            if (!astIsPointer(tok))
                continue;
            if (Token::Match(tok->astParent(), ""?|!|&&|%oror%|%comp%""))
                continue;
            if (tok->astParent() && Token::Match(tok->astParent()->previous(), ""if|while|switch|sizeof (""))
                continue;
            if (tok->isExpandedMacro())
                continue;
            if (findParent(tok, [](const Token* parent) {
                r...",1,1,lib/checkother.cpp,CheckOther.checkKnownPointerToBool:void(),<empty>,,false,4070,4098,checkKnownPointerToBool,,,1,void()
111669151885,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::knownPointerToBoolError(const Token* tok, const ValueFlow::Value* value)
{
    if (!tok) {
        reportError(tok, Severity::style, ""knownPointerToBool"", ""Pointer expression 'p' converted to bool is always true."");
        return;
    }
    std::string cond = bool_to_string(!!value->intvalue);
    const std::string& expr = tok->expressionString();
    std::string errmsg = ""Pointer expression '"" + expr + ""' converted to bool is always "" + cond + ""."";
    const ErrorPath errorPath = getErrorPath(tok, value, errmsg);
    reportError(errorPath, Severity::style, ""knownPointerToBool"", errmsg, CWE570, Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.knownPointerToBoolError:void(Token*,ValueFlow.Value*)",<empty>,,false,4100,4111,knownPointerToBoolError,,,1,"void(Token*,ValueFlow.Value*)"
111669151886,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkComparePointers()
{
    logChecker(""CheckOther::checkComparePointers"");
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope *functionScope : symbolDatabase->functionScopes) {
        for (const Token *tok = functionScope->bodyStart; tok != functionScope->bodyEnd; tok = tok->next()) {
            if (!Token::Match(tok, ""<|>|<=|>=|-""))
                continue;
            const Token *tok1 = tok->astOperand1();
            if (!astIsPointer(tok1))
                continue;
            const Token *tok2 = tok->astOperand2();
            if (!astIsPointer(tok2))
                continue;
            ValueFlow::Value v1 = ValueFlow::getLifetimeObjValue(tok1);
            if (!v1.isLocalLifetimeValue())
                continue;
            ValueFlow::Value v2 = ValueFlow::getLifetimeObjValue(tok2);
            if (!v2.isLocalLifetimeValue())
                continue;
            const Variable *var1 = v1.tokvalue->variab...",1,1,lib/checkother.cpp,CheckOther.checkComparePointers:void(),<empty>,,false,4113,4152,checkComparePointers,,,1,void()
111669151887,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::comparePointersError(const Token *tok, const ValueFlow::Value *v1, const ValueFlow::Value *v2)
{
    ErrorPath errorPath;
    std::string verb = ""Comparing"";
    if (Token::simpleMatch(tok, ""-""))
        verb = ""Subtracting"";
    const char * const id = (verb[0] == 'C') ? ""comparePointers"" : ""subtractPointers"";
    if (v1) {
        errorPath.emplace_back(v1->tokvalue->variable()->nameToken(), ""Variable declared here."");
        errorPath.insert(errorPath.end(), v1->errorPath.cbegin(), v1->errorPath.cend());
    }
    if (v2) {
        errorPath.emplace_back(v2->tokvalue->variable()->nameToken(), ""Variable declared here."");
        errorPath.insert(errorPath.end(), v2->errorPath.cbegin(), v2->errorPath.cend());
    }
    errorPath.emplace_back(tok, """");
    reportError(
        errorPath, Severity::error, id, verb + "" pointers that point to different objects"", CWE570, Certainty::normal);
}",1,1,lib/checkother.cpp,"CheckOther.comparePointersError:void(Token*,ValueFlow.Value*,ValueFlow.Value*)",<empty>,,false,4154,4172,comparePointersError,,,1,"void(Token*,ValueFlow.Value*,ValueFlow.Value*)"
111669151888,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkModuloOfOne()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""moduloofone""))
        return;

    logChecker(""CheckOther::checkModuloOfOne""); // style

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (!tok->astOperand2() || !tok->astOperand1())
            continue;
        if (tok->str() != ""%"")
            continue;
        if (!tok->valueType() || !tok->valueType()->isIntegral())
            continue;

        // Value flow..
        const ValueFlow::Value *value = tok->astOperand2()->getValue(1LL);
        if (value && value->isKnown())
            checkModuloOfOneError(tok);
    }
}",1,1,lib/checkother.cpp,CheckOther.checkModuloOfOne:void(),<empty>,,false,4174,4194,checkModuloOfOne,,,1,void()
111669151889,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkModuloOfOneError(const Token *tok)
{
    reportError(tok, Severity::style, ""moduloofone"", ""Modulo of one is always equal to zero"");
}",1,1,lib/checkother.cpp,CheckOther.checkModuloOfOneError:void(Token*),<empty>,,false,4196,4199,checkModuloOfOneError,,,1,void(Token*)
111669151890,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"static bool getBufAndOffset(const Token *expr, const Token *&buf, MathLib::bigint *offset, const Settings& settings, MathLib::bigint* sizeValue = nullptr)
{
    if (!expr)
        return false;
    const Token *bufToken, *offsetToken;
    MathLib::bigint elementSize = 0;
    if (expr->isUnaryOp(""&"") && Token::simpleMatch(expr->astOperand1(), ""["")) {
        bufToken = expr->astOperand1()->astOperand1();
        offsetToken = expr->astOperand1()->astOperand2();
        if (expr->astOperand1()->valueType())
            elementSize =  ValueFlow::getSizeOf(*expr->astOperand1()->valueType(), settings);
    } else if (Token::Match(expr, ""+|-"") && expr->isBinaryOp()) {
        const bool pointer1 = (expr->astOperand1()->valueType() && expr->astOperand1()->valueType()->pointer > 0);
        const bool pointer2 = (expr->astOperand2()->valueType() && expr->astOperand2()->valueType()->pointer > 0);
        if (pointer1 && !pointer2) {
            bufToken = expr->astOperand1();
            off...",1,1,lib/checkother.cpp,"getBufAndOffset:bool(Token*,Token*&,MathLib.bigint*,Settings&,MathLib.bigint*)",<empty>,,false,4204,4260,getBufAndOffset,,,1,"bool(Token*,Token*&,MathLib.bigint*,Settings&,MathLib.bigint*)"
111669151891,METHOD,<empty>,<empty>,"[lhsvar, lhsmember, &errorToken](const Token *rhs) {
                    if (!Token::simpleMatch(rhs, "".""))
                        return ChildrenToVisit::op1_and_op2;
                    if (!rhs->isBinaryOp() || rhs->astOperand1()->variable() != lhsvar)
                        return ChildrenToVisit::none;
                    if (lhsmember->str() == rhs->astOperand2()->str())
                        return ChildrenToVisit::none;
                    const Variable* rhsmembervar = rhs->astOperand2()->variable();
                    const Scope* varscope1 = lhsmember->variable() ? lhsmember->variable()->typeStartToken()->scope() : nullptr;
                    const Scope* varscope2 = rhsmembervar ? rhsmembervar->typeStartToken()->scope() : nullptr;
                    if (varscope1 && varscope1 == varscope2 && varscope1 != lhsvar->typeScope())
                        // lhsmember and rhsmember are declared in same anonymous scope inside union
                        return ChildrenT...",51,17,lib/checkother.cpp,lib/checkother.cpp:<global>.CheckOther.checkOverlappingWrite.<lambda>19:ChildrenToVisit(Token*),<empty>,,false,4282,4297,<lambda>19,,,1,ChildrenToVisit(Token*)
111669151892,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::checkOverlappingWrite()
{
    logChecker(""CheckOther::checkOverlappingWrite"");
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope *functionScope : symbolDatabase->functionScopes) {
        for (const Token *tok = functionScope->bodyStart; tok != functionScope->bodyEnd; tok = tok->next()) {
            if (tok->isAssignmentOp()) {
                // check if LHS is a union member..
                const Token * const lhs = tok->astOperand1();
                if (!Token::simpleMatch(lhs, ""."") || !lhs->isBinaryOp())
                    continue;
                const Variable * const lhsvar = lhs->astOperand1()->variable();
                if (!lhsvar || !lhsvar->typeScope() || lhsvar->typeScope()->type != ScopeType::eUnion)
                    continue;
                const Token* const lhsmember = lhs->astOperand2();
                if (!lhsmember)
                    continue;

                // Is other union member u...",1,1,lib/checkother.cpp,CheckOther.checkOverlappingWrite:void(),<empty>,,false,4262,4358,checkOverlappingWrite,,,1,void()
111669151893,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::overlappingWriteUnion(const Token *tok)
{
    reportError(tok, Severity::error, ""overlappingWriteUnion"", ""Overlapping read/write of union is undefined behavior"");
}",1,1,lib/checkother.cpp,CheckOther.overlappingWriteUnion:void(Token*),<empty>,,false,4360,4363,overlappingWriteUnion,,,1,void(Token*)
111669151894,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::overlappingWriteFunction(const Token *tok, const std::string& funcname)
{
    reportError(tok, Severity::error, ""overlappingWriteFunction"", ""Overlapping read/write in "" + funcname + ""() is undefined behavior"");
}",1,1,lib/checkother.cpp,"CheckOther.overlappingWriteFunction:void(Token*,std.string&)",<empty>,,false,4365,4368,overlappingWriteFunction,,,1,"void(Token*,std.string&)"
111669151895,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    CheckOther checkOther(&tokenizer, &tokenizer.getSettings(), errorLogger);

    // Checks
    checkOther.warningOldStylePointerCast();
    checkOther.suspiciousFloatingPointCast();
    checkOther.invalidPointerCast();
    checkOther.checkCharVariable();
    checkOther.redundantBitwiseOperationInSwitchError();
    checkOther.checkSuspiciousCaseInSwitch();
    checkOther.checkDuplicateBranch();
    checkOther.checkDuplicateExpression();
    checkOther.checkRedundantAssignment();
    checkOther.checkUnreachableCode();
    checkOther.checkSuspiciousSemicolon();
    checkOther.checkVariableScope();
    checkOther.checkSignOfUnsignedVariable();  // don't ignore casts (#3574)
    checkOther.checkIncompleteArrayFill();
    checkOther.checkVarFuncNullUB();
    checkOther.checkNanInArithmeticExpression();
    checkOther.checkCommaSeparatedReturn();
    checkOther.checkRedundantPointerOp();
    checkOther.che...",1,1,lib/checkother.cpp,"CheckOther.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,4370,4417,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669151896,METHOD,lib/checkother.cpp:<global>,TYPE_DECL,"void CheckOther::getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const
{
    CheckOther c(nullptr, settings, errorLogger);

    // error
    c.zerodivError(nullptr, nullptr);
    c.misusedScopeObjectError(nullptr, ""varname"");
    c.invalidPointerCastError(nullptr,  ""float *"", ""double *"", false, false);
    c.negativeBitwiseShiftError(nullptr, 1);
    c.negativeBitwiseShiftError(nullptr, 2);
    c.raceAfterInterlockedDecrementError(nullptr);
    c.invalidFreeError(nullptr, ""malloc"", false);
    c.overlappingWriteUnion(nullptr);
    c.overlappingWriteFunction(nullptr, ""funcname"");

    //performance
    c.redundantCopyError(nullptr,  ""varname"");
    c.redundantCopyError(nullptr, nullptr, ""var"");

    // style/warning
    c.checkComparisonFunctionIsAlwaysTrueOrFalseError(nullptr, ""isless"",""varName"",false);
    c.checkCastIntToCharAndBackError(nullptr, ""func_name"");
    c.cstyleCastError(nullptr);
    c.suspiciousFloatingPointCastError(nullptr);
    c.passedByValueE...",1,1,lib/checkother.cpp,"CheckOther.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,4419,4493,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669151897,METHOD,lib/checkother.h:<global>,TYPE_DECL,<global>,1,1,lib/checkother.h,lib/checkother.h:<global>,<empty>,,false,1,325,<global>,,,1,
111669151898,METHOD,lib/checkpostfixoperator.cpp:<global>,TYPE_DECL,"void CheckPostfixOperator::postfixOperator()
{
    if (!mSettings->severity.isEnabled(Severity::performance))
        return;

    logChecker(""CheckPostfixOperator::postfixOperator""); // performance

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            const Variable *var = tok->variable();
            if (!var || !Token::Match(tok, ""%var% ++|--""))
                continue;

            const Token* parent = tok->next()->astParent();
            if (!parent || parent->str() == "";"" || (parent->str() == "","" && (!parent->astParent() || parent->astParent()->str() != ""(""))) {
                if (var->isPointer() || var->isArray())
                    continue;

                const Token* typeEndTok = var->typeStartToken();
                if (Token::simpleMatch(typeEndTok, ""::""))
      ...",1,1,lib/checkpostfixoperator.cpp,CheckPostfixOperator.postfixOperator:void(),<empty>,,false,47,89,postfixOperator,,,1,void()
111669151899,METHOD,lib/checkpostfixoperator.cpp:<global>,TYPE_DECL,<global>,1,1,lib/checkpostfixoperator.cpp,lib/checkpostfixoperator.cpp:<global>,<empty>,,false,1,117,<global>,,,1,
111669151900,METHOD,lib/checkpostfixoperator.cpp:<global>,TYPE_DECL,"void CheckPostfixOperator::postfixOperatorError(const Token *tok)
{
    reportError(tok, Severity::performance, ""postfixOperator"",
                ""Prefer prefix ++/-- operators for non-primitive types.\\n""
                ""Prefix ++/-- operators should be preferred for non-primitive types. ""
                ""Pre-increment/decrement can be more efficient than ""
                ""post-increment/decrement. Post-increment/decrement usually ""
                ""involves keeping a copy of the previous value around and ""
                ""adds a little extra code."", CWE398, Certainty::normal);
}",1,1,lib/checkpostfixoperator.cpp,CheckPostfixOperator.postfixOperatorError:void(Token*),<empty>,,false,93,102,postfixOperatorError,,,1,void(Token*)
111669151901,METHOD,lib/checkpostfixoperator.cpp:<global>,TYPE_DECL,"void CheckPostfixOperator::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    if (tokenizer.isC())
        return;

    CheckPostfixOperator checkPostfixOperator(&tokenizer, &tokenizer.getSettings(), errorLogger);
    checkPostfixOperator.postfixOperator();
}",1,1,lib/checkpostfixoperator.cpp,"CheckPostfixOperator.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,104,111,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669151902,METHOD,lib/checkpostfixoperator.cpp:<global>,TYPE_DECL,"void CheckPostfixOperator::getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const
{
    CheckPostfixOperator c(nullptr, settings, errorLogger);
    c.postfixOperatorError(nullptr);
}",1,1,lib/checkpostfixoperator.cpp,"CheckPostfixOperator.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,113,117,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669151903,METHOD,lib/checkpostfixoperator.h:<global>,TYPE_DECL,<global>,1,1,lib/checkpostfixoperator.h,lib/checkpostfixoperator.h:<global>,<empty>,,false,1,74,<global>,,,1,
111669151904,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::checkSizeofForNumericParameter()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckSizeof::checkSizeofForNumericParameter""); // warning

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (Token::Match(tok, ""sizeof ( %num% )"") ||
                Token::Match(tok, ""sizeof %num%"")) {
                sizeofForNumericParameterError(tok);
            }
        }
    }
}",1,1,lib/checksizeof.cpp,CheckSizeof.checkSizeofForNumericParameter:void(),<empty>,,false,47,63,checkSizeofForNumericParameter,,,1,void()
111669151905,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,<global>,1,78,lib/checksizeof.cpp,lib/checksizeof.cpp:<global>,<empty>,,false,1,535,<global>,,,1,
111669151906,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::sizeofForNumericParameterError(const Token *tok)
{
    reportError(tok, Severity::warning,
                ""sizeofwithnumericparameter"", ""Suspicious usage of 'sizeof' with a numeric constant as parameter.\\n""
                ""It is unusual to use a constant value with sizeof. For example, 'sizeof(10)'""
                "" returns 4 (in 32-bit systems) or 8 (in 64-bit systems) instead of 10. 'sizeof('A')'""
                "" and 'sizeof(char)' can return different results."", CWE682, Certainty::normal);
}",1,1,lib/checksizeof.cpp,CheckSizeof.sizeofForNumericParameterError:void(Token*),<empty>,,false,65,72,sizeofForNumericParameterError,,,1,void(Token*)
111669151907,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::checkSizeofForArrayParameter()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckSizeof::checkSizeofForArrayParameter""); // warning

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (Token::Match(tok, ""sizeof ( %var% )"") ||
                Token::Match(tok, ""sizeof %var% !!["")) {
                const Token* varTok = tok->next();
                if (varTok->str() == ""("") {
                    varTok = varTok->next();
                }

                const Variable *var = varTok->variable();
                if (var && var->isArray() && var->isArgument() && !var->isReference())
                    sizeofForArrayParameterError(tok);
            }
        }
    }
}",1,1,lib/checksizeof.cpp,CheckSizeof.checkSizeofForArrayParameter:void(),<empty>,,false,77,100,checkSizeofForArrayParameter,,,1,void()
111669151908,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::sizeofForArrayParameterError(const Token *tok)
{
    reportError(tok, Severity::warning,
                ""sizeofwithsilentarraypointer"", ""Using 'sizeof' on array given as function argument ""
                ""returns size of a pointer.\\n""
                ""Using 'sizeof' for array given as function argument returns the size of a pointer. ""
                ""It does not return the size of the whole array in bytes as might be ""
                ""expected. For example, this code:\\n""
                ""     int f(char a[100]) {\\n""
                ""         return sizeof(a);\\n""
                ""     }\\n""
                ""returns 4 (in 32-bit systems) or 8 (in 64-bit systems) instead of 100 (the ""
                ""size of the array in bytes)."", CWE467, Certainty::normal
                );
}",1,1,lib/checksizeof.cpp,CheckSizeof.sizeofForArrayParameterError:void(Token*),<empty>,,false,102,116,sizeofForArrayParameterError,,,1,void(Token*)
111669151909,METHOD,<empty>,<empty>,"[](const Token* szTok) {
                                        return Token::simpleMatch(szTok, ""("") && Token::simpleMatch(szTok->previous(), ""sizeof"");
                                    }",91,37,lib/checksizeof.cpp,lib/checksizeof.cpp:<global>.CheckSizeof.checkSizeofForPointerSize.<lambda>0.<lambda>1:bool(Token*),<empty>,,false,181,183,<lambda>1,,,1,bool(Token*)
111669151910,METHOD,<empty>,<empty>,"[](const Token* parTok) -> bool {
                            while (parTok) { // Allow division if followed by multiplication
                                if (parTok->isArithmeticalOp() && parTok->str() == ""*"") {
                                    const Token* szToks[] = { parTok->astOperand1(), parTok->astOperand2() };
                                    if (std::any_of(std::begin(szToks), std::end(szToks), [](const Token* szTok) {
                                        return Token::simpleMatch(szTok, ""("") && Token::simpleMatch(szTok->previous(), ""sizeof"");
                                    }))
                                        return true;
                                }
                                parTok = parTok->astParent();
                            }
                            return false;
                        }",50,25,lib/checksizeof.cpp,lib/checksizeof.cpp:<global>.CheckSizeof.checkSizeofForPointerSize.<lambda>0:bool(Token*),<empty>,,false,177,189,<lambda>0,,,1,bool(Token*)
111669151911,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::checkSizeofForPointerSize()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckSizeof::checkSizeofForPointerSize""); // warning

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
            const Token* tokSize;
            const Token* tokFunc;
            const Token *variable = nullptr;
            const Token *variable2 = nullptr;

            // Find any function that may use sizeof on a pointer
            // Once leaving those tests, it is mandatory to have:
            // - variable matching the used pointer
            // - tokVar pointing on the argument where sizeof may be used
            if (Token::Match(tok->tokAt(2), ""%name% ("") && mSettings->library.getAllocFuncInfo(tok->tokAt(2))) {
                if (Token::Match(tok,...",1,1,lib/checksizeof.cpp,CheckSizeof.checkSizeofForPointerSize:void(),<empty>,,false,118,268,checkSizeofForPointerSize,,,1,void()
111669151912,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::sizeofForPointerError(const Token *tok, const std::string &varname)
{
    reportError(tok, Severity::warning, ""pointerSize"",
                ""Size of pointer '"" + varname + ""' used instead of size of its data.\\n""
                ""Size of pointer '"" + varname + ""' used instead of size of its data. ""
                ""This is likely to lead to a buffer overflow. You probably intend to ""
                ""write 'sizeof(*"" + varname + "")'."", CWE467, Certainty::normal);
}",1,1,lib/checksizeof.cpp,"CheckSizeof.sizeofForPointerError:void(Token*,std.string&)",<empty>,,false,270,277,sizeofForPointerError,,,1,"void(Token*,std.string&)"
111669151913,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::divideBySizeofError(const Token *tok, const std::string &memfunc)
{
    reportError(tok, Severity::warning, ""sizeofDivisionMemfunc"",
                ""Division by result of sizeof(). "" + memfunc + ""() expects a size in bytes, did you intend to multiply instead?"", CWE682, Certainty::normal);
}",1,1,lib/checksizeof.cpp,"CheckSizeof.divideBySizeofError:void(Token*,std.string&)",<empty>,,false,279,283,divideBySizeofError,,,1,"void(Token*,std.string&)"
111669151914,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::sizeofsizeof()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckSizeof::sizeofsizeof""); // warning

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""sizeof (| sizeof"")) {
            sizeofsizeofError(tok);
            tok = tok->next();
        }
    }
}",1,1,lib/checksizeof.cpp,CheckSizeof.sizeofsizeof:void(),<empty>,,false,287,300,sizeofsizeof,,,1,void()
111669151915,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::sizeofsizeofError(const Token *tok)
{
    reportError(tok, Severity::warning,
                ""sizeofsizeof"", ""Calling 'sizeof' on 'sizeof'.\\n""
                ""Calling sizeof for 'sizeof looks like a suspicious code and ""
                ""most likely there should be just one 'sizeof'. The current ""
                ""code is equivalent to 'sizeof(size_t)'"", CWE682, Certainty::normal);
}",1,1,lib/checksizeof.cpp,CheckSizeof.sizeofsizeofError:void(Token*),<empty>,,false,302,309,sizeofsizeofError,,,1,void(Token*)
111669151916,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::sizeofCalculation()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckSizeof::sizeofCalculation""); // warning

    const bool printInconclusive = mSettings->certainty.isEnabled(Certainty::inconclusive);

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (!Token::simpleMatch(tok, ""sizeof (""))
            continue;

        // ignore if the `sizeof` result is cast to void inside a macro, i.e. the calculation is
        // expected to be parsed but skipped, such as in a disabled custom ASSERT() macro
        if (tok->isExpandedMacro() && tok->previous()) {
            const Token *cast_end = (tok->strAt(-1) == ""("") ? tok->previous() : tok;
            if (Token::simpleMatch(cast_end->tokAt(-3), ""( void )"") ||
                Token::simpleMatch(cast_end->tokAt(-4), ""static_cast < void >"")) {
                continue;
            }
        }

        const Token *argument = tok->next()...",1,1,lib/checksizeof.cpp,CheckSizeof.sizeofCalculation:void(),<empty>,,false,313,349,sizeofCalculation,,,1,void()
111669151917,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::sizeofCalculationError(const Token *tok, bool inconclusive)
{
    reportError(tok, Severity::warning,
                ""sizeofCalculation"", ""Found calculation inside sizeof()."", CWE682, inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checksizeof.cpp,"CheckSizeof.sizeofCalculationError:void(Token*,bool)",<empty>,,false,351,355,sizeofCalculationError,,,1,"void(Token*,bool)"
111669151918,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::sizeofFunction()
{
    if (!mSettings->severity.isEnabled(Severity::warning) && !mSettings->isPremiumEnabled(""sizeofFunctionCall""))
        return;

    logChecker(""CheckSizeof::sizeofFunction""); // warning

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (Token::simpleMatch(tok, ""sizeof ("")) {

            // ignore if the `sizeof` result is cast to void inside a macro, i.e. the calculation is
            // expected to be parsed but skipped, such as in a disabled custom ASSERT() macro
            if (tok->isExpandedMacro() && tok->previous()) {
                const Token *cast_end = (tok->strAt(-1) == ""("") ? tok->previous() : tok;
                if (Token::simpleMatch(cast_end->tokAt(-3), ""( void )"") ||
                    Token::simpleMatch(cast_end->tokAt(-4), ""static_cast < void >"")) {
                    continue;
                }
            }

            if (const Token *argument = tok->next()->astOperand2()) {
   ...",1,1,lib/checksizeof.cpp,CheckSizeof.sizeofFunction:void(),<empty>,,false,359,391,sizeofFunction,,,1,void()
111669151919,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::sizeofFunctionError(const Token *tok)
{
    reportError(tok, Severity::warning,
                ""sizeofFunctionCall"", ""Found function call inside sizeof()."", CWE682, Certainty::normal);
}",1,1,lib/checksizeof.cpp,CheckSizeof.sizeofFunctionError:void(Token*),<empty>,,false,393,397,sizeofFunctionError,,,1,void(Token*)
111669151920,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::suspiciousSizeofCalculation()
{
    if (!mSettings->severity.isEnabled(Severity::warning) || !mSettings->certainty.isEnabled(Certainty::inconclusive))
        return;

    logChecker(""CheckSizeof::suspiciousSizeofCalculation""); // warning,inconclusive

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (Token::simpleMatch(tok, ""sizeof ("")) {
            const Token* lPar = tok->astParent();
            if (lPar && lPar->str() == ""("") {
                const Token* const rPar = lPar->link();
                const Token* varTok = lPar->astOperand2();
                int derefCount = 0;
                while (Token::Match(varTok, ""[|*"")) {
                    ++derefCount;
                    varTok = varTok->astOperand1();
                }
                if (lPar->astParent() && lPar->astParent()->str() == ""/"") {
                    const Variable* var = varTok ? varTok->variable() : nullptr;
                    if (var && var->i...",1,1,lib/checksizeof.cpp,CheckSizeof.suspiciousSizeofCalculation:void(),<empty>,,false,402,430,suspiciousSizeofCalculation,,,1,void()
111669151921,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::multiplySizeofError(const Token *tok)
{
    reportError(tok, Severity::warning,
                ""multiplySizeof"", ""Multiplying sizeof() with sizeof() indicates a logic error."", CWE682, Certainty::inconclusive);
}",1,1,lib/checksizeof.cpp,CheckSizeof.multiplySizeofError:void(Token*),<empty>,,false,432,436,multiplySizeofError,,,1,void(Token*)
111669151922,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::divideSizeofError(const Token *tok)
{
    reportError(tok, Severity::warning,
                ""divideSizeof"", ""Division of result of sizeof() on pointer type.\\n""
                ""Division of result of sizeof() on pointer type. sizeof() returns the size of the pointer, ""
                ""not the size of the memory area it points to."", CWE682, Certainty::inconclusive);
}",1,1,lib/checksizeof.cpp,CheckSizeof.divideSizeofError:void(Token*),<empty>,,false,438,444,divideSizeofError,,,1,void(Token*)
111669151923,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::sizeofVoid()
{
    if (!mSettings->severity.isEnabled(Severity::portability))
        return;

    logChecker(""CheckSizeof::sizeofVoid""); // portability

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (Token::simpleMatch(tok, ""sizeof ( void )"")) {
            sizeofVoidError(tok);
        } else if (Token::simpleMatch(tok, ""sizeof ("") && tok->next()->astOperand2()) {
            const ValueType *vt = tok->next()->astOperand2()->valueType();
            if (vt && vt->type == ValueType::Type::VOID && vt->pointer == 0U)
                sizeofDereferencedVoidPointerError(tok, tok->strAt(3));
        } else if (tok->str() == ""-"") {
            // only warn for: 'void *' - 'integral'
            const ValueType *vt1  = tok->astOperand1() ? tok->astOperand1()->valueType() : nullptr;
            const ValueType *vt2  = tok->astOperand2() ? tok->astOperand2()->valueType() : nullptr;
            const bool op1IsvoidPointer = (vt1 && vt...",1,1,lib/checksizeof.cpp,CheckSizeof.sizeofVoid:void(),<empty>,,false,446,482,sizeofVoid,,,1,void()
111669151924,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::sizeofVoidError(const Token *tok)
{
    const std::string message = ""Behaviour of 'sizeof(void)' is not covered by the ISO C standard."";
    const std::string verbose = message + "" A value for 'sizeof(void)' is defined only as part of a GNU C extension, which defines 'sizeof(void)' to be 1."";
    reportError(tok, Severity::portability, ""sizeofVoid"", message + ""\\n"" + verbose, CWE682, Certainty::normal);
}",1,1,lib/checksizeof.cpp,CheckSizeof.sizeofVoidError:void(Token*),<empty>,,false,484,489,sizeofVoidError,,,1,void(Token*)
111669151925,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::sizeofDereferencedVoidPointerError(const Token *tok, const std::string &varname)
{
    const std::string message = ""'*"" + varname + ""' is of type 'void', the behaviour of 'sizeof(void)' is not covered by the ISO C standard."";
    const std::string verbose = message + "" A value for 'sizeof(void)' is defined only as part of a GNU C extension, which defines 'sizeof(void)' to be 1."";
    reportError(tok, Severity::portability, ""sizeofDereferencedVoidPointer"", message + ""\\n"" + verbose, CWE682, Certainty::normal);
}",1,1,lib/checksizeof.cpp,"CheckSizeof.sizeofDereferencedVoidPointerError:void(Token*,std.string&)",<empty>,,false,491,496,sizeofDereferencedVoidPointerError,,,1,"void(Token*,std.string&)"
111669151926,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::arithOperationsOnVoidPointerError(const Token* tok, const std::string &varname, const std::string &vartype)
{
    const std::string message = ""'$symbol' is of type '"" + vartype + ""'. When using void pointers in calculations, the behaviour is undefined."";
    const std::string verbose = message + "" Arithmetic operations on 'void *' is a GNU C extension, which defines the 'sizeof(void)' to be 1."";
    reportError(tok, Severity::portability, ""arithOperationsOnVoidPointer"", ""$symbol:"" + varname + '\\n' + message + '\\n' + verbose, CWE467, Certainty::normal);
}",1,1,lib/checksizeof.cpp,"CheckSizeof.arithOperationsOnVoidPointerError:void(Token*,std.string&,std.string&)",<empty>,,false,498,503,arithOperationsOnVoidPointerError,,,1,"void(Token*,std.string&,std.string&)"
111669151927,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::runChecks(const Tokenizer& tokenizer, ErrorLogger* errorLogger)
{
    CheckSizeof checkSizeof(&tokenizer, &tokenizer.getSettings(), errorLogger);

    // Checks
    checkSizeof.sizeofsizeof();
    checkSizeof.sizeofCalculation();
    checkSizeof.sizeofFunction();
    checkSizeof.suspiciousSizeofCalculation();
    checkSizeof.checkSizeofForArrayParameter();
    checkSizeof.checkSizeofForPointerSize();
    checkSizeof.checkSizeofForNumericParameter();
    checkSizeof.sizeofVoid();
}",1,1,lib/checksizeof.cpp,"CheckSizeof.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,505,518,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669151928,METHOD,lib/checksizeof.cpp:<global>,TYPE_DECL,"void CheckSizeof::getErrorMessages(ErrorLogger* errorLogger, const Settings* settings) const
{
    CheckSizeof c(nullptr, settings, errorLogger);
    c.sizeofForArrayParameterError(nullptr);
    c.sizeofForPointerError(nullptr, ""varname"");
    c.divideBySizeofError(nullptr, ""memset"");
    c.sizeofForNumericParameterError(nullptr);
    c.sizeofsizeofError(nullptr);
    c.sizeofCalculationError(nullptr, false);
    c.sizeofFunctionError(nullptr);
    c.multiplySizeofError(nullptr);
    c.divideSizeofError(nullptr);
    c.sizeofVoidError(nullptr);
    c.sizeofDereferencedVoidPointerError(nullptr, ""varname"");
    c.arithOperationsOnVoidPointerError(nullptr, ""varname"", ""vartype"");
}",1,1,lib/checksizeof.cpp,"CheckSizeof.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,520,535,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669151929,METHOD,lib/checksizeof.h:<global>,TYPE_DECL,<global>,1,1,lib/checksizeof.h,lib/checksizeof.h:<global>,<empty>,,false,1,112,<global>,,,1,
111669151930,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static bool isElementAccessYield(Library::Container::Yield yield)
{
    return contains({Library::Container::Yield::ITEM, Library::Container::Yield::AT_INDEX}, yield);
}",1,1,lib/checkstl.cpp,isElementAccessYield:bool(Library.Container.Yield),<empty>,,false,68,71,isElementAccessYield,,,1,bool(Library.Container.Yield)
111669151931,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,<global>,1,1,lib/checkstl.cpp,lib/checkstl.cpp:<global>,<empty>,,false,1,3484,<global>,,,1,
111669151932,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static bool containerAppendsElement(const Library::Container* container, const Token* parent)
{
    if (Token::Match(parent, "". %name% ("")) {
        const Library::Container::Action action = container->getAction(parent->strAt(1));
        if (contains({Library::Container::Action::INSERT,
                      Library::Container::Action::APPEND,
                      Library::Container::Action::CHANGE,
                      Library::Container::Action::CHANGE_INTERNAL,
                      Library::Container::Action::PUSH,
                      Library::Container::Action::RESIZE},
                     action))
            return true;
    }
    return false;
}",1,1,lib/checkstl.cpp,"containerAppendsElement:bool(Library.Container*,Token*)",<empty>,,false,73,87,containerAppendsElement,,,1,"bool(Library.Container*,Token*)"
111669151933,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static bool containerYieldsElement(const Library::Container* container, const Token* parent)
{
    if (Token::Match(parent, "". %name% ("")) {
        const Library::Container::Yield yield = container->getYield(parent->strAt(1));
        if (isElementAccessYield(yield))
            return true;
    }
    return false;
}",1,1,lib/checkstl.cpp,"containerYieldsElement:bool(Library.Container*,Token*)",<empty>,,false,89,97,containerYieldsElement,,,1,"bool(Library.Container*,Token*)"
111669151934,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static bool containerPopsElement(const Library::Container* container, const Token* parent)
{
    if (Token::Match(parent, "". %name% ("")) {
        const Library::Container::Action action = container->getAction(parent->strAt(1));
        if (contains({ Library::Container::Action::POP }, action))
            return true;
    }
    return false;
}",1,1,lib/checkstl.cpp,"containerPopsElement:bool(Library.Container*,Token*)",<empty>,,false,99,107,containerPopsElement,,,1,"bool(Library.Container*,Token*)"
111669151935,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static const Token* getContainerIndex(const Library::Container* container, const Token* parent)
{
    if (Token::Match(parent, "". %name% ("")) {
        const Library::Container::Yield yield = container->getYield(parent->strAt(1));
        if (yield == Library::Container::Yield::AT_INDEX && !Token::simpleMatch(parent->tokAt(2), ""( )""))
            return parent->tokAt(2)->astOperand2();
    }
    if (!container->arrayLike_indexOp && !container->stdStringLike)
        return nullptr;
    if (Token::simpleMatch(parent, ""[""))
        return parent->astOperand2();
    return nullptr;
}",1,1,lib/checkstl.cpp,"getContainerIndex:Token*(Library.Container*,Token*)",<empty>,,false,109,121,getContainerIndex,,,1,"Token*(Library.Container*,Token*)"
111669151936,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static const Token* getContainerFromSize(const Library::Container* container, const Token* tok)
{
    if (!tok)
        return nullptr;
    if (Token::Match(tok->tokAt(-2), "". %name% ("")) {
        const Library::Container::Yield yield = container->getYield(tok->strAt(-1));
        if (yield == Library::Container::Yield::SIZE)
            return tok->tokAt(-2)->astOperand1();
    }
    return nullptr;
}",1,1,lib/checkstl.cpp,"getContainerFromSize:Token*(Library.Container*,Token*)",<empty>,,false,123,133,getContainerFromSize,,,1,"Token*(Library.Container*,Token*)"
111669151937,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
                    if (!v.isSymbolicValue())
                        return false;
                    if (v.isImpossible())
                        return false;
                    if (v.intvalue < 0)
                        return false;
                    const Token* sizeTok = v.tokvalue;
                    if (sizeTok && sizeTok->isCast())
                        sizeTok = sizeTok->astOperand2() ? sizeTok->astOperand2() : sizeTok->astOperand1();
                    const Token* containerTok = getContainerFromSize(container, sizeTok);
                    if (!containerTok)
                        return false;
                    return containerTok->exprId() == tok->exprId();
                }",74,17,lib/checkstl.cpp,lib/checkstl.cpp:<global>.CheckStl.outOfBounds.<lambda>0:bool(ValueFlow.Value&),<empty>,,false,183,197,<lambda>0,,,1,bool(ValueFlow.Value&)
111669151938,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::outOfBounds()
{
    logChecker(""CheckStl::outOfBounds"");

    for (const Scope *function : mTokenizer->getSymbolDatabase()->functionScopes) {
        for (const Token *tok = function->bodyStart; tok != function->bodyEnd; tok = tok->next()) {
            const Library::Container *container = getLibraryContainer(tok);
            if (!container || container->stdAssociativeLike)
                continue;
            const Token * parent = astParentSkipParens(tok);
            const Token* accessTok = parent;
            if (Token::simpleMatch(accessTok, ""."") && Token::simpleMatch(accessTok->astParent(), ""(""))
                accessTok = accessTok->astParent();
            if (astIsIterator(accessTok) && Token::simpleMatch(accessTok->astParent(), ""+""))
                accessTok = accessTok->astParent();
            const Token* indexTok = getContainerIndex(container, parent);
            if (indexTok == tok)
                continue;
            for (const ValueFlow::Valu...",1,1,lib/checkstl.cpp,CheckStl.outOfBounds:void(),<empty>,,false,135,204,outOfBounds,,,1,void()
111669151939,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static std::string indexValueString(const ValueFlow::Value& indexValue, const std::string& containerName = emptyString)
{
    if (indexValue.isIteratorStartValue())
        return ""at position "" + MathLib::toString(indexValue.intvalue) + "" from the beginning"";
    if (indexValue.isIteratorEndValue())
        return ""at position "" + MathLib::toString(-indexValue.intvalue) + "" from the end"";
    std::string indexString = MathLib::toString(indexValue.intvalue);
    if (indexValue.isSymbolicValue()) {
        indexString = containerName + "".size()"";
        if (indexValue.intvalue != 0)
            indexString += ""+"" + MathLib::toString(indexValue.intvalue);
    }
    if (indexValue.bound == ValueFlow::Value::Bound::Lower)
        return ""greater or equal to "" + indexString;
    return indexString;
}",1,1,lib/checkstl.cpp,"indexValueString:string(ValueFlow.Value&,std.string&)",<empty>,,false,206,221,indexValueString,,,1,"string(ValueFlow.Value&,std.string&)"
111669151940,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::outOfBoundsError(const Token *tok, const std::string &containerName, const ValueFlow::Value *containerSize, const std::string &index, const ValueFlow::Value *indexValue)
{
    // Do not warn if both the container size and index value are possible
    if (containerSize && indexValue && containerSize->isPossible() && indexValue->isPossible())
        return;

    const std::string expression = tok ? tok->expressionString() : (containerName+""[x]"");

    std::string errmsg;
    if (!containerSize) {
        if (indexValue && indexValue->condition)
            errmsg = ValueFlow::eitherTheConditionIsRedundant(indexValue->condition) + "" or '"" + index +
                     ""' can have the value "" + indexValueString(*indexValue, containerName) + "". Expression '"" +
                     expression + ""' causes access out of bounds."";
        else
            errmsg = ""Out of bounds access in expression '"" + expression + ""'"";
    } else if (containerSize->intvalue == 0) {
      ...",1,1,lib/checkstl.cpp,"CheckStl.outOfBoundsError:void(Token*,std.string&,ValueFlow.Value*,std.string&,ValueFlow.Value*)",<empty>,,false,223,280,outOfBoundsError,,,1,"void(Token*,std.string&,ValueFlow.Value*,std.string&,ValueFlow.Value*)"
111669151941,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"bool CheckStl::isContainerSize(const Token *containerToken, const Token *expr) const
{
    if (!Token::simpleMatch(expr, ""( )""))
        return false;
    if (!Token::Match(expr->astOperand1(), "". %name% (""))
        return false;
    if (!isSameExpression(false, containerToken, expr->astOperand1()->astOperand1(), *mSettings, false, false))
        return false;
    return containerToken->valueType()->container->getYield(expr->strAt(-1)) == Library::Container::Yield::SIZE;
}",1,1,lib/checkstl.cpp,"CheckStl.isContainerSize<const>:bool(Token*,Token*)",<empty>,,false,282,291,isContainerSize,,,1,"bool(Token*,Token*)"
111669151942,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"bool CheckStl::isContainerSizeGE(const Token * containerToken, const Token *expr) const
{
    if (!expr)
        return false;
    if (isContainerSize(containerToken, expr))
        return true;
    if (expr->str() == ""*"") {
        const Token *mul;
        if (isContainerSize(containerToken, expr->astOperand1()))
            mul = expr->astOperand2();
        else if (isContainerSize(containerToken, expr->astOperand2()))
            mul = expr->astOperand1();
        else
            return false;
        return mul && (!mul->hasKnownIntValue() || mul->getKnownIntValue() != 0);
    }
    if (expr->str() == ""+"") {
        const Token *op;
        if (isContainerSize(containerToken, expr->astOperand1()))
            op = expr->astOperand2();
        else if (isContainerSize(containerToken, expr->astOperand2()))
            op = expr->astOperand1();
        else
            return false;
        return op && op->getValueGE(0, *mSettings);
    }
    return false;
}",1,1,lib/checkstl.cpp,"CheckStl.isContainerSizeGE<const>:bool(Token*,Token*)",<empty>,,false,293,320,isContainerSizeGE,,,1,"bool(Token*,Token*)"
111669151943,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::outOfBoundsIndexExpression()
{
    logChecker(""CheckStl::outOfBoundsIndexExpression"");
    for (const Scope *function : mTokenizer->getSymbolDatabase()->functionScopes) {
        for (const Token *tok = function->bodyStart; tok != function->bodyEnd; tok = tok->next()) {
            if (!tok->isName() || !tok->valueType())
                continue;
            const Library::Container *container = tok->valueType()->container;
            if (!container)
                continue;
            if (!container->arrayLike_indexOp && !container->stdStringLike)
                continue;
            if (!Token::Match(tok, ""%name% [""))
                continue;
            if (isContainerSizeGE(tok, tok->next()->astOperand2()))
                outOfBoundsIndexExpressionError(tok, tok->next()->astOperand2());
        }
    }
}",1,1,lib/checkstl.cpp,CheckStl.outOfBoundsIndexExpression:void(),<empty>,,false,322,340,outOfBoundsIndexExpression,,,1,void()
111669151944,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::outOfBoundsIndexExpressionError(const Token *tok, const Token *index)
{
    const std::string varname = tok ? tok->str() : std::string(""var"");
    const std::string i = index ? index->expressionString() : (varname + "".size()"");

    std::string errmsg = ""Out of bounds access of $symbol, index '"" + i + ""' is out of bounds."";

    reportError(tok,
                Severity::error,
                ""containerOutOfBoundsIndexExpression"",
                ""$symbol:"" + varname +""\\n"" + errmsg,
                CWE398,
                Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.outOfBoundsIndexExpressionError:void(Token*,Token*)",<empty>,,false,342,355,outOfBoundsIndexExpressionError,,,1,"void(Token*,Token*)"
111669151945,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::invalidIteratorError(const Token *tok, const std::string &iteratorName)
{
    reportError(tok, Severity::error, ""invalidIterator1"", ""$symbol:""+iteratorName+""\\nInvalid iterator: $symbol"", CWE664, Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.invalidIteratorError:void(Token*,std.string&)",<empty>,,false,360,363,invalidIteratorError,,,1,"void(Token*,std.string&)"
111669151946,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::iteratorsError(const Token* tok, const std::string& containerName1, const std::string& containerName2)
{
    reportError(tok, Severity::error, ""iterators1"",
                ""$symbol:"" + containerName1 + ""\\n""
                ""$symbol:"" + containerName2 + ""\\n""
                ""Same iterator is used with different containers '"" + containerName1 + ""' and '"" + containerName2 + ""'."", CWE664, Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.iteratorsError:void(Token*,std.string&,std.string&)",<empty>,,false,365,371,iteratorsError,,,1,"void(Token*,std.string&,std.string&)"
111669151947,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::iteratorsError(const Token* tok, const Token* containerTok, const std::string& containerName1, const std::string& containerName2)
{
    std::list<const Token*> callstack = { tok, containerTok };
    reportError(callstack, Severity::error, ""iterators2"",
                ""$symbol:"" + containerName1 + ""\\n""
                ""$symbol:"" + containerName2 + ""\\n""
                ""Same iterator is used with different containers '"" + containerName1 + ""' and '"" + containerName2 + ""'."", CWE664, Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.iteratorsError:void(Token*,Token*,std.string&,std.string&)",<empty>,,false,373,380,iteratorsError,,,1,"void(Token*,Token*,std.string&,std.string&)"
111669151948,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::iteratorsError(const Token* tok, const Token* containerTok, const std::string& containerName)
{
    std::list<const Token*> callstack = { tok, containerTok };
    reportError(callstack,
                Severity::error,
                ""iterators3"",
                ""$symbol:"" + containerName +
                ""\\n""
                ""Same iterator is used with containers '$symbol' that are temporaries or defined in different scopes."",
                CWE664,
                Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.iteratorsError:void(Token*,Token*,std.string&)",<empty>,,false,382,393,iteratorsError,,,1,"void(Token*,Token*,std.string&)"
111669151949,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::dereferenceErasedError(const Token *erased, const Token* deref, const std::string &itername, bool inconclusive)
{
    if (erased) {
        std::list<const Token*> callstack = { deref, erased };
        reportError(callstack, Severity::error, ""eraseDereference"",
                    ""$symbol:"" + itername + ""\\n""
                    ""Iterator '$symbol' used after element has been erased.\\n""
                    ""The iterator '$symbol' is invalid after the element it pointed to has been erased. ""
                    ""Dereferencing or comparing it with another iterator is invalid operation."", CWE664, inconclusive ? Certainty::inconclusive : Certainty::normal);
    } else {
        reportError(deref, Severity::error, ""eraseDereference"",
                    ""$symbol:"" + itername + ""\\n""
                    ""Invalid iterator '$symbol' used.\\n""
                    ""The iterator '$symbol' is invalid before being assigned. ""
                    ""Dereferencing or comparing it with ...",1,1,lib/checkstl.cpp,"CheckStl.dereferenceErasedError:void(Token*,Token*,std.string&,bool)",<empty>,,false,396,412,dereferenceErasedError,,,1,"void(Token*,Token*,std.string&,bool)"
111669151950,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static const Token *skipMembers(const Token *tok)
{
    while (Token::Match(tok, ""%name% .""))
        tok = tok->tokAt(2);
    return tok;
}",1,1,lib/checkstl.cpp,skipMembers:Token*(Token*),<empty>,,false,414,419,skipMembers,,,1,Token*(Token*)
111669151951,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static bool isIterator(const Variable *var, bool& inconclusiveType)
{
    // Check that its an iterator
    if (!var || !var->isLocal() || !Token::Match(var->typeEndToken(), ""iterator|const_iterator|reverse_iterator|const_reverse_iterator|auto""))
        return false;

    inconclusiveType = false;
    if (var->typeEndToken()->str() == ""auto"")
        return (var->nameToken()->valueType() && var->nameToken()->valueType()->type == ValueType::Type::ITERATOR);

    if (var->type()) { // If it is defined, ensure that it is defined like an iterator
        // look for operator* and operator++
        const Function* end = var->type()->getFunction(""operator*"");
        const Function* incOperator = var->type()->getFunction(""operator++"");
        if (!end || end->argCount() > 0 || !incOperator)
            return false;

        inconclusiveType = true; // heuristics only
    }

    return true;
}",1,1,lib/checkstl.cpp,"isIterator:bool(Variable*,bool&)",<empty>,,false,421,442,isIterator,,,1,"bool(Variable*,bool&)"
111669151952,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static std::string getContainerName(const Token *containerToken)
{
    if (!containerToken)
        return std::string();
    std::string ret(containerToken->str());
    for (const Token *nametok = containerToken; nametok; nametok = nametok->tokAt(-2)) {
        if (!Token::Match(nametok->tokAt(-2), ""%name% .""))
            break;
        ret = nametok->strAt(-2) + '.' + ret;
    }
    return ret;
}",1,1,lib/checkstl.cpp,getContainerName:string(Token*),<empty>,,false,444,455,getContainerName,,,1,string(Token*)
111669151953,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static bool isVector(const Token* tok)
{
    if (!tok)
        return false;
    const Variable *var = tok->variable();
    const Token *decltok = var ? var->typeStartToken() : nullptr;
    return Token::simpleMatch(decltok, ""std :: vector"");
}",1,1,lib/checkstl.cpp,isVector:bool(Token*),<empty>,,false,457,464,isVector,,,1,bool(Token*)
111669151954,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::iterators()
{
    logChecker(""CheckStl::iterators"");

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    // Filling map of iterators id and their scope begin
    std::map<int, const Token*> iteratorScopeBeginInfo;
    for (const Variable* var : symbolDatabase->variableList()) {
        bool inconclusiveType=false;
        if (!isIterator(var, inconclusiveType))
            continue;
        const int iteratorId = var->declarationId();
        if (iteratorId != 0)
            iteratorScopeBeginInfo[iteratorId] = var->nameToken();
    }

    for (const Variable* var : symbolDatabase->variableList()) {
        bool inconclusiveType=false;
        if (!isIterator(var, inconclusiveType))
            continue;
        if (inconclusiveType && !mSettings->certainty.isEnabled(Certainty::inconclusive))
            continue;

        const int iteratorId = var->declarationId();

        // the validIterator flag says if the iterator has a valid valu...",1,1,lib/checkstl.cpp,CheckStl.iterators:void(),<empty>,,false,466,649,iterators,,,1,void()
111669151955,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::mismatchingContainerIteratorError(const Token* containerTok, const Token* iterTok, const Token* containerTok2)
{
    const std::string container(containerTok ? containerTok->expressionString() : std::string(""v1""));
    const std::string container2(containerTok2 ? containerTok2->expressionString() : std::string(""v2""));
    const std::string iter(iterTok ? iterTok->expressionString() : std::string(""it""));
    reportError(containerTok,
                Severity::error,
                ""mismatchingContainerIterator"",
                ""Iterator '"" + iter + ""' referring to container '"" + container2 + ""' is used with container '"" + container + ""'."",
                CWE664,
                Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.mismatchingContainerIteratorError:void(Token*,Token*,Token*)",<empty>,,false,651,662,mismatchingContainerIteratorError,,,1,"void(Token*,Token*,Token*)"
111669151956,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::mismatchingContainersError(const Token* tok1, const Token* tok2)
{
    const std::string expr1(tok1 ? tok1->expressionString() : std::string(""v1""));
    const std::string expr2(tok2 ? tok2->expressionString() : std::string(""v2""));
    reportError(tok1,
                Severity::error,
                ""mismatchingContainers"",
                ""Iterators of different containers '"" + expr1 + ""' and '"" + expr2 + ""' are used together."",
                CWE664,
                Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.mismatchingContainersError:void(Token*,Token*)",<empty>,,false,665,675,mismatchingContainersError,,,1,"void(Token*,Token*)"
111669151957,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::mismatchingContainerExpressionError(const Token *tok1, const Token *tok2)
{
    const std::string expr1(tok1 ? tok1->expressionString() : std::string(""v1""));
    const std::string expr2(tok2 ? tok2->expressionString() : std::string(""v2""));
    reportError(tok1, Severity::warning, ""mismatchingContainerExpression"",
                ""Iterators to containers from different expressions '"" +
                expr1 + ""' and '"" + expr2 + ""' are used together."", CWE664, Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.mismatchingContainerExpressionError:void(Token*,Token*)",<empty>,,false,677,684,mismatchingContainerExpressionError,,,1,"void(Token*,Token*)"
111669151958,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::sameIteratorExpressionError(const Token *tok)
{
    reportError(tok, Severity::style, ""sameIteratorExpression"", ""Same iterators expression are used for algorithm."", CWE664, Certainty::normal);
}",1,1,lib/checkstl.cpp,CheckStl.sameIteratorExpressionError:void(Token*),<empty>,,false,686,689,sameIteratorExpressionError,,,1,void(Token*)
111669151959,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static std::vector<const Token*> getAddressContainer(const Token* tok)
{
    if (Token::simpleMatch(tok, ""["") && tok->astOperand1())
        return { tok->astOperand1() };
    while (Token::simpleMatch(tok, ""::"") && tok->astOperand2())
        tok = tok->astOperand2();
    std::vector<ValueFlow::Value> values = ValueFlow::getLifetimeObjValues(tok, /*inconclusive*/ false);
    std::vector<const Token*> res;
    for (const auto& v : values) {
        if (v.tokvalue)
            res.emplace_back(v.tokvalue);
    }
    if (res.empty())
        res.emplace_back(tok);
    return res;
}",1,1,lib/checkstl.cpp,getAddressContainer:vector<constToken*>(Token*),<empty>,,false,691,706,getAddressContainer,,,1,vector<const Token*>(Token*)
111669151960,METHOD,<empty>,<empty>,"[&](const Token* tok2) {
                return isSameExpression(false, tok1, tok2, settings, false, false);
            }",66,13,lib/checkstl.cpp,lib/checkstl.cpp:<global>.isSameIteratorContainerExpression.<lambda>1.<lambda>2:bool(Token*),<empty>,,false,722,724,<lambda>2,,,1,bool(Token*)
111669151961,METHOD,<empty>,<empty>,"[&](const Token* tok1) {
            return std::any_of(address2.begin(), address2.end(), [&](const Token* tok2) {
                return isSameExpression(false, tok1, tok2, settings, false, false);
            });
        }",62,9,lib/checkstl.cpp,lib/checkstl.cpp:<global>.isSameIteratorContainerExpression.<lambda>1:ANY(Token*),<empty>,,false,721,725,<lambda>1,,,1,ANY(Token*)
111669151962,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static bool isSameIteratorContainerExpression(const Token* tok1,
                                              const Token* tok2,
                                              const Settings& settings,
                                              ValueFlow::Value::LifetimeKind kind = ValueFlow::Value::LifetimeKind::Iterator)
{
    if (isSameExpression(false, tok1, tok2, settings, false, false)) {
        return !astIsContainerOwned(tok1) || !isTemporary(tok1, &settings.library);
    }
    if (astContainerYield(tok2) == Library::Container::Yield::ITEM)
        return true;
    if (kind == ValueFlow::Value::LifetimeKind::Address || kind == ValueFlow::Value::LifetimeKind::Iterator) {
        const auto address1 = getAddressContainer(tok1);
        const auto address2 = getAddressContainer(tok2);
        return std::any_of(address1.begin(), address1.end(), [&](const Token* tok1) {
            return std::any_of(address2.begin(), address2.end(), [&](const Token* tok2) {
                ...",1,1,lib/checkstl.cpp,"isSameIteratorContainerExpression:bool(Token*,Token*,Settings&,ValueFlow.Value.LifetimeKind)",<empty>,,false,708,728,isSameIteratorContainerExpression,,,1,"bool(Token*,Token*,Settings&,ValueFlow.Value.LifetimeKind)"
111669151963,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
            const Token* tok2 = v.tokvalue;
            return start->lifetimeKind == v.lifetimeKind && (astHasToken(tok1, tok2) || astHasToken(tok2, tok1));
        }",58,9,lib/checkstl.cpp,lib/checkstl.cpp:<global>.pruneLifetimes:vector<ValueFlow.Value>(std.vector<ValueFlow.Value>).<lambda>3:bool(ValueFlow.Value&),<empty>,,false,739,742,<lambda>3,,,1,bool(ValueFlow.Value&)
111669151964,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& x, const ValueFlow::Value& y) {
            return x.tokvalue != y.tokvalue && astHasToken(x.tokvalue, y.tokvalue);
        }",49,9,lib/checkstl.cpp,"lib/checkstl.cpp:<global>.pruneLifetimes:vector<ValueFlow.Value>(std.vector<ValueFlow.Value>).<lambda>4:bool(ValueFlow.Value&,ValueFlow.Value&)",<empty>,,false,743,745,<lambda>4,,,1,"bool(ValueFlow.Value&,ValueFlow.Value&)"
111669151965,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static std::vector<ValueFlow::Value> pruneLifetimes(std::vector<ValueFlow::Value> lifetimes)
{
    std::vector<ValueFlow::Value> result;
    auto start = lifetimes.begin();
    while (start != lifetimes.end())
    {
        const Token* tok1 = start->tokvalue;
        auto it = std::partition(start, lifetimes.end(), [&](const ValueFlow::Value& v) {
            const Token* tok2 = v.tokvalue;
            return start->lifetimeKind == v.lifetimeKind && (astHasToken(tok1, tok2) || astHasToken(tok2, tok1));
        });
        auto root = std::min_element(start, it, [](const ValueFlow::Value& x, const ValueFlow::Value& y) {
            return x.tokvalue != y.tokvalue && astHasToken(x.tokvalue, y.tokvalue);
        });
        result.push_back(*root);
        start = it;
    }
    return result;
}",1,1,lib/checkstl.cpp,pruneLifetimes:vector<ValueFlow.Value>(std.vector<ValueFlow.Value>),<empty>,,false,732,750,pruneLifetimes,,,1,vector<ValueFlow::Value>(std.vector<ValueFlow.Value>)
111669151966,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
            return v.lifetimeKind == ValueFlow::Value::LifetimeKind::Iterator;
        }",49,9,lib/checkstl.cpp,lib/checkstl.cpp:<global>.getLifetimeIteratorValue.<lambda>5.<lambda>6:bool(ValueFlow.Value&),<empty>,,false,755,757,<lambda>6,,,1,bool(ValueFlow.Value&)
111669151967,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& values, const std::vector<ValueFlow::Value>::const_iterator beg) {
        return std::find_if(beg, values.cend(), [](const ValueFlow::Value& v) {
            return v.lifetimeKind == ValueFlow::Value::LifetimeKind::Iterator;
        });
    }",24,5,lib/checkstl.cpp,"lib/checkstl.cpp:<global>.getLifetimeIteratorValue.<lambda>5:ANY(std.vector<ValueFlow.Value>&,std.vector<ValueFlow.Value>.const_iterator)",<empty>,,false,754,758,<lambda>5,,,1,"ANY(std.vector<ValueFlow.Value>&,std.vector<ValueFlow.Value>.const_iterator)"
111669151968,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static ValueFlow::Value getLifetimeIteratorValue(const Token* tok, MathLib::bigint path = 0)
{
    auto findIterVal = [](const std::vector<ValueFlow::Value>& values, const std::vector<ValueFlow::Value>::const_iterator beg) {
        return std::find_if(beg, values.cend(), [](const ValueFlow::Value& v) {
            return v.lifetimeKind == ValueFlow::Value::LifetimeKind::Iterator;
        });
    };
    std::vector<ValueFlow::Value> values = pruneLifetimes(ValueFlow::getLifetimeObjValues(tok, false, path));
    auto it = findIterVal(values, values.begin());
    if (it != values.end()) {
        auto it2 = findIterVal(values, it + 1);
        if (it2 == values.cend())
            return *it;
    }
    if (values.size() == 1)
        return values.front();
    return ValueFlow::Value{};
}",1,1,lib/checkstl.cpp,"getLifetimeIteratorValue:ValueFlow.Value(Token*,MathLib.bigint)",<empty>,,false,752,769,getLifetimeIteratorValue,,,1,"ValueFlow.Value(Token*,MathLib.bigint)"
111669151969,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"bool CheckStl::checkIteratorPair(const Token* tok1, const Token* tok2)
{
    if (!tok1)
        return false;
    if (!tok2)
        return false;
    ValueFlow::Value val1 = getLifetimeIteratorValue(tok1);
    ValueFlow::Value val2 = getLifetimeIteratorValue(tok2);
    if (val1.tokvalue && val2.tokvalue && val1.lifetimeKind == val2.lifetimeKind) {
        if (val1.lifetimeKind == ValueFlow::Value::LifetimeKind::Lambda)
            return false;
        if (tok1->astParent() == tok2->astParent() && Token::Match(tok1->astParent(), ""%comp%|-"")) {
            if (val1.lifetimeKind == ValueFlow::Value::LifetimeKind::Address)
                return false;
            if (val1.lifetimeKind == ValueFlow::Value::LifetimeKind::Object &&
                (!astIsContainer(val1.tokvalue) || !astIsContainer(val2.tokvalue)))
                return false;
        }
        if (isSameIteratorContainerExpression(val1.tokvalue, val2.tokvalue, *mSettings, val1.lifetimeKind))
            return false;
 ...",1,1,lib/checkstl.cpp,"CheckStl.checkIteratorPair:bool(Token*,Token*)",<empty>,,false,771,814,checkIteratorPair,,,1,"bool(Token*,Token*)"
111669151970,METHOD,<empty>,<empty>,"[&] {
                for (const auto& p : containers)
                {
                    const std::vector<ArgIteratorInfo>& cargs = p.second;
                    for (ArgIteratorInfo iter1 : cargs) {
                        for (ArgIteratorInfo iter2 : cargs) {
                            if (iter1.tok == iter2.tok)
                                continue;
                            if (iter1.info->first && iter2.info->last &&
                                isSameExpression(false, iter1.tok, iter2.tok, *mSettings, false, false))
                                sameIteratorExpressionError(iter1.tok);
                            if (checkIteratorPair(iter1.tok, iter2.tok))
                                return;
                        }
                    }
                }
            }",13,13,lib/checkstl.cpp,lib/checkstl.cpp:<global>.CheckStl.mismatchingContainers.<lambda>7:void(),<empty>,,false,854,870,<lambda>7,,,1,void()
111669151971,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::mismatchingContainers()
{
    logChecker(""CheckStl::misMatchingContainers"");

    // Check if different containers are used in various calls of standard functions
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (Token::Match(tok, ""%comp%|-"")) {
                if (checkIteratorPair(tok->astOperand1(), tok->astOperand2()))
                    continue;
            }
            if (!Token::Match(tok, ""%name% ( !!)""))
                continue;
            const Token * const ftok = tok;

            const std::vector<const Token *> args = getArguments(ftok);
            if (args.size() < 2)
                continue;

            // Group args together by container
            std::map<int, std::vector<ArgIteratorInfo>> containers;
            for (int argnr = 1; a...",1,1,lib/checkstl.cpp,CheckStl.mismatchingContainers:void(),<empty>,,false,823,881,mismatchingContainers,,,1,void()
111669151972,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::mismatchingContainerIterator()
{
    logChecker(""CheckStl::misMatchingContainerIterator"");

    // Check if different containers are used in various calls of standard functions
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!astIsContainer(tok))
                continue;
            if (!astIsLHS(tok))
                continue;
            if (!Token::Match(tok->astParent(), "". %name% ( !!)""))
                continue;
            const Token* const ftok = tok->astParent()->next();
            const std::vector<const Token *> args = getArguments(ftok);

            const Library::Container * c = tok->valueType()->container;
            const Library::Container::Action action = c->getAction(tok->strAt(2));
            const Token* iterTok = nullptr;
           ...",1,1,lib/checkstl.cpp,CheckStl.mismatchingContainerIterator:void(),<empty>,,false,883,932,mismatchingContainerIterator,,,1,void()
111669151973,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static const Token* getInvalidMethod(const Token* tok)
{
    if (!astIsLHS(tok))
        return nullptr;
    if (Token::Match(tok->astParent(), "". assign|clear|swap""))
        return tok->astParent()->next();
    if (Token::Match(tok->astParent(), ""%assign%""))
        return tok->astParent();
    const Token* ftok = nullptr;
    if (Token::Match(tok->astParent(), "". %name% (""))
        ftok = tok->astParent()->next();
    if (!ftok)
        return nullptr;
    if (const Library::Container * c = tok->valueType()->container) {
        const Library::Container::Action action = c->getAction(ftok->str());
        if (c->unstableErase) {
            if (action == Library::Container::Action::ERASE)
                return ftok;
        }
        if (c->unstableInsert) {
            if (action == Library::Container::Action::RESIZE)
                return ftok;
            if (action == Library::Container::Action::CLEAR)
                return ftok;
            if (action == Library::Containe...",1,1,lib/checkstl.cpp,getInvalidMethod:Token*(Token*),<empty>,,false,934,973,getInvalidMethod,,,1,Token*(Token*)
111669151974,METHOD,InvalidContainerAnalyzer.Info,TYPE_DECL,"void add(const std::vector<Reference>& refs) {
                for (const Reference& r : refs) {
                    add(r);
                }
            }",13,13,lib/checkstl.cpp,InvalidContainerAnalyzer.Info.add:void(std.vector<Reference>&),<empty>,,false,985,989,add,,,3,void(std.vector<Reference>&)
111669151975,METHOD,InvalidContainerAnalyzer.Info,TYPE_DECL,"void add(const Reference& r) {
                if (!r.tok)
                    return;
                expressions.emplace(r.tok->exprId(), r);
            }",13,13,lib/checkstl.cpp,InvalidContainerAnalyzer.Info.add:void(InvalidContainerAnalyzer.Info.Reference&),<empty>,,false,990,994,add,,,4,void(InvalidContainerAnalyzer.Info.Reference&)
111669151976,METHOD,InvalidContainerAnalyzer.Info,TYPE_DECL,"std::vector<Reference> invalidTokens() const {
                std::vector<Reference> result;
                std::transform(expressions.cbegin(), expressions.cend(), std::back_inserter(result), SelectMapValues{});
                return result;
            }",13,13,lib/checkstl.cpp,InvalidContainerAnalyzer.Info.invalidTokens<const>:vector<Reference>(),<empty>,,false,996,1000,invalidTokens,,,5,vector<Reference>()
111669151977,METHOD,<empty>,<empty>,"[&](const Info::Reference& r) {
                        const Variable* var = r.tok->variable();
                        if (!var)
                            return false;
                        if (dependsOnThis && !var->isLocal() && !var->isGlobal() && !var->isStatic())
                            return true;
                        if (!var->isArgument())
                            return false;
                        if (!var->isReference())
                            return false;
                        return true;
                    }",90,21,lib/checkstl.cpp,lib/checkstl.cpp:<global>.InvalidContainerAnalyzer.invalidatesContainer<const>:vector<Info.Reference>(Token*).<lambda>8:bool(InvalidContainerAnalyzer.Info.Reference&),<empty>,,false,1015,1026,<lambda>8,,,1,bool(InvalidContainerAnalyzer.Info.Reference&)
111669151978,METHOD,InvalidContainerAnalyzer,TYPE_DECL,"std::vector<Info::Reference> invalidatesContainer(const Token* tok) const {
            std::vector<Info::Reference> result;
            if (Token::Match(tok, ""%name% ("")) {
                const Function* f = tok->function();
                if (!f)
                    return result;
                ErrorPathItem epi = std::make_pair(tok, ""Calling function "" + tok->str());
                const bool dependsOnThis = exprDependsOnThis(tok->next());
                auto it = invalidMethods.find(f);
                if (it != invalidMethods.end()) {
                    std::vector<Info::Reference> refs = it->second.invalidTokens();
                    std::copy_if(refs.cbegin(), refs.cend(), std::back_inserter(result), [&](const Info::Reference& r) {
                        const Variable* var = r.tok->variable();
                        if (!var)
                            return false;
                        if (dependsOnThis && !var->isLocal() && !var->isGlobal() && !var->isStatic(...",9,9,lib/checkstl.cpp,InvalidContainerAnalyzer.invalidatesContainer<const>:vector<Info.Reference>(Token*),<empty>,,false,1004,1054,invalidatesContainer,,,3,vector<Info::Reference>(Token*)
111669151979,METHOD,InvalidContainerAnalyzer,TYPE_DECL,"void analyze(const SymbolDatabase* symboldatabase) {
            for (const Scope* scope : symboldatabase->functionScopes) {
                const Function* f = scope->function;
                if (!f)
                    continue;
                for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
                    if (Token::Match(tok, ""if|while|for|goto|return""))
                        break;
                    std::vector<Info::Reference> c = invalidatesContainer(tok);
                    if (c.empty())
                        continue;
                    invalidMethods[f].add(c);
                }
            }
        }",9,9,lib/checkstl.cpp,InvalidContainerAnalyzer.analyze:void(SymbolDatabase*),<empty>,,false,1056,1070,analyze,,,4,void(SymbolDatabase*)
111669151980,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static const Token* getLoopContainer(const Token* tok)
{
    if (!Token::simpleMatch(tok, ""for (""))
        return nullptr;
    const Token* sepTok = tok->next()->astOperand2();
    if (!Token::simpleMatch(sepTok, "":""))
        return nullptr;
    return sepTok->astOperand2();
}",1,1,lib/checkstl.cpp,getLoopContainer:Token*(Token*),<empty>,,false,1074,1082,getLoopContainer,,,1,Token*(Token*)
111669151981,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static const ValueFlow::Value* getInnerLifetime(const Token* tok,
                                                nonneg int id,
                                                ErrorPath* errorPath = nullptr,
                                                int depth = 4)
{
    if (depth < 0)
        return nullptr;
    if (!tok)
        return nullptr;
    for (const ValueFlow::Value& val : tok->values()) {
        if (!val.isLocalLifetimeValue())
            continue;
        if (contains({ValueFlow::Value::LifetimeKind::Address,
                      ValueFlow::Value::LifetimeKind::SubObject,
                      ValueFlow::Value::LifetimeKind::Lambda},
                     val.lifetimeKind)) {
            if (val.isInconclusive())
                return nullptr;
            if (val.capturetok)
                if (const ValueFlow::Value* v = getInnerLifetime(val.capturetok, id, errorPath, depth - 1))
                    return v;
            if (errorPath)
                errorPa...",1,48,lib/checkstl.cpp,"getInnerLifetime:ValueFlow.Value*(Token*,int,ErrorPath*,int)",<empty>,,false,1084,1118,getInnerLifetime,,,1,"ValueFlow.Value*(Token*,int,ErrorPath*,int)"
111669151982,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static const Token* endOfExpression(const Token* tok)
{
    if (!tok)
        return nullptr;
    const Token* parent = tok->astParent();
    while (Token::simpleMatch(parent, "".""))
        parent = parent->astParent();
    if (!parent)
        return tok->next();
    const Token* endToken = nextAfterAstRightmostLeaf(parent);
    if (!endToken)
        return parent->next();
    return endToken;
}",1,1,lib/checkstl.cpp,endOfExpression:Token*(Token*),<empty>,,false,1120,1133,endOfExpression,,,1,Token*(Token*)
111669151983,METHOD,<empty>,<empty>,"[&](const PathAnalysis::Info& info) {
                        if (!info.tok->variable())
                            return false;
                        if (info.tok->varId() == 0)
                            return false;
                        if (skipVarIds.count(info.tok->varId()) > 0)
                            return false;
                        // if (Token::simpleMatch(info.tok->next(), "".""))
                        // return false;
                        if (Token::Match(info.tok->astParent(), ""%assign%"") && astIsLHS(info.tok))
                            skipVarIds.insert(info.tok->varId());
                        if (info.tok->variable()->isReference() && !isVariableDecl(info.tok) &&
                            reaches(info.tok->variable()->nameToken(), tok, library, nullptr)) {

                            ErrorPath ep;
                            bool addressOf = false;
                            const Variable* var = ValueFlow::getLifetimeVariable(info.tok, ep...",69,21,lib/checkstl.cpp,lib/checkstl.cpp:<global>.CheckStl.invalidContainer.<lambda>9:bool(PathAnalysis.Info&),<empty>,,false,1192,1229,<lambda>9,,,1,bool(PathAnalysis.Info&)
111669151984,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::invalidContainer()
{
    logChecker(""CheckStl::invalidContainer"");
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    const Library& library = mSettings->library;
    InvalidContainerAnalyzer analyzer;
    analyzer.analyze(symbolDatabase);
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (const Token* contTok = getLoopContainer(tok)) {
                const Token* blockStart = tok->linkAt(1)->next();
                const Token* blockEnd = blockStart->link();
                if (contTok->exprId() == 0)
                    continue;
                if (!astIsContainer(contTok))
                    continue;
                for (const Token* tok2 = blockStart; tok2 != blockEnd; tok2 = tok2->next()) {
                    bool bail = false;
                    for (const InvalidContainerAnalyzer::Info::Reference&...",1,29,lib/checkstl.cpp,CheckStl.invalidContainer:void(),<empty>,,false,1135,1243,invalidContainer,,,1,void()
111669151985,METHOD,<empty>,<empty>,"[&](const ErrorPathItem& epi) {
        return epi.first == tok;
    }",25,5,lib/checkstl.cpp,lib/checkstl.cpp:<global>.CheckStl.invalidContainerLoopError.<lambda>10:bool(ErrorPathItem&),<empty>,,false,1251,1253,<lambda>10,,,1,bool(ErrorPathItem&)
111669151986,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::invalidContainerLoopError(const Token* tok, const Token* loopTok, ErrorPath errorPath)
{
    const std::string method = tok ? tok->str() : ""erase"";
    errorPath.emplace_back(loopTok, ""Iterating container here."");

    // Remove duplicate entries from error path
    errorPath.remove_if([&](const ErrorPathItem& epi) {
        return epi.first == tok;
    });

    const std::string msg = ""Calling '"" + method + ""' while iterating the container is invalid."";
    errorPath.emplace_back(tok, """");
    reportError(errorPath, Severity::error, ""invalidContainerLoop"", msg, CWE664, Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.invalidContainerLoopError:void(Token*,Token*,ErrorPath)",<empty>,,false,1245,1258,invalidContainerLoopError,,,1,"void(Token*,Token*,ErrorPath)"
111669151987,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::invalidContainerError(const Token *tok, const Token * /*contTok*/, const ValueFlow::Value *val, ErrorPath errorPath)
{
    const bool inconclusive = val ? val->isInconclusive() : false;
    if (val)
        errorPath.insert(errorPath.begin(), val->errorPath.cbegin(), val->errorPath.cend());
    std::string msg = ""Using "" + lifetimeMessage(tok, val, errorPath);
    errorPath.emplace_back(tok, """");
    reportError(errorPath, Severity::error, ""invalidContainer"", msg + "" that may be invalid."", CWE664, inconclusive ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.invalidContainerError:void(Token*,Token*,ValueFlow.Value*,ErrorPath)",<empty>,,false,1260,1268,invalidContainerError,,,1,"void(Token*,Token*,ValueFlow.Value*,ErrorPath)"
111669151988,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::invalidContainerReferenceError(const Token* tok, const Token* contTok, ErrorPath errorPath)
{
    std::string name = contTok ? contTok->expressionString() : ""x"";
    std::string msg = ""Reference to "" + name;
    errorPath.emplace_back(tok, """");
    reportError(errorPath, Severity::error, ""invalidContainerReference"", msg + "" that may be invalid."", CWE664, Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.invalidContainerReferenceError:void(Token*,Token*,ErrorPath)",<empty>,,false,1270,1276,invalidContainerReferenceError,,,1,"void(Token*,Token*,ErrorPath)"
111669151989,METHOD,<empty>,<empty>,"[&](const Token *cond) {
            if (Token::Match(cond, ""%oror%|&&""))
                return ChildrenToVisit::op1_and_op2;
            if (cond->isComparisonOp())
                conds.emplace_back(cond);
            return ChildrenToVisit::none;
        }",23,9,lib/checkstl.cpp,lib/checkstl.cpp:<global>.CheckStl.stlOutOfBounds.<lambda>11:ChildrenToVisit(Token*),<empty>,,false,1306,1312,<lambda>11,,,1,ChildrenToVisit(Token*)
111669151990,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::stlOutOfBounds()
{
    logChecker(""CheckStl::stlOutOfBounds"");

    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();

    // Scan through all scopes..
    for (const Scope &scope : symbolDatabase->scopeList) {
        const Token* tok = scope.classDef;
        // only interested in conditions
        if ((!scope.isLoopScope() && scope.type != ScopeType::eIf) || !tok)
            continue;

        const Token *condition = nullptr;
        if (scope.type == ScopeType::eFor) {
            if (Token::simpleMatch(tok->next()->astOperand2(), "";"") && Token::simpleMatch(tok->next()->astOperand2()->astOperand2(), "";""))
                condition = tok->next()->astOperand2()->astOperand2()->astOperand1();
        } else if (Token::simpleMatch(tok, ""do {"") && Token::simpleMatch(tok->linkAt(1), ""} while (""))
            condition = tok->linkAt(1)->tokAt(2)->astOperand2();
        else
            condition = tok->next()->astOperand2();

        if (!c...",1,1,lib/checkstl.cpp,CheckStl.stlOutOfBounds:void(),<empty>,,false,1278,1362,stlOutOfBounds,,,1,void()
111669151991,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::stlOutOfBoundsError(const Token *tok, const std::string &num, const std::string &var, bool at)
{
    if (at)
        reportError(tok, Severity::error, ""stlOutOfBounds"", ""$symbol:"" + var + ""\\nWhen "" + num + ""==$symbol.size(), $symbol.at("" + num + "") is out of bounds."", CWE788, Certainty::normal);
    else
        reportError(tok, Severity::error, ""stlOutOfBounds"", ""$symbol:"" + var + ""\\nWhen "" + num + ""==$symbol.size(), $symbol["" + num + ""] is out of bounds."", CWE788, Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.stlOutOfBoundsError:void(Token*,std.string&,std.string&,bool)",<empty>,,false,1364,1370,stlOutOfBoundsError,,,1,"void(Token*,std.string&,std.string&,bool)"
111669151992,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::negativeIndex()
{
    logChecker(""CheckStl::negativeIndex"");

    // Negative index is out of bounds..
    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!Token::Match(tok, ""%var% ["") || !tok->next()->astOperand2())
                continue;
            const Variable * const var = tok->variable();
            if (!var || tok == var->nameToken())
                continue;
            const Library::Container * const container = mSettings->library.detectContainer(var->typeStartToken());
            if (!container || !container->arrayLike_indexOp)
                continue;
            const ValueFlow::Value *index = tok->next()->astOperand2()->getValueLE(-1, *mSettings);
            if (!index)
                continue;
            negativeIndexError(tok, *ind...",1,1,lib/checkstl.cpp,CheckStl.negativeIndex:void(),<empty>,,false,1372,1394,negativeIndex,,,1,void()
111669151993,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::negativeIndexError(const Token *tok, const ValueFlow::Value &index)
{
    const ErrorPath errorPath = getErrorPath(tok, &index, ""Negative array index"");
    std::ostringstream errmsg;
    if (index.condition)
        errmsg << ValueFlow::eitherTheConditionIsRedundant(index.condition)
               << "", otherwise there is negative array index "" << index.intvalue << ""."";
    else
        errmsg << ""Array index "" << index.intvalue << "" is out of bounds."";
    const auto severity = index.errorSeverity() && index.isKnown() ? Severity::error : Severity::warning;
    const auto certainty = index.isInconclusive() ? Certainty::inconclusive : Certainty::normal;
    reportError(errorPath, severity, ""negativeContainerIndex"", errmsg.str(), CWE786, certainty);
}",1,1,lib/checkstl.cpp,"CheckStl.negativeIndexError:void(Token*,ValueFlow.Value&)",<empty>,,false,1396,1408,negativeIndexError,,,1,"void(Token*,ValueFlow.Value&)"
111669151994,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::erase()
{
    logChecker(""CheckStl::erase"");

    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope &scope : symbolDatabase->scopeList) {
        if (scope.type == ScopeType::eFor && Token::simpleMatch(scope.classDef, ""for ("")) {
            const Token *tok = scope.classDef->linkAt(1);
            if (!Token::Match(tok->tokAt(-3), ""; ++| %var% ++| ) {""))
                continue;
            tok = tok->previous();
            if (!tok->isName())
                tok = tok->previous();
            eraseCheckLoopVar(scope, tok->variable());
        } else if (scope.type == ScopeType::eWhile && Token::Match(scope.classDef, ""while ( %var% !="")) {
            eraseCheckLoopVar(scope, scope.classDef->tokAt(2)->variable());
        }
    }
}",1,1,lib/checkstl.cpp,CheckStl.erase:void(),<empty>,,false,1410,1429,erase,,,1,void()
111669151995,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::eraseCheckLoopVar(const Scope &scope, const Variable *var)
{
    bool inconclusiveType=false;
    if (!isIterator(var, inconclusiveType))
        return;
    for (const Token *tok = scope.bodyStart; tok != scope.bodyEnd; tok = tok->next()) {
        if (tok->str() != ""("")
            continue;
        if (!Token::Match(tok->tokAt(-2), "". erase ( ++| %varid% )"", var->declarationId()))
            continue;
        // Vector erases are handled by invalidContainer check
        if (isVector(tok->tokAt(-3)))
            continue;
        if (Token::Match(tok->astParent(), ""=|return""))
            continue;
        // Iterator is invalid..
        int indentlevel = 0U;
        const Token *tok2 = tok->link();
        for (; tok2 != scope.bodyEnd; tok2 = tok2->next()) {
            if (tok2->str() == ""{"") {
                ++indentlevel;
                continue;
            }
            if (tok2->str() == ""}"") {
                if (indentlevel > 0U)
                    --...",1,1,lib/checkstl.cpp,"CheckStl.eraseCheckLoopVar:void(Scope&,Variable*)",<empty>,,false,1431,1473,eraseCheckLoopVar,,,1,"void(Scope&,Variable*)"
111669151996,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::stlBoundaries()
{
    logChecker(""CheckStl::stlBoundaries"");

    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Variable* var : symbolDatabase->variableList()) {
        if (!var || !var->scope() || !var->scope()->isExecutable())
            continue;

        const Library::Container* container = mSettings->library.detectIterator(var->typeStartToken());
        if (!container || container->opLessAllowed)
            continue;

        const Token* const end = var->scope()->bodyEnd;
        for (const Token *tok = var->nameToken(); tok != end; tok = tok->next()) {
            if (Token::Match(tok, ""!!* %varid% <"", var->declarationId())) {
                stlBoundariesError(tok);
            } else if (Token::Match(tok, ""> %varid% !!."", var->declarationId())) {
                stlBoundariesError(tok);
            }
        }
    }
}",1,1,lib/checkstl.cpp,CheckStl.stlBoundaries:void(),<empty>,,false,1475,1497,stlBoundaries,,,1,void()
111669151997,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::stlBoundariesError(const Token *tok)
{
    reportError(tok, Severity::error, ""stlBoundaries"",
                ""Dangerous comparison using operator< on iterator.\\n""
                ""Iterator compared with operator<. This is dangerous since the order of items in the ""
                ""container is not guaranteed. One should use operator!= instead to compare iterators."", CWE664, Certainty::normal);
}",1,1,lib/checkstl.cpp,CheckStl.stlBoundariesError:void(Token*),<empty>,,false,1500,1506,stlBoundariesError,,,1,void(Token*)
111669151998,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static bool if_findCompare(const Token * const tokBack, bool stdStringLike)
{
    const Token *tok = tokBack->astParent();
    if (!tok)
        return true;
    if (tok->isComparisonOp()) {
        if (stdStringLike) {
            const Token * const tokOther = tokBack->astSibling();
            return !tokOther || !tokOther->hasKnownIntValue() || tokOther->getKnownIntValue() != 0;
        }
        return (!tok->astOperand1()->isNumber() && !tok->astOperand2()->isNumber());
    }
    if (tok->isArithmeticalOp()) // result is used in some calculation
        return true;  // TODO: check if there is a comparison of the result somewhere
    if (tok->str() == ""."")
        return true; // Dereferencing is OK, the programmer might know that the element exists - TODO: An inconclusive warning might be appropriate
    if (tok->isAssignmentOp())
        return if_findCompare(tok, stdStringLike); // Go one step upwards in the AST
    return false;
}",1,1,lib/checkstl.cpp,"if_findCompare:bool(Token*,bool)",<empty>,,false,1508,1527,if_findCompare,,,1,"bool(Token*,bool)"
111669151999,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::if_find()
{
    const bool printWarning = mSettings->severity.isEnabled(Severity::warning);
    const bool printPerformance = mSettings->severity.isEnabled(Severity::performance);
    if (!printWarning && !printPerformance)
        return;

    logChecker(""CheckStl::if_find""); // warning,performance

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope &scope : symbolDatabase->scopeList) {
        if ((scope.type != ScopeType::eIf && scope.type != ScopeType::eWhile) || !scope.classDef)
            continue;

        const Token *conditionStart = scope.classDef->next();
        if (Token::simpleMatch(conditionStart->astOperand2(), "";""))
            conditionStart = conditionStart->astOperand2();

        for (const Token *tok = conditionStart; tok->str() != ""{""; tok = tok->next()) {
            const Token* funcTok = nullptr;
            const Library::Container* container = nullptr;

            if (Token::Match(tok, ""%name...",1,1,lib/checkstl.cpp,CheckStl.if_find:void(),<empty>,,false,1529,1603,if_find,,,1,void()
111669152000,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::if_findError(const Token *tok, bool str)
{
    if (str && mSettings->standards.cpp >= Standards::CPP20)
        reportError(tok, Severity::performance, ""stlIfStrFind"",
                    ""Inefficient usage of string::find() in condition; string::starts_with() could be faster.\\n""
                    ""Either inefficient or wrong usage of string::find(). string::starts_with() will be faster if ""
                    ""string::find's result is compared with 0, because it will not scan the whole ""
                    ""string. If your intention is to check that there are no findings in the string, ""
                    ""you should compare with std::string::npos."", CWE597, Certainty::normal);
    if (!str)
        reportError(tok, Severity::warning, ""stlIfFind"", ""Suspicious condition. The result of find() is an iterator, but it is not properly checked."", CWE398, Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.if_findError:void(Token*,bool)",<empty>,,false,1606,1617,if_findError,,,1,"void(Token*,bool)"
111669152001,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static std::pair<const Token *, const Token *> isMapFind(const Token *tok)
{
    if (!Token::simpleMatch(tok, ""(""))
        return {};
    if (!Token::simpleMatch(tok->astOperand1(), "".""))
        return {};
    if (!astIsContainer(tok->astOperand1()->astOperand1()))
        return {};
    const Token * contTok = tok->astOperand1()->astOperand1();
    const Library::Container * container = contTok->valueType()->container;
    if (!container)
        return {};
    if (!container->stdAssociativeLike)
        return {};
    if (!Token::Match(tok->astOperand1(), "". find|count (""))
        return {};
    if (!tok->astOperand2())
        return {};
    return {contTok, tok->astOperand2()};
}",1,1,lib/checkstl.cpp,"isMapFind:pair<constToken*,constToken*>(Token*)",<empty>,,false,1619,1638,isMapFind,,,1,"pair<const Token*,const Token*>(Token*)"
111669152002,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static const Token* skipLocalVars(const Token* const tok)
{
    if (!tok)
        return tok;
    if (Token::simpleMatch(tok, ""{""))
        return skipLocalVars(tok->next());

    if (tok->isAssignmentOp()) {
        const Token *top = tok->astTop();
        const Token *varTok = top->astOperand1();
        const Variable *var = varTok->variable();
        if (!var)
            return tok;
        if (var->scope() != tok->scope())
            return tok;
        const Token *endTok = nextAfterAstRightmostLeaf(top);
        if (!endTok)
            return tok;
        return skipLocalVars(endTok->next());
    }
    return tok;
}",1,1,lib/checkstl.cpp,skipLocalVars:Token*(Token*),<empty>,,false,1640,1661,skipLocalVars,,,1,Token*(Token*)
111669152003,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static const Token *findInsertValue(const Token *tok, const Token *containerTok, const Token *keyTok, const Settings &settings)
{
    const Token *startTok = skipLocalVars(tok);
    const Token *top = startTok->astTop();

    const Token *icontainerTok = nullptr;
    const Token *ikeyTok = nullptr;
    const Token *ivalueTok = nullptr;
    if (Token::simpleMatch(top, ""="") && Token::simpleMatch(top->astOperand1(), ""["")) {
        icontainerTok = top->astOperand1()->astOperand1();
        ikeyTok = top->astOperand1()->astOperand2();
        ivalueTok = top->astOperand2();
    }
    if (Token::simpleMatch(top, ""("") && Token::Match(top->astOperand1(), "". insert|emplace ("") && !astIsIterator(top->astOperand1()->tokAt(2))) {
        icontainerTok = top->astOperand1()->astOperand1();
        const Token *itok = top->astOperand1()->tokAt(2)->astOperand2();
        if (Token::simpleMatch(itok, "","")) {
            ikeyTok = itok->astOperand1();
            ivalueTok = itok->astOperand2();
   ...",1,1,lib/checkstl.cpp,"findInsertValue:Token*(Token*,Token*,Token*,Settings&)",<empty>,,false,1663,1695,findInsertValue,,,1,"Token*(Token*,Token*,Token*,Settings&)"
111669152004,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::checkFindInsert()
{
    if (!mSettings->severity.isEnabled(Severity::performance))
        return;

    logChecker(""CheckStl::checkFindInsert""); // performance

    const SymbolDatabase *const symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope *scope : symbolDatabase->functionScopes) {
        for (const Token *tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!Token::simpleMatch(tok, ""if (""))
                continue;
            if (!Token::simpleMatch(tok->linkAt(1), "") {""))
                continue;
            if (!Token::Match(tok->next()->astOperand2(), ""%comp%""))
                continue;
            const Token *condTok = tok->next()->astOperand2();
            const Token *containerTok;
            const Token *keyTok;
            std::tie(containerTok, keyTok) = isMapFind(condTok->astOperand1());
            if (!containerTok)
                continue;
            // In < C++17 we only warn for s...",1,1,lib/checkstl.cpp,CheckStl.checkFindInsert:void(),<empty>,,false,1697,1741,checkFindInsert,,,1,void()
111669152005,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::checkFindInsertError(const Token *tok)
{
    std::string replaceExpr;
    if (tok && Token::simpleMatch(tok->astParent(), ""="") && tok == tok->astParent()->astOperand2() && Token::simpleMatch(tok->astParent()->astOperand1(), ""["")) {
        if (mSettings->standards.cpp < Standards::CPP11)
            // We will recommend using emplace/try_emplace instead
            return;
        const std::string f = (mSettings->standards.cpp < Standards::CPP17) ? ""emplace"" : ""try_emplace"";
        replaceExpr = "" Instead of '"" + tok->astParent()->expressionString() + ""' consider using '"" +
                      tok->astParent()->astOperand1()->astOperand1()->expressionString() +
                      ""."" + f + ""("" +
                      tok->astParent()->astOperand1()->astOperand2()->expressionString() +
                      "", "" +
                      tok->expressionString() +
                      "");'."";
    }

    reportError(
        tok, Severity::performance, ""stlFindInse...",1,1,lib/checkstl.cpp,CheckStl.checkFindInsertError:void(Token*),<empty>,,false,1743,1762,checkFindInsertError,,,1,void(Token*)
111669152006,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static bool isCpp03ContainerSizeSlow(const Token *tok)
{
    if (!tok)
        return false;
    const Variable* var = tok->variable();
    return var && var->isStlType(""list"");
}",1,1,lib/checkstl.cpp,isCpp03ContainerSizeSlow:bool(Token*),<empty>,,false,1767,1773,isCpp03ContainerSizeSlow,,,1,bool(Token*)
111669152007,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::size()
{
    if (!mSettings->severity.isEnabled(Severity::performance))
        return;

    if (mSettings->standards.cpp >= Standards::CPP11)
        return;

    logChecker(""CheckStl::size""); // performance,c++03

    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (Token::Match(tok, ""%var% . size ( )"") ||
                Token::Match(tok, ""%name% . %var% . size ( )"")) {
                // get the variable
                const Token *varTok = tok;
                if (tok->strAt(2) != ""size"")
                    varTok = varTok->tokAt(2);

                const Token* const end = varTok->tokAt(5);

                // check for comparison to zero
                if ((!tok->previous()->isArithmeticalOp() && Token::Match(end, ""==|<=|!=|> 0"")) ||
               ...",1,1,lib/checkstl.cpp,CheckStl.size:void(),<empty>,,false,1775,1822,size,,,1,void()
111669152008,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::sizeError(const Token *tok)
{
    const std::string varname = tok ? tok->str() : std::string(""list"");
    reportError(tok, Severity::performance, ""stlSize"",
                ""$symbol:"" + varname + ""\\n""
                ""Possible inefficient checking for '$symbol' emptiness.\\n""
                ""Checking for '$symbol' emptiness might be inefficient. ""
                ""Using $symbol.empty() instead of $symbol.size() can be faster. ""
                ""$symbol.size() can take linear time but $symbol.empty() is ""
                ""guaranteed to take constant time."", CWE398, Certainty::normal);
}",1,1,lib/checkstl.cpp,CheckStl.sizeError:void(Token*),<empty>,,false,1824,1834,sizeError,,,1,void(Token*)
111669152009,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::redundantCondition()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""redundantIfRemove""))
        return;

    logChecker(""CheckStl::redundantCondition""); // style

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope &scope : symbolDatabase->scopeList) {
        if (scope.type != ScopeType::eIf)
            continue;

        const Token* tok = scope.classDef->tokAt(2);
        if (!Token::Match(tok, ""%name% . find ( %any% ) != %name% . end|rend|cend|crend ( ) ) { %name% . remove|erase ( %any% ) ;""))
            continue;

        // Get tokens for the fields %name% and %any%
        const Token *var1 = tok;
        const Token *any1 = var1->tokAt(4);
        const Token *var2 = any1->tokAt(3);
        const Token *var3 = var2->tokAt(7);
        const Token *any2 = var3->tokAt(4);

        // Check if all the ""%name%"" fields are the same and if all the ""%any%"" are the same..
     ...",1,1,lib/checkstl.cpp,CheckStl.redundantCondition:void(),<empty>,,false,1836,1867,redundantCondition,,,1,void()
111669152010,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::redundantIfRemoveError(const Token *tok)
{
    reportError(tok, Severity::style, ""redundantIfRemove"",
                ""Redundant checking of STL container element existence before removing it.\\n""
                ""Redundant checking of STL container element existence before removing it. ""
                ""It is safe to call the remove method on a non-existing element."", CWE398, Certainty::normal);
}",1,1,lib/checkstl.cpp,CheckStl.redundantIfRemoveError:void(Token*),<empty>,,false,1869,1875,redundantIfRemoveError,,,1,void(Token*)
111669152011,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::missingComparison()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckStl::missingComparison""); // warning

    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope &scope : symbolDatabase->scopeList) {
        if (scope.type != ScopeType::eFor || !scope.classDef)
            continue;

        for (const Token *tok2 = scope.classDef->tokAt(2); tok2 != scope.bodyStart; tok2 = tok2->next()) {
            if (tok2->str() == "";"")
                break;

            if (!Token::Match(tok2, ""%var% = %name% . begin|rbegin|cbegin|crbegin ( ) ; %name% != %name% . end|rend|cend|crend ( ) ; ++| %name% ++| ) {""))
                continue;

            // same container
            if (tok2->strAt(2) != tok2->strAt(10))
                break;

            const int iteratorId(tok2->varId());

            // same iterator
            if (iteratorId == tok2->tokAt(10)->varId())
         ...",1,1,lib/checkstl.cpp,CheckStl.missingComparison:void(),<empty>,,false,1877,1939,missingComparison,,,1,void()
111669152012,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::missingComparisonError(const Token *incrementToken1, const Token *incrementToken2)
{
    std::list<const Token*> callstack = { incrementToken1,incrementToken2 };

    std::ostringstream errmsg;
    errmsg << ""Missing bounds check for extra iterator increment in loop.\\n""
           << ""The iterator incrementing is suspicious - it is incremented at line "";
    if (incrementToken1)
        errmsg << incrementToken1->linenr();
    errmsg << "" and then at line "";
    if (incrementToken2)
        errmsg << incrementToken2->linenr();
    errmsg << "". The loop might unintentionally skip an element in the container. ""
           << ""There is no comparison between these increments to prevent that the iterator is ""
           << ""incremented beyond the end."";

    reportError(callstack, Severity::warning, ""StlMissingComparison"", errmsg.str(), CWE834, Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.missingComparisonError:void(Token*,Token*)",<empty>,,false,1941,1958,missingComparisonError,,,1,"void(Token*,Token*)"
111669152013,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static bool isLocal(const Token *tok)
{
    const Variable *var = tok->variable();
    return var && !var->isStatic() && var->isLocal();
}",1,1,lib/checkstl.cpp,isLocal:bool(Token*),<empty>,,false,1961,1965,isLocal,,,1,bool(Token*)
111669152014,METHOD,<empty>,<empty>,"[](const Token* str) -> bool {
        while (Token::Match(str, ""::|.""))
            str = str->astOperand2();
        if (Token::Match(str, ""(|["") && !(str->valueType() && str->valueType()->type == ValueType::ITERATOR))
            str = str->previous();
        return str && ((str->variable() && str->variable()->isStlStringType()) || // variable
                       (str->function() && isStlStringType(str->function()->retDef)) || // function returning string
                       (str->valueType() && str->valueType()->type == ValueType::ITERATOR && isStlStringType(str->valueType()->containerTypeToken))); // iterator pointing to string
    }",21,5,lib/checkstl.cpp,lib/checkstl.cpp:<global>.CheckStl.string_c_str.<lambda>12:bool(Token*),<empty>,,false,2001,2009,<lambda>12,,,1,bool(Token*)
111669152015,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::string_c_str()
{
    const bool printInconclusive = mSettings->certainty.isEnabled(Certainty::inconclusive);
    const bool printPerformance = mSettings->severity.isEnabled(Severity::performance);

    const SymbolDatabase* symbolDatabase = mTokenizer->getSymbolDatabase();

    logChecker(""CheckStl::string_c_str"");

    // Find all functions that take std::string as argument
    struct StrArg {
        nonneg int n;
        std::string argtype;
    };
    std::multimap<const Function*, StrArg> c_strFuncParam;
    if (printPerformance) {
        for (const Scope &scope : symbolDatabase->scopeList) {
            for (const Function &func : scope.functionList) {
                nonneg int numpar = 0;
                for (const Variable &var : func.argumentList) {
                    numpar++;
                    if ((var.isStlStringType() || var.isStlStringViewType()) && (!var.isReference() || var.isConst()))
                        c_strFuncParam.emplace(&func, StrArg{ ...",1,8,lib/checkstl.cpp,CheckStl.string_c_str:void(),<empty>,,false,1973,2173,string_c_str,,,1,void()
111669152016,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::string_c_strThrowError(const Token* tok)
{
    reportError(tok, Severity::error, ""stlcstrthrow"", ""Dangerous usage of c_str(). The value returned by c_str() is invalid after throwing exception.\\n""
                ""Dangerous usage of c_str(). The string is destroyed after the c_str() call so the thrown pointer is invalid."");
}",1,1,lib/checkstl.cpp,CheckStl.string_c_strThrowError:void(Token*),<empty>,,false,2175,2179,string_c_strThrowError,,,1,void(Token*)
111669152017,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::string_c_strError(const Token* tok)
{
    reportError(tok, Severity::error, ""stlcstr"", ""Dangerous usage of c_str(). The value returned by c_str() is invalid after this call.\\n""
                ""Dangerous usage of c_str(). The c_str() return value is only valid until its string is deleted."", CWE664, Certainty::normal);
}",1,1,lib/checkstl.cpp,CheckStl.string_c_strError:void(Token*),<empty>,,false,2181,2185,string_c_strError,,,1,void(Token*)
111669152018,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::string_c_strReturn(const Token* tok)
{
    reportError(tok, Severity::performance, ""stlcstrReturn"", ""Returning the result of c_str() in a function that returns std::string is slow and redundant.\\n""
                ""The conversion from const char* as returned by c_str() to std::string creates an unnecessary string copy. Solve that by directly returning the string."", CWE704, Certainty::normal);
}",1,1,lib/checkstl.cpp,CheckStl.string_c_strReturn:void(Token*),<empty>,,false,2187,2191,string_c_strReturn,,,1,void(Token*)
111669152019,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::string_c_strParam(const Token* tok, nonneg int number, const std::string& argtype)
{
    std::ostringstream oss;
    oss << ""Passing the result of c_str() to a function that takes "" << argtype << "" as argument no. "" << number << "" is slow and redundant.\\n""
        ""The conversion from const char* as returned by c_str() to "" << argtype << "" creates an unnecessary string copy or length calculation. Solve that by directly passing the string."";
    reportError(tok, Severity::performance, ""stlcstrParam"", oss.str(), CWE704, Certainty::normal);
}",1,51,lib/checkstl.cpp,"CheckStl.string_c_strParam:void(Token*,int,std.string&)",<empty>,,false,2193,2199,string_c_strParam,,,1,"void(Token*,int,std.string&)"
111669152020,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::string_c_strConstructor(const Token* tok, const std::string& argtype)
{
    std::string msg = ""Constructing a "" + argtype + "" from the result of c_str() is slow and redundant.\\n""
                      ""Constructing a "" + argtype + "" from const char* requires a call to strlen(). Solve that by directly passing the string."";
    reportError(tok, Severity::performance, ""stlcstrConstructor"", msg, CWE704, Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.string_c_strConstructor:void(Token*,std.string&)",<empty>,,false,2201,2206,string_c_strConstructor,,,1,"void(Token*,std.string&)"
111669152021,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::string_c_strAssignment(const Token* tok, const std::string& argtype)
{
    std::string msg = ""Assigning the result of c_str() to a "" + argtype + "" is slow and redundant.\\n""
                      ""Assigning a const char* to a "" + argtype + "" requires a call to strlen(). Solve that by directly assigning the string."";
    reportError(tok, Severity::performance, ""stlcstrAssignment"", msg, CWE704, Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.string_c_strAssignment:void(Token*,std.string&)",<empty>,,false,2208,2213,string_c_strAssignment,,,1,"void(Token*,std.string&)"
111669152022,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::string_c_strConcat(const Token* tok)
{
    std::string msg = ""Concatenating the result of c_str() and a std::string is slow and redundant.\\n""
                      ""Concatenating a const char* with a std::string requires a call to strlen(). Solve that by directly concatenating the strings."";
    reportError(tok, Severity::performance, ""stlcstrConcat"", msg, CWE704, Certainty::normal);
}",1,1,lib/checkstl.cpp,CheckStl.string_c_strConcat:void(Token*),<empty>,,false,2215,2220,string_c_strConcat,,,1,void(Token*)
111669152023,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::string_c_strStream(const Token* tok)
{
    std::string msg = ""Passing the result of c_str() to a stream is slow and redundant.\\n""
                      ""Passing a const char* to a stream requires a call to strlen(). Solve that by directly passing the string."";
    reportError(tok, Severity::performance, ""stlcstrStream"", msg, CWE704, Certainty::normal);
}",1,1,lib/checkstl.cpp,CheckStl.string_c_strStream:void(Token*),<empty>,,false,2222,2227,string_c_strStream,,,1,void(Token*)
111669152024,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::uselessCalls()
{
    const bool printPerformance = mSettings->severity.isEnabled(Severity::performance);
    const bool printWarning = mSettings->severity.isEnabled(Severity::warning);
    if (!printPerformance && !printWarning)
        return;

    logChecker(""CheckStl::uselessCalls""); // performance,warning

    const SymbolDatabase* symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
            if (printWarning && Token::Match(tok, ""%var% . compare|find|rfind|find_first_not_of|find_first_of|find_last_not_of|find_last_of ( %name% [,)]"") &&
                tok->varId() == tok->tokAt(4)->varId()) {
                const Variable* var = tok->variable();
                if (!var || !var->isStlType())
                    continue;
                uselessCallsReturnValueError(tok->tokAt(4), tok->str(), tok->strAt(2))...",1,1,lib/checkstl.cpp,CheckStl.uselessCalls:void(),<empty>,,false,2243,2301,uselessCalls,,,1,void()
111669152025,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::uselessCallsReturnValueError(const Token *tok, const std::string &varname, const std::string &function)
{
    std::ostringstream errmsg;
    errmsg << ""$symbol:"" << varname << '\\n';
    errmsg << ""$symbol:"" << function << '\\n';
    errmsg << ""It is inefficient to call '"" << varname << ""."" << function << ""("" << varname << "")' as it always returns 0.\\n""
           << ""'std::string::"" << function << ""()' returns zero when given itself as parameter ""
           << ""("" << varname << ""."" << function << ""("" << varname << "")). As it is currently the ""
           << ""code is inefficient. It is possible either the string searched ('""
           << varname << ""') or searched for ('"" << varname << ""') is wrong."";
    reportError(tok, Severity::warning, ""uselessCallsCompare"", errmsg.str(), CWE628, Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.uselessCallsReturnValueError:void(Token*,std.string&,std.string&)",<empty>,,false,2304,2315,uselessCallsReturnValueError,,,1,"void(Token*,std.string&,std.string&)"
111669152026,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::uselessCallsSwapError(const Token *tok, const std::string &varname)
{
    reportError(tok, Severity::performance, ""uselessCallsSwap"",
                ""$symbol:"" + varname + ""\\n""
                ""It is inefficient to swap a object with itself by calling '$symbol.swap($symbol)'\\n""
                ""The 'swap()' function has no logical effect when given itself as parameter ""
                ""($symbol.swap($symbol)). As it is currently the ""
                ""code is inefficient. Is the object or the parameter wrong here?"", CWE628, Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.uselessCallsSwapError:void(Token*,std.string&)",<empty>,,false,2317,2325,uselessCallsSwapError,,,1,"void(Token*,std.string&)"
111669152027,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::uselessCallsSubstrError(const Token *tok, SubstrErrorType type)
{
    std::string msg = ""Ineffective call of function 'substr' because "";
    switch (type) {
    case SubstrErrorType::EMPTY:
        msg += ""it returns an empty string."";
        break;
    case SubstrErrorType::COPY:
        msg += ""it returns a copy of the object. Use operator= instead."";
        break;
    case SubstrErrorType::PREFIX:
        msg += ""a prefix of the string is assigned to itself. Use resize() or pop_back() instead."";
        break;
    case SubstrErrorType::PREFIX_CONCAT:
        msg += ""a prefix of the string is assigned to itself. Use replace() instead."";
        break;
    }
    reportError(tok, Severity::performance, ""uselessCallsSubstr"", msg, CWE398, Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.uselessCallsSubstrError:void(Token*,CheckStl.SubstrErrorType)",<empty>,,false,2327,2345,uselessCallsSubstrError,,,1,"void(Token*,CheckStl.SubstrErrorType)"
111669152028,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::uselessCallsConstructorError(const Token *tok)
{
    const std::string msg = ""Inefficient constructor call: container '"" + tok->str() + ""' is assigned a partial copy of itself. Use erase() or resize() instead."";
    reportError(tok, Severity::performance, ""uselessCallsConstructor"", msg, CWE398, Certainty::normal);
}",1,1,lib/checkstl.cpp,CheckStl.uselessCallsConstructorError:void(Token*),<empty>,,false,2347,2351,uselessCallsConstructorError,,,1,void(Token*)
111669152029,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::uselessCallsEmptyError(const Token *tok)
{
    reportError(tok, Severity::warning, ""uselessCallsEmpty"", ""Ineffective call of function 'empty()'. Did you intend to call 'clear()' instead?"", CWE398, Certainty::normal);
}",1,1,lib/checkstl.cpp,CheckStl.uselessCallsEmptyError:void(Token*),<empty>,,false,2353,2356,uselessCallsEmptyError,,,1,void(Token*)
111669152030,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::uselessCallsRemoveError(const Token *tok, const std::string& function)
{
    reportError(tok, Severity::warning, ""uselessCallsRemove"",
                ""$symbol:"" + function + ""\\n""
                ""Return value of std::$symbol() ignored. Elements remain in container.\\n""
                ""The return value of std::$symbol() is ignored. This function returns an iterator to the end of the range containing those elements that should be kept. ""
                ""Elements past new end remain valid but with unspecified values. Use the erase method of the container to delete them."", CWE762, Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.uselessCallsRemoveError:void(Token*,std.string&)",<empty>,,false,2358,2365,uselessCallsRemoveError,,,1,"void(Token*,std.string&)"
111669152031,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::checkDereferenceInvalidIterator()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckStl::checkDereferenceInvalidIterator""); // warning

    // Iterate over ""if"", ""while"", and ""for"" conditions where there may
    // be an iterator that is dereferenced before being checked for validity.
    for (const Scope &scope : mTokenizer->getSymbolDatabase()->scopeList) {
        if (!(scope.type == ScopeType::eIf || scope.isLoopScope()))
            continue;

        const Token* const tok = scope.classDef;
        const Token* startOfCondition = tok->next();
        if (scope.type == ScopeType::eDo)
            startOfCondition = startOfCondition->link()->tokAt(2);
        if (!startOfCondition) // ticket #6626 invalid code
            continue;
        const Token* endOfCondition = startOfCondition->link();
        if (!endOfCondition)
            continue;

        // For ""for"" loops, only search between the two semicolons
    ...",1,1,lib/checkstl.cpp,CheckStl.checkDereferenceInvalidIterator:void(),<empty>,,false,2369,2430,checkDereferenceInvalidIterator,,,1,void()
111669152032,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& value) {
            if (value.isImpossible())
                return false;
            if (!printInconclusive && value.isInconclusive())
                return false;
            return value.isContainerSizeValue();
        }",100,9,lib/checkstl.cpp,lib/checkstl.cpp:<global>.CheckStl.checkDereferenceInvalidIterator2.<lambda>13:bool(ValueFlow.Value&),<empty>,,false,2449,2455,<lambda>13,,,1,bool(ValueFlow.Value&)
111669152033,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& c) {
                    if (value.path != c.path)
                        return false;
                    if (value.isIteratorStartValue() && value.intvalue >= c.intvalue)
                        return true;
                    if (value.isIteratorEndValue() && -value.intvalue > c.intvalue)
                        return true;
                    return false;
                }",80,17,lib/checkstl.cpp,lib/checkstl.cpp:<global>.CheckStl.checkDereferenceInvalidIterator2.<lambda>14:bool(ValueFlow.Value&),<empty>,,false,2473,2481,<lambda>14,,,1,bool(ValueFlow.Value&)
111669152034,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::checkDereferenceInvalidIterator2()
{
    const bool printInconclusive = (mSettings->certainty.isEnabled(Certainty::inconclusive));

    logChecker(""CheckStl::checkDereferenceInvalidIterator2"");

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""sizeof|decltype|typeid|typeof ("")) {
            tok = tok->linkAt(1);
            continue;
        }

        if (Token::Match(tok, ""%assign%""))
            continue;

        std::vector<ValueFlow::Value> contValues;
        std::copy_if(tok->values().cbegin(), tok->values().cend(), std::back_inserter(contValues), [&](const ValueFlow::Value& value) {
            if (value.isImpossible())
                return false;
            if (!printInconclusive && value.isInconclusive())
                return false;
            return value.isContainerSizeValue();
        });


        // Can iterator point to END or before START?
        for (const ValueFlow::Value& value:tok-...",1,1,lib/checkstl.cpp,CheckStl.checkDereferenceInvalidIterator2:void(),<empty>,,false,2433,2527,checkDereferenceInvalidIterator2,,,1,void()
111669152035,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::dereferenceInvalidIteratorError(const Token* tok, const ValueFlow::Value *value, bool inconclusive)
{
    const std::string& varname = tok ? tok->expressionString() : ""var"";
    const std::string errmsgcond(""$symbol:"" + varname + '\\n' + ValueFlow::eitherTheConditionIsRedundant(value ? value->condition : nullptr) + "" or there is possible dereference of an invalid iterator: $symbol."");
    if (!tok || !value) {
        reportError(tok, Severity::error, ""derefInvalidIterator"", ""Dereference of an invalid iterator"", CWE825, Certainty::normal);
        reportError(tok, Severity::warning, ""derefInvalidIteratorRedundantCheck"", errmsgcond, CWE825, Certainty::normal);
        return;
    }
    if (!mSettings->isEnabled(value, inconclusive))
        return;

    const ErrorPath errorPath = getErrorPath(tok, value, ""Dereference of an invalid iterator"");

    if (value->condition) {
        reportError(errorPath, Severity::warning, ""derefInvalidIteratorRedundantCheck"", errmsgcond,...",1,1,lib/checkstl.cpp,"CheckStl.dereferenceInvalidIteratorError:void(Token*,ValueFlow.Value*,bool)",<empty>,,false,2529,2556,dereferenceInvalidIteratorError,,,1,"void(Token*,ValueFlow.Value*,bool)"
111669152036,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::dereferenceInvalidIteratorError(const Token* deref, const std::string &iterName)
{
    reportError(deref, Severity::warning,
                ""derefInvalidIterator"",
                ""$symbol:"" + iterName + ""\\n""
                ""Possible dereference of an invalid iterator: $symbol\\n""
                ""Possible dereference of an invalid iterator: $symbol. Make sure to check that the iterator is valid before dereferencing it - not after."", CWE825, Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.dereferenceInvalidIteratorError:void(Token*,std.string&)",<empty>,,false,2558,2565,dereferenceInvalidIteratorError,,,1,"void(Token*,std.string&)"
111669152037,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::useStlAlgorithmError(const Token *tok, const std::string &algoName)
{
    reportError(tok, Severity::style, ""useStlAlgorithm"",
                ""Consider using "" + algoName + "" algorithm instead of a raw loop."", CWE398, Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.useStlAlgorithmError:void(Token*,std.string&)",<empty>,,false,2567,2571,useStlAlgorithmError,,,1,"void(Token*,std.string&)"
111669152038,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static bool isEarlyExit(const Token *start)
{
    if (start->str() != ""{"")
        return false;
    const Token *endToken = start->link();
    const Token *tok = Token::findmatch(start, ""return|throw|break"", endToken);
    if (!tok)
        return false;
    const Token *endStatement = Token::findsimplematch(tok, ""; }"", endToken);
    if (!endStatement)
        return false;
    if (endStatement->next() != endToken)
        return false;
    return true;
}",1,1,lib/checkstl.cpp,isEarlyExit:bool(Token*),<empty>,,false,2573,2587,isEarlyExit,,,1,bool(Token*)
111669152039,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static const Token *singleStatement(const Token *start)
{
    if (start->str() != ""{"")
        return nullptr;
    const Token *endToken = start->link();
    const Token *endStatement = Token::findsimplematch(start->next(), "";"");
    if (!Token::simpleMatch(endStatement, ""; }""))
        return nullptr;
    if (endStatement->next() != endToken)
        return nullptr;
    return endStatement;
}",1,1,lib/checkstl.cpp,singleStatement:Token*(Token*),<empty>,,false,2589,2600,singleStatement,,,1,Token*(Token*)
111669152040,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static const Token *singleAssignInScope(const Token *start, nonneg int varid, bool &input, bool &hasBreak, LoopType loopType, const Settings& settings)
{
    const Token *endStatement = singleStatement(start);
    if (!endStatement)
        return nullptr;
    if (!Token::Match(start->next(), ""%var% %assign%""))
        return nullptr;
    const Token *assignTok = start->tokAt(2);
    if (isVariableChanged(assignTok->next(), endStatement, assignTok->astOperand1()->varId(), /*globalvar*/ false, settings))
        return nullptr;
    if (isVariableChanged(assignTok->next(), endStatement, varid, /*globalvar*/ false, settings))
        return nullptr;
    input = Token::findmatch(assignTok->next(), ""%varid%"", endStatement, varid) || !Token::Match(start->next(), ""%var% ="");
    hasBreak = Token::simpleMatch(endStatement->previous(), ""break"");

    if (loopType == LoopType::INDEX) { // check for container access
        nonneg int containerId{};
        for (const Token* tok = assignTok->n...",1,60,lib/checkstl.cpp,"singleAssignInScope:Token*(Token*,int,bool&,bool&,LoopType,Settings&)",<empty>,,false,2604,2636,singleAssignInScope,,,1,"Token*(Token*,int,bool&,bool&,LoopType,Settings&)"
111669152041,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static const Token *singleMemberCallInScope(const Token *start, nonneg int varid, bool &input, const Settings& settings)
{
    if (start->str() != ""{"")
        return nullptr;
    const Token *endToken = start->link();
    if (!Token::Match(start->next(), ""%var% . %name% (""))
        return nullptr;
    if (!Token::simpleMatch(start->linkAt(4), "") ; }""))
        return nullptr;
    const Token *endStatement = start->linkAt(4)->next();
    if (endStatement->next() != endToken)
        return nullptr;

    const Token *dotTok = start->tokAt(2);
    if (!Token::findmatch(dotTok->tokAt(2), ""%varid%"", endStatement, varid))
        return nullptr;
    input = Token::Match(start->next(), ""%var% . %name% ( %varid% )"", varid);
    if (isVariableChanged(dotTok->next(), endStatement, dotTok->astOperand1()->varId(), /*globalvar*/ false, settings))
        return nullptr;
    return dotTok;
}",1,64,lib/checkstl.cpp,"singleMemberCallInScope:Token*(Token*,int,bool&,Settings&)",<empty>,,false,2638,2658,singleMemberCallInScope,,,1,"Token*(Token*,int,bool&,Settings&)"
111669152042,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static const Token *singleIncrementInScope(const Token *start, nonneg int varid, bool &input)
{
    if (start->str() != ""{"")
        return nullptr;
    const Token *varTok = nullptr;
    if (Token::Match(start->next(), ""++ %var% ; }""))
        varTok = start->tokAt(2);
    else if (Token::Match(start->next(), ""%var% ++ ; }""))
        varTok = start->tokAt(1);
    if (!varTok)
        return nullptr;
    input = varTok->varId() == varid;
    return varTok;
}",1,63,lib/checkstl.cpp,"singleIncrementInScope:Token*(Token*,int,bool&)",<empty>,,false,2660,2673,singleIncrementInScope,,,1,"Token*(Token*,int,bool&)"
111669152043,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static const Token *singleConditionalInScope(const Token *start, nonneg int varid, LoopType loopType, const Settings& settings)
{
    if (start->str() != ""{"")
        return nullptr;
    const Token *endToken = start->link();
    if (!Token::simpleMatch(start->next(), ""if (""))
        return nullptr;
    if (!Token::simpleMatch(start->linkAt(2), "") {""))
        return nullptr;
    const Token *bodyTok = start->linkAt(2)->next();
    const Token *endBodyTok = bodyTok->link();
    if (!Token::simpleMatch(endBodyTok, ""} }""))
        return nullptr;
    if (endBodyTok->next() != endToken)
        return nullptr;
    if (!Token::findmatch(start, ""%varid%"", bodyTok, varid))
        return nullptr;
    if (isVariableChanged(start, bodyTok, varid, /*globalvar*/ false, settings))
        return nullptr;
    if (loopType == LoopType::INDEX) { // check for container access
        nonneg int containerId{};
        for (const Token* tok = start->tokAt(2); tok != start->linkAt(2); tok = tok->nex...",1,65,lib/checkstl.cpp,"singleConditionalInScope:Token*(Token*,int,LoopType,Settings&)",<empty>,,false,2675,2711,singleConditionalInScope,,,1,"Token*(Token*,int,LoopType,Settings&)"
111669152044,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static bool addByOne(const Token *tok, nonneg int varid)
{
    if (Token::Match(tok, ""+= %any% ;"") &&
        tok->tokAt(1)->hasKnownIntValue() &&
        tok->tokAt(1)->getValue(1)) {
        return true;
    }
    if (Token::Match(tok, ""= %varid% + %any% ;"", varid) &&
        tok->tokAt(3)->hasKnownIntValue() &&
        tok->tokAt(3)->getValue(1)) {
        return true;
    }
    return false;
}",1,39,lib/checkstl.cpp,"addByOne:bool(Token*,int)",<empty>,,false,2713,2726,addByOne,,,1,"bool(Token*,int)"
111669152045,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static bool accumulateBoolLiteral(const Token *tok, nonneg int varid)
{
    if (Token::Match(tok, ""%assign% %bool% ;"") &&
        tok->tokAt(1)->hasKnownIntValue()) {
        return true;
    }
    if (Token::Match(tok, ""= %varid% %oror%|%or%|&&|& %bool% ;"", varid) &&
        tok->tokAt(3)->hasKnownIntValue()) {
        return true;
    }
    return false;
}",1,52,lib/checkstl.cpp,"accumulateBoolLiteral:bool(Token*,int)",<empty>,,false,2728,2739,accumulateBoolLiteral,,,1,"bool(Token*,int)"
111669152046,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static bool accumulateBool(const Token *tok, nonneg int varid)
{
    // Missing %oreq% so we have to check both manually
    if (Token::simpleMatch(tok, ""&="") || Token::simpleMatch(tok, ""|="")) {
        return true;
    }
    if (Token::Match(tok, ""= %varid% %oror%|%or%|&&|&"", varid)) {
        return true;
    }
    return false;
}",1,45,lib/checkstl.cpp,"accumulateBool:bool(Token*,int)",<empty>,,false,2741,2751,accumulateBool,,,1,"bool(Token*,int)"
111669152047,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static bool hasVarIds(const Token *tok, nonneg int var1, nonneg int var2)
{
    if (tok->astOperand1()->varId() == tok->astOperand2()->varId())
        return false;
    if (tok->astOperand1()->varId() == var1 || tok->astOperand1()->varId() == var2) {
        if (tok->astOperand2()->varId() == var1 || tok->astOperand2()->varId() == var2) {
            return true;
        }
    }
    return false;
}",1,40,lib/checkstl.cpp,"hasVarIds:bool(Token*,int,int)",<empty>,,false,2753,2763,hasVarIds,,,1,"bool(Token*,int,int)"
111669152048,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static std::string flipMinMax(const std::string &algo)
{
    if (algo == ""std::max_element"")
        return ""std::min_element"";
    if (algo == ""std::min_element"")
        return ""std::max_element"";
    return algo;
}",1,1,lib/checkstl.cpp,flipMinMax:string(std.string&),<empty>,,false,2765,2772,flipMinMax,,,1,string(std.string&)
111669152049,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static std::string minmaxCompare(const Token *condTok, nonneg int loopVar, nonneg int assignVar, LoopType loopType, bool invert = false)
{
    if (loopType == LoopType::RANGE && !hasVarIds(condTok, loopVar, assignVar))
        return ""std::accumulate"";
    std::string algo = ""std::max_element"";
    if (Token::Match(condTok, ""<|<=""))
        algo = ""std::min_element"";
    if (condTok->astOperand1()->varId() == assignVar)
        algo = flipMinMax(algo);
    if (invert)
        algo = flipMinMax(algo);
    return algo;
}",1,55,lib/checkstl.cpp,"minmaxCompare:string(Token*,int,int,LoopType,bool)",<empty>,,false,2774,2786,minmaxCompare,,,1,"string(Token*,int,int,LoopType,bool)"
111669152050,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static bool isTernaryAssignment(const Token* assignTok, nonneg int loopVarId, nonneg int assignVarId, LoopType loopType, std::string& algo)
{
    if (!Token::simpleMatch(assignTok->astOperand2(), ""?""))
        return false;
    const Token* condTok = assignTok->astOperand2()->astOperand1();
    if (!Token::Match(condTok, ""<|<=|>=|>""))
        return false;

    const Token* colon = assignTok->astOperand2()->astOperand2();
    if (loopType == LoopType::RANGE) {
        if (!(condTok->astOperand1()->varId() && condTok->astOperand2()->varId() && colon->astOperand1()->varId() && colon->astOperand2()->varId()))
            return false;
    }
    else if (loopType == LoopType::INDEX) {
        int nVar = 0, nCont = 0;
        for (const Token* tok : { condTok->astOperand1(), condTok->astOperand2(), colon->astOperand1(), colon->astOperand2() }) {
            if (tok->varId())
                ++nVar;
            else if (tok->str() == ""["" && tok->astOperand1()->varId() && tok->astOperand1(...",1,56,lib/checkstl.cpp,"isTernaryAssignment:bool(Token*,int,int,LoopType,std.string&)",<empty>,,false,2788,2818,isTernaryAssignment,,,1,"bool(Token*,int,int,LoopType,std.string&)"
111669152051,METHOD,<empty>,<empty>,"[](const Token* tok) {
                return Token::Match(tok, ""goto|break"");
            }",30,13,lib/checkstl.cpp,lib/checkstl.cpp:<global>.LoopAnalyzer.hasGotoOrBreak<const>.<lambda>15:bool(Token*),<empty>,,false,2880,2882,<lambda>15,,,1,bool(Token*)
111669152052,METHOD,<empty>,<empty>,"[](const Token* tok) {
                    return Token::simpleMatch(tok, ""return"");
                }",34,17,lib/checkstl.cpp,lib/checkstl.cpp:<global>.LoopAnalyzer.findAlgo<const>.<lambda>16:ANY(Token*),<empty>,,false,2899,2901,<lambda>16,,,1,ANY(Token*)
111669152053,METHOD,<empty>,<empty>,"[&](const Token* tok) {
                    const Token* returnTok = tok->astOperand1();
                    if (!returnTok || !returnTok->hasKnownIntValue() || !astIsBool(returnTok)) {
                        alwaysTrue = false;
                        alwaysFalse = false;
                        return;
                    }
                    (returnTok->getKnownIntValue() ? alwaysTrue : alwaysFalse) &= true;
                    (returnTok->getKnownIntValue() ? alwaysFalse : alwaysTrue) &= false;
                }",39,17,lib/checkstl.cpp,lib/checkstl.cpp:<global>.LoopAnalyzer.findAlgo<const>.<lambda>17:void(Token*),<empty>,,false,2902,2911,<lambda>17,,,1,void(Token*)
111669152054,METHOD,LoopAnalyzer,TYPE_DECL,"explicit LoopAnalyzer(const Token* tok, const Settings* psettings)
            : bodyTok(tok->linkAt(1)->next()), settings(psettings)
        {
            const Token* splitTok = tok->next()->astOperand2();
            if (Token::simpleMatch(splitTok, "":"") && splitTok->previous()->varId() != 0) {
                loopVar = splitTok->previous();
            }
            if (valid()) {
                findChangedVariables();
            }
        }",9,9,lib/checkstl.cpp,"LoopAnalyzer.LoopAnalyzer:ANY(Token*,Settings*)",<empty>,,false,2827,2837,LoopAnalyzer,,,5,"LoopAnalyzer.LoopAnalyzer:ANY(Token*,Settings*)(Token*,Settings*)"
111669152055,METHOD,LoopAnalyzer,TYPE_DECL,"bool isLoopVarChanged() const {
            return varsChanged.count(loopVar->varId()) > 0;
        }",9,9,lib/checkstl.cpp,LoopAnalyzer.isLoopVarChanged<const>:bool(),<empty>,,false,2838,2840,isLoopVarChanged,,,6,bool()
111669152056,METHOD,LoopAnalyzer,TYPE_DECL,"bool isModified(const Token* tok) const
        {
            if (tok->variable() && tok->variable()->isConst())
                return false;
            int n = 1 + (astIsPointer(tok) ? 1 : 0);
            for (int i = 0; i < n; i++) {
                bool inconclusive = false;
                if (isVariableChangedByFunctionCall(tok, i, *settings, &inconclusive))
                    return true;
                if (inconclusive)
                    return true;
                if (isVariableChanged(tok, i, *settings))
                    return true;
            }
            return false;
        }",9,9,lib/checkstl.cpp,LoopAnalyzer.isModified<const>:bool(Token*),<empty>,,false,2842,2857,isModified,,,7,bool(Token*)
111669152057,METHOD,LoopAnalyzer,TYPE_DECL,"void findTokens(Predicate pred, F f) const
        {
            for (const Token* tok = bodyTok; precedes(tok, bodyTok->link()); tok = tok->next()) {
                if (pred(tok))
                    f(tok);
            }
        }",9,9,lib/checkstl.cpp,"LoopAnalyzer.findTokens<const>:void(Predicate,F)",<empty>,,false,2860,2866,findTokens,,,8,"void(Predicate,F)"
111669152058,METHOD,LoopAnalyzer,TYPE_DECL,"const Token* findToken(Predicate pred) const
        {
            for (const Token* tok = bodyTok; precedes(tok, bodyTok->link()); tok = tok->next()) {
                if (pred(tok))
                    return tok;
            }
            return nullptr;
        }",9,9,lib/checkstl.cpp,LoopAnalyzer.findToken<const>:Token(Predicate),<empty>,,false,2869,2876,findToken,,,9,Token(Predicate)
111669152059,METHOD,LoopAnalyzer,TYPE_DECL,"bool hasGotoOrBreak() const
        {
            return findToken([](const Token* tok) {
                return Token::Match(tok, ""goto|break"");
            });
        }",9,9,lib/checkstl.cpp,LoopAnalyzer.hasGotoOrBreak<const>:bool(),<empty>,,false,2878,2883,hasGotoOrBreak,,,10,bool()
111669152060,METHOD,LoopAnalyzer,TYPE_DECL,"bool valid() const {
            return bodyTok && loopVar;
        }",9,9,lib/checkstl.cpp,LoopAnalyzer.valid<const>:bool(),<empty>,,false,2885,2887,valid,,,11,bool()
111669152061,METHOD,LoopAnalyzer,TYPE_DECL,"std::string findAlgo() const
        {
            if (!valid())
                return """";
            bool loopVarChanged = isLoopVarChanged();
            if (!loopVarChanged && varsChanged.empty()) {
                if (hasGotoOrBreak())
                    return """";
                bool alwaysTrue = true;
                bool alwaysFalse = true;
                auto hasReturn = [](const Token* tok) {
                    return Token::simpleMatch(tok, ""return"");
                };
                findTokens(hasReturn, [&](const Token* tok) {
                    const Token* returnTok = tok->astOperand1();
                    if (!returnTok || !returnTok->hasKnownIntValue() || !astIsBool(returnTok)) {
                        alwaysTrue = false;
                        alwaysFalse = false;
                        return;
                    }
                    (returnTok->getKnownIntValue() ? alwaysTrue : alwaysFalse) &= true;
                    (returnTok->getKnownIntValue() ...",9,9,lib/checkstl.cpp,LoopAnalyzer.findAlgo<const>:string(),<empty>,,false,2889,2919,findAlgo,,,12,string()
111669152062,METHOD,LoopAnalyzer,TYPE_DECL,"bool isLocalVar(const Variable* var) const
        {
            if (!var)
                return false;
            if (var->isPointer() || var->isReference())
                return false;
            if (var->declarationId() == loopVar->varId())
                return false;
            const Scope* scope = var->scope();
            return scope && scope->isNestedIn(bodyTok->scope());
        }",9,9,lib/checkstl.cpp,LoopAnalyzer.isLocalVar<const>:bool(Variable*),<empty>,,false,2921,2931,isLocalVar,,,13,bool(Variable*)
111669152063,METHOD,LoopAnalyzer,TYPE_DECL,"void findChangedVariables()
        {
            std::set<nonneg int> vars;
            for (const Token* tok = bodyTok; precedes(tok, bodyTok->link()); tok = tok->next()) {
                if (tok->varId() == 0)
                    continue;
                if (vars.count(tok->varId()) > 0)
                    continue;
                if (isLocalVar(tok->variable())) {
                    vars.insert(tok->varId());
                    continue;
                }
                if (!isModified(tok))
                    continue;
                varsChanged.insert(tok->varId());
                vars.insert(tok->varId());
            }
        }",9,21,lib/checkstl.cpp,LoopAnalyzer.findChangedVariables:void(),<empty>,,false,2934,2951,findChangedVariables,,,14,void()
111669152064,METHOD,<empty>,<empty>,<empty>,5,,lib/checkstl.cpp,LoopAnalyzer.<clinit>,<empty>,,false,2821,,<clinit>,,,15,
111669152065,METHOD,<empty>,<empty>,"[](const Token* tok) {
        if (astIsBool(tok)) // std::accumulate is not a good fit for bool values, std::all/any/none_of return early
            return false;
        return !astIsContainer(tok); // don't warn for containers, where overloaded operators can be costly
    }",26,5,lib/checkstl.cpp,lib/checkstl.cpp:<global>.CheckStl.useStlAlgorithm.<lambda>18:bool(Token*),<empty>,,false,2962,2966,<lambda>18,,,1,bool(Token*)
111669152066,METHOD,<empty>,<empty>,"[this](const Token* tok, ConditionOpType& type) -> bool {
        if (!Token::simpleMatch(tok, ""{"") || !Token::simpleMatch(tok->previous(), "")""))
            return false;
        const Token* condTok = tok->linkAt(-1)->astOperand2();
        if (isConstExpression(condTok, mSettings->library)) {
            if (condTok->str() == ""<"")
                type = ConditionOpType::MIN;
            else if (condTok->str() == "">"")
                type = ConditionOpType::MAX;
            else
                type = ConditionOpType::OTHER;
            return true;
        }
        return false;
    }",42,5,lib/checkstl.cpp,"lib/checkstl.cpp:<global>.CheckStl.useStlAlgorithm.<lambda>19:bool(Token*,ConditionOpType&)",<empty>,,false,2969,2983,<lambda>19,,,1,"bool(Token*,ConditionOpType&)"
111669152067,METHOD,<empty>,<empty>,"[](const Token* tok, int varId) {
        if (tok->str() != ""="")
            return true;
        const Token* end = Token::findmatch(tok, ""%varid%|;"", varId); // TODO: lambdas?
        return end && end->varId() != 0;
    }",27,5,lib/checkstl.cpp,"lib/checkstl.cpp:<global>.CheckStl.useStlAlgorithm.<lambda>20:bool(Token*,int)",<empty>,,false,2985,2990,<lambda>20,,,1,"bool(Token*,int)"
111669152068,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::useStlAlgorithm()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""useStlAlgorithm""))
        return;

    logChecker(""CheckStl::useStlAlgorithm""); // style

    auto checkAssignee = [](const Token* tok) {
        if (astIsBool(tok)) // std::accumulate is not a good fit for bool values, std::all/any/none_of return early
            return false;
        return !astIsContainer(tok); // don't warn for containers, where overloaded operators can be costly
    };

    enum class ConditionOpType : std::uint8_t { OTHER, MIN, MAX };
    auto isConditionWithoutSideEffects = [this](const Token* tok, ConditionOpType& type) -> bool {
        if (!Token::simpleMatch(tok, ""{"") || !Token::simpleMatch(tok->previous(), "")""))
            return false;
        const Token* condTok = tok->linkAt(-1)->astOperand2();
        if (isConstExpression(condTok, mSettings->library)) {
            if (condTok->str() == ""<"")
                type = Condition...",1,1,lib/checkstl.cpp,CheckStl.useStlAlgorithm:void(),<empty>,,false,2955,3189,useStlAlgorithm,,,1,void()
111669152069,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::knownEmptyContainerError(const Token *tok, const std::string& algo)
{
    const std::string var = tok ? tok->expressionString() : std::string(""var"");

    std::string msg;
    if (astIsIterator(tok)) {
        msg = ""Using "" + algo + "" with iterator '"" + var + ""' that is always empty."";
    } else {
        msg = ""Iterating over container '"" + var + ""' that is always empty."";
    }

    reportError(tok, Severity::style,
                ""knownEmptyContainer"",
                msg, CWE398, Certainty::normal);
}",1,1,lib/checkstl.cpp,"CheckStl.knownEmptyContainerError:void(Token*,std.string&)",<empty>,,false,3191,3205,knownEmptyContainerError,,,1,"void(Token*,std.string&)"
111669152070,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
        if (!v.isKnown())
            return false;
        if (!v.isContainerSizeValue())
            return false;
        if (v.intvalue != 0)
            return false;
        return true;
    }",68,5,lib/checkstl.cpp,lib/checkstl.cpp:<global>.isKnownEmptyContainer.<lambda>21:bool(ValueFlow.Value&),<empty>,,false,3211,3219,<lambda>21,,,1,bool(ValueFlow.Value&)
111669152071,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static bool isKnownEmptyContainer(const Token* tok)
{
    if (!tok)
        return false;
    return std::any_of(tok->values().begin(), tok->values().end(), [&](const ValueFlow::Value& v) {
        if (!v.isKnown())
            return false;
        if (!v.isContainerSizeValue())
            return false;
        if (v.intvalue != 0)
            return false;
        return true;
    });
}",1,1,lib/checkstl.cpp,isKnownEmptyContainer:bool(Token*),<empty>,,false,3207,3220,isKnownEmptyContainer,,,1,bool(Token*)
111669152072,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::knownEmptyContainer()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""knownEmptyContainer""))
        return;
    logChecker(""CheckStl::knownEmptyContainer""); // style
    for (const Scope *function : mTokenizer->getSymbolDatabase()->functionScopes) {
        for (const Token *tok = function->bodyStart; tok != function->bodyEnd; tok = tok->next()) {

            if (!Token::Match(tok, ""%name% ( !!)""))
                continue;

            // Parse range-based for loop
            if (tok->str() == ""for"") {
                if (!Token::simpleMatch(tok->linkAt(1), "") {""))
                    continue;
                const Token *splitTok = tok->next()->astOperand2();
                if (!Token::simpleMatch(splitTok, "":""))
                    continue;
                const Token* contTok = splitTok->astOperand2();
                if (!isKnownEmptyContainer(contTok))
                    continue;
                knownEmptyContai...",1,1,lib/checkstl.cpp,CheckStl.knownEmptyContainer:void(),<empty>,,false,3222,3263,knownEmptyContainer,,,1,void()
111669152073,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::eraseIteratorOutOfBoundsError(const Token *ftok, const Token* itertok, const ValueFlow::Value* val)
{
    if (!ftok || !itertok || !val) {
        reportError(ftok, Severity::error, ""eraseIteratorOutOfBounds"",
                    ""Calling function 'erase()' on the iterator 'iter' which is out of bounds."", CWE628, Certainty::normal);
        reportError(ftok, Severity::warning, ""eraseIteratorOutOfBoundsCond"",
                    ""Either the condition 'x' is redundant or function 'erase()' is called on the iterator 'iter' which is out of bounds."", CWE628, Certainty::normal);
        return;
    }
    const std::string& func = ftok->str();
    const std::string iter = itertok->expressionString();

    const bool isConditional = val->isPossible();
    std::string msg;
    if (isConditional) {
        msg = ValueFlow::eitherTheConditionIsRedundant(val->condition) + "" or function '"" + func + ""()' is called on the iterator '"" + iter + ""' which is out of bounds."";
    } else ...",1,1,lib/checkstl.cpp,"CheckStl.eraseIteratorOutOfBoundsError:void(Token*,Token*,ValueFlow.Value*)",<empty>,,false,3265,3290,eraseIteratorOutOfBoundsError,,,1,"void(Token*,Token*,ValueFlow.Value*)"
111669152074,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
        if (v.isPossible() || v.isKnown()) {
            switch (v.valueType) {
            case ValueFlow::Value::ValueType::ITERATOR_END:
                return v.intvalue >= 0;
            case ValueFlow::Value::ValueType::ITERATOR_START:
                return (v.intvalue < 0) || (sizeVal && v.intvalue >= sizeVal->intvalue);
            default:
                break;
            }
        }
        return false;
    }",72,5,lib/checkstl.cpp,lib/checkstl.cpp:<global>.getOOBIterValue.<lambda>22:bool(ValueFlow.Value&),<empty>,,false,3294,3306,<lambda>22,,,1,bool(ValueFlow.Value&)
111669152075,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static const ValueFlow::Value* getOOBIterValue(const Token* tok, const ValueFlow::Value* sizeVal)
{
    auto it = std::find_if(tok->values().begin(), tok->values().end(), [&](const ValueFlow::Value& v) {
        if (v.isPossible() || v.isKnown()) {
            switch (v.valueType) {
            case ValueFlow::Value::ValueType::ITERATOR_END:
                return v.intvalue >= 0;
            case ValueFlow::Value::ValueType::ITERATOR_START:
                return (v.intvalue < 0) || (sizeVal && v.intvalue >= sizeVal->intvalue);
            default:
                break;
            }
        }
        return false;
    });
    return it != tok->values().end() ? &*it : nullptr;
}",1,1,lib/checkstl.cpp,"getOOBIterValue:ValueFlow.Value*(Token*,ValueFlow.Value*)",<empty>,,false,3292,3308,getOOBIterValue,,,1,"ValueFlow.Value*(Token*,ValueFlow.Value*)"
111669152076,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::eraseIteratorOutOfBounds()
{
    logChecker(""CheckStl::eraseIteratorOutOfBounds"");
    for (const Scope *function : mTokenizer->getSymbolDatabase()->functionScopes) {
        for (const Token *tok = function->bodyStart; tok != function->bodyEnd; tok = tok->next()) {

            if (!tok->valueType())
                continue;
            const Library::Container* container = tok->valueType()->container;
            if (!container || !astIsLHS(tok) || !Token::simpleMatch(tok->astParent(), "".""))
                continue;
            const Token* const ftok = tok->astParent()->astOperand2();
            const Library::Container::Action action = container->getAction(ftok->str());
            if (action != Library::Container::Action::ERASE)
                continue;
            const std::vector<const Token*> args = getArguments(ftok);
            if (args.size() != 1) // TODO: check range overload
                continue;

            const ValueFlow::Value* sizeVal = t...",1,1,lib/checkstl.cpp,CheckStl.eraseIteratorOutOfBounds:void(),<empty>,,false,3310,3334,eraseIteratorOutOfBounds,,,1,void()
111669152077,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static bool isMutex(const Variable* var)
{
    const Token* tok = Token::typeDecl(var->nameToken()).first;
    return Token::Match(tok, ""std :: mutex|recursive_mutex|timed_mutex|recursive_timed_mutex|shared_mutex"");
}",1,1,lib/checkstl.cpp,isMutex:bool(Variable*),<empty>,,false,3336,3340,isMutex,,,1,bool(Variable*)
111669152078,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static bool isLockGuard(const Variable* var)
{
    const Token* tok = Token::typeDecl(var->nameToken()).first;
    return Token::Match(tok, ""std :: lock_guard|unique_lock|scoped_lock|shared_lock"");
}",1,1,lib/checkstl.cpp,isLockGuard:bool(Variable*),<empty>,,false,3342,3346,isLockGuard,,,1,bool(Variable*)
111669152079,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"static bool isLocalMutex(const Variable* var, const Scope* scope)
{
    if (!var)
        return false;
    if (isLockGuard(var))
        return false;
    return !var->isReference() && !var->isRValueReference() && !var->isStatic() && var->scope() == scope;
}",1,1,lib/checkstl.cpp,"isLocalMutex:bool(Variable*,Scope*)",<empty>,,false,3348,3355,isLocalMutex,,,1,"bool(Variable*,Scope*)"
111669152080,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::globalLockGuardError(const Token* tok)
{
    reportError(tok, Severity::warning,
                ""globalLockGuard"",
                ""Lock guard is defined globally. Lock guards are intended to be local. A global lock guard could lead to a deadlock since it won't unlock until the end of the program."", CWE833, Certainty::normal);
}",1,1,lib/checkstl.cpp,CheckStl.globalLockGuardError:void(Token*),<empty>,,false,3357,3362,globalLockGuardError,,,1,void(Token*)
111669152081,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::localMutexError(const Token* tok)
{
    reportError(tok, Severity::warning,
                ""localMutex"",
                ""The lock is ineffective because the mutex is locked at the same scope as the mutex itself."", CWE667, Certainty::normal);
}",1,1,lib/checkstl.cpp,CheckStl.localMutexError:void(Token*),<empty>,,false,3364,3369,localMutexError,,,1,void(Token*)
111669152082,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::checkMutexes()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;
    logChecker(""CheckStl::checkMutexes""); // warning
    for (const Scope *function : mTokenizer->getSymbolDatabase()->functionScopes) {
        std::set<nonneg int> checkedVars;
        for (const Token *tok = function->bodyStart; tok != function->bodyEnd; tok = tok->next()) {
            if (!Token::Match(tok, ""%var%""))
                continue;
            const Variable* var = tok->variable();
            if (!var)
                continue;
            if (Token::Match(tok, ""%var% . lock ( )"")) {
                if (!isMutex(var))
                    continue;
                if (!checkedVars.insert(var->declarationId()).second)
                    continue;
                if (isLocalMutex(var, tok->scope()))
                    localMutexError(tok);
            } else if (Token::Match(tok, ""%var% (|{ %var% )|}|,"")) {
                if (!isLockGuard(var))
                ...",1,17,lib/checkstl.cpp,CheckStl.checkMutexes:void(),<empty>,,false,3371,3406,checkMutexes,,,1,void()
111669152083,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    if (!tokenizer.isCPP()) {
        return;
    }

    CheckStl checkStl(&tokenizer, &tokenizer.getSettings(), errorLogger);
    checkStl.erase();
    checkStl.if_find();
    checkStl.checkFindInsert();
    checkStl.iterators();
    checkStl.missingComparison();
    checkStl.outOfBounds();
    checkStl.outOfBoundsIndexExpression();
    checkStl.redundantCondition();
    checkStl.string_c_str();
    checkStl.uselessCalls();
    checkStl.useStlAlgorithm();

    checkStl.stlOutOfBounds();
    checkStl.negativeIndex();

    checkStl.invalidContainer();
    checkStl.mismatchingContainers();
    checkStl.mismatchingContainerIterator();
    checkStl.knownEmptyContainer();
    checkStl.eraseIteratorOutOfBounds();

    checkStl.stlBoundaries();
    checkStl.checkDereferenceInvalidIterator();
    checkStl.checkDereferenceInvalidIterator2();
    checkStl.checkMutexes();

    // Style check
    checkStl.size();
}",1,1,lib/checkstl.cpp,"CheckStl.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,3408,3443,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669152084,METHOD,lib/checkstl.cpp:<global>,TYPE_DECL,"void CheckStl::getErrorMessages(ErrorLogger* errorLogger, const Settings* settings) const
{
    CheckStl c(nullptr, settings, errorLogger);
    c.outOfBoundsError(nullptr, ""container"", nullptr, ""x"", nullptr);
    c.invalidIteratorError(nullptr, ""iterator"");
    c.iteratorsError(nullptr, ""container1"", ""container2"");
    c.iteratorsError(nullptr, nullptr, ""container0"", ""container1"");
    c.iteratorsError(nullptr, nullptr, ""container"");
    c.invalidContainerLoopError(nullptr, nullptr, ErrorPath{});
    c.invalidContainerError(nullptr, nullptr, nullptr, ErrorPath{});
    c.mismatchingContainerIteratorError(nullptr, nullptr, nullptr);
    c.mismatchingContainersError(nullptr, nullptr);
    c.mismatchingContainerExpressionError(nullptr, nullptr);
    c.sameIteratorExpressionError(nullptr);
    c.dereferenceErasedError(nullptr, nullptr, ""iter"", false);
    c.stlOutOfBoundsError(nullptr, ""i"", ""foo"", false);
    c.negativeIndexError(nullptr, ValueFlow::Value(-1));
    c.stlBoundariesError(n...",1,1,lib/checkstl.cpp,"CheckStl.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,3445,3484,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669152085,METHOD,lib/checkstl.h:<global>,TYPE_DECL,<global>,1,1,lib/checkstl.h,lib/checkstl.h:<global>,<empty>,,false,1,244,<global>,,,1,
111669152086,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"void CheckString::stringLiteralWrite()
{
    logChecker(""CheckString::stringLiteralWrite"");
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!tok->variable() || !tok->variable()->isPointer())
                continue;
            const Token *str = tok->getValueTokenMinStrSize(*mSettings);
            if (!str)
                continue;
            if (Token::Match(tok, ""%var% ["") && Token::simpleMatch(tok->linkAt(1), ""] =""))
                stringLiteralWriteError(tok, str);
            else if (Token::Match(tok->previous(), ""* %var% =""))
                stringLiteralWriteError(tok, str);
        }
    }
}",1,1,lib/checkstring.cpp,CheckString.stringLiteralWrite:void(),<empty>,,false,55,72,stringLiteralWrite,,,1,void()
111669152087,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,<global>,1,78,lib/checkstring.cpp,lib/checkstring.cpp:<global>,<empty>,,false,1,506,<global>,,,1,
111669152088,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"void CheckString::stringLiteralWriteError(const Token *tok, const Token *strValue)
{
    std::list<const Token*> callstack{ tok };
    if (strValue)
        callstack.push_back(strValue);

    std::string errmsg(""Modifying string literal"");
    if (strValue) {
        std::string s = strValue->str();
        // 20 is an arbitrary value, the max string length shown in a warning message
        if (s.size() > 20U)
            s.replace(17, std::string::npos, ""..\\"""");
        errmsg += "" "" + s;
    }
    errmsg += "" directly or indirectly is undefined behaviour."";

    reportError(callstack, Severity::error, ""stringLiteralWrite"", errmsg, CWE758, Certainty::normal);
}",1,1,lib/checkstring.cpp,"CheckString.stringLiteralWriteError:void(Token*,Token*)",<empty>,,false,74,91,stringLiteralWriteError,,,1,"void(Token*,Token*)"
111669152089,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"void CheckString::checkAlwaysTrueOrFalseStringCompare()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckString::checkAlwaysTrueOrFalseStringCompare""); // warning

    for (const Token* tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (tok->isName() && tok->strAt(1) == ""("" && Token::Match(tok, ""memcmp|strncmp|strcmp|stricmp|strverscmp|bcmp|strcmpi|strcasecmp|strncasecmp|strncasecmp_l|strcasecmp_l|wcsncasecmp|wcscasecmp|wmemcmp|wcscmp|wcscasecmp_l|wcsncasecmp_l|wcsncmp|_mbscmp|_mbscmp_l|_memicmp|_memicmp_l|_stricmp|_wcsicmp|wcsicmp|_mbsicmp|_stricmp_l|_wcsicmp_l|_mbsicmp_l"")) {
            if (Token::Match(tok->tokAt(2), ""%str% , %str% ,|)"")) {
                const std::string &str1 = tok->strAt(2);
                const std::string &str2 = tok->strAt(4);
                if (!tok->isExpandedMacro() && !tok->tokAt(2)->isExpandedMacro() && !tok->tokAt(4)->isExpandedMacro())
                    alwaysTrueFalseStringCompa...",1,1,lib/checkstring.cpp,CheckString.checkAlwaysTrueOrFalseStringCompare:void(),<empty>,,false,97,139,checkAlwaysTrueOrFalseStringCompare,,,1,void()
111669152090,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"void CheckString::alwaysTrueFalseStringCompareError(const Token *tok, const std::string& str1, const std::string& str2)
{
    constexpr std::size_t stringLen = 10;
    const std::string string1 = (str1.size() < stringLen) ? str1 : (str1.substr(0, stringLen-2) + "".."");
    const std::string string2 = (str2.size() < stringLen) ? str2 : (str2.substr(0, stringLen-2) + "".."");

    reportError(tok, Severity::warning, ""staticStringCompare"",
                ""Unnecessary comparison of static strings.\\n""
                ""The compared strings, '"" + string1 + ""' and '"" + string2 + ""', are always "" + (str1==str2?""identical"":""unequal"") + "". ""
                ""Therefore the comparison is unnecessary and looks suspicious."", (str1==str2)?CWE571:CWE570, Certainty::normal);
}",1,1,lib/checkstring.cpp,"CheckString.alwaysTrueFalseStringCompareError:void(Token*,std.string&,std.string&)",<empty>,,false,141,151,alwaysTrueFalseStringCompareError,,,1,"void(Token*,std.string&,std.string&)"
111669152091,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"void CheckString::alwaysTrueStringVariableCompareError(const Token *tok, const std::string& str1, const std::string& str2)
{
    reportError(tok, Severity::warning, ""stringCompare"",
                ""Comparison of identical string variables.\\n""
                ""The compared strings, '"" + str1 + ""' and '"" + str2 + ""', are identical. ""
                ""This could be a logic bug."", CWE571, Certainty::normal);
}",1,1,lib/checkstring.cpp,"CheckString.alwaysTrueStringVariableCompareError:void(Token*,std.string&,std.string&)",<empty>,,false,153,159,alwaysTrueStringVariableCompareError,,,1,"void(Token*,std.string&,std.string&)"
111669152092,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"void CheckString::checkSuspiciousStringCompare()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckString::checkSuspiciousStringCompare""); // warning

    const SymbolDatabase* symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!tok->isComparisonOp())
                continue;

            const Token* varTok = tok->astOperand1();
            const Token* litTok = tok->astOperand2();
            if (!varTok || !litTok)  // <- failed to create AST for comparison
                continue;
            if (Token::Match(varTok, ""%char%|%num%|%str%""))
                std::swap(varTok, litTok);
            else if (!Token::Match(litTok, ""%char%|%num%|%str%""))
                continue;

            if (varTok->isLiteral())
                continue;

            co...",1,1,lib/checkstring.cpp,CheckString.checkSuspiciousStringCompare:void(),<empty>,,false,166,203,checkSuspiciousStringCompare,,,1,void()
111669152093,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"void CheckString::suspiciousStringCompareError(const Token* tok, const std::string& var, bool isLong)
{
    const std::string cmpFunc = isLong ? ""wcscmp"" : ""strcmp"";
    reportError(tok, Severity::warning, ""literalWithCharPtrCompare"",
                ""$symbol:"" + var + ""\\nString literal compared with variable '$symbol'. Did you intend to use "" + cmpFunc + ""() instead?"", CWE595, Certainty::normal);
}",1,1,lib/checkstring.cpp,"CheckString.suspiciousStringCompareError:void(Token*,std.string&,bool)",<empty>,,false,205,210,suspiciousStringCompareError,,,1,"void(Token*,std.string&,bool)"
111669152094,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"void CheckString::suspiciousStringCompareError_char(const Token* tok, const std::string& var)
{
    reportError(tok, Severity::warning, ""charLiteralWithCharPtrCompare"",
                ""$symbol:"" + var + ""\\nChar literal compared with pointer '$symbol'. Did you intend to dereference it?"", CWE595, Certainty::normal);
}",1,1,lib/checkstring.cpp,"CheckString.suspiciousStringCompareError_char:void(Token*,std.string&)",<empty>,,false,212,216,suspiciousStringCompareError_char,,,1,"void(Token*,std.string&)"
111669152095,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"static bool isChar(const Variable* var)
{
    return (var && !var->isPointer() && !var->isArray() && (var->typeStartToken()->str() == ""char"" || var->typeStartToken()->str() == ""wchar_t""));
}",1,1,lib/checkstring.cpp,isChar:bool(Variable*),<empty>,,false,223,226,isChar,,,1,bool(Variable*)
111669152096,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"void CheckString::strPlusChar()
{
    logChecker(""CheckString::strPlusChar"");
    const SymbolDatabase* symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (tok->str() == ""+"") {
                if (tok->astOperand1() && (tok->astOperand1()->tokType() == Token::eString)) { // string literal...
                    if (tok->astOperand2() && (tok->astOperand2()->tokType() == Token::eChar || isChar(tok->astOperand2()->variable()))) // added to char variable or char constant
                        strPlusCharError(tok);
                }
            }
        }
    }
}",1,1,lib/checkstring.cpp,CheckString.strPlusChar:void(),<empty>,,false,228,242,strPlusChar,,,1,void()
111669152097,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"void CheckString::strPlusCharError(const Token *tok)
{
    std::string charType = ""char"";
    if (tok && tok->astOperand2() && tok->astOperand2()->variable())
        charType = tok->astOperand2()->variable()->typeStartToken()->str();
    else if (tok && tok->astOperand2() && tok->astOperand2()->tokType() == Token::eChar && tok->astOperand2()->isLong())
        charType = ""wchar_t"";
    reportError(tok, Severity::error, ""strPlusChar"", ""Unusual pointer arithmetic. A value of type '"" + charType +""' is added to a string literal."", CWE665, Certainty::normal);
}",1,1,lib/checkstring.cpp,CheckString.strPlusCharError:void(Token*),<empty>,,false,244,252,strPlusCharError,,,1,void(Token*)
111669152098,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"static bool isMacroUsage(const Token* tok)
{
    if (const Token* parent = tok->astParent()) {
        while (parent && (parent->isCast() || parent->str() == ""&&"")) {
            if (parent->isExpandedMacro())
                return true;
            parent = parent->astParent();
        }
        if (!parent)
            return false;
        if (parent->isExpandedMacro())
            return true;
        if (parent->isUnaryOp(""!"") || parent->isComparisonOp()) {
            int argn{};
            const Token* ftok = getTokenArgumentFunction(parent, argn);
            if (ftok && !ftok->function())
                return true;
        }
    }
    return false;
}",1,1,lib/checkstring.cpp,isMacroUsage:bool(Token*),<empty>,,false,254,274,isMacroUsage,,,1,bool(Token*)
111669152099,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"void CheckString::checkIncorrectStringCompare()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckString::checkIncorrectStringCompare""); // warning

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            // skip ""assert(str && ..)"" and ""assert(.. && str)""
            if ((endsWith(tok->str(), ""assert"") || endsWith(tok->str(), ""ASSERT"")) &&
                Token::Match(tok, ""%name% ("") &&
                (Token::Match(tok->tokAt(2), ""%str% &&"") || Token::Match(tok->linkAt(1)->tokAt(-2), ""&& %str% )"")))
                tok = tok->linkAt(1);

            if (Token::simpleMatch(tok, "". substr ("") && Token::Match(tok->tokAt(3)->nextArgument(), ""%num% )"")) {
                const MathLib::biguint clen = MathLib::toBigUNumber(tok->linkAt(2)->tok...",1,1,lib/checkstring.cpp,CheckString.checkIncorrectStringCompare:void(),<empty>,,false,280,326,checkIncorrectStringCompare,,,1,void()
111669152100,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"void CheckString::incorrectStringCompareError(const Token *tok, const std::string& func, const std::string &string)
{
    reportError(tok, Severity::warning, ""incorrectStringCompare"", ""$symbol:"" + func + ""\\nString literal "" + string + "" doesn't match length argument for $symbol()."", CWE570, Certainty::normal);
}",1,1,lib/checkstring.cpp,"CheckString.incorrectStringCompareError:void(Token*,std.string&,std.string&)",<empty>,,false,328,331,incorrectStringCompareError,,,1,"void(Token*,std.string&,std.string&)"
111669152101,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"void CheckString::incorrectStringBooleanError(const Token *tok, const std::string& string)
{
    const bool charLiteral = isCharLiteral(string);
    const std::string literalType = charLiteral ? ""char"" : ""string"";
    const std::string result = bool_to_string(getCharLiteral(string) != ""\\\\0"");
    reportError(tok,
                Severity::warning,
                charLiteral ? ""incorrectCharBooleanError"" : ""incorrectStringBooleanError"",
                ""Conversion of "" + literalType + "" literal "" + string + "" to bool always evaluates to "" + result + '.', CWE571, Certainty::normal);
}",1,1,lib/checkstring.cpp,"CheckString.incorrectStringBooleanError:void(Token*,std.string&)",<empty>,,false,333,342,incorrectStringBooleanError,,,1,"void(Token*,std.string&)"
111669152102,METHOD,<empty>,<empty>,"[&](const Token * t) {
                if (!t)
                    return ChildrenToVisit::none;
                if (t->str() == ""||"") {
                    return ChildrenToVisit::op1_and_op2;
                }
                if (t->str() == ""=="") {
                    if (Token::simpleMatch(t->astOperand1(), ""("") && Token::simpleMatch(t->astOperand2(), ""0""))
                        equals0.push_back(t->astOperand1());
                    else if (Token::simpleMatch(t->astOperand2(), ""("") && Token::simpleMatch(t->astOperand1(), ""0""))
                        equals0.push_back(t->astOperand2());
                    return ChildrenToVisit::none;
                }
                if (t->str() == ""!="") {
                    if (Token::simpleMatch(t->astOperand1(), ""("") && Token::simpleMatch(t->astOperand2(), ""0""))
                        notEquals0.push_back(t->astOperand1());
                    else if (Token::simpleMatch(t->astOperand2(), ""("") && Token::simpleMatch(t->astOperand1(),...",32,13,lib/checkstring.cpp,lib/checkstring.cpp:<global>.CheckString.overlappingStrcmp.<lambda>0:ChildrenToVisit(Token*),<empty>,,false,362,387,<lambda>0,,,1,ChildrenToVisit(Token*)
111669152103,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"void CheckString::overlappingStrcmp()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckString::overlappingStrcmp""); // warning

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (tok->str() != ""||"")
                continue;
            std::list<const Token *> equals0;
            std::list<const Token *> notEquals0;
            visitAstNodes(tok, [&](const Token * t) {
                if (!t)
                    return ChildrenToVisit::none;
                if (t->str() == ""||"") {
                    return ChildrenToVisit::op1_and_op2;
                }
                if (t->str() == ""=="") {
                    if (Token::simpleMatch(t->astOperand1(), ""("") && Token::simpleMatch(t->astOperand2(), ""0""))
                        ...",1,1,lib/checkstring.cpp,CheckString.overlappingStrcmp:void(),<empty>,,false,348,408,overlappingStrcmp,,,1,void()
111669152104,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"void CheckString::overlappingStrcmpError(const Token *eq0, const Token *ne0)
{
    std::string eq0Expr(eq0 ? eq0->expressionString() : std::string(""strcmp(x,\\""abc\\"")""));
    if (eq0 && eq0->astParent()->str() == ""!"")
        eq0Expr = ""!"" + eq0Expr;
    else
        eq0Expr += "" == 0"";

    const std::string ne0Expr = (ne0 ? ne0->expressionString() : std::string(""strcmp(x,\\""def\\"")"")) + "" != 0"";

    reportError(ne0, Severity::warning, ""overlappingStrcmp"", ""The expression '"" + ne0Expr + ""' is suspicious. It overlaps '"" + eq0Expr + ""'."");
}",1,1,lib/checkstring.cpp,"CheckString.overlappingStrcmpError:void(Token*,Token*)",<empty>,,false,410,421,overlappingStrcmpError,,,1,"void(Token*,Token*)"
111669152105,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"void CheckString::sprintfOverlappingData()
{
    logChecker(""CheckString::sprintfOverlappingData"");

    const SymbolDatabase* symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope * scope : symbolDatabase->functionScopes) {
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!Token::Match(tok, ""sprintf|snprintf|swprintf (""))
                continue;

            const std::vector<const Token *> args = getArguments(tok);

            const int formatString = Token::simpleMatch(tok, ""sprintf"") ? 1 : 2;
            for (unsigned int argnr = formatString + 1; argnr < args.size(); ++argnr) {
                const Token *dest = args[0];
                while (dest->isCast())
                    dest = dest->astOperand2() ? dest->astOperand2() : dest->astOperand1();
                const Token *arg = args[argnr];
                if (!arg->valueType() || arg->valueType()->pointer != 1)
                    c...",1,1,lib/checkstring.cpp,CheckString.sprintfOverlappingData:void(),<empty>,,false,427,462,sprintfOverlappingData,,,1,void()
111669152106,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"void CheckString::sprintfOverlappingDataError(const Token *funcTok, const Token *tok, const std::string &varname)
{
    const std::string func = funcTok ? funcTok->str() : ""s[n]printf"";

    reportError(tok, Severity::error, ""sprintfOverlappingData"",
                ""$symbol:"" + varname + ""\\n""
                ""Undefined behavior: Variable '$symbol' is used as parameter and destination in "" + func + ""().\\n"" +
                ""The variable '$symbol' is used both as a parameter and as destination in "" +
                func + ""(). The origin and destination buffers overlap. Quote from glibc (C-library) ""
                ""documentation (http://www.gnu.org/software/libc/manual/html_mono/libc.html#Formatted-Output-Functions): ""
                ""\\""If copying takes place between objects that overlap as a result of a call ""
                ""to sprintf() or snprintf(), the results are undefined.\\"""", CWE628, Certainty::normal);
}",1,1,lib/checkstring.cpp,"CheckString.sprintfOverlappingDataError:void(Token*,Token*,std.string&)",<empty>,,false,464,476,sprintfOverlappingDataError,,,1,"void(Token*,Token*,std.string&)"
111669152107,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"void CheckString::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    CheckString checkString(&tokenizer, &tokenizer.getSettings(), errorLogger);

    // Checks
    checkString.strPlusChar();
    checkString.checkSuspiciousStringCompare();
    checkString.stringLiteralWrite();
    checkString.overlappingStrcmp();
    checkString.checkIncorrectStringCompare();
    checkString.sprintfOverlappingData();
    checkString.checkAlwaysTrueOrFalseStringCompare();
}",1,1,lib/checkstring.cpp,"CheckString.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,478,490,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669152108,METHOD,lib/checkstring.cpp:<global>,TYPE_DECL,"void CheckString::getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const
{
    CheckString c(nullptr, settings, errorLogger);
    c.stringLiteralWriteError(nullptr, nullptr);
    c.sprintfOverlappingDataError(nullptr, nullptr, ""varname"");
    c.strPlusCharError(nullptr);
    c.incorrectStringCompareError(nullptr, ""substr"", ""\\""Hello World\\"""");
    c.suspiciousStringCompareError(nullptr, ""foo"", false);
    c.suspiciousStringCompareError_char(nullptr, ""foo"");
    c.incorrectStringBooleanError(nullptr, ""\\""Hello World\\"""");
    c.incorrectStringBooleanError(nullptr, ""\\'x\\'"");
    c.alwaysTrueFalseStringCompareError(nullptr, ""str1"", ""str2"");
    c.alwaysTrueStringVariableCompareError(nullptr, ""varname1"", ""varname2"");
    c.overlappingStrcmpError(nullptr, nullptr);
}",1,1,lib/checkstring.cpp,"CheckString.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,492,506,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669152109,METHOD,lib/checkstring.h:<global>,TYPE_DECL,<global>,1,1,lib/checkstring.h,lib/checkstring.h:<global>,<empty>,,false,1,105,<global>,,,1,
111669152110,METHOD,lib/checktype.cpp:<global>,TYPE_DECL,"void CheckType::checkTooBigBitwiseShift()
{
    // unknown sizeof(int) => can't run this checker
    if (mSettings->platform.type == Platform::Type::Unspecified)
        return;

    logChecker(""CheckType::checkTooBigBitwiseShift""); // platform

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        // C++ and macro: OUT(x<<y)
        if (tok->isCpp() && Token::Match(tok, ""[;{}] %name% ("") && Token::simpleMatch(tok->linkAt(2), "") ;"") && tok->next()->isUpperCaseName() && !tok->next()->function())
            tok = tok->linkAt(2);

        tok = skipUnreachableBranch(tok);

        if (!tok->astOperand1() || !tok->astOperand2())
            continue;

        if (!Token::Match(tok, ""<<|>>|<<=|>>=""))
            continue;

        // get number of bits of lhs
        const ValueType * const lhstype = tok->astOperand1()->valueType();
        if (!lhstype || !lhstype->isIntegral() || lhstype->pointer >= 1)
            continue;
        // C11 Standard, sectio...",1,1,lib/checktype.cpp,CheckType.checkTooBigBitwiseShift:void(),<empty>,,false,64,116,checkTooBigBitwiseShift,,,1,void()
111669152111,METHOD,lib/checktype.cpp:<global>,TYPE_DECL,<global>,1,78,lib/checktype.cpp,lib/checktype.cpp:<global>,<empty>,,false,1,550,<global>,,,1,
111669152112,METHOD,lib/checktype.cpp:<global>,TYPE_DECL,"void CheckType::tooBigBitwiseShiftError(const Token *tok, int lhsbits, const ValueFlow::Value &rhsbits)
{
    constexpr char id[] = ""shiftTooManyBits"";

    if (!tok) {
        reportError(tok, Severity::error, id, ""Shifting 32-bit value by 40 bits is undefined behaviour"", CWE758, Certainty::normal);
        return;
    }

    const ErrorPath errorPath = getErrorPath(tok, &rhsbits, ""Shift"");

    std::ostringstream errmsg;
    errmsg << ""Shifting "" << lhsbits << ""-bit value by "" << rhsbits.intvalue << "" bits is undefined behaviour"";
    if (rhsbits.condition)
        errmsg << "". See condition at line "" << rhsbits.condition->linenr() << ""."";

    reportError(errorPath, rhsbits.errorSeverity() ? Severity::error : Severity::warning, id, errmsg.str(), CWE758, rhsbits.isInconclusive() ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checktype.cpp,"CheckType.tooBigBitwiseShiftError:void(Token*,int,ValueFlow.Value&)",<empty>,,false,118,135,tooBigBitwiseShiftError,,,1,"void(Token*,int,ValueFlow.Value&)"
111669152113,METHOD,lib/checktype.cpp:<global>,TYPE_DECL,"void CheckType::tooBigSignedBitwiseShiftError(const Token *tok, int lhsbits, const ValueFlow::Value &rhsbits)
{
    constexpr char id[] = ""shiftTooManyBitsSigned"";

    const bool cpp14 = ((tok && tok->isCpp()) || (mTokenizer && mTokenizer->isCPP())) && (mSettings->standards.cpp >= Standards::CPP14);

    std::string behaviour = ""undefined"";
    if (cpp14)
        behaviour = ""implementation-defined"";
    if (!tok) {
        reportError(tok, Severity::error, id, ""Shifting signed 32-bit value by 31 bits is "" + behaviour + "" behaviour"", CWE758, Certainty::normal);
        return;
    }


    Severity severity = rhsbits.errorSeverity() ? Severity::error : Severity::warning;
    if (cpp14)
        severity = Severity::portability;

    if ((severity == Severity::portability) && !mSettings->severity.isEnabled(Severity::portability))
        return;
    const ErrorPath errorPath = getErrorPath(tok, &rhsbits, ""Shift"");

    std::ostringstream errmsg;
    errmsg << ""Shifting signed "" << lhs...",1,1,lib/checktype.cpp,"CheckType.tooBigSignedBitwiseShiftError:void(Token*,int,ValueFlow.Value&)",<empty>,,false,137,166,tooBigSignedBitwiseShiftError,,,1,"void(Token*,int,ValueFlow.Value&)"
111669152114,METHOD,lib/checktype.cpp:<global>,TYPE_DECL,"void CheckType::checkIntegerOverflow()
{
    // unknown sizeof(int) => can't run this checker
    if (mSettings->platform.type == Platform::Type::Unspecified || mSettings->platform.int_bit >= MathLib::bigint_bits)
        return;

    logChecker(""CheckType::checkIntegerOverflow""); // platform

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (!tok->isArithmeticalOp())
            continue;

        // is result signed integer?
        const ValueType *vt = tok->valueType();
        if (!vt || !vt->isIntegral() || vt->sign != ValueType::Sign::SIGNED)
            continue;

        unsigned int bits;
        if (vt->type == ValueType::Type::INT)
            bits = mSettings->platform.int_bit;
        else if (vt->type == ValueType::Type::LONG)
            bits = mSettings->platform.long_bit;
        else if (vt->type == ValueType::Type::LONGLONG)
            bits = mSettings->platform.long_long_bit;
        else
            continue;

        if (...",1,1,lib/checktype.cpp,CheckType.checkIntegerOverflow:void(),<empty>,,false,172,221,checkIntegerOverflow,,,1,void()
111669152115,METHOD,lib/checktype.cpp:<global>,TYPE_DECL,"void CheckType::integerOverflowError(const Token *tok, const ValueFlow::Value &value, bool isOverflow)
{
    const std::string expr(tok ? tok->expressionString() : """");
    const std::string type = isOverflow ? ""overflow"" : ""underflow"";

    std::string msg;
    if (value.condition)
        msg = ValueFlow::eitherTheConditionIsRedundant(value.condition) +
              "" or there is signed integer "" + type + "" for expression '"" + expr + ""'."";
    else
        msg = ""Signed integer "" + type + "" for expression '"" + expr + ""'."";

    if (value.safe)
        msg = ""Safe checks: "" + msg;

    reportError(getErrorPath(tok, &value, ""Integer "" + type),
                value.errorSeverity() ? Severity::error : Severity::warning,
                getMessageId(value, ""integerOverflow"").c_str(),
                msg,
                CWE190,
                value.isInconclusive() ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checktype.cpp,"CheckType.integerOverflowError:void(Token*,ValueFlow.Value&,bool)",<empty>,,false,223,244,integerOverflowError,,,1,"void(Token*,ValueFlow.Value&,bool)"
111669152116,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
                return !v.isImpossible() && v.isIntValue() && (v.intvalue <= -1 || v.wideintvalue <= -1);
            }",66,13,lib/checktype.cpp,lib/checktype.cpp:<global>.CheckType.checkSignConversion.<lambda>0:bool(ValueFlow.Value&),<empty>,,false,271,273,<lambda>0,,,1,bool(ValueFlow.Value&)
111669152117,METHOD,lib/checktype.cpp:<global>,TYPE_DECL,"void CheckType::checkSignConversion()
{
    if (!mSettings->severity.isEnabled(Severity::warning))
        return;

    logChecker(""CheckType::checkSignConversion""); // warning

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (!tok->isArithmeticalOp() || Token::Match(tok,""+|-""))
            continue;

        // Is result unsigned?
        if (!(tok->valueType() && tok->valueType()->sign == ValueType::Sign::UNSIGNED))
            continue;

        // Check if an operand can be negative..
        const Token * astOperands[] = { tok->astOperand1(), tok->astOperand2() };
        for (const Token * tok1 : astOperands) {
            if (!tok1)
                continue;
            const ValueFlow::Value* negativeValue =
                ValueFlow::findValue(tok1->values(), *mSettings, [&](const ValueFlow::Value& v) {
                return !v.isImpossible() && v.isIntValue() && (v.intvalue <= -1 || v.wideintvalue <= -1);
            });
            ...",1,1,lib/checktype.cpp,CheckType.checkSignConversion:void(),<empty>,,false,250,280,checkSignConversion,,,1,void()
111669152118,METHOD,lib/checktype.cpp:<global>,TYPE_DECL,"void CheckType::signConversionError(const Token *tok, const ValueFlow::Value *negativeValue, const bool constvalue)
{
    const std::string expr(tok ? tok->expressionString() : ""var"");

    std::ostringstream msg;
    if (tok && tok->isName())
        msg << ""$symbol:"" << expr << ""\\n"";
    if (constvalue)
        msg << ""Expression '"" << expr << ""' has a negative value. That is converted to an unsigned value and used in an unsigned calculation."";
    else
        msg << ""Expression '"" << expr << ""' can have a negative value. That is converted to an unsigned value and used in an unsigned calculation."";

    if (!negativeValue)
        reportError(tok, Severity::warning, ""signConversion"", msg.str(), CWE195, Certainty::normal);
    else {
        const ErrorPath &errorPath = getErrorPath(tok,negativeValue,""Negative value is converted to an unsigned value"");
        reportError(errorPath,
                    Severity::warning,
                    Check::getMessageId(*negativeValue, ""sig...",1,1,lib/checktype.cpp,"CheckType.signConversionError:void(Token*,ValueFlow.Value*,bool)",<empty>,,false,282,305,signConversionError,,,1,"void(Token*,ValueFlow.Value*,bool)"
111669152119,METHOD,<empty>,<empty>,"[&](const std::pair<ValueType::Type, ValueType::Type>& p) {
        return src.type == p.first && tgt.type == p.second;
    }",82,5,lib/checktype.cpp,"lib/checktype.cpp:<global>.checkTypeCombination.<lambda>1:bool(std.pair<ValueType.Type,ValueType.Type>&)",<empty>,,false,330,332,<lambda>1,,,1,"bool(std.pair<ValueType.Type,ValueType.Type>&)"
111669152120,METHOD,lib/checktype.cpp:<global>,TYPE_DECL,"static bool checkTypeCombination(ValueType src, ValueType tgt, const Settings& settings)
{
    static const std::pair<ValueType::Type, ValueType::Type> typeCombinations[] = {
        { ValueType::Type::INT, ValueType::Type::LONG },
        { ValueType::Type::INT, ValueType::Type::LONGLONG },
        { ValueType::Type::LONG, ValueType::Type::LONGLONG },
        { ValueType::Type::FLOAT, ValueType::Type::DOUBLE },
        { ValueType::Type::FLOAT, ValueType::Type::LONGDOUBLE },
        { ValueType::Type::DOUBLE, ValueType::Type::LONGDOUBLE },
    };

    src.reference = Reference::None;
    tgt.reference = Reference::None;

    const std::size_t sizeSrc = ValueFlow::getSizeOf(src, settings);
    const std::size_t sizeTgt = ValueFlow::getSizeOf(tgt, settings);
    if (!(sizeSrc > 0 && sizeTgt > 0 && sizeSrc < sizeTgt))
        return false;

    return std::any_of(std::begin(typeCombinations), std::end(typeCombinations), [&](const std::pair<ValueType::Type, ValueType::Type>& p) {
     ...",1,1,lib/checktype.cpp,"checkTypeCombination:bool(ValueType,ValueType,Settings&)",<empty>,,false,311,333,checkTypeCombination,,,1,"bool(ValueType,ValueType,Settings&)"
111669152121,METHOD,lib/checktype.cpp:<global>,TYPE_DECL,"void CheckType::checkLongCast()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""truncLongCastAssignment""))
        return;

    logChecker(""CheckType::checkLongCast""); // style

    // Assignments..
    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (tok->str() != ""="" || !Token::Match(tok->astOperand2(), ""*|<<"") || tok->astOperand2()->isUnaryOp(""*""))
            continue;

        if (const ValueFlow::Value* v = tok->astOperand2()->getKnownValue(ValueFlow::Value::ValueType::INT)) {
            if (mSettings->platform.isIntValue(v->intvalue))
                continue;
        }

        const ValueType *lhstype = tok->astOperand1() ? tok->astOperand1()->valueType() : nullptr;
        const ValueType *rhstype = tok->astOperand2()->valueType();

        if (!lhstype || !rhstype)
            continue;
        if (!checkTypeCombination(*rhstype, *lhstype, *mSettings))
            continue;

        // assign i...",1,1,lib/checktype.cpp,CheckType.checkLongCast:void(),<empty>,,false,335,400,checkLongCast,,,1,void()
111669152122,METHOD,lib/checktype.cpp:<global>,TYPE_DECL,"static void makeBaseTypeString(std::string& typeStr)
{
    const auto pos = typeStr.find(""signed"");
    if (pos != std::string::npos)
        typeStr.erase(typeStr.begin(), typeStr.begin() + pos + 6 + 1);
}",1,1,lib/checktype.cpp,makeBaseTypeString:void(std.string&),<empty>,,false,402,407,makeBaseTypeString,,,1,void(std.string&)
111669152123,METHOD,lib/checktype.cpp:<global>,TYPE_DECL,"void CheckType::longCastAssignError(const Token *tok, const ValueType* src, const ValueType* tgt)
{
    std::string srcStr = src ? src->str() : ""int"";
    makeBaseTypeString(srcStr);
    std::string tgtStr = tgt ? tgt->str() : ""long"";
    makeBaseTypeString(tgtStr);
    reportError(tok,
                Severity::style,
                ""truncLongCastAssignment"",
                srcStr + "" result is assigned to "" + tgtStr + "" variable. If the variable is "" + tgtStr + "" to avoid loss of information, then you have loss of information.\\n"" +
                srcStr + "" result is assigned to "" + tgtStr + "" variable. If the variable is "" + tgtStr + "" to avoid loss of information, then there is loss of information. To avoid loss of information you must cast a calculation operand to "" + tgtStr + "", for example 'l = a * b;' => 'l = ("" + tgtStr + "")a * b;'."", CWE197, Certainty::normal);
}",1,1,lib/checktype.cpp,"CheckType.longCastAssignError:void(Token*,ValueType*,ValueType*)",<empty>,,false,409,420,longCastAssignError,,,1,"void(Token*,ValueType*,ValueType*)"
111669152124,METHOD,lib/checktype.cpp:<global>,TYPE_DECL,"void CheckType::longCastReturnError(const Token *tok, const ValueType* src, const ValueType* tgt)
{
    std::string srcStr = src ? src->str() : ""int"";
    makeBaseTypeString(srcStr);
    std::string tgtStr = tgt ? tgt->str() : ""long"";
    makeBaseTypeString(tgtStr);
    reportError(tok,
                Severity::style,
                ""truncLongCastReturn"",
                srcStr +"" result is returned as "" + tgtStr + "" value. If the return value is "" + tgtStr + "" to avoid loss of information, then you have loss of information.\\n"" +
                srcStr +"" result is returned as "" + tgtStr + "" value. If the return value is "" + tgtStr + "" to avoid loss of information, then there is loss of information. To avoid loss of information you must cast a calculation operand to long, for example 'return a*b;' => 'return (long)a*b'."", CWE197, Certainty::normal);
}",1,1,lib/checktype.cpp,"CheckType.longCastReturnError:void(Token*,ValueType*,ValueType*)",<empty>,,false,422,433,longCastReturnError,,,1,"void(Token*,ValueType*,ValueType*)"
111669152125,METHOD,lib/checktype.cpp:<global>,TYPE_DECL,"void CheckType::checkFloatToIntegerOverflow()
{
    logChecker(""CheckType::checkFloatToIntegerOverflow"");

    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        const ValueType *vtint, *vtfloat;

        // Explicit cast
        if (Token::Match(tok, ""( %name%"") && tok->astOperand1() && !tok->astOperand2()) {
            if (isUnreachableOperand(tok))
                continue;
            vtint = tok->valueType();
            vtfloat = tok->astOperand1()->valueType();
            checkFloatToIntegerOverflow(tok, vtint, vtfloat, tok->astOperand1()->values());
        }

        // Assignment
        else if (tok->str() == ""="" && tok->astOperand1() && tok->astOperand2()) {
            if (isUnreachableOperand(tok))
                continue;
            vtint = tok->astOperand1()->valueType();
            vtfloat = tok->astOperand2()->valueType();
            checkFloatToIntegerOverflow(tok, vtint, vtfloat, tok->astOperand2()->values());
        }

       ...",1,1,lib/checktype.cpp,CheckType.checkFloatToIntegerOverflow:void(),<empty>,,false,439,477,checkFloatToIntegerOverflow,,,1,void()
111669152126,METHOD,lib/checktype.cpp:<global>,TYPE_DECL,"void CheckType::checkFloatToIntegerOverflow(const Token *tok, const ValueType *vtint, const ValueType *vtfloat, const std::list<ValueFlow::Value> &floatValues)
{
    // Conversion of float to integer?
    if (!vtint || !vtint->isIntegral())
        return;
    if (!vtfloat || !vtfloat->isFloat())
        return;

    for (const ValueFlow::Value &f : floatValues) {
        if (f.valueType != ValueFlow::Value::ValueType::FLOAT)
            continue;
        if (!mSettings->isEnabled(&f, false))
            continue;
        if (f.floatValue >= std::exp2(mSettings->platform.long_long_bit))
            floatToIntegerOverflowError(tok, f);
        else if ((-f.floatValue) > std::exp2(mSettings->platform.long_long_bit - 1))
            floatToIntegerOverflowError(tok, f);
        else if (mSettings->platform.type != Platform::Type::Unspecified) {
            int bits = 0;
            if (vtint->type == ValueType::Type::CHAR)
                bits = mSettings->platform.char_bit;
           ...",1,1,lib/checktype.cpp,"CheckType.checkFloatToIntegerOverflow:void(Token*,ValueType*,ValueType*,std.list<ValueFlow.Value>&)",<empty>,,false,479,514,checkFloatToIntegerOverflow,,,1,"void(Token*,ValueType*,ValueType*,std.list<ValueFlow.Value>&)"
111669152127,METHOD,lib/checktype.cpp:<global>,TYPE_DECL,"void CheckType::floatToIntegerOverflowError(const Token *tok, const ValueFlow::Value &value)
{
    std::ostringstream errmsg;
    errmsg << ""Undefined behaviour: float ("" << value.floatValue << "") to integer conversion overflow."";
    reportError(getErrorPath(tok, &value, ""float to integer conversion""),
                value.errorSeverity() ? Severity::error : Severity::warning,
                ""floatConversionOverflow"",
                errmsg.str(), CWE190, value.isInconclusive() ? Certainty::inconclusive : Certainty::normal);
}",1,1,lib/checktype.cpp,"CheckType.floatToIntegerOverflowError:void(Token*,ValueFlow.Value&)",<empty>,,false,516,524,floatToIntegerOverflowError,,,1,"void(Token*,ValueFlow.Value&)"
111669152128,METHOD,lib/checktype.cpp:<global>,TYPE_DECL,"void CheckType::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    // These are not ""simplified"" because casts can't be ignored
    CheckType checkType(&tokenizer, &tokenizer.getSettings(), errorLogger);
    checkType.checkTooBigBitwiseShift();
    checkType.checkIntegerOverflow();
    checkType.checkSignConversion();
    checkType.checkLongCast();
    checkType.checkFloatToIntegerOverflow();
}",1,1,lib/checktype.cpp,"CheckType.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,526,535,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669152129,METHOD,lib/checktype.cpp:<global>,TYPE_DECL,"void CheckType::getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const
{
    CheckType c(nullptr, settings, errorLogger);
    c.tooBigBitwiseShiftError(nullptr, 32, ValueFlow::Value(64));
    c.tooBigSignedBitwiseShiftError(nullptr, 31, ValueFlow::Value(31));
    c.integerOverflowError(nullptr, ValueFlow::Value(1LL<<32));
    c.signConversionError(nullptr, nullptr, false);
    c.longCastAssignError(nullptr);
    c.longCastReturnError(nullptr);
    ValueFlow::Value f;
    f.valueType = ValueFlow::Value::ValueType::FLOAT;
    f.floatValue = 1E100;
    c.floatToIntegerOverflowError(nullptr, f);
}",1,1,lib/checktype.cpp,"CheckType.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,537,550,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669152130,METHOD,lib/checktype.h:<global>,TYPE_DECL,<global>,1,1,lib/checktype.h,lib/checktype.h:<global>,<empty>,,false,1,103,<global>,,,1,
111669152131,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"static const Token *getAstParentSkipPossibleCastAndAddressOf(const Token *vartok, bool *unknown)
{
    if (unknown)
        *unknown = false;
    if (!vartok)
        return nullptr;
    const Token *parent = vartok->astParent();
    while (Token::Match(parent, "".|::""))
        parent = parent->astParent();
    if (!parent)
        return nullptr;
    if (parent->isUnaryOp(""&""))
        parent = parent->astParent();
    else if (parent->str() == ""&"" && vartok == parent->astOperand2() && Token::Match(parent->astOperand1()->previous(), ""( %type% )"")) {
        parent = parent->astParent();
        if (unknown)
            *unknown = true;
    }
    while (parent && parent->isCast())
        parent = parent->astParent();
    return parent;
}",1,1,lib/checkuninitvar.cpp,"getAstParentSkipPossibleCastAndAddressOf:Token*(Token*,bool*)",<empty>,,false,60,81,getAstParentSkipPossibleCastAndAddressOf,,,1,"Token*(Token*,bool*)"
111669152132,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,<global>,1,78,lib/checkuninitvar.cpp,lib/checkuninitvar.cpp:<global>,<empty>,,false,1,1815,<global>,,,1,
111669152133,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"static std::map<nonneg int, VariableValue> getVariableValues(const Token* tok) {
    std::map<nonneg int, VariableValue> ret;
    if (!tok || !tok->scope()->isExecutable())
        return ret;
    while (tok && tok->str() != ""{"") {
        if (tok->str() == ""}"") {
            if (tok->link()->isBinaryOp())
                tok = tok->link()->previous();
            else
                break;
        }
        if (Token::Match(tok, ""%var% =|{"") && tok->next()->isBinaryOp() && tok->varId() && ret.count(tok->varId()) == 0) {
            const Token* rhs = tok->next()->astOperand2();
            if (rhs && rhs->hasKnownIntValue())
                ret[tok->varId()] = VariableValue(rhs->getKnownIntValue());
        }
        tok = tok->previous();
    }
    return ret;
}",1,16,lib/checkuninitvar.cpp,"getVariableValues:map<int,VariableValue>(Token*)",<empty>,,false,83,102,getVariableValues,,,1,"map<int,VariableValue>(Token*)"
111669152134,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"bool CheckUninitVar::diag(const Token* tok)
{
    if (!tok)
        return true;
    while (Token::Match(tok->astParent(), ""*|&|.""))
        tok = tok->astParent();
    return !mUninitDiags.insert(tok).second;
}",1,1,lib/checkuninitvar.cpp,CheckUninitVar.diag:bool(Token*),<empty>,,false,104,111,diag,,,1,bool(Token*)
111669152135,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"void CheckUninitVar::check()
{
    logChecker(""CheckUninitVar::check"");

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    std::set<std::string> arrayTypeDefs;
    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""%name% ["") && tok->variable() && Token::Match(tok->variable()->typeStartToken(), ""%type% %var% ;""))
            arrayTypeDefs.insert(tok->variable()->typeStartToken()->str());
    }

    // check every executable scope
    for (const Scope &scope : symbolDatabase->scopeList) {
        if (scope.isExecutable()) {
            checkScope(&scope, arrayTypeDefs);
        }
    }
}",1,1,lib/checkuninitvar.cpp,CheckUninitVar.check:void(),<empty>,,false,113,131,check,,,1,void()
111669152136,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"void CheckUninitVar::checkScope(const Scope* scope, const std::set<std::string> &arrayTypeDefs)
{
    for (const Variable &var : scope->varlist) {
        if ((mTokenizer->isCPP() && var.type() && !var.isPointer() && var.type()->needInitialization != Type::NeedInitialization::True) ||
            var.isStatic() || var.isExtern() || var.isReference())
            continue;

        // don't warn for try/catch exception variable
        if (var.isThrow())
            continue;

        if (Token::Match(var.nameToken()->next(), ""[({:]""))
            continue;

        if (Token::Match(var.nameToken(), ""%name% ="")) { // Variable is initialized, but Rhs might be not
            checkRhs(var.nameToken(), var, NO_ALLOC, 0U, emptyString);
            continue;
        }
        if (Token::Match(var.nameToken(), ""%name% ) ("") && Token::simpleMatch(var.nameToken()->linkAt(2), "") ="")) { // Function pointer is initialized, but Rhs might be not
            checkRhs(var.nameToken()->linkAt(2)->ne...",1,25,lib/checkuninitvar.cpp,"CheckUninitVar.checkScope:void(Scope*,std.set<std.string>&)",<empty>,,false,133,236,checkScope,,,1,"void(Scope*,std.set<std.string>&)"
111669152137,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"void CheckUninitVar::checkStruct(const Token *tok, const Variable &structvar)
{
    const Token *typeToken = structvar.typeStartToken();
    while (Token::Match(typeToken, ""%name% ::""))
        typeToken = typeToken->tokAt(2);
    const SymbolDatabase * symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Scope *scope2 : symbolDatabase->classAndStructScopes) {
        if (scope2->className == typeToken->str() && scope2->numConstructors == 0U) {
            for (const Variable &var : scope2->varlist) {
                if (var.isStatic() || var.hasDefault() || var.isArray() ||
                    (!mTokenizer->isC() && var.isClass() && (!var.type() || var.type()->needInitialization != Type::NeedInitialization::True)))
                    continue;

                // is the variable declared in a inner union?
                bool innerunion = false;
                for (const Scope *innerScope : scope2->nestedList) {
                    if (innerScope->type == ScopeType::e...",1,29,lib/checkuninitvar.cpp,"CheckUninitVar.checkStruct:void(Token*,Variable&)",<empty>,,false,238,274,checkStruct,,,1,"void(Token*,Variable&)"
111669152138,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"static VariableValue operator!(VariableValue v)
{
    v.notEqual = !v.notEqual;
    return v;
}",1,1,lib/checkuninitvar.cpp,!:VariableValue(VariableValue),<empty>,,false,276,280,!,,,1,VariableValue(VariableValue)
111669152139,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"static bool operator==(const VariableValue & v, MathLib::bigint i)
{
    return v.notEqual ? (i != v.value) : (i == v.value);
}",1,1,lib/checkuninitvar.cpp,"==:bool(VariableValue&,MathLib.bigint)",<empty>,,false,281,284,==,,,1,"bool(VariableValue&,MathLib.bigint)"
111669152140,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"static bool operator!=(const VariableValue & v, MathLib::bigint i)
{
    return v.notEqual ? (i == v.value) : (i != v.value);
}",1,1,lib/checkuninitvar.cpp,"!=:bool(VariableValue&,MathLib.bigint)",<empty>,,false,285,288,!=,,,1,"bool(VariableValue&,MathLib.bigint)"
111669152141,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"static void conditionAlwaysTrueOrFalse(const Token *tok, const std::map<nonneg int, VariableValue> &variableValue, bool *alwaysTrue, bool *alwaysFalse)
{
    if (!tok)
        return;

    if (const ValueFlow::Value* v = tok->getKnownValue(ValueFlow::Value::ValueType::INT)) {
        if (v->intvalue == 0)
            *alwaysFalse = true;
        else
            *alwaysTrue = true;
        return;
    }

    if (tok->isName() || tok->str() == ""."") {
        while (tok && tok->str() == ""."")
            tok = tok->astOperand2();
        const auto it = utils::as_const(variableValue).find(tok ? tok->varId() : ~0U);
        if (it != variableValue.end()) {
            *alwaysTrue = (it->second != 0LL);
            *alwaysFalse = (it->second == 0LL);
        }
    }

    else if (tok->isComparisonOp()) {
        if (variableValue.empty()) {
            return;
        }

        const Token *vartok, *numtok;
        if (tok->astOperand2() && tok->astOperand2()->isNumber()) {
            ...",1,72,lib/checkuninitvar.cpp,"conditionAlwaysTrueOrFalse:void(Token*,std.map<int,VariableValue>&,bool*,bool*)",<empty>,,false,290,373,conditionAlwaysTrueOrFalse,,,1,"void(Token*,std.map<int,VariableValue>&,bool*,bool*)"
111669152142,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"static bool isVariableUsed(const Token *tok, const Variable& var)
{
    if (!tok)
        return false;
    if (tok->str() == ""&"" && !tok->astOperand2())
        return false;
    if (tok->isConstOp())
        return isVariableUsed(tok->astOperand1(),var) || isVariableUsed(tok->astOperand2(),var);
    if (tok->varId() != var.declarationId())
        return false;
    if (!var.isArray())
        return true;

    const Token *parent = tok->astParent();
    while (Token::Match(parent, ""[?:]""))
        parent = parent->astParent();
    // no dereference, then array is not ""used""
    if (!Token::Match(parent, ""*|[""))
        return false;
    const Token *parent2 = parent->astParent();
    // TODO: handle function calls. There is a TODO assertion in TestUninitVar::uninitvar_arrays
    return !parent2 || parent2->isConstOp() || (parent2->str() == ""="" && parent2->astOperand2() == parent);
}",1,1,lib/checkuninitvar.cpp,"isVariableUsed:bool(Token*,Variable&)",<empty>,,false,375,397,isVariableUsed,,,1,"bool(Token*,Variable&)"
111669152143,METHOD,<empty>,<empty>,"[&](const Token *child) {
                if (child->isUnaryOp(""&""))
                    return ChildrenToVisit::none;
                if (child->str() == "","" || child->str() == ""{"" || child->isConstOp())
                    return ChildrenToVisit::op1_and_op2;
                if (child->str() == ""."" && Token::Match(child->astOperand1(), ""%varid%"", var.declarationId()) && child->astOperand2() && child->astOperand2()->str() == membervar) {
                    errorToken = child;
                    return ChildrenToVisit::done;
                }
                return ChildrenToVisit::none;
            }",27,13,lib/checkuninitvar.cpp,lib/checkuninitvar.cpp:<global>.CheckUninitVar.checkScopeForVariable.<lambda>0:ChildrenToVisit(Token*),<empty>,,false,596,606,<lambda>0,,,1,ChildrenToVisit(Token*)
111669152144,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
                                return v.isUninitValue() && !v.isInconclusive();
                            }",91,29,lib/checkuninitvar.cpp,lib/checkuninitvar.cpp:<global>.CheckUninitVar.checkScopeForVariable.<lambda>1:bool(ValueFlow.Value&),<empty>,,false,727,729,<lambda>1,,,1,bool(ValueFlow.Value&)
111669152145,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"bool CheckUninitVar::checkScopeForVariable(const Token *tok, const Variable& var, bool * const possibleInit, bool * const noreturn, Alloc* const alloc, const std::string &membervar, std::map<nonneg int, VariableValue>& variableValue)
{
    const bool suppressErrors(possibleInit && *possibleInit);  // Assume that this is a variable declaration, rather than a fundef
    const bool printDebug = mSettings->debugwarnings;

    if (possibleInit)
        *possibleInit = false;

    int number_of_if = 0;

    if (var.declarationId() == 0U)
        return true;

    for (; tok; tok = tok->next()) {
        // End of scope..
        if (tok->str() == ""}"") {
            if (number_of_if && possibleInit)
                *possibleInit = true;

            // might be a noreturn function..
            if (mTokenizer->isScopeNoReturn(tok)) {
                if (noreturn)
                    *noreturn = true;
                return false;
            }

            break;
        }

        // Unco...",1,191,lib/checkuninitvar.cpp,"CheckUninitVar.checkScopeForVariable:bool(Token*,Variable&,bool*,bool*,CheckUninitVar.Alloc*,std.string&,std.map<int,VariableValue>&)",<empty>,,false,399,849,checkScopeForVariable,,,1,"bool(Token*,Variable&,bool*,bool*,CheckUninitVar.Alloc*,std.string&,std.map<int,VariableValue>&)"
111669152146,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"const Token* CheckUninitVar::checkExpr(const Token* tok, const Variable& var, const Alloc alloc, bool known, bool* bailout) const
{
    if (!tok)
        return nullptr;
    if (isUnevaluated(tok->previous()))
        return nullptr;

    if (tok->astOperand1()) {
        bool bailout1 = false;
        const Token *errorToken = checkExpr(tok->astOperand1(), var, alloc, known, &bailout1);
        if (bailout && bailout1)
            *bailout = true;
        if (errorToken)
            return errorToken;
        if ((bailout1 || !known) && Token::Match(tok, ""%oror%|&&|?""))
            return nullptr;
    }
    if (tok->astOperand2())
        return checkExpr(tok->astOperand2(), var, alloc, known, bailout);
    if (tok->varId() == var.declarationId()) {
        const Token *errorToken = isVariableUsage(tok, var.isPointer(), alloc);
        if (errorToken)
            return errorToken;
        if (bailout)
            *bailout = true;
    }
    return nullptr;
}",1,1,lib/checkuninitvar.cpp,"CheckUninitVar.checkExpr<const>:Token*(Token*,Variable&,CheckUninitVar.Alloc,bool,bool*)",<empty>,,false,851,878,checkExpr,,,1,"Token*(Token*,Variable&,CheckUninitVar.Alloc,bool,bool*)"
111669152147,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"bool CheckUninitVar::checkIfForWhileHead(const Token *startparentheses, const Variable& var, bool suppressErrors, bool isuninit, Alloc alloc, const std::string &membervar)
{
    const Token * const endpar = startparentheses->link();
    if (Token::Match(startparentheses, ""( ! %name% %oror%"") && startparentheses->tokAt(2)->getValue(0))
        suppressErrors = true;
    for (const Token *tok = startparentheses->next(); tok && tok != endpar; tok = tok->next()) {
        if (tok->varId() == var.declarationId()) {
            if (Token::Match(tok, ""%name% . %name%"")) {
                if (membervar.empty())
                    return true;
                if (tok->strAt(2) == membervar) {
                    if (isMemberVariableAssignment(tok, membervar))
                        return true;

                    if (!suppressErrors && isMemberVariableUsage(tok, var.isPointer(), alloc, membervar))
                        uninitStructMemberError(tok, tok->str() + ""."" + membervar);
       ...",1,1,lib/checkuninitvar.cpp,"CheckUninitVar.checkIfForWhileHead:bool(Token*,Variable&,bool,bool,CheckUninitVar.Alloc,std.string&)",<empty>,,false,880,914,checkIfForWhileHead,,,1,"bool(Token*,Variable&,bool,bool,CheckUninitVar.Alloc,std.string&)"
111669152148,METHOD,<empty>,<empty>,"[&](const Token * t) {
                    if (!t)
                        return ChildrenToVisit::none;
                    if (t->varId() == var.declarationId()) {
                        varIsUsedInRhs = true;
                        return ChildrenToVisit::done;
                    }
                    if (isUnevaluated(t->previous()))
                        return ChildrenToVisit::none;
                    return ChildrenToVisit::op1_and_op2;
                }",59,17,lib/checkuninitvar.cpp,lib/checkuninitvar.cpp:<global>.CheckUninitVar.checkLoopBodyRecursive<const>.<lambda>2:ChildrenToVisit(Token*),<empty>,,false,1060,1070,<lambda>2,,,1,ChildrenToVisit(Token*)
111669152149,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"const Token* CheckUninitVar::checkLoopBodyRecursive(const Token *start, const Variable& var, const Alloc alloc, const std::string &membervar, bool &bailout, bool &alwaysReturns) const
{
    assert(start->str() == ""{"");

    const Token *errorToken = nullptr;

    const Token *const end = start->link();
    for (const Token *tok = start->next(); tok != end; tok = tok->next()) {
        // skip sizeof / offsetof
        if (isUnevaluated(tok)) {
            tok = tok->linkAt(1);
            continue;
        }

        if (Token::Match(tok, ""asm ( %str% ) ;"")) {
            bailout = true;
            return nullptr;
        }

        // for loop; skip third expression until loop body has been analyzed..
        if (tok->str() == "";"" && Token::simpleMatch(tok->astParent(), "";"") && Token::simpleMatch(tok->astParent()->astParent(), ""("")) {
            const Token *top = tok->astParent()->astParent();
            if (!Token::simpleMatch(top->previous(), ""for ("") || !Token::simpleMatch(t...",1,1,lib/checkuninitvar.cpp,"CheckUninitVar.checkLoopBodyRecursive<const>:Token*(Token*,Variable&,CheckUninitVar.Alloc,std.string&,bool&,bool&)",<empty>,,false,917,1083,checkLoopBodyRecursive,,,1,"Token*(Token*,Variable&,CheckUninitVar.Alloc,std.string&,bool&,bool&)"
111669152150,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"bool CheckUninitVar::checkLoopBody(const Token *tok, const Variable& var, const Alloc alloc, const std::string &membervar, const bool suppressErrors)
{
    bool bailout = false;
    bool alwaysReturns = false;
    const Token *errorToken = checkLoopBodyRecursive(tok, var, alloc, membervar, bailout, alwaysReturns);

    if (!suppressErrors && !bailout && !alwaysReturns && errorToken) {
        if (membervar.empty())
            uninitvarError(errorToken, errorToken->expressionString(), alloc);
        else
            uninitStructMemberError(errorToken, errorToken->expressionString() + ""."" + membervar);
        return true;
    }

    return bailout || alwaysReturns;
}",1,1,lib/checkuninitvar.cpp,"CheckUninitVar.checkLoopBody:bool(Token*,Variable&,CheckUninitVar.Alloc,std.string&,bool)",<empty>,,false,1085,1100,checkLoopBody,,,1,"bool(Token*,Variable&,CheckUninitVar.Alloc,std.string&,bool)"
111669152151,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"void CheckUninitVar::checkRhs(const Token *tok, const Variable &var, Alloc alloc, nonneg int number_of_if, const std::string &membervar)
{
    bool rhs = false;
    int indent = 0;
    while (nullptr != (tok = tok->next())) {
        if (tok->str() == ""="")
            rhs = true;
        else if (rhs && tok->varId() == var.declarationId()) {
            if (membervar.empty() && isVariableUsage(tok, var.isPointer(), alloc))
                uninitvarError(tok, tok->str(), alloc);
            else if (!membervar.empty() && isMemberVariableUsage(tok, var.isPointer(), alloc, membervar))
                uninitStructMemberError(tok, tok->str() + ""."" + membervar);
            else if (Token::Match(tok, ""%var% =""))
                break;
            else if (Token::Match(tok->previous(), ""[(,&]""))
                break;
        } else if (tok->str() == "";"" || (indent==0 && tok->str() == "",""))
            break;
        else if (tok->str() == ""("")
            ++indent;
        else if (tok->s...",1,82,lib/checkuninitvar.cpp,"CheckUninitVar.checkRhs:void(Token*,Variable&,CheckUninitVar.Alloc,int,std.string&)",<empty>,,false,1102,1137,checkRhs,,,1,"void(Token*,Variable&,CheckUninitVar.Alloc,int,std.string&)"
111669152152,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"static bool astIsLhs(const Token *tok)
{
    return tok && tok->astParent() && tok == tok->astParent()->astOperand1();
}",1,1,lib/checkuninitvar.cpp,astIsLhs:bool(Token*),<empty>,,false,1139,1142,astIsLhs,,,1,bool(Token*)
111669152153,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"static bool astIsRhs(const Token *tok)
{
    return tok && tok->astParent() && tok == tok->astParent()->astOperand2();
}",1,1,lib/checkuninitvar.cpp,astIsRhs:bool(Token*),<empty>,,false,1144,1147,astIsRhs,,,1,bool(Token*)
111669152154,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"static bool isVoidCast(const Token *tok)
{
    return Token::simpleMatch(tok, ""("") && tok->isCast() && tok->valueType() && tok->valueType()->type == ValueType::Type::VOID && tok->valueType()->pointer == 0;
}",1,1,lib/checkuninitvar.cpp,isVoidCast:bool(Token*),<empty>,,false,1149,1152,isVoidCast,,,1,bool(Token*)
111669152155,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"const Token* CheckUninitVar::isVariableUsage(const Token *vartok, const Library& library, bool pointer, Alloc alloc, int indirect)
{
    const bool cpp = vartok->isCpp();
    const Token *valueExpr = vartok;   // non-dereferenced , no address of value as variable
    while (Token::Match(valueExpr->astParent(), "".|::"") && astIsRhs(valueExpr))
        valueExpr = valueExpr->astParent();
    // stuff we ignore..
    while (valueExpr->astParent()) {
        // *&x
        if (valueExpr->astParent()->isUnaryOp(""&"") && valueExpr->astParent()->astParent() && valueExpr->astParent()->astParent()->isUnaryOp(""*""))
            valueExpr = valueExpr->astParent()->astParent();
        // (type &)x
        else if (valueExpr->astParent()->isCast() && valueExpr->astParent()->isUnaryOp(""("") && Token::simpleMatch(valueExpr->astParent()->link()->previous(), ""& )""))
            valueExpr = valueExpr->astParent();
        // designated initializers: {.x | { ... , .x
        else if (Token::simpleMatch(v...",1,1,lib/checkuninitvar.cpp,"CheckUninitVar.isVariableUsage:Token*(Token*,Library&,bool,CheckUninitVar.Alloc,int)",<empty>,,false,1154,1356,isVariableUsage,,,1,"Token*(Token*,Library&,bool,CheckUninitVar.Alloc,int)"
111669152156,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"const Token* CheckUninitVar::isVariableUsage(const Token *vartok, bool pointer, Alloc alloc, int indirect) const
{
    return isVariableUsage(vartok, mSettings->library, pointer, alloc, indirect);
}",1,1,lib/checkuninitvar.cpp,"CheckUninitVar.isVariableUsage<const>:Token*(Token*,bool,CheckUninitVar.Alloc,int)",<empty>,,false,1358,1361,isVariableUsage,,,1,"Token*(Token*,bool,CheckUninitVar.Alloc,int)"
111669152157,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"int CheckUninitVar::isFunctionParUsage(const Token *vartok, const Library& library, bool pointer, Alloc alloc, int indirect)
{
    bool unknown = false;
    const Token *parent = getAstParentSkipPossibleCastAndAddressOf(vartok, &unknown);
    if (unknown || !Token::Match(parent, ""[(,]""))
        return -1;

    // locate start parentheses in function call..
    int argumentNumber = 0;
    const Token *start = vartok;
    while (start && !Token::Match(start, ""[;{}(]"")) {
        if (start->str() == "")"")
            start = start->link();
        else if (start->str() == "","")
            ++argumentNumber;
        start = start->previous();
    }
    if (!start)
        return -1;

    if (Token::simpleMatch(start->link(), "") {"") && Token::Match(start->previous(), ""if|for|while|switch""))
        return (!pointer || alloc == NO_ALLOC);

    // is this a function call?
    if (Token::Match(start->previous(), ""%name% ("")) {
        const bool address(vartok->strAt(-1) == ""&"");
        con...",1,1,lib/checkuninitvar.cpp,"CheckUninitVar.isFunctionParUsage:int(Token*,Library&,bool,CheckUninitVar.Alloc,int)",<empty>,,false,1369,1435,isFunctionParUsage,,,1,"int(Token*,Library&,bool,CheckUninitVar.Alloc,int)"
111669152158,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"int CheckUninitVar::isFunctionParUsage(const Token *vartok, bool pointer, Alloc alloc, int indirect) const
{
    return CheckUninitVar::isFunctionParUsage(vartok, mSettings->library, pointer, alloc, indirect);
}",1,1,lib/checkuninitvar.cpp,"CheckUninitVar.isFunctionParUsage<const>:int(Token*,bool,CheckUninitVar.Alloc,int)",<empty>,,false,1437,1440,isFunctionParUsage,,,1,"int(Token*,bool,CheckUninitVar.Alloc,int)"
111669152159,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"bool CheckUninitVar::isMemberVariableAssignment(const Token *tok, const std::string &membervar) const
{
    if (Token::Match(tok, ""%name% . %name%"") && tok->strAt(2) == membervar) {
        if (Token::Match(tok->tokAt(3), ""[=.[]""))
            return true;
        if (Token::Match(tok->tokAt(-2), ""[(,=] &""))
            return true;
        if (isLikelyStreamRead(tok->previous()))
            return true;
        if ((tok->previous() && tok->previous()->isConstOp()) || Token::Match(tok->previous(), ""[|=""))
            ; // member variable usage
        else if (tok->tokAt(3)->isConstOp())
            ; // member variable usage
        else if (Token::Match(tok->previous(), ""[(,] %name% . %name% [,)]"") &&
                 1 == isFunctionParUsage(tok, false, NO_ALLOC)) {
            return false;
        } else
            return true;
    } else if (tok->strAt(1) == ""="")
        return true;
    else if (Token::Match(tok, ""%var% . %name% ("")) {
        const Token *ftok = tok->tokAt(...",1,1,lib/checkuninitvar.cpp,"CheckUninitVar.isMemberVariableAssignment<const>:bool(Token*,std.string&)",<empty>,,false,1442,1509,isMemberVariableAssignment,,,1,"bool(Token*,std.string&)"
111669152160,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"bool CheckUninitVar::isMemberVariableUsage(const Token *tok, bool isPointer, Alloc alloc, const std::string &membervar) const
{
    if (Token::Match(tok->previous(), ""[(,] %name% . %name% [,)]"") &&
        tok->strAt(2) == membervar) {
        const int use = isFunctionParUsage(tok, isPointer, alloc);
        if (use == 1)
            return true;
    }

    if (isMemberVariableAssignment(tok, membervar))
        return false;

    if (Token::Match(tok, ""%name% . %name%"") && tok->strAt(2) == membervar && !(tok->tokAt(-2)->variable() && tok->tokAt(-2)->variable()->isReference())) {
        const Token *parent = tok->next()->astParent();
        return !parent || !parent->isUnaryOp(""&"");
    }
    if (!isPointer && !Token::simpleMatch(tok->astParent(), ""."") && Token::Match(tok->previous(), ""[(,] %name% [,)]"") && isVariableUsage(tok, isPointer, alloc))
        return true;

    if (!isPointer && Token::Match(tok->previous(), ""= %name% ;"")) {
        const Token* lhs = tok->previous()->...",1,1,lib/checkuninitvar.cpp,"CheckUninitVar.isMemberVariableUsage<const>:bool(Token*,bool,CheckUninitVar.Alloc,std.string&)",<empty>,,false,1511,1551,isMemberVariableUsage,,,1,"bool(Token*,bool,CheckUninitVar.Alloc,std.string&)"
111669152161,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"void CheckUninitVar::uninitdataError(const Token *tok, const std::string &varname)
{
    reportError(tok, Severity::error, ""uninitdata"", ""$symbol:"" + varname + ""\\nMemory is allocated but not initialized: $symbol"", CWE_USE_OF_UNINITIALIZED_VARIABLE, Certainty::normal);
}",1,1,lib/checkuninitvar.cpp,"CheckUninitVar.uninitdataError:void(Token*,std.string&)",<empty>,,false,1553,1556,uninitdataError,,,1,"void(Token*,std.string&)"
111669152162,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"void CheckUninitVar::uninitvarError(const Token *tok, const std::string &varname, ErrorPath errorPath)
{
    if (diag(tok))
        return;
    errorPath.emplace_back(tok, """");
    reportError(errorPath,
                Severity::error,
                ""legacyUninitvar"",
                ""$symbol:"" + varname + ""\\nUninitialized variable: $symbol"",
                CWE_USE_OF_UNINITIALIZED_VARIABLE,
                Certainty::normal);
}",1,1,lib/checkuninitvar.cpp,"CheckUninitVar.uninitvarError:void(Token*,std.string&,ErrorPath)",<empty>,,false,1558,1569,uninitvarError,,,1,"void(Token*,std.string&,ErrorPath)"
111669152163,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"void CheckUninitVar::uninitvarError(const Token* tok, const ValueFlow::Value& v)
{
    if (!mSettings->isEnabled(&v))
        return;
    if (diag(tok))
        return;
    const Token* ltok = tok;
    if (tok && Token::simpleMatch(tok->astParent(), ""."") && astIsRHS(tok))
        ltok = tok->astParent();
    const std::string& varname = ltok ? ltok->expressionString() : ""x"";
    ErrorPath errorPath = v.errorPath;
    errorPath.emplace_back(tok, """");
    auto severity = v.isKnown() ? Severity::error : Severity::warning;
    auto certainty = v.isInconclusive() ? Certainty::inconclusive : Certainty::normal;
    if (v.subexpressions.empty()) {
        reportError(errorPath,
                    severity,
                    ""uninitvar"",
                    ""$symbol:"" + varname + ""\\nUninitialized variable: $symbol"",
                    CWE_USE_OF_UNINITIALIZED_VARIABLE,
                    certainty);
        return;
    }
    std::string vars = v.subexpressions.size() == 1 ? ""variable: ""...",1,1,lib/checkuninitvar.cpp,"CheckUninitVar.uninitvarError:void(Token*,ValueFlow.Value&)",<empty>,,false,1571,1606,uninitvarError,,,1,"void(Token*,ValueFlow.Value&)"
111669152164,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"void CheckUninitVar::uninitStructMemberError(const Token *tok, const std::string &membername)
{
    reportError(tok,
                Severity::error,
                ""uninitStructMember"",
                ""$symbol:"" + membername + ""\\nUninitialized struct member: $symbol"", CWE_USE_OF_UNINITIALIZED_VARIABLE, Certainty::normal);
}",1,1,lib/checkuninitvar.cpp,"CheckUninitVar.uninitStructMemberError:void(Token*,std.string&)",<empty>,,false,1608,1614,uninitStructMemberError,,,1,"void(Token*,std.string&)"
111669152165,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"void CheckUninitVar::valueFlowUninit()
{
    logChecker(""CheckUninitVar::valueFlowUninit"");

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    std::unordered_set<nonneg int> ids;
    for (const bool subfunction : {false, true}) {
        // check every executable scope
        for (const Scope* scope : symbolDatabase->functionScopes) {
            for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
                if (isUnevaluated(tok)) {
                    tok = tok->linkAt(1);
                    continue;
                }
                if (ids.count(tok->exprId()) > 0)
                    continue;
                if (!tok->variable() && !tok->isUnaryOp(""*"") && !tok->isUnaryOp(""&""))
                    continue;
                if (Token::Match(tok, ""%name% (""))
                    continue;
                const Token* parent = tok->astParent();
                while (Token::simpleMatch(parent, "".""))
         ...",1,23,lib/checkuninitvar.cpp,CheckUninitVar.valueFlowUninit:void(),<empty>,,false,1616,1693,valueFlowUninit,,,1,void()
111669152166,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"static bool isVariableUsage(const Settings &settings, const Token *vartok, MathLib::bigint *value)
{
    (void)value;
    return CheckUninitVar::isVariableUsage(vartok, settings.library, true, CheckUninitVar::Alloc::ARRAY);
}",1,1,lib/checkuninitvar.cpp,"isVariableUsage:bool(Settings&,Token*,MathLib.bigint*)",<empty>,,false,1696,1700,isVariableUsage,,,1,"bool(Settings&,Token*,MathLib.bigint*)"
111669152167,METHOD,MyFileInfo,TYPE_DECL,"std::string toString() const override
        {
            return CTU::toString(unsafeUsage);
        }",9,9,lib/checkuninitvar.cpp,MyFileInfo.toString<const><duplicate>2:string(),<empty>,,false,1718,1721,toString,,,2,string()
111669152168,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"static bool isVariableUsage(const Settings &settings, const Token *argtok, CTU::FileInfo::Value *value) {
    return isVariableUsage(settings, argtok, &value->value);
}",1,1,lib/checkuninitvar.cpp,"isVariableUsage:bool(Settings&,Token*,CTU.FileInfo.Value*)",<empty>,,false,1725,1727,isVariableUsage,,,1,"bool(Settings&,Token*,CTU.FileInfo.Value*)"
111669152169,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"Check::FileInfo *CheckUninitVar::getFileInfo(const Tokenizer &tokenizer, const Settings &settings) const
{
    const std::list<CTU::FileInfo::UnsafeUsage> &unsafeUsage = CTU::getUnsafeUsage(tokenizer, settings, ::isVariableUsage);
    if (unsafeUsage.empty())
        return nullptr;

    auto *fileInfo = new MyFileInfo(tokenizer.list.getFiles()[0]);
    fileInfo->unsafeUsage = unsafeUsage;
    return fileInfo;
}",1,1,lib/checkuninitvar.cpp,"CheckUninitVar.getFileInfo<const>:Check.FileInfo*(Tokenizer&,Settings&)",<empty>,,false,1729,1738,getFileInfo,,,1,"Check.FileInfo*(Tokenizer&,Settings&)"
111669152170,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"Check::FileInfo * CheckUninitVar::loadFileInfoFromXml(const tinyxml2::XMLElement *xmlElement) const
{
    const std::list<CTU::FileInfo::UnsafeUsage> &unsafeUsage = CTU::loadUnsafeUsageListFromXml(xmlElement);
    if (unsafeUsage.empty())
        return nullptr;

    auto *fileInfo = new MyFileInfo;
    fileInfo->unsafeUsage = unsafeUsage;
    return fileInfo;
}",1,1,lib/checkuninitvar.cpp,CheckUninitVar.loadFileInfoFromXml<const>:Check.FileInfo*(tinyxml2.XMLElement*),<empty>,,false,1740,1749,loadFileInfoFromXml,,,1,Check.FileInfo*(tinyxml2.XMLElement*)
111669152171,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"bool CheckUninitVar::analyseWholeProgram(const CTU::FileInfo &ctu, const std::list<Check::FileInfo*> &fileInfo, const Settings& settings, ErrorLogger &errorLogger)
{
    (void)settings;

    CheckUninitVar dummy(nullptr, &settings, &errorLogger);
    dummy.
    logChecker(""CheckUninitVar::analyseWholeProgram"");

    if (fileInfo.empty())
        return false;

    const std::map<std::string, std::list<const CTU::FileInfo::CallBase *>> callsMap = ctu.getCallsMap();

    bool foundErrors = false;

    for (const Check::FileInfo* fi1 : fileInfo) {
        const auto *fi = dynamic_cast<const MyFileInfo*>(fi1);
        if (!fi)
            continue;
        for (const CTU::FileInfo::UnsafeUsage &unsafeUsage : fi->unsafeUsage) {
            const CTU::FileInfo::FunctionCall *functionCall = nullptr;

            const std::list<ErrorMessage::FileLocation> &locationList =
                CTU::FileInfo::getErrorPath(CTU::FileInfo::InvalidValueType::uninit,
                                   ...",1,1,lib/checkuninitvar.cpp,"CheckUninitVar.analyseWholeProgram:bool(CTU.FileInfo&,std.list<Check.FileInfo*>&,Settings&,ErrorLogger&)",<empty>,,false,1751,1797,analyseWholeProgram,,,1,"bool(CTU.FileInfo&,std.list<Check.FileInfo*>&,Settings&,ErrorLogger&)"
111669152172,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"void CheckUninitVar::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    CheckUninitVar checkUninitVar(&tokenizer, &tokenizer.getSettings(), errorLogger);
    checkUninitVar.valueFlowUninit();
    checkUninitVar.check();
}",1,1,lib/checkuninitvar.cpp,"CheckUninitVar.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,1799,1804,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669152173,METHOD,lib/checkuninitvar.cpp:<global>,TYPE_DECL,"void CheckUninitVar::getErrorMessages(ErrorLogger* errorLogger, const Settings* settings) const
{
    CheckUninitVar c(nullptr, settings, errorLogger);

    ValueFlow::Value v{};

    c.uninitvarError(nullptr, v);
    c.uninitdataError(nullptr, ""varname"");
    c.uninitStructMemberError(nullptr, ""a.b"");
}",1,1,lib/checkuninitvar.cpp,"CheckUninitVar.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,1806,1815,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669152174,METHOD,lib/checkuninitvar.h:<global>,TYPE_DECL,<global>,1,1,lib/checkuninitvar.h,lib/checkuninitvar.h:<global>,<empty>,,false,1,136,<global>,,,1,
111669152175,METHOD,lib/checkunusedfunctions.cpp:<global>,TYPE_DECL,"static std::string stripTemplateParameters(const std::string& funcName) {
    std::string name = funcName;
    const auto pos = name.find('<');
    if (pos > 0 && pos != std::string::npos)
        name.erase(pos - 1);
    return name;
}",1,1,lib/checkunusedfunctions.cpp,stripTemplateParameters:string(std.string&),<empty>,,false,50,56,stripTemplateParameters,,,1,string(std.string&)
111669152176,METHOD,lib/checkunusedfunctions.cpp:<global>,TYPE_DECL,<global>,1,78,lib/checkunusedfunctions.cpp,lib/checkunusedfunctions.cpp:<global>,<empty>,,false,1,532,<global>,,,1,
111669152177,METHOD,lib/checkunusedfunctions.cpp:<global>,TYPE_DECL,"static bool isRecursiveCall(const Token* ftok)
{
    return ftok->function() && ftok->function() == Scope::nestedInFunction(ftok->scope());
}",1,1,lib/checkunusedfunctions.cpp,isRecursiveCall:bool(Token*),<empty>,,false,62,65,isRecursiveCall,,,1,bool(Token*)
111669152178,METHOD,lib/checkunusedfunctions.cpp:<global>,TYPE_DECL,"void CheckUnusedFunctions::parseTokens(const Tokenizer &tokenizer, const Settings &settings)
{
    const char * const FileName = tokenizer.list.getFiles().front().c_str();

    const bool doMarkup = settings.library.markupFile(FileName);

    // Function declarations..
    if (!doMarkup) {
        const SymbolDatabase* symbolDatabase = tokenizer.getSymbolDatabase();
        for (const Scope* scope : symbolDatabase->functionScopes) {
            const Function* func = scope->function;
            if (!func || !func->token)
                continue;

            // Don't warn about functions that are marked by __attribute__((constructor)) or __attribute__((destructor))
            if (func->isAttributeConstructor() || func->isAttributeDestructor() || func->type != FunctionType::eFunction || func->isOperator())
                continue;

            if (func->isAttributeUnused() || func->isAttributeMaybeUnused())
                continue;

            if (func->isExtern())
            ...",1,1,lib/checkunusedfunctions.cpp,"CheckUnusedFunctions.parseTokens:void(Tokenizer&,Settings&)",<empty>,,false,67,292,parseTokens,,,1,"void(Tokenizer&,Settings&)"
111669152179,METHOD,lib/checkunusedfunctions.cpp:<global>,TYPE_DECL,"static bool isOperatorFunction(const std::string & funcName)
{
    /* Operator functions are invalid function names for C, so no need to check
     * this in here. As result the returned error function might be incorrect.
     *
     * List of valid operators can be found at:
     * http://en.cppreference.com/w/cpp/language/operators
     *
     * Conversion functions must be a member function (at least for gcc), so no
     * need to cover them for unused functions.
     *
     * To speed up the comparison, not the whole list of operators is used.
     * Instead only the character after the operator prefix is checked to be a
     * none alpa numeric value, but the '_', to cover function names like
     * ""operator_unused"". In addition the following valid operators are checked:
     * - new
     * - new[]
     * - delete
     * - delete[]
     */
    const std::string operatorPrefix = ""operator"";
    if (funcName.compare(0, operatorPrefix.length(), operatorPrefix) != 0) {
        ret...",1,1,lib/checkunusedfunctions.cpp,isOperatorFunction:bool(std.string&),<empty>,,false,295,340,isOperatorFunction,,,1,bool(std.string&)
111669152180,METHOD,lib/checkunusedfunctions.cpp:<global>,TYPE_DECL,"static void staticFunctionError(ErrorLogger& errorLogger,
                                const std::string &filename,
                                unsigned int fileIndex,
                                unsigned int lineNumber,
                                const std::string &funcname)
{
    std::list<ErrorMessage::FileLocation> locationList;
    if (!filename.empty()) {
        locationList.emplace_back(filename, lineNumber, 0);
        locationList.back().fileIndex = fileIndex;
    }

    const ErrorMessage errmsg(std::move(locationList), """", Severity::style, ""$symbol:"" + funcname + ""\\nThe function '$symbol' should have static linkage since it is not used outside of its translation unit."", ""staticFunction"", Certainty::normal);
    errorLogger.reportErr(errmsg);
}",1,1,lib/checkunusedfunctions.cpp,"staticFunctionError:void(ErrorLogger&,std.string&,unsigned int,unsigned int,std.string&)",<empty>,,false,342,356,staticFunctionError,,,1,"void(ErrorLogger&,std.string&,unsigned int,unsigned int,std.string&)"
111669152181,METHOD,lib/checkunusedfunctions.cpp:<global>,TYPE_DECL,"bool CheckUnusedFunctions::check(const Settings& settings, ErrorLogger& errorLogger) const
{
    logChecker(""CheckUnusedFunctions::check""); // unusedFunction

    using ErrorParams = std::tuple<std::string, unsigned int, unsigned int, std::string>;
    std::vector<ErrorParams> errors; // ensure well-defined order
    std::vector<ErrorParams> staticFunctionErrors;

    for (auto it = mFunctions.cbegin(); it != mFunctions.cend(); ++it) {
        const FunctionUsage &func = it->second;
        if (func.usedOtherFile || func.filename.empty())
            continue;
        if (settings.library.isentrypoint(it->first))
            continue;
        if (!func.usedSameFile) {
            if (isOperatorFunction(it->first))
                continue;
            std::string filename;
            if (func.filename != ""+"")
                filename = func.filename;
            errors.emplace_back(filename, func.fileIndex, func.lineNumber, it->first);
        } else if (func.isC && !func.isStatic ...",1,4,lib/checkunusedfunctions.cpp,"CheckUnusedFunctions.check<const>:bool(Settings&,ErrorLogger&)",<empty>,,false,365,403,check,,,1,"bool(Settings&,ErrorLogger&)"
111669152182,METHOD,lib/checkunusedfunctions.cpp:<global>,TYPE_DECL,"void CheckUnusedFunctions::unusedFunctionError(ErrorLogger& errorLogger,
                                               const std::string &filename, unsigned int fileIndex, unsigned int lineNumber,
                                               const std::string &funcname)
{
    std::list<ErrorMessage::FileLocation> locationList;
    if (!filename.empty()) {
        locationList.emplace_back(filename, lineNumber, 0);
        locationList.back().fileIndex = fileIndex;
    }

    const ErrorMessage errmsg(std::move(locationList), """", Severity::style, ""$symbol:"" + funcname + ""\\nThe function '$symbol' is never used."", ""unusedFunction"", CWE561, Certainty::normal);
    errorLogger.reportErr(errmsg);
}",1,1,lib/checkunusedfunctions.cpp,"CheckUnusedFunctions.unusedFunctionError:void(ErrorLogger&,std.string&,unsigned int,unsigned int,std.string&)",<empty>,,false,405,417,unusedFunctionError,,,1,"void(ErrorLogger&,std.string&,unsigned int,unsigned int,std.string&)"
111669152183,METHOD,lib/checkunusedfunctions.cpp:<global>,TYPE_DECL,"CheckUnusedFunctions::FunctionDecl::FunctionDecl(const Function *f)
    : functionName(f->name()), fileName(f->token->fileName()), lineNumber(f->token->linenr())
{}",1,2,lib/checkunusedfunctions.cpp,CheckUnusedFunctions.FunctionDecl.FunctionDecl:ANY(Function*),<empty>,,false,419,421,FunctionDecl,,,1,CheckUnusedFunctions.FunctionDecl.FunctionDecl:ANY(Function*)(Function*)
111669152184,METHOD,lib/checkunusedfunctions.cpp:<global>,TYPE_DECL,"std::string CheckUnusedFunctions::analyzerInfo() const
{
    std::ostringstream ret;
    for (const FunctionDecl &functionDecl : mFunctionDecl) {
        ret << ""    <functiondecl""
            << "" file=\\"""" << ErrorLogger::toxml(functionDecl.fileName) << '\\""'
            << "" functionName=\\"""" << ErrorLogger::toxml(functionDecl.functionName) << '\\""'
            << "" lineNumber=\\"""" << functionDecl.lineNumber << ""\\""/>\\n"";
    }
    for (const std::string &fc : mFunctionCalls) {
        ret << ""    <functioncall functionName=\\"""" << ErrorLogger::toxml(fc) << ""\\""/>\\n"";
    }
    return ret.str();
}",1,1,lib/checkunusedfunctions.cpp,CheckUnusedFunctions.analyzerInfo<const>:string(),<empty>,,false,423,436,analyzerInfo,,,1,string()
111669152185,METHOD,Location,TYPE_DECL,Location() : lineNumber(0) {},9,37,lib/checkunusedfunctions.cpp,Location.Location:ANY(),<empty>,,false,440,440,Location,,,1,Location.Location:ANY()()
111669152186,METHOD,Location,TYPE_DECL,"Location(std::string f, const int l) : fileName(std::move(f)), lineNumber(l) {}",9,87,lib/checkunusedfunctions.cpp,"Location.Location:ANY(std.string,int)",<empty>,,false,441,441,Location,,,2,"Location.Location:ANY(std.string,int)(std.string,int)"
111669152187,METHOD,lib/checkunusedfunctions.cpp:<global>,TYPE_DECL,"void CheckUnusedFunctions::analyseWholeProgram(const Settings &settings, ErrorLogger &errorLogger, const std::string &buildDir)
{
    std::map<std::string, Location> decls;
    std::set<std::string> calls;

    const std::string filesTxt(buildDir + ""/files.txt"");
    std::ifstream fin(filesTxt.c_str());
    std::string filesTxtLine;
    while (std::getline(fin, filesTxtLine)) {
        const std::string::size_type firstColon = filesTxtLine.find(':');
        if (firstColon == std::string::npos)
            continue;
        const std::string::size_type secondColon = filesTxtLine.find(':', firstColon+1);
        if (secondColon == std::string::npos)
            continue;
        const std::string xmlfile = buildDir + '/' + filesTxtLine.substr(0,firstColon);
        const std::string sourcefile = filesTxtLine.substr(secondColon+1);

        tinyxml2::XMLDocument doc;
        const tinyxml2::XMLError error = doc.LoadFile(xmlfile.c_str());
        if (error != tinyxml2::XML_SUCCESS)
   ...",1,1,lib/checkunusedfunctions.cpp,"CheckUnusedFunctions.analyseWholeProgram:void(Settings&,ErrorLogger&,std.string&)",<empty>,,false,447,512,analyseWholeProgram,,,1,"void(Settings&,ErrorLogger&,std.string&)"
111669152188,METHOD,lib/checkunusedfunctions.cpp:<global>,TYPE_DECL,"void CheckUnusedFunctions::updateFunctionData(const CheckUnusedFunctions& check)
{
    for (const auto& entry : check.mFunctions)
    {
        FunctionUsage &usage = mFunctions[entry.first];
        if (!usage.lineNumber)
            usage.lineNumber = entry.second.lineNumber;
        // TODO: why always overwrite this but not the filename and line?
        usage.fileIndex = entry.second.fileIndex;
        if (usage.filename.empty())
            usage.filename = entry.second.filename;
        // cppcheck-suppress bitwiseOnBoolean - TODO: FP
        usage.usedOtherFile |= entry.second.usedOtherFile;
        // cppcheck-suppress bitwiseOnBoolean - TODO: FP
        usage.usedSameFile |= entry.second.usedSameFile;
    }
    mFunctionDecl.insert(mFunctionDecl.cend(), check.mFunctionDecl.cbegin(), check.mFunctionDecl.cend());
    mFunctionCalls.insert(check.mFunctionCalls.cbegin(), check.mFunctionCalls.cend());
}",1,1,lib/checkunusedfunctions.cpp,CheckUnusedFunctions.updateFunctionData:void(CheckUnusedFunctions&),<empty>,,false,514,532,updateFunctionData,,,1,void(CheckUnusedFunctions&)
111669152189,METHOD,lib/checkunusedfunctions.h:<global>,TYPE_DECL,<global>,1,1,lib/checkunusedfunctions.h,lib/checkunusedfunctions.h:<global>,<empty>,,false,1,97,<global>,,,1,
111669152190,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"static bool isRaiiClassScope(const Scope *classScope)
{
    return classScope && classScope->getDestructor() != nullptr;
}",1,1,lib/checkunusedvar.cpp,isRaiiClassScope:bool(Scope*),<empty>,,false,51,54,isRaiiClassScope,,,1,bool(Scope*)
111669152191,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,<global>,1,78,lib/checkunusedvar.cpp,lib/checkunusedvar.cpp:<global>,<empty>,,false,1,1828,<global>,,,1,
111669152192,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"static bool isRaiiClass(const ValueType *valueType, bool cpp, bool defaultReturn = true)
{
    if (!cpp)
        return false;

    if (!valueType)
        return defaultReturn;

    if ((valueType->smartPointerType && isRaiiClassScope(valueType->smartPointerType->classScope)) || (!valueType->smartPointerType && valueType->type == ValueType::Type::SMART_POINTER))
        return true;

    switch (valueType->type) {
    case ValueType::Type::UNKNOWN_TYPE:
    case ValueType::Type::NONSTD:
        return defaultReturn;

    case ValueType::Type::RECORD:
        if (isRaiiClassScope(valueType->typeScope))
            return true;
        return defaultReturn;

    case ValueType::Type::POD:
    case ValueType::Type::SMART_POINTER:
    case ValueType::Type::CONTAINER:
    case ValueType::Type::ITERATOR:
    case ValueType::Type::VOID:
    case ValueType::Type::BOOL:
    case ValueType::Type::CHAR:
    case ValueType::Type::SHORT:
    case ValueType::Type::WCHAR_T:
    case ValueType::Ty...",1,1,lib/checkunusedvar.cpp,"isRaiiClass:bool(ValueType*,bool,bool)",<empty>,,false,57,98,isRaiiClass,,,1,"bool(ValueType*,bool,bool)"
111669152193,METHOD,Variables.VariableUsage,TYPE_DECL,"explicit VariableUsage(const Variable *var = nullptr,
                               VariableType type = standard,
                               bool read = false,
                               bool write = false,
                               bool modified = false,
                               bool allocateMemory = false) :
            _var(var),
            _lastAccess(var ? var->nameToken() : nullptr),
            mType(type),
            _read(read),
            _write(write),
            _modified(modified),
            _allocateMemory(allocateMemory) {}",9,46,lib/checkunusedvar.cpp,"Variables.VariableUsage.VariableUsage:ANY(Variable*,Variables.VariableType,bool,bool,bool,bool)",<empty>,,false,110,122,VariableUsage,,,1,"Variables.VariableUsage.VariableUsage:ANY(Variable*,Variables.VariableType,bool,bool,bool,bool)(Variable*,Variables.VariableType,bool,bool,bool,bool)"
111669152194,METHOD,Variables.VariableUsage,TYPE_DECL,"void use() {
            _read = true;
            _write = true;
        }",9,9,lib/checkunusedvar.cpp,Variables.VariableUsage.use:void(),<empty>,,false,125,128,use,,,2,void()
111669152195,METHOD,Variables.VariableUsage,TYPE_DECL,"bool unused() const {
            return (!_read && !_write);
        }",9,9,lib/checkunusedvar.cpp,Variables.VariableUsage.unused<const>:bool(),<empty>,,false,131,133,unused,,,3,bool()
111669152196,METHOD,Variables,TYPE_DECL,"void clear() {
        mVarUsage.clear();
    }",5,5,lib/checkunusedvar.cpp,Variables.clear:void(),<empty>,,false,147,149,clear,,,3,void()
111669152197,METHOD,Variables,TYPE_DECL,"const std::map<nonneg int, VariableUsage> &varUsage() const {
        return mVarUsage;
    }",5,19,lib/checkunusedvar.cpp,Variables.varUsage<const>:ANY(),<empty>,,false,150,152,varUsage,,,4,ANY()
111669152198,METHOD,Variables,TYPE_DECL,"void erase(nonneg int varid) {
        mVarUsage.erase(varid);
    }",5,15,lib/checkunusedvar.cpp,Variables.erase:void(int),<empty>,,false,165,167,erase,,,5,void(int)
111669152199,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void Variables::alias(nonneg int varid1, nonneg int varid2, bool replace)
{
    VariableUsage *var1 = find(varid1);
    VariableUsage *var2 = find(varid2);

    if (!var1 || !var2)
        return;

    // alias to self
    if (varid1 == varid2) {
        var1->use();
        return;
    }

    if (replace) {
        // remove var1 from all aliases
        for (auto i = var1->_aliases.cbegin(); i != var1->_aliases.cend(); ++i) {
            VariableUsage *temp = find(*i);

            if (temp)
                temp->_aliases.erase(var1->_var->declarationId());
        }

        // remove all aliases from var1
        var1->_aliases.clear();
    }

    // var1 gets all var2s aliases
    for (auto i = var2->_aliases.cbegin(); i != var2->_aliases.cend(); ++i) {
        if (*i != varid1)
            var1->_aliases.insert(*i);
    }

    // var2 is an alias of var1
    var2->_aliases.insert(varid1);
    var1->_aliases.insert(varid2);

    if (var2->mType == Variables::pointer) {
        ...",1,22,lib/checkunusedvar.cpp,"Variables.alias:void(int,int,bool)",<empty>,,false,185,225,alias,,,1,"void(int,int,bool)"
111669152200,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void Variables::clearAliases(nonneg int varid)
{
    VariableUsage *usage = find(varid);

    if (usage) {
        // remove usage from all aliases
        for (auto i = usage->_aliases.cbegin(); i != usage->_aliases.cend(); ++i) {
            VariableUsage *temp = find(*i);

            if (temp)
                temp->_aliases.erase(usage->_var->declarationId());
        }

        // remove all aliases from usage
        usage->_aliases.clear();
    }
}",1,29,lib/checkunusedvar.cpp,Variables.clearAliases:void(int),<empty>,,false,227,243,clearAliases,,,1,void(int)
111669152201,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void Variables::eraseAliases(nonneg int varid)
{
    VariableUsage *usage = find(varid);

    if (usage) {
        for (auto aliases = usage->_aliases.cbegin(); aliases != usage->_aliases.cend(); ++aliases)
            erase(*aliases);
    }
}",1,29,lib/checkunusedvar.cpp,Variables.eraseAliases:void(int),<empty>,,false,245,253,eraseAliases,,,1,void(int)
111669152202,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void Variables::eraseAll(nonneg int varid)
{
    eraseAliases(varid);
    erase(varid);
}",1,25,lib/checkunusedvar.cpp,Variables.eraseAll:void(int),<empty>,,false,255,259,eraseAll,,,1,void(int)
111669152203,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void Variables::addVar(const Variable *var,
                       VariableType type,
                       bool write_)
{
    if (var->declarationId() > 0) {
        mVarUsage.emplace(var->declarationId(), VariableUsage(var, type, false, write_, false));
    }
}",1,1,lib/checkunusedvar.cpp,"Variables.addVar:void(Variable*,Variables.VariableType,bool)",<empty>,,false,261,268,addVar,,,1,"void(Variable*,Variables.VariableType,bool)"
111669152204,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void Variables::allocateMemory(nonneg int varid, const Token* tok)
{
    VariableUsage *usage = find(varid);

    if (usage) {
        usage->_allocateMemory = true;
        usage->_lastAccess = tok;
    }
}",1,31,lib/checkunusedvar.cpp,"Variables.allocateMemory:void(int,Token*)",<empty>,,false,270,278,allocateMemory,,,1,"void(int,Token*)"
111669152205,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void Variables::read(nonneg int varid, const Token* tok)
{
    VariableUsage *usage = find(varid);

    if (usage) {
        usage->_read = true;
        if (tok)
            usage->_lastAccess = tok;
    }
}",1,21,lib/checkunusedvar.cpp,"Variables.read:void(int,Token*)",<empty>,,false,280,289,read,,,1,"void(int,Token*)"
111669152206,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void Variables::readAliases(nonneg int varid, const Token* tok)
{
    const VariableUsage *usage = find(varid);

    if (usage) {
        for (nonneg int const aliases : usage->_aliases) {
            VariableUsage *aliased = find(aliases);

            if (aliased) {
                aliased->_read = true;
                aliased->_lastAccess = tok;
            }
        }
    }
}",1,28,lib/checkunusedvar.cpp,"Variables.readAliases:void(int,Token*)",<empty>,,false,291,305,readAliases,,,1,"void(int,Token*)"
111669152207,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void Variables::readAll(nonneg int varid, const Token* tok)
{
    read(varid, tok);
    readAliases(varid, tok);
}",1,24,lib/checkunusedvar.cpp,"Variables.readAll:void(int,Token*)",<empty>,,false,307,311,readAll,,,1,"void(int,Token*)"
111669152208,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void Variables::write(nonneg int varid, const Token* tok)
{
    VariableUsage *usage = find(varid);

    if (usage) {
        usage->_write = true;
        if (!usage->_var->isStatic() && !Token::simpleMatch(tok->next(), ""= 0 ;""))
            usage->_read = false;
        usage->_lastAccess = tok;
    }
}",1,22,lib/checkunusedvar.cpp,"Variables.write:void(int,Token*)",<empty>,,false,313,323,write,,,1,"void(int,Token*)"
111669152209,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void Variables::writeAliases(nonneg int varid, const Token* tok)
{
    VariableUsage *usage = find(varid);

    if (usage) {
        for (auto aliases = usage->_aliases.cbegin(); aliases != usage->_aliases.cend(); ++aliases) {
            VariableUsage *aliased = find(*aliases);

            if (aliased) {
                aliased->_write = true;
                aliased->_lastAccess = tok;
            }
        }
    }
}",1,29,lib/checkunusedvar.cpp,"Variables.writeAliases:void(int,Token*)",<empty>,,false,325,339,writeAliases,,,1,"void(int,Token*)"
111669152210,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void Variables::writeAll(nonneg int varid, const Token* tok)
{
    write(varid, tok);
    writeAliases(varid, tok);
}",1,25,lib/checkunusedvar.cpp,"Variables.writeAll:void(int,Token*)",<empty>,,false,341,345,writeAll,,,1,"void(int,Token*)"
111669152211,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void Variables::use(nonneg int varid, const Token* tok)
{
    VariableUsage *usage = find(varid);

    if (usage) {
        usage->use();
        usage->_lastAccess = tok;

        for (auto aliases = usage->_aliases.cbegin(); aliases != usage->_aliases.cend(); ++aliases) {
            VariableUsage *aliased = find(*aliases);

            if (aliased) {
                aliased->use();
                aliased->_lastAccess = tok;
            }
        }
    }
}",1,20,lib/checkunusedvar.cpp,"Variables.use:void(int,Token*)",<empty>,,false,347,364,use,,,1,"void(int,Token*)"
111669152212,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void Variables::modified(nonneg int varid, const Token* tok)
{
    VariableUsage *usage = find(varid);

    if (usage) {
        if (!usage->_var->isStatic())
            usage->_read = false;
        usage->_modified = true;
        usage->_lastAccess = tok;

        for (auto aliases = usage->_aliases.cbegin(); aliases != usage->_aliases.cend(); ++aliases) {
            VariableUsage *aliased = find(*aliases);

            if (aliased) {
                aliased->_modified = true;
                aliased->_lastAccess = tok;
            }
        }
    }
}",1,25,lib/checkunusedvar.cpp,"Variables.modified:void(int,Token*)",<empty>,,false,366,385,modified,,,1,"void(int,Token*)"
111669152213,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"Variables::VariableUsage *Variables::find(nonneg int varid)
{
    if (varid) {
        const auto i = mVarUsage.find(varid);
        if (i != mVarUsage.end())
            return &i->second;
    }
    return nullptr;
}",1,42,lib/checkunusedvar.cpp,Variables.find:Variables.VariableUsage*(int),<empty>,,false,387,395,find,,,1,Variables.VariableUsage*(int)
111669152214,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"static const Token* doAssignment(Variables &variables, const Token *tok, bool dereference, const Scope *scope)
{
    // a = a + b;
    if (Token::Match(tok, ""%var% = %var% !!;"")) {
        const Token* rhsVarTok = tok->tokAt(2);
        if (tok->varId() == rhsVarTok->varId()) {
            return rhsVarTok;
        }
    }

    if (Token::Match(tok, ""%var% %assign%"") && tok->strAt(1) != ""="")
        return tok->next();

    const Token* const tokOld = tok;

    // check for aliased variable
    const nonneg int varid1 = tok->varId();
    Variables::VariableUsage *var1 = variables.find(varid1);

    if (var1) {
        // jump behind '='
        tok = tok->next();
        while (!tok->isAssignmentOp()) {
            if (tok->varId())
                variables.read(tok->varId(), tok);
            tok = tok->next();
        }
        tok = tok->next();

        if (Token::Match(tok, ""( const| struct|union| %type% * ) ( (""))
            tok = tok->link()->next();

        if (Token::Mat...",1,10,lib/checkunusedvar.cpp,"doAssignment:Token*(Variables&,Token*,bool,Scope*)",<empty>,,false,397,629,doAssignment,,,1,"Token*(Variables&,Token*,bool,Scope*)"
111669152215,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"static bool isPartOfClassStructUnion(const Token* tok)
{
    for (; tok; tok = tok->previous()) {
        if (tok->str() == ""}"" || tok->str() == "")"")
            tok = tok->link();
        else if (tok->str() == ""("")
            return false;
        else if (tok->str() == ""{"") {
            return (tok->strAt(-1) == ""struct"" || tok->strAt(-2) == ""struct"" || tok->strAt(-1) == ""class"" || tok->strAt(-2) == ""class"" || tok->strAt(-1) == ""union"" || tok->strAt(-2) == ""union"");
        }
    }
    return false;
}",1,1,lib/checkunusedvar.cpp,isPartOfClassStructUnion:bool(Token*),<empty>,,false,631,643,isPartOfClassStructUnion,,,1,bool(Token*)
111669152216,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"static bool isVarDecl(const Token *tok)
{
    return tok && tok->variable() && tok->variable()->nameToken() == tok;
}",1,1,lib/checkunusedvar.cpp,isVarDecl:bool(Token*),<empty>,,false,645,648,isVarDecl,,,1,bool(Token*)
111669152217,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"static const Token * skipBrackets(const Token *tok)
{
    while (tok && tok->str() == ""["")
        tok = tok->link()->next();
    return tok;
}",1,1,lib/checkunusedvar.cpp,skipBrackets:Token*(Token*),<empty>,,false,651,656,skipBrackets,,,1,Token*(Token*)
111669152218,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"static const Token * skipBracketsAndMembers(const Token *tok)
{
    while (tok) {
        if (tok->str() == ""["")
            tok = tok->link()->next();
        else if (Token::Match(tok, "". %name%""))
            tok = tok->tokAt(2);
        else
            break;
    }
    return tok;
}",1,1,lib/checkunusedvar.cpp,skipBracketsAndMembers:Token*(Token*),<empty>,,false,660,671,skipBracketsAndMembers,,,1,Token*(Token*)
111669152219,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"static void useFunctionArgs(const Token *tok, Variables& variables)
{
    // TODO: Match function args to see if they are const or not. Assume that const data is not written.
    if (!tok)
        return;
    if (tok->str() == "","") {
        useFunctionArgs(tok->astOperand1(), variables);
        useFunctionArgs(tok->astOperand2(), variables);
    } else if (Token::Match(tok, ""[+:]"") && (!tok->valueType() || tok->valueType()->pointer)) {
        useFunctionArgs(tok->astOperand1(), variables);
        useFunctionArgs(tok->astOperand2(), variables);
    } else if (tok->variable() && tok->variable()->isArray()) {
        variables.use(tok->varId(), tok);
    }
}",1,1,lib/checkunusedvar.cpp,"useFunctionArgs:void(Token*,Variables&)",<empty>,,false,673,687,useFunctionArgs,,,1,"void(Token*,Variables&)"
111669152220,METHOD,<empty>,<empty>,"[&](const Scope* s) {
                return s->bodyStart == tok;
            }",83,13,lib/checkunusedvar.cpp,lib/checkunusedvar.cpp:<global>.CheckUnusedVar.checkFunctionVariableUsage_iterateScopes.<lambda>0:bool(Scope*),<empty>,,false,780,782,<lambda>0,,,1,bool(Scope*)
111669152221,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void CheckUnusedVar::checkFunctionVariableUsage_iterateScopes(const Scope* const scope, Variables& variables)
{
    // Find declarations if the scope is executable..
    if (scope->isExecutable()) {
        // Find declarations
        for (auto i = scope->varlist.cbegin(); i != scope->varlist.cend(); ++i) {
            if (i->isThrow() || i->isExtern())
                continue;
            Variables::VariableType type = Variables::none;
            if (i->isArray() && (i->nameToken()->strAt(-1) == ""*"" || i->nameToken()->strAt(-2) == ""*""))
                type = Variables::pointerArray;
            else if (i->isArray() && i->nameToken()->strAt(-1) == ""&"")
                type = Variables::referenceArray;
            else if (i->isArray())
                type = Variables::array;
            else if (i->isReference() && !(i->valueType() && i->valueType()->type == ValueType::UNKNOWN_TYPE && Token::simpleMatch(i->typeStartToken(), ""auto"")))
                type = Variables::reference...",1,12,lib/checkunusedvar.cpp,"CheckUnusedVar.checkFunctionVariableUsage_iterateScopes:void(Scope*,Variables&)",<empty>,,false,692,1151,checkFunctionVariableUsage_iterateScopes,,,1,"void(Scope*,Variables&)"
111669152222,METHOD,<empty>,<empty>,"[var](const Token* tok) {
        return tok->varId() == var->declarationId();
    }",56,5,lib/checkunusedvar.cpp,lib/checkunusedvar.cpp:<global>.isReturnedByRef.<lambda>1:bool(Token*),<empty>,,false,1158,1160,<lambda>1,,,1,bool(Token*)
111669152223,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"static bool isReturnedByRef(const Variable* var, const Function* func)
{
    if (!func || !Function::returnsReference(func, true))
        return false;
    const std::vector<const Token*> returns = Function::findReturns(func);
    return std::any_of(returns.begin(), returns.end(), [var](const Token* tok) {
        return tok->varId() == var->declarationId();
    });
}",1,1,lib/checkunusedvar.cpp,"isReturnedByRef:bool(Variable*,Function*)",<empty>,,false,1153,1161,isReturnedByRef,,,1,"bool(Variable*,Function*)"
111669152224,METHOD,<empty>,<empty>,"[this](const Token* tok, const std::string& typeName) {
        if (mSettings->checkLibrary) {
            reportError(tok,
                        Severity::information,
                        ""checkLibraryCheckType"",
                        ""--check-library: Provide <type-checks><unusedvar> configuration for "" + typeName);
        }
    }",34,5,lib/checkunusedvar.cpp,"lib/checkunusedvar.cpp:<global>.CheckUnusedVar.checkFunctionVariableUsage.<lambda>2:void(Token*,std.string&)",<empty>,,false,1173,1180,<lambda>2,,,1,"void(Token*,std.string&)"
111669152225,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void CheckUnusedVar::checkFunctionVariableUsage()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->checkLibrary && !mSettings->isPremiumEnabled(""unusedVariable""))
        return;

    logChecker(""CheckUnusedVar::checkFunctionVariableUsage""); // style

    // Parse all executing scopes..
    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    auto reportLibraryCfgError = [this](const Token* tok, const std::string& typeName) {
        if (mSettings->checkLibrary) {
            reportError(tok,
                        Severity::information,
                        ""checkLibraryCheckType"",
                        ""--check-library: Provide <type-checks><unusedvar> configuration for "" + typeName);
        }
    };

    // only check functions
    for (const Scope * scope : symbolDatabase->functionScopes) {
        // Bailout when there are lambdas or inline functions
        // TODO: Handle lambdas and inline functions properly
        cons...",1,1,lib/checkunusedvar.cpp,CheckUnusedVar.checkFunctionVariableUsage:void(),<empty>,,false,1163,1426,checkFunctionVariableUsage,,,1,void()
111669152226,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void CheckUnusedVar::unusedVariableError(const Token *tok, const std::string &varname)
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""unusedVariable""))
        return;

    reportError(tok, Severity::style, ""unusedVariable"", ""$symbol:"" + varname + ""\\nUnused variable: $symbol"", CWE563, Certainty::normal);
}",1,1,lib/checkunusedvar.cpp,"CheckUnusedVar.unusedVariableError:void(Token*,std.string&)",<empty>,,false,1428,1434,unusedVariableError,,,1,"void(Token*,std.string&)"
111669152227,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void CheckUnusedVar::allocatedButUnusedVariableError(const Token *tok, const std::string &varname)
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""unusedVariable""))
        return;

    reportError(tok, Severity::style, ""unusedAllocatedMemory"", ""$symbol:"" + varname + ""\\nVariable '$symbol' is allocated memory that is never used."", CWE563, Certainty::normal);
}",1,1,lib/checkunusedvar.cpp,"CheckUnusedVar.allocatedButUnusedVariableError:void(Token*,std.string&)",<empty>,,false,1436,1442,allocatedButUnusedVariableError,,,1,"void(Token*,std.string&)"
111669152228,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void CheckUnusedVar::unreadVariableError(const Token *tok, const std::string &varname, bool modified)
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""unusedVariable""))
        return;

    if (modified)
        reportError(tok, Severity::style, ""unreadVariable"", ""$symbol:"" + varname + ""\\nVariable '$symbol' is modified but its new value is never used."", CWE563, Certainty::normal);
    else
        reportError(tok, Severity::style, ""unreadVariable"", ""$symbol:"" + varname + ""\\nVariable '$symbol' is assigned a value that is never used."", CWE563, Certainty::normal);
}",1,1,lib/checkunusedvar.cpp,"CheckUnusedVar.unreadVariableError:void(Token*,std.string&,bool)",<empty>,,false,1444,1453,unreadVariableError,,,1,"void(Token*,std.string&,bool)"
111669152229,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void CheckUnusedVar::unassignedVariableError(const Token *tok, const std::string &varname)
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""unusedVariable""))
        return;

    reportError(tok, Severity::style, ""unassignedVariable"", ""$symbol:"" + varname + ""\\nVariable '$symbol' is not assigned a value."", CWE665, Certainty::normal);
}",1,1,lib/checkunusedvar.cpp,"CheckUnusedVar.unassignedVariableError:void(Token*,std.string&)",<empty>,,false,1455,1461,unassignedVariableError,,,1,"void(Token*,std.string&)"
111669152230,METHOD,<empty>,<empty>,"[&](const Type::BaseInfo& derivedFrom) {
                return derivedFrom.type == scope.definedType && derivedFrom.access != AccessControl::Private;
            }",97,13,lib/checkunusedvar.cpp,lib/checkunusedvar.cpp:<global>.CheckUnusedVar.checkStructMemberUsage.<lambda>3.<lambda>4:bool(Type.BaseInfo&),<empty>,,false,1498,1500,<lambda>4,,,1,bool(Type.BaseInfo&)
111669152231,METHOD,<empty>,<empty>,"[&](const Scope& derivedScope) {
            const Type* dType = derivedScope.definedType;
            return dType && std::any_of(dType->derivedFrom.cbegin(), dType->derivedFrom.cend(), [&](const Type::BaseInfo& derivedFrom) {
                return derivedFrom.type == scope.definedType && derivedFrom.access != AccessControl::Private;
            });
        }",116,9,lib/checkunusedvar.cpp,lib/checkunusedvar.cpp:<global>.CheckUnusedVar.checkStructMemberUsage.<lambda>3:bool(Scope&),<empty>,,false,1496,1501,<lambda>3,,,1,bool(Scope&)
111669152232,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void CheckUnusedVar::checkStructMemberUsage()
{
    if (!mSettings->severity.isEnabled(Severity::style) && !mSettings->isPremiumEnabled(""unusedStructMember"") && !mSettings->isPremiumEnabled(""unusedVariable""))
        return;

    logChecker(""CheckUnusedVar::checkStructMemberUsage""); // style

    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();

    for (const Scope &scope : symbolDatabase->scopeList) {
        if (scope.type != ScopeType::eStruct && scope.type != ScopeType::eClass && scope.type != ScopeType::eUnion)
            continue;

        if (scope.bodyStart->fileIndex() != 0 || scope.className.empty())
            continue;

        if (scope.classDef->isExpandedMacro())
            continue;

        // Packed struct => possibly used by lowlevel code. Struct members might be required by hardware.
        if (scope.bodyEnd->isAttributePacked())
            continue;
        if (mTokenizer->isPacked(scope.bodyStart))
            continue;

        // ...",1,1,lib/checkunusedvar.cpp,CheckUnusedVar.checkStructMemberUsage:void(),<empty>,,false,1466,1611,checkStructMemberUsage,,,1,void()
111669152233,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void CheckUnusedVar::unusedStructMemberError(const Token* tok, const std::string& structname, const std::string& varname, const std::string& prefix)
{
    reportError(tok, Severity::style, ""unusedStructMember"", ""$symbol:"" + structname + ""::"" + varname + '\\n' + prefix + "" member '$symbol' is never used."", CWE563, Certainty::normal);
}",1,1,lib/checkunusedvar.cpp,"CheckUnusedVar.unusedStructMemberError:void(Token*,std.string&,std.string&,std.string&)",<empty>,,false,1613,1616,unusedStructMemberError,,,1,"void(Token*,std.string&,std.string&,std.string&)"
111669152234,METHOD,<empty>,<empty>,"[this](const Type::BaseInfo& derivedFrom) {
        return !isRecordTypeWithoutSideEffects(derivedFrom.type);
    }",75,5,lib/checkunusedvar.cpp,lib/checkunusedvar.cpp:<global>.CheckUnusedVar.isRecordTypeWithoutSideEffects.<lambda>5:bool(Type.BaseInfo&),<empty>,,false,1677,1679,<lambda>5,,,1,bool(Type.BaseInfo&)
111669152235,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"bool CheckUnusedVar::isRecordTypeWithoutSideEffects(const Type* type)
{
    // a type that has no side effects (no constructors and no members with constructors)
    /** @todo false negative: check constructors for side effects */
    const std::pair<std::map<const Type *,bool>::iterator,bool> found=mIsRecordTypeWithoutSideEffectsMap.insert(
        std::pair<const Type *,bool>(type,false));         //Initialize with side effects for possible recursions
    bool & withoutSideEffects = found.first->second;
    if (!found.second)
        return withoutSideEffects;

    // unknown types are assumed to have side effects
    if (!type || !type->classScope)
        return (withoutSideEffects = false);

    // Non-empty constructors => possible side effects
    for (const Function& f : type->classScope->functionList) {
        if (!f.isConstructor() && !f.isDestructor())
            continue;
        if (f.argDef && Token::simpleMatch(f.argDef->link(), "") =""))
            continue; // igno...",1,1,lib/checkunusedvar.cpp,CheckUnusedVar.isRecordTypeWithoutSideEffects:bool(Type*),<empty>,,false,1618,1692,isRecordTypeWithoutSideEffects,,,1,bool(Type*)
111669152236,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"bool CheckUnusedVar::isVariableWithoutSideEffects(const Variable& var, const Type* type)
{
    const Type* variableType = var.type();
    if (variableType && variableType != type) {
        if (!isRecordTypeWithoutSideEffects(variableType))
            return false;
    } else {
        if (WRONG_DATA(!var.valueType(), var.typeStartToken()))
            return false;
        const ValueType::Type valueType = var.valueType()->type;
        if ((valueType == ValueType::Type::UNKNOWN_TYPE) || (valueType == ValueType::Type::NONSTD))
            return false;
    }

    return true;
}",1,12,lib/checkunusedvar.cpp,"CheckUnusedVar.isVariableWithoutSideEffects:bool(Variable&,Type*)",<empty>,,false,1694,1709,isVariableWithoutSideEffects,,,1,"bool(Variable&,Type*)"
111669152237,METHOD,<empty>,<empty>,"[this](const Type::BaseInfo& bi) {
            return isEmptyType(bi.type);
        }",95,9,lib/checkunusedvar.cpp,lib/checkunusedvar.cpp:<global>.CheckUnusedVar.isEmptyType.<lambda>6:bool(Type.BaseInfo&),<empty>,,false,1723,1725,<lambda>6,,,1,bool(Type.BaseInfo&)
111669152238,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"bool CheckUnusedVar::isEmptyType(const Type* type)
{
    // a type that has no variables and no constructor

    const std::pair<std::map<const Type *,bool>::iterator,bool> found=mIsEmptyTypeMap.insert(
        std::pair<const Type *,bool>(type,false));
    bool & emptyType=found.first->second;
    if (!found.second)
        return emptyType;

    if (type && type->classScope && type->classScope->numConstructors == 0 &&
        (type->classScope->varlist.empty())) {
        return (emptyType = std::all_of(type->derivedFrom.cbegin(), type->derivedFrom.cend(), [this](const Type::BaseInfo& bi) {
            return isEmptyType(bi.type);
        }));
    }

    // unknown types are assumed to be nonempty
    return (emptyType = false);
}",1,1,lib/checkunusedvar.cpp,CheckUnusedVar.isEmptyType:bool(Type*),<empty>,,false,1711,1730,isEmptyType,,,1,bool(Type*)
111669152239,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"bool CheckUnusedVar::isFunctionWithoutSideEffects(const Function& func, const Token* functionUsageToken,
                                                  std::list<const Function*> checkedFuncs)
{
    // no body to analyze
    if (!func.hasBody()) {
        return false;
    }

    for (const Token* argsToken = functionUsageToken->next(); !Token::simpleMatch(argsToken, "")""); argsToken = argsToken->next()) {
        const Variable* argVar = argsToken->variable();
        if (argVar && argVar->isGlobal()) {
            return false; // TODO: analyze global variable usage
        }
    }

    bool sideEffectReturnFound = false;
    std::set<const Variable*> pointersToGlobals;
    for (const Token* bodyToken = func.functionScope->bodyStart->next(); bodyToken != func.functionScope->bodyEnd;
         bodyToken = bodyToken->next()) {
        // check variable inside function body
        const Variable* bodyVariable = bodyToken->variable();
        if (bodyVariable) {
            if (!isV...",1,1,lib/checkunusedvar.cpp,"CheckUnusedVar.isFunctionWithoutSideEffects:bool(Function&,Token*,std.list<constFunction*>)",<empty>,,false,1732,1809,isFunctionWithoutSideEffects,,,1,"bool(Function&,Token*,std.list<constFunction*>)"
111669152240,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void CheckUnusedVar::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    CheckUnusedVar checkUnusedVar(&tokenizer, &tokenizer.getSettings(), errorLogger);

    // Coding style checks
    checkUnusedVar.checkStructMemberUsage();
    checkUnusedVar.checkFunctionVariableUsage();
}",1,1,lib/checkunusedvar.cpp,"CheckUnusedVar.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,1811,1818,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669152241,METHOD,lib/checkunusedvar.cpp:<global>,TYPE_DECL,"void CheckUnusedVar::getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const
{
    CheckUnusedVar c(nullptr, settings, errorLogger);
    c.unusedVariableError(nullptr, ""varname"");
    c.allocatedButUnusedVariableError(nullptr, ""varname"");
    c.unreadVariableError(nullptr, ""varname"", false);
    c.unassignedVariableError(nullptr, ""varname"");
    c.unusedStructMemberError(nullptr, ""structname"", ""variable"");
}",1,1,lib/checkunusedvar.cpp,"CheckUnusedVar.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,1820,1828,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669152242,METHOD,lib/checkunusedvar.h:<global>,TYPE_DECL,<global>,1,1,lib/checkunusedvar.h,lib/checkunusedvar.h:<global>,<empty>,,false,1,106,<global>,,,1,
111669152243,METHOD,lib/checkvaarg.cpp:<global>,TYPE_DECL,"void CheckVaarg::va_start_argument()
{
    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();
    const std::size_t functions = symbolDatabase->functionScopes.size();
    const bool printWarnings = mSettings->severity.isEnabled(Severity::warning);

    logChecker(""CheckVaarg::va_start_argument"");

    for (std::size_t i = 0; i < functions; ++i) {
        const Scope* scope = symbolDatabase->functionScopes[i];
        const Function* function = scope->function;
        if (!function)
            continue;
        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {
            if (!tok->scope()->isExecutable())
                tok = tok->scope()->bodyEnd;
            else if (Token::simpleMatch(tok, ""va_start ("")) {
                const Token* param2 = tok->tokAt(2)->nextArgument();
                if (!param2)
                    continue;
                const Variable* var = param2->variable();
                if...",1,1,lib/checkvaarg.cpp,CheckVaarg.va_start_argument:void(),<empty>,,false,50,82,va_start_argument,,,1,void()
111669152244,METHOD,lib/checkvaarg.cpp:<global>,TYPE_DECL,<global>,1,1,lib/checkvaarg.cpp,lib/checkvaarg.cpp:<global>,<empty>,,false,1,199,<global>,,,1,
111669152245,METHOD,lib/checkvaarg.cpp:<global>,TYPE_DECL,"void CheckVaarg::wrongParameterTo_va_start_error(const Token *tok, const std::string& paramIsName, const std::string& paramShouldName)
{
    reportError(tok, Severity::warning,
                ""va_start_wrongParameter"", ""'"" + paramIsName + ""' given to va_start() is not last named argument of the function. Did you intend to pass '"" + paramShouldName + ""'?"", CWE688, Certainty::normal);
}",1,1,lib/checkvaarg.cpp,"CheckVaarg.wrongParameterTo_va_start_error:void(Token*,std.string&,std.string&)",<empty>,,false,84,88,wrongParameterTo_va_start_error,,,1,"void(Token*,std.string&,std.string&)"
111669152246,METHOD,lib/checkvaarg.cpp:<global>,TYPE_DECL,"void CheckVaarg::referenceAs_va_start_error(const Token *tok, const std::string& paramName)
{
    reportError(tok, Severity::error,
                ""va_start_referencePassed"", ""Using reference '"" + paramName + ""' as parameter for va_start() results in undefined behaviour."", CWE758, Certainty::normal);
}",1,1,lib/checkvaarg.cpp,"CheckVaarg.referenceAs_va_start_error:void(Token*,std.string&)",<empty>,,false,90,94,referenceAs_va_start_error,,,1,"void(Token*,std.string&)"
111669152247,METHOD,lib/checkvaarg.cpp:<global>,TYPE_DECL,"void CheckVaarg::va_list_usage()
{
    if (mSettings->clang)
        return;

    logChecker(""CheckVaarg::va_list_usage""); // notclang

    const SymbolDatabase* const symbolDatabase = mTokenizer->getSymbolDatabase();
    for (const Variable* var : symbolDatabase->variableList()) {
        if (!var || var->isPointer() || var->isReference() || var->isArray() || !var->scope() || var->typeStartToken()->str() != ""va_list"")
            continue;
        if (!var->isLocal() && !var->isArgument()) // Check only local variables and arguments
            continue;

        bool open = var->isArgument(); // va_list passed as argument are opened
        bool exitOnEndOfStatement = false;

        const Token* tok = var->nameToken()->next();
        for (; tok && tok != var->scope()->bodyEnd; tok = tok->next()) {
            // Skip lambdas
            const Token* tok2 = findLambdaEndToken(tok);
            if (tok2)
                tok = tok2;
            if (Token::Match(tok, ""va_start ( %va...",1,1,lib/checkvaarg.cpp,CheckVaarg.va_list_usage:void(),<empty>,,false,101,164,va_list_usage,,,1,void()
111669152248,METHOD,lib/checkvaarg.cpp:<global>,TYPE_DECL,"void CheckVaarg::va_end_missingError(const Token *tok, const std::string& varname)
{
    reportError(tok, Severity::error,
                ""va_end_missing"", ""va_list '"" + varname + ""' was opened but not closed by va_end()."", CWE664, Certainty::normal);
}",1,1,lib/checkvaarg.cpp,"CheckVaarg.va_end_missingError:void(Token*,std.string&)",<empty>,,false,166,170,va_end_missingError,,,1,"void(Token*,std.string&)"
111669152249,METHOD,lib/checkvaarg.cpp:<global>,TYPE_DECL,"void CheckVaarg::va_list_usedBeforeStartedError(const Token *tok, const std::string& varname)
{
    reportError(tok, Severity::error,
                ""va_list_usedBeforeStarted"", ""va_list '"" + varname + ""' used before va_start() was called."", CWE664, Certainty::normal);
}",1,1,lib/checkvaarg.cpp,"CheckVaarg.va_list_usedBeforeStartedError:void(Token*,std.string&)",<empty>,,false,172,176,va_list_usedBeforeStartedError,,,1,"void(Token*,std.string&)"
111669152250,METHOD,lib/checkvaarg.cpp:<global>,TYPE_DECL,"void CheckVaarg::va_start_subsequentCallsError(const Token *tok, const std::string& varname)
{
    reportError(tok, Severity::error,
                ""va_start_subsequentCalls"", ""va_start() or va_copy() called subsequently on '"" + varname + ""' without va_end() in between."", CWE664, Certainty::normal);
}",1,1,lib/checkvaarg.cpp,"CheckVaarg.va_start_subsequentCallsError:void(Token*,std.string&)",<empty>,,false,178,182,va_start_subsequentCallsError,,,1,"void(Token*,std.string&)"
111669152251,METHOD,lib/checkvaarg.cpp:<global>,TYPE_DECL,"void CheckVaarg::runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger)
{
    CheckVaarg check(&tokenizer, &tokenizer.getSettings(), errorLogger);
    check.va_start_argument();
    check.va_list_usage();
}",1,1,lib/checkvaarg.cpp,"CheckVaarg.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,false,184,189,runChecks,,,1,"void(Tokenizer&,ErrorLogger*)"
111669152252,METHOD,lib/checkvaarg.cpp:<global>,TYPE_DECL,"void CheckVaarg::getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const
{
    CheckVaarg c(nullptr, settings, errorLogger);
    c.wrongParameterTo_va_start_error(nullptr, ""arg1"", ""arg2"");
    c.referenceAs_va_start_error(nullptr, ""arg1"");
    c.va_end_missingError(nullptr, ""vl"");
    c.va_list_usedBeforeStartedError(nullptr, ""vl"");
    c.va_start_subsequentCallsError(nullptr, ""vl"");
}",1,1,lib/checkvaarg.cpp,"CheckVaarg.getErrorMessages<const>:void(ErrorLogger*,Settings*)",<empty>,,false,191,199,getErrorMessages,,,1,"void(ErrorLogger*,Settings*)"
111669152253,METHOD,lib/checkvaarg.h:<global>,TYPE_DECL,<global>,1,1,lib/checkvaarg.h,lib/checkvaarg.h:<global>,<empty>,,false,1,80,<global>,,,1,
111669152254,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"static std::string unquote(const std::string &s)
{
    return (s[0] == '\\'') ? s.substr(1, s.size() - 2) : s;
}",1,1,lib/clangimport.cpp,unquote:string(std.string&),<empty>,,false,119,122,unquote,,,1,string(std.string&)
111669152255,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,<global>,1,1,lib/clangimport.cpp,lib/clangimport.cpp:<global>,<empty>,,false,1,1679,<global>,,,1,
111669152256,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"static std::vector<std::string> splitString(const std::string &line)
{
    std::vector<std::string> ret;
    std::string::size_type pos1 = line.find_first_not_of(' ');
    while (pos1 < line.size()) {
        std::string::size_type pos2;
        if (std::strchr(""*()"", line[pos1])) {
            ret.push_back(line.substr(pos1,1));
            pos1 = line.find_first_not_of(' ', pos1 + 1);
            continue;
        }
        if (line[pos1] == '<')
            pos2 = line.find('>', pos1);
        else if (line[pos1] == '\\""')
            pos2 = line.find('\\""', pos1+1);
        else if (line[pos1] == '\\'') {
            pos2 = line.find('\\'', pos1+1);
            if (pos2 < (int)line.size() - 3 && line.compare(pos2, 3, ""\\':\\'"", 0, 3) == 0)
                pos2 = line.find('\\'', pos2 + 3);
        } else {
            pos2 = pos1;
            while (pos2 < line.size() && (line[pos2] == '_' || line[pos2] == ':' || std::isalnum((unsigned char)line[pos2])))
                ++pos2;
       ...",1,1,lib/clangimport.cpp,splitString:vector<std.string>(std.string&),<empty>,,false,125,203,splitString,,,1,vector<std::string>(std.string&)
111669152257,METHOD,clangimport.Data.Decl,TYPE_DECL,explicit Decl(Scope *scope) : scope(scope) {},13,57,lib/clangimport.cpp,clangimport.Data.Decl.Decl:ANY(Scope*),<empty>,,false,209,209,Decl,,,1,clangimport.Data.Decl.Decl:ANY(Scope*)(Scope*)
111669152258,METHOD,clangimport.Data.Decl,TYPE_DECL,"Decl(Token *def, Variable *var) : def(def), var(var) {}",13,67,lib/clangimport.cpp,"clangimport.Data.Decl.Decl:ANY(Token*,Variable*)",<empty>,,false,210,210,Decl,,,2,"clangimport.Data.Decl.Decl:ANY(Token*,Variable*)(Token*,Variable*)"
111669152259,METHOD,clangimport.Data.Decl,TYPE_DECL,"Decl(Token *def, Function *function) : def(def), function(function) {}",13,82,lib/clangimport.cpp,"clangimport.Data.Decl.Decl:ANY(Token*,Function*)",<empty>,,false,211,211,Decl,,,3,"clangimport.Data.Decl.Decl:ANY(Token*,Function*)(Token*,Function*)"
111669152260,METHOD,clangimport.Data.Decl,TYPE_DECL,"Decl(Token *def, Enumerator *enumerator) : def(def), enumerator(enumerator) {}",13,90,lib/clangimport.cpp,"clangimport.Data.Decl.Decl:ANY(Token*,Enumerator*)",<empty>,,false,212,212,Decl,,,4,"clangimport.Data.Decl.Decl:ANY(Token*,Enumerator*)(Token*,Enumerator*)"
111669152261,METHOD,clangimport.Data.Decl,TYPE_DECL,"void ref(Token *tok) const {
                if (enumerator)
                    tok->enumerator(enumerator);
                if (function)
                    tok->function(function);
                if (var) {
                    tok->variable(var);
                    tok->varId(var->declarationId());
                }
            }",13,13,lib/clangimport.cpp,clangimport.Data.Decl.ref<const>:void(Token*),<empty>,,false,213,222,ref,,,5,void(Token*)
111669152262,METHOD,<empty>,<empty>,<empty>,9,,lib/clangimport.cpp,clangimport.Data.Decl.<clinit>,<empty>,,false,208,,<clinit>,,,11,
111669152263,METHOD,clangimport.Data,TYPE_DECL,"void enumDecl(const std::string &addr, Token *nameToken, Enumerator *enumerator) {
            Decl decl(nameToken, enumerator);
            mDeclMap.emplace(addr, decl);
            nameToken->enumerator(enumerator);
            notFound(addr);
        }",9,9,lib/clangimport.cpp,"clangimport.Data.enumDecl:void(std.string&,Token*,Enumerator*)",<empty>,,false,235,240,enumDecl,,,5,"void(std.string&,Token*,Enumerator*)"
111669152264,METHOD,clangimport.Data,TYPE_DECL,"void funcDecl(const std::string &addr, Token *nameToken, Function *function) {
            Decl decl(nameToken, function);
            mDeclMap.emplace(addr, decl);
            nameToken->function(function);
            notFound(addr);
        }",9,9,lib/clangimport.cpp,"clangimport.Data.funcDecl:void(std.string&,Token*,Function*)",<empty>,,false,242,247,funcDecl,,,6,"void(std.string&,Token*,Function*)"
111669152265,METHOD,clangimport.Data,TYPE_DECL,"void scopeDecl(const std::string &addr, Scope *scope) {
            Decl decl(scope);
            mDeclMap.emplace(addr, decl);
        }",9,9,lib/clangimport.cpp,"clangimport.Data.scopeDecl:void(std.string&,Scope*)",<empty>,,false,249,252,scopeDecl,,,7,"void(std.string&,Scope*)"
111669152266,METHOD,clangimport.Data,TYPE_DECL,"void varDecl(const std::string &addr, Token *def, Variable *var) {
            Decl decl(def, var);
            mDeclMap.emplace(addr, decl);
            def->varId(++mVarId);
            def->variable(var);
            if (def->valueType())
                var->setValueType(*def->valueType());
            notFound(addr);
        }",9,9,lib/clangimport.cpp,"clangimport.Data.varDecl:void(std.string&,Token*,Variable*)",<empty>,,false,254,262,varDecl,,,8,"void(std.string&,Token*,Variable*)"
111669152267,METHOD,clangimport.Data,TYPE_DECL,"void replaceVarDecl(const Variable *from, Variable *to) {
            for (auto &it: mDeclMap) {
                Decl &decl = it.second;
                if (decl.var == from)
                    decl.var = to;
            }
        }",9,9,lib/clangimport.cpp,"clangimport.Data.replaceVarDecl:void(Variable*,Variable*)",<empty>,,false,264,270,replaceVarDecl,,,9,"void(Variable*,Variable*)"
111669152268,METHOD,clangimport.Data,TYPE_DECL,"void ref(const std::string &addr, Token *tok) {
            auto it = mDeclMap.find(addr);
            if (it != mDeclMap.end())
                it->second.ref(tok);
            else
                mNotFound[addr].push_back(tok);
        }",9,9,lib/clangimport.cpp,"clangimport.Data.ref:void(std.string&,Token*)",<empty>,,false,272,278,ref,,,10,"void(std.string&,Token*)"
111669152269,METHOD,clangimport.Data,TYPE_DECL,"std::vector<const Variable *> getVariableList() const {
            std::vector<const Variable *> ret;
            ret.resize(mVarId + 1, nullptr);
            for (const auto& it: mDeclMap) {
                if (it.second.var)
                    ret[it.second.var->declarationId()] = it.second.var;
            }
            return ret;
        }",9,9,lib/clangimport.cpp,clangimport.Data.getVariableList<const>:vector<constVariable*>(),<empty>,,false,280,288,getVariableList,,,11,vector<const Variable*>()
111669152270,METHOD,clangimport.Data,TYPE_DECL,"bool hasDecl(const std::string &addr) const {
            return mDeclMap.find(addr) != mDeclMap.end();
        }",9,9,lib/clangimport.cpp,clangimport.Data.hasDecl<const>:bool(std.string&),<empty>,,false,290,292,hasDecl,,,12,bool(std.string&)
111669152271,METHOD,clangimport.Data,TYPE_DECL,"const Scope *getScope(const std::string &addr) {
            auto it = mDeclMap.find(addr);
            return (it == mDeclMap.end() ? nullptr : it->second.scope);
        }",9,9,lib/clangimport.cpp,clangimport.Data.getScope:Scope*(std.string&),<empty>,,false,294,297,getScope,,,13,Scope*(std.string&)
111669152272,METHOD,clangimport.Data,TYPE_DECL,"void notFound(const std::string &addr) {
            auto it = mNotFound.find(addr);
            if (it != mNotFound.end()) {
                for (Token *reftok: it->second)
                    ref(addr, reftok);
                mNotFound.erase(it);
            }
        }",9,9,lib/clangimport.cpp,clangimport.Data.notFound:void(std.string&),<empty>,,false,304,311,notFound,,,16,void(std.string&)
111669152273,METHOD,<empty>,<empty>,<empty>,5,,lib/clangimport.cpp,clangimport.Data.<clinit>,<empty>,,false,207,,<clinit>,,,20,
111669152274,METHOD,clangimport.AstNode,TYPE_DECL,"AstNode(std::string nodeType, const std::string &ext, Data *data)
            : nodeType(std::move(nodeType)), mExtTokens(splitString(ext)), mData(data)
        {}",9,10,lib/clangimport.cpp,"clangimport.AstNode.AstNode:ANY(std.string,std.string&,clangimport.Data*)",<empty>,,false,323,325,AstNode,,,1,"clangimport.AstNode.AstNode:ANY(std.string,std.string&,clangimport.Data*)(std.string,std.string&,clangimport.Data*)"
111669152275,METHOD,clangimport.AstNode,TYPE_DECL,"void createTokens1(TokenList &tokenList) {
            //dumpAst(); // TODO: reactivate or remove
            if (isPrologueTypedefDecl())
                return;
            if (!tokenList.back()) {
                setLocations(tokenList, 0, 1, 1);
            }
            else
                setLocations(tokenList, tokenList.back()->fileIndex(), tokenList.back()->linenr(), 1);
            createTokens(tokenList);
            if (nodeType == VarDecl || nodeType == RecordDecl || nodeType == TypedefDecl)
                addtoken(tokenList, "";"");
            mData->mNotScope.clear();
        }",9,9,lib/clangimport.cpp,clangimport.AstNode.createTokens1:void(TokenList&),<empty>,,false,333,346,createTokens1,,,4,void(TokenList&)
111669152276,METHOD,clangimport.AstNode,TYPE_DECL,"AstNodePtr getChild(int c) {
            if (c >= children.size()) {
                std::ostringstream err;
                err << ""ClangImport: AstNodePtr::getChild("" << c << "") out of bounds. children.size="" << children.size() << "" "" << nodeType;
                for (const std::string &s: mExtTokens)
                    err << "" "" << s;
                throw InternalError(nullptr, err.str());
            }
            return children[c];
        }",9,9,lib/clangimport.cpp,clangimport.AstNode.getChild:AstNodePtr(int),<empty>,,false,348,357,getChild,,,5,AstNodePtr(int)
111669152277,METHOD,<empty>,<empty>,<empty>,5,,lib/clangimport.cpp,clangimport.AstNode.<clinit>,<empty>,,false,321,,<clinit>,,,11,
111669152278,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"std::string clangimport::AstNode::getSpelling() const
{
    if (nodeType == CompoundAssignOperator) {
        std::size_t typeIndex = 1;
        while (typeIndex < mExtTokens.size() && mExtTokens[typeIndex][0] != '\\'')
            typeIndex++;
        // name is next quoted token
        std::size_t nameIndex = typeIndex + 1;
        while (nameIndex < mExtTokens.size() && mExtTokens[nameIndex][0] != '\\'')
            nameIndex++;
        return (nameIndex < mExtTokens.size()) ? unquote(mExtTokens[nameIndex]) : """";
    }

    if (nodeType == UnaryExprOrTypeTraitExpr) {
        std::size_t typeIndex = 1;
        while (typeIndex < mExtTokens.size() && mExtTokens[typeIndex][0] != '\\'')
            typeIndex++;
        const std::size_t nameIndex = typeIndex + 1;
        return (nameIndex < mExtTokens.size()) ? unquote(mExtTokens[nameIndex]) : """";
    }

    int typeIndex = mExtTokens.size() - 1;
    if (nodeType == FunctionDecl || nodeType == CXXConstructorDecl || nodeType == CXXMetho...",1,1,lib/clangimport.cpp,clangimport.AstNode.getSpelling<const>:string(),<empty>,,false,385,427,getSpelling,,,1,string()
111669152279,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"std::string clangimport::AstNode::getType(int index) const
{
    std::string type = getFullType(index);
    if (type.find("" ("") != std::string::npos) {
        const std::string::size_type pos = type.find("" ("");
        type[pos] = '\\'';
        type.erase(pos+1);
    }
    if (type.find("" *("") != std::string::npos) {
        const std::string::size_type pos = type.find("" *("") + 2;
        type[pos] = '\\'';
        type.erase(pos+1);
    }
    if (type.find("" &("") != std::string::npos) {
        const std::string::size_type pos = type.find("" &("") + 2;
        type[pos] = '\\'';
        type.erase(pos+1);
    }
    return unquote(type);
}",1,1,lib/clangimport.cpp,clangimport.AstNode.getType<const>:string(int),<empty>,,false,429,448,getType,,,1,string(int)
111669152280,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"std::string clangimport::AstNode::getFullType(int index) const
{
    std::size_t typeIndex = 1;
    while (typeIndex < mExtTokens.size() && mExtTokens[typeIndex][0] != '\\'')
        typeIndex++;
    if (typeIndex >= mExtTokens.size())
        return """";
    std::string type = mExtTokens[typeIndex];
    if (type.find(""\\':\\'"") != std::string::npos) {
        if (index == 0)
            type.erase(type.find(""\\':\\'"") + 1);
        else
            type.erase(0, type.find(""\\':\\'"") + 2);
    }
    return type;
}",1,1,lib/clangimport.cpp,clangimport.AstNode.getFullType<const>:string(int),<empty>,,false,450,465,getFullType,,,1,string(int)
111669152281,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"bool clangimport::AstNode::isDefinition() const
{
    return contains(mExtTokens, ""definition"");
}",1,1,lib/clangimport.cpp,clangimport.AstNode.isDefinition<const>:bool(),<empty>,,false,467,470,isDefinition,,,1,bool()
111669152282,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"std::string clangimport::AstNode::getTemplateParameters() const
{
    if (children.empty() || children[0]->nodeType != TemplateArgument)
        return """";
    std::string templateParameters;
    for (const AstNodePtr& child: children) {
        if (child->nodeType == TemplateArgument) {
            if (templateParameters.empty())
                templateParameters = ""<"";
            else
                templateParameters += "","";
            templateParameters += unquote(child->mExtTokens.back());
        }
    }
    return templateParameters + "">"";
}",1,1,lib/clangimport.cpp,clangimport.AstNode.getTemplateParameters<const>:string(),<empty>,,false,472,487,getTemplateParameters,,,1,string()
111669152283,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"void clangimport::AstNode::dumpAst(int num, int indent) const
{
    (void)num;
    std::cout << std::string(indent, ' ') << nodeType;
    for (const auto& tok: mExtTokens)
        std::cout << "" "" << tok;
    std::cout << std::endl;
    for (int c = 0; c < children.size(); ++c) {
        if (children[c])
            children[c]->dumpAst(c, indent + 2);
        else
            std::cout << std::string(indent + 2, ' ') << ""<<<<NULL>>>>>"" << std::endl;
    }
}",1,1,lib/clangimport.cpp,"clangimport.AstNode.dumpAst<const>:void(int,int)",<empty>,,false,490,503,dumpAst,,,1,"void(int,int)"
111669152284,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"bool clangimport::AstNode::isPrologueTypedefDecl() const
{
    // these TypedefDecl are included in *any* AST dump and we should ignore them as they should not be of interest to us
    // see https://github.com/llvm/llvm-project/issues/120228#issuecomment-2549212109 for an explanation
    if (nodeType != TypedefDecl)
        return false;

    // TODO: use different values to indicate ""<invalid sloc>""?
    if (mFile != 0 || mLine != 1 || mCol != 1)
        return false;

    // TODO: match without using children
    if (children.empty())
        return false;

    if (children[0].get()->mExtTokens.size() < 2)
        return false;

    const auto& type = children[0].get()->mExtTokens[1];
    if (type == ""'__int128'"" ||
        type == ""'unsigned __int128'"" ||
        type == ""'struct __NSConstantString_tag'"" ||
        type == ""'char *'"" ||
        type == ""'struct __va_list_tag[1]'"")
    {
        // NOLINTNEXTLINE(readability-simplify-boolean-expr)
        return true;
    }

    ...",1,1,lib/clangimport.cpp,clangimport.AstNode.isPrologueTypedefDecl<const>:bool(),<empty>,,false,505,535,isPrologueTypedefDecl,,,1,bool()
111669152285,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"void clangimport::AstNode::setLocations(TokenList &tokenList, int file, int line, int col)
{
    if (mExtTokens.size() >= 2)
    {
        const std::string &ext = mExtTokens[1];
        if (startsWith(ext, ""<col:""))
            col = strToInt<int>(ext.substr(5, ext.find_first_of("",>"", 5) - 5));
        else if (startsWith(ext, ""<line:"")) {
            line = strToInt<int>(ext.substr(6, ext.find_first_of("":,>"", 6) - 6));
            const auto pos = ext.find("", col:"");
            if (pos != std::string::npos)
                col = strToInt<int>(ext.substr(pos+6, ext.find_first_of("":,>"", pos+6) - (pos+6)));
        } else if (ext[0] == '<') {
            const std::string::size_type colon = ext.find(':');
            if (colon != std::string::npos) {
                const bool windowsPath = colon == 2 && ext.size() > 3 && ext[2] == ':';
                const std::string::size_type sep1 = windowsPath ? ext.find(':', 4) : colon;
                const std::string::size_type sep2 = ext....",1,1,lib/clangimport.cpp,"clangimport.AstNode.setLocations:void(TokenList&,int,int,int)",<empty>,,false,537,573,setLocations,,,1,"void(TokenList&,int,int,int)"
111669152286,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"Token *clangimport::AstNode::addtoken(TokenList &tokenList, const std::string &str, bool valueType)
{
    const Scope *scope = getNestedInScope(tokenList);
    tokenList.addtoken(str, mLine, mCol, mFile);
    tokenList.back()->scope(scope);
    if (valueType)
        setValueType(tokenList.back());
    return tokenList.back();
}",1,1,lib/clangimport.cpp,"clangimport.AstNode.addtoken:Token*(TokenList&,std.string&,bool)",<empty>,,false,575,583,addtoken,,,1,"Token*(TokenList&,std.string&,bool)"
111669152287,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"const ::Type * clangimport::AstNode::addTypeTokens(TokenList &tokenList, const std::string &str, const Scope *scope)
{
    if (str.find(""\\':\\'"") != std::string::npos) {
        return addTypeTokens(tokenList, str.substr(0, str.find(""\\':\\'"") + 1), scope);
    }

    if (startsWith(str, ""'enum (anonymous""))
        return nullptr;

    std::string type;
    if (str.find("" ("") != std::string::npos) {
        if (str.find('<') != std::string::npos)
            type = str.substr(1, str.find('<')) + ""...>"";
        else
            type = str.substr(1,str.find("" ("")-1);
    } else
        type = unquote(str);

    if (type.find(""(*)("") != std::string::npos) {
        type.erase(type.find(""(*)(""));
        type += ""*"";
    }
    if (type.find('(') != std::string::npos)
        type.erase(type.find('('));

    // TODO: put in a helper?
    std::stack<Token *> lpar;
    for (const std::string &s: splitString(type)) {
        Token *tok = addtoken(tokenList, s, false);
        if (tok->str() ...",1,1,lib/clangimport.cpp,"clangimport.AstNode.addTypeTokens:Type*(TokenList&,std.string&,Scope*)",<empty>,,false,585,638,addTypeTokens,,,1,"Type*(TokenList&,std.string&,Scope*)"
111669152288,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"void clangimport::AstNode::addFullScopeNameTokens(TokenList &tokenList, const Scope *recordScope)
{
    if (!recordScope)
        return;
    std::list<const Scope *> scopes;
    while (recordScope && recordScope != tokenList.back()->scope() && !recordScope->isExecutable()) {
        scopes.push_front(recordScope);
        recordScope = recordScope->nestedIn;
    }
    for (const Scope *s: scopes) {
        if (!s->className.empty()) {
            addtoken(tokenList, s->className);
            addtoken(tokenList, ""::"");
        }
    }
}",1,1,lib/clangimport.cpp,"clangimport.AstNode.addFullScopeNameTokens:void(TokenList&,Scope*)",<empty>,,false,640,655,addFullScopeNameTokens,,,1,"void(TokenList&,Scope*)"
111669152289,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"const Scope *clangimport::AstNode::getNestedInScope(TokenList &tokenList)
{
    if (!tokenList.back())
        return &mData->mSymbolDatabase->scopeList.front();
    if (tokenList.back()->str() == ""}"" && mData->mNotScope.find(tokenList.back()) == mData->mNotScope.end())
        return tokenList.back()->scope()->nestedIn;
    return tokenList.back()->scope();
}",1,1,lib/clangimport.cpp,clangimport.AstNode.getNestedInScope:Scope*(TokenList&),<empty>,,false,657,664,getNestedInScope,,,1,Scope*(TokenList&)
111669152290,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"void clangimport::AstNode::setValueType(Token *tok)
{
    for (int i = 0; i < 2; i++) {
        const std::string &type = getType(i);

        if (type.find('<') != std::string::npos)
            // TODO
            continue;

        TokenList decl(nullptr);
        decl.setLang(tok->isCpp() ? Standards::Language::CPP : Standards::Language::C);
        addTypeTokens(decl, type, tok->scope());
        if (!decl.front())
            break;

        ValueType valueType = ValueType::parseDecl(decl.front(), *mData->mSettings);
        if (valueType.type != ValueType::Type::UNKNOWN_TYPE) {
            tok->setValueType(new ValueType(std::move(valueType)));
            break;
        }
    }
}",1,1,lib/clangimport.cpp,clangimport.AstNode.setValueType:void(Token*),<empty>,,false,666,687,setValueType,,,1,void(Token*)
111669152291,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"Scope *clangimport::AstNode::createScope(TokenList &tokenList, ScopeType scopeType, AstNodePtr astNode, const Token *def)
{
    std::vector<AstNodePtr> children2{std::move(astNode)};
    return createScope(tokenList, scopeType, children2, def);
}",1,1,lib/clangimport.cpp,"clangimport.AstNode.createScope:Scope*(TokenList&,ScopeType,clangimport.AstNodePtr,Token*)",<empty>,,false,689,693,createScope,,,1,"Scope*(TokenList&,ScopeType,clangimport.AstNodePtr,Token*)"
111669152292,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"Scope *clangimport::AstNode::createScope(TokenList &tokenList, ScopeType scopeType, const std::vector<AstNodePtr> & children2, const Token *def)
{
    SymbolDatabase *symbolDatabase = mData->mSymbolDatabase;

    auto *nestedIn = const_cast<Scope *>(getNestedInScope(tokenList));

    symbolDatabase->scopeList.emplace_back(nullptr, nullptr, nestedIn);
    Scope *scope = &symbolDatabase->scopeList.back();
    if (scopeType == ScopeType::eEnum)
        scope->enumeratorList.reserve(children2.size());
    nestedIn->nestedList.push_back(scope);
    scope->type = scopeType;
    scope->classDef = def;
    scope->check = nestedIn->check;
    if (Token::Match(def, ""if|for|while ("")) {
        std::map<const Variable *, const Variable *> replaceVar;
        for (const Token *vartok = def->tokAt(2); vartok; vartok = vartok->next()) {
            if (!vartok->variable())
                continue;
            if (vartok->variable()->nameToken() == vartok) {
                const Variable *from =...",1,1,lib/clangimport.cpp,"clangimport.AstNode.createScope:Scope*(TokenList&,ScopeType,std.vector<AstNodePtr>&,Token*)",<empty>,,false,695,759,createScope,,,1,"Scope*(TokenList&,ScopeType,std.vector<AstNodePtr>&,Token*)"
111669152293,METHOD,<empty>,<empty>,"[&](const AstNodePtr& c) {
            return c && c->nodeType == DeclStmt && c->getChild(0)->nodeType == VarDecl;
        }",74,9,lib/clangimport.cpp,lib/clangimport.cpp:<global>.clangimport.AstNode.createTokens.<lambda>0:bool(clangimport.AstNodePtr&),<empty>,,false,910,912,<lambda>0,,,1,bool(clangimport.AstNodePtr&)
111669152294,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"Token *clangimport::AstNode::createTokens(TokenList &tokenList)
{
    if (nodeType == ArraySubscriptExpr) {
        Token *array = getChild(0)->createTokens(tokenList);
        Token *bracket1 = addtoken(tokenList, ""["");
        Token *index = children[1]->createTokens(tokenList);
        Token *bracket2 = addtoken(tokenList, ""]"");
        bracket1->astOperand1(array);
        bracket1->astOperand2(index);
        bracket1->link(bracket2);
        bracket2->link(bracket1);
        return bracket1;
    }
    if (nodeType == BinaryOperator) {
        Token *tok1 = getChild(0)->createTokens(tokenList);
        Token *binop = addtoken(tokenList, unquote(mExtTokens.back()));
        Token *tok2 = children[1]->createTokens(tokenList);
        binop->astOperand1(tok1);
        binop->astOperand2(tok2);
        return binop;
    }
    if (nodeType == BreakStmt)
        return addtoken(tokenList, ""break"");
    if (nodeType == CharacterLiteral) {
        const int c = MathLib::toBigNumber(mEx...",1,1,lib/clangimport.cpp,clangimport.AstNode.createTokens:Token*(TokenList&),<empty>,,false,761,1309,createTokens,,,1,Token*(TokenList&)
111669152295,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"Token * clangimport::AstNode::createTokensCall(TokenList &tokenList)
{
    int firstParam;
    Token *f;
    if (nodeType == CXXOperatorCallExpr) {
        firstParam = 2;
        Token *obj = getChild(1)->createTokens(tokenList);
        Token *dot = addtoken(tokenList, ""."");
        Token *op = getChild(0)->createTokens(tokenList);
        dot->astOperand1(obj);
        dot->astOperand2(op);
        f = dot;
    } else {
        firstParam = 1;
        f = getChild(0)->createTokens(tokenList);
    }
    f->setValueType(nullptr);
    Token *par1 = addtoken(tokenList, ""("");
    par1->astOperand1(f);
    std::size_t args = 0;
    while (args < children.size() && children[args]->nodeType != CXXDefaultArgExpr)
        args++;
    Token *child = nullptr;
    for (std::size_t c = firstParam; c < args; ++c) {
        if (child) {
            Token *comma = addtoken(tokenList, "","");
            comma->setValueType(nullptr);
            comma->astOperand1(child);
            comma->astOpera...",1,1,lib/clangimport.cpp,clangimport.AstNode.createTokensCall:Token*(TokenList&),<empty>,,false,1311,1350,createTokensCall,,,1,Token*(TokenList&)
111669152296,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"void clangimport::AstNode::createTokensFunctionDecl(TokenList &tokenList)
{
    const bool prev = contains(mExtTokens, ""prev"");
    const bool hasBody = !children.empty() && children.back()->nodeType == CompoundStmt;
    const bool isStatic = contains(mExtTokens, ""static"");
    const bool isInline = contains(mExtTokens, ""inline"");

    const Token *startToken = nullptr;

    SymbolDatabase *symbolDatabase = mData->mSymbolDatabase;
    if (nodeType != CXXConstructorDecl && nodeType != CXXDestructorDecl) {
        if (isStatic)
            addtoken(tokenList, ""static"");
        if (isInline)
            addtoken(tokenList, ""inline"");
        const Token * const before = tokenList.back();
        addTypeTokens(tokenList, '\\'' + getType() + '\\'');
        startToken = before ? before->next() : tokenList.front();
    }

    if (mExtTokens.size() > 4 && mExtTokens[1] == ""parent"")
        addFullScopeNameTokens(tokenList, mData->getScope(mExtTokens[2]));

    Token *nameToken = addtoken(to...",1,1,lib/clangimport.cpp,clangimport.AstNode.createTokensFunctionDecl:void(TokenList&),<empty>,,false,1352,1472,createTokensFunctionDecl,,,1,void(TokenList&)
111669152297,METHOD,<empty>,<empty>,"[](const AstNodePtr& child) {
            return child->nodeType == CXXConstructorDecl ||
            child->nodeType == CXXDestructorDecl ||
            child->nodeType == CXXMethodDecl ||
            child->nodeType == FieldDecl ||
            child->nodeType == VarDecl ||
            child->nodeType == AccessSpecDecl ||
            child->nodeType == TypedefDecl;
        }",89,9,lib/clangimport.cpp,lib/clangimport.cpp:<global>.clangimport.AstNode.createTokensForCXXRecord.<lambda>1:bool(clangimport.AstNodePtr&),<empty>,,false,1498,1506,<lambda>1,,,1,bool(clangimport.AstNodePtr&)
111669152298,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"void clangimport::AstNode::createTokensForCXXRecord(TokenList &tokenList)
{
    const bool isStruct = contains(mExtTokens, ""struct"");
    Token * const classToken = addtoken(tokenList, isStruct ? ""struct"" : ""class"");
    std::string className;
    if (mExtTokens[mExtTokens.size() - 2] == (isStruct?""struct"":""class""))
        className = mExtTokens.back();
    else
        className = mExtTokens[mExtTokens.size() - 2];
    className += getTemplateParameters();
    /*Token *nameToken =*/ addtoken(tokenList, className);
    // base classes
    bool firstBase = true;
    for (const AstNodePtr &child: children) {
        if (child->nodeType == ""public"" || child->nodeType == ""protected"" || child->nodeType == ""private"") {
            addtoken(tokenList, firstBase ? "":"" : "","");
            addtoken(tokenList, child->nodeType);
            addtoken(tokenList, unquote(child->mExtTokens.back()));
            firstBase = false;
        }
    }
    // definition
    if (isDefinition()) {
        ...",1,1,lib/clangimport.cpp,clangimport.AstNode.createTokensForCXXRecord:void(TokenList&),<empty>,,false,1474,1517,createTokensForCXXRecord,,,1,void(TokenList&)
111669152299,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"Token * clangimport::AstNode::createTokensVarDecl(TokenList &tokenList)
{
    const std::string addr = mExtTokens.front();
    if (contains(mExtTokens, ""static""))
        addtoken(tokenList, ""static"");
    int typeIndex = mExtTokens.size() - 1;
    while (typeIndex > 1 && std::isalpha(mExtTokens[typeIndex][0]))
        typeIndex--;
    const std::string type = mExtTokens[typeIndex];
    const std::string name = mExtTokens[typeIndex - 1];
    const Token *startToken = tokenList.back();
    const ::Type *recordType = addTypeTokens(tokenList, type);
    if (!startToken)
        startToken = tokenList.front();
    else if (startToken->str() != ""static"")
        startToken = startToken->next();
    Token *vartok1 = addtoken(tokenList, name);
    auto *scope = const_cast<Scope *>(tokenList.back()->scope());
    scope->varlist.emplace_back(vartok1, unquote(type), startToken, vartok1->previous(), 0, scope->defaultAccess(), recordType, scope);
    mData->varDecl(addr, vartok1, &scope->varlis...",1,1,lib/clangimport.cpp,clangimport.AstNode.createTokensVarDecl:Token*(TokenList&),<empty>,,false,1519,1558,createTokensVarDecl,,,1,Token*(TokenList&)
111669152300,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"static void setTypes(TokenList &tokenList)
{
    for (Token *tok = tokenList.front(); tok; tok = tok->next()) {
        if (Token::simpleMatch(tok, ""sizeof ("")) {
            for (Token *typeToken = tok->tokAt(2); typeToken->str() != "")""; typeToken = typeToken->next()) {
                if (typeToken->type())
                    continue;
                typeToken->type(typeToken->scope()->findType(typeToken->str()));
            }
        }
    }
}",1,1,lib/clangimport.cpp,setTypes:void(TokenList&),<empty>,,false,1560,1571,setTypes,,,1,void(TokenList&)
111669152301,METHOD,<empty>,<empty>,"[](int v, const Dimension& dim) {
                return v * dim.num;
            }",100,13,lib/clangimport.cpp,"lib/clangimport.cpp:<global>.setValues.<lambda>2:longlong(int,Dimension&)",<empty>,,false,1583,1585,<lambda>2,,,1,"longlong(int,Dimension&)"
111669152302,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"static void setValues(const Tokenizer &tokenizer, const SymbolDatabase *symbolDatabase)
{
    const Settings & settings = tokenizer.getSettings();

    for (const Scope& scope : symbolDatabase->scopeList) {
        if (!scope.definedType)
            continue;

        MathLib::bigint typeSize = 0;
        for (const Variable &var: scope.varlist) {
            const int mul = std::accumulate(var.dimensions().cbegin(), var.dimensions().cend(), 1, [](int v, const Dimension& dim) {
                return v * dim.num;
            });
            if (var.valueType())
                typeSize += mul * var.valueType()->typeSize(settings.platform, true);
        }
        scope.definedType->sizeOf = typeSize;
    }

    for (auto *tok = const_cast<Token*>(tokenizer.tokens()); tok; tok = tok->next()) {
        if (Token::simpleMatch(tok, ""sizeof ("")) {
            ValueType vt = ValueType::parseDecl(tok->tokAt(2), settings);
            const MathLib::bigint sz = vt.typeSize(settings.platfor...",1,1,lib/clangimport.cpp,"setValues:void(Tokenizer&,SymbolDatabase*)",<empty>,,false,1573,1611,setValues,,,1,"void(Tokenizer&,SymbolDatabase*)"
111669152303,METHOD,lib/clangimport.cpp:<global>,TYPE_DECL,"void clangimport::parseClangAstDump(Tokenizer &tokenizer, std::istream &f)
{
    TokenList &tokenList = tokenizer.list;

    tokenizer.createSymbolDatabase();
    auto *symbolDatabase = const_cast<SymbolDatabase *>(tokenizer.getSymbolDatabase());
    symbolDatabase->scopeList.emplace_back(nullptr, nullptr, nullptr);
    symbolDatabase->scopeList.back().type = ScopeType::eGlobal;
    symbolDatabase->scopeList.back().check = symbolDatabase;

    clangimport::Data data;
    data.mSettings = &tokenizer.getSettings();
    data.mSymbolDatabase = symbolDatabase;
    std::string line;
    std::vector<AstNodePtr> tree;
    while (std::getline(f,line)) {
        const std::string::size_type pos1 = line.find('-');
        if (pos1 == std::string::npos)
            continue;
        if (!tree.empty() && line.substr(pos1) == ""-<<<NULL>>>"") {
            const int level = (pos1 - 1) / 2;
            tree[level - 1]->children.push_back(nullptr);
            continue;
        }
        const std::s...",1,1,lib/clangimport.cpp,"clangimport.parseClangAstDump:void(Tokenizer&,std.istream&)",<empty>,,false,1613,1679,parseClangAstDump,,,1,"void(Tokenizer&,std.istream&)"
111669152304,METHOD,lib/clangimport.h:<global>,TYPE_DECL,<global>,1,1,lib/clangimport.h,lib/clangimport.h:<global>,<empty>,,false,1,35,<global>,,,1,
111669152305,METHOD,lib/color.cpp:<global>,TYPE_DECL,"static bool isStreamATty(const std::ostream & os)
{
    static const bool stdout_tty = isatty(STDOUT_FILENO);
    static const bool stderr_tty = isatty(STDERR_FILENO);
    if (&os == &std::cout)
        return stdout_tty;
    if (&os == &std::cerr)
        return stderr_tty;
    return (stdout_tty && stderr_tty);
}",1,1,lib/color.cpp,isStreamATty:bool(std.ostream&),<empty>,,false,32,41,isStreamATty,,,1,bool(std.ostream&)
111669152306,METHOD,lib/color.cpp:<global>,TYPE_DECL,<global>,1,1,lib/color.cpp,lib/color.cpp:<global>,<empty>,,false,1,78,<global>,,,1,
111669152307,METHOD,lib/color.cpp:<global>,TYPE_DECL,"static bool isColorEnabled(const std::ostream & os)
{
    // See https://bixense.com/clicolors/
    static const bool color_forced_off = (nullptr != std::getenv(""NO_COLOR""));
    if (color_forced_off)
    {
        return false;
    }
    static const bool color_forced_on = (nullptr != std::getenv(""CLICOLOR_FORCE""));
    if (color_forced_on)
    {
        return true;
    }
#ifdef _WIN32
    (void)os;
    return false;
#else
    return isStreamATty(os);
#endif
}",1,1,lib/color.cpp,isColorEnabled:bool(std.ostream&),<empty>,,false,44,63,isColorEnabled,,,1,bool(std.ostream&)
111669152308,METHOD,lib/color.cpp:<global>,TYPE_DECL,"std::ostream& operator<<(std::ostream & os, Color c)
{
    if (!gDisableColors && isColorEnabled(os))
        return os << ""\\033["" << static_cast<std::size_t>(c) << ""m"";

    return os;
}",1,1,lib/color.cpp,"<<:ostream(std.ostream&,Color)",<empty>,,false,65,71,<<,,,1,"ostream(std.ostream&,Color)"
111669152309,METHOD,lib/color.cpp:<global>,TYPE_DECL,"std::string toString(Color c)
{
    std::ostringstream ss;
    ss << c;
    return ss.str();
}",1,1,lib/color.cpp,toString:string(Color),<empty>,,false,73,78,toString,,,1,string(Color)
111669152310,METHOD,lib/color.h:<global>,TYPE_DECL,<global>,1,1,lib/color.h,lib/color.h:<global>,<empty>,,false,1,44,<global>,,,1,
111669152311,METHOD,lib/config.h:<global>,TYPE_DECL,<global>,1,4,lib/config.h,lib/config.h:<global>,<empty>,,false,1,223,<global>,,,1,
111669152312,METHOD,CppCheck.CppCheckLogger,TYPE_DECL,"CppCheckLogger(ErrorLogger& errorLogger, const Settings& settings, Suppressions& suppressions, bool useGlobalSuppressions)
        : mErrorLogger(errorLogger)
        , mSettings(settings)
        , mSuppressions(suppressions)
        , mUseGlobalSuppressions(useGlobalSuppressions)
    {}",5,6,lib/cppcheck.cpp,"CppCheck.CppCheckLogger.CppCheckLogger:ANY(ErrorLogger&,Settings&,Suppressions&,bool)",<empty>,,false,95,100,CppCheckLogger,,,1,"CppCheck.CppCheckLogger.CppCheckLogger:ANY(ErrorLogger&,Settings&,Suppressions&,bool)(ErrorLogger&,Settings&,Suppressions&,bool)"
111669152313,METHOD,CppCheck.CppCheckLogger,TYPE_DECL,"~CppCheckLogger() override
    {
        closePlist();
    }",5,5,lib/cppcheck.cpp,CppCheck.CppCheckLogger.~CppCheckLogger:ANY(),<empty>,,false,102,105,~CppCheckLogger,,,2,ANY()
111669152314,METHOD,CppCheck.CppCheckLogger,TYPE_DECL,"void setRemarkComments(std::vector<RemarkComment> remarkComments)
    {
        mRemarkComments = std::move(remarkComments);
    }",5,5,lib/cppcheck.cpp,CppCheck.CppCheckLogger.setRemarkComments:void(std.vector<RemarkComment>),<empty>,,false,107,110,setRemarkComments,,,3,void(std.vector<RemarkComment>)
111669152315,METHOD,CppCheck.CppCheckLogger,TYPE_DECL,"void setLocationMacros(const Token* startTok, const std::vector<std::string>& files)
    {
        mLocationMacros.clear();
        for (const Token* tok = startTok; tok; tok = tok->next()) {
            if (!tok->getMacroName().empty())
                mLocationMacros[Location(files[tok->fileIndex()], tok->linenr())].emplace(tok->getMacroName());
        }
    }",5,5,lib/cppcheck.cpp,"CppCheck.CppCheckLogger.setLocationMacros:void(Token*,std.vector<std.string>&)",<empty>,,false,112,119,setLocationMacros,,,4,"void(Token*,std.vector<std.string>&)"
111669152316,METHOD,CppCheck.CppCheckLogger,TYPE_DECL,"void resetExitCode()
    {
        mExitCode = 0;
    }",5,5,lib/cppcheck.cpp,CppCheck.CppCheckLogger.resetExitCode:void(),<empty>,,false,121,124,resetExitCode,,,5,void()
111669152317,METHOD,CppCheck.CppCheckLogger,TYPE_DECL,"void clear()
    {
        mErrorList.clear();
    }",5,5,lib/cppcheck.cpp,CppCheck.CppCheckLogger.clear:void(),<empty>,,false,126,129,clear,,,6,void()
111669152318,METHOD,CppCheck.CppCheckLogger,TYPE_DECL,"void openPlist(const std::string& filename, const std::vector<std::string>& files)
    {
        mPlistFile.open(filename);
        mPlistFile << ErrorLogger::plistHeader(version(), files);
    }",5,5,lib/cppcheck.cpp,"CppCheck.CppCheckLogger.openPlist:void(std.string&,std.vector<std.string>&)",<empty>,,false,131,135,openPlist,,,7,"void(std.string&,std.vector<std.string>&)"
111669152319,METHOD,CppCheck.CppCheckLogger,TYPE_DECL,"void closePlist()
    {
        if (mPlistFile.is_open()) {
            mPlistFile << ErrorLogger::plistFooter();
            mPlistFile.close();
        }
    }",5,5,lib/cppcheck.cpp,CppCheck.CppCheckLogger.closePlist:void(),<empty>,,false,137,143,closePlist,,,8,void()
111669152320,METHOD,CppCheck.CppCheckLogger,TYPE_DECL,"unsigned int exitcode() const
    {
        return mExitCode;
    }",5,5,lib/cppcheck.cpp,CppCheck.CppCheckLogger.exitcode<const>:unsigned int(),<empty>,,false,145,148,exitcode,,,9,unsigned int()
111669152321,METHOD,CppCheck.CppCheckLogger,TYPE_DECL,"void setAnalyzerInfo(AnalyzerInformation* info)
    {
        mAnalyzerInformation = info;
    }",5,5,lib/cppcheck.cpp,CppCheck.CppCheckLogger.setAnalyzerInfo:void(AnalyzerInformation*),<empty>,,false,150,153,setAnalyzerInfo,,,10,void(AnalyzerInformation*)
111669152322,METHOD,CppCheck.CppCheckLogger,TYPE_DECL,"void reportErr(const ErrorMessage &msg) override
    {
        if (msg.severity == Severity::internal) {
            mErrorLogger.reportErr(msg);
            return;
        }

        if (!mSettings.library.reportErrors(msg.file0))
            return;

        std::set<std::string> macroNames;
        if (!msg.callStack.empty()) {
            const std::string &file = msg.callStack.back().getfile(false);
            int lineNumber = msg.callStack.back().line;
            const auto it = mLocationMacros.find(Location(file, lineNumber));
            if (it != mLocationMacros.cend())
                macroNames = it->second;
        }

        // TODO: only convert if necessary
        const auto errorMessage = SuppressionList::ErrorMessage::fromErrorMessage(msg, macroNames);

        if (mSuppressions.nomsg.isSuppressed(errorMessage, mUseGlobalSuppressions)) {
            // Safety: Report critical errors to ErrorLogger
            if (mSettings.safety && ErrorLogger::isCriticalErrorI...",5,5,lib/cppcheck.cpp,CppCheck.CppCheckLogger.reportErr:void(ErrorMessage&),<empty>,,false,164,248,reportErr,,,11,void(ErrorMessage&)
111669152323,METHOD,CppCheck.CppCheckLogger,TYPE_DECL,"void reportOut(const std::string &outmsg, Color c = Color::Reset) override
    {
        mErrorLogger.reportOut(outmsg, c);
    }",5,5,lib/cppcheck.cpp,"CppCheck.CppCheckLogger.reportOut:void(std.string&,Color)",<empty>,,false,255,258,reportOut,,,12,"void(std.string&,Color)"
111669152324,METHOD,CppCheck.CppCheckLogger,TYPE_DECL,"void reportProgress(const std::string &filename, const char stage[], const std::size_t value) override
    {
        mErrorLogger.reportProgress(filename, stage, value);
    }",5,5,lib/cppcheck.cpp,"CppCheck.CppCheckLogger.reportProgress:void(std.string&,char[],std.size_t)",<empty>,,false,260,263,reportProgress,,,13,"void(std.string&,char[],std.size_t)"
111669152325,METHOD,<empty>,<empty>,<empty>,1,,lib/cppcheck.cpp,CppCheck.CppCheckLogger.<clinit>,<empty>,,false,92,,<clinit>,,,25,
111669152326,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,<global>,1,1,lib/cppcheck.cpp,lib/cppcheck.cpp:<global>,<empty>,,false,1,2115,<global>,,,1,
111669152327,METHOD,FilesDeleter,TYPE_DECL,FilesDeleter() = default;,9,33,lib/cppcheck.cpp,FilesDeleter.FilesDeleter:ANY(),<empty>,,false,290,290,FilesDeleter,,,1,ANY()
111669152328,METHOD,FilesDeleter,TYPE_DECL,"~FilesDeleter() {
            for (const std::string& fileName: mFilenames)
                std::remove(fileName.c_str());
        }",9,9,lib/cppcheck.cpp,FilesDeleter.~FilesDeleter:ANY(),<empty>,,false,291,294,~FilesDeleter,,,2,ANY()
111669152329,METHOD,FilesDeleter,TYPE_DECL,"void addFile(const std::string& fileName) {
            mFilenames.push_back(fileName);
        }",9,9,lib/cppcheck.cpp,FilesDeleter.addFile:void(std.string&),<empty>,,false,295,297,addFile,,,3,void(std.string&)
111669152330,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"static std::string cmdFileName(std::string f)
{
    f = Path::toNativeSeparators(std::move(f));
    if (f.find(' ') != std::string::npos)
        return ""\\"""" + f + ""\\"""";
    return f;
}",1,1,lib/cppcheck.cpp,cmdFileName:string(std.string),<empty>,,false,303,309,cmdFileName,,,1,string(std.string)
111669152331,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"static std::vector<std::string> split(const std::string &str, const std::string &sep="" "")
{
    std::vector<std::string> ret;
    for (std::string::size_type startPos = 0U; startPos < str.size();) {
        startPos = str.find_first_not_of(sep, startPos);
        if (startPos == std::string::npos)
            break;

        if (str[startPos] == '\\""') {
            const std::string::size_type endPos = str.find('\\""', startPos + 1);
            ret.push_back(str.substr(startPos + 1, endPos - startPos - 1));
            startPos = (endPos < str.size()) ? (endPos + 1) : endPos;
            continue;
        }

        const std::string::size_type endPos = str.find(sep, startPos + 1);
        ret.push_back(str.substr(startPos, endPos - startPos));
        startPos = endPos;
    }

    return ret;
}",1,1,lib/cppcheck.cpp,"split:vector<std.string>(std.string&,std.string&)",<empty>,,false,311,332,split,,,1,"vector<std::string>(std.string&,std.string&)"
111669152332,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"static std::string getDumpFileName(const Settings& settings, const std::string& filename)
{
    std::string extension;
    if (settings.dump || !settings.buildDir.empty())
        extension = "".dump"";
    else
        extension = ""."" + std::to_string(settings.pid) + "".dump"";

    if (!settings.dump && !settings.buildDir.empty())
        return AnalyzerInformation::getAnalyzerInfoFile(settings.buildDir, filename, """") + extension;
    return filename + extension;
}",1,1,lib/cppcheck.cpp,"getDumpFileName:string(Settings&,std.string&)",<empty>,,false,334,345,getDumpFileName,,,1,"string(Settings&,std.string&)"
111669152333,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"static std::string getCtuInfoFileName(const std::string &dumpFile)
{
    return dumpFile.substr(0, dumpFile.size()-4) + ""ctu-info"";
}",1,1,lib/cppcheck.cpp,getCtuInfoFileName:string(std.string&),<empty>,,false,347,350,getCtuInfoFileName,,,1,string(std.string&)
111669152334,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"static void createDumpFile(const Settings& settings,
                           const FileWithDetails& file,
                           std::ofstream& fdump,
                           std::string& dumpFile)
{
    if (!settings.dump && settings.addons.empty())
        return;
    dumpFile = getDumpFileName(settings, file.spath());

    fdump.open(dumpFile);
    if (!fdump.is_open())
        return;

    if (!settings.buildDir.empty()) {
        std::ofstream fout(getCtuInfoFileName(dumpFile));
    }

    // TODO: enforcedLang should be already applied in FileWithDetails object
    std::string language;
    switch (settings.enforcedLang) {
    case Standards::Language::C:
        language = "" language=\\""c\\"""";
        break;
    case Standards::Language::CPP:
        language = "" language=\\""cpp\\"""";
        break;
    case Standards::Language::None:
    {
        // TODO: get language from FileWithDetails object
        // TODO: error out on unknown language?
        const Standards::L...",1,1,lib/cppcheck.cpp,"createDumpFile:void(Settings&,FileWithDetails&,std.ofstream&,std.string&)",<empty>,,false,352,404,createDumpFile,,,1,"void(Settings&,FileWithDetails&,std.ofstream&,std.string&)"
111669152335,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"static std::string detectPython(const CppCheck::ExecuteCmdFn &executeCommand)
{
#ifdef _WIN32
    const char *py_exes[] = { ""python3.exe"", ""python.exe"" };
#else
    const char *py_exes[] = { ""python3"", ""python"" };
#endif
    for (const char* py_exe : py_exes) {
        std::string out;
#ifdef _MSC_VER
        // FIXME: hack to avoid debug assertion with _popen() in executeCommand() for non-existing commands
        const std::string cmd = std::string(py_exe) + "" --version >NUL 2>&1"";
        if (system(cmd.c_str()) != 0) {
            // TODO: get more detailed error?
            continue;
        }
#endif
        if (executeCommand(py_exe, split(""--version""), ""2>&1"", out) == EXIT_SUCCESS && startsWith(out, ""Python "") && std::isdigit(out[7])) {
            return py_exe;
        }
    }
    return """";
}",1,1,lib/cppcheck.cpp,detectPython:string(CppCheck.ExecuteCmdFn&),<empty>,,false,406,428,detectPython,,,1,string(CppCheck.ExecuteCmdFn&)
111669152336,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"static std::vector<picojson::value> executeAddon(const AddonInfo &addonInfo,
                                                 const std::string &defaultPythonExe,
                                                 const std::string &file,
                                                 const std::string &premiumArgs,
                                                 const CppCheck::ExecuteCmdFn &executeCommand)
{
    std::string pythonExe;

    if (!addonInfo.executable.empty())
        pythonExe = addonInfo.executable;
    else if (!addonInfo.python.empty())
        pythonExe = cmdFileName(addonInfo.python);
    else if (!defaultPythonExe.empty())
        pythonExe = cmdFileName(defaultPythonExe);
    else {
        // store in static variable so we only look this up once
        static const std::string detectedPythonExe = detectPython(executeCommand);
        if (detectedPythonExe.empty())
            throw InternalError(nullptr, ""Failed to auto detect python"");
        pythonExe =...",1,1,lib/cppcheck.cpp,"executeAddon:vector<picojson.value>(AddonInfo&,std.string&,std.string&,std.string&,CppCheck.ExecuteCmdFn&)",<empty>,,false,430,520,executeAddon,,,1,"vector<picojson::value>(AddonInfo&,std.string&,std.string&,std.string&,CppCheck.ExecuteCmdFn&)"
111669152337,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"static std::string getDefinesFlags(const std::string &semicolonSeparatedString)
{
    std::string flags;
    for (const std::string &d: split(semicolonSeparatedString, "";""))
        flags += ""-D"" + d + "" "";
    return flags;
}",1,1,lib/cppcheck.cpp,getDefinesFlags:string(std.string&),<empty>,,false,522,528,getDefinesFlags,,,1,string(std.string&)
111669152338,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"CppCheck::CppCheck(const Settings& settings,
                   Suppressions& supprs,
                   ErrorLogger &errorLogger,
                   bool useGlobalSuppressions,
                   ExecuteCmdFn executeCommand)
    : mSettings(settings)
    , mSuppressions(supprs)
    , mLogger(new CppCheckLogger(errorLogger, mSettings, mSuppressions, useGlobalSuppressions))
    , mErrorLogger(*mLogger)
    , mErrorLoggerDirect(errorLogger)
    , mUseGlobalSuppressions(useGlobalSuppressions)
    , mExecuteCommand(std::move(executeCommand))
{}",1,2,lib/cppcheck.cpp,"CppCheck.CppCheck:ANY(Settings&,Suppressions&,ErrorLogger&,bool,CppCheck.ExecuteCmdFn)",<empty>,,false,530,542,CppCheck,,,1,"CppCheck.CppCheck:ANY(Settings&,Suppressions&,ErrorLogger&,bool,CppCheck.ExecuteCmdFn)(Settings&,Suppressions&,ErrorLogger&,bool,CppCheck.ExecuteCmdFn)"
111669152339,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"CppCheck::~CppCheck()
{
    mLogger->setAnalyzerInfo(nullptr);

    while (!mFileInfo.empty()) {
        delete mFileInfo.back();
        mFileInfo.pop_back();
    }
}",1,1,lib/cppcheck.cpp,CppCheck.~CppCheck:ANY(),<empty>,,false,544,552,~CppCheck,,,1,ANY()
111669152340,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"const char * CppCheck::version()
{
    return Version;
}",1,1,lib/cppcheck.cpp,CppCheck.version:char*(),<empty>,,false,554,557,version,,,1,char*()
111669152341,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"const char * CppCheck::extraVersion()
{
    return ExtraVersion;
}",1,1,lib/cppcheck.cpp,CppCheck.extraVersion:char*(),<empty>,,false,559,562,extraVersion,,,1,char*()
111669152342,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"static bool reportClangErrors(std::istream &is, const std::function<void(const ErrorMessage&)>& reportErr, std::vector<ErrorMessage> &warnings)
{
    std::string line;
    while (std::getline(is, line)) {
        if (line.empty() || line[0] == ' ' || line[0] == '`' || line[0] == '-')
            continue;

        std::string::size_type pos3 = line.find("": error: "");
        if (pos3 == std::string::npos)
            pos3 = line.find("": fatal error:"");
        if (pos3 == std::string::npos)
            pos3 = line.find("": warning:"");
        if (pos3 == std::string::npos)
            continue;

        // file:line:column: error: ....
        const std::string::size_type pos2 = line.rfind(':', pos3 - 1);
        const std::string::size_type pos1 = line.rfind(':', pos2 - 1);

        if (pos1 >= pos2 || pos2 >= pos3)
            continue;

        std::string filename = line.substr(0, pos1);
        const std::string linenr = line.substr(pos1+1, pos2-pos1-1);
        const std::strin...",1,1,lib/cppcheck.cpp,"reportClangErrors:bool(std.istream&,std.function<void(constErrorMessage&)>&,std.vector<ErrorMessage>&)",<empty>,,false,564,612,reportClangErrors,,,1,"bool(std.istream&,std.function<void(constErrorMessage&)>&,std.vector<ErrorMessage>&)"
111669152343,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"std::string CppCheck::getLibraryDumpData() const {
    std::string out;
    for (const std::string &s : mSettings.libraries) {
        out += ""  <library lib=\\"""" + s + ""\\""/>\\n"";
    }
    return out;
}",1,1,lib/cppcheck.cpp,CppCheck.getLibraryDumpData<const>:string(),<empty>,,false,614,620,getLibraryDumpData,,,1,string()
111669152344,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"std::string CppCheck::getClangFlags(Standards::Language fileLang) const {
    std::string flags;

    const Standards::Language lang = mSettings.enforcedLang != Standards::None ? mSettings.enforcedLang : fileLang;

    switch (lang) {
    case Standards::Language::None:
    case Standards::Language::C:
        flags = ""-x c "";
        if (!mSettings.standards.stdValueC.empty())
            flags += ""-std="" + mSettings.standards.stdValueC + "" "";
        break;
    case Standards::Language::CPP:
        flags += ""-x c++ "";
        if (!mSettings.standards.stdValueCPP.empty())
            flags += ""-std="" + mSettings.standards.stdValueCPP + "" "";
        break;
    }

    for (const std::string &i: mSettings.includePaths)
        flags += ""-I"" + i + "" "";

    flags += getDefinesFlags(mSettings.userDefines);

    for (const std::string &i: mSettings.userIncludes)
        flags += ""--include "" + cmdFileName(i) + "" "";

    return flags;
}",1,1,lib/cppcheck.cpp,CppCheck.getClangFlags<const>:string(Standards.Language),<empty>,,false,622,650,getClangFlags,,,1,string(Standards.Language)
111669152345,METHOD,<empty>,<empty>,"[this](const ErrorMessage& errorMessage) {
        mErrorLogger.reportErr(errorMessage);
    }",30,5,lib/cppcheck.cpp,lib/cppcheck.cpp:<global>.CppCheck.checkClang.<lambda>0:void(ErrorMessage&),<empty>,,false,702,704,<lambda>0,,,1,void(ErrorMessage&)
111669152346,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"unsigned int CppCheck::checkClang(const FileWithDetails &file)
{
    // TODO: clear exitcode

    if (mSettings.checks.isEnabled(Checks::unusedFunction) && !mUnusedFunctionsCheck)
        mUnusedFunctionsCheck.reset(new CheckUnusedFunctions());

    if (!mSettings.quiet)
        mErrorLogger.reportOut(std::string(""Checking "") + file.spath() + "" ..."", Color::FgGreen);

    // TODO: get language from FileWithDetails object
    std::string clangStderr;
    if (!mSettings.buildDir.empty())
        clangStderr = AnalyzerInformation::getAnalyzerInfoFile(mSettings.buildDir, file.spath(), """") + "".clang-stderr"";

    std::string exe = mSettings.clangExecutable;
#ifdef _WIN32
    // append .exe if it is not a path
    if (Path::fromNativeSeparators(mSettings.clangExecutable).find('/') == std::string::npos) {
        exe += "".exe"";
    }
#endif

    const std::string args2 = ""-fsyntax-only -Xclang -ast-dump -fno-color-diagnostics "" +
                              getClangFlags(Path::identify(f...",1,1,lib/cppcheck.cpp,CppCheck.checkClang:unsigned int(FileWithDetails&),<empty>,,false,653,765,checkClang,,,1,unsigned int(FileWithDetails&)
111669152347,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"unsigned int CppCheck::check(const FileWithDetails &file)
{
    if (mSettings.clang)
        return checkClang(file);

    return checkFile(file, """");
}",1,1,lib/cppcheck.cpp,CppCheck.check:unsigned int(FileWithDetails&),<empty>,,false,767,773,check,,,1,unsigned int(FileWithDetails&)
111669152348,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"unsigned int CppCheck::check(const FileWithDetails &file, const std::string &content)
{
    std::istringstream iss(content);
    return checkFile(file, """", &iss);
}",1,1,lib/cppcheck.cpp,"CppCheck.check:unsigned int(FileWithDetails&,std.string&)",<empty>,,false,775,779,check,,,1,"unsigned int(FileWithDetails&,std.string&)"
111669152349,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"unsigned int CppCheck::check(const FileSettings &fs)
{
    // TODO: move to constructor when CppCheck no longer owns the settings
    if (mSettings.checks.isEnabled(Checks::unusedFunction) && !mUnusedFunctionsCheck)
        mUnusedFunctionsCheck.reset(new CheckUnusedFunctions());

    Settings tempSettings = mSettings; // this is a copy
    if (!tempSettings.userDefines.empty())
        tempSettings.userDefines += ';';
    if (mSettings.clang)
        tempSettings.userDefines += fs.defines;
    else
        tempSettings.userDefines += fs.cppcheckDefines();
    tempSettings.includePaths = fs.includePaths;
    tempSettings.userUndefs.insert(fs.undefs.cbegin(), fs.undefs.cend());
    if (fs.standard.find(""++"") != std::string::npos)
        tempSettings.standards.setCPP(fs.standard);
    else if (!fs.standard.empty())
        tempSettings.standards.setC(fs.standard);
    if (fs.platformType != Platform::Type::Unspecified)
        tempSettings.platform.set(fs.platformType);
    if (mSett...",1,1,lib/cppcheck.cpp,CppCheck.check:unsigned int(FileSettings&),<empty>,,false,781,823,check,,,1,unsigned int(FileSettings&)
111669152350,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"static simplecpp::TokenList createTokenList(const std::string& filename, std::vector<std::string>& files, simplecpp::OutputList* outputList, std::istream* fileStream)
{
    if (fileStream)
        return {*fileStream, files, filename, outputList};

    return {filename, files, outputList};
}",1,1,lib/cppcheck.cpp,"createTokenList:simplecpp.TokenList(std.string&,std.vector<std.string>&,simplecpp.OutputList*,std.istream*)",<empty>,,false,825,831,createTokenList,,,1,"simplecpp.TokenList(std.string&,std.vector<std.string>&,simplecpp.OutputList*,std.istream*)"
111669152351,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"static std::size_t calculateHash(const Preprocessor& preprocessor, const simplecpp::TokenList& tokens, const Settings& settings, const Suppressions& supprs)
{
    std::ostringstream toolinfo;
    toolinfo << (settings.cppcheckCfgProductName.empty() ? CPPCHECK_VERSION_STRING : settings.cppcheckCfgProductName);
    toolinfo << (settings.severity.isEnabled(Severity::warning) ? 'w' : ' ');
    toolinfo << (settings.severity.isEnabled(Severity::style) ? 's' : ' ');
    toolinfo << (settings.severity.isEnabled(Severity::performance) ? 'p' : ' ');
    toolinfo << (settings.severity.isEnabled(Severity::portability) ? 'p' : ' ');
    toolinfo << (settings.severity.isEnabled(Severity::information) ? 'i' : ' ');
    toolinfo << settings.userDefines;
    toolinfo << std::to_string(static_cast<std::uint8_t>(settings.checkLevel));
    // TODO: do we need to add more options?
    supprs.nomsg.dump(toolinfo);
    return preprocessor.calculateHash(tokens, toolinfo.str());
}",1,59,lib/cppcheck.cpp,"calculateHash:size_t(Preprocessor&,simplecpp.TokenList&,Settings&,Suppressions&)",<empty>,,false,833,847,calculateHash,,,1,"size_t(Preprocessor&,simplecpp.TokenList&,Settings&,Suppressions&)"
111669152352,METHOD,<empty>,<empty>,"[](const simplecpp::Output &output){
            return Preprocessor::hasErrors(output);
        }",85,9,lib/cppcheck.cpp,lib/cppcheck.cpp:<global>.CppCheck.checkFile.<lambda>1:bool(simplecpp.Output&),<empty>,,false,939,941,<lambda>1,,,1,bool(simplecpp.Output&)
111669152353,METHOD,<empty>,<empty>,"[&]() {
                configurations = preprocessor.getConfigs(tokens1);
            }",89,13,lib/cppcheck.cpp,lib/cppcheck.cpp:<global>.CppCheck.checkFile.<lambda>2:void(),<empty>,,false,1019,1021,<lambda>2,,,1,void()
111669152354,METHOD,<empty>,<empty>,"[&]() {
                    codeWithoutCfg = preprocessor.getcode(tokens1, mCurrentConfig, files, true);
                }",90,17,lib/cppcheck.cpp,lib/cppcheck.cpp:<global>.CppCheck.checkFile.<lambda>3:void(),<empty>,,false,1100,1102,<lambda>3,,,1,void()
111669152355,METHOD,<empty>,<empty>,"[&]() {
                    simplecpp::TokenList tokensP = preprocessor.preprocess(tokens1, mCurrentConfig, files, true);
                    tokenizer.list.createTokens(std::move(tokensP));
                }",92,17,lib/cppcheck.cpp,lib/cppcheck.cpp:<global>.CppCheck.checkFile.<lambda>4:void(),<empty>,,false,1126,1129,<lambda>4,,,1,void()
111669152356,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"unsigned int CppCheck::checkFile(const FileWithDetails& file, const std::string &cfgname, std::istream* fileStream)
{
    // TODO: move to constructor when CppCheck no longer owns the settings
    if (mSettings.checks.isEnabled(Checks::unusedFunction) && !mUnusedFunctionsCheck)
        mUnusedFunctionsCheck.reset(new CheckUnusedFunctions());

    mLogger->resetExitCode();

    if (Settings::terminated())
        return mLogger->exitcode();

    const Timer fileTotalTimer(mSettings.showtime == SHOWTIME_MODES::SHOWTIME_FILE_TOTAL, file.spath());

    if (!mSettings.quiet) {
        std::string fixedpath = Path::toNativeSeparators(file.spath());
        mErrorLogger.reportOut(std::string(""Checking "") + fixedpath + ' ' + cfgname + std::string(""...""), Color::FgGreen);

        if (mSettings.verbose) {
            mErrorLogger.reportOut(""Defines:"" + mSettings.userDefines, Color::Reset);
            std::string undefs;
            for (const std::string& U : mSettings.userUndefs) {
       ...",1,1,lib/cppcheck.cpp,"CppCheck.checkFile:unsigned int(FileWithDetails&,std.string&,std.istream*)",<empty>,,false,849,1284,checkFile,,,1,"unsigned int(FileWithDetails&,std.string&,std.istream*)"
111669152357,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"void CppCheck::internalError(const std::string &filename, const std::string &msg)
{
    const std::string fullmsg(""Bailing out from analysis: "" + msg);

    ErrorMessage::FileLocation loc1(filename, 0, 0);

    ErrorMessage errmsg({std::move(loc1)},
                        """",
                        Severity::error,
                        fullmsg,
                        ""internalError"",
                        Certainty::normal);

    mErrorLogger.reportErr(errmsg);
}",1,1,lib/cppcheck.cpp,"CppCheck.internalError:void(std.string&,std.string&)",<empty>,,false,1287,1301,internalError,,,1,"void(std.string&,std.string&)"
111669152358,METHOD,<empty>,<empty>,"[&]() {
                check->runChecks(tokenizer, &mErrorLogger);
            }",92,13,lib/cppcheck.cpp,lib/cppcheck.cpp:<global>.CppCheck.checkNormalTokens.<lambda>5:void(),<empty>,,false,1339,1341,<lambda>5,,,1,void()
111669152359,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"void CppCheck::checkNormalTokens(const Tokenizer &tokenizer, AnalyzerInformation* analyzerInformation)
{
    CheckUnusedFunctions unusedFunctionsChecker;

    // TODO: this should actually be the behavior if only ""--enable=unusedFunction"" is specified - see #10648
    // TODO: log message when this is active?
    const char* unusedFunctionOnly = std::getenv(""UNUSEDFUNCTION_ONLY"");
    const bool doUnusedFunctionOnly = unusedFunctionOnly && (std::strcmp(unusedFunctionOnly, ""1"") == 0);

    if (!doUnusedFunctionOnly) {
        const std::time_t maxTime = mSettings.checksMaxTime > 0 ? std::time(nullptr) + mSettings.checksMaxTime : 0;

        // call all ""runChecks"" in all registered Check classes
        // cppcheck-suppress shadowFunction - TODO: fix this
        for (Check *check : Check::instances()) {
            if (Settings::terminated())
                return;

            if (maxTime > 0 && std::time(nullptr) > maxTime) {
                if (mSettings.debugwarnings) {
       ...",1,1,lib/cppcheck.cpp,"CppCheck.checkNormalTokens:void(Tokenizer&,AnalyzerInformation*)",<empty>,,false,1307,1391,checkNormalTokens,,,1,"void(Tokenizer&,AnalyzerInformation*)"
111669152360,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"bool CppCheck::hasRule(const std::string &tokenlist) const
{
    return std::any_of(mSettings.rules.cbegin(), mSettings.rules.cend(), [&](const Settings::Rule& rule) {
        return rule.tokenlist == tokenlist;
    });
}",1,1,lib/cppcheck.cpp,CppCheck.hasRule<const>:bool(std.string&),<empty>,,false,1396,1401,hasRule,,,1,bool(std.string&)
111669152361,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"static const char * pcreErrorCodeToString(const int pcreExecRet)
{
    switch (pcreExecRet) {
    case PCRE_ERROR_NULL:
        return ""Either code or subject was passed as NULL, or ovector was NULL ""
               ""and ovecsize was not zero (PCRE_ERROR_NULL)"";
    case PCRE_ERROR_BADOPTION:
        return ""An unrecognized bit was set in the options argument (PCRE_ERROR_BADOPTION)"";
    case PCRE_ERROR_BADMAGIC:
        return ""PCRE stores a 4-byte \\""magic number\\"" at the start of the compiled code, ""
               ""to catch the case when it is passed a junk pointer and to detect when a ""
               ""pattern that was compiled in an environment of one endianness is run in ""
               ""an environment with the other endianness. This is the error that PCRE ""
               ""gives when the magic number is not present (PCRE_ERROR_BADMAGIC)"";
    case PCRE_ERROR_UNKNOWN_NODE:
        return ""While running the pattern match, an unknown item was encountered in the ""
              ...",1,1,lib/cppcheck.cpp,pcreErrorCodeToString:char*(int),<empty>,,false,1403,1530,pcreErrorCodeToString,,,1,char*(int)
111669152362,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"void CppCheck::executeRules(const std::string &tokenlist, const TokenList &list)
{
    // There is no rule to execute
    if (!hasRule(tokenlist))
        return;

    // Write all tokens in a string that can be parsed by pcre
    std::string str;
    for (const Token *tok = list.front(); tok; tok = tok->next()) {
        str += "" "";
        str += tok->str();
    }

    for (const Settings::Rule &rule : mSettings.rules) {
        if (rule.tokenlist != tokenlist)
            continue;

        if (!mSettings.quiet) {
            mErrorLogger.reportOut(""Processing rule: "" + rule.pattern, Color::FgGreen);
        }

        const char *pcreCompileErrorStr = nullptr;
        int erroffset = 0;
        pcre * const re = pcre_compile(rule.pattern.c_str(),0,&pcreCompileErrorStr,&erroffset,nullptr);
        if (!re) {
            if (pcreCompileErrorStr) {
                const std::string msg = ""pcre_compile failed: "" + std::string(pcreCompileErrorStr);
                const ErrorMessage ...",1,1,lib/cppcheck.cpp,"CppCheck.executeRules:void(std.string&,TokenList&)",<empty>,,false,1532,1658,executeRules,,,1,"void(std.string&,TokenList&)"
111669152363,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"void CppCheck::executeAddons(const std::string& dumpFile, const FileWithDetails& file)
{
    if (!dumpFile.empty()) {
        std::vector<std::string> f{dumpFile};
        executeAddons(f, file.spath());
    }
}",1,1,lib/cppcheck.cpp,"CppCheck.executeAddons:void(std.string&,FileWithDetails&)",<empty>,,false,1661,1667,executeAddons,,,1,"void(std.string&,FileWithDetails&)"
111669152364,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"void CppCheck::executeAddons(const std::vector<std::string>& files, const std::string& file0)
{
    if (mSettings.addons.empty() || files.empty())
        return;

    const bool isCtuInfo = endsWith(files[0], "".ctu-info"");

    FilesDeleter filesDeleter;
    std::string fileList;

    if (files.size() >= 2) {
        fileList = Path::getPathFromFilename(files[0]) + FILELIST + (""-"" + std::to_string(mSettings.pid)) + "".txt"";
        std::ofstream fout(fileList);
        filesDeleter.addFile(fileList);
        // TODO: check if file could be created
        for (const std::string& f: files)
            fout << f << std::endl;
    }

    // ensure all addons have already been resolved - TODO: remove when settings are const after creation
    assert(mSettings.addonInfos.size() == mSettings.addons.size());

    std::string ctuInfo;

    for (const AddonInfo &addonInfo : mSettings.addonInfos) {
        if (isCtuInfo && addonInfo.name != ""misra"" && !addonInfo.ctu)
            continue;

  ...",1,1,lib/cppcheck.cpp,"CppCheck.executeAddons:void(std.vector<std.string>&,std.string&)",<empty>,,false,1669,1772,executeAddons,,,1,"void(std.vector<std.string>&,std.string&)"
111669152365,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"void CppCheck::executeAddonsWholeProgram(const std::list<FileWithDetails> &files, const std::list<FileSettings>& fileSettings, const std::string& ctuInfo)
{
    if (mSettings.addons.empty())
        return;

    if (mSettings.buildDir.empty()) {
        std::string fileName = std::to_string(mSettings.pid) + "".ctu-info"";
        FilesDeleter filesDeleter;
        filesDeleter.addFile(fileName);
        std::ofstream fout(fileName);
        fout << ctuInfo;
        fout.close();
        executeAddons({std::move(fileName)}, """");
        return;
    }

    std::vector<std::string> ctuInfoFiles;
    for (const auto &f: files) {
        const std::string &dumpFileName = getDumpFileName(mSettings, f.path());
        ctuInfoFiles.push_back(getCtuInfoFileName(dumpFileName));
    }

    for (const auto &f: fileSettings) {
        const std::string &dumpFileName = getDumpFileName(mSettings, f.filename());
        ctuInfoFiles.push_back(getCtuInfoFileName(dumpFileName));
    }

    executeAddon...",1,1,lib/cppcheck.cpp,"CppCheck.executeAddonsWholeProgram:void(std.list<FileWithDetails>&,std.list<FileSettings>&,std.string&)",<empty>,,false,1774,1802,executeAddonsWholeProgram,,,1,"void(std.list<FileWithDetails>&,std.list<FileSettings>&,std.string&)"
111669152366,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"void CppCheck::tooManyConfigsError(const std::string &file, const int numberOfConfigurations)
{
    if (!mSettings.severity.isEnabled(Severity::information) && !mTooManyConfigs)
        return;

    mTooManyConfigs = false;

    if (mSettings.severity.isEnabled(Severity::information) && file.empty())
        return;

    std::list<ErrorMessage::FileLocation> loclist;
    if (!file.empty()) {
        loclist.emplace_back(file, 0, 0);
    }

    std::ostringstream msg;
    msg << ""Too many #ifdef configurations - cppcheck only checks "" << mSettings.maxConfigs;
    if (numberOfConfigurations > mSettings.maxConfigs)
        msg << "" of "" << numberOfConfigurations << "" configurations. Use --force to check all configurations.\\n"";
    if (file.empty())
        msg << "" configurations. Use --force to check all configurations. For more details, use --enable=information.\\n"";
    msg << ""The checking of the file will be interrupted because there are too many ""
        ""#ifdef configurations. C...",1,1,lib/cppcheck.cpp,"CppCheck.tooManyConfigsError:void(std.string&,int)",<empty>,,false,1804,1841,tooManyConfigsError,,,1,"void(std.string&,int)"
111669152367,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"void CppCheck::purgedConfigurationMessage(const std::string &file, const std::string& configuration)
{
    mTooManyConfigs = false;

    if (mSettings.severity.isEnabled(Severity::information) && file.empty())
        return;

    std::list<ErrorMessage::FileLocation> loclist;
    if (!file.empty()) {
        loclist.emplace_back(file, 0, 0);
    }

    ErrorMessage errmsg(std::move(loclist),
                        """",
                        Severity::information,
                        ""The configuration '"" + configuration + ""' was not checked because its code equals another one."",
                        ""purgedConfiguration"",
                        Certainty::normal);

    mErrorLogger.reportErr(errmsg);
}",1,1,lib/cppcheck.cpp,"CppCheck.purgedConfigurationMessage:void(std.string&,std.string&)",<empty>,,false,1843,1863,purgedConfigurationMessage,,,1,"void(std.string&,std.string&)"
111669152368,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"void CppCheck::getErrorMessages(ErrorLogger &errorlogger)
{
    Settings settings;
    Suppressions supprs;

    CppCheck cppcheck(settings, supprs, errorlogger, true, nullptr);
    cppcheck.purgedConfigurationMessage("""","""");
    cppcheck.mTooManyConfigs = true;
    cppcheck.tooManyConfigsError("""",0U);
    // TODO: add functions to get remaining error messages

    Settings s;
    s.addEnabled(""all"");

    // call all ""getErrorMessages"" in all registered Check classes
    for (auto it = Check::instances().cbegin(); it != Check::instances().cend(); ++it)
        (*it)->getErrorMessages(&errorlogger, &s);

    CheckUnusedFunctions::getErrorMessages(errorlogger);
    Preprocessor::getErrorMessages(errorlogger, s);
    Tokenizer::getErrorMessages(errorlogger, s);
}",1,1,lib/cppcheck.cpp,CppCheck.getErrorMessages:void(ErrorLogger&),<empty>,,false,1867,1888,getErrorMessages,,,1,void(ErrorLogger&)
111669152369,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"void CppCheck::analyseClangTidy(const FileSettings &fileSettings)
{
    std::string allIncludes;
    for (const std::string &inc : fileSettings.includePaths) {
        allIncludes = allIncludes + ""-I\\"""" + inc + ""\\"" "";
    }

    const std::string allDefines = getDefinesFlags(fileSettings.defines);

#ifdef _WIN32
    constexpr char exe[] = ""clang-tidy.exe"";
#else
    constexpr char exe[] = ""clang-tidy"";
#endif

    const std::string args = ""-quiet -checks=*,-clang-analyzer-*,-llvm* \\"""" + fileSettings.filename() + ""\\"" -- "" + allIncludes + allDefines;
    std::string output;
    if (const int exitcode = mExecuteCommand(exe, split(args), """", output)) {
        std::cerr << ""Failed to execute '"" << exe << ""' (exitcode: "" << std::to_string(exitcode) << "")"" << std::endl;
        return;
    }

    // parse output and create error messages
    std::istringstream istr(output);
    std::string line;

    if (!mSettings.buildDir.empty()) {
        const std::string analyzerInfoFile = AnalyzerI...",1,1,lib/cppcheck.cpp,CppCheck.analyseClangTidy:void(FileSettings&),<empty>,,false,1890,1965,analyseClangTidy,,,1,void(FileSettings&)
111669152370,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"bool CppCheck::analyseWholeProgram()
{
    bool errors = false;
    // Analyse the tokens
    CTU::FileInfo ctu;
    if (mSettings.useSingleJob() || !mSettings.buildDir.empty())
    {
        for (const Check::FileInfo *fi : mFileInfo) {
            const auto *fi2 = dynamic_cast<const CTU::FileInfo *>(fi);
            if (fi2) {
                ctu.functionCalls.insert(ctu.functionCalls.end(), fi2->functionCalls.cbegin(), fi2->functionCalls.cend());
                ctu.nestedCalls.insert(ctu.nestedCalls.end(), fi2->nestedCalls.cbegin(), fi2->nestedCalls.cend());
            }
        }
    }

    // cppcheck-suppress shadowFunction - TODO: fix this
    for (Check *check : Check::instances())
        errors |= check->analyseWholeProgram(ctu, mFileInfo, mSettings, mErrorLogger);  // TODO: ctu

    if (mUnusedFunctionsCheck)
        errors |= mUnusedFunctionsCheck->check(mSettings, mErrorLogger);

    return errors && (mLogger->exitcode() > 0);
}",1,1,lib/cppcheck.cpp,CppCheck.analyseWholeProgram:bool(),<empty>,,false,1967,1991,analyseWholeProgram,,,1,bool()
111669152371,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"unsigned int CppCheck::analyseWholeProgram(const std::string &buildDir, const std::list<FileWithDetails> &files, const std::list<FileSettings>& fileSettings, const std::string& ctuInfo)
{
    executeAddonsWholeProgram(files, fileSettings, ctuInfo);
    if (mSettings.checks.isEnabled(Checks::unusedFunction))
        CheckUnusedFunctions::analyseWholeProgram(mSettings, mErrorLogger, buildDir);
    std::list<Check::FileInfo*> fileInfoList;
    CTU::FileInfo ctuFileInfo;

    // Load all analyzer info data..
    const std::string filesTxt(buildDir + ""/files.txt"");
    std::ifstream fin(filesTxt);
    std::string filesTxtLine;
    while (std::getline(fin, filesTxtLine)) {
        const std::string::size_type firstColon = filesTxtLine.find(':');
        if (firstColon == std::string::npos)
            continue;
        const std::string::size_type lastColon = filesTxtLine.rfind(':');
        if (firstColon == lastColon)
            continue;
        const std::string xmlfile = buildDir + ...",1,1,lib/cppcheck.cpp,"CppCheck.analyseWholeProgram:unsigned int(std.string&,std.list<FileWithDetails>&,std.list<FileSettings>&,std.string&)",<empty>,,false,1993,2057,analyseWholeProgram,,,1,"unsigned int(std.string&,std.list<FileWithDetails>&,std.list<FileSettings>&,std.string&)"
111669152372,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"void CppCheck::resetTimerResults()
{
    s_timerResults.reset();
}",1,1,lib/cppcheck.cpp,CppCheck.resetTimerResults:void(),<empty>,,false,2060,2063,resetTimerResults,,,1,void()
111669152373,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"void CppCheck::printTimerResults(SHOWTIME_MODES mode)
{
    s_timerResults.showResults(mode);
}",1,1,lib/cppcheck.cpp,CppCheck.printTimerResults:void(SHOWTIME_MODES),<empty>,,false,2065,2068,printTimerResults,,,1,void(SHOWTIME_MODES)
111669152374,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"bool CppCheck::isPremiumCodingStandardId(const std::string& id) const {
    if (mSettings.premiumArgs.find(""--misra"") != std::string::npos) {
        if (startsWith(id, ""misra-"") || startsWith(id, ""premium-misra-""))
            return true;
    }
    if (mSettings.premiumArgs.find(""--cert"") != std::string::npos && startsWith(id, ""premium-cert-""))
        return true;
    if (mSettings.premiumArgs.find(""--autosar"") != std::string::npos && startsWith(id, ""premium-autosar-""))
        return true;
    return false;
}",1,1,lib/cppcheck.cpp,CppCheck.isPremiumCodingStandardId<const>:bool(std.string&),<empty>,,false,2070,2080,isPremiumCodingStandardId,,,1,bool(std.string&)
111669152375,METHOD,lib/cppcheck.cpp:<global>,TYPE_DECL,"std::string CppCheck::getDumpFileContentsRawTokens(const std::vector<std::string>& files, const simplecpp::TokenList& tokens1) const {
    std::string dumpProlog;
    dumpProlog += ""  <rawtokens>\\n"";
    for (unsigned int i = 0; i < files.size(); ++i) {
        dumpProlog += ""    <file index=\\"""";
        dumpProlog += std::to_string(i);
        dumpProlog += ""\\"" name=\\"""";
        dumpProlog += ErrorLogger::toxml(Path::getRelativePath(files[i], mSettings.basePaths));
        dumpProlog += ""\\""/>\\n"";
    }
    for (const simplecpp::Token *tok = tokens1.cfront(); tok; tok = tok->next) {
        dumpProlog += ""    <tok "";

        dumpProlog += ""fileIndex=\\"""";
        dumpProlog += std::to_string(tok->location.fileIndex);
        dumpProlog += ""\\"" "";

        dumpProlog += ""linenr=\\"""";
        dumpProlog += std::to_string(tok->location.line);
        dumpProlog += ""\\"" "";

        dumpProlog +=""column=\\"""";
        dumpProlog += std::to_string(tok->location.col);
        dumpProlog += ""\\"" ...",1,1,lib/cppcheck.cpp,"CppCheck.getDumpFileContentsRawTokens<const>:string(std.vector<std.string>&,simplecpp.TokenList&)",<empty>,,false,2082,2115,getDumpFileContentsRawTokens,,,1,"string(std.vector<std.string>&,simplecpp.TokenList&)"
111669152376,METHOD,lib/cppcheck.h:<global>,TYPE_DECL,<global>,1,1,lib/cppcheck.h,lib/cppcheck.h:<global>,<empty>,,false,1,237,<global>,,,1,
111669152377,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"std::string CTU::getFunctionId(const Tokenizer &tokenizer, const Function *function)
{
    return tokenizer.list.file(function->tokenDef) + ':' + std::to_string(function->tokenDef->linenr()) + ':' + std::to_string(function->tokenDef->column());
}",1,1,lib/ctu.cpp,"CTU.getFunctionId:string(Tokenizer&,Function*)",<empty>,,false,59,62,getFunctionId,,,1,"string(Tokenizer&,Function*)"
111669152378,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,<global>,1,78,lib/ctu.cpp,lib/ctu.cpp:<global>,<empty>,,false,1,607,<global>,,,1,
111669152379,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"CTU::FileInfo::Location::Location(const Tokenizer &tokenizer, const Token *tok)
    : fileName(tokenizer.list.file(tok))
    , lineNumber(tok->linenr())
    , column(tok->column())
{}",1,2,lib/ctu.cpp,"CTU.FileInfo.Location.Location:ANY(Tokenizer&,Token*)",<empty>,,false,64,68,Location,,,1,"CTU.FileInfo.Location.Location:ANY(Tokenizer&,Token*)(Tokenizer&,Token*)"
111669152380,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"std::string CTU::FileInfo::toString() const
{
    std::ostringstream out;

    // Function calls..
    for (const CTU::FileInfo::FunctionCall &functionCall : functionCalls) {
        out << functionCall.toXmlString();
    }

    // Nested calls..
    for (const CTU::FileInfo::NestedCall &nestedCall : nestedCalls) {
        out << nestedCall.toXmlString() << ""\\n"";
    }

    return out.str();
}",1,1,lib/ctu.cpp,CTU.FileInfo.toString<const>:string(),<empty>,,false,70,85,toString,,,1,string()
111669152381,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"std::string CTU::FileInfo::CallBase::toBaseXmlString() const
{
    std::ostringstream out;
    out << "" "" << ATTR_CALL_ID << ""=\\"""" << callId << ""\\""""
        << "" "" << ATTR_CALL_FUNCNAME << ""=\\"""" << ErrorLogger::toxml(callFunctionName) << ""\\""""
        << "" "" << ATTR_CALL_ARGNR << ""=\\"""" << callArgNr << ""\\""""
        << "" "" << ATTR_LOC_FILENAME << ""=\\"""" << ErrorLogger::toxml(location.fileName) << ""\\""""
        << "" "" << ATTR_LOC_LINENR << ""=\\"""" << location.lineNumber << ""\\""""
        << "" "" << ATTR_LOC_COLUMN << ""=\\"""" << location.column << ""\\"""";
    return out.str();
}",1,1,lib/ctu.cpp,CTU.FileInfo.CallBase.toBaseXmlString<const>:string(),<empty>,,false,87,97,toBaseXmlString,,,1,string()
111669152382,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"std::string CTU::FileInfo::FunctionCall::toXmlString() const
{
    std::ostringstream out;
    out << ""<function-call""
        << toBaseXmlString()
        << "" "" << ATTR_CALL_ARGEXPR << ""=\\"""" << ErrorLogger::toxml(callArgumentExpression) << ""\\""""
        << "" "" << ATTR_CALL_ARGVALUETYPE << ""=\\"""" << static_cast<int>(callValueType) << ""\\""""
        << "" "" << ATTR_CALL_ARGVALUE << ""=\\"""" << callArgValue.value << ""\\""""
        << "" "" << ATTR_CALL_UNKNOWN_FUNCTION_RETURN << ""=\\"""" << (int)callArgValue.unknownFunctionReturn << ""\\"""";
    if (warning)
        out << "" "" << ATTR_WARNING << ""=\\""true\\"""";
    if (callValuePath.empty())
        out << ""/>"";
    else {
        out << "">\\n"";
        for (const ErrorMessage::FileLocation &loc : callValuePath)
            out << ""  <path""
                << "" "" << ATTR_LOC_FILENAME << ""=\\"""" << ErrorLogger::toxml(loc.getfile()) << ""\\""""
                << "" "" << ATTR_LOC_LINENR << ""=\\"""" << loc.line << ""\\""""
                << "" "" << ATTR_LOC_COLUMN << ""=\\""...",1,1,lib/ctu.cpp,CTU.FileInfo.FunctionCall.toXmlString<const>:string(),<empty>,,false,99,123,toXmlString,,,1,string()
111669152383,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"std::string CTU::FileInfo::NestedCall::toXmlString() const
{
    std::ostringstream out;
    out << ""<function-call""
        << toBaseXmlString()
        << "" "" << ATTR_MY_ID << ""=\\"""" << myId << ""\\""""
        << "" "" << ATTR_MY_ARGNR << ""=\\"""" << myArgNr << ""\\""""
        << ""/>"";
    return out.str();
}",1,1,lib/ctu.cpp,CTU.FileInfo.NestedCall.toXmlString<const>:string(),<empty>,,false,125,134,toXmlString,,,1,string()
111669152384,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"std::string CTU::FileInfo::UnsafeUsage::toString() const
{
    std::ostringstream out;
    out << ""    <unsafe-usage""
        << "" "" << ATTR_MY_ID << ""=\\"""" << myId << '\\""'
        << "" "" << ATTR_MY_ARGNR << ""=\\"""" << myArgNr << '\\""'
        << "" "" << ATTR_MY_ARGNAME << ""=\\"""" << myArgumentName << '\\""'
        << "" "" << ATTR_LOC_FILENAME << ""=\\"""" << ErrorLogger::toxml(location.fileName) << '\\""'
        << "" "" << ATTR_LOC_LINENR << ""=\\"""" << location.lineNumber << '\\""'
        << "" "" << ATTR_LOC_COLUMN << ""=\\"""" << location.column << '\\""'
        << "" "" << ATTR_VALUE << ""=\\"""" << value << ""\\""""
        << ""/>\\n"";
    return out.str();
}",1,1,lib/ctu.cpp,CTU.FileInfo.UnsafeUsage.toString<const>:string(),<empty>,,false,136,149,toString,,,1,string()
111669152385,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"std::string CTU::toString(const std::list<CTU::FileInfo::UnsafeUsage> &unsafeUsage)
{
    std::ostringstream ret;
    for (const CTU::FileInfo::UnsafeUsage &u : unsafeUsage)
        ret << u.toString();
    return ret.str();
}",1,1,lib/ctu.cpp,CTU.toString:string(std.list<CTU.FileInfo.UnsafeUsage>&),<empty>,,false,151,157,toString,,,1,string(std.list<CTU.FileInfo.UnsafeUsage>&)
111669152386,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"CTU::FileInfo::CallBase::CallBase(const Tokenizer &tokenizer, const Token *callToken)
    : callId(getFunctionId(tokenizer, callToken->function()))
    , callFunctionName(callToken->next()->astOperand1()->expressionString())
    , location(CTU::FileInfo::Location(tokenizer, callToken))
{}",1,2,lib/ctu.cpp,"CTU.FileInfo.CallBase.CallBase:ANY(Tokenizer&,Token*)",<empty>,,false,159,163,CallBase,,,1,"CTU.FileInfo.CallBase.CallBase:ANY(Tokenizer&,Token*)(Tokenizer&,Token*)"
111669152387,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"CTU::FileInfo::NestedCall::NestedCall(const Tokenizer &tokenizer, const Function *myFunction, const Token *callToken)
    : CallBase(tokenizer, callToken)
    , myId(getFunctionId(tokenizer, myFunction))
{}",1,2,lib/ctu.cpp,"CTU.FileInfo.NestedCall.NestedCall:ANY(Tokenizer&,Function*,Token*)",<empty>,,false,165,168,NestedCall,,,1,"CTU.FileInfo.NestedCall.NestedCall:ANY(Tokenizer&,Function*,Token*)(Tokenizer&,Function*,Token*)"
111669152388,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"static std::string readAttrString(const tinyxml2::XMLElement *e, const char *attr, bool *error)
{
    const char *value = e->Attribute(attr);
    if (!value && error)
        *error = true;
    return empty_if_null(value);
}",1,1,lib/ctu.cpp,"readAttrString:string(tinyxml2.XMLElement*,char*,bool*)",<empty>,,false,170,176,readAttrString,,,1,"string(tinyxml2.XMLElement*,char*,bool*)"
111669152389,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"static long long readAttrInt(const tinyxml2::XMLElement *e, const char *attr, bool *error)
{
    int64_t value = 0;
    const bool err = (e->QueryInt64Attribute(attr, &value) != tinyxml2::XML_SUCCESS);
    if (error)
        *error = err;
    return value;
}",1,1,lib/ctu.cpp,"readAttrInt:longlong(tinyxml2.XMLElement*,char*,bool*)",<empty>,,false,178,185,readAttrInt,,,1,"longlong(tinyxml2.XMLElement*,char*,bool*)"
111669152390,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"bool CTU::FileInfo::CallBase::loadBaseFromXml(const tinyxml2::XMLElement *xmlElement)
{
    bool error = false;
    callId = readAttrString(xmlElement, ATTR_CALL_ID, &error);
    callFunctionName = readAttrString(xmlElement, ATTR_CALL_FUNCNAME, &error);
    callArgNr = readAttrInt(xmlElement, ATTR_CALL_ARGNR, &error);
    location.fileName = readAttrString(xmlElement, ATTR_LOC_FILENAME, &error);
    location.lineNumber = readAttrInt(xmlElement, ATTR_LOC_LINENR, &error);
    location.column = readAttrInt(xmlElement, ATTR_LOC_COLUMN, &error);
    return !error;
}",1,1,lib/ctu.cpp,CTU.FileInfo.CallBase.loadBaseFromXml:bool(tinyxml2.XMLElement*),<empty>,,false,187,197,loadBaseFromXml,,,1,bool(tinyxml2.XMLElement*)
111669152391,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"bool CTU::FileInfo::FunctionCall::loadFromXml(const tinyxml2::XMLElement *xmlElement)
{
    if (!loadBaseFromXml(xmlElement))
        return false;
    bool error=false;
    callArgumentExpression = readAttrString(xmlElement, ATTR_CALL_ARGEXPR, &error);
    callValueType = (ValueFlow::Value::ValueType)readAttrInt(xmlElement, ATTR_CALL_ARGVALUETYPE, &error);
    callArgValue.value = readAttrInt(xmlElement, ATTR_CALL_ARGVALUE, &error);
    const auto ufr = readAttrInt(xmlElement, ATTR_CALL_UNKNOWN_FUNCTION_RETURN, &error);
    callArgValue.unknownFunctionReturn = (ValueFlow::Value::UnknownFunctionReturn)(ufr>=0 && ufr <=0xff ? ufr : 0xff);
    const char *w = xmlElement->Attribute(ATTR_WARNING);
    warning = w && std::strcmp(w, ""true"") == 0;
    for (const tinyxml2::XMLElement *e2 = xmlElement->FirstChildElement(); !error && e2; e2 = e2->NextSiblingElement()) {
        if (std::strcmp(e2->Name(), ""path"") != 0)
            continue;
        std::string file = readAttrString(e2, ATTR_L...",1,1,lib/ctu.cpp,CTU.FileInfo.FunctionCall.loadFromXml:bool(tinyxml2.XMLElement*),<empty>,,false,199,222,loadFromXml,,,1,bool(tinyxml2.XMLElement*)
111669152392,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"bool CTU::FileInfo::NestedCall::loadFromXml(const tinyxml2::XMLElement *xmlElement)
{
    if (!loadBaseFromXml(xmlElement))
        return false;
    bool error = false;
    myId = readAttrString(xmlElement, ATTR_MY_ID, &error);
    myArgNr = readAttrInt(xmlElement, ATTR_MY_ARGNR, &error);
    return !error;
}",1,1,lib/ctu.cpp,CTU.FileInfo.NestedCall.loadFromXml:bool(tinyxml2.XMLElement*),<empty>,,false,224,232,loadFromXml,,,1,bool(tinyxml2.XMLElement*)
111669152393,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"void CTU::FileInfo::loadFromXml(const tinyxml2::XMLElement *xmlElement)
{
    for (const tinyxml2::XMLElement *e = xmlElement->FirstChildElement(); e; e = e->NextSiblingElement()) {
        const char* name = e->Name();
        if (std::strcmp(name, ""function-call"") == 0) {
            FunctionCall functionCall;
            if (functionCall.loadFromXml(e))
                functionCalls.push_back(std::move(functionCall));
        } else if (std::strcmp(name, ""nested-call"") == 0) {
            NestedCall nestedCall;
            if (nestedCall.loadFromXml(e))
                nestedCalls.push_back(std::move(nestedCall));
        }
    }
}",1,1,lib/ctu.cpp,CTU.FileInfo.loadFromXml:void(tinyxml2.XMLElement*),<empty>,,false,234,248,loadFromXml,,,1,void(tinyxml2.XMLElement*)
111669152394,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"std::map<std::string, std::list<const CTU::FileInfo::CallBase *>> CTU::FileInfo::getCallsMap() const
{
    std::map<std::string, std::list<const CTU::FileInfo::CallBase *>> ret;
    for (const CTU::FileInfo::NestedCall &nc : nestedCalls)
        ret[nc.callId].push_back(&nc);
    for (const CTU::FileInfo::FunctionCall &fc : functionCalls)
        ret[fc.callId].push_back(&fc);
    return ret;
}",1,1,lib/ctu.cpp,"CTU.FileInfo.getCallsMap<const>:map<std.string,std.list<constCTU.FileInfo.CallBase*>>()",<empty>,,false,250,258,getCallsMap,,,1,"map<std::string,std::list<const CTU::FileInfo::CallBase*>>()"
111669152395,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"std::list<CTU::FileInfo::UnsafeUsage> CTU::loadUnsafeUsageListFromXml(const tinyxml2::XMLElement *xmlElement)
{
    std::list<CTU::FileInfo::UnsafeUsage> ret;
    for (const tinyxml2::XMLElement *e = xmlElement->FirstChildElement(); e; e = e->NextSiblingElement()) {
        if (std::strcmp(e->Name(), ""unsafe-usage"") != 0)
            continue;
        bool error = false;
        FileInfo::UnsafeUsage unsafeUsage;
        unsafeUsage.myId = readAttrString(e, ATTR_MY_ID, &error);
        unsafeUsage.myArgNr = readAttrInt(e, ATTR_MY_ARGNR, &error);
        unsafeUsage.myArgumentName = readAttrString(e, ATTR_MY_ARGNAME, &error);
        unsafeUsage.location.fileName = readAttrString(e, ATTR_LOC_FILENAME, &error);
        unsafeUsage.location.lineNumber = readAttrInt(e, ATTR_LOC_LINENR, &error);
        unsafeUsage.location.column = readAttrInt(e, ATTR_LOC_COLUMN, &error);
        unsafeUsage.value = readAttrInt(e, ATTR_VALUE, &error);

        if (!error)
            ret.push_back(std::...",1,1,lib/ctu.cpp,CTU.loadUnsafeUsageListFromXml:list<CTU.FileInfo.UnsafeUsage>(tinyxml2.XMLElement*),<empty>,,false,260,280,loadUnsafeUsageListFromXml,,,1,list<CTU::FileInfo::UnsafeUsage>(tinyxml2.XMLElement*)
111669152396,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"static int isCallFunction(const Scope *scope, int argnr, const Token *&tok)
{
    const Variable * const argvar = scope->function->getArgumentVar(argnr);
    if (!argvar->isPointer())
        return -1;
    for (const Token *tok2 = scope->bodyStart; tok2 != scope->bodyEnd; tok2 = tok2->next()) {
        if (tok2->variable() != argvar)
            continue;
        if (!Token::Match(tok2->previous(), ""[(,] %var% [,)]""))
            break;
        int argnr2 = 1;
        const Token *prev = tok2;
        while (prev && prev->str() != ""("") {
            if (Token::Match(prev,""]|)""))
                prev = prev->link();
            else if (prev->str() == "","")
                ++argnr2;
            prev = prev->previous();
        }
        if (!prev || !Token::Match(prev->previous(), ""%name% (""))
            break;
        if (!prev->astOperand1() || !prev->astOperand1()->function())
            break;
        tok = prev->previous();
        return argnr2;
    }
    return -1;
}",1,1,lib/ctu.cpp,"isCallFunction:int(Scope*,int,Token*&)",<empty>,,false,282,309,isCallFunction,,,1,"int(Scope*,int,Token*&)"
111669152397,METHOD,<empty>,<empty>,"[](const Token* argtok) -> const Token* {
                    if (!argtok->isUnaryOp(""&""))
                        return nullptr;
                    argtok = argtok->astOperand1();
                    if (!argtok || !argtok->valueType() || argtok->valueType()->pointer != 0)
                        return nullptr;
                    return argtok;
                }",39,17,lib/ctu.cpp,lib/ctu.cpp:<global>.CTU.getFileInfo.<lambda>0:Token(Token*),<empty>,,false,389,396,<lambda>0,,,1,Token(Token*)
111669152398,METHOD,<empty>,<empty>,"[&](const Token* argtok) -> const Token* {
                    const Variable* argvar = tokFunction->getArgumentVar(argnr);
                    if (!argvar || !argvar->valueType() || argvar->valueType()->reference == Reference::None)
                        return nullptr;
                    return argtok;
                }",39,17,lib/ctu.cpp,lib/ctu.cpp:<global>.CTU.getFileInfo.<lambda>1:Token(Token*),<empty>,,false,397,402,<lambda>1,,,1,Token(Token*)
111669152399,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"CTU::FileInfo *CTU::getFileInfo(const Tokenizer &tokenizer)
{
    const SymbolDatabase * const symbolDatabase = tokenizer.getSymbolDatabase();

    auto *fileInfo = new FileInfo;

    // Parse all functions in TU
    for (const Scope &scope : symbolDatabase->scopeList) {
        if (!scope.isExecutable() || scope.type != ScopeType::eFunction || !scope.function)
            continue;
        const Function *const scopeFunction = scope.function;

        // source function calls
        for (const Token *tok = scope.bodyStart; tok != scope.bodyEnd; tok = tok->next()) {
            if (tok->str() != ""("" || !tok->astOperand1() || !tok->astOperand2())
                continue;
            const Function* tokFunction = tok->astOperand1()->function();
            if (!tokFunction)
                continue;
            const std::vector<const Token *> args(getArguments(tok->previous()));
            for (int argnr = 0; argnr < args.size(); ++argnr) {
                const Token *argtok = ar...",1,1,lib/ctu.cpp,CTU.getFileInfo:CTU.FileInfo*(Tokenizer&),<empty>,,false,312,442,getFileInfo,,,1,CTU.FileInfo*(Tokenizer&)
111669152400,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"static std::vector<std::pair<const Token *, CTU::FileInfo::Value>> getUnsafeFunction(const Settings &settings, const Scope *scope, int argnr, bool (*isUnsafeUsage)(const Settings &settings, const Token *argtok, CTU::FileInfo::Value *value))
{
    std::vector<std::pair<const Token *, CTU::FileInfo::Value>> ret;
    const Variable * const argvar = scope->function->getArgumentVar(argnr);
    if (!argvar->isArrayOrPointer() && !argvar->isReference())
        return ret;
    for (const Token *tok2 = scope->bodyStart; tok2 != scope->bodyEnd; tok2 = tok2->next()) {
        if (Token::Match(tok2, "")|else {"")) {
            tok2 = tok2->linkAt(1);
            if (Token::findmatch(tok2->link(), ""return|throw"", tok2))
                return ret;
            int indirect = 0;
            if (argvar->valueType())
                indirect = argvar->valueType()->pointer;
            if (isVariableChanged(tok2->link(), tok2, indirect, argvar->declarationId(), false, settings))
                retur...",1,1,lib/ctu.cpp,"getUnsafeFunction:vector<std.pair<constToken*,CTU.FileInfo.Value>>(Settings&,Scope*,int,bool)",<empty>,,false,444,474,getUnsafeFunction,,,1,"vector<std::pair<const Token*,CTU::FileInfo::Value>>(Settings&,Scope*,int,bool)"
111669152401,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"std::list<CTU::FileInfo::UnsafeUsage> CTU::getUnsafeUsage(const Tokenizer &tokenizer, const Settings &settings, bool (*isUnsafeUsage)(const Settings &settings, const Token *argtok, CTU::FileInfo::Value *value))
{
    std::list<CTU::FileInfo::UnsafeUsage> unsafeUsage;

    // Parse all functions in TU
    const SymbolDatabase * const symbolDatabase = tokenizer.getSymbolDatabase();

    for (const Scope &scope : symbolDatabase->scopeList) {
        if (!scope.isExecutable() || scope.type != ScopeType::eFunction || !scope.function)
            continue;
        const Function *const function = scope.function;

        // ""Unsafe"" functions unconditionally reads data before it is written..
        for (int argnr = 0; argnr < function->argCount(); ++argnr) {
            for (const std::pair<const Token *, CTU::FileInfo::Value> &v : getUnsafeFunction(settings, &scope, argnr, isUnsafeUsage)) {
                const Token *tok = v.first;
                const MathLib::bigint val = v.second....",1,1,lib/ctu.cpp,"CTU.getUnsafeUsage:list<CTU.FileInfo.UnsafeUsage>(Tokenizer&,Settings&,bool)",<empty>,,false,476,499,getUnsafeUsage,,,1,"list<CTU::FileInfo::UnsafeUsage>(Tokenizer&,Settings&,bool)"
111669152402,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"static bool findPath(const std::string &callId,
                     nonneg int callArgNr,
                     MathLib::bigint unsafeValue,
                     CTU::FileInfo::InvalidValueType invalidValue,
                     const std::map<std::string, std::list<const CTU::FileInfo::CallBase *>> &callsMap,
                     const CTU::FileInfo::CallBase *path[10],
                     int index,
                     bool warning,
                     int maxCtuDepth)
{
    if (index >= maxCtuDepth)
        return false; // TODO: add bailout message?

    const auto it = utils::as_const(callsMap).find(callId);
    if (it == callsMap.end())
        return false;

    for (const CTU::FileInfo::CallBase *c : it->second) {
        if (c->callArgNr != callArgNr)
            continue;

        const auto *functionCall = dynamic_cast<const CTU::FileInfo::FunctionCall *>(c);
        if (functionCall) {
            if (!warning && functionCall->warning)
                continue;
      ...",1,21,lib/ctu.cpp,"findPath:bool(std.string&,int,MathLib.bigint,CTU.FileInfo.InvalidValueType,std.map<std.string,std.list<constCTU.FileInfo.CallBase*>>&,CTU.FileInfo.CallBase[10]*,int,bool,int)",<empty>,,false,501,559,findPath,,,1,"bool(std.string&,int,MathLib.bigint,CTU.FileInfo.InvalidValueType,std.map<std.string,std.list<constCTU.FileInfo.CallBase*>>&,CTU.FileInfo.CallBase[10]*,int,bool,int)"
111669152403,METHOD,lib/ctu.cpp:<global>,TYPE_DECL,"std::list<ErrorMessage::FileLocation> CTU::FileInfo::getErrorPath(InvalidValueType invalidValue,
                                                                  const CTU::FileInfo::UnsafeUsage &unsafeUsage,
                                                                  const std::map<std::string, std::list<const CTU::FileInfo::CallBase *>> &callsMap,
                                                                  const char info[],
                                                                  const FunctionCall ** const functionCallPtr,
                                                                  bool warning,
                                                                  int maxCtuDepth,
                                                                  ValueFlow::Value::UnknownFunctionReturn *unknownFunctionReturn)
{
    const CTU::FileInfo::CallBase *path[10] = {nullptr};

    if (!findPath(unsafeUsage.myId, unsafeUsage.myArgNr, unsafeUsage.value, invalidValue,...",1,1,lib/ctu.cpp,"CTU.FileInfo.getErrorPath:list<ErrorMessage.FileLocation>(CTU.FileInfo.InvalidValueType,CTU.FileInfo.UnsafeUsage&,std.map<std.string,std.list<constCTU.FileInfo.CallBase*>>&,char[],CTU.FileInfo.FunctionCall**,bool,int,ValueFlow.Value.UnknownFunctionReturn*)",<empty>,,false,561,607,getErrorPath,,,1,"list<ErrorMessage::FileLocation>(CTU.FileInfo.InvalidValueType,CTU.FileInfo.UnsafeUsage&,std.map<std.string,std.list<constCTU.FileInfo.CallBase*>>&,char[],CTU.FileInfo.FunctionCall**,bool,int,ValueFlow.Value.UnknownFunctionReturn*)"
111669152404,METHOD,lib/ctu.h:<global>,TYPE_DECL,<global>,1,1,lib/ctu.h,lib/ctu.h:<global>,<empty>,,false,1,172,<global>,,,1,
111669152405,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"ErrorMessage::ErrorMessage()
    : severity(Severity::none), cwe(0U), certainty(Certainty::normal), hash(0)
{}",1,2,lib/errorlogger.cpp,ErrorMessage.ErrorMessage:ANY(),<empty>,,false,59,61,ErrorMessage,,,1,ErrorMessage.ErrorMessage:ANY()()
111669152406,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,<global>,1,1,lib/errorlogger.cpp,lib/errorlogger.cpp:<global>,<empty>,,false,1,1113,<global>,,,1,
111669152407,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"ErrorMessage::ErrorMessage(std::list<FileLocation> callStack, std::string file1, Severity severity, const std::string &msg, std::string id, Certainty certainty) :
    callStack(std::move(callStack)), // locations for this error message
    id(std::move(id)),               // set the message id
    file0(std::move(file1)),
    severity(severity),   // severity for this error message
    cwe(0U),
    certainty(certainty),
    hash(0)
{
    // set the summary and verbose messages
    setmsg(msg);
}",1,1,lib/errorlogger.cpp,"ErrorMessage.ErrorMessage:ANY(std.list<FileLocation>,std.string,Severity,std.string&,std.string,Certainty)",<empty>,,false,64,75,ErrorMessage,,,1,"ErrorMessage.ErrorMessage:ANY(std.list<FileLocation>,std.string,Severity,std.string&,std.string,Certainty)(std.list<FileLocation>,std.string,Severity,std.string&,std.string,Certainty)"
111669152408,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"ErrorMessage::ErrorMessage(std::list<FileLocation> callStack, std::string file1, Severity severity, const std::string &msg, std::string id, const CWE &cwe, Certainty certainty) :
    callStack(std::move(callStack)), // locations for this error message
    id(std::move(id)),               // set the message id
    file0(std::move(file1)),
    severity(severity),   // severity for this error message
    cwe(cwe.id),
    certainty(certainty),
    hash(0)
{
    // set the summary and verbose messages
    setmsg(msg);
}",1,1,lib/errorlogger.cpp,"ErrorMessage.ErrorMessage:ANY(std.list<FileLocation>,std.string,Severity,std.string&,std.string,CWE&,Certainty)",<empty>,,false,79,90,ErrorMessage,,,1,"ErrorMessage.ErrorMessage:ANY(std.list<FileLocation>,std.string,Severity,std.string&,std.string,CWE&,Certainty)(std.list<FileLocation>,std.string,Severity,std.string&,std.string,CWE&,Certainty)"
111669152409,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"ErrorMessage::ErrorMessage(const std::list<const Token*>& callstack, const TokenList* list, Severity severity, std::string id, const std::string& msg, Certainty certainty)
    : id(std::move(id)), severity(severity), cwe(0U), certainty(certainty), hash(0)
{
    // Format callstack
    for (auto it = callstack.cbegin(); it != callstack.cend(); ++it) {
        // --errorlist can provide null values here
        if (!(*it))
            continue;

        callStack.emplace_back(*it, list);
    }

    if (list && !list->getFiles().empty())
        file0 = list->getFiles()[0];

    setmsg(msg);
}",1,1,lib/errorlogger.cpp,"ErrorMessage.ErrorMessage:ANY(std.list<constToken*>&,TokenList*,Severity,std.string,std.string&,Certainty)",<empty>,,false,92,108,ErrorMessage,,,1,"ErrorMessage.ErrorMessage:ANY(std.list<constToken*>&,TokenList*,Severity,std.string,std.string&,Certainty)(std.list<constToken*>&,TokenList*,Severity,std.string,std.string&,Certainty)"
111669152410,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"ErrorMessage::ErrorMessage(const std::list<const Token*>& callstack, const TokenList* list, Severity severity, std::string id, const std::string& msg, const CWE &cwe, Certainty certainty)
    : id(std::move(id)), severity(severity), cwe(cwe.id), certainty(certainty)
{
    // Format callstack
    for (const Token *tok: callstack) {
        // --errorlist can provide null values here
        if (!tok)
            continue;

        callStack.emplace_back(tok, list);
    }

    if (list && !list->getFiles().empty())
        file0 = list->getFiles()[0];

    setmsg(msg);

    hash = 0; // calculateWarningHash(list, hashWarning.str());
}",1,1,lib/errorlogger.cpp,"ErrorMessage.ErrorMessage:ANY(std.list<constToken*>&,TokenList*,Severity,std.string,std.string&,CWE&,Certainty)",<empty>,,false,111,129,ErrorMessage,,,1,"ErrorMessage.ErrorMessage:ANY(std.list<constToken*>&,TokenList*,Severity,std.string,std.string&,CWE&,Certainty)(std.list<constToken*>&,TokenList*,Severity,std.string,std.string&,CWE&,Certainty)"
111669152411,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"ErrorMessage::ErrorMessage(const ErrorPath &errorPath, const TokenList *tokenList, Severity severity, const char id[], const std::string &msg, const CWE &cwe, Certainty certainty)
    : id(id), severity(severity), cwe(cwe.id), certainty(certainty)
{
    // Format callstack
    for (const ErrorPathItem& e: errorPath) {
        const Token *tok = e.first;
        // --errorlist can provide null values here
        if (!tok)
            continue;

        const std::string& path_info = e.second;

        std::string info;
        if (startsWith(path_info,""$symbol:"") && path_info.find('\\n') < path_info.size()) {
            const std::string::size_type pos = path_info.find('\\n');
            const std::string symbolName = path_info.substr(8, pos - 8);
            info = replaceStr(path_info.substr(pos+1), ""$symbol"", symbolName);
        }
        else {
            info = path_info;
        }

        callStack.emplace_back(tok, std::move(info), tokenList);
    }

    if (tokenList && !...",1,1,lib/errorlogger.cpp,"ErrorMessage.ErrorMessage:ANY(ErrorPath&,TokenList*,Severity,char[],std.string&,CWE&,Certainty)",<empty>,,false,131,162,ErrorMessage,,,1,"ErrorMessage.ErrorMessage:ANY(ErrorPath&,TokenList*,Severity,char[],std.string&,CWE&,Certainty)(ErrorPath&,TokenList*,Severity,char[],std.string&,CWE&,Certainty)"
111669152412,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"ErrorMessage::ErrorMessage(const tinyxml2::XMLElement * const errmsg)
    : severity(Severity::none),
    cwe(0U),
    certainty(Certainty::normal)
{
    const char * const unknown = ""<UNKNOWN>"";

    const char *attr = errmsg->Attribute(""id"");
    id = attr ? attr : unknown;

    attr = errmsg->Attribute(""file0"");
    file0 = attr ? attr : """";

    attr = errmsg->Attribute(""severity"");
    severity = attr ? severityFromString(attr) : Severity::none;

    attr = errmsg->Attribute(""cwe"");
    // cppcheck-suppress templateInstantiation - TODO: fix this - see #11631
    cwe.id = attr ? strToInt<unsigned short>(attr) : 0;

    attr = errmsg->Attribute(""inconclusive"");
    certainty = (attr && (std::strcmp(attr, ""true"") == 0)) ? Certainty::inconclusive : Certainty::normal;

    attr = errmsg->Attribute(""msg"");
    mShortMessage = attr ? attr : """";

    attr = errmsg->Attribute(""verbose"");
    mVerboseMessage = attr ? attr : """";

    attr = errmsg->Attribute(""hash"");
    hash = attr ? str...",1,1,lib/errorlogger.cpp,ErrorMessage.ErrorMessage:ANY(tinyxml2.XMLElement*),<empty>,,false,164,213,ErrorMessage,,,1,ErrorMessage.ErrorMessage:ANY(tinyxml2.XMLElement*)(tinyxml2.XMLElement*)
111669152413,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"void ErrorMessage::setmsg(const std::string &msg)
{
    // If a message ends to a '\\n' and contains only a one '\\n'
    // it will cause the mVerboseMessage to be empty which will show
    // as an empty message to the user if --verbose is used.
    // Even this doesn't cause problems with messages that have multiple
    // lines, none of the error messages should end into it.
    assert(!endsWith(msg,'\\n'));

    // The summary and verbose message are separated by a newline
    // If there is no newline then both the summary and verbose messages
    // are the given message
    const std::string::size_type pos = msg.find('\\n');
    const std::string symbolName = mSymbolNames.empty() ? std::string() : mSymbolNames.substr(0, mSymbolNames.find('\\n'));
    if (pos == std::string::npos) {
        mShortMessage = replaceStr(msg, ""$symbol"", symbolName);
        mVerboseMessage = replaceStr(msg, ""$symbol"", symbolName);
    } else if (startsWith(msg,""$symbol:"")) {
        mSymbolNames += ms...",1,1,lib/errorlogger.cpp,ErrorMessage.setmsg:void(std.string&),<empty>,,false,215,239,setmsg,,,1,void(std.string&)
111669152414,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"static void serializeString(std::string &oss, const std::string & str)
{
    oss += std::to_string(str.length());
    oss += "" "";
    oss += str;
}",1,1,lib/errorlogger.cpp,"serializeString:void(std.string&,std.string&)",<empty>,,false,241,246,serializeString,,,1,"void(std.string&,std.string&)"
111669152415,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"ErrorMessage ErrorMessage::fromInternalError(const InternalError &internalError, const TokenList *tokenList, const std::string &filename, const std::string& msg)
{
    if (internalError.token)
        assert(tokenList != nullptr); // we need to make sure we can look up the provided token

    std::list<ErrorMessage::FileLocation> locationList;
    if (tokenList && internalError.token) {
        locationList.emplace_back(internalError.token, tokenList);
    } else {
        locationList.emplace_back(filename, 0, 0);
        if (tokenList && (filename != tokenList->getSourceFilePath())) {
            locationList.emplace_back(tokenList->getSourceFilePath(), 0, 0);
        }
    }
    ErrorMessage errmsg(std::move(locationList),
                        tokenList ? tokenList->getSourceFilePath() : filename,
                        Severity::error,
                        (msg.empty() ? """" : (msg + "": "")) + internalError.errorMessage,
                        internalError.id,
           ...",1,1,lib/errorlogger.cpp,"ErrorMessage.fromInternalError:ErrorMessage(InternalError&,TokenList*,std.string&,std.string&)",<empty>,,false,248,272,fromInternalError,,,1,"ErrorMessage(InternalError&,TokenList*,std.string&,std.string&)"
111669152416,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"std::string ErrorMessage::serialize() const
{
    // Serialize this message into a simple string
    std::string oss;
    serializeString(oss, id);
    serializeString(oss, severityToString(severity));
    serializeString(oss, std::to_string(cwe.id));
    serializeString(oss, std::to_string(hash));
    serializeString(oss, fixInvalidChars(remark));
    serializeString(oss, file0);
    serializeString(oss, (certainty == Certainty::inconclusive) ? ""1"" : ""0"");

    const std::string saneShortMessage = fixInvalidChars(mShortMessage);
    const std::string saneVerboseMessage = fixInvalidChars(mVerboseMessage);

    serializeString(oss, saneShortMessage);
    serializeString(oss, saneVerboseMessage);
    serializeString(oss, mSymbolNames);
    oss += std::to_string(callStack.size());
    oss += "" "";

    for (auto loc = callStack.cbegin(); loc != callStack.cend(); ++loc) {
        std::string frame;
        frame += std::to_string(loc->line);
        frame += '\\t';
        frame += std::t...",1,1,lib/errorlogger.cpp,ErrorMessage.serialize<const>:string(),<empty>,,false,274,310,serialize,,,1,string()
111669152417,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"void ErrorMessage::deserialize(const std::string &data)
{
    // TODO: clear all fields
    certainty = Certainty::normal;
    callStack.clear();

    std::istringstream iss(data);
    std::array<std::string, 10> results;
    std::size_t elem = 0;
    while (iss.good() && elem < 10) {
        unsigned int len = 0;
        if (!(iss >> len))
            throw InternalError(nullptr, ""Internal Error: Deserialization of error message failed - invalid length"");

        if (iss.get() != ' ')
            throw InternalError(nullptr, ""Internal Error: Deserialization of error message failed - invalid separator"");

        if (!iss.good())
            throw InternalError(nullptr, ""Internal Error: Deserialization of error message failed - premature end of data"");

        std::string temp;
        if (len > 0) {
            temp.resize(len);
            iss.read(&temp[0], len);

            if (!iss.good())
                throw InternalError(nullptr, ""Internal Error: Deserialization of error...",1,1,lib/errorlogger.cpp,ErrorMessage.deserialize:void(std.string&),<empty>,,false,312,430,deserialize,,,1,void(std.string&)
111669152418,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"std::string ErrorMessage::getXMLHeader(std::string productName, int xmlVersion)
{
    const auto nameAndVersion = Settings::getNameAndVersion(productName);
    productName = nameAndVersion.first;
    const std::string version = nameAndVersion.first.empty() ? CppCheck::version() : nameAndVersion.second;

    tinyxml2::XMLPrinter printer;

    // standard xml header
    printer.PushDeclaration(""xml version=\\""1.0\\"" encoding=\\""UTF-8\\"""");

    // header
    printer.OpenElement(""results"", false);

    printer.PushAttribute(""version"", xmlVersion);
    printer.OpenElement(""cppcheck"", false);
    if (!productName.empty())
        printer.PushAttribute(""product-name"", productName.c_str());
    printer.PushAttribute(""version"", version.c_str());
    printer.CloseElement(false);
    printer.OpenElement(""errors"", false);

    return std::string(printer.CStr()) + '>';
}",1,1,lib/errorlogger.cpp,"ErrorMessage.getXMLHeader:string(std.string,int)",<empty>,,false,432,455,getXMLHeader,,,1,"string(std.string,int)"
111669152419,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"std::string ErrorMessage::getXMLFooter(int xmlVersion)
{
    return xmlVersion == 3 ? ""</results>"" : ""    </errors>\\n</results>"";
}",1,1,lib/errorlogger.cpp,ErrorMessage.getXMLFooter:string(int),<empty>,,false,457,460,getXMLFooter,,,1,string(int)
111669152420,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"std::string ErrorMessage::fixInvalidChars(const std::string& raw)
{
    std::string result;
    result.reserve(raw.length());
    auto from=raw.cbegin();
    while (from!=raw.cend()) {
        if (std::isprint(static_cast<unsigned char>(*from))) {
            result.push_back(*from);
        } else {
            std::ostringstream es;
            // straight cast to (unsigned) doesn't work out.
            const unsigned uFrom = (unsigned char)*from;
            es << '\\\\' << std::setbase(8) << std::setw(3) << std::setfill('0') << uFrom;
            result += es.str();
        }
        ++from;
    }
    return result;
}",1,1,lib/errorlogger.cpp,ErrorMessage.fixInvalidChars:string(std.string&),<empty>,,false,464,482,fixInvalidChars,,,1,string(std.string&)
111669152421,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"std::string ErrorMessage::toXML() const
{
    tinyxml2::XMLPrinter printer(nullptr, false, 2);
    printer.OpenElement(""error"", false);
    printer.PushAttribute(""id"", id.c_str());
    if (!guideline.empty())
        printer.PushAttribute(""guideline"", guideline.c_str());
    printer.PushAttribute(""severity"", severityToString(severity).c_str());
    if (!classification.empty())
        printer.PushAttribute(""classification"", classification.c_str());
    printer.PushAttribute(""msg"", fixInvalidChars(mShortMessage).c_str());
    printer.PushAttribute(""verbose"", fixInvalidChars(mVerboseMessage).c_str());
    if (cwe.id)
        printer.PushAttribute(""cwe"", cwe.id);
    if (hash)
        printer.PushAttribute(""hash"", std::to_string(hash).c_str());
    if (certainty == Certainty::inconclusive)
        printer.PushAttribute(""inconclusive"", ""true"");

    if (!file0.empty())
        printer.PushAttribute(""file0"", file0.c_str());

    if (!remark.empty())
        printer.PushAttribute(""remark""...",1,1,lib/errorlogger.cpp,ErrorMessage.toXML<const>:string(),<empty>,,false,484,534,toXML,,,1,string()
111669152422,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"static std::string readCode(const std::string &file, int linenr, int column, const char endl[])
{
    std::ifstream fin(file);
    std::string line;
    while (linenr > 0 && std::getline(fin,line)) {
        linenr--;
    }
    const std::string::size_type endPos = line.find_last_not_of(""\\r\\n\\t "");
    if (endPos + 1 < line.size())
        line.erase(endPos + 1);
    std::string::size_type pos = 0;
    while ((pos = line.find('\\t', pos)) != std::string::npos)
        line[pos] = ' ';
    return line + endl + std::string((column>0 ? column-1 : 0), ' ') + '^';
}",1,1,lib/errorlogger.cpp,"readCode:string(std.string&,int,int,char[])",<empty>,,false,537,551,readCode,,,1,"string(std.string&,int,int,char[])"
111669152423,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"static void replaceSpecialChars(std::string& source)
{
    // Support a few special characters to allow to specific formatting, see http://sourceforge.net/apps/phpbb/cppcheck/viewtopic.php?f=4&t=494&sid=21715d362c0dbafd3791da4d9522f814
    // Substitution should be done first so messages from cppcheck never get translated.
    static const std::unordered_map<char, std::string> substitutionMap = {
        {'b', ""\\b""},
        {'n', ""\\n""},
        {'r', ""\\r""},
        {'t', ""\\t""}
    };

    std::string::size_type index = 0;
    while ((index = source.find('\\\\', index)) != std::string::npos) {
        const char searchFor = source[index+1];
        const auto it = substitutionMap.find(searchFor);
        if (it == substitutionMap.end()) {
            index += 1;
            continue;
        }
        const std::string& replaceWith = it->second;
        source.replace(index, 2, replaceWith);
        index += replaceWith.length();
    }
}",1,1,lib/errorlogger.cpp,replaceSpecialChars:void(std.string&),<empty>,,false,553,576,replaceSpecialChars,,,1,void(std.string&)
111669152424,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"static void replace(std::string& source, const std::unordered_map<std::string, std::string> &substitutionMap)
{
    std::string::size_type index = 0;
    while ((index = source.find('{', index)) != std::string::npos) {
        const std::string::size_type end = source.find('}', index);
        if (end == std::string::npos)
            break;
        const std::string searchFor = source.substr(index, end-index+1);
        const auto it = substitutionMap.find(searchFor);
        if (it == substitutionMap.end()) {
            index += 1;
            continue;
        }
        const std::string& replaceWith = it->second;
        source.replace(index, searchFor.length(), replaceWith);
        index += replaceWith.length();
    }
}",1,1,lib/errorlogger.cpp,"replace:void(std.string&,std.unordered_map<std.string,std.string>&)",<empty>,,false,578,595,replace,,,1,"void(std.string&,std.unordered_map<std.string,std.string>&)"
111669152425,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"static void replaceColors(std::string& source) {
    // TODO: colors are not applied when either stdout or stderr is not a TTY because we resolve them before the stream usage
    static const std::unordered_map<std::string, std::string> substitutionMap =
    {
        {""{reset}"",   ::toString(Color::Reset)},
        {""{bold}"",    ::toString(Color::Bold)},
        {""{dim}"",     ::toString(Color::Dim)},
        {""{red}"",     ::toString(Color::FgRed)},
        {""{green}"",   ::toString(Color::FgGreen)},
        {""{blue}"",    ::toString(Color::FgBlue)},
        {""{magenta}"", ::toString(Color::FgMagenta)},
        {""{default}"", ::toString(Color::FgDefault)},
    };
    replace(source, substitutionMap);
}",1,1,lib/errorlogger.cpp,replaceColors:void(std.string&),<empty>,,false,597,611,replaceColors,,,1,void(std.string&)
111669152426,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"std::string ErrorMessage::toString(bool verbose, const std::string &templateFormat, const std::string &templateLocation) const
{
    // Save this ErrorMessage in plain text.

    // TODO: should never happen - remove this
    // No template is given
    // (not 100%) equivalent templateFormat: {callstack} ({severity}{inconclusive:, inconclusive}) {message}
    if (templateFormat.empty()) {
        std::string text;
        if (!callStack.empty()) {
            text += ErrorLogger::callStackToString(callStack);
            text += "": "";
        }
        if (severity != Severity::none) {
            text += '(';
            text += severityToString(severity);
            if (certainty == Certainty::inconclusive)
                text += "", inconclusive"";
            text += "") "";
        }
        text += (verbose ? mVerboseMessage : mShortMessage);
        return text;
    }

    // template is given. Reformat the output according to it
    std::string result = templateFormat;

    /...",1,1,lib/errorlogger.cpp,"ErrorMessage.toString<const>:string(bool,std.string&,std.string&)",<empty>,,false,614,713,toString,,,1,"string(bool,std.string&,std.string&)"
111669152427,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"std::string ErrorLogger::callStackToString(const std::list<ErrorMessage::FileLocation> &callStack)
{
    std::string str;
    for (auto tok = callStack.cbegin(); tok != callStack.cend(); ++tok) {
        str += (tok == callStack.cbegin() ? """" : "" -> "");
        str += tok->stringify();
    }
    return str;
}",1,1,lib/errorlogger.cpp,ErrorLogger.callStackToString:string(std.list<ErrorMessage.FileLocation>&),<empty>,,false,715,723,callStackToString,,,1,string(std.list<ErrorMessage.FileLocation>&)
111669152428,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"ErrorMessage::FileLocation::FileLocation(const Token* tok, const TokenList* tokenList)
    : fileIndex(tok->fileIndex()), line(tok->linenr()), column(tok->column()), mOrigFileName(tokenList->getOrigFile(tok)), mFileName(tokenList->file(tok))
{}",1,2,lib/errorlogger.cpp,"ErrorMessage.FileLocation.FileLocation:ANY(Token*,TokenList*)",<empty>,,false,726,728,FileLocation,,,1,"ErrorMessage.FileLocation.FileLocation:ANY(Token*,TokenList*)(Token*,TokenList*)"
111669152429,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"ErrorMessage::FileLocation::FileLocation(const Token* tok, std::string info, const TokenList* tokenList)
    : fileIndex(tok->fileIndex()), line(tok->linenr()), column(tok->column()), mOrigFileName(tokenList->getOrigFile(tok)), mFileName(tokenList->file(tok)), mInfo(std::move(info))
{}",1,2,lib/errorlogger.cpp,"ErrorMessage.FileLocation.FileLocation:ANY(Token*,std.string,TokenList*)",<empty>,,false,730,732,FileLocation,,,1,"ErrorMessage.FileLocation.FileLocation:ANY(Token*,std.string,TokenList*)(Token*,std.string,TokenList*)"
111669152430,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"std::string ErrorMessage::FileLocation::getfile(bool convert) const
{
    if (convert)
        return Path::toNativeSeparators(mFileName);
    return mFileName;
}",1,1,lib/errorlogger.cpp,ErrorMessage.FileLocation.getfile<const>:string(bool),<empty>,,false,734,739,getfile,,,1,string(bool)
111669152431,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"std::string ErrorMessage::FileLocation::getOrigFile(bool convert) const
{
    if (convert)
        return Path::toNativeSeparators(mOrigFileName);
    return mOrigFileName;
}",1,1,lib/errorlogger.cpp,ErrorMessage.FileLocation.getOrigFile<const>:string(bool),<empty>,,false,741,746,getOrigFile,,,1,string(bool)
111669152432,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"void ErrorMessage::FileLocation::setfile(std::string file)
{
    mFileName = Path::simplifyPath(std::move(file));
}",1,1,lib/errorlogger.cpp,ErrorMessage.FileLocation.setfile:void(std.string),<empty>,,false,748,751,setfile,,,1,void(std.string)
111669152433,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"std::string ErrorMessage::FileLocation::stringify() const
{
    std::string str;
    str += '[';
    str += Path::toNativeSeparators(mFileName);
    if (line != SuppressionList::Suppression::NO_LINE) {
        str += ':';
        str += std::to_string(line);
    }
    str += ']';
    return str;
}",1,1,lib/errorlogger.cpp,ErrorMessage.FileLocation.stringify<const>:string(),<empty>,,false,753,764,stringify,,,1,string()
111669152434,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"std::string ErrorLogger::toxml(const std::string &str)
{
    std::string xml;
    for (const unsigned char c : str) {
        switch (c) {
        case '<':
            xml += ""&lt;"";
            break;
        case '>':
            xml += ""&gt;"";
            break;
        case '&':
            xml += ""&amp;"";
            break;
        case '\\""':
            xml += ""&quot;"";
            break;
        case '\\'':
            xml += ""&apos;"";
            break;
        case '\\0':
            xml += ""\\\\0"";
            break;
        default:
            if (c >= ' ' && c <= 0x7f)
                xml += c;
            else
                xml += 'x';
            break;
        }
    }
    return xml;
}",1,1,lib/errorlogger.cpp,ErrorLogger.toxml:string(std.string&),<empty>,,false,766,798,toxml,,,1,string(std.string&)
111669152435,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"std::string ErrorLogger::plistHeader(const std::string &version, const std::vector<std::string> &files)
{
    std::ostringstream ostr;
    ostr << ""<?xml version=\\""1.0\\"" encoding=\\""UTF-8\\""?>\\r\\n""
         << ""<!DOCTYPE plist PUBLIC \\""-//Apple Computer//DTD PLIST 1.0//EN\\"" \\""http://www.apple.com/DTDs/PropertyList-1.0.dtd\\"">\\r\\n""
         << ""<plist version=\\""1.0\\"">\\r\\n""
         << ""<dict>\\r\\n""
         << "" <key>clang_version</key>\\r\\n""
         << ""<string>cppcheck version "" << version << ""</string>\\r\\n""
         << "" <key>files</key>\\r\\n""
         << "" <array>\\r\\n"";
    for (const std::string & file : files)
        ostr << ""  <string>"" << ErrorLogger::toxml(file) << ""</string>\\r\\n"";
    ostr << "" </array>\\r\\n""
         << "" <key>diagnostics</key>\\r\\n""
         << "" <array>\\r\\n"";
    return ostr.str();
}",1,1,lib/errorlogger.cpp,"ErrorLogger.plistHeader:string(std.string&,std.vector<std.string>&)",<empty>,,false,800,817,plistHeader,,,1,"string(std.string&,std.vector<std.string>&)"
111669152436,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"static std::string plistLoc(const char indent[], const ErrorMessage::FileLocation &loc)
{
    std::ostringstream ostr;
    ostr << indent << ""<dict>\\r\\n""
         << indent << ' ' << ""<key>line</key><integer>"" << loc.line << ""</integer>\\r\\n""
         << indent << ' ' << ""<key>col</key><integer>"" << loc.column << ""</integer>\\r\\n""
         << indent << ' ' << ""<key>file</key><integer>"" << loc.fileIndex << ""</integer>\\r\\n""
         << indent << ""</dict>\\r\\n"";
    return ostr.str();
}",1,1,lib/errorlogger.cpp,"plistLoc:string(char[],ErrorMessage.FileLocation&)",<empty>,,false,819,828,plistLoc,,,1,"string(char[],ErrorMessage.FileLocation&)"
111669152437,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"std::string ErrorLogger::plistData(const ErrorMessage &msg)
{
    std::ostringstream plist;
    plist << ""  <dict>\\r\\n""
          << ""   <key>path</key>\\r\\n""
          << ""   <array>\\r\\n"";

    auto prev = msg.callStack.cbegin();

    for (auto it = msg.callStack.cbegin(); it != msg.callStack.cend(); ++it) {
        if (prev != it) {
            plist << ""    <dict>\\r\\n""
                  << ""     <key>kind</key><string>control</string>\\r\\n""
                  << ""     <key>edges</key>\\r\\n""
                  << ""      <array>\\r\\n""
                  << ""       <dict>\\r\\n""
                  << ""        <key>start</key>\\r\\n""
                  << ""         <array>\\r\\n""
                  << plistLoc(""          "", *prev)
                  << plistLoc(""          "", *prev)
                  << ""         </array>\\r\\n""
                  << ""        <key>end</key>\\r\\n""
                  << ""         <array>\\r\\n""
                  << plistLoc(""          "", *it)
                  << plistLoc(""   ...",1,1,lib/errorlogger.cpp,ErrorLogger.plistData:string(ErrorMessage&),<empty>,,false,830,899,plistData,,,1,string(ErrorMessage&)
111669152438,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"std::string replaceStr(std::string s, const std::string &from, const std::string &to)
{
    std::string::size_type pos1 = 0;
    while (pos1 < s.size()) {
        pos1 = s.find(from, pos1);
        if (pos1 == std::string::npos)
            return s;
        if (pos1 > 0 && (s[pos1-1] == '_' || std::isalnum(s[pos1-1]))) {
            pos1++;
            continue;
        }
        const std::string::size_type pos2 = pos1 + from.size();
        if (pos2 >= s.size())
            return s.substr(0,pos1) + to;
        if (s[pos2] == '_' || std::isalnum(s[pos2])) {
            pos1++;
            continue;
        }
        s.replace(pos1, from.size(), to);
        pos1 += to.size();
    }
    return s;
}",1,1,lib/errorlogger.cpp,"replaceStr:string(std.string,std.string&,std.string&)",<empty>,,false,902,924,replaceStr,,,1,"string(std.string,std.string&,std.string&)"
111669152439,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"void substituteTemplateFormatStatic(std::string& templateFormat)
{
    replaceSpecialChars(templateFormat);
    replaceColors(templateFormat);
}",1,1,lib/errorlogger.cpp,substituteTemplateFormatStatic:void(std.string&),<empty>,,false,926,930,substituteTemplateFormatStatic,,,1,void(std.string&)
111669152440,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"void substituteTemplateLocationStatic(std::string& templateLocation)
{
    replaceSpecialChars(templateLocation);
    replaceColors(templateLocation);
}",1,1,lib/errorlogger.cpp,substituteTemplateLocationStatic:void(std.string&),<empty>,,false,932,936,substituteTemplateLocationStatic,,,1,void(std.string&)
111669152441,METHOD,<empty>,<empty>,"[&](const checkers::Info &i) {
            return caseInsensitiveStringCompare(i.guideline, guideline) == 0;
        }",66,9,lib/errorlogger.cpp,lib/errorlogger.cpp:<global>.getClassification.<lambda>0.<lambda>1:bool(checkers.Info&),<empty>,,false,943,945,<lambda>1,,,1,bool(checkers.Info&)
111669152442,METHOD,<empty>,<empty>,"[](const std::vector<checkers::Info> &info, const std::string &guideline) -> std::string {
        const auto it = std::find_if(info.cbegin(), info.cend(), [&](const checkers::Info &i) {
            return caseInsensitiveStringCompare(i.guideline, guideline) == 0;
        });
        if (it == info.cend())
            return """";
        return it->classification;
    }",36,5,lib/errorlogger.cpp,"lib/errorlogger.cpp:<global>.getClassification.<lambda>0:string(std.vector<checkers.Info>&,std.string&)",<empty>,,false,942,949,<lambda>0,,,1,"string(std.vector<checkers.Info>&,std.string&)"
111669152443,METHOD,<empty>,<empty>,"[&](const checkers::MisraInfo &i) {
                return i.a == a && i.b == b;
            }",66,13,lib/errorlogger.cpp,lib/errorlogger.cpp:<global>.getClassification.<lambda>2:bool(checkers.MisraInfo&),<empty>,,false,968,970,<lambda>2,,,1,bool(checkers.MisraInfo&)
111669152444,METHOD,<empty>,<empty>,"[&](const checkers::MisraCppInfo &i) {
                return i.a == a && i.b == b && i.c == c;
            }",68,13,lib/errorlogger.cpp,lib/errorlogger.cpp:<global>.getClassification.<lambda>3:bool(checkers.MisraCppInfo&),<empty>,,false,998,1000,<lambda>3,,,1,bool(checkers.MisraCppInfo&)
111669152445,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"std::string getClassification(const std::string &guideline, ReportType reportType) {
    if (guideline.empty())
        return """";

    const auto getClassification = [](const std::vector<checkers::Info> &info, const std::string &guideline) -> std::string {
        const auto it = std::find_if(info.cbegin(), info.cend(), [&](const checkers::Info &i) {
            return caseInsensitiveStringCompare(i.guideline, guideline) == 0;
        });
        if (it == info.cend())
            return """";
        return it->classification;
    };

    switch (reportType) {
    case ReportType::autosar:
        return getClassification(checkers::autosarInfo, guideline);
    case ReportType::certC:
        return getClassification(checkers::certCInfo, guideline);
    case ReportType::certCpp:
        return getClassification(checkers::certCppInfo, guideline);
    case ReportType::misraC:
    {
        auto components = splitString(guideline, '.');
        if (components.size() != 2)
            re...",1,1,lib/errorlogger.cpp,"getClassification:string(std.string&,ReportType)",<empty>,,false,938,1010,getClassification,,,1,"string(std.string&,ReportType)"
111669152446,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"std::string getGuideline(const std::string &errId, ReportType reportType,
                         const std::map<std::string, std::string> &guidelineMapping,
                         Severity severity)
{
    std::string guideline;

    switch (reportType) {
    case ReportType::autosar:
        if (errId.rfind(""premium-autosar-"", 0) == 0) {
            guideline = errId.substr(16);
            break;
        }
        if (errId.rfind(""premium-misra-cpp-2008-"", 0) == 0)
            guideline = ""M"" + errId.substr(23);
        break;
    case ReportType::certC:
    case ReportType::certCpp:
        if (errId.rfind(""premium-cert-"", 0) == 0) {
            guideline = errId.substr(13);
            std::transform(guideline.begin(), guideline.end(),
                           guideline.begin(), static_cast<int (*)(int)>(std::toupper));
        }
        break;
    case ReportType::misraC:
        if (errId.rfind(""misra-c20"", 0) == 0)
            guideline = errId.substr(errId.rfind('-') + ...",1,1,lib/errorlogger.cpp,"getGuideline:string(std.string&,ReportType,std.map<std.string,std.string>&,Severity)",<empty>,,false,1012,1067,getGuideline,,,1,"string(std.string&,ReportType,std.map<std.string,std.string>&,Severity)"
111669152447,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"std::map<std::string, std::string> createGuidelineMapping(ReportType reportType) {
    std::map<std::string, std::string> guidelineMapping;
    const std::vector<checkers::IdMapping> *idMapping1 = nullptr;
    const std::vector<checkers::IdMapping> *idMapping2 = nullptr;
    std::string ext1, ext2;

    switch (reportType) {
    case ReportType::autosar:
        idMapping1 = &checkers::idMappingAutosar;
        break;
    case ReportType::certCpp:
        idMapping2 = &checkers::idMappingCertCpp;
        ext2 = ""-CPP"";
        FALLTHROUGH;
    case ReportType::certC:
        idMapping1 = &checkers::idMappingCertC;
        ext1 = ""-C"";
        break;
    case ReportType::misraC:
        idMapping1 = &checkers::idMappingMisraC;
        break;
    case ReportType::misraCpp2008:
        idMapping1 = &checkers::idMappingMisraCpp2008;
        break;
    case ReportType::misraCpp2023:
        idMapping1 = &checkers::idMappingMisraCpp2023;
        break;
    default:
        break;
    }

 ...",1,8,lib/errorlogger.cpp,"createGuidelineMapping:map<std.string,std.string>(ReportType)",<empty>,,false,1069,1113,createGuidelineMapping,,,1,"map<std::string,std::string>(ReportType)"
111669152448,METHOD,lib/errorlogger.h:<global>,TYPE_DECL,<global>,1,1,lib/errorlogger.h,lib/errorlogger.h:<global>,<empty>,,false,1,307,<global>,,,1,
111669152449,METHOD,lib/errortypes.cpp:<global>,TYPE_DECL,"static std::string typeToString(InternalError::Type type)
{
    switch (type) {
    case InternalError::Type::AST:
        return ""internalAstError"";
    case InternalError::Type::SYNTAX:
        return ""syntaxError"";
    case InternalError::Type::UNKNOWN_MACRO:
        return ""unknownMacro"";
    case InternalError::Type::INTERNAL:
        return ""internalError"";
    case InternalError::Type::LIMIT:
        return ""cppcheckLimit"";
    case InternalError::Type::INSTANTIATION:
        return ""instantiationError"";
    }
    cppcheck::unreachable();
}",1,1,lib/errortypes.cpp,typeToString:string(InternalError.Type),<empty>,,false,23,40,typeToString,,,1,string(InternalError.Type)
111669152450,METHOD,lib/errortypes.cpp:<global>,TYPE_DECL,<global>,1,1,lib/errortypes.cpp,lib/errortypes.cpp:<global>,<empty>,,false,1,99,<global>,,,1,
111669152451,METHOD,lib/errortypes.cpp:<global>,TYPE_DECL,"InternalError::InternalError(const Token *tok, std::string errorMsg, Type type) :
    InternalError(tok, std::move(errorMsg), """", type)
{}",1,2,lib/errortypes.cpp,"InternalError.InternalError:ANY(Token*,std.string,InternalError.Type)",<empty>,,false,42,44,InternalError,,,1,"InternalError.InternalError:ANY(Token*,std.string,InternalError.Type)(Token*,std.string,InternalError.Type)"
111669152452,METHOD,lib/errortypes.cpp:<global>,TYPE_DECL,"InternalError::InternalError(const Token *tok, std::string errorMsg, std::string details, Type type) :
    token(tok), errorMessage(std::move(errorMsg)), details(std::move(details)), type(type), id(typeToString(type))
{}",1,2,lib/errortypes.cpp,"InternalError.InternalError:ANY(Token*,std.string,std.string,InternalError.Type)",<empty>,,false,46,48,InternalError,,,1,"InternalError.InternalError:ANY(Token*,std.string,std.string,InternalError.Type)(Token*,std.string,std.string,InternalError.Type)"
111669152453,METHOD,lib/errortypes.cpp:<global>,TYPE_DECL,"std::string severityToString(Severity severity)
{
    switch (severity) {
    case Severity::none:
        return """";
    case Severity::error:
        return ""error"";
    case Severity::warning:
        return ""warning"";
    case Severity::style:
        return ""style"";
    case Severity::performance:
        return ""performance"";
    case Severity::portability:
        return ""portability"";
    case Severity::information:
        return ""information"";
    case Severity::debug:
        return ""debug"";
    case Severity::internal:
        return ""internal"";
    }
    throw InternalError(nullptr, ""Unknown severity"");
}",1,1,lib/errortypes.cpp,severityToString:string(Severity),<empty>,,false,50,73,severityToString,,,1,string(Severity)
111669152454,METHOD,lib/errortypes.cpp:<global>,TYPE_DECL,"Severity severityFromString(const std::string& severity)
{
    if (severity.empty())
        return Severity::none;
    if (severity == ""none"")
        return Severity::none;
    if (severity == ""error"")
        return Severity::error;
    if (severity == ""warning"")
        return Severity::warning;
    if (severity == ""style"")
        return Severity::style;
    if (severity == ""performance"")
        return Severity::performance;
    if (severity == ""portability"")
        return Severity::portability;
    if (severity == ""information"")
        return Severity::information;
    if (severity == ""debug"")
        return Severity::debug;
    if (severity == ""internal"")
        return Severity::internal;
    return Severity::none;
}",1,1,lib/errortypes.cpp,severityFromString:Severity(std.string&),<empty>,,false,76,99,severityFromString,,,1,Severity(std.string&)
111669152455,METHOD,lib/errortypes.h:<global>,TYPE_DECL,<global>,1,1,lib/errortypes.h,lib/errortypes.h:<global>,<empty>,,false,1,135,<global>,,,1,
111669152456,METHOD,lib/filesettings.h:<global>,TYPE_DECL,<global>,1,1,lib/filesettings.h,lib/filesettings.h:<global>,<empty>,,false,1,118,<global>,,,1,
111669152457,METHOD,lib/findtoken.cpp:<global>,TYPE_DECL,"static bool findTokensSkipDeadCodeImpl(const Library& library,
                                       T* start,
                                       const Token* end,
                                       const std::function<bool(const Token*)>& pred,
                                       const std::function<bool(T*)>& found,
                                       const std::function<std::vector<MathLib::bigint>(const Token*)>& evaluate,
                                       bool skipUnevaluated)
{
    for (T* tok = start; precedes(tok, end); tok = tok->next()) {
        if (pred(tok)) {
            if (found(tok))
                return true;
        }
        if (Token::Match(tok, ""if|for|while ("") && Token::simpleMatch(tok->linkAt(1), "") {"")) {
            const Token* condTok = getCondTok(tok);
            if (!condTok)
                continue;
            auto result = evaluate(condTok);
            if (result.empty())
                continue;
            if (internal::f...",1,1,lib/findtoken.cpp,"findTokensSkipDeadCodeImpl:bool(Library&,T*,Token*,std.function<bool(constToken*)>&,std.function<bool(T*)>&,std.function<std.vector<MathLib.bigint>(constToken*)>&,bool)",<empty>,,false,27,121,findTokensSkipDeadCodeImpl,,,1,"bool(Library&,T*,Token*,std.function<bool(constToken*)>&,std.function<bool(T*)>&,std.function<std.vector<MathLib.bigint>(constToken*)>&,bool)"
111669152458,METHOD,lib/findtoken.cpp:<global>,TYPE_DECL,<global>,1,1,lib/findtoken.cpp,lib/findtoken.cpp:<global>,<empty>,,false,1,145,<global>,,,1,
111669152459,METHOD,lib/findtoken.cpp:<global>,TYPE_DECL,"bool findTokensSkipDeadCodeImpl(const Library& library,
                                    Token* start,
                                    const Token* end,
                                    const std::function<bool(const Token*)>& pred,
                                    const std::function<bool(Token*)>& found,
                                    const std::function<std::vector<MathLib::bigint>(const Token*)>& evaluate,
                                    bool skipUnevaluated)
    {
        return ::findTokensSkipDeadCodeImpl(library, start, end, pred, found, evaluate, skipUnevaluated);
    }",5,5,lib/findtoken.cpp,"internal.findTokensSkipDeadCodeImpl:bool(Library&,Token*,Token*,std.function<bool(constToken*)>&,std.function<bool(Token*)>&,std.function<std.vector<MathLib.bigint>(constToken*)>&,bool)",<empty>,,false,124,133,findTokensSkipDeadCodeImpl,,,1,"bool(Library&,Token*,Token*,std.function<bool(constToken*)>&,std.function<bool(Token*)>&,std.function<std.vector<MathLib.bigint>(constToken*)>&,bool)"
111669152460,METHOD,lib/findtoken.cpp:<global>,TYPE_DECL,"bool findTokensSkipDeadCodeImpl(const Library& library,
                                    const Token* start,
                                    const Token* end,
                                    const std::function<bool(const Token*)>& pred,
                                    const std::function<bool(const Token*)>& found,
                                    const std::function<std::vector<MathLib::bigint>(const Token*)>& evaluate,
                                    bool skipUnevaluated)
    {
        return ::findTokensSkipDeadCodeImpl(library, start, end, pred, found, evaluate, skipUnevaluated);
    }",5,5,lib/findtoken.cpp,"internal.findTokensSkipDeadCodeImpl:bool(Library&,Token*,Token*,std.function<bool(constToken*)>&,std.function<bool(constToken*)>&,std.function<std.vector<MathLib.bigint>(constToken*)>&,bool)",<empty>,,false,135,144,findTokensSkipDeadCodeImpl,,,1,"bool(Library&,Token*,Token*,std.function<bool(constToken*)>&,std.function<bool(constToken*)>&,std.function<std.vector<MathLib.bigint>(constToken*)>&,bool)"
111669152461,METHOD,lib/findtoken.h:<global>,TYPE_DECL,<global>,1,1,lib/findtoken.h,lib/findtoken.h:<global>,<empty>,,false,1,173,<global>,,,1,
111669152462,METHOD,ForwardTraversal.Branch,TYPE_DECL,explicit Branch(Token* tok = nullptr) : endBlock(tok) {},13,68,lib/forwardanalyzer.cpp,ForwardTraversal.Branch.Branch:ANY(Token*),<empty>,,false,71,71,Branch,,,1,ForwardTraversal.Branch.Branch:ANY(Token*)(Token*)
111669152463,METHOD,ForwardTraversal.Branch,TYPE_DECL,"bool isEscape() const {
                return escape || escapeUnknown;
            }",13,13,lib/forwardanalyzer.cpp,ForwardTraversal.Branch.isEscape<const>:bool(),<empty>,,false,78,80,isEscape,,,8,bool()
111669152464,METHOD,ForwardTraversal.Branch,TYPE_DECL,"bool isConclusiveEscape() const {
                return escape && !escapeUnknown;
            }",13,13,lib/forwardanalyzer.cpp,ForwardTraversal.Branch.isConclusiveEscape<const>:bool(),<empty>,,false,81,83,isConclusiveEscape,,,9,bool()
111669152465,METHOD,ForwardTraversal.Branch,TYPE_DECL,"bool isModified() const {
                return action.isModified() && !isConclusiveEscape();
            }",13,13,lib/forwardanalyzer.cpp,ForwardTraversal.Branch.isModified<const>:bool(),<empty>,,false,84,86,isModified,,,10,bool()
111669152466,METHOD,ForwardTraversal.Branch,TYPE_DECL,"bool isInconclusive() const {
                return action.isInconclusive() && !isConclusiveEscape();
            }",13,13,lib/forwardanalyzer.cpp,ForwardTraversal.Branch.isInconclusive<const>:bool(),<empty>,,false,87,89,isInconclusive,,,11,bool()
111669152467,METHOD,ForwardTraversal.Branch,TYPE_DECL,"bool isDead() const {
                return action.isModified() || action.isInconclusive() || isEscape();
            }",13,13,lib/forwardanalyzer.cpp,ForwardTraversal.Branch.isDead<const>:bool(),<empty>,,false,90,92,isDead,,,12,bool()
111669152468,METHOD,<empty>,<empty>,<empty>,9,,lib/forwardanalyzer.cpp,ForwardTraversal.Branch.<clinit>,<empty>,,false,70,,<clinit>,,,13,
111669152469,METHOD,<empty>,<empty>,"[](const Token* tok) {
                return tok->isIncompleteVar();
            }",67,13,lib/forwardanalyzer.cpp,lib/forwardanalyzer.cpp:<global>.ForwardTraversal.stopOnCondition<const>.<lambda>0:bool(Token*),<empty>,,false,102,104,<lambda>0,,,1,bool(Token*)
111669152470,METHOD,<empty>,<empty>,"[](MathLib::bigint x) {
                return x != 0;
            }",80,13,lib/forwardanalyzer.cpp,lib/forwardanalyzer.cpp:<global>.ForwardTraversal.evalCond<const>.<lambda>1:bool(MathLib.bigint),<empty>,,false,114,116,<lambda>1,,,1,bool(MathLib.bigint)
111669152471,METHOD,<empty>,<empty>,"[](MathLib::bigint x) {
                return x == 0;
            }",80,13,lib/forwardanalyzer.cpp,lib/forwardanalyzer.cpp:<global>.ForwardTraversal.evalCond<const>.<lambda>2:bool(MathLib.bigint),<empty>,,false,117,119,<lambda>2,,,1,bool(MathLib.bigint)
111669152472,METHOD,<empty>,<empty>,"[this](Token* tok2) {
                return update(tok2);
            }",22,13,lib/forwardanalyzer.cpp,lib/forwardanalyzer.cpp:<global>.ForwardTraversal.updateTok.<lambda>3:ForwardTraversal.Progress(Token*),<empty>,,false,250,252,<lambda>3,,,1,ForwardTraversal.Progress(Token*)
111669152473,METHOD,<empty>,<empty>,"[this](Token* tok2) {
                return update(tok2);
            }",22,13,lib/forwardanalyzer.cpp,lib/forwardanalyzer.cpp:<global>.ForwardTraversal.updateRecursive.<lambda>4:ForwardTraversal.Progress(Token*),<empty>,,false,257,259,<lambda>4,,,1,ForwardTraversal.Progress(Token*)
111669152474,METHOD,<empty>,<empty>,"[&](const Token* tok) {
                result = analyzer->analyze(tok, Analyzer::Direction::Forward);
                if (result.isModified() || result.isInconclusive())
                    return Break();
                return Progress::Continue;
            }",22,13,lib/forwardanalyzer.cpp,lib/forwardanalyzer.cpp:<global>.ForwardTraversal.analyzeRecursive.<lambda>5:ForwardTraversal.Progress(Token*),<empty>,,false,265,270,<lambda>5,,,1,ForwardTraversal.Progress(Token*)
111669152475,METHOD,<empty>,<empty>,"[&](const Token* tok) {
                return isVariableChanged(tok, 0, settings);
            }",49,13,lib/forwardanalyzer.cpp,lib/forwardanalyzer.cpp:<global>.ForwardTraversal.reentersLoop<const>.<lambda>6:bool(Token*),<empty>,,false,395,397,<lambda>6,,,1,bool(Token*)
111669152476,METHOD,<empty>,<empty>,"[&] {
                    loopEnds.pop_back();
                }",23,17,lib/forwardanalyzer.cpp,lib/forwardanalyzer.cpp:<global>.ForwardTraversal.updateInnerLoop.<lambda>7:void(),<empty>,,false,408,410,<lambda>7,,,1,void()
111669152477,METHOD,ForwardTraversal,TYPE_DECL,"ForwardTraversal(const ValuePtr<Analyzer>& analyzer, const TokenList& tokenList, ErrorLogger& errorLogger, const Settings& settings)
            : analyzer(analyzer), tokenList(tokenList), errorLogger(errorLogger), settings(settings)
        {}",9,10,lib/forwardanalyzer.cpp,"ForwardTraversal.ForwardTraversal:ANY(ValuePtr<Analyzer>&,TokenList&,ErrorLogger&,Settings&)",<empty>,,false,50,52,ForwardTraversal,,,2,"ForwardTraversal.ForwardTraversal:ANY(ValuePtr<Analyzer>&,TokenList&,ErrorLogger&,Settings&)(ValuePtr<Analyzer>&,TokenList&,ErrorLogger&,Settings&)"
111669152478,METHOD,ForwardTraversal,TYPE_DECL,"Progress Break(Analyzer::Terminate t = Analyzer::Terminate::None) {
            if ((!analyzeOnly || analyzeTerminate) && t != Analyzer::Terminate::None)
                terminate = t;
            return Progress::Break;
        }",9,9,lib/forwardanalyzer.cpp,ForwardTraversal.Break:ForwardTraversal.Progress(Analyzer.Terminate),<empty>,,false,64,68,Break,,,13,ForwardTraversal.Progress(Analyzer.Terminate)
111669152479,METHOD,ForwardTraversal,TYPE_DECL,"bool stopUpdates() {
            analyzeOnly = true;
            return actions.isModified();
        }",9,9,lib/forwardanalyzer.cpp,ForwardTraversal.stopUpdates:bool(),<empty>,,false,95,98,stopUpdates,,,15,bool()
111669152480,METHOD,ForwardTraversal,TYPE_DECL,"bool stopOnCondition(const Token* condTok) const
        {
            if (analyzer->isConditional() && findAstNode(condTok, [](const Token* tok) {
                return tok->isIncompleteVar();
            }))
                return true;
            return analyzer->stopOnCondition(condTok);
        }",9,9,lib/forwardanalyzer.cpp,ForwardTraversal.stopOnCondition<const>:bool(Token*),<empty>,,false,100,107,stopOnCondition,,,16,bool(Token*)
111669152481,METHOD,ForwardTraversal,TYPE_DECL,"std::pair<bool, bool> evalCond(const Token* tok, const Token* ctx = nullptr) const {
            if (!tok)
                return std::make_pair(false, false);
            std::vector<MathLib::bigint> result = analyzer->evaluate(tok, ctx);
            // TODO: We should convert to bool
            const bool checkThen = std::any_of(result.cbegin(), result.cend(), [](MathLib::bigint x) {
                return x != 0;
            });
            const bool checkElse = std::any_of(result.cbegin(), result.cend(), [](MathLib::bigint x) {
                return x == 0;
            });
            return std::make_pair(checkThen, checkElse);
        }",9,9,lib/forwardanalyzer.cpp,"ForwardTraversal.evalCond<const>:pair<bool,bool>(Token*,Token*)",<empty>,,false,109,121,evalCond,,,17,"pair<bool,bool>(Token*,Token*)"
111669152482,METHOD,ForwardTraversal,TYPE_DECL,"bool isConditionTrue(const Token* tok, const Token* ctx = nullptr) const {
            return evalCond(tok, ctx).first;
        }",9,9,lib/forwardanalyzer.cpp,"ForwardTraversal.isConditionTrue<const>:bool(Token*,Token*)",<empty>,,false,123,125,isConditionTrue,,,18,"bool(Token*,Token*)"
111669152483,METHOD,ForwardTraversal,TYPE_DECL,"Progress traverseTok(T* tok, const F &f, bool traverseUnknown, T** out = nullptr) {
            if (Token::Match(tok, ""asm|goto""))
                return Break(Analyzer::Terminate::Bail);
            if (Token::Match(tok, ""setjmp|longjmp ("")) {
                // Traverse the parameters of the function before escaping
                traverseRecursive(tok->next()->astOperand2(), f, traverseUnknown);
                return Break(Analyzer::Terminate::Bail);
            }
            if (Token::simpleMatch(tok, ""continue"")) {
                if (loopEnds.empty())
                    return Break(Analyzer::Terminate::Escape);
                // If we are in a loop then jump to the end
                if (out)
                    *out = loopEnds.back();
            } else if (Token::Match(tok, ""return|throw"")) {
                traverseRecursive(tok->astOperand2(), f, traverseUnknown);
                traverseRecursive(tok->astOperand1(), f, traverseUnknown);
                return Break...",9,9,lib/forwardanalyzer.cpp,"ForwardTraversal.traverseTok:Progress(T*,F&,bool,T**)",<empty>,,false,128,175,traverseTok,,,19,"Progress(T*,F&,bool,T**)"
111669152484,METHOD,ForwardTraversal,TYPE_DECL,"Progress traverseRecursive(T* tok, const F &f, bool traverseUnknown, unsigned int recursion=0) {
            if (!tok)
                return Progress::Continue;
            if (recursion > 10000)
                return Progress::Skip;
            T* firstOp = tok->astOperand1();
            T* secondOp = tok->astOperand2();
            // Evaluate:
            //     1. RHS of assignment before LHS
            //     2. Unary op before operand
            //     3. Function arguments before function call
            if (tok->isAssignmentOp() || !secondOp || isFunctionCall(tok))
                std::swap(firstOp, secondOp);
            if (firstOp && traverseRecursive(firstOp, f, traverseUnknown, recursion+1) == Progress::Break)
                return Break();
            const Progress p = tok->isAssignmentOp() ? Progress::Continue : traverseTok(tok, f, traverseUnknown);
            if (p == Progress::Break)
                return Break();
            if (p == Progress::Continue &&...",9,9,lib/forwardanalyzer.cpp,"ForwardTraversal.traverseRecursive:Progress(T*,F&,bool,unsigned int)",<empty>,,false,178,201,traverseRecursive,,,20,"Progress(T*,F&,bool,unsigned int)"
111669152485,METHOD,ForwardTraversal,TYPE_DECL,"Progress traverseConditional(T* tok, F f, bool traverseUnknown) {
            if (Token::Match(tok, ""?|&&|%oror%"") && tok->astOperand1() && tok->astOperand2()) {
                const T* condTok = tok->astOperand1();
                T* childTok = tok->astOperand2();
                bool checkThen, checkElse;
                std::tie(checkThen, checkElse) = evalCond(condTok);
                if (!checkThen && !checkElse) {
                    if (!traverseUnknown && stopOnCondition(condTok) && stopUpdates()) {
                        return Progress::Continue;
                    }
                    checkThen = true;
                    checkElse = true;
                }
                if (childTok->str() == "":"") {
                    if (checkThen && traverseRecursive(childTok->astOperand1(), f, traverseUnknown) == Progress::Break)
                        return Break();
                    if (checkElse && traverseRecursive(childTok->astOperand2(), f, traverseUnknown) == Progre...",9,9,lib/forwardanalyzer.cpp,"ForwardTraversal.traverseConditional:Progress(T*,F,bool)",<empty>,,false,204,232,traverseConditional,,,21,"Progress(T*,F,bool)"
111669152486,METHOD,ForwardTraversal,TYPE_DECL,"Progress update(Token* tok) {
            Analyzer::Action action = analyzer->analyze(tok, Analyzer::Direction::Forward);
            actions |= action;
            if (!action.isNone() && !analyzeOnly)
                analyzer->update(tok, action, Analyzer::Direction::Forward);
            if (action.isInconclusive() && !analyzer->lowerToInconclusive())
                return Break(Analyzer::Terminate::Inconclusive);
            if (action.isInvalid())
                return Break(Analyzer::Terminate::Modified);
            if (action.isWrite() && !action.isRead())
                // Analysis of this write will continue separately
                return Break(Analyzer::Terminate::Modified);
            return Progress::Continue;
        }",9,9,lib/forwardanalyzer.cpp,ForwardTraversal.update:ForwardTraversal.Progress(Token*),<empty>,,false,234,247,update,,,22,ForwardTraversal.Progress(Token*)
111669152487,METHOD,ForwardTraversal,TYPE_DECL,"Progress updateTok(Token* tok, Token** out = nullptr) {
            auto f = [this](Token* tok2) {
                return update(tok2);
            };
            return traverseTok(tok, f, false, out);
        }",9,9,lib/forwardanalyzer.cpp,"ForwardTraversal.updateTok:ForwardTraversal.Progress(Token*,Token**)",<empty>,,false,249,254,updateTok,,,23,"ForwardTraversal.Progress(Token*,Token**)"
111669152488,METHOD,ForwardTraversal,TYPE_DECL,"Progress updateRecursive(Token* tok) {
            auto f = [this](Token* tok2) {
                return update(tok2);
            };
            return traverseRecursive(tok, f, false);
        }",9,9,lib/forwardanalyzer.cpp,ForwardTraversal.updateRecursive:ForwardTraversal.Progress(Token*),<empty>,,false,256,261,updateRecursive,,,24,ForwardTraversal.Progress(Token*)
111669152489,METHOD,ForwardTraversal,TYPE_DECL,"Analyzer::Action analyzeRecursive(const Token* start) {
            Analyzer::Action result = Analyzer::Action::None;
            auto f = [&](const Token* tok) {
                result = analyzer->analyze(tok, Analyzer::Direction::Forward);
                if (result.isModified() || result.isInconclusive())
                    return Break();
                return Progress::Continue;
            };
            traverseRecursive(start, f, true);
            return result;
        }",9,9,lib/forwardanalyzer.cpp,ForwardTraversal.analyzeRecursive:Analyzer.Action(Token*),<empty>,,false,263,273,analyzeRecursive,,,25,Analyzer.Action(Token*)
111669152490,METHOD,ForwardTraversal,TYPE_DECL,"Analyzer::Action analyzeRange(const Token* start, const Token* end) const {
            Analyzer::Action result = Analyzer::Action::None;
            for (const Token* tok = start; tok && tok != end; tok = tok->next()) {
                Analyzer::Action action = analyzer->analyze(tok, Analyzer::Direction::Forward);
                if (action.isModified() || action.isInconclusive())
                    return action;
                result |= action;
            }
            return result;
        }",9,9,lib/forwardanalyzer.cpp,"ForwardTraversal.analyzeRange<const>:Analyzer.Action(Token*,Token*)",<empty>,,false,275,284,analyzeRange,,,26,"Analyzer.Action(Token*,Token*)"
111669152491,METHOD,ForwardTraversal,TYPE_DECL,"ForwardTraversal fork(bool analyze = false) const {
            ForwardTraversal ft = *this;
            if (analyze) {
                ft.analyzeOnly = true;
                ft.analyzeTerminate = true;
            }
            ft.actions = Analyzer::Action::None;
            return ft;
        }",9,9,lib/forwardanalyzer.cpp,ForwardTraversal.fork<const>:ForwardTraversal(bool),<empty>,,false,286,294,fork,,,27,ForwardTraversal(bool)
111669152492,METHOD,ForwardTraversal,TYPE_DECL,"std::vector<ForwardTraversal> tryForkScope(Token* endBlock, bool isModified = false) const {
            if (analyzer->updateScope(endBlock, isModified)) {
                ForwardTraversal ft = fork();
                return {std::move(ft)};
            }
            return std::vector<ForwardTraversal> {};
        }",9,9,lib/forwardanalyzer.cpp,"ForwardTraversal.tryForkScope<const>:vector<ForwardTraversal>(Token*,bool)",<empty>,,false,296,302,tryForkScope,,,28,"vector<ForwardTraversal>(Token*,bool)"
111669152493,METHOD,ForwardTraversal,TYPE_DECL,"std::vector<ForwardTraversal> tryForkUpdateScope(Token* endBlock, bool isModified = false) const {
            std::vector<ForwardTraversal> result = tryForkScope(endBlock, isModified);
            for (ForwardTraversal& ft : result)
                ft.updateScope(endBlock);
            return result;
        }",9,9,lib/forwardanalyzer.cpp,"ForwardTraversal.tryForkUpdateScope<const>:vector<ForwardTraversal>(Token*,bool)",<empty>,,false,304,309,tryForkUpdateScope,,,29,"vector<ForwardTraversal>(Token*,bool)"
111669152494,METHOD,ForwardTraversal,TYPE_DECL,"static bool hasGoto(const Token* endBlock) {
            return Token::findsimplematch(endBlock->link(), ""goto"", endBlock);
        }",9,9,lib/forwardanalyzer.cpp,ForwardTraversal.hasGoto:bool(Token*),<empty>,,false,311,313,hasGoto,,,30,bool(Token*)
111669152495,METHOD,ForwardTraversal,TYPE_DECL,"static bool hasJump(const Token* endBlock) {
            return Token::findmatch(endBlock->link(), ""goto|break"", endBlock);
        }",9,9,lib/forwardanalyzer.cpp,ForwardTraversal.hasJump:bool(Token*),<empty>,,false,315,317,hasJump,,,31,bool(Token*)
111669152496,METHOD,ForwardTraversal,TYPE_DECL,"bool hasInnerReturnScope(const Token* start, const Token* end) const {
            for (const Token* tok=start; tok != end; tok = tok->previous()) {
                if (Token::simpleMatch(tok, ""}"")) {
                    const Token* ftok = nullptr;
                    const bool r = isReturnScope(tok, settings.library, &ftok);
                    if (r)
                        return true;
                }
            }
            return false;
        }",9,9,lib/forwardanalyzer.cpp,"ForwardTraversal.hasInnerReturnScope<const>:bool(Token*,Token*)",<empty>,,false,319,329,hasInnerReturnScope,,,32,"bool(Token*,Token*)"
111669152497,METHOD,ForwardTraversal,TYPE_DECL,"bool isEscapeScope(const Token* endBlock, bool& unknown) const {
            const Token* ftok = nullptr;
            const bool r = isReturnScope(endBlock, settings.library, &ftok);
            if (!r && ftok)
                unknown = true;
            return r;
        }",9,9,lib/forwardanalyzer.cpp,"ForwardTraversal.isEscapeScope<const>:bool(Token*,bool&)",<empty>,,false,331,337,isEscapeScope,,,33,"bool(Token*,bool&)"
111669152498,METHOD,ForwardTraversal,TYPE_DECL,"Analyzer::Action analyzeScope(const Token* endBlock) const {
            return analyzeRange(endBlock->link(), endBlock);
        }",9,9,lib/forwardanalyzer.cpp,ForwardTraversal.analyzeScope<const>:Analyzer.Action(Token*),<empty>,,false,339,341,analyzeScope,,,34,Analyzer.Action(Token*)
111669152499,METHOD,ForwardTraversal,TYPE_DECL,"Analyzer::Action checkScope(Token* endBlock) const {
            Analyzer::Action a = analyzeScope(endBlock);
            tryForkUpdateScope(endBlock, a.isModified());
            return a;
        }",9,9,lib/forwardanalyzer.cpp,ForwardTraversal.checkScope<const>:Analyzer.Action(Token*),<empty>,,false,343,347,checkScope,,,35,Analyzer.Action(Token*)
111669152500,METHOD,ForwardTraversal,TYPE_DECL,"Analyzer::Action checkScope(const Token* endBlock) const {
            Analyzer::Action a = analyzeScope(endBlock);
            return a;
        }",9,9,lib/forwardanalyzer.cpp,ForwardTraversal.checkScope<const><duplicate>0:Analyzer.Action(Token*),<empty>,,false,349,352,checkScope,,,36,Analyzer.Action(Token*)
111669152501,METHOD,ForwardTraversal,TYPE_DECL,"bool checkBranch(Branch& branch) const {
            Analyzer::Action a = analyzeScope(branch.endBlock);
            branch.action = a;
            std::vector<ForwardTraversal> ft1 = tryForkUpdateScope(branch.endBlock, a.isModified());
            const bool bail = hasGoto(branch.endBlock);
            if (!a.isModified() && !bail) {
                if (ft1.empty()) {
                    // Traverse into the branch to see if there is a conditional escape
                    if (!branch.escape && hasInnerReturnScope(branch.endBlock->previous(), branch.endBlock->link())) {
                        ForwardTraversal ft2 = fork(true);
                        ft2.updateScope(branch.endBlock);
                        if (ft2.terminate == Analyzer::Terminate::Escape) {
                            branch.escape = true;
                            branch.escapeUnknown = false;
                        }
                    }
                } else {
                    if (ft1.front().terminat...",9,9,lib/forwardanalyzer.cpp,ForwardTraversal.checkBranch<const>:bool(ForwardTraversal.Branch&),<empty>,,false,354,378,checkBranch,,,37,bool(ForwardTraversal.Branch&)
111669152502,METHOD,ForwardTraversal,TYPE_DECL,"bool reentersLoop(Token* endBlock, const Token* condTok, const Token* stepTok) const {
            if (!condTok)
                return true;
            if (Token::simpleMatch(condTok, "":""))
                return true;
            bool stepChangesCond = false;
            if (stepTok) {
                std::pair<const Token*, const Token*> exprToks = stepTok->findExpressionStartEndTokens();
                if (exprToks.first != nullptr && exprToks.second != nullptr)
                    stepChangesCond |=
                        findExpressionChanged(condTok, exprToks.first, exprToks.second->next(), settings) != nullptr;
            }
            const bool bodyChangesCond = findExpressionChanged(condTok, endBlock->link(), endBlock, settings);
            // Check for mutation in the condition
            const bool condChanged =
                nullptr != findAstNode(condTok, [&](const Token* tok) {
                return isVariableChanged(tok, 0, settings);
            });
      ...",9,9,lib/forwardanalyzer.cpp,"ForwardTraversal.reentersLoop<const>:bool(Token*,Token*,Token*)",<empty>,,false,380,404,reentersLoop,,,38,"bool(Token*,Token*,Token*)"
111669152503,METHOD,ForwardTraversal,TYPE_DECL,"Progress updateInnerLoop(Token* endBlock, Token* stepTok, Token* condTok) {
            loopEnds.push_back(endBlock);
            OnExit oe{[&] {
                    loopEnds.pop_back();
                }};
            if (endBlock && updateScope(endBlock) == Progress::Break)
                return Break();
            if (stepTok && updateRecursive(stepTok) == Progress::Break)
                return Break();
            if (condTok && !Token::simpleMatch(condTok, "":"") && updateRecursive(condTok) == Progress::Break)
                return Break();
            return Progress::Continue;
        }",9,9,lib/forwardanalyzer.cpp,"ForwardTraversal.updateInnerLoop:ForwardTraversal.Progress(Token*,Token*,Token*)",<empty>,,false,406,418,updateInnerLoop,,,39,"ForwardTraversal.Progress(Token*,Token*,Token*)"
111669152504,METHOD,ForwardTraversal,TYPE_DECL,"Progress updateLoop(const Token* endToken,
                            Token* endBlock,
                            Token* condTok,
                            Token* initTok = nullptr,
                            Token* stepTok = nullptr,
                            bool exit = false) {
            if (initTok && updateRecursive(initTok) == Progress::Break)
                return Break();
            const bool isDoWhile = precedes(endBlock, condTok);
            bool checkThen = true;
            bool checkElse = false;
            if (condTok && !Token::simpleMatch(condTok, "":""))
                std::tie(checkThen, checkElse) = evalCond(condTok, isDoWhile ? endBlock->previous() : nullptr);
            // exiting a do while(false)
            if (checkElse && exit) {
                if (hasJump(endBlock)) {
                    if (!analyzer->lowerToPossible())
                        return Break(Analyzer::Terminate::Bail);
                    if (analyzer->isConditional() && stop...",9,9,lib/forwardanalyzer.cpp,"ForwardTraversal.updateLoop:ForwardTraversal.Progress(Token*,Token*,Token*,Token*,Token*,bool)",<empty>,,false,420,523,updateLoop,,,40,"ForwardTraversal.Progress(Token*,Token*,Token*,Token*,Token*,bool)"
111669152505,METHOD,ForwardTraversal,TYPE_DECL,"Progress updateLoopExit(const Token* endToken,
                                Token* endBlock,
                                Token* condTok,
                                Token* initTok = nullptr,
                                Token* stepTok = nullptr) {
            return updateLoop(endToken, endBlock, condTok, initTok, stepTok, true);
        }",9,9,lib/forwardanalyzer.cpp,"ForwardTraversal.updateLoopExit:ForwardTraversal.Progress(Token*,Token*,Token*,Token*,Token*)",<empty>,,false,525,531,updateLoopExit,,,41,"ForwardTraversal.Progress(Token*,Token*,Token*,Token*,Token*)"
111669152506,METHOD,ForwardTraversal,TYPE_DECL,"Progress updateScope(Token* endBlock, int depth = 20)
        {
            if (!endBlock)
                return Break();
            assert(endBlock->link());
            Token* ctx = endBlock->link()->previous();
            if (Token::simpleMatch(ctx, "")""))
                ctx = ctx->link()->previous();
            if (ctx)
                analyzer->updateState(ctx);
            return updateRange(endBlock->link(), endBlock, depth);
        }",9,9,lib/forwardanalyzer.cpp,"ForwardTraversal.updateScope:ForwardTraversal.Progress(Token*,int)",<empty>,,false,533,544,updateScope,,,42,"ForwardTraversal.Progress(Token*,int)"
111669152507,METHOD,ForwardTraversal,TYPE_DECL,"Progress updateRange(Token* start, const Token* end, int depth = 20) {
            if (depth < 0)
                return Break(Analyzer::Terminate::Bail);
            std::size_t i = 0;
            for (Token* tok = start; precedes(tok, end); tok = tok->next()) {
                Token* next = nullptr;
                if (tok->index() <= i)
                    throw InternalError(tok, ""Cyclic forward analysis."");
                i = tok->index();

                if (tok->link()) {
                    // Skip casts..
                    if (tok->str() == ""("" && !tok->astOperand2() && tok->isCast()) {
                        tok = tok->link();
                        continue;
                    }
                    // Skip template arguments..
                    if (tok->str() == ""<"") {
                        tok = tok->link();
                        continue;
                    }
                }

                // Evaluate RHS of assignment before LHS
                if (To...",9,9,lib/forwardanalyzer.cpp,"ForwardTraversal.updateRange:ForwardTraversal.Progress(Token*,Token*,int)",<empty>,,false,546,837,updateRange,,,43,"ForwardTraversal.Progress(Token*,Token*,int)"
111669152508,METHOD,ForwardTraversal,TYPE_DECL,"void reportError(Severity severity, const std::string& id, const std::string& msg) {
            ErrorMessage::FileLocation loc(tokenList.getSourceFilePath(), 0, 0);
            const ErrorMessage errmsg({std::move(loc)}, tokenList.getSourceFilePath(), severity, msg, id, Certainty::normal);
            errorLogger.reportErr(errmsg);
        }",9,9,lib/forwardanalyzer.cpp,"ForwardTraversal.reportError:void(Severity,std.string&,std.string&)",<empty>,,false,839,843,reportError,,,44,"void(Severity,std.string&,std.string&)"
111669152509,METHOD,ForwardTraversal,TYPE_DECL,"static bool isFunctionCall(const Token* tok)
        {
            if (!Token::simpleMatch(tok, ""(""))
                return false;
            if (tok->isCast())
                return false;
            if (!tok->isBinaryOp())
                return false;
            if (Token::simpleMatch(tok->link(), "") {""))
                return false;
            if (isUnevaluated(tok->previous()))
                return false;
            return Token::Match(tok->previous(), ""%name%|)|]|>"");
        }",9,9,lib/forwardanalyzer.cpp,ForwardTraversal.isFunctionCall:bool(Token*),<empty>,,false,845,858,isFunctionCall,,,45,bool(Token*)
111669152510,METHOD,ForwardTraversal,TYPE_DECL,"static Token* assignExpr(Token* tok) {
            while (tok->astParent() && astIsLHS(tok)) {
                if (tok->astParent()->isAssignmentOp())
                    return tok->astParent();
                tok = tok->astParent();
            }
            return nullptr;
        }",9,9,lib/forwardanalyzer.cpp,ForwardTraversal.assignExpr:Token*(Token*),<empty>,,false,860,867,assignExpr,,,46,Token*(Token*)
111669152511,METHOD,ForwardTraversal,TYPE_DECL,"static Token* callExpr(Token* tok)
        {
            while (tok->astParent() && astIsLHS(tok)) {
                if (!Token::Match(tok, ""%name%|::|<|.""))
                    break;
                if (Token::simpleMatch(tok, ""<"") && !tok->link())
                    break;
                tok = tok->astParent();
            }
            if (isFunctionCall(tok))
                return tok;
            return nullptr;
        }",9,9,lib/forwardanalyzer.cpp,ForwardTraversal.callExpr:Token*(Token*),<empty>,,false,869,881,callExpr,,,47,Token*(Token*)
111669152512,METHOD,ForwardTraversal,TYPE_DECL,"static Token* skipTo(Token* tok, const Token* dest, const Token* end = nullptr) {
            if (end && dest->index() > end->index())
                return nullptr;
            const int i = dest->index() - tok->index();
            if (i > 0)
                return tok->tokAt(dest->index() - tok->index());
            return nullptr;
        }",9,9,lib/forwardanalyzer.cpp,"ForwardTraversal.skipTo:Token*(Token*,Token*,Token*)",<empty>,,false,883,890,skipTo,,,48,"Token*(Token*,Token*,Token*)"
111669152513,METHOD,ForwardTraversal,TYPE_DECL,"static Token* getStepTokFromEnd(Token* tok) {
            if (!Token::simpleMatch(tok, ""}""))
                return nullptr;
            Token* end = tok->link()->previous();
            if (!Token::simpleMatch(end, "")""))
                return nullptr;
            return getStepTok(end->link());
        }",9,9,lib/forwardanalyzer.cpp,ForwardTraversal.getStepTokFromEnd:Token*(Token*),<empty>,,false,892,899,getStepTokFromEnd,,,49,Token*(Token*)
111669152514,METHOD,<empty>,<empty>,<empty>,5,,lib/forwardanalyzer.cpp,ForwardTraversal.<clinit>,<empty>,,false,48,,<clinit>,,,50,
111669152515,METHOD,lib/forwardanalyzer.cpp:<global>,TYPE_DECL,"Analyzer::Result valueFlowGenericForward(Token* start, const Token* end, const ValuePtr<Analyzer>& a, const TokenList& tokenList, ErrorLogger& errorLogger, const Settings& settings)
{
    if (a->invalid())
        return Analyzer::Result{Analyzer::Action::None, Analyzer::Terminate::Bail};
    ForwardTraversal ft{a, tokenList, errorLogger, settings};
    if (start)
        ft.analyzer->updateState(start);
    ft.updateRange(start, end);
    return Analyzer::Result{ ft.actions, ft.terminate };
}",1,1,lib/forwardanalyzer.cpp,"valueFlowGenericForward:Analyzer.Result(Token*,Token*,ValuePtr<Analyzer>&,TokenList&,ErrorLogger&,Settings&)",<empty>,,false,903,912,valueFlowGenericForward,,,1,"Analyzer.Result(Token*,Token*,ValuePtr<Analyzer>&,TokenList&,ErrorLogger&,Settings&)"
111669152516,METHOD,lib/forwardanalyzer.cpp:<global>,TYPE_DECL,<global>,1,1,lib/forwardanalyzer.cpp,lib/forwardanalyzer.cpp:<global>,<empty>,,false,1,923,<global>,,,1,
111669152517,METHOD,lib/forwardanalyzer.cpp:<global>,TYPE_DECL,"Analyzer::Result valueFlowGenericForward(Token* start, const ValuePtr<Analyzer>& a, const TokenList& tokenList, ErrorLogger& errorLogger, const Settings& settings)
{
    if (Settings::terminated())
        throw TerminateException();
    if (a->invalid())
        return Analyzer::Result{Analyzer::Action::None, Analyzer::Terminate::Bail};
    ForwardTraversal ft{a, tokenList, errorLogger, settings};
    (void)ft.updateRecursive(start);
    return Analyzer::Result{ ft.actions, ft.terminate };
}",1,1,lib/forwardanalyzer.cpp,"valueFlowGenericForward:Analyzer.Result(Token*,ValuePtr<Analyzer>&,TokenList&,ErrorLogger&,Settings&)",<empty>,,false,914,923,valueFlowGenericForward,,,1,"Analyzer.Result(Token*,ValuePtr<Analyzer>&,TokenList&,ErrorLogger&,Settings&)"
111669152518,METHOD,lib/forwardanalyzer.h:<global>,TYPE_DECL,<global>,1,1,lib/forwardanalyzer.h,lib/forwardanalyzer.h:<global>,<empty>,,false,1,39,<global>,,,1,
111669152519,METHOD,lib/fwdanalysis.cpp:<global>,TYPE_DECL,"static bool isUnchanged(const Token *startToken, const Token *endToken, const std::set<nonneg int> &exprVarIds, bool local)
{
    for (const Token *tok = startToken; tok != endToken; tok = tok->next()) {
        if (!local && Token::Match(tok, ""%name% ("") && !Token::simpleMatch(tok->linkAt(1), "") {""))
            // TODO: this is a quick bailout
            return false;
        if (tok->varId() == 0 || exprVarIds.find(tok->varId()) == exprVarIds.end())
            continue;
        const Token *parent = tok;
        while (parent->astParent() && !parent->astParent()->isAssignmentOp() && parent->astParent()->tokType() != Token::Type::eIncDecOp) {
            if (parent->str() == "","" || parent->isUnaryOp(""&""))
                // TODO: This is a quick bailout
                return false;
            parent = parent->astParent();
        }
        if (parent->astParent()) {
            if (parent->astParent()->tokType() == Token::Type::eIncDecOp)
                return false;
        ...",1,87,lib/fwdanalysis.cpp,"isUnchanged:bool(Token*,Token*,std.set<int>&,bool)",<empty>,,false,33,56,isUnchanged,,,1,"bool(Token*,Token*,std.set<int>&,bool)"
111669152520,METHOD,lib/fwdanalysis.cpp:<global>,TYPE_DECL,<global>,1,1,lib/fwdanalysis.cpp,lib/fwdanalysis.cpp:<global>,<empty>,,false,1,580,<global>,,,1,
111669152521,METHOD,lib/fwdanalysis.cpp:<global>,TYPE_DECL,"static bool hasFunctionCall(const Token *tok)
{
    if (!tok)
        return false;
    if (Token::Match(tok, ""%name% (""))
        // todo, const/pure function?
        return true;
    return hasFunctionCall(tok->astOperand1()) || hasFunctionCall(tok->astOperand2());
}",1,1,lib/fwdanalysis.cpp,hasFunctionCall:bool(Token*),<empty>,,false,58,66,hasFunctionCall,,,1,bool(Token*)
111669152522,METHOD,lib/fwdanalysis.cpp:<global>,TYPE_DECL,"static bool hasGccCompoundStatement(const Token *tok)
{
    if (!tok)
        return false;
    if (tok->str() == ""{"" && Token::simpleMatch(tok->previous(), ""( {""))
        return true;
    return hasGccCompoundStatement(tok->astOperand1()) || hasGccCompoundStatement(tok->astOperand2());
}",1,1,lib/fwdanalysis.cpp,hasGccCompoundStatement:bool(Token*),<empty>,,false,68,75,hasGccCompoundStatement,,,1,bool(Token*)
111669152523,METHOD,lib/fwdanalysis.cpp:<global>,TYPE_DECL,"static bool nonLocal(const Variable* var, bool deref)
{
    return !var || (!var->isLocal() && !var->isArgument()) || (deref && var->isArgument() && var->isPointer()) || var->isStatic() || var->isReference() || var->isExtern();
}",1,1,lib/fwdanalysis.cpp,"nonLocal:bool(Variable*,bool)",<empty>,,false,77,80,nonLocal,,,1,"bool(Variable*,bool)"
111669152524,METHOD,<empty>,<empty>,"[&ret](const Token *tok) {
        if (tok->variable() && tok->variable()->isVolatile())
            ret = true;
        else if (Token::simpleMatch(tok, ""( volatile""))
            ret = true;
        return ret ? ChildrenToVisit::none : ChildrenToVisit::op1_and_op2;
    }",19,5,lib/fwdanalysis.cpp,lib/fwdanalysis.cpp:<global>.hasVolatileCastOrVar.<lambda>0:ChildrenToVisit(Token*),<empty>,,false,86,92,<lambda>0,,,1,ChildrenToVisit(Token*)
111669152525,METHOD,lib/fwdanalysis.cpp:<global>,TYPE_DECL,"static bool hasVolatileCastOrVar(const Token *expr)
{
    bool ret = false;
    visitAstNodes(expr,
                  [&ret](const Token *tok) {
        if (tok->variable() && tok->variable()->isVolatile())
            ret = true;
        else if (Token::simpleMatch(tok, ""( volatile""))
            ret = true;
        return ret ? ChildrenToVisit::none : ChildrenToVisit::op1_and_op2;
    });
    return ret;
}",1,1,lib/fwdanalysis.cpp,hasVolatileCastOrVar:bool(Token*),<empty>,,false,82,94,hasVolatileCastOrVar,,,1,bool(Token*)
111669152526,METHOD,lib/fwdanalysis.cpp:<global>,TYPE_DECL,"FwdAnalysis::Result FwdAnalysis::checkRecursive(const Token *expr, const Token *startToken, const Token *endToken, const std::set<nonneg int> &exprVarIds, bool local, bool inInnerClass, int depth)
{
    // Parse the given tokens
    if (++depth > 1000)
        return Result(Result::Type::BAILOUT);

    for (const Token* tok = startToken; precedes(tok, endToken); tok = tok->next()) {
        if (Token::simpleMatch(tok, ""try {"")) {
            // TODO: handle try
            return Result(Result::Type::BAILOUT);
        }

        if (Token::simpleMatch(tok, ""break ;"")) {
            return Result(Result::Type::BREAK, tok);
        }

        if (Token::simpleMatch(tok, ""goto""))
            return Result(Result::Type::BAILOUT);

        if (!inInnerClass && tok->str() == ""{"" && tok->scope()->isClassOrStruct()) {
            // skip returns from local class definition
            FwdAnalysis::Result result = checkRecursive(expr, tok, tok->link(), exprVarIds, local, true, depth);
      ...",1,130,lib/fwdanalysis.cpp,"FwdAnalysis.checkRecursive:FwdAnalysis.Result(Token*,Token*,Token*,std.set<int>&,bool,bool,int)",<empty>,,false,96,410,checkRecursive,,,1,"FwdAnalysis.Result(Token*,Token*,Token*,std.set<int>&,bool,bool,int)"
111669152527,METHOD,<empty>,<empty>,"[&](const Token *tok) {
        if (tok->str() == ""["" && mWhat == What::UnusedValue)
            return ChildrenToVisit::op1;
        if (tok->varId() == 0 && tok->isName() && tok->strAt(-1) != ""."") {
            // unknown variable
            unknownVarId = true;
            return ChildrenToVisit::none;
        }
        if (tok->varId() > 0) {
            exprVarIds.insert(tok->varId());
            if (!Token::simpleMatch(tok->previous(), ""."")) {
                const Variable *var = tok->variable();
                if (var && var->isReference() && var->isLocal() && Token::Match(var->nameToken(), ""%var% [=(]"") && !isGlobalData(var->nameToken()->next()->astOperand2()))
                    return ChildrenToVisit::none;
                const bool deref = tok->astParent() && (tok->astParent()->isUnaryOp(""*"") || (tok->astParent()->str() == ""["" && tok == tok->astParent()->astOperand1()));
                local &= !nonLocal(tok->variable(), deref);
            }
        }
        retu...",19,5,lib/fwdanalysis.cpp,lib/fwdanalysis.cpp:<global>.FwdAnalysis.getExprVarIds<const>.<lambda>1:ChildrenToVisit(Token*),<empty>,,false,419,438,<lambda>1,,,1,ChildrenToVisit(Token*)
111669152528,METHOD,lib/fwdanalysis.cpp:<global>,TYPE_DECL,"std::set<nonneg int> FwdAnalysis::getExprVarIds(const Token* expr, bool* localOut, bool* unknownVarIdOut) const
{
    // all variable ids in expr.
    std::set<nonneg int> exprVarIds;
    bool local = true;
    bool unknownVarId = false;
    visitAstNodes(expr,
                  [&](const Token *tok) {
        if (tok->str() == ""["" && mWhat == What::UnusedValue)
            return ChildrenToVisit::op1;
        if (tok->varId() == 0 && tok->isName() && tok->strAt(-1) != ""."") {
            // unknown variable
            unknownVarId = true;
            return ChildrenToVisit::none;
        }
        if (tok->varId() > 0) {
            exprVarIds.insert(tok->varId());
            if (!Token::simpleMatch(tok->previous(), ""."")) {
                const Variable *var = tok->variable();
                if (var && var->isReference() && var->isLocal() && Token::Match(var->nameToken(), ""%var% [=(]"") && !isGlobalData(var->nameToken()->next()->astOperand2()))
                    return Children...",1,9,lib/fwdanalysis.cpp,"FwdAnalysis.getExprVarIds<const>:set<int>(Token*,bool*,bool*)",<empty>,,false,412,444,getExprVarIds,,,1,"set<int>(Token*,bool*,bool*)"
111669152529,METHOD,lib/fwdanalysis.cpp:<global>,TYPE_DECL,"FwdAnalysis::Result FwdAnalysis::check(const Token* expr, const Token* startToken, const Token* endToken)
{
    // all variable ids in expr.
    bool local = true;
    bool unknownVarId = false;
    std::set<nonneg int> exprVarIds = getExprVarIds(expr, &local, &unknownVarId);

    if (unknownVarId)
        return Result(FwdAnalysis::Result::Type::BAILOUT);

    if (mWhat == What::Reassign && isGlobalData(expr))
        local = false;

    // In unused values checking we do not want to check assignments to
    // global data.
    if (mWhat == What::UnusedValue && isGlobalData(expr))
        return Result(FwdAnalysis::Result::Type::BAILOUT);

    Result result = checkRecursive(expr, startToken, endToken, exprVarIds, local, false);

    // Break => continue checking in outer scope
    while (mWhat!=What::ValueFlow && result.type == FwdAnalysis::Result::Type::BREAK) {
        const Token *scopeEndToken = findNextTokenFromBreak(result.token);
        if (!scopeEndToken)
            break...",1,13,lib/fwdanalysis.cpp,"FwdAnalysis.check:FwdAnalysis.Result(Token*,Token*,Token*)",<empty>,,false,446,475,check,,,1,"FwdAnalysis.Result(Token*,Token*,Token*)"
111669152530,METHOD,lib/fwdanalysis.cpp:<global>,TYPE_DECL,"bool FwdAnalysis::hasOperand(const Token *tok, const Token *lhs) const
{
    if (!tok)
        return false;
    if (isSameExpression(false, tok, lhs, mSettings, false, false, nullptr))
        return true;
    return hasOperand(tok->astOperand1(), lhs) || hasOperand(tok->astOperand2(), lhs);
}",1,1,lib/fwdanalysis.cpp,"FwdAnalysis.hasOperand<const>:bool(Token*,Token*)",<empty>,,false,477,484,hasOperand,,,1,"bool(Token*,Token*)"
111669152531,METHOD,lib/fwdanalysis.cpp:<global>,TYPE_DECL,"const Token *FwdAnalysis::reassign(const Token *expr, const Token *startToken, const Token *endToken)
{
    if (hasVolatileCastOrVar(expr))
        return nullptr;
    mWhat = What::Reassign;
    Result result = check(expr, startToken, endToken);
    return result.type == FwdAnalysis::Result::Type::WRITE ? result.token : nullptr;
}",1,1,lib/fwdanalysis.cpp,"FwdAnalysis.reassign:Token*(Token*,Token*,Token*)",<empty>,,false,486,493,reassign,,,1,"Token*(Token*,Token*,Token*)"
111669152532,METHOD,lib/fwdanalysis.cpp:<global>,TYPE_DECL,"bool FwdAnalysis::unusedValue(const Token *expr, const Token *startToken, const Token *endToken)
{
    if (isEscapedAlias(expr))
        return false;
    if (hasVolatileCastOrVar(expr))
        return false;
    if (Token::simpleMatch(expr, ""["") && astIsContainerView(expr->astOperand1()))
        return false;
    mWhat = What::UnusedValue;
    Result result = check(expr, startToken, endToken);
    return (result.type == FwdAnalysis::Result::Type::NONE || result.type == FwdAnalysis::Result::Type::RETURN) && !possiblyAliased(expr, startToken);
}",1,1,lib/fwdanalysis.cpp,"FwdAnalysis.unusedValue:bool(Token*,Token*,Token*)",<empty>,,false,495,506,unusedValue,,,1,"bool(Token*,Token*,Token*)"
111669152533,METHOD,lib/fwdanalysis.cpp:<global>,TYPE_DECL,"bool FwdAnalysis::possiblyAliased(const Token *expr, const Token *startToken) const
{
    if (expr->isUnaryOp(""*"") && !expr->astOperand1()->isUnaryOp(""&""))
        return true;
    if (Token::simpleMatch(expr, "". *""))
        return true;
    if (expr->str() == ""("" && Token::simpleMatch(expr->astOperand1(), "".""))
        return true;

    const bool macro = false;
    const bool pure = false;
    const bool followVar = false;
    for (const Token *tok = startToken; tok; tok = tok->previous()) {

        if (Token::Match(tok, ""%name% ("") && !Token::Match(tok, ""if|while|for"")) {
            // Is argument passed by reference?
            const std::vector<const Token*> args = getArguments(tok);
            for (int argnr = 0; argnr < args.size(); ++argnr) {
                if (!Token::Match(args[argnr], ""%name%|.|::""))
                    continue;
                if (tok->function() && tok->function()->getArgumentVar(argnr) && !tok->function()->getArgumentVar(argnr)->isReference() &&...",1,1,lib/fwdanalysis.cpp,"FwdAnalysis.possiblyAliased<const>:bool(Token*,Token*)",<empty>,,false,508,561,possiblyAliased,,,1,"bool(Token*,Token*)"
111669152534,METHOD,lib/fwdanalysis.cpp:<global>,TYPE_DECL,"bool FwdAnalysis::isEscapedAlias(const Token* expr)
{
    for (const Token *subexpr = expr; subexpr; subexpr = subexpr->astOperand1()) {
        for (const ValueFlow::Value &val : subexpr->values()) {
            if (!val.isLocalLifetimeValue())
                continue;
            const Variable* var = val.tokvalue->variable();
            if (!var)
                continue;
            if (!var->isLocal())
                return true;
            if (var->isArgument())
                return true;

        }
    }
    return false;
}",1,1,lib/fwdanalysis.cpp,FwdAnalysis.isEscapedAlias:bool(Token*),<empty>,,false,563,580,isEscapedAlias,,,1,bool(Token*)
111669152535,METHOD,lib/fwdanalysis.h:<global>,TYPE_DECL,<global>,1,1,lib/fwdanalysis.h,lib/fwdanalysis.h:<global>,<empty>,,false,1,92,<global>,,,1,
111669152536,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"void ImportProject::ignorePaths(const std::vector<std::string> &ipaths, bool debug)
{
    for (auto it = fileSettings.cbegin(); it != fileSettings.cend();) {
        bool ignore = false;
        for (std::string i : ipaths) {
            if (it->filename().size() > i.size() && it->filename().compare(0,i.size(),i)==0) {
                ignore = true;
                break;
            }
            if (isValidGlobPattern(i) && matchglob(i, it->filename())) {
                ignore = true;
                break;
            }
            if (!Path::isAbsolute(i)) {
                i = mPath + i;
                if (it->filename().size() > i.size() && it->filename().compare(0,i.size(),i)==0) {
                    ignore = true;
                    break;
                }
            }
        }
        if (ignore) {
            if (debug)
                std::cout << ""ignored path: "" << it->filename() << std::endl;
            it = fileSettings.erase(it);
        }
        else
      ...",1,1,lib/importproject.cpp,"ImportProject.ignorePaths:void(std.vector<std.string>&,bool)",<empty>,,false,45,74,ignorePaths,,,1,"void(std.vector<std.string>&,bool)"
111669152537,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,<global>,1,1,lib/importproject.cpp,lib/importproject.cpp:<global>,<empty>,,false,1,1500,<global>,,,1,
111669152538,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"void ImportProject::ignoreOtherConfigs(const std::string &cfg)
{
    for (auto it = fileSettings.cbegin(); it != fileSettings.cend();) {
        if (it->cfg != cfg)
            it = fileSettings.erase(it);
        else
            ++it;
    }
}",1,1,lib/importproject.cpp,ImportProject.ignoreOtherConfigs:void(std.string&),<empty>,,false,76,84,ignoreOtherConfigs,,,1,void(std.string&)
111669152539,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"void ImportProject::fsSetDefines(FileSettings& fs, std::string defs)
{
    while (defs.find("";%("") != std::string::npos) {
        const std::string::size_type pos1 = defs.find("";%("");
        const std::string::size_type pos2 = defs.find(';', pos1+1);
        defs.erase(pos1, pos2 == std::string::npos ? pos2 : (pos2-pos1));
    }
    while (defs.find("";;"") != std::string::npos)
        defs.erase(defs.find("";;""),1);
    while (!defs.empty() && defs[0] == ';')
        defs.erase(0, 1);
    while (!defs.empty() && endsWith(defs,';'))
        defs.erase(defs.size() - 1U); // TODO: Use std::string::pop_back() as soon as travis supports it
    bool eq = false;
    for (std::size_t pos = 0; pos < defs.size(); ++pos) {
        if (defs[pos] == '(' || defs[pos] == '=')
            eq = true;
        else if (defs[pos] == ';') {
            if (!eq) {
                defs.insert(pos,""=1"");
                pos += 3;
            }
            if (pos < defs.size())
                eq = false;...",1,1,lib/importproject.cpp,"ImportProject.fsSetDefines:void(FileSettings&,std.string)",<empty>,,false,86,115,fsSetDefines,,,1,"void(FileSettings&,std.string)"
111669152540,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"static bool simplifyPathWithVariables(std::string &s, std::map<std::string, std::string, cppcheck::stricmp> &variables)
{
    std::set<std::string, cppcheck::stricmp> expanded;
    std::string::size_type start = 0;
    while ((start = s.find(""$("")) != std::string::npos) {
        const std::string::size_type end = s.find(')',start);
        if (end == std::string::npos)
            break;
        const std::string var = s.substr(start+2,end-start-2);
        if (expanded.find(var) != expanded.end())
            break;
        expanded.insert(var);
        auto it1 = utils::as_const(variables).find(var);
        // variable was not found within defined variables
        if (it1 == variables.end()) {
            const char *envValue = std::getenv(var.c_str());
            if (!envValue) {
                //! \\todo generate a debug/info message about undefined variable
                break;
            }
            variables[var] = std::string(envValue);
            it1 = variables.f...",1,1,lib/importproject.cpp,"simplifyPathWithVariables:bool(std.string&,std.map<std.string,std.string,cppcheck.stricmp>&)",<empty>,,false,117,146,simplifyPathWithVariables,,,1,"bool(std.string&,std.map<std.string,std.string,cppcheck.stricmp>&)"
111669152541,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"void ImportProject::fsSetIncludePaths(FileSettings& fs, const std::string &basepath, const std::list<std::string> &in, std::map<std::string, std::string, cppcheck::stricmp> &variables)
{
    std::set<std::string> found;
    // NOLINTNEXTLINE(performance-unnecessary-copy-initialization)
    const std::list<std::string> copyIn(in);
    fs.includePaths.clear();
    for (const std::string &ipath : copyIn) {
        if (ipath.empty())
            continue;
        if (startsWith(ipath,""%(""))
            continue;
        std::string s(Path::fromNativeSeparators(ipath));
        if (!found.insert(s).second)
            continue;
        if (s[0] == '/' || (s.size() > 1U && s.compare(1,2,"":/"") == 0)) {
            if (!endsWith(s,'/'))
                s += '/';
            fs.includePaths.push_back(std::move(s));
            continue;
        }

        if (endsWith(s,'/')) // this is a temporary hack, simplifyPath can crash if path ends with '/'
            s.pop_back();

        if (s.fi...",1,1,lib/importproject.cpp,"ImportProject.fsSetIncludePaths:void(FileSettings&,std.string&,std.list<std.string>&,std.map<std.string,std.string,cppcheck.stricmp>&)",<empty>,,false,148,182,fsSetIncludePaths,,,1,"void(FileSettings&,std.string&,std.list<std.string>&,std.map<std.string,std.string,cppcheck.stricmp>&)"
111669152542,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"ImportProject::Type ImportProject::import(const std::string &filename, Settings *settings, Suppressions *supprs)
{
    std::ifstream fin(filename);
    if (!fin.is_open())
        return ImportProject::Type::MISSING;

    mPath = Path::getPathFromFilename(Path::fromNativeSeparators(filename));
    if (!mPath.empty() && !endsWith(mPath,'/'))
        mPath += '/';

    const std::vector<std::string> fileFilters =
        settings ? settings->fileFilters : std::vector<std::string>();

    if (endsWith(filename, "".json"")) {
        if (importCompileCommands(fin)) {
            setRelativePaths(filename);
            return ImportProject::Type::COMPILE_DB;
        }
    } else if (endsWith(filename, "".sln"")) {
        if (importSln(fin, mPath, fileFilters)) {
            setRelativePaths(filename);
            return ImportProject::Type::VS_SLN;
        }
    } else if (endsWith(filename, "".vcxproj"")) {
        std::map<std::string, std::string, cppcheck::stricmp> variables;
        std:...",1,1,lib/importproject.cpp,"ImportProject.import:ImportProject.Type(std.string&,Settings*,Suppressions*)",<empty>,,false,184,228,import,,,1,"ImportProject.Type(std.string&,Settings*,Suppressions*)"
111669152543,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"static std::string readUntil(const std::string &command, std::string::size_type *pos, const char until[])
{
    std::string ret;
    bool escapedString = false;
    bool str = false;
    bool escape = false;
    for (; *pos < command.size() && (str || !std::strchr(until, command[*pos])); (*pos)++) {
        if (escape)
            escape = false;
        else if (command[*pos] == '\\\\') {
            if (str)
                escape = true;
            else if (command[*pos + 1] == '""') {
                if (escapedString)
                    return ret + ""\\\\\\"""";
                escapedString = true;
                ret += ""\\\\\\"""";
                (*pos)++;
                continue;
            }
        } else if (command[*pos] == '\\""')
            str = !str;
        ret += command[*pos];
    }
    return ret;
}",1,1,lib/importproject.cpp,"readUntil:string(std.string&,std.string.size_type*,char[])",<empty>,,false,230,255,readUntil,,,1,"string(std.string&,std.string.size_type*,char[])"
111669152544,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"static std::string unescape(const std::string &in)
{
    std::string out;
    bool escape = false;
    for (const char c: in) {
        if (escape) {
            escape = false;
            if (!std::strchr(""\\\\\\""\\'"",c))
                out += ""\\\\"";
            out += c;
        } else if (c == '\\\\')
            escape = true;
        else
            out += c;
    }
    return out;
}",1,1,lib/importproject.cpp,unescape:string(std.string&),<empty>,,false,257,273,unescape,,,1,string(std.string&)
111669152545,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"void ImportProject::fsParseCommand(FileSettings& fs, const std::string& command)
{
    std::string defs;

    // Parse command..
    std::string::size_type pos = 0;
    while (std::string::npos != (pos = command.find(' ',pos))) {
        while (pos < command.size() && command[pos] == ' ')
            pos++;
        if (pos >= command.size())
            break;
        if (command[pos] != '/' && command[pos] != '-')
            continue;
        pos++;
        if (pos >= command.size())
            break;
        const char F = command[pos++];
        if (std::strchr(""DUI"", F)) {
            while (pos < command.size() && command[pos] == ' ')
                ++pos;
        }
        std::string fval = readUntil(command, &pos, "" ="");
        if (F=='D') {
            std::string defval = readUntil(command, &pos, "" "");
            defs += fval;
            if (defval.size() >= 3 && startsWith(defval,""=\\"""") && defval.back()=='\\""')
                defval = ""="" + unescape(defval.substr(2,...",1,1,lib/importproject.cpp,"ImportProject.fsParseCommand:void(FileSettings&,std.string&)",<empty>,,false,275,346,fsParseCommand,,,1,"void(FileSettings&,std.string&)"
111669152546,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"bool ImportProject::importCompileCommands(std::istream &istr)
{
    picojson::value compileCommands;
    istr >> compileCommands;
    if (!compileCommands.is<picojson::array>()) {
        printError(""compilation database is not a JSON array"");
        return false;
    }

    for (const picojson::value &fileInfo : compileCommands.get<picojson::array>()) {
        picojson::object obj = fileInfo.get<picojson::object>();
        std::string dirpath = Path::fromNativeSeparators(obj[""directory""].get<std::string>());

        /* CMAKE produces the directory without trailing / so add it if not
         * there - it is needed by setIncludePaths() */
        if (!endsWith(dirpath, '/'))
            dirpath += '/';

        const std::string directory = std::move(dirpath);

        std::string command;
        if (obj.count(""arguments"")) {
            if (obj[""arguments""].is<picojson::array>()) {
                for (const picojson::value& arg : obj[""arguments""].get<picojson::array>()) {
   ...",1,1,lib/importproject.cpp,ImportProject.importCompileCommands:bool(std.istream&),<empty>,,false,348,430,importCompileCommands,,,1,bool(std.istream&)
111669152547,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"bool ImportProject::importSln(std::istream &istr, const std::string &path, const std::vector<std::string> &fileFilters)
{
    std::string line;

    if (!std::getline(istr,line)) {
        printError(""Visual Studio solution file is empty"");
        return false;
    }

    if (!startsWith(line, ""Microsoft Visual Studio Solution File"")) {
        // Skip BOM
        if (!std::getline(istr, line) || !startsWith(line, ""Microsoft Visual Studio Solution File"")) {
            printError(""Visual Studio solution file header not found"");
            return false;
        }
    }

    std::map<std::string,std::string,cppcheck::stricmp> variables;
    variables[""SolutionDir""] = path;

    bool found = false;
    std::vector<SharedItemsProject> sharedItemsProjects;
    while (std::getline(istr,line)) {
        if (!startsWith(line,""Project(""))
            continue;
        const std::string::size_type pos = line.find("".vcxproj"");
        if (pos == std::string::npos)
            continue;
     ...",1,1,lib/importproject.cpp,"ImportProject.importSln:bool(std.istream&,std.string&,std.vector<std.string>&)",<empty>,,false,432,481,importSln,,,1,"bool(std.istream&,std.string&,std.vector<std.string>&)"
111669152548,METHOD,ProjectConfiguration,TYPE_DECL,"explicit ProjectConfiguration(const tinyxml2::XMLElement *cfg) {
            const char *a = cfg->Attribute(""Include"");
            if (a)
                name = a;
            for (const tinyxml2::XMLElement *e = cfg->FirstChildElement(); e; e = e->NextSiblingElement()) {
                const char * const text = e->GetText();
                if (!text)
                    continue;
                const char * ename = e->Name();
                if (std::strcmp(ename,""Configuration"")==0)
                    configuration = text;
                else if (std::strcmp(ename,""Platform"")==0) {
                    platformStr = text;
                    if (platformStr == ""Win32"")
                        platform = Win32;
                    else if (platformStr == ""x64"")
                        platform = x64;
                    else
                        platform = Unknown;
                }
            }
        }",9,9,lib/importproject.cpp,ProjectConfiguration.ProjectConfiguration:ANY(tinyxml2.XMLElement*),<empty>,,false,485,506,ProjectConfiguration,,,1,ANY(tinyxml2.XMLElement*)
111669152549,METHOD,<empty>,<empty>,<empty>,5,,lib/importproject.cpp,ProjectConfiguration.<clinit>,<empty>,,false,484,,<clinit>,,,6,
111669152550,METHOD,ItemDefinitionGroup,TYPE_DECL,"explicit ItemDefinitionGroup(const tinyxml2::XMLElement *idg, std::string includePaths) : additionalIncludePaths(std::move(includePaths)) {
            const char *condAttr = idg->Attribute(""Condition"");
            if (condAttr)
                condition = condAttr;
            for (const tinyxml2::XMLElement *e1 = idg->FirstChildElement(); e1; e1 = e1->NextSiblingElement()) {
                const char* name = e1->Name();
                if (std::strcmp(name, ""ClCompile"") == 0) {
                    enhancedInstructionSet = ""StreamingSIMDExtensions2"";
                    for (const tinyxml2::XMLElement *e = e1->FirstChildElement(); e; e = e->NextSiblingElement()) {
                        const char * const text = e->GetText();
                        if (!text)
                            continue;
                        const char * const ename = e->Name();
                        if (std::strcmp(ename, ""PreprocessorDefinitions"") == 0)
                            preprocessorDe...",9,9,lib/importproject.cpp,"ItemDefinitionGroup.ItemDefinitionGroup:ANY(tinyxml2.XMLElement*,std.string)",<empty>,,false,514,558,ItemDefinitionGroup,,,1,"ItemDefinitionGroup.ItemDefinitionGroup:ANY(tinyxml2.XMLElement*,std.string)(tinyxml2.XMLElement*,std.string)"
111669152551,METHOD,ItemDefinitionGroup,TYPE_DECL,"static void replaceAll(std::string &c, const std::string &from, const std::string &to) {
            std::string::size_type pos;
            while ((pos = c.find(from)) != std::string::npos) {
                c.erase(pos,from.size());
                c.insert(pos,to);
            }
        }",9,9,lib/importproject.cpp,"ItemDefinitionGroup.replaceAll:void(std.string&,std.string&,std.string&)",<empty>,,false,560,566,replaceAll,,,2,"void(std.string&,std.string&,std.string&)"
111669152552,METHOD,ItemDefinitionGroup,TYPE_DECL,"bool conditionIsTrue(const ProjectConfiguration &p) const {
            if (condition.empty())
                return true;
            std::string c = '(' + condition + "");"";
            replaceAll(c, ""$(Configuration)"", p.configuration);
            replaceAll(c, ""$(Platform)"", p.platformStr);

            // TODO: improve evaluation
            const Settings s;
            TokenList tokenlist(&s);
            std::istringstream istr(c);
            tokenlist.createTokens(istr, Standards::Language::C); // TODO: check result
            // TODO: put in a helper
            // generate links
            {
                std::stack<Token*> lpar;
                for (Token* tok2 = tokenlist.front(); tok2; tok2 = tok2->next()) {
                    if (tok2->str() == ""("")
                        lpar.push(tok2);
                    else if (tok2->str() == "")"") {
                        if (lpar.empty())
                            break;
                        Token::createMutualLin...",9,9,lib/importproject.cpp,ItemDefinitionGroup.conditionIsTrue<const>:bool(ProjectConfiguration&),<empty>,,false,570,608,conditionIsTrue,,,3,bool(ProjectConfiguration&)
111669152553,METHOD,<empty>,<empty>,<empty>,5,,lib/importproject.cpp,ItemDefinitionGroup.<clinit>,<empty>,,false,513,,<clinit>,,,10,
111669152554,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"static std::list<std::string> toStringList(const std::string &s)
{
    std::list<std::string> ret;
    std::string::size_type pos1 = 0;
    std::string::size_type pos2;
    while ((pos2 = s.find(';',pos1)) != std::string::npos) {
        ret.push_back(s.substr(pos1, pos2-pos1));
        pos1 = pos2 + 1;
        if (pos1 >= s.size())
            break;
    }
    if (pos1 < s.size())
        ret.push_back(s.substr(pos1));
    return ret;
}",1,1,lib/importproject.cpp,toStringList:list<std.string>(std.string&),<empty>,,false,618,632,toStringList,,,1,list<std::string>(std.string&)
111669152555,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"static void importPropertyGroup(const tinyxml2::XMLElement *node, std::map<std::string,std::string,cppcheck::stricmp> &variables, std::string &includePath, bool *useOfMfc)
{
    if (useOfMfc) {
        for (const tinyxml2::XMLElement *e = node->FirstChildElement(); e; e = e->NextSiblingElement()) {
            if (std::strcmp(e->Name(), ""UseOfMfc"") == 0) {
                *useOfMfc = true;
                break;
            }
        }
    }

    const char* labelAttribute = node->Attribute(""Label"");
    if (labelAttribute && std::strcmp(labelAttribute, ""UserMacros"") == 0) {
        for (const tinyxml2::XMLElement *propertyGroup = node->FirstChildElement(); propertyGroup; propertyGroup = propertyGroup->NextSiblingElement()) {
            const char* name = propertyGroup->Name();
            const char *text = empty_if_null(propertyGroup->GetText());
            variables[name] = text;
        }

    } else if (!labelAttribute) {
        for (const tinyxml2::XMLElement *propertyGroup...",1,1,lib/importproject.cpp,"importPropertyGroup:void(tinyxml2.XMLElement*,std.map<std.string,std.string,cppcheck.stricmp>&,std.string&,bool*)",<empty>,,false,634,667,importPropertyGroup,,,1,"void(tinyxml2.XMLElement*,std.map<std.string,std.string,cppcheck.stricmp>&,std.string&,bool*)"
111669152556,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"static void loadVisualStudioProperties(const std::string &props, std::map<std::string,std::string,cppcheck::stricmp> &variables, std::string &includePath, const std::string &additionalIncludeDirectories, std::list<ItemDefinitionGroup> &itemDefinitionGroupList)
{
    std::string filename(props);
    // variables can't be resolved
    if (!simplifyPathWithVariables(filename, variables))
        return;

    // prepend project dir (if it exists) to transform relative paths into absolute ones
    if (!Path::isAbsolute(filename) && variables.count(""ProjectDir"") > 0)
        filename = Path::getAbsoluteFilePath(variables.at(""ProjectDir"") + filename);

    tinyxml2::XMLDocument doc;
    if (doc.LoadFile(filename.c_str()) != tinyxml2::XML_SUCCESS)
        return;
    const tinyxml2::XMLElement * const rootnode = doc.FirstChildElement();
    if (rootnode == nullptr)
        return;
    for (const tinyxml2::XMLElement *node = rootnode->FirstChildElement(); node; node = node->NextSiblingElemen...",1,1,lib/importproject.cpp,"loadVisualStudioProperties:void(std.string&,std.map<std.string,std.string,cppcheck.stricmp>&,std.string&,std.string&,std.list<ItemDefinitionGroup>&)",<empty>,,false,669,710,loadVisualStudioProperties,,,1,"void(std.string&,std.map<std.string,std.string,cppcheck.stricmp>&,std.string&,std.string&,std.list<ItemDefinitionGroup>&)"
111669152557,METHOD,<empty>,<empty>,"[&](const std::string& c) {
                    return c == p.configuration;
                }",123,17,lib/importproject.cpp,lib/importproject.cpp:<global>.ImportProject.importVcxproj.<lambda>0:bool(std.string&),<empty>,,false,828,830,<lambda>0,,,1,bool(std.string&)
111669152558,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"bool ImportProject::importVcxproj(const std::string &filename, std::map<std::string, std::string, cppcheck::stricmp> &variables, const std::string &additionalIncludeDirectories, const std::vector<std::string> &fileFilters, std::vector<SharedItemsProject> &cache)
{
    variables[""ProjectDir""] = Path::simplifyPath(Path::getPathFromFilename(filename));

    std::list<ProjectConfiguration> projectConfigurationList;
    std::list<std::string> compileList;
    std::list<ItemDefinitionGroup> itemDefinitionGroupList;
    std::string includePath;
    std::vector<SharedItemsProject> sharedItemsProjects;

    bool useOfMfc = false;

    tinyxml2::XMLDocument doc;
    const tinyxml2::XMLError error = doc.LoadFile(filename.c_str());
    if (error != tinyxml2::XML_SUCCESS) {
        printError(std::string(""Visual Studio project file is not a valid XML - "") + tinyxml2::XMLDocument::ErrorIDToName(error));
        return false;
    }
    const tinyxml2::XMLElement * const rootnode = doc.FirstChildEl...",1,1,lib/importproject.cpp,"ImportProject.importVcxproj:bool(std.string&,std.map<std.string,std.string,cppcheck.stricmp>&,std.string&,std.vector<std.string>&,std.vector<SharedItemsProject>&)",<empty>,,false,712,875,importVcxproj,,,1,"bool(std.string&,std.map<std.string,std.string,cppcheck.stricmp>&,std.string&,std.vector<std.string>&,std.vector<SharedItemsProject>&)"
111669152559,METHOD,<empty>,<empty>,"[filename](const ImportProject::SharedItemsProject& e) -> bool {
        return filename == e.pathToProjectFile;
    }",27,5,lib/importproject.cpp,lib/importproject.cpp:<global>.ImportProject.importVcxitems.<lambda>1:bool(ImportProject.SharedItemsProject&),<empty>,,false,879,881,<lambda>1,,,1,bool(ImportProject.SharedItemsProject&)
111669152560,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"ImportProject::SharedItemsProject ImportProject::importVcxitems(const std::string& filename, const std::vector<std::string>& fileFilters, std::vector<SharedItemsProject> &cache)
{
    auto isInCacheCheck = [filename](const ImportProject::SharedItemsProject& e) -> bool {
        return filename == e.pathToProjectFile;
    };
    const auto iterator = std::find_if(cache.begin(), cache.end(), isInCacheCheck);
    if (iterator != std::end(cache)) {
        return *iterator;
    }

    SharedItemsProject result;
    result.pathToProjectFile = filename;

    tinyxml2::XMLDocument doc;
    const tinyxml2::XMLError error = doc.LoadFile(filename.c_str());
    if (error != tinyxml2::XML_SUCCESS) {
        printError(std::string(""Visual Studio project file is not a valid XML - "") + tinyxml2::XMLDocument::ErrorIDToName(error));
        return result;
    }
    const tinyxml2::XMLElement * const rootnode = doc.FirstChildElement();
    if (rootnode == nullptr) {
        printError(""Visual Studio ...",1,1,lib/importproject.cpp,"ImportProject.importVcxitems:ImportProject.SharedItemsProject(std.string&,std.vector<std.string>&,std.vector<SharedItemsProject>&)",<empty>,,false,877,937,importVcxitems,,,1,"ImportProject.SharedItemsProject(std.string&,std.vector<std.string>&,std.vector<SharedItemsProject>&)"
111669152561,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"bool ImportProject::importBcb6Prj(const std::string &projectFilename)
{
    tinyxml2::XMLDocument doc;
    const tinyxml2::XMLError error = doc.LoadFile(projectFilename.c_str());
    if (error != tinyxml2::XML_SUCCESS) {
        printError(std::string(""Borland project file is not a valid XML - "") + tinyxml2::XMLDocument::ErrorIDToName(error));
        return false;
    }
    const tinyxml2::XMLElement * const rootnode = doc.FirstChildElement();
    if (rootnode == nullptr) {
        printError(""Borland project file has no XML root node"");
        return false;
    }

    const std::string& projectDir = Path::simplifyPath(Path::getPathFromFilename(projectFilename));

    std::list<std::string> compileList;
    std::string includePath;
    std::string userdefines;
    std::string sysdefines;
    std::string cflag1;

    for (const tinyxml2::XMLElement *node = rootnode->FirstChildElement(); node; node = node->NextSiblingElement()) {
        const char* name = node->Name();
        if (...",1,1,lib/importproject.cpp,ImportProject.importBcb6Prj:bool(std.string&),<empty>,,false,939,1204,importBcb6Prj,,,1,bool(std.string&)
111669152562,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"static std::string joinRelativePath(const std::string &path1, const std::string &path2)
{
    if (!path1.empty() && !Path::isAbsolute(path2))
        return path1 + path2;
    return path2;
}",1,1,lib/importproject.cpp,"joinRelativePath:string(std.string&,std.string&)",<empty>,,false,1206,1211,joinRelativePath,,,1,"string(std.string&,std.string&)"
111669152563,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"static std::list<std::string> readXmlStringList(const tinyxml2::XMLElement *node, const std::string &path, const char name[], const char attribute[])
{
    std::list<std::string> ret;
    for (const tinyxml2::XMLElement *child = node->FirstChildElement(); child; child = child->NextSiblingElement()) {
        if (strcmp(child->Name(), name) != 0)
            continue;
        const char *attr = attribute ? child->Attribute(attribute) : child->GetText();
        if (attr)
            ret.push_back(joinRelativePath(path, attr));
    }
    return ret;
}",1,1,lib/importproject.cpp,"readXmlStringList:list<std.string>(tinyxml2.XMLElement*,std.string&,char[],char[])",<empty>,,false,1213,1224,readXmlStringList,,,1,"list<std::string>(tinyxml2.XMLElement*,std.string&,char[],char[])"
111669152564,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"static std::string join(const std::list<std::string> &strlist, const char *sep)
{
    std::string ret;
    for (const std::string &s : strlist) {
        ret += (ret.empty() ? """" : sep) + s;
    }
    return ret;
}",1,1,lib/importproject.cpp,"join:string(std.list<std.string>&,char*)",<empty>,,false,1226,1233,join,,,1,"string(std.list<std.string>&,char*)"
111669152565,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"static std::string istream_to_string(std::istream &istr)
{
    std::istreambuf_iterator<char> eos;
    return std::string(std::istreambuf_iterator<char>(istr), eos);
}",1,1,lib/importproject.cpp,istream_to_string:string(std.istream&),<empty>,,false,1235,1239,istream_to_string,,,1,string(std.istream&)
111669152566,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"bool ImportProject::importCppcheckGuiProject(std::istream &istr, Settings &settings, Suppressions &supprs)
{
    tinyxml2::XMLDocument doc;
    const std::string xmldata = istream_to_string(istr);
    const tinyxml2::XMLError error = doc.Parse(xmldata.data(), xmldata.size());
    if (error != tinyxml2::XML_SUCCESS) {
        printError(std::string(""Cppcheck GUI project file is not a valid XML - "") + tinyxml2::XMLDocument::ErrorIDToName(error));
        return false;
    }
    const tinyxml2::XMLElement * const rootnode = doc.FirstChildElement();
    if (rootnode == nullptr || strcmp(rootnode->Name(), CppcheckXml::ProjectElementName) != 0) {
        printError(""Cppcheck GUI project file has no XML root node"");
        return false;
    }

    const std::string &path = mPath;

    std::list<std::string> paths;
    std::list<SuppressionList::Suppression> suppressions;
    Settings temp;

    // default to --check-level=normal for import for now
    temp.setCheckLevel(Settings::CheckLev...",1,1,lib/importproject.cpp,"ImportProject.importCppcheckGuiProject:bool(std.istream&,Settings&,Suppressions&)",<empty>,,false,1241,1420,importCppcheckGuiProject,,,1,"bool(std.istream&,Settings&,Suppressions&)"
111669152567,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"void ImportProject::selectOneVsConfig(Platform::Type platform)
{
    std::set<std::string> filenames;
    for (auto it = fileSettings.cbegin(); it != fileSettings.cend();) {
        if (it->cfg.empty()) {
            ++it;
            continue;
        }
        const FileSettings &fs = *it;
        bool remove = false;
        if (!startsWith(fs.cfg,""Debug""))
            remove = true;
        if (platform == Platform::Type::Win64 && fs.platformType != platform)
            remove = true;
        else if ((platform == Platform::Type::Win32A || platform == Platform::Type::Win32W) && fs.platformType == Platform::Type::Win64)
            remove = true;
        else if (filenames.find(fs.filename()) != filenames.end())
            remove = true;
        if (remove) {
            it = fileSettings.erase(it);
        } else {
            filenames.insert(fs.filename());
            ++it;
        }
    }
}",1,1,lib/importproject.cpp,ImportProject.selectOneVsConfig:void(Platform.Type),<empty>,,false,1422,1447,selectOneVsConfig,,,1,void(Platform.Type)
111669152568,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"void ImportProject::selectVsConfigurations(Platform::Type platform, const std::vector<std::string> &configurations)
{
    for (auto it = fileSettings.cbegin(); it != fileSettings.cend();) {
        if (it->cfg.empty()) {
            ++it;
            continue;
        }
        const FileSettings &fs = *it;
        const auto config = fs.cfg.substr(0, fs.cfg.find('|'));
        bool remove = false;
        if (std::find(configurations.begin(), configurations.end(), config) == configurations.end())
            remove = true;
        if (platform == Platform::Type::Win64 && fs.platformType != platform)
            remove = true;
        else if ((platform == Platform::Type::Win32A || platform == Platform::Type::Win32W) && fs.platformType == Platform::Type::Win64)
            remove = true;
        if (remove) {
            it = fileSettings.erase(it);
        } else {
            ++it;
        }
    }
}",1,1,lib/importproject.cpp,"ImportProject.selectVsConfigurations:void(Platform.Type,std.vector<std.string>&)",<empty>,,false,1450,1472,selectVsConfigurations,,,1,"void(Platform.Type,std.vector<std.string>&)"
111669152569,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"std::list<std::string> ImportProject::getVSConfigs()
{
    return std::list<std::string>(mAllVSConfigs.cbegin(), mAllVSConfigs.cend());
}",1,1,lib/importproject.cpp,ImportProject.getVSConfigs:list<std.string>(),<empty>,,false,1475,1478,getVSConfigs,,,1,list<std::string>()
111669152570,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"void ImportProject::setRelativePaths(const std::string &filename)
{
    if (Path::isAbsolute(filename))
        return;
    const std::vector<std::string> basePaths{Path::fromNativeSeparators(Path::getCurrentPath())};
    for (auto &fs: fileSettings) {
        fs.file = FileWithDetails{Path::getRelativePath(fs.filename(), basePaths)};
        for (auto &includePath: fs.includePaths)
            includePath = Path::getRelativePath(includePath, basePaths);
    }
}",1,1,lib/importproject.cpp,ImportProject.setRelativePaths:void(std.string&),<empty>,,false,1480,1490,setRelativePaths,,,1,void(std.string&)
111669152571,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"void ImportProject::printError(const std::string &message)
{
    std::cout << ""cppcheck: error: "" << message << std::endl;
}",1,1,lib/importproject.cpp,ImportProject.printError:void(std.string&),<empty>,,false,1492,1495,printError,,,1,void(std.string&)
111669152572,METHOD,lib/importproject.cpp:<global>,TYPE_DECL,"bool ImportProject::sourceFileExists(const std::string &file)
{
    return Path::isFile(file);
}",1,1,lib/importproject.cpp,ImportProject.sourceFileExists:bool(std.string&),<empty>,,false,1497,1500,sourceFileExists,,,1,bool(std.string&)
111669152573,METHOD,lib/importproject.h:<global>,TYPE_DECL,<global>,1,1,lib/importproject.h,lib/importproject.h:<global>,<empty>,,false,1,195,<global>,,,1,
111669152574,METHOD,<empty>,<empty>,"[compare](const ValueFlow::Value& x, const ValueFlow::Value& y) {
                return compare(x.intvalue, y.intvalue);
            }",48,13,lib/infer.cpp,"lib/infer.cpp:<global>.getCompareValue.<lambda>0:ANY(ValueFlow.Value&,ValueFlow.Value&)",<empty>,,false,42,44,<lambda>0,,,1,"ANY(ValueFlow.Value&,ValueFlow.Value&)"
111669152575,METHOD,lib/infer.cpp:<global>,TYPE_DECL,"static const ValueFlow::Value* getCompareValue(const std::list<ValueFlow::Value>& values, Predicate pred, Compare compare)
{
    const ValueFlow::Value* result = nullptr;
    for (const ValueFlow::Value& value : values) {
        if (!pred(value))
            continue;
        if (result)
            result = &std::min(value, *result, [compare](const ValueFlow::Value& x, const ValueFlow::Value& y) {
                return compare(x.intvalue, y.intvalue);
            });
        else
            result = &value;
    }
    return result;
}",1,1,lib/infer.cpp,"getCompareValue:Value(std.list<ValueFlow.Value>&,Predicate,Compare)",<empty>,,false,35,49,getCompareValue,,,1,"Value(std.list<ValueFlow.Value>&,Predicate,Compare)"
111669152576,METHOD,lib/infer.cpp:<global>,TYPE_DECL,<global>,1,1,lib/infer.cpp,lib/infer.cpp:<global>,<empty>,,false,1,422,<global>,,,1,
111669152577,METHOD,<empty>,<empty>,"[](const ValueFlow::Value&) {
                return true;
            }",49,13,lib/infer.cpp,lib/infer.cpp:<global>.Interval.fromValues.<lambda>1:bool(ValueFlow.Value&),<empty>,,false,151,153,<lambda>1,,,1,bool(ValueFlow.Value&)
111669152578,METHOD,<empty>,<empty>,"[&](int i) {
                return b == calculate(op, i, 0);
            }",55,13,lib/infer.cpp,lib/infer.cpp:<global>.Interval.compare.<lambda>2:bool(int),<empty>,,false,231,233,<lambda>2,,,1,bool(int)
111669152579,METHOD,Interval,TYPE_DECL,"void setMinValue(MathLib::bigint x, const ValueFlow::Value* ref = nullptr)
        {
            minvalue = {x};
            if (ref)
                minRef = {ref};
        }",9,9,lib/infer.cpp,"Interval.setMinValue:void(MathLib.bigint,ValueFlow.Value*)",<empty>,,false,56,61,setMinValue,,,5,"void(MathLib.bigint,ValueFlow.Value*)"
111669152580,METHOD,Interval,TYPE_DECL,"void setMaxValue(MathLib::bigint x, const ValueFlow::Value* ref = nullptr)
        {
            maxvalue = {x};
            if (ref)
                maxRef = {ref};
        }",9,9,lib/infer.cpp,"Interval.setMaxValue:void(MathLib.bigint,ValueFlow.Value*)",<empty>,,false,63,68,setMaxValue,,,6,"void(MathLib.bigint,ValueFlow.Value*)"
111669152581,METHOD,Interval,TYPE_DECL,"bool isLessThan(MathLib::bigint x, std::vector<const ValueFlow::Value*>* ref = nullptr) const
        {
            if (!this->maxvalue.empty() && this->maxvalue.front() < x) {
                if (ref)
                    *ref = maxRef;
                return true;
            }
            return false;
        }",9,9,lib/infer.cpp,"Interval.isLessThan<const>:bool(MathLib.bigint,std.vector<constValueFlow.Value*>*)",<empty>,,false,70,78,isLessThan,,,7,"bool(MathLib.bigint,std.vector<constValueFlow.Value*>*)"
111669152582,METHOD,Interval,TYPE_DECL,"bool isGreaterThan(MathLib::bigint x, std::vector<const ValueFlow::Value*>* ref = nullptr) const
        {
            if (!this->minvalue.empty() && this->minvalue.front() > x) {
                if (ref)
                    *ref = minRef;
                return true;
            }
            return false;
        }",9,9,lib/infer.cpp,"Interval.isGreaterThan<const>:bool(MathLib.bigint,std.vector<constValueFlow.Value*>*)",<empty>,,false,80,88,isGreaterThan,,,8,"bool(MathLib.bigint,std.vector<constValueFlow.Value*>*)"
111669152583,METHOD,Interval,TYPE_DECL,"bool isScalar() const {
            return minvalue.size() == 1 && minvalue == maxvalue;
        }",9,9,lib/infer.cpp,Interval.isScalar<const>:bool(),<empty>,,false,90,92,isScalar,,,9,bool()
111669152584,METHOD,Interval,TYPE_DECL,"bool empty() const {
            return minvalue.empty() && maxvalue.empty();
        }",9,9,lib/infer.cpp,Interval.empty<const>:bool(),<empty>,,false,94,96,empty,,,10,bool()
111669152585,METHOD,Interval,TYPE_DECL,"bool isScalarOrEmpty() const {
            return empty() || isScalar();
        }",9,9,lib/infer.cpp,Interval.isScalarOrEmpty<const>:bool(),<empty>,,false,98,100,isScalarOrEmpty,,,11,bool()
111669152586,METHOD,Interval,TYPE_DECL,"MathLib::bigint getScalar() const
        {
            assert(isScalar());
            return minvalue.front();
        }",9,9,lib/infer.cpp,Interval.getScalar<const>:longlongint(),<empty>,,false,102,106,getScalar,,,12,longlongint()
111669152587,METHOD,Interval,TYPE_DECL,"std::vector<const ValueFlow::Value*> getScalarRef() const
        {
            assert(isScalar());
            if (minRef != maxRef)
                return merge(minRef, maxRef);
            return minRef;
        }",9,9,lib/infer.cpp,Interval.getScalarRef<const>:vector<constValueFlow.Value*>(),<empty>,,false,108,114,getScalarRef,,,13,vector<const ValueFlow::Value*>()
111669152588,METHOD,Interval,TYPE_DECL,"static Interval fromInt(MathLib::bigint x, const ValueFlow::Value* ref = nullptr)
        {
            Interval result;
            result.setMinValue(x, ref);
            result.setMaxValue(x, ref);
            return result;
        }",9,9,lib/infer.cpp,"Interval.fromInt:Interval(MathLib.bigint,ValueFlow.Value*)",<empty>,,false,116,122,fromInt,,,14,"Interval(MathLib.bigint,ValueFlow.Value*)"
111669152589,METHOD,Interval,TYPE_DECL,"static Interval fromValues(const std::list<ValueFlow::Value>& values, Predicate predicate)
        {
            Interval result;
            const ValueFlow::Value* minValue = getCompareValue(values, predicate, std::less<MathLib::bigint>{});
            if (minValue) {
                if (minValue->isImpossible() && minValue->bound == ValueFlow::Value::Bound::Upper)
                    result.setMinValue(minValue->intvalue + 1, minValue);
                if (minValue->isPossible() && minValue->bound == ValueFlow::Value::Bound::Lower)
                    result.setMinValue(minValue->intvalue, minValue);
                if (!minValue->isImpossible() && (minValue->bound == ValueFlow::Value::Bound::Point || minValue->isKnown()) &&
                    std::count_if(values.begin(), values.end(), predicate) == 1)
                    return Interval::fromInt(minValue->intvalue, minValue);
            }
            const ValueFlow::Value* maxValue = getCompareValue(values, predicate, std::g...",9,9,lib/infer.cpp,"Interval.fromValues:Interval(std.list<ValueFlow.Value>&,Predicate)",<empty>,,false,125,147,fromValues,,,15,"Interval(std.list<ValueFlow.Value>&,Predicate)"
111669152590,METHOD,Interval,TYPE_DECL,"static Interval fromValues(const std::list<ValueFlow::Value>& values)
        {
            return Interval::fromValues(values, [](const ValueFlow::Value&) {
                return true;
            });
        }",9,9,lib/infer.cpp,Interval.fromValues:Interval(std.list<ValueFlow.Value>&),<empty>,,false,149,154,fromValues,,,16,Interval(std.list<ValueFlow.Value>&)
111669152591,METHOD,Interval,TYPE_DECL,"static std::vector<MathLib::bigint> apply(const std::vector<MathLib::bigint>& x,
                                                  const std::vector<MathLib::bigint>& y,
                                                  F f)
        {
            if (x.empty())
                return {};
            if (y.empty())
                return {};
            return {f(x.front(), y.front())};
        }",9,9,lib/infer.cpp,"Interval.apply:vector<MathLib.bigint>(std.vector<MathLib.bigint>&,std.vector<MathLib.bigint>&,F)",<empty>,,false,157,166,apply,,,17,"vector<MathLib::bigint>(std.vector<MathLib.bigint>&,std.vector<MathLib.bigint>&,F)"
111669152592,METHOD,Interval,TYPE_DECL,"static std::vector<const ValueFlow::Value*> merge(std::vector<const ValueFlow::Value*> x,
                                                          const std::vector<const ValueFlow::Value*>& y)
        {
            x.insert(x.end(), y.cbegin(), y.cend());
            return x;
        }",9,9,lib/infer.cpp,"Interval.merge:vector<constValueFlow.Value*>(std.vector<constValueFlow.Value*>,std.vector<constValueFlow.Value*>&)",<empty>,,false,168,173,merge,,,18,"vector<const ValueFlow::Value*>(std.vector<constValueFlow.Value*>,std.vector<constValueFlow.Value*>&)"
111669152593,METHOD,Interval,TYPE_DECL,"friend Interval operator-(const Interval& lhs, const Interval& rhs)
        {
            Interval result;
            result.minvalue = Interval::apply(lhs.minvalue, rhs.maxvalue, std::minus<MathLib::bigint>{});
            result.maxvalue = Interval::apply(lhs.maxvalue, rhs.minvalue, std::minus<MathLib::bigint>{});
            if (!result.minvalue.empty())
                result.minRef = merge(lhs.minRef, rhs.maxRef);
            if (!result.maxvalue.empty())
                result.maxRef = merge(lhs.maxRef, rhs.minRef);
            return result;
        }",9,9,lib/infer.cpp,"-:Interval(Interval&,Interval&)",<empty>,,false,175,185,-,,,19,"Interval(Interval&,Interval&)"
111669152594,METHOD,Interval,TYPE_DECL,"static std::vector<int> equal(const Interval& lhs,
                                      const Interval& rhs,
                                      std::vector<const ValueFlow::Value*>* ref = nullptr)
        {
            if (!lhs.isScalar())
                return {};
            if (!rhs.isScalar())
                return {};
            if (ref)
                *ref = merge(lhs.getScalarRef(), rhs.getScalarRef());
            return {lhs.minvalue == rhs.minvalue};
        }",9,9,lib/infer.cpp,"Interval.equal:vector<int>(Interval&,Interval&,std.vector<constValueFlow.Value*>*)",<empty>,,false,187,198,equal,,,20,"vector<int>(Interval&,Interval&,std.vector<constValueFlow.Value*>*)"
111669152595,METHOD,Interval,TYPE_DECL,"static std::vector<int> compare(const Interval& lhs,
                                        const Interval& rhs,
                                        std::vector<const ValueFlow::Value*>* ref = nullptr)
        {
            Interval diff = lhs - rhs;
            if (diff.isGreaterThan(0, ref))
                return {1};
            if (diff.isLessThan(0, ref))
                return {-1};
            std::vector<int> eq = Interval::equal(lhs, rhs, ref);
            if (!eq.empty()) {
                if (eq.front() == 0)
                    return {1, -1};
                return {0};
            }
            if (diff.isGreaterThan(-1, ref))
                return {0, 1};
            if (diff.isLessThan(1, ref))
                return {0, -1};
            return {};
        }",9,9,lib/infer.cpp,"Interval.compare:vector<int>(Interval&,Interval&,std.vector<constValueFlow.Value*>*)",<empty>,,false,200,220,compare,,,21,"vector<int>(Interval&,Interval&,std.vector<constValueFlow.Value*>*)"
111669152596,METHOD,Interval,TYPE_DECL,"static std::vector<bool> compare(const std::string& op,
                                         const Interval& lhs,
                                         const Interval& rhs,
                                         std::vector<const ValueFlow::Value*>* ref = nullptr)
        {
            std::vector<int> r = compare(lhs, rhs, ref);
            if (r.empty())
                return {};
            bool b = calculate(op, r.front(), 0);
            if (std::all_of(r.cbegin() + 1, r.cend(), [&](int i) {
                return b == calculate(op, i, 0);
            }))
                return {b};
            return {};
        }",9,9,lib/infer.cpp,"Interval.compare:vector<bool>(std.string&,Interval&,Interval&,std.vector<constValueFlow.Value*>*)",<empty>,,false,222,236,compare,,,22,"vector<bool>(std.string&,Interval&,Interval&,std.vector<constValueFlow.Value*>*)"
111669152597,METHOD,<empty>,<empty>,"[&](const ErrorPathItem& e) {
            return locations.insert(e.first).second;
        }",22,9,lib/infer.cpp,lib/infer.cpp:<global>.addToErrorPath.<lambda>3:ANY(ErrorPathItem&),<empty>,,false,249,251,<lambda>3,,,1,ANY(ErrorPathItem&)
111669152598,METHOD,<empty>,<empty>,"[&](const ErrorPathItem& e) {
            return locations.insert(e.first).second;
        }",22,9,lib/infer.cpp,lib/infer.cpp:<global>.addToErrorPath.<lambda>4:ANY(ErrorPathItem&),<empty>,,false,255,257,<lambda>4,,,1,ANY(ErrorPathItem&)
111669152599,METHOD,lib/infer.cpp:<global>,TYPE_DECL,"static void addToErrorPath(ValueFlow::Value& value, const std::vector<const ValueFlow::Value*>& refs)
{
    std::unordered_set<const Token*> locations;
    for (const ValueFlow::Value* ref : refs) {
        if (ref->condition && !value.condition)
            value.condition = ref->condition;
        std::copy_if(ref->errorPath.cbegin(),
                     ref->errorPath.cend(),
                     std::back_inserter(value.errorPath),
                     [&](const ErrorPathItem& e) {
            return locations.insert(e.first).second;
        });
        std::copy_if(ref->debugPath.cbegin(),
                     ref->debugPath.cend(),
                     std::back_inserter(value.debugPath),
                     [&](const ErrorPathItem& e) {
            return locations.insert(e.first).second;
        });
    }
}",1,1,lib/infer.cpp,"addToErrorPath:void(ValueFlow.Value&,std.vector<constValueFlow.Value*>&)",<empty>,,false,240,259,addToErrorPath,,,1,"void(ValueFlow.Value&,std.vector<constValueFlow.Value*>&)"
111669152600,METHOD,lib/infer.cpp:<global>,TYPE_DECL,"static void setValueKind(ValueFlow::Value& value, const std::vector<const ValueFlow::Value*>& refs)
{
    bool isPossible = false;
    bool isInconclusive = false;
    for (const ValueFlow::Value* ref : refs) {
        if (ref->isPossible())
            isPossible = true;
        if (ref->isInconclusive())
            isInconclusive = true;
    }
    if (isInconclusive)
        value.setInconclusive();
    else if (isPossible)
        value.setPossible();
    else
        value.setKnown();
}",1,1,lib/infer.cpp,"setValueKind:void(ValueFlow.Value&,std.vector<constValueFlow.Value*>&)",<empty>,,false,261,277,setValueKind,,,1,"void(ValueFlow.Value&,std.vector<constValueFlow.Value*>&)"
111669152601,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& value) {
        return value.isImpossible() && value.intvalue == x;
    }",56,5,lib/infer.cpp,lib/infer.cpp:<global>.inferNotEqual.<lambda>5:bool(ValueFlow.Value&),<empty>,,false,281,283,<lambda>5,,,1,bool(ValueFlow.Value&)
111669152602,METHOD,lib/infer.cpp:<global>,TYPE_DECL,"static bool inferNotEqual(const std::list<ValueFlow::Value>& values, MathLib::bigint x)
{
    return std::any_of(values.cbegin(), values.cend(), [&](const ValueFlow::Value& value) {
        return value.isImpossible() && value.intvalue == x;
    });
}",1,1,lib/infer.cpp,"inferNotEqual:bool(std.list<ValueFlow.Value>&,MathLib.bigint)",<empty>,,false,279,284,inferNotEqual,,,1,"bool(std.list<ValueFlow.Value>&,MathLib.bigint)"
111669152603,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& value) {
        return !model->match(value);
    }",21,5,lib/infer.cpp,"lib/infer.cpp:<global>.infer:vector<ValueFlow.Value>(ValuePtr<InferModel>&,std.string&,std.list<ValueFlow.Value>,std.list<ValueFlow.Value>).<lambda>6:bool(ValueFlow.Value&)",<empty>,,false,292,294,<lambda>6,,,1,bool(ValueFlow.Value&)
111669152604,METHOD,lib/infer.cpp:<global>,TYPE_DECL,"std::vector<ValueFlow::Value> infer(const ValuePtr<InferModel>& model,
                                    const std::string& op,
                                    std::list<ValueFlow::Value> lhsValues,
                                    std::list<ValueFlow::Value> rhsValues)
{
    std::vector<ValueFlow::Value> result;
    auto notMatch = [&](const ValueFlow::Value& value) {
        return !model->match(value);
    };
    lhsValues.remove_if(notMatch);
    if (lhsValues.empty())
        return result;
    rhsValues.remove_if(notMatch);
    if (rhsValues.empty())
        return result;

    Interval lhs = Interval::fromValues(lhsValues);
    Interval rhs = Interval::fromValues(rhsValues);

    if (op == ""-"") {
        Interval diff = lhs - rhs;
        if (diff.isScalar()) {
            std::vector<const ValueFlow::Value*> refs = diff.getScalarRef();
            ValueFlow::Value value(diff.getScalar());
            addToErrorPath(value, refs);
            setValueKind(value, refs)...",1,1,lib/infer.cpp,"infer:vector<ValueFlow.Value>(ValuePtr<InferModel>&,std.string&,std.list<ValueFlow.Value>,std.list<ValueFlow.Value>)",<empty>,,false,286,361,infer,,,1,"vector<ValueFlow::Value>(ValuePtr<InferModel>&,std.string&,std.list<ValueFlow.Value>,std.list<ValueFlow.Value>)"
111669152605,METHOD,lib/infer.cpp:<global>,TYPE_DECL,"std::vector<ValueFlow::Value> infer(const ValuePtr<InferModel>& model,
                                    const std::string& op,
                                    MathLib::bigint lhs,
                                    std::list<ValueFlow::Value> rhsValues)
{
    return infer(model, op, {model->yield(lhs)}, std::move(rhsValues));
}",1,1,lib/infer.cpp,"infer:vector<ValueFlow.Value>(ValuePtr<InferModel>&,std.string&,MathLib.bigint,std.list<ValueFlow.Value>)",<empty>,,false,363,369,infer,,,1,"vector<ValueFlow::Value>(ValuePtr<InferModel>&,std.string&,MathLib.bigint,std.list<ValueFlow.Value>)"
111669152606,METHOD,lib/infer.cpp:<global>,TYPE_DECL,"std::vector<ValueFlow::Value> infer(const ValuePtr<InferModel>& model,
                                    const std::string& op,
                                    std::list<ValueFlow::Value> lhsValues,
                                    MathLib::bigint rhs)
{
    return infer(model, op, std::move(lhsValues), {model->yield(rhs)});
}",1,1,lib/infer.cpp,"infer:vector<ValueFlow.Value>(ValuePtr<InferModel>&,std.string&,std.list<ValueFlow.Value>,MathLib.bigint)",<empty>,,false,371,377,infer,,,1,"vector<ValueFlow::Value>(ValuePtr<InferModel>&,std.string&,std.list<ValueFlow.Value>,MathLib.bigint)"
111669152607,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
        return model->match(v);
    }",41,5,lib/infer.cpp,"lib/infer.cpp:<global>.getMinValue:vector<MathLib.bigint>(ValuePtr<InferModel>&,std.list<ValueFlow.Value>&).<lambda>7:bool(ValueFlow.Value&)",<empty>,,false,381,383,<lambda>7,,,1,bool(ValueFlow.Value&)
111669152608,METHOD,lib/infer.cpp:<global>,TYPE_DECL,"std::vector<MathLib::bigint> getMinValue(const ValuePtr<InferModel>& model, const std::list<ValueFlow::Value>& values)
{
    return Interval::fromValues(values, [&](const ValueFlow::Value& v) {
        return model->match(v);
    }).minvalue;
}",1,1,lib/infer.cpp,"getMinValue:vector<MathLib.bigint>(ValuePtr<InferModel>&,std.list<ValueFlow.Value>&)",<empty>,,false,379,384,getMinValue,,,1,"vector<MathLib::bigint>(ValuePtr<InferModel>&,std.list<ValueFlow.Value>&)"
111669152609,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
        return model->match(v);
    }",41,5,lib/infer.cpp,"lib/infer.cpp:<global>.getMaxValue:vector<MathLib.bigint>(ValuePtr<InferModel>&,std.list<ValueFlow.Value>&).<lambda>8:bool(ValueFlow.Value&)",<empty>,,false,387,389,<lambda>8,,,1,bool(ValueFlow.Value&)
111669152610,METHOD,lib/infer.cpp:<global>,TYPE_DECL,"std::vector<MathLib::bigint> getMaxValue(const ValuePtr<InferModel>& model, const std::list<ValueFlow::Value>& values)
{
    return Interval::fromValues(values, [&](const ValueFlow::Value& v) {
        return model->match(v);
    }).maxvalue;
}",1,1,lib/infer.cpp,"getMaxValue:vector<MathLib.bigint>(ValuePtr<InferModel>&,std.list<ValueFlow.Value>&)",<empty>,,false,385,390,getMaxValue,,,1,"vector<MathLib::bigint>(ValuePtr<InferModel>&,std.list<ValueFlow.Value>&)"
111669152611,METHOD,IntegralInferModel,TYPE_DECL,"bool match(const ValueFlow::Value& value) const override {
            return value.isIntValue();
        }",9,9,lib/infer.cpp,IntegralInferModel.match<const>:bool(ValueFlow.Value&),<empty>,,false,394,396,match,,,1,bool(ValueFlow.Value&)
111669152612,METHOD,IntegralInferModel,TYPE_DECL,"ValueFlow::Value yield(MathLib::bigint value) const override
        {
            ValueFlow::Value result(value);
            result.valueType = ValueFlow::Value::ValueType::INT;
            result.setKnown();
            return result;
        }",9,9,lib/infer.cpp,IntegralInferModel.yield<const>:ValueFlow.Value(MathLib.bigint),<empty>,,false,397,403,yield,,,2,ValueFlow.Value(MathLib.bigint)
111669152613,METHOD,lib/infer.cpp:<global>,TYPE_DECL,"ValuePtr<InferModel> makeIntegralInferModel()
{
    return IntegralInferModel{};
}",1,1,lib/infer.cpp,makeIntegralInferModel:ValuePtr<InferModel>(),<empty>,,false,407,410,makeIntegralInferModel,,,1,ValuePtr<InferModel>()
111669152614,METHOD,lib/infer.cpp:<global>,TYPE_DECL,"ValueFlow::Value inferCondition(const std::string& op, const Token* varTok, MathLib::bigint val)
{
    if (!varTok)
        return ValueFlow::Value{};
    if (varTok->hasKnownIntValue())
        return ValueFlow::Value{};
    std::vector<ValueFlow::Value> r = infer(makeIntegralInferModel(), op, varTok->values(), val);
    if (r.size() == 1 && r.front().isKnown())
        return r.front();
    return ValueFlow::Value{};
}",1,1,lib/infer.cpp,"inferCondition:ValueFlow.Value(std.string&,Token*,MathLib.bigint)",<empty>,,false,412,422,inferCondition,,,1,"ValueFlow.Value(std.string&,Token*,MathLib.bigint)"
111669152615,METHOD,lib/infer.h:<global>,TYPE_DECL,<global>,1,1,lib/infer.h,lib/infer.h:<global>,<empty>,,false,1,68,<global>,,,1,
111669152616,METHOD,lib/json.h:<global>,TYPE_DECL,<global>,1,1,lib/json.h,lib/json.h:<global>,<empty>,,false,1,43,<global>,,,1,
111669152617,METHOD,lib/keywords.cpp:<global>,TYPE_DECL,"const std::unordered_set<std::string>& Keywords::getAll(Standards::cstd_t cStd)
{
    // cppcheck-suppress missingReturn
    switch (cStd) {
    case Standards::cstd_t::C89:
        return c89_keywords_all;
    case Standards::cstd_t::C99:
        return c99_keywords_all;
    case Standards::cstd_t::C11:
        return c11_keywords_all;
    case Standards::cstd_t::C17:
        return c17_keywords_all;
    case Standards::cstd_t::C23:
        return c23_keywords_all;
    }
    cppcheck::unreachable();
}",1,1,lib/keywords.cpp,Keywords.getAll:ANY(Standards.cstd_t),<empty>,,false,170,186,getAll,,,1,ANY(Standards.cstd_t)
111669152618,METHOD,lib/keywords.cpp:<global>,TYPE_DECL,<global>,1,1,lib/keywords.cpp,lib/keywords.cpp:<global>,<empty>,,false,1,250,<global>,,,1,
111669152619,METHOD,lib/keywords.cpp:<global>,TYPE_DECL,"const std::unordered_set<std::string>& Keywords::getAll(Standards::cppstd_t cppStd) {
    // cppcheck-suppress missingReturn
    switch (cppStd) {
    case Standards::cppstd_t::CPP03:
        return cpp03_keywords_all;
    case Standards::cppstd_t::CPP11:
        return cpp11_keywords_all;
    case Standards::cppstd_t::CPP14:
        return cpp14_keywords_all;
    case Standards::cppstd_t::CPP17:
        return cpp17_keywords_all;
    case Standards::cppstd_t::CPP20:
        return cpp20_keywords_all;
    case Standards::cppstd_t::CPP23:
        return cpp23_keywords_all;
    case Standards::cppstd_t::CPP26:
        return cpp26_keywords_all;
    }
    cppcheck::unreachable();
}",1,1,lib/keywords.cpp,Keywords.getAll:ANY(Standards.cppstd_t),<empty>,,false,189,208,getAll,,,1,ANY(Standards.cppstd_t)
111669152620,METHOD,lib/keywords.cpp:<global>,TYPE_DECL,"const std::unordered_set<std::string>& Keywords::getOnly(Standards::cstd_t cStd)
{
    // cppcheck-suppress missingReturn
    switch (cStd) {
    case Standards::cstd_t::C89:
        return c89_keywords;
    case Standards::cstd_t::C99:
        return c99_keywords;
    case Standards::cstd_t::C11:
        return c11_keywords;
    case Standards::cstd_t::C17:
        return c17_keywords;
    case Standards::cstd_t::C23:
        return c23_keywords;
    }
    cppcheck::unreachable();
}",1,1,lib/keywords.cpp,Keywords.getOnly:ANY(Standards.cstd_t),<empty>,,false,211,227,getOnly,,,1,ANY(Standards.cstd_t)
111669152621,METHOD,lib/keywords.cpp:<global>,TYPE_DECL,"const std::unordered_set<std::string>& Keywords::getOnly(Standards::cppstd_t cppStd)
{
    // cppcheck-suppress missingReturn
    switch (cppStd) {
    case Standards::cppstd_t::CPP03:
        return cpp03_keywords;
    case Standards::cppstd_t::CPP11:
        return cpp11_keywords;
    case Standards::cppstd_t::CPP14:
        return cpp14_keywords;
    case Standards::cppstd_t::CPP17:
        return cpp17_keywords;
    case Standards::cppstd_t::CPP20:
        return cpp20_keywords;
    case Standards::cppstd_t::CPP23:
        return cpp23_keywords;
    case Standards::cppstd_t::CPP26:
        return cpp26_keywords;
    }
    cppcheck::unreachable();
}",1,1,lib/keywords.cpp,Keywords.getOnly:ANY(Standards.cppstd_t),<empty>,,false,230,250,getOnly,,,1,ANY(Standards.cppstd_t)
111669152622,METHOD,lib/keywords.h:<global>,TYPE_DECL,<global>,1,1,lib/keywords.h,lib/keywords.h:<global>,<empty>,,false,1,37,<global>,,,1,
111669152623,METHOD,Library.LibraryData.Platform,TYPE_DECL,"const PlatformType *platform_type(const std::string &name) const {
            const auto it = utils::as_const(mPlatformTypes).find(name);
            return (it != mPlatformTypes.end()) ? &(it->second) : nullptr;
        }",9,9,lib/library.cpp,Library.LibraryData.Platform.platform_type<const>:Library.PlatformType*(std.string&),<empty>,,false,48,51,platform_type,,,1,Library.PlatformType*(std.string&)
111669152624,METHOD,Library.LibraryData.ExportedFunctions,TYPE_DECL,"void addPrefix(std::string prefix) {
            mPrefixes.insert(std::move(prefix));
        }",9,9,lib/library.cpp,Library.LibraryData.ExportedFunctions.addPrefix:void(std.string),<empty>,,false,57,59,addPrefix,,,1,void(std.string)
111669152625,METHOD,Library.LibraryData.ExportedFunctions,TYPE_DECL,"void addSuffix(std::string suffix) {
            mSuffixes.insert(std::move(suffix));
        }",9,9,lib/library.cpp,Library.LibraryData.ExportedFunctions.addSuffix:void(std.string),<empty>,,false,60,62,addSuffix,,,2,void(std.string)
111669152626,METHOD,Library.LibraryData.ExportedFunctions,TYPE_DECL,"bool isPrefix(const std::string& prefix) const {
            return (mPrefixes.find(prefix) != mPrefixes.end());
        }",9,9,lib/library.cpp,Library.LibraryData.ExportedFunctions.isPrefix<const>:bool(std.string&),<empty>,,false,63,65,isPrefix,,,3,bool(std.string&)
111669152627,METHOD,Library.LibraryData.ExportedFunctions,TYPE_DECL,"bool isSuffix(const std::string& suffix) const {
            return (mSuffixes.find(suffix) != mSuffixes.end());
        }",9,9,lib/library.cpp,Library.LibraryData.ExportedFunctions.isSuffix<const>:bool(std.string&),<empty>,,false,66,68,isSuffix,,,4,bool(std.string&)
111669152628,METHOD,Library.LibraryData.CodeBlock,TYPE_DECL,CodeBlock() = default;,9,30,lib/library.cpp,Library.LibraryData.CodeBlock.CodeBlock:ANY(),<empty>,,false,77,77,CodeBlock,,,1,ANY()
111669152629,METHOD,Library.LibraryData.CodeBlock,TYPE_DECL,"void setStart(const char* s) {
            mStart = s;
        }",9,9,lib/library.cpp,Library.LibraryData.CodeBlock.setStart:void(char*),<empty>,,false,79,81,setStart,,,2,void(char*)
111669152630,METHOD,Library.LibraryData.CodeBlock,TYPE_DECL,"void setEnd(const char* e) {
            mEnd = e;
        }",9,9,lib/library.cpp,Library.LibraryData.CodeBlock.setEnd:void(char*),<empty>,,false,82,84,setEnd,,,3,void(char*)
111669152631,METHOD,Library.LibraryData.CodeBlock,TYPE_DECL,"void setOffset(const int o) {
            mOffset = o;
        }",9,9,lib/library.cpp,Library.LibraryData.CodeBlock.setOffset:void(int),<empty>,,false,85,87,setOffset,,,4,void(int)
111669152632,METHOD,Library.LibraryData.CodeBlock,TYPE_DECL,"void addBlock(const char* blockName) {
            mBlocks.insert(blockName);
        }",9,9,lib/library.cpp,Library.LibraryData.CodeBlock.addBlock:void(char*),<empty>,,false,88,90,addBlock,,,5,void(char*)
111669152633,METHOD,Library.LibraryData.CodeBlock,TYPE_DECL,"const std::string& start() const {
            return mStart;
        }",9,9,lib/library.cpp,Library.LibraryData.CodeBlock.start<const>:ANY(),<empty>,,false,91,93,start,,,6,ANY()
111669152634,METHOD,Library.LibraryData.CodeBlock,TYPE_DECL,"const std::string& end() const {
            return mEnd;
        }",9,9,lib/library.cpp,Library.LibraryData.CodeBlock.end<const>:ANY(),<empty>,,false,94,96,end,,,7,ANY()
111669152635,METHOD,Library.LibraryData.CodeBlock,TYPE_DECL,"int offset() const {
            return mOffset;
        }",9,9,lib/library.cpp,Library.LibraryData.CodeBlock.offset<const>:int(),<empty>,,false,97,99,offset,,,8,int()
111669152636,METHOD,Library.LibraryData.CodeBlock,TYPE_DECL,"bool isBlock(const std::string& blockName) const {
            return mBlocks.find(blockName) != mBlocks.end();
        }",9,9,lib/library.cpp,Library.LibraryData.CodeBlock.isBlock<const>:bool(std.string&),<empty>,,false,100,102,isBlock,,,9,bool(std.string&)
111669152637,METHOD,<empty>,<empty>,<empty>,5,,lib/library.cpp,Library.LibraryData.CodeBlock.<clinit>,<empty>,,false,75,,<clinit>,,,14,
111669152638,METHOD,<empty>,<empty>,<empty>,1,,lib/library.cpp,Library.LibraryData.<clinit>,<empty>,,false,45,,<clinit>,,,34,
111669152639,METHOD,lib/library.cpp:<global>,TYPE_DECL,<global>,1,1,lib/library.cpp,lib/library.cpp:<global>,<empty>,,false,1,2032,<global>,,,1,
111669152640,METHOD,lib/library.cpp:<global>,TYPE_DECL,"Library::Library()
    : mData(new LibraryData())
{}",1,2,lib/library.cpp,Library.Library:ANY(),<empty>,,false,148,150,Library,,,1,Library.Library:ANY()()
111669152641,METHOD,lib/library.cpp:<global>,TYPE_DECL,Library::~Library() = default;,1,30,lib/library.cpp,Library.~Library:ANY(),<empty>,,false,152,152,~Library,,,1,ANY()
111669152642,METHOD,lib/library.cpp:<global>,TYPE_DECL,"Library::Library(const Library& other)
    : mData(new LibraryData(*other.mData))
{}",1,2,lib/library.cpp,Library.Library:ANY(Library&),<empty>,,false,154,156,Library,,,1,Library.Library:ANY(Library&)(Library&)
111669152643,METHOD,lib/library.cpp:<global>,TYPE_DECL,"Library& Library::operator=(const Library& other) &
{
    if (this == &other)
        return *this;

    mData.reset(new LibraryData(*other.mData));
    return *this;
}",1,1,lib/library.cpp,Library.=:Library&(Library&),<empty>,,false,158,165,=,,,1,Library&(Library&)
111669152644,METHOD,lib/library.cpp:<global>,TYPE_DECL,"static std::vector<std::string> getnames(const char *names)
{
    std::vector<std::string> ret;
    while (const char *p = std::strchr(names,',')) {
        ret.emplace_back(names, p-names);
        names = p + 1;
    }
    ret.emplace_back(names);
    return ret;
}",1,1,lib/library.cpp,getnames:vector<std.string>(char*),<empty>,,false,167,176,getnames,,,1,vector<std::string>(char*)
111669152645,METHOD,lib/library.cpp:<global>,TYPE_DECL,"static void gettokenlistfromvalid(const std::string& valid, bool cpp, TokenList& tokenList)
{
    std::istringstream istr(valid + ',');
    tokenList.createTokens(istr, cpp ? Standards::Language::CPP : Standards::Language::C); // TODO: check result?
    for (Token *tok = tokenList.front(); tok; tok = tok->next()) {
        if (Token::Match(tok,""- %num%"")) {
            tok->str(""-"" + tok->strAt(1));
            tok->deleteNext();
        }
    }
}",1,1,lib/library.cpp,"gettokenlistfromvalid:void(std.string&,bool,TokenList&)",<empty>,,false,178,188,gettokenlistfromvalid,,,1,"void(std.string&,bool,TokenList&)"
111669152646,METHOD,lib/library.cpp:<global>,TYPE_DECL,"Library::Error Library::load(const char exename[], const char path[], bool debug)
{
    if (std::strchr(path,',') != nullptr) {
        throw std::runtime_error(""handling of multiple libraries not supported"");
    }

    const bool is_abs_path = Path::isAbsolute(path);

    std::string absolute_path;
    // open file..
    tinyxml2::XMLDocument doc;
    if (debug)
        std::cout << ""looking for library '"" + std::string(path) + ""'"" << std::endl;
    tinyxml2::XMLError error = xml_LoadFile(doc, path);
    if (error == tinyxml2::XML_ERROR_FILE_NOT_FOUND) {
        // failed to open file.. is there no extension?
        std::string fullfilename(path);
        if (Path::getFilenameExtension(fullfilename).empty()) {
            fullfilename += "".cfg"";
            if (debug)
                std::cout << ""looking for library '"" + fullfilename + ""'"" << std::endl;
            error = xml_LoadFile(doc, fullfilename.c_str());
            if (error != tinyxml2::XML_ERROR_FILE_NOT_FOUND)
     ...",1,1,lib/library.cpp,"Library.load:Library.Error(char[],char[],bool)",<empty>,,false,190,263,load,,,1,"Library.Error(char[],char[],bool)"
111669152647,METHOD,lib/library.cpp:<global>,TYPE_DECL,"Library::Container::Yield Library::Container::yieldFrom(const std::string& yieldName)
{
    if (yieldName == ""at_index"")
        return Container::Yield::AT_INDEX;
    if (yieldName == ""item"")
        return Container::Yield::ITEM;
    if (yieldName == ""buffer"")
        return Container::Yield::BUFFER;
    if (yieldName == ""buffer-nt"")
        return Container::Yield::BUFFER_NT;
    if (yieldName == ""start-iterator"")
        return Container::Yield::START_ITERATOR;
    if (yieldName == ""end-iterator"")
        return Container::Yield::END_ITERATOR;
    if (yieldName == ""iterator"")
        return Container::Yield::ITERATOR;
    if (yieldName == ""size"")
        return Container::Yield::SIZE;
    if (yieldName == ""empty"")
        return Container::Yield::EMPTY;
    return Container::Yield::NO_YIELD;
}",1,1,lib/library.cpp,Library.Container.yieldFrom:Library.Container.Yield(std.string&),<empty>,,false,265,286,yieldFrom,,,1,Library.Container.Yield(std.string&)
111669152648,METHOD,lib/library.cpp:<global>,TYPE_DECL,"Library::Container::Action Library::Container::actionFrom(const std::string& actionName)
{
    if (actionName == ""resize"")
        return Container::Action::RESIZE;
    if (actionName == ""clear"")
        return Container::Action::CLEAR;
    if (actionName == ""push"")
        return Container::Action::PUSH;
    if (actionName == ""pop"")
        return Container::Action::POP;
    if (actionName == ""find"")
        return Container::Action::FIND;
    if (actionName == ""find-const"")
        return Container::Action::FIND_CONST;
    if (actionName == ""insert"")
        return Container::Action::INSERT;
    if (actionName == ""erase"")
        return Container::Action::ERASE;
    if (actionName == ""append"")
        return Container::Action::APPEND;
    if (actionName == ""change-content"")
        return Container::Action::CHANGE_CONTENT;
    if (actionName == ""change-internal"")
        return Container::Action::CHANGE_INTERNAL;
    if (actionName == ""change"")
        return Container::Action::CH...",1,1,lib/library.cpp,Library.Container.actionFrom:Library.Container.Action(std.string&),<empty>,,false,287,314,actionFrom,,,1,Library.Container.Action(std.string&)
111669152649,METHOD,lib/library.cpp:<global>,TYPE_DECL,"Library::Error Library::load(const tinyxml2::XMLDocument &doc)
{
    const tinyxml2::XMLElement * const rootnode = doc.FirstChildElement();

    if (rootnode == nullptr) {
        doc.PrintError();
        return Error(ErrorCode::BAD_XML);
    }

    if (strcmp(rootnode->Name(),""def"") != 0)
        return Error(ErrorCode::UNSUPPORTED_FORMAT, rootnode->Name());

    const int format = rootnode->IntAttribute(""format"", 1); // Assume format version 1 if nothing else is specified (very old .cfg files had no 'format' attribute)

    if (format > 2 || format <= 0)
        return Error(ErrorCode::UNSUPPORTED_FORMAT);

    std::set<std::string> unknown_elements;

    for (const tinyxml2::XMLElement *node = rootnode->FirstChildElement(); node; node = node->NextSiblingElement()) {
        const std::string nodename = node->Name();
        if (nodename == ""memory"" || nodename == ""resource"") {
            // get allocationId to use..
            int allocationId = 0;
            for (const tinyx...",1,1,lib/library.cpp,Library.load:Library.Error(tinyxml2.XMLDocument&),<empty>,,false,316,799,load,,,1,Library.Error(tinyxml2.XMLDocument&)
111669152650,METHOD,lib/library.cpp:<global>,TYPE_DECL,"Library::Error Library::loadFunction(const tinyxml2::XMLElement * const node, const std::string &name, std::set<std::string> &unknown_elements)
{
    if (name.empty())
        return Error(ErrorCode::OK);

    // TODO: write debug warning if we modify an existing entry
    Function& func = mData->mFunctions[name];

    for (const tinyxml2::XMLElement *functionnode = node->FirstChildElement(); functionnode; functionnode = functionnode->NextSiblingElement()) {
        const std::string functionnodename = functionnode->Name();
        if (functionnodename == ""noreturn"") {
            const char * const text = functionnode->GetText();
            if (strcmp(text, ""false"") == 0)
                mData->mNoReturn[name] = LibraryData::FalseTrueMaybe::False;
            else if (strcmp(text, ""maybe"") == 0)
                mData->mNoReturn[name] = LibraryData::FalseTrueMaybe::Maybe;
            else
                mData->mNoReturn[name] = LibraryData::FalseTrueMaybe::True; // Safe
        } ...",1,1,lib/library.cpp,"Library.loadFunction:Library.Error(tinyxml2.XMLElement*,std.string&,std.set<std.string>&)",<empty>,,false,801,1055,loadFunction,,,1,"Library.Error(tinyxml2.XMLElement*,std.string&,std.set<std.string>&)"
111669152651,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isIntArgValid(const Token *ftok, int argnr, const MathLib::bigint argvalue) const
{
    const ArgumentChecks *ac = getarg(ftok, argnr);
    if (!ac || ac->valid.empty())
        return true;
    if (ac->valid.find('.') != std::string::npos)
        return isFloatArgValid(ftok, argnr, static_cast<double>(argvalue));
    TokenList tokenList(nullptr);
    gettokenlistfromvalid(ac->valid, ftok->isCpp(), tokenList);
    for (const Token *tok = tokenList.front(); tok; tok = tok->next()) {
        if (tok->isNumber() && argvalue == MathLib::toBigNumber(tok))
            return true;
        if (Token::Match(tok, ""%num% : %num%"") && argvalue >= MathLib::toBigNumber(tok) && argvalue <= MathLib::toBigNumber(tok->tokAt(2)))
            return true;
        if (Token::Match(tok, ""%num% : ,"") && argvalue >= MathLib::toBigNumber(tok))
            return true;
        if ((!tok->previous() || tok->strAt(-1) == "","") && Token::Match(tok,"": %num%"") && argvalue <= MathLib::toBigNumber(to...",1,1,lib/library.cpp,"Library.isIntArgValid<const>:bool(Token*,int,MathLib.bigint)",<empty>,,false,1057,1077,isIntArgValid,,,1,"bool(Token*,int,MathLib.bigint)"
111669152652,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isFloatArgValid(const Token *ftok, int argnr, double argvalue) const
{
    const ArgumentChecks *ac = getarg(ftok, argnr);
    if (!ac || ac->valid.empty())
        return true;
    TokenList tokenList(nullptr);
    gettokenlistfromvalid(ac->valid, ftok->isCpp(), tokenList);
    for (const Token *tok = tokenList.front(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""%num% : %num%"") && argvalue >= MathLib::toDoubleNumber(tok) && argvalue <= MathLib::toDoubleNumber(tok->tokAt(2)))
            return true;
        if (Token::Match(tok, ""%num% : ,"") && argvalue >= MathLib::toDoubleNumber(tok))
            return true;
        if ((!tok->previous() || tok->strAt(-1) == "","") && Token::Match(tok,"": %num%"") && argvalue <= MathLib::toDoubleNumber(tok->tokAt(1)))
            return true;
        if (Token::Match(tok, ""%num%"") && MathLib::isFloat(tok->str()) && MathLib::isEqual(tok->str(), MathLib::toString(argvalue)))
            return true;
        if (Token::Match(...",1,1,lib/library.cpp,"Library.isFloatArgValid<const>:bool(Token*,int,double)",<empty>,,false,1079,1099,isFloatArgValid,,,1,"bool(Token*,int,double)"
111669152653,METHOD,lib/library.cpp:<global>,TYPE_DECL,"std::string Library::getFunctionName(const Token *ftok, bool &error) const
{
    if (!ftok) {
        error = true;
        return """";
    }
    if (ftok->isName()) {
        if (Token::simpleMatch(ftok->astParent(), ""::""))
            return ftok->str();
        for (const Scope *scope = ftok->scope(); scope; scope = scope->nestedIn) {
            if (!scope->isClassOrStruct())
                continue;
            const std::vector<Type::BaseInfo> &derivedFrom = scope->definedType->derivedFrom;
            for (const Type::BaseInfo & baseInfo : derivedFrom) {
                std::string name;
                const Token* tok = baseInfo.nameTok; // baseInfo.name still contains template parameters, but is missing namespaces
                if (tok->str() == ""::"")
                    tok = tok->next();
                while (Token::Match(tok, ""%name%|::"")) {
                    name += tok->str();
                    tok = tok->next();
                }
                name += ""::"" +...",1,1,lib/library.cpp,"Library.getFunctionName<const>:string(Token*,bool&)",<empty>,,false,1101,1146,getFunctionName,,,1,"string(Token*,bool&)"
111669152654,METHOD,lib/library.cpp:<global>,TYPE_DECL,"std::string Library::getFunctionName(const Token *ftok) const
{
    if (!Token::Match(ftok, ""%name% )| ("") && (ftok->strAt(-1) != ""&"" || ftok->previous()->astOperand2()))
        return """";

    // Lookup function name using AST..
    if (ftok->astParent()) {
        bool error = false;
        const Token * tok = ftok->astParent()->isUnaryOp(""&"") ? ftok->astParent()->astOperand1() : ftok->next()->astOperand1();
        std::string ret = getFunctionName(tok, error);
        if (error)
            return {};
        if (startsWith(ret, ""::""))
            ret.erase(0, 2);
        return ret;
    }

    // Lookup function name without using AST..
    if (Token::simpleMatch(ftok->previous(), "".""))
        return """";
    if (!Token::Match(ftok->tokAt(-2), ""%name% ::""))
        return ftok->str();
    std::string ret(ftok->str());
    ftok = ftok->tokAt(-2);
    while (Token::Match(ftok, ""%name% ::"")) {
        ret = ftok->str() + ""::"" + ret;
        ftok = ftok->tokAt(-2);
    }
    retu...",1,1,lib/library.cpp,Library.getFunctionName<const>:string(Token*),<empty>,,false,1148,1177,getFunctionName,,,1,string(Token*)
111669152655,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isnullargbad(const Token *ftok, int argnr) const
{
    const ArgumentChecks *arg = getarg(ftok, argnr);
    if (!arg) {
        // scan format string argument should not be null
        const std::string funcname = getFunctionName(ftok);
        const auto it = utils::as_const(mData->mFunctions).find(funcname);
        if (it != mData->mFunctions.cend() && it->second.formatstr && it->second.formatstr_scan)
            return true;
    }
    return arg && arg->notnull;
}",1,1,lib/library.cpp,"Library.isnullargbad<const>:bool(Token*,int)",<empty>,,false,1179,1190,isnullargbad,,,1,"bool(Token*,int)"
111669152656,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isuninitargbad(const Token *ftok, int argnr, int indirect, bool *hasIndirect) const
{
    const ArgumentChecks *arg = getarg(ftok, argnr);
    if (!arg) {
        // non-scan format string argument should not be uninitialized
        const std::string funcname = getFunctionName(ftok);
        const auto it = utils::as_const(mData->mFunctions).find(funcname);
        if (it != mData->mFunctions.cend() && it->second.formatstr && !it->second.formatstr_scan)
            return true;
    }
    if (hasIndirect && arg && arg->notuninit >= 1)
        *hasIndirect = true;
    return arg && arg->notuninit >= indirect;
}",1,1,lib/library.cpp,"Library.isuninitargbad<const>:bool(Token*,int,int,bool*)",<empty>,,false,1192,1205,isuninitargbad,,,1,"bool(Token*,int,int,bool*)"
111669152657,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const Library::AllocFunc* Library::getAllocFuncInfo(const Token *tok) const
{
    while (Token::simpleMatch(tok, ""::""))
        tok = tok->astOperand2() ? tok->astOperand2() : tok->astOperand1();
    if (!tok)
        return nullptr;
    const std::string funcname = getFunctionName(tok);
    return isNotLibraryFunction(tok) && mData->mFunctions.find(funcname) != mData->mFunctions.end() ? nullptr : getAllocDealloc(mData->mAlloc, funcname);
}",1,1,lib/library.cpp,Library.getAllocFuncInfo<const>:Library.AllocFunc*(Token*),<empty>,,false,1209,1217,getAllocFuncInfo,,,1,Library.AllocFunc*(Token*)
111669152658,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const Library::AllocFunc* Library::getDeallocFuncInfo(const Token *tok) const
{
    while (Token::simpleMatch(tok, ""::""))
        tok = tok->astOperand2() ? tok->astOperand2() : tok->astOperand1();
    if (!tok)
        return nullptr;
    const std::string funcname = getFunctionName(tok);
    return isNotLibraryFunction(tok) && mData->mFunctions.find(funcname) != mData->mFunctions.end() ? nullptr : getAllocDealloc(mData->mDealloc, funcname);
}",1,1,lib/library.cpp,Library.getDeallocFuncInfo<const>:Library.AllocFunc*(Token*),<empty>,,false,1220,1228,getDeallocFuncInfo,,,1,Library.AllocFunc*(Token*)
111669152659,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const Library::AllocFunc* Library::getReallocFuncInfo(const Token *tok) const
{
    while (Token::simpleMatch(tok, ""::""))
        tok = tok->astOperand2() ? tok->astOperand2() : tok->astOperand1();
    if (!tok)
        return nullptr;
    const std::string funcname = getFunctionName(tok);
    return isNotLibraryFunction(tok) && mData->mFunctions.find(funcname) != mData->mFunctions.end() ? nullptr : getAllocDealloc(mData->mRealloc, funcname);
}",1,1,lib/library.cpp,Library.getReallocFuncInfo<const>:Library.AllocFunc*(Token*),<empty>,,false,1231,1239,getReallocFuncInfo,,,1,Library.AllocFunc*(Token*)
111669152660,METHOD,lib/library.cpp:<global>,TYPE_DECL,"int Library::getAllocId(const Token *tok, int arg) const
{
    const Library::AllocFunc* af = getAllocFuncInfo(tok);
    return (af && af->arg == arg) ? af->groupId : 0;
}",1,1,lib/library.cpp,"Library.getAllocId<const>:int(Token*,int)",<empty>,,false,1242,1246,getAllocId,,,1,"int(Token*,int)"
111669152661,METHOD,lib/library.cpp:<global>,TYPE_DECL,"int Library::getDeallocId(const Token *tok, int arg) const
{
    const Library::AllocFunc* af = getDeallocFuncInfo(tok);
    return (af && af->arg == arg) ? af->groupId : 0;
}",1,1,lib/library.cpp,"Library.getDeallocId<const>:int(Token*,int)",<empty>,,false,1249,1253,getDeallocId,,,1,"int(Token*,int)"
111669152662,METHOD,lib/library.cpp:<global>,TYPE_DECL,"int Library::getReallocId(const Token *tok, int arg) const
{
    const Library::AllocFunc* af = getReallocFuncInfo(tok);
    return (af && af->arg == arg) ? af->groupId : 0;
}",1,1,lib/library.cpp,"Library.getReallocId<const>:int(Token*,int)",<empty>,,false,1256,1260,getReallocId,,,1,"int(Token*,int)"
111669152663,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const Library::ArgumentChecks * Library::getarg(const Token *ftok, int argnr) const
{
    const Function* func = nullptr;
    if (isNotLibraryFunction(ftok, &func))
        return nullptr;
    const auto it2 = utils::as_const(func->argumentChecks).find(argnr);
    if (it2 != func->argumentChecks.cend())
        return &it2->second;
    const auto it3 = utils::as_const(func->argumentChecks).find(-1);
    if (it3 != func->argumentChecks.cend())
        return &it3->second;
    return nullptr;
}",1,1,lib/library.cpp,"Library.getarg<const>:Library.ArgumentChecks*(Token*,int)",<empty>,,false,1263,1275,getarg,,,1,"Library.ArgumentChecks*(Token*,int)"
111669152664,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isScopeNoReturn(const Token *end, std::string *unknownFunc) const
{
    if (unknownFunc)
        unknownFunc->clear();

    if (Token::Match(end->tokAt(-2), ""!!{ ; }"")) {
        const Token *lastTop = end->tokAt(-2)->astTop();
        if (Token::simpleMatch(lastTop, ""<<"") &&
            Token::simpleMatch(lastTop->astOperand1(), ""("") &&
            Token::Match(lastTop->astOperand1()->previous(), ""%name% (""))
            return isnoreturn(lastTop->astOperand1()->previous());
    }

    if (!Token::simpleMatch(end->tokAt(-2), "") ; }""))
        return false;

    const Token *funcname = end->linkAt(-2)->previous();
    if (funcname->isCpp() && funcname->astTop()->str() == ""throw"")
        return true;
    const Token *start = funcname;
    if (Token::Match(funcname->tokAt(-3),""( * %name% )"")) {
        funcname = funcname->previous();
        start = funcname->tokAt(-3);
    } else if (funcname->isName()) {
        while (Token::Match(start, ""%name%|.|::""))
            ...",1,1,lib/library.cpp,"Library.isScopeNoReturn<const>:bool(Token*,std.string*)",<empty>,,false,1277,1318,isScopeNoReturn,,,1,"bool(Token*,std.string*)"
111669152665,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const std::unordered_map<std::string, Library::Container>& Library::containers() const
{
    return mData->mContainers;
}",1,1,lib/library.cpp,Library.containers<const>:ANY(),<empty>,,false,1321,1324,containers,,,1,ANY()
111669152666,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const Library::Container* Library::detectContainerInternal(const Token* const typeStart, DetectContainer detect, bool* isIterator, bool withoutStd) const
{
    if (!typeStart)
        return nullptr;
    const Token* firstLinkedTok = nullptr;
    for (const Token* tok = typeStart; tok && !tok->varId(); tok = tok->next()) {
        if (!tok->link())
            continue;

        firstLinkedTok = tok;
        break;
    }

    for (const std::pair<const std::string, Library::Container> & c : mData->mContainers) {
        const Container& container = c.second;
        if (container.startPattern.empty())
            continue;

        const int offset = (withoutStd && startsWith(container.startPattern2, ""std :: "")) ? 7 : 0;

        // If endPattern is undefined, it will always match, but itEndPattern has to be defined.
        if (detect != IteratorOnly && container.endPattern.empty()) {
            if (!Token::Match(typeStart, container.startPattern2.c_str() + offset))
              ...",1,1,lib/library.cpp,"Library.detectContainerInternal<const>:Library.Container*(Token*,Library.DetectContainer,bool*,bool)",<empty>,,false,1326,1375,detectContainerInternal,,,1,"Library.Container*(Token*,Library.DetectContainer,bool*,bool)"
111669152667,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const Library::Container* Library::detectContainer(const Token* typeStart) const
{
    return detectContainerInternal(typeStart, ContainerOnly);
}",1,1,lib/library.cpp,Library.detectContainer<const>:Library.Container*(Token*),<empty>,,false,1377,1380,detectContainer,,,1,Library.Container*(Token*)
111669152668,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const Library::Container* Library::detectIterator(const Token* typeStart) const
{
    return detectContainerInternal(typeStart, IteratorOnly);
}",1,1,lib/library.cpp,Library.detectIterator<const>:Library.Container*(Token*),<empty>,,false,1382,1385,detectIterator,,,1,Library.Container*(Token*)
111669152669,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const Library::Container* Library::detectContainerOrIterator(const Token* typeStart, bool* isIterator, bool withoutStd) const
{
    bool res;
    const Library::Container* c = detectContainerInternal(typeStart, Both, &res, withoutStd);
    if (c && isIterator)
        *isIterator = res;
    return c;
}",1,1,lib/library.cpp,"Library.detectContainerOrIterator<const>:Library.Container*(Token*,bool*,bool)",<empty>,,false,1387,1394,detectContainerOrIterator,,,1,"Library.Container*(Token*,bool*,bool)"
111669152670,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isContainerYield(const Token * const cond, Library::Container::Yield y, const std::string& fallback)
{
    if (!cond)
        return false;
    if (cond->str() == ""("") {
        const Token* tok = cond->astOperand1();
        if (tok && tok->str() == ""."") {
            if (tok->astOperand1() && tok->astOperand1()->valueType()) {
                if (const Library::Container *container = tok->astOperand1()->valueType()->container) {
                    return tok->astOperand2() && y == container->getYield(tok->astOperand2()->str());
                }
            } else if (!fallback.empty()) {
                return Token::simpleMatch(cond, ""( )"") && cond->strAt(-1) == fallback;
            }
        }
    }
    return false;
}",1,1,lib/library.cpp,"Library.isContainerYield:bool(Token*,Library.Container.Yield,std.string&)",<empty>,,false,1396,1413,isContainerYield,,,1,"bool(Token*,Library.Container.Yield,std.string&)"
111669152671,METHOD,lib/library.cpp:<global>,TYPE_DECL,"Library::Container::Yield Library::getContainerYield(const Token* const cond)
{
    if (Token::simpleMatch(cond, ""("")) {
        const Token* tok = cond->astOperand1();
        if (tok && tok->str() == ""."") {
            if (tok->astOperand1() && tok->astOperand1()->valueType()) {
                if (const Library::Container *container = tok->astOperand1()->valueType()->container) {
                    if (tok->astOperand2())
                        return container->getYield(tok->astOperand2()->str());
                }
            }
        }
    }
    return Library::Container::Yield::NO_YIELD;
}",1,1,lib/library.cpp,Library.getContainerYield:Library.Container.Yield(Token*),<empty>,,false,1415,1429,getContainerYield,,,1,Library.Container.Yield(Token*)
111669152672,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isNotLibraryFunction(const Token *ftok, const Function **func) const
{
    if (ftok->isKeyword() || ftok->isStandardType())
        return true;

    if (ftok->function() && ftok->function()->nestedIn && ftok->function()->nestedIn->type != ScopeType::eGlobal)
        return true;

    // variables are not library functions.
    if (ftok->varId())
        return true;

    return !matchArguments(ftok, getFunctionName(ftok), func);
}",1,1,lib/library.cpp,"Library.isNotLibraryFunction<const>:bool(Token*,Library.Function**)",<empty>,,false,1432,1445,isNotLibraryFunction,,,1,"bool(Token*,Library.Function**)"
111669152673,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::matchArguments(const Token *ftok, const std::string &functionName, const Function **func) const
{
    if (functionName.empty())
        return false;
    const auto it = utils::as_const(mData->mFunctions).find(functionName);
    if (it == mData->mFunctions.cend())
        return false;
    const int callargs = numberOfArgumentsWithoutAst(ftok);
    int args = 0;
    int firstOptionalArg = -1;
    for (const std::pair<const int, Library::ArgumentChecks> & argCheck : it->second.argumentChecks) {
        args = std::max(argCheck.first, args);
        if (argCheck.second.optional && (firstOptionalArg == -1 || firstOptionalArg > argCheck.first))
            firstOptionalArg = argCheck.first;

        if (argCheck.second.formatstr || argCheck.second.variadic) {
            const bool b = args <= callargs;
            if (b && func)
                *func = &it->second;
            return b;
        }
    }
    const bool b = (firstOptionalArg < 0) ? args == callargs : (callar...",1,1,lib/library.cpp,"Library.matchArguments<const>:bool(Token*,std.string&,Library.Function**)",<empty>,,false,1447,1473,matchArguments,,,1,"bool(Token*,std.string&,Library.Function**)"
111669152674,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const std::map<std::string, Library::WarnInfo>& Library::functionwarn() const
{
    return mData->mFunctionwarn;
}",1,1,lib/library.cpp,Library.functionwarn<const>:ANY(),<empty>,,false,1475,1478,functionwarn,,,1,ANY()
111669152675,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const Library::WarnInfo* Library::getWarnInfo(const Token* ftok) const
{
    if (isNotLibraryFunction(ftok))
        return nullptr;
    const auto i = utils::as_const(mData->mFunctionwarn).find(getFunctionName(ftok));
    if (i ==  mData->mFunctionwarn.cend())
        return nullptr;
    return &i->second;
}",1,1,lib/library.cpp,Library.getWarnInfo<const>:Library.WarnInfo*(Token*),<empty>,,false,1480,1488,getWarnInfo,,,1,Library.WarnInfo*(Token*)
111669152676,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isCompliantValidationExpression(const char* p)
{
    if (!p || !*p)
        return false;

    bool error = false;
    bool range = false;
    bool has_dot = false;
    bool has_E = false;

    error = *p == '.';
    for (; *p; p++) {
        if (std::isdigit(*p)) {
            error |= (*(p + 1) == '-');
        }
        else if (*p == ':') {
            // cppcheck-suppress bitwiseOnBoolean - TODO: fix this
            error |= range | (*(p + 1) == '.');
            range = true;
            has_dot = false;
            has_E = false;
        }
        else if ((*p == '-') || (*p == '+')) {
            error |= (!std::isdigit(*(p + 1)));
        }
        else if (*p == ',') {
            range = false;
            error |= *(p + 1) == '.';
            has_dot = false;
            has_E = false;
        } else if (*p == '.') {
            // cppcheck-suppress bitwiseOnBoolean - TODO: fix this
            error |= has_dot | (!std::isdigit(*(p + 1)));
            has_...",1,1,lib/library.cpp,Library.isCompliantValidationExpression:bool(char*),<empty>,,false,1490,1533,isCompliantValidationExpression,,,1,bool(char*)
111669152677,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::formatstr_function(const Token* ftok) const
{
    if (isNotLibraryFunction(ftok))
        return false;

    const auto it = utils::as_const(mData->mFunctions).find(getFunctionName(ftok));
    if (it != mData->mFunctions.cend())
        return it->second.formatstr;
    return false;
}",1,1,lib/library.cpp,Library.formatstr_function<const>:bool(Token*),<empty>,,false,1535,1544,formatstr_function,,,1,bool(Token*)
111669152678,METHOD,<empty>,<empty>,"[](const std::pair<const int, Library::ArgumentChecks>& a) {
        return a.second.formatstr;
    }",84,5,lib/library.cpp,"lib/library.cpp:<global>.Library.formatstr_argno<const>.<lambda>0:ANY(std.pair<constint,Library.ArgumentChecks>&)",<empty>,,false,1549,1551,<lambda>0,,,1,"ANY(std.pair<constint,Library.ArgumentChecks>&)"
111669152679,METHOD,lib/library.cpp:<global>,TYPE_DECL,"int Library::formatstr_argno(const Token* ftok) const
{
    const std::map<int, Library::ArgumentChecks>& argumentChecksFunc = mData->mFunctions.at(getFunctionName(ftok)).argumentChecks;
    auto it = std::find_if(argumentChecksFunc.cbegin(), argumentChecksFunc.cend(), [](const std::pair<const int, Library::ArgumentChecks>& a) {
        return a.second.formatstr;
    });
    return it == argumentChecksFunc.cend() ? -1 : it->first - 1;
}",1,1,lib/library.cpp,Library.formatstr_argno<const>:int(Token*),<empty>,,false,1546,1553,formatstr_argno,,,1,int(Token*)
111669152680,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::formatstr_scan(const Token* ftok) const
{
    return mData->mFunctions.at(getFunctionName(ftok)).formatstr_scan;
}",1,1,lib/library.cpp,Library.formatstr_scan<const>:bool(Token*),<empty>,,false,1555,1558,formatstr_scan,,,1,bool(Token*)
111669152681,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::formatstr_secure(const Token* ftok) const
{
    return mData->mFunctions.at(getFunctionName(ftok)).formatstr_secure;
}",1,1,lib/library.cpp,Library.formatstr_secure<const>:bool(Token*),<empty>,,false,1560,1563,formatstr_secure,,,1,bool(Token*)
111669152682,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const Library::NonOverlappingData* Library::getNonOverlappingData(const Token *ftok) const
{
    if (isNotLibraryFunction(ftok))
        return nullptr;
    const auto it = utils::as_const(mData->mNonOverlappingData).find(getFunctionName(ftok));
    return (it != mData->mNonOverlappingData.cend()) ? &it->second : nullptr;
}",1,1,lib/library.cpp,Library.getNonOverlappingData<const>:Library.NonOverlappingData*(Token*),<empty>,,false,1565,1571,getNonOverlappingData,,,1,Library.NonOverlappingData*(Token*)
111669152683,METHOD,lib/library.cpp:<global>,TYPE_DECL,"Library::UseRetValType Library::getUseRetValType(const Token *ftok) const
{
    if (isNotLibraryFunction(ftok)) {
        if (Token::simpleMatch(ftok->astParent(), ""."")) {
            const Token* contTok = ftok->astParent()->astOperand1();
            using Yield = Library::Container::Yield;
            const Yield yield = astContainerYield(contTok);
            if (yield == Yield::START_ITERATOR || yield == Yield::END_ITERATOR || yield == Yield::AT_INDEX ||
                yield == Yield::SIZE || yield == Yield::EMPTY || yield == Yield::BUFFER || yield == Yield::BUFFER_NT ||
                ((yield == Yield::ITEM || yield == Yield::ITERATOR) && astContainerAction(contTok) == Library::Container::Action::NO_ACTION))
                return Library::UseRetValType::DEFAULT;
        }
        return Library::UseRetValType::NONE;
    }
    const auto it = utils::as_const(mData->mFunctions).find(getFunctionName(ftok));
    if (it != mData->mFunctions.cend())
        return it->second.user...",1,1,lib/library.cpp,Library.getUseRetValType<const>:Library.UseRetValType(Token*),<empty>,,false,1573,1591,getUseRetValType,,,1,Library.UseRetValType(Token*)
111669152684,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const std::string& Library::returnValue(const Token *ftok) const
{
    if (isNotLibraryFunction(ftok))
        return mEmptyString;
    const auto it = utils::as_const(mData->mReturnValue).find(getFunctionName(ftok));
    return it != mData->mReturnValue.cend() ? it->second : mEmptyString;
}",1,1,lib/library.cpp,Library.returnValue<const>:ANY(Token*),<empty>,,false,1593,1599,returnValue,,,1,ANY(Token*)
111669152685,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const std::string& Library::returnValueType(const Token *ftok) const
{
    while (Token::simpleMatch(ftok, ""::""))
        ftok = ftok->astOperand2() ? ftok->astOperand2() : ftok->astOperand1();
    if (!ftok)
        return mEmptyString;
    if (isNotLibraryFunction(ftok)) {
        if (Token::simpleMatch(ftok->astParent(), ""."") && ftok->astParent()->astOperand1()) {
            const Token* contTok = ftok->astParent()->astOperand1();
            if (contTok->valueType() && contTok->valueType()->container)
                return contTok->valueType()->container->getReturnType(ftok->str());
        }
        return mEmptyString;
    }
    const auto it = utils::as_const(mData->mReturnValueType).find(getFunctionName(ftok));
    return it != mData->mReturnValueType.cend() ? it->second : mEmptyString;
}",1,1,lib/library.cpp,Library.returnValueType<const>:ANY(Token*),<empty>,,false,1601,1617,returnValueType,,,1,ANY(Token*)
111669152686,METHOD,lib/library.cpp:<global>,TYPE_DECL,"int Library::returnValueContainer(const Token *ftok) const
{
    if (isNotLibraryFunction(ftok))
        return -1;
    const auto it = utils::as_const(mData->mReturnValueContainer).find(getFunctionName(ftok));
    return it != mData->mReturnValueContainer.cend() ? it->second : -1;
}",1,1,lib/library.cpp,Library.returnValueContainer<const>:int(Token*),<empty>,,false,1619,1625,returnValueContainer,,,1,int(Token*)
111669152687,METHOD,lib/library.cpp:<global>,TYPE_DECL,"std::vector<MathLib::bigint> Library::unknownReturnValues(const Token *ftok) const
{
    if (isNotLibraryFunction(ftok))
        return std::vector<MathLib::bigint>();
    const auto it = utils::as_const(mData->mUnknownReturnValues).find(getFunctionName(ftok));
    return (it == mData->mUnknownReturnValues.cend()) ? std::vector<MathLib::bigint>() : it->second;
}",1,1,lib/library.cpp,Library.unknownReturnValues<const>:vector<MathLib.bigint>(Token*),<empty>,,false,1627,1633,unknownReturnValues,,,1,vector<MathLib::bigint>(Token*)
111669152688,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const Library::Function *Library::getFunction(const Token *ftok) const
{
    if (isNotLibraryFunction(ftok))
        return nullptr;
    const auto it1 = utils::as_const(mData->mFunctions).find(getFunctionName(ftok));
    if (it1 == mData->mFunctions.cend())
        return nullptr;
    return &it1->second;
}",1,1,lib/library.cpp,Library.getFunction<const>:Library.Function*(Token*),<empty>,,false,1635,1643,getFunction,,,1,Library.Function*(Token*)
111669152689,METHOD,<empty>,<empty>,"[](const std::pair<const int, Library::ArgumentChecks>& a) {
        return !a.second.minsizes.empty();
    }",94,5,lib/library.cpp,"lib/library.cpp:<global>.Library.hasminsize<const>.<lambda>1:bool(std.pair<constint,Library.ArgumentChecks>&)",<empty>,,false,1653,1655,<lambda>1,,,1,"bool(std.pair<constint,Library.ArgumentChecks>&)"
111669152690,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::hasminsize(const Token *ftok) const
{
    if (isNotLibraryFunction(ftok))
        return false;
    const auto it = utils::as_const(mData->mFunctions).find(getFunctionName(ftok));
    if (it == mData->mFunctions.cend())
        return false;
    return std::any_of(it->second.argumentChecks.cbegin(), it->second.argumentChecks.cend(), [](const std::pair<const int, Library::ArgumentChecks>& a) {
        return !a.second.minsizes.empty();
    });
}",1,1,lib/library.cpp,Library.hasminsize<const>:bool(Token*),<empty>,,false,1646,1656,hasminsize,,,1,bool(Token*)
111669152691,METHOD,lib/library.cpp:<global>,TYPE_DECL,"Library::ArgumentChecks::Direction Library::getArgDirection(const Token* ftok, int argnr, int indirect) const
{
    const ArgumentChecks* arg = getarg(ftok, argnr);
    if (arg) {
        if (indirect < 0 || indirect >= arg->direction.size())
            return ArgumentChecks::Direction::DIR_UNKNOWN; // TODO: don't generate bad indirect values
        return arg->direction[indirect];
    }
    if (formatstr_function(ftok)) {
        const int fs_argno = formatstr_argno(ftok);
        if (fs_argno >= 0 && argnr >= fs_argno) {
            if (formatstr_scan(ftok))
                return ArgumentChecks::Direction::DIR_OUT;
            return ArgumentChecks::Direction::DIR_IN;
        }
    }
    return ArgumentChecks::Direction::DIR_UNKNOWN;
}",1,1,lib/library.cpp,"Library.getArgDirection<const>:Library.ArgumentChecks.Direction(Token*,int,int)",<empty>,,false,1658,1675,getArgDirection,,,1,"Library.ArgumentChecks.Direction(Token*,int,int)"
111669152692,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::ignorefunction(const std::string& functionName) const
{
    const auto it = utils::as_const(mData->mFunctions).find(functionName);
    if (it != mData->mFunctions.cend())
        return it->second.ignore;
    return false;
}",1,1,lib/library.cpp,Library.ignorefunction<const>:bool(std.string&),<empty>,,false,1677,1683,ignorefunction,,,1,bool(std.string&)
111669152693,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const std::unordered_map<std::string, Library::Function>& Library::functions() const
{
    return mData->mFunctions;
}",1,1,lib/library.cpp,Library.functions<const>:ANY(),<empty>,,false,1684,1687,functions,,,1,ANY()
111669152694,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isUse(const std::string& functionName) const
{
    const auto it = utils::as_const(mData->mFunctions).find(functionName);
    if (it != mData->mFunctions.cend())
        return it->second.use;
    return false;
}",1,1,lib/library.cpp,Library.isUse<const>:bool(std.string&),<empty>,,false,1688,1694,isUse,,,1,bool(std.string&)
111669152695,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isLeakIgnore(const std::string& functionName) const
{
    const auto it = utils::as_const(mData->mFunctions).find(functionName);
    if (it != mData->mFunctions.cend())
        return it->second.leakignore;
    return false;
}",1,1,lib/library.cpp,Library.isLeakIgnore<const>:bool(std.string&),<empty>,,false,1695,1701,isLeakIgnore,,,1,bool(std.string&)
111669152696,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isFunctionConst(const std::string& functionName, bool pure) const
{
    const auto it = utils::as_const(mData->mFunctions).find(functionName);
    if (it != mData->mFunctions.cend())
        return pure ? it->second.ispure : it->second.isconst;
    return false;
}",1,1,lib/library.cpp,"Library.isFunctionConst<const>:bool(std.string&,bool)",<empty>,,false,1702,1708,isFunctionConst,,,1,"bool(std.string&,bool)"
111669152697,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isFunctionConst(const Token *ftok) const
{
    if (ftok->function() && ftok->function()->isConst())
        return true;
    if (isNotLibraryFunction(ftok)) {
        if (Token::simpleMatch(ftok->astParent(), ""."")) {
            using Yield = Library::Container::Yield;
            const Yield yield = astContainerYield(ftok->astParent()->astOperand1());
            if (yield == Yield::EMPTY || yield == Yield::SIZE || yield == Yield::BUFFER_NT)
                return true;
        }
        return false;
    }
    const auto it = utils::as_const(mData->mFunctions).find(getFunctionName(ftok));
    return (it != mData->mFunctions.cend() && it->second.isconst);
}",1,1,lib/library.cpp,Library.isFunctionConst<const>:bool(Token*),<empty>,,false,1709,1724,isFunctionConst,,,1,bool(Token*)
111669152698,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isnoreturn(const Token *ftok) const
{
    if (ftok->function() && ftok->function()->isAttributeNoreturn())
        return true;
    if (ftok->variable() && ftok->variable()->nameToken()->isAttributeNoreturn())
        return true;
    if (isNotLibraryFunction(ftok)) {
        if (Token::simpleMatch(ftok->astParent(), ""."")) {
            const Token* contTok = ftok->astParent()->astOperand1();
            if (astContainerAction(contTok) != Library::Container::Action::NO_ACTION ||
                astContainerYield(contTok) != Library::Container::Yield::NO_YIELD)
                return false;
        }
        return false;
    }
    const auto it = utils::as_const(mData->mNoReturn).find(getFunctionName(ftok));
    if (it == mData->mNoReturn.end())
        return false;
    if (it->second == LibraryData::FalseTrueMaybe::Maybe)
        return true;
    return it->second == LibraryData::FalseTrueMaybe::True;
}",1,1,lib/library.cpp,Library.isnoreturn<const>:bool(Token*),<empty>,,false,1726,1747,isnoreturn,,,1,bool(Token*)
111669152699,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isnotnoreturn(const Token *ftok) const
{
    if (ftok->function() && ftok->function()->isAttributeNoreturn())
        return false;
    if (isNotLibraryFunction(ftok))
        return hasAnyTypeCheck(getFunctionName(ftok));
    const auto it = utils::as_const(mData->mNoReturn).find(getFunctionName(ftok));
    if (it == mData->mNoReturn.end())
        return false;
    if (it->second == LibraryData::FalseTrueMaybe::Maybe)
        return false;
    return it->second == LibraryData::FalseTrueMaybe::False;
}",1,1,lib/library.cpp,Library.isnotnoreturn<const>:bool(Token*),<empty>,,false,1749,1761,isnotnoreturn,,,1,bool(Token*)
111669152700,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::markupFile(const std::string &path) const
{
    return mData->mMarkupExtensions.find(Path::getFilenameExtensionInLowerCase(path)) != mData->mMarkupExtensions.end();
}",1,1,lib/library.cpp,Library.markupFile<const>:bool(std.string&),<empty>,,false,1763,1766,markupFile,,,1,bool(std.string&)
111669152701,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::processMarkupAfterCode(const std::string &path) const
{
    const auto it = utils::as_const(mData->mProcessAfterCode).find(Path::getFilenameExtensionInLowerCase(path));
    return (it == mData->mProcessAfterCode.cend() || it->second);
}",1,1,lib/library.cpp,Library.processMarkupAfterCode<const>:bool(std.string&),<empty>,,false,1768,1772,processMarkupAfterCode,,,1,bool(std.string&)
111669152702,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::reportErrors(const std::string &path) const
{
    const auto it = utils::as_const(mData->mReportErrors).find(Path::getFilenameExtensionInLowerCase(path));
    return (it == mData->mReportErrors.cend() || it->second);
}",1,1,lib/library.cpp,Library.reportErrors<const>:bool(std.string&),<empty>,,false,1774,1778,reportErrors,,,1,bool(std.string&)
111669152703,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isexecutableblock(const std::string &file, const std::string &token) const
{
    const auto it = utils::as_const(mData->mExecutableBlocks).find(Path::getFilenameExtensionInLowerCase(file));
    return (it != mData->mExecutableBlocks.cend() && it->second.isBlock(token));
}",1,1,lib/library.cpp,"Library.isexecutableblock<const>:bool(std.string&,std.string&)",<empty>,,false,1780,1784,isexecutableblock,,,1,"bool(std.string&,std.string&)"
111669152704,METHOD,lib/library.cpp:<global>,TYPE_DECL,"int Library::blockstartoffset(const std::string &file) const
{
    int offset = -1;
    const auto map_it
        = utils::as_const(mData->mExecutableBlocks).find(Path::getFilenameExtensionInLowerCase(file));

    if (map_it != mData->mExecutableBlocks.end()) {
        offset = map_it->second.offset();
    }
    return offset;
}",1,1,lib/library.cpp,Library.blockstartoffset<const>:int(std.string&),<empty>,,false,1786,1796,blockstartoffset,,,1,int(std.string&)
111669152705,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const std::string& Library::blockstart(const std::string &file) const
{
    const auto map_it
        = utils::as_const(mData->mExecutableBlocks).find(Path::getFilenameExtensionInLowerCase(file));

    if (map_it != mData->mExecutableBlocks.end()) {
        return map_it->second.start();
    }
    return mEmptyString;
}",1,1,lib/library.cpp,Library.blockstart<const>:ANY(std.string&),<empty>,,false,1798,1807,blockstart,,,1,ANY(std.string&)
111669152706,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const std::string& Library::blockend(const std::string &file) const
{
    const auto map_it
        = utils::as_const(mData->mExecutableBlocks).find(Path::getFilenameExtensionInLowerCase(file));

    if (map_it != mData->mExecutableBlocks.end()) {
        return map_it->second.end();
    }
    return mEmptyString;
}",1,1,lib/library.cpp,Library.blockend<const>:ANY(std.string&),<empty>,,false,1809,1818,blockend,,,1,ANY(std.string&)
111669152707,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::iskeyword(const std::string &file, const std::string &keyword) const
{
    const auto it =
        utils::as_const(mData->mKeywords).find(Path::getFilenameExtensionInLowerCase(file));
    return (it != mData->mKeywords.end() && it->second.count(keyword));
}",1,1,lib/library.cpp,"Library.iskeyword<const>:bool(std.string&,std.string&)",<empty>,,false,1820,1825,iskeyword,,,1,"bool(std.string&,std.string&)"
111669152708,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isimporter(const std::string& file, const std::string &importer) const
{
    const auto it =
        utils::as_const(mData->mImporters).find(Path::getFilenameExtensionInLowerCase(file));
    return (it != mData->mImporters.end() && it->second.count(importer) > 0);
}",1,1,lib/library.cpp,"Library.isimporter<const>:bool(std.string&,std.string&)",<empty>,,false,1827,1832,isimporter,,,1,"bool(std.string&,std.string&)"
111669152709,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const Token* Library::getContainerFromYield(const Token* tok, Library::Container::Yield yield) const
{
    if (!tok)
        return nullptr;
    if (Token::Match(tok->tokAt(-2), "". %name% ("")) {
        const Token* containerTok = tok->tokAt(-2)->astOperand1();
        if (!astIsContainer(containerTok))
            return nullptr;
        if (containerTok->valueType()->container &&
            containerTok->valueType()->container->getYield(tok->strAt(-1)) == yield)
            return containerTok;
        if (yield == Library::Container::Yield::EMPTY && Token::simpleMatch(tok->tokAt(-1), ""empty ( )""))
            return containerTok;
        if (yield == Library::Container::Yield::SIZE && Token::Match(tok->tokAt(-1), ""size|length ( )""))
            return containerTok;
    } else if (Token::Match(tok->previous(), ""%name% ("")) {
        if (const Library::Function* f = this->getFunction(tok->previous())) {
            if (f->containerYield == yield) {
                return tok->astO...",1,1,lib/library.cpp,"Library.getContainerFromYield<const>:Token*(Token*,Library.Container.Yield)",<empty>,,false,1834,1857,getContainerFromYield,,,1,"Token*(Token*,Library.Container.Yield)"
111669152710,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const Token* Library::getContainerFromAction(const Token* tok, Library::Container::Action action) const
{
    if (!tok)
        return nullptr;
    if (Token::Match(tok->tokAt(-2), "". %name% ("")) {
        const Token* containerTok = tok->tokAt(-2)->astOperand1();
        if (!astIsContainer(containerTok))
            return nullptr;
        if (containerTok->valueType()->container &&
            containerTok->valueType()->container->getAction(tok->strAt(-1)) == action)
            return containerTok;
        if (Token::simpleMatch(tok->tokAt(-1), ""empty ( )""))
            return containerTok;
    } else if (Token::Match(tok->previous(), ""%name% ("")) {
        if (const Library::Function* f = this->getFunction(tok->previous())) {
            if (f->containerAction == action) {
                return tok->astOperand2();
            }
        }
    }
    return nullptr;
}",1,1,lib/library.cpp,"Library.getContainerFromAction<const>:Token*(Token*,Library.Container.Action)",<empty>,,false,1860,1881,getContainerFromAction,,,1,"Token*(Token*,Library.Container.Action)"
111669152711,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const std::unordered_map<std::string, Library::SmartPointer>& Library::smartPointers() const
{
    return mData->mSmartPointers;
}",1,1,lib/library.cpp,Library.smartPointers<const>:ANY(),<empty>,,false,1883,1886,smartPointers,,,1,ANY()
111669152712,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isSmartPointer(const Token* tok) const
{
    return detectSmartPointer(tok);
}",1,1,lib/library.cpp,Library.isSmartPointer<const>:bool(Token*),<empty>,,false,1888,1891,isSmartPointer,,,1,bool(Token*)
111669152713,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const Library::SmartPointer* Library::detectSmartPointer(const Token* tok, bool withoutStd) const
{
    if (!tok)
        return nullptr;
    std::string typestr = withoutStd ? ""std::"" : """";
    if (tok->str() == ""::"")
        tok = tok->next();
    while (Token::Match(tok, ""%name% ::"")) {
        typestr += tok->str();
        typestr += ""::"";
        tok = tok->tokAt(2);
    }
    if (tok && tok->isName()) {
        typestr += tok->str();
    }
    auto it = mData->mSmartPointers.find(typestr);
    if (it == mData->mSmartPointers.end())
        return nullptr;
    return &it->second;
}",1,1,lib/library.cpp,"Library.detectSmartPointer<const>:Library.SmartPointer*(Token*,bool)",<empty>,,false,1893,1912,detectSmartPointer,,,1,"Library.SmartPointer*(Token*,bool)"
111669152714,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const Library::Container * getLibraryContainer(const Token * tok)
{
    if (!tok)
        return nullptr;
    // TODO: Support dereferencing iterators
    // TODO: Support dereferencing with ->
    if (tok->isUnaryOp(""*"") && astIsPointer(tok->astOperand1())) {
        for (const ValueFlow::Value& v:tok->astOperand1()->values()) {
            if (!v.isLocalLifetimeValue())
                continue;
            if (v.lifetimeKind != ValueFlow::Value::LifetimeKind::Address)
                continue;
            return getLibraryContainer(v.tokvalue);
        }
    }
    if (!tok->valueType())
        return nullptr;
    return tok->valueType()->container;
}",1,1,lib/library.cpp,getLibraryContainer:Library.Container*(Token*),<empty>,,false,1914,1932,getLibraryContainer,,,1,Library.Container*(Token*)
111669152715,METHOD,lib/library.cpp:<global>,TYPE_DECL,"Library::TypeCheck Library::getTypeCheck(std::string check,  std::string typeName) const
{
    auto it = mData->mTypeChecks.find(std::pair<std::string, std::string>(std::move(check), std::move(typeName)));
    return it == mData->mTypeChecks.end() ? TypeCheck::def : it->second;
}",1,1,lib/library.cpp,"Library.getTypeCheck<const>:Library.TypeCheck(std.string,std.string)",<empty>,,false,1934,1938,getTypeCheck,,,1,"Library.TypeCheck(std.string,std.string)"
111669152716,METHOD,<empty>,<empty>,"[&](const std::pair<std::pair<std::string, std::string>, Library::TypeCheck>& tc) {
        return tc.first.second == typeName;
    }",78,5,lib/library.cpp,"lib/library.cpp:<global>.Library.hasAnyTypeCheck<const>.<lambda>2:bool(std.pair<std.pair<std.string,std.string>,Library.TypeCheck>&)",<empty>,,false,1942,1944,<lambda>2,,,1,"bool(std.pair<std.pair<std.string,std.string>,Library.TypeCheck>&)"
111669152717,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::hasAnyTypeCheck(const std::string& typeName) const
{
    return std::any_of(mData->mTypeChecks.begin(), mData->mTypeChecks.end(), [&](const std::pair<std::pair<std::string, std::string>, Library::TypeCheck>& tc) {
        return tc.first.second == typeName;
    });
}",1,1,lib/library.cpp,Library.hasAnyTypeCheck<const>:bool(std.string&),<empty>,,false,1940,1945,hasAnyTypeCheck,,,1,bool(std.string&)
111669152718,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const Library::AllocFunc* Library::getAllocFuncInfo(const char name[]) const
{
    return getAllocDealloc(mData->mAlloc, name);
}",1,1,lib/library.cpp,Library.getAllocFuncInfo<const>:Library.AllocFunc*(char[]),<empty>,,false,1947,1950,getAllocFuncInfo,,,1,Library.AllocFunc*(char[])
111669152719,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const Library::AllocFunc* Library::getDeallocFuncInfo(const char name[]) const
{
    return getAllocDealloc(mData->mDealloc, name);
}",1,1,lib/library.cpp,Library.getDeallocFuncInfo<const>:Library.AllocFunc*(char[]),<empty>,,false,1952,1955,getDeallocFuncInfo,,,1,Library.AllocFunc*(char[])
111669152720,METHOD,lib/library.cpp:<global>,TYPE_DECL,"int Library::allocId(const char name[]) const
{
    const AllocFunc* af = getAllocDealloc(mData->mAlloc, name);
    return af ? af->groupId : 0;
}",1,1,lib/library.cpp,Library.allocId<const>:int(char[]),<empty>,,false,1958,1962,allocId,,,1,int(char[])
111669152721,METHOD,lib/library.cpp:<global>,TYPE_DECL,"int Library::deallocId(const char name[]) const
{
    const AllocFunc* af = getAllocDealloc(mData->mDealloc, name);
    return af ? af->groupId : 0;
}",1,1,lib/library.cpp,Library.deallocId<const>:int(char[]),<empty>,,false,1964,1968,deallocId,,,1,int(char[])
111669152722,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const std::set<std::string> &Library::markupExtensions() const
{
    return mData->mMarkupExtensions;
}",1,1,lib/library.cpp,Library.markupExtensions<const>:ANY(),<empty>,,false,1970,1973,markupExtensions,,,1,ANY()
111669152723,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isexporter(const std::string &prefix) const
{
    return mData->mExporters.find(prefix) != mData->mExporters.end();
}",1,1,lib/library.cpp,Library.isexporter<const>:bool(std.string&),<empty>,,false,1975,1978,isexporter,,,1,bool(std.string&)
111669152724,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isexportedprefix(const std::string &prefix, const std::string &token) const
{
    const auto it = utils::as_const(mData->mExporters).find(prefix);
    return (it != mData->mExporters.end() && it->second.isPrefix(token));
}",1,1,lib/library.cpp,"Library.isexportedprefix<const>:bool(std.string&,std.string&)",<empty>,,false,1980,1984,isexportedprefix,,,1,"bool(std.string&,std.string&)"
111669152725,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isexportedsuffix(const std::string &prefix, const std::string &token) const
{
    const auto it = utils::as_const(mData->mExporters).find(prefix);
    return (it != mData->mExporters.end() && it->second.isSuffix(token));
}",1,1,lib/library.cpp,"Library.isexportedsuffix<const>:bool(std.string&,std.string&)",<empty>,,false,1986,1990,isexportedsuffix,,,1,"bool(std.string&,std.string&)"
111669152726,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isreflection(const std::string &token) const
{
    return mData->mReflection.find(token) != mData->mReflection.end();
}",1,1,lib/library.cpp,Library.isreflection<const>:bool(std.string&),<empty>,,false,1992,1995,isreflection,,,1,bool(std.string&)
111669152727,METHOD,lib/library.cpp:<global>,TYPE_DECL,"int Library::reflectionArgument(const std::string &token) const
{
    const auto it = utils::as_const(mData->mReflection).find(token);
    if (it != mData->mReflection.end())
        return it->second;
    return -1;
}",1,1,lib/library.cpp,Library.reflectionArgument<const>:int(std.string&),<empty>,,false,1997,2003,reflectionArgument,,,1,int(std.string&)
111669152728,METHOD,lib/library.cpp:<global>,TYPE_DECL,"bool Library::isentrypoint(const std::string &func) const
{
    return func == ""main"" || mData->mEntrypoints.find(func) != mData->mEntrypoints.end();
}",1,1,lib/library.cpp,Library.isentrypoint<const>:bool(std.string&),<empty>,,false,2005,2008,isentrypoint,,,1,bool(std.string&)
111669152729,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const std::set<std::string>& Library::defines() const
{
    return mData->mDefines;
}",1,1,lib/library.cpp,Library.defines<const>:ANY(),<empty>,,false,2010,2013,defines,,,1,ANY()
111669152730,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const Library::PodType *Library::podtype(const std::string &name) const
{
    const auto it = utils::as_const(mData->mPodTypes).find(name);
    return (it != mData->mPodTypes.end()) ? &(it->second) : nullptr;
}",1,1,lib/library.cpp,Library.podtype<const>:Library.PodType*(std.string&),<empty>,,false,2015,2019,podtype,,,1,Library.PodType*(std.string&)
111669152731,METHOD,lib/library.cpp:<global>,TYPE_DECL,"const Library::PlatformType *Library::platform_type(const std::string &name, const std::string & platform) const
{
    const auto it = utils::as_const(mData->mPlatforms).find(platform);
    if (it != mData->mPlatforms.end()) {
        const PlatformType * const type = it->second.platform_type(name);
        if (type)
            return type;
    }

    const auto it2 = utils::as_const(mData->mPlatformTypes).find(name);
    return (it2 != mData->mPlatformTypes.end()) ? &(it2->second) : nullptr;
}",1,1,lib/library.cpp,"Library.platform_type<const>:Library.PlatformType*(std.string&,std.string&)",<empty>,,false,2021,2032,platform_type,,,1,"Library.PlatformType*(std.string&,std.string&)"
111669152732,METHOD,lib/library.h:<global>,TYPE_DECL,<global>,1,1,lib/library.h,lib/library.h:<global>,<empty>,,false,1,492,<global>,,,1,
111669152733,METHOD,lib/matchcompiler.h:<global>,TYPE_DECL,<global>,1,25,lib/matchcompiler.h,lib/matchcompiler.h:<global>,<empty>,,false,1,73,<global>,,,1,
111669152734,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"MathLib::value::value(const std::string &s)
{
    if (MathLib::isFloat(s)) {
        mType = MathLib::value::Type::FLOAT;
        mDoubleValue = MathLib::toDoubleNumber(s);
        return;
    }

    if (!MathLib::isInt(s))
        throw InternalError(nullptr, ""Invalid value: "" + s);

    mType = MathLib::value::Type::INT;
    mIntValue = MathLib::toBigNumber(s);

    if (isIntHex(s) && mIntValue < 0)
        mIsUnsigned = true;

    // read suffix
    if (s.size() >= 2U) {
        for (std::size_t i = s.size() - 1U; i > 0U; --i) {
            const char c = s[i];
            if (c == 'u' || c == 'U')
                mIsUnsigned = true;
            else if (c == 'l' || c == 'L') {
                if (mType == MathLib::value::Type::INT)
                    mType = MathLib::value::Type::LONG;
                else if (mType == MathLib::value::Type::LONG)
                    mType = MathLib::value::Type::LONGLONG;
            } else if (i > 2U && c == '4' && s[i-1] == '6' && s[i-2] == '...",1,1,lib/mathlib.cpp,MathLib.value.value:ANY(std.string&),<empty>,,false,41,73,value,,,1,ANY(std.string&)
111669152735,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,<global>,1,1,lib/mathlib.cpp,lib/mathlib.cpp:<global>,<empty>,,false,1,1363,<global>,,,1,
111669152736,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"std::string MathLib::value::str() const
{
    std::ostringstream ostr;
    if (mType == MathLib::value::Type::FLOAT) {
        if (std::isnan(mDoubleValue))
            return ""nan.0"";
        if (std::isinf(mDoubleValue))
            return (mDoubleValue > 0) ? ""inf.0"" : ""-inf.0"";

        ostr.precision(9);
        ostr << std::fixed << mDoubleValue;

        // remove trailing zeros
        std::string ret(ostr.str());
        std::string::size_type pos = ret.size() - 1U;
        while (ret[pos] == '0')
            pos--;
        if (ret[pos] == '.')
            ++pos;

        return ret.substr(0, pos+1);
    }

    if (mIsUnsigned)
        ostr << static_cast<biguint>(mIntValue) << ""U"";
    else
        ostr << mIntValue;
    if (mType == MathLib::value::Type::LONG)
        ostr << ""L"";
    else if (mType == MathLib::value::Type::LONGLONG)
        ostr << ""LL"";
    return ostr.str();
}",1,1,lib/mathlib.cpp,MathLib.value.str<const>:string(),<empty>,,false,75,107,str,,,1,string()
111669152737,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"void MathLib::value::promote(const MathLib::value &v)
{
    if (isInt() && v.isInt()) {
        if (mType < v.mType) {
            mType = v.mType;
            mIsUnsigned = v.mIsUnsigned;
        } else if (mType == v.mType) {
            mIsUnsigned |= v.mIsUnsigned;
        }
    } else if (!isFloat()) {
        mIsUnsigned = false;
        mDoubleValue = static_cast<double>(mIntValue);
        mType = MathLib::value::Type::FLOAT;
    }
}",1,1,lib/mathlib.cpp,MathLib.value.promote:void(MathLib.value&),<empty>,,false,109,123,promote,,,1,void(MathLib.value&)
111669152738,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"MathLib::value MathLib::value::calc(char op, const MathLib::value &v1, const MathLib::value &v2)
{
    value temp(v1);
    temp.promote(v2);
    if (temp.isFloat()) {
        switch (op) {
        case '+':
            temp.mDoubleValue += v2.getDoubleValue();
            break;
        case '-':
            temp.mDoubleValue -= v2.getDoubleValue();
            break;
        case '*':
            temp.mDoubleValue *= v2.getDoubleValue();
            break;
        case '/':
            temp.mDoubleValue /= v2.getDoubleValue();
            break;
        case '%':
        case '&':
        case '|':
        case '^':
            throw InternalError(nullptr, ""Invalid calculation"");
        default:
            throw InternalError(nullptr, ""Unhandled calculation"");
        }
    } else if (temp.mIsUnsigned) {
        switch (op) {
        case '+':
            temp.mIntValue += (unsigned long long)v2.mIntValue;
            break;
        case '-':
            temp.mIntValue -= (unsign...",1,1,lib/mathlib.cpp,"MathLib.value.calc:MathLib.value(char,MathLib.value&,MathLib.value&)",<empty>,,false,126,224,calc,,,1,"MathLib.value(char,MathLib.value&,MathLib.value&)"
111669152739,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"int MathLib::value::compare(const MathLib::value &v) const
{
    value temp(*this);
    temp.promote(v);

    if (temp.isFloat()) {
        if (temp.mDoubleValue < v.getDoubleValue())
            return -1;
        if (temp.mDoubleValue > v.getDoubleValue())
            return 1;
        return 0;
    }

    if (temp.mIsUnsigned) {
        if ((unsigned long long)mIntValue < (unsigned long long)v.mIntValue)
            return -1;
        if ((unsigned long long)mIntValue > (unsigned long long)v.mIntValue)
            return 1;
        return 0;
    }

    if (mIntValue < v.mIntValue)
        return -1;
    if (mIntValue > v.mIntValue)
        return 1;
    return 0;
}",1,1,lib/mathlib.cpp,MathLib.value.compare<const>:int(MathLib.value&),<empty>,,false,227,253,compare,,,1,int(MathLib.value&)
111669152740,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"MathLib::value MathLib::value::add(int v) const
{
    MathLib::value temp(*this);
    if (temp.isInt())
        temp.mIntValue += v;
    else
        temp.mDoubleValue += v;
    return temp;
}",1,1,lib/mathlib.cpp,MathLib.value.add<const>:MathLib.value(int),<empty>,,false,255,263,add,,,1,MathLib.value(int)
111669152741,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"MathLib::value MathLib::value::shiftLeft(const MathLib::value &v) const
{
    if (!isInt() || !v.isInt())
        throw InternalError(nullptr, ""Shift operand is not integer"");
    MathLib::value ret(*this);
    if (v.mIntValue >= MathLib::bigint_bits) {
        return ret;
    }
    ret.mIntValue <<= v.mIntValue;
    return ret;
}",1,1,lib/mathlib.cpp,MathLib.value.shiftLeft<const>:MathLib.value(MathLib.value&),<empty>,,false,265,275,shiftLeft,,,1,MathLib.value(MathLib.value&)
111669152742,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"MathLib::value MathLib::value::shiftRight(const MathLib::value &v) const
{
    if (!isInt() || !v.isInt())
        throw InternalError(nullptr, ""Shift operand is not integer"");
    MathLib::value ret(*this);
    if (v.mIntValue >= MathLib::bigint_bits) {
        return ret;
    }
    ret.mIntValue >>= v.mIntValue;
    return ret;
}",1,1,lib/mathlib.cpp,MathLib.value.shiftRight<const>:MathLib.value(MathLib.value&),<empty>,,false,277,287,shiftRight,,,1,MathLib.value(MathLib.value&)
111669152743,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"MathLib::biguint MathLib::toBigUNumber(const Token * tok)
{
    return toBigUNumber(tok->str(), tok);
}",1,1,lib/mathlib.cpp,MathLib.toBigUNumber:unsigned longlongint(Token*),<empty>,,false,289,292,toBigUNumber,,,1,unsigned longlongint(Token*)
111669152744,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"MathLib::biguint MathLib::toBigUNumber(const std::string & str, const Token * const tok)
{
    // hexadecimal numbers:
    if (isIntHex(str)) {
        try {
            const biguint ret = std::stoull(str, nullptr, 16);
            return ret;
        } catch (const std::out_of_range& /*e*/) {
            throw InternalError(tok, ""Internal Error. MathLib::toBigUNumber: out_of_range: "" + str);
        } catch (const std::invalid_argument& /*e*/) {
            throw InternalError(tok, ""Internal Error. MathLib::toBigUNumber: invalid_argument: "" + str);
        }
    }

    // octal numbers:
    if (isOct(str)) {
        try {
            const biguint ret = std::stoull(str, nullptr, 8);
            return ret;
        } catch (const std::out_of_range& /*e*/) {
            throw InternalError(tok, ""Internal Error. MathLib::toBigUNumber: out_of_range: "" + str);
        } catch (const std::invalid_argument& /*e*/) {
            throw InternalError(tok, ""Internal Error. MathLib::toBigUNum...",1,1,lib/mathlib.cpp,"MathLib.toBigUNumber:unsigned longlongint(std.string&,Token*)",<empty>,,false,295,364,toBigUNumber,,,1,"unsigned longlongint(std.string&,Token*)"
111669152745,METHOD,<empty>,<empty>,"[](uint32_t v, char c) {
        return (v << 8) | c;
    }",66,5,lib/mathlib.cpp,"lib/mathlib.cpp:<global>.MathLib.encodeMultiChar.<lambda>0:ANY(uint32_t,char)",<empty>,,false,368,370,<lambda>0,,,1,"ANY(uint32_t,char)"
111669152746,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"unsigned int MathLib::encodeMultiChar(const std::string& str)
{
    return std::accumulate(str.cbegin(), str.cend(), uint32_t(), [](uint32_t v, char c) {
        return (v << 8) | c;
    });
}",1,1,lib/mathlib.cpp,MathLib.encodeMultiChar:unsigned int(std.string&),<empty>,,false,366,371,encodeMultiChar,,,1,unsigned int(std.string&)
111669152747,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"MathLib::bigint MathLib::toBigNumber(const Token * tok)
{
    return toBigNumber(tok->str(), tok);
}",1,1,lib/mathlib.cpp,MathLib.toBigNumber:longlongint(Token*),<empty>,,false,373,376,toBigNumber,,,1,longlongint(Token*)
111669152748,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"MathLib::bigint MathLib::toBigNumber(const std::string & str, const Token * const tok)
{
    // hexadecimal numbers:
    if (isIntHex(str)) {
        try {
            const biguint ret = std::stoull(str, nullptr, 16);
            return (bigint)ret;
        } catch (const std::out_of_range& /*e*/) {
            throw InternalError(tok, ""Internal Error. MathLib::toBigNumber: out_of_range: "" + str);
        } catch (const std::invalid_argument& /*e*/) {
            throw InternalError(tok, ""Internal Error. MathLib::toBigNumber: invalid_argument: "" + str);
        }
    }

    // octal numbers:
    if (isOct(str)) {
        try {
            const biguint ret = std::stoull(str, nullptr, 8);
            return ret;
        } catch (const std::out_of_range& /*e*/) {
            throw InternalError(tok, ""Internal Error. MathLib::toBigNumber: out_of_range: "" + str);
        } catch (const std::invalid_argument& /*e*/) {
            throw InternalError(tok, ""Internal Error. MathLib::toBigN...",1,1,lib/mathlib.cpp,"MathLib.toBigNumber:longlongint(std.string&,Token*)",<empty>,,false,379,449,toBigNumber,,,1,"longlongint(std.string&,Token*)"
111669152749,METHOD,<empty>,<empty>,"[&](char c) {
        if ((10 < base) && (c > '9'))
            return 10 + std::tolower(c) - 'a';
        return c - '0';
    }",21,5,lib/mathlib.cpp,lib/mathlib.cpp:<global>.myStod.<lambda>1:int(char),<empty>,,false,472,476,<lambda>1,,,1,int(char)
111669152750,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"static double myStod(const std::string& str, std::string::const_iterator from, std::string::const_iterator to, int base)
{
    double result = 0.;
    bool positivesign = true;
    std::string::const_iterator it;
    if ('+' == *from) {
        it = from + 1;
    } else if ('-' == *from) {
        it = from + 1;
        positivesign = false;
    } else
        it = from;
    const std::size_t decimalsep = str.find('.', it-str.begin());
    int distance;
    if (std::string::npos == decimalsep) {
        distance = to - it;
    } else if (decimalsep > (to - str.begin()))
        return 0.; // error handling??
    else
        distance = int(decimalsep)-(from - str.begin());
    auto digitval = [&](char c) {
        if ((10 < base) && (c > '9'))
            return 10 + std::tolower(c) - 'a';
        return c - '0';
    };
    for (; it!=to; ++it) {
        if ('.' == *it)
            continue;
        --distance;
        result += digitval(*it)* std::pow(base, distance);
    }
    ret...",1,1,lib/mathlib.cpp,"myStod:double(std.string&,std.string.const_iterator,std.string.const_iterator,int)",<empty>,,false,452,484,myStod,,,1,"double(std.string&,std.string.const_iterator,std.string.const_iterator,int)"
111669152751,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"static double floatHexToDoubleNumber(const std::string& str)
{
    const std::size_t p = str.find_first_of(""pP"",3);
    const double factor1 = myStod(str, str.cbegin() + 2, str.cbegin()+p, 16);
    const bool suffix = (str.back() == 'f') || (str.back() == 'F') || (str.back() == 'l') || (str.back() == 'L');
    const double exponent = myStod(str, str.cbegin() + p + 1, suffix ? str.cend()-1:str.cend(), 10);
    const double factor2 = std::pow(2, exponent);
    return factor1 * factor2;
}",1,1,lib/mathlib.cpp,floatHexToDoubleNumber:double(std.string&),<empty>,,false,488,496,floatHexToDoubleNumber,,,1,double(std.string&)
111669152752,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"double MathLib::toDoubleNumber(const Token * tok)
{
    return toDoubleNumber(tok->str(), tok);
}",1,1,lib/mathlib.cpp,MathLib.toDoubleNumber:double(Token*),<empty>,,false,498,501,toDoubleNumber,,,1,double(Token*)
111669152753,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"double MathLib::toDoubleNumber(const std::string &str, const Token * const tok)
{
    if (isCharLiteral(str)) {
        try {
            return simplecpp::characterLiteralToLL(str);
        } catch (const std::exception& e) {
            throw InternalError(tok, ""Internal Error. MathLib::toDoubleNumber: characterLiteralToLL("" + str + "") => "" + e.what());
        }
    }
    if (isIntHex(str))
        return static_cast<double>(toBigNumber(str, tok));
#ifdef _LIBCPP_VERSION
    if (isFloat(str)) // Workaround libc++ bug at https://github.com/llvm/llvm-project/issues/18156
        // TODO: handle locale
        // TODO: make sure all characters are being consumed
        return std::strtod(str.c_str(), nullptr);
#endif
    if (isFloatHex(str))
        return floatHexToDoubleNumber(str);
    // otherwise, convert to double
    std::istringstream istr(str);
    istr.imbue(std::locale::classic());
    double ret;
    if (!(istr >> ret))
        throw InternalError(tok, ""Internal Error. ...",1,1,lib/mathlib.cpp,"MathLib.toDoubleNumber:double(std.string&,Token*)",<empty>,,false,503,536,toDoubleNumber,,,1,"double(std.string&,Token*)"
111669152754,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"std::string MathLib::toString<MathLib::bigint>(MathLib::bigint value)
{
#if defined(HAVE_BOOST) && defined(HAVE_BOOST_INT128)
    std::ostringstream result;
    result << value;
    return result.str();
#else
    return std::to_string(value);
#endif
}",12,1,lib/mathlib.cpp,MathLib.toString<MathLib.bigint>:string(MathLib.bigint),<empty>,,false,538,547,toString,,,1,string(MathLib.bigint)
111669152755,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"std::string MathLib::toString<MathLib::biguint>(MathLib::biguint value)
{
#if defined(HAVE_BOOST) && defined(HAVE_BOOST_INT128)
    std::ostringstream result;
    result << value;
    return result.str();
#else
    return std::to_string(value);
#endif
}",12,1,lib/mathlib.cpp,MathLib.toString<MathLib.biguint>:string(MathLib.biguint),<empty>,,false,549,558,toString,,,1,string(MathLib.biguint)
111669152756,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"std::string MathLib::toString<double>(double value)
{
    std::ostringstream result;
    result.precision(12);
    result << value;
    std::string s = result.str();
    if (s == ""-0"")
        return ""0.0"";
    if (s.find_first_of("".e"") == std::string::npos)
        return s + "".0"";
    return s;
}",12,1,lib/mathlib.cpp,MathLib.toString<double>:string(double),<empty>,,false,560,571,toString,,,1,string(double)
111669152757,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"bool MathLib::isFloat(const std::string &str)
{
    return isDecimalFloat(str) || isFloatHex(str);
}",1,1,lib/mathlib.cpp,MathLib.isFloat:bool(std.string&),<empty>,,false,573,576,isFloat,,,1,bool(std.string&)
111669152758,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"bool MathLib::isDecimalFloat(const std::string &str)
{
    if (str.empty())
        return false;
    enum class State : std::uint8_t {
        START, BASE_DIGITS1, LEADING_DECIMAL, TRAILING_DECIMAL, BASE_DIGITS2, E, MANTISSA_PLUSMINUS, MANTISSA_DIGITS, SUFFIX_F, SUFFIX_L, SUFFIX_LITERAL_LEADER, SUFFIX_LITERAL
    } state = State::START;
    auto it = str.cbegin();
    if ('+' == *it || '-' == *it)
        ++it;
    for (; it != str.cend(); ++it) {
        switch (state) {
        case State::START:
            if (*it=='.')
                state = State::LEADING_DECIMAL;
            else if (std::isdigit(static_cast<unsigned char>(*it)))
                state = State::BASE_DIGITS1;
            else
                return false;
            break;
        case State::LEADING_DECIMAL:
            if (std::isdigit(static_cast<unsigned char>(*it)))
                state = State::BASE_DIGITS2;
            else
                return false;
            break;
        case State::BASE_DIG...",1,1,lib/mathlib.cpp,MathLib.isDecimalFloat:bool(std.string&),<empty>,,false,578,672,isDecimalFloat,,,1,bool(std.string&)
111669152759,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"bool MathLib::isNegative(const std::string &str)
{
    if (str.empty())
        return false;
    return (str[0] == '-');
}",1,1,lib/mathlib.cpp,MathLib.isNegative:bool(std.string&),<empty>,,false,674,679,isNegative,,,1,bool(std.string&)
111669152760,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"bool MathLib::isPositive(const std::string &str)
{
    if (str.empty())
        return false;
    return !MathLib::isNegative(str);
}",1,1,lib/mathlib.cpp,MathLib.isPositive:bool(std.string&),<empty>,,false,681,686,isPositive,,,1,bool(std.string&)
111669152761,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"static bool isValidIntegerSuffixIt(std::string::const_iterator it, std::string::const_iterator end, bool supportMicrosoftExtensions=true)
{
    enum class Status : std::uint8_t { START, SUFFIX_U, SUFFIX_UL, SUFFIX_ULL, SUFFIX_UZ, SUFFIX_L, SUFFIX_LU, SUFFIX_LL, SUFFIX_LLU, SUFFIX_I, SUFFIX_I6, SUFFIX_I64, SUFFIX_UI, SUFFIX_UI6, SUFFIX_UI64, SUFFIX_Z, SUFFIX_LITERAL_LEADER, SUFFIX_LITERAL } state = Status::START;
    for (; it != end; ++it) {
        switch (state) {
        case Status::START:
            if (*it == 'u' || *it == 'U')
                state = Status::SUFFIX_U;
            else if (*it == 'l' || *it == 'L')
                state = Status::SUFFIX_L;
            else if (*it == 'z' || *it == 'Z')
                state = Status::SUFFIX_Z;
            else if (supportMicrosoftExtensions && (*it == 'i' || *it == 'I'))
                state = Status::SUFFIX_I;
            else if (*it == '_')
                state = Status::SUFFIX_LITERAL_LEADER;
            else
          ...",1,1,lib/mathlib.cpp,"isValidIntegerSuffixIt:bool(std.string.const_iterator,std.string.const_iterator,bool)",<empty>,,false,688,790,isValidIntegerSuffixIt,,,1,"bool(std.string.const_iterator,std.string.const_iterator,bool)"
111669152762,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"bool MathLib::isValidIntegerSuffix(const std::string& str, bool supportMicrosoftExtensions)
{
    return isValidIntegerSuffixIt(str.cbegin(), str.cend(), supportMicrosoftExtensions);
}",1,1,lib/mathlib.cpp,"MathLib.isValidIntegerSuffix:bool(std.string&,bool)",<empty>,,false,793,796,isValidIntegerSuffix,,,1,"bool(std.string&,bool)"
111669152763,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"bool MathLib::isOct(const std::string& str)
{
    enum class Status : std::uint8_t {
        START, OCTAL_PREFIX, DIGITS
    } state = Status::START;
    if (str.empty())
        return false;
    auto it = str.cbegin();
    if ('+' == *it || '-' == *it)
        ++it;
    for (; it != str.cend(); ++it) {
        switch (state) {
        case Status::START:
            if (*it == '0')
                state = Status::OCTAL_PREFIX;
            else
                return false;
            break;
        case Status::OCTAL_PREFIX:
            if (isOctalDigit(static_cast<unsigned char>(*it)))
                state = Status::DIGITS;
            else
                return false;
            break;
        case Status::DIGITS:
            if (isOctalDigit(static_cast<unsigned char>(*it)))
                state = Status::DIGITS;
            else
                return isValidIntegerSuffixIt(it,str.end());
            break;
        }
    }
    return state == Status::DIGITS;
}",1,1,lib/mathlib.cpp,MathLib.isOct:bool(std.string&),<empty>,,false,809,842,isOct,,,1,bool(std.string&)
111669152764,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"bool MathLib::isIntHex(const std::string& str)
{
    enum class Status : std::uint8_t {
        START, HEX_0, HEX_X, DIGIT
    } state = Status::START;
    if (str.empty())
        return false;
    auto it = str.cbegin();
    if ('+' == *it || '-' == *it)
        ++it;
    for (; it != str.cend(); ++it) {
        switch (state) {
        case Status::START:
            if (*it == '0')
                state = Status::HEX_0;
            else
                return false;
            break;
        case Status::HEX_0:
            if (*it == 'x' || *it == 'X')
                state = Status::HEX_X;
            else
                return false;
            break;
        case Status::HEX_X:
            if (isxdigit(static_cast<unsigned char>(*it)))
                state = Status::DIGIT;
            else
                return false;
            break;
        case Status::DIGIT:
            if (isxdigit(static_cast<unsigned char>(*it)))
                ; //  state = Status::DIGIT;
    ...",1,1,lib/mathlib.cpp,MathLib.isIntHex:bool(std.string&),<empty>,,false,844,883,isIntHex,,,1,bool(std.string&)
111669152765,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"bool MathLib::isFloatHex(const std::string& str)
{
    enum class Status : std::uint8_t {
        START, HEX_0, HEX_X, WHOLE_NUMBER_DIGIT, POINT, FRACTION, EXPONENT_P, EXPONENT_SIGN, EXPONENT_DIGITS, EXPONENT_SUFFIX
    } state = Status::START;
    if (str.empty())
        return false;
    auto it = str.cbegin();
    if ('+' == *it || '-' == *it)
        ++it;
    for (; it != str.cend(); ++it) {
        switch (state) {
        case Status::START:
            if (*it == '0')
                state = Status::HEX_0;
            else
                return false;
            break;
        case Status::HEX_0:
            if (*it == 'x' || *it == 'X')
                state = Status::HEX_X;
            else
                return false;
            break;
        case Status::HEX_X:
            if (isxdigit(static_cast<unsigned char>(*it)))
                state = Status::WHOLE_NUMBER_DIGIT;
            else if (*it == '.')
                state = Status::POINT;
            else
       ...",1,1,lib/mathlib.cpp,MathLib.isFloatHex:bool(std.string&),<empty>,,false,885,963,isFloatHex,,,1,bool(std.string&)
111669152766,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"bool MathLib::isBin(const std::string& str)
{
    enum class Status : std::uint8_t {
        START, GNU_BIN_PREFIX_0, GNU_BIN_PREFIX_B, DIGIT
    } state = Status::START;
    if (str.empty())
        return false;
    auto it = str.cbegin();
    if ('+' == *it || '-' == *it)
        ++it;
    for (; it != str.cend(); ++it) {
        switch (state) {
        case Status::START:
            if (*it == '0')
                state = Status::GNU_BIN_PREFIX_0;
            else
                return false;
            break;
        case Status::GNU_BIN_PREFIX_0:
            if (*it == 'b' || *it == 'B')
                state = Status::GNU_BIN_PREFIX_B;
            else
                return false;
            break;
        case Status::GNU_BIN_PREFIX_B:
            if (*it == '0' || *it == '1')
                state = Status::DIGIT;
            else
                return false;
            break;
        case Status::DIGIT:
            if (*it == '0' || *it == '1')
                ; //...",1,1,lib/mathlib.cpp,MathLib.isBin:bool(std.string&),<empty>,,false,975,1014,isBin,,,1,bool(std.string&)
111669152767,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"bool MathLib::isDec(const std::string & str)
{
    enum class Status : std::uint8_t {
        START, DIGIT
    } state = Status::START;
    if (str.empty())
        return false;
    auto it = str.cbegin();
    if ('+' == *it || '-' == *it)
        ++it;
    for (; it != str.cend(); ++it) {
        switch (state) {
        case Status::START:
            if (isdigit(static_cast<unsigned char>(*it)))
                state = Status::DIGIT;
            else
                return false;
            break;
        case Status::DIGIT:
            if (isdigit(static_cast<unsigned char>(*it)))
                state = Status::DIGIT;
            else
                return isValidIntegerSuffixIt(it,str.end());
            break;
        }
    }
    return state == Status::DIGIT;
}",1,1,lib/mathlib.cpp,MathLib.isDec:bool(std.string&),<empty>,,false,1016,1043,isDec,,,1,bool(std.string&)
111669152768,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"bool MathLib::isInt(const std::string & str)
{
    return isDec(str) || isIntHex(str) || isOct(str) || isBin(str);
}",1,1,lib/mathlib.cpp,MathLib.isInt:bool(std.string&),<empty>,,false,1045,1048,isInt,,,1,bool(std.string&)
111669152769,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"std::string MathLib::getSuffix(const std::string& value)
{
    if (value.size() > 3 && value[value.size() - 3] == 'i' && value[value.size() - 2] == '6' && value[value.size() - 1] == '4') {
        if (value[value.size() - 4] == 'u')
            return ""ULL"";
        return ""LL"";
    }
    bool isUnsigned = false;
    unsigned int longState = 0;
    for (std::size_t i = 1U; i < value.size(); ++i) {
        const char c = value[value.size() - i];
        if (c == 'u' || c == 'U')
            isUnsigned = true;
        else if (c == 'L' || c == 'l')
            longState++;
        else break;
    }
    if (longState == 0)
        return isUnsigned ? ""U"" : """";
    if (longState == 1)
        return isUnsigned ? ""UL"" : ""L"";
    if (longState == 2)
        return isUnsigned ? ""ULL"" : ""LL"";
    return """";
}",1,1,lib/mathlib.cpp,MathLib.getSuffix:string(std.string&),<empty>,,false,1050,1074,getSuffix,,,1,string(std.string&)
111669152770,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"static std::string intsuffix(const std::string & first, const std::string & second)
{
    const std::string suffix1 = MathLib::getSuffix(first);
    const std::string suffix2 = MathLib::getSuffix(second);
    if (suffix1 == ""ULL"" || suffix2 == ""ULL"")
        return ""ULL"";
    if (suffix1 == ""LL"" || suffix2 == ""LL"")
        return ""LL"";
    if (suffix1 == ""UL"" || suffix2 == ""UL"")
        return ""UL"";
    if (suffix1 == ""L"" || suffix2 == ""L"")
        return ""L"";
    if (suffix1 == ""U"" || suffix2 == ""U"")
        return ""U"";

    return suffix1.empty() ? suffix2 : suffix1;
}",1,1,lib/mathlib.cpp,"intsuffix:string(std.string&,std.string&)",<empty>,,false,1076,1092,intsuffix,,,1,"string(std.string&,std.string&)"
111669152771,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"std::string MathLib::add(const std::string & first, const std::string & second)
{
#ifdef TEST_MATHLIB_VALUE
    return (value(first) + value(second)).str();
#else
    if (MathLib::isInt(first) && MathLib::isInt(second)) {
        return MathLib::toString(toBigNumber(first) + toBigNumber(second)) + intsuffix(first, second);
    }

    double d1 = toDoubleNumber(first);
    double d2 = toDoubleNumber(second);

    int count = 0;
    while (d1 > 100000.0 * d2 && toString(d1+d2)==first && ++count<5)
        d2 *= 10.0;
    while (d2 > 100000.0 * d1 && toString(d1+d2)==second && ++count<5)
        d1 *= 10.0;

    return toString(d1 + d2);
#endif
}",1,1,lib/mathlib.cpp,"MathLib.add:string(std.string&,std.string&)",<empty>,,false,1094,1114,add,,,1,"string(std.string&,std.string&)"
111669152772,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"std::string MathLib::subtract(const std::string &first, const std::string &second)
{
#ifdef TEST_MATHLIB_VALUE
    return (value(first) - value(second)).str();
#else
    if (MathLib::isInt(first) && MathLib::isInt(second)) {
        return MathLib::toString(toBigNumber(first) - toBigNumber(second)) + intsuffix(first, second);
    }

    if (first == second)
        return ""0.0"";

    double d1 = toDoubleNumber(first);
    double d2 = toDoubleNumber(second);

    int count = 0;
    while (d1 > 100000.0 * d2 && toString(d1-d2)==first && ++count<5)
        d2 *= 10.0;
    while (d2 > 100000.0 * d1 && toString(d1-d2)==second && ++count<5)
        d1 *= 10.0;

    return toString(d1 - d2);
#endif
}",1,1,lib/mathlib.cpp,"MathLib.subtract:string(std.string&,std.string&)",<empty>,,false,1116,1139,subtract,,,1,"string(std.string&,std.string&)"
111669152773,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"std::string MathLib::divide(const std::string &first, const std::string &second)
{
#ifdef TEST_MATHLIB_VALUE
    return (value(first) / value(second)).str();
#else
    if (MathLib::isInt(first) && MathLib::isInt(second)) {
        const bigint a = toBigNumber(first);
        const bigint b = toBigNumber(second);
        if (b == 0)
            throw InternalError(nullptr, ""Internal Error: Division by zero"");
        if (a == std::numeric_limits<bigint>::min() && std::abs(b)<=1)
            throw InternalError(nullptr, ""Internal Error: Division overflow"");
        return MathLib::toString(toBigNumber(first) / b) + intsuffix(first, second);
    }
    if (isNullValue(second)) {
        if (isNullValue(first))
            return ""nan.0"";
        return isPositive(first) == isPositive(second) ? ""inf.0"" : ""-inf.0"";
    }
    return toString(toDoubleNumber(first) / toDoubleNumber(second));
#endif
}",1,1,lib/mathlib.cpp,"MathLib.divide:string(std.string&,std.string&)",<empty>,,false,1141,1162,divide,,,1,"string(std.string&,std.string&)"
111669152774,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"std::string MathLib::multiply(const std::string &first, const std::string &second)
{
#ifdef TEST_MATHLIB_VALUE
    return (value(first) * value(second)).str();
#else
    if (MathLib::isInt(first) && MathLib::isInt(second)) {
        return MathLib::toString(toBigNumber(first) * toBigNumber(second)) + intsuffix(first, second);
    }
    return toString(toDoubleNumber(first) * toDoubleNumber(second));
#endif
}",1,1,lib/mathlib.cpp,"MathLib.multiply:string(std.string&,std.string&)",<empty>,,false,1164,1174,multiply,,,1,"string(std.string&,std.string&)"
111669152775,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"std::string MathLib::mod(const std::string &first, const std::string &second)
{
#ifdef TEST_MATHLIB_VALUE
    return (value(first) % value(second)).str();
#else
    if (MathLib::isInt(first) && MathLib::isInt(second)) {
        const bigint b = toBigNumber(second);
        if (b == 0)
            throw InternalError(nullptr, ""Internal Error: Division by zero"");
        return MathLib::toString(toBigNumber(first) % b) + intsuffix(first, second);
    }
    return toString(std::fmod(toDoubleNumber(first),toDoubleNumber(second)));
#endif
}",1,1,lib/mathlib.cpp,"MathLib.mod:string(std.string&,std.string&)",<empty>,,false,1176,1189,mod,,,1,"string(std.string&,std.string&)"
111669152776,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"std::string MathLib::calculate(const std::string &first, const std::string &second, char action)
{
    switch (action) {
    case '+':
        return MathLib::add(first, second);

    case '-':
        return MathLib::subtract(first, second);

    case '*':
        return MathLib::multiply(first, second);

    case '/':
        return MathLib::divide(first, second);

    case '%':
        return MathLib::mod(first, second);

    case '&':
        return MathLib::toString(MathLib::toBigNumber(first) & MathLib::toBigNumber(second)) + intsuffix(first, second);

    case '|':
        return MathLib::toString(MathLib::toBigNumber(first) | MathLib::toBigNumber(second)) + intsuffix(first, second);

    case '^':
        return MathLib::toString(MathLib::toBigNumber(first) ^ MathLib::toBigNumber(second)) + intsuffix(first, second);

    default:
        throw InternalError(nullptr, std::string(""Unexpected action '"") + action + ""' in MathLib::calculate(). Please report this to Cppcheck devel...",1,1,lib/mathlib.cpp,"MathLib.calculate:string(std.string&,std.string&,char)",<empty>,,false,1191,1221,calculate,,,1,"string(std.string&,std.string&,char)"
111669152777,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"std::string MathLib::sin(const std::string &tok)
{
    return toString(std::sin(toDoubleNumber(tok)));
}",1,1,lib/mathlib.cpp,MathLib.sin:string(std.string&),<empty>,,false,1223,1226,sin,,,1,string(std.string&)
111669152778,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"std::string MathLib::cos(const std::string &tok)
{
    return toString(std::cos(toDoubleNumber(tok)));
}",1,1,lib/mathlib.cpp,MathLib.cos:string(std.string&),<empty>,,false,1229,1232,cos,,,1,string(std.string&)
111669152779,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"std::string MathLib::tan(const std::string &tok)
{
    return toString(std::tan(toDoubleNumber(tok)));
}",1,1,lib/mathlib.cpp,MathLib.tan:string(std.string&),<empty>,,false,1234,1237,tan,,,1,string(std.string&)
111669152780,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"std::string MathLib::abs(const std::string &tok)
{
    if (isNegative(tok))
        return tok.substr(1, tok.length() - 1);
    return tok;
}",1,1,lib/mathlib.cpp,MathLib.abs:string(std.string&),<empty>,,false,1240,1245,abs,,,1,string(std.string&)
111669152781,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"bool MathLib::isEqual(const std::string &first, const std::string &second)
{
    // this conversion is needed for formatting
    // e.g. if first=0.1 and second=1.0E-1, the direct comparison of the strings would fail
    return toString(toDoubleNumber(first)) == toString(toDoubleNumber(second));
}",1,1,lib/mathlib.cpp,"MathLib.isEqual:bool(std.string&,std.string&)",<empty>,,false,1247,1252,isEqual,,,1,"bool(std.string&,std.string&)"
111669152782,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"bool MathLib::isNotEqual(const std::string &first, const std::string &second)
{
    return !isEqual(first, second);
}",1,1,lib/mathlib.cpp,"MathLib.isNotEqual:bool(std.string&,std.string&)",<empty>,,false,1254,1257,isNotEqual,,,1,"bool(std.string&,std.string&)"
111669152783,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"bool MathLib::isGreater(const std::string &first, const std::string &second)
{
    return toDoubleNumber(first) > toDoubleNumber(second);
}",1,1,lib/mathlib.cpp,"MathLib.isGreater:bool(std.string&,std.string&)",<empty>,,false,1260,1263,isGreater,,,1,"bool(std.string&,std.string&)"
111669152784,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"bool MathLib::isGreaterEqual(const std::string &first, const std::string &second)
{
    return toDoubleNumber(first) >= toDoubleNumber(second);
}",1,1,lib/mathlib.cpp,"MathLib.isGreaterEqual:bool(std.string&,std.string&)",<empty>,,false,1266,1269,isGreaterEqual,,,1,"bool(std.string&,std.string&)"
111669152785,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"bool MathLib::isLess(const std::string &first, const std::string &second)
{
    return toDoubleNumber(first) < toDoubleNumber(second);
}",1,1,lib/mathlib.cpp,"MathLib.isLess:bool(std.string&,std.string&)",<empty>,,false,1272,1275,isLess,,,1,"bool(std.string&,std.string&)"
111669152786,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"bool MathLib::isLessEqual(const std::string &first, const std::string &second)
{
    return toDoubleNumber(first) <= toDoubleNumber(second);
}",1,1,lib/mathlib.cpp,"MathLib.isLessEqual:bool(std.string&,std.string&)",<empty>,,false,1277,1280,isLessEqual,,,1,"bool(std.string&,std.string&)"
111669152787,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"bool MathLib::isNullValue(const std::string &str)
{
    if (str.empty() || (!std::isdigit(static_cast<unsigned char>(str[0])) && (str[0] != '.' && str[0] != '-' && str[0] != '+')))
        return false; // Has to be a number

    if (!isInt(str) && !isFloat(str))
        return false;
    const bool isHex = isIntHex(str) || isFloatHex(str);
    for (const char i : str) {
        if (std::isdigit(static_cast<unsigned char>(i)) && i != '0') // May not contain digits other than 0
            return false;
        if (i == 'p' || i == 'P' || (!isHex && (i == 'E' || i == 'e')))
            return true;
        if (isHex && isxdigit(i) && i != '0')
            return false;
    }
    return true;
}",1,1,lib/mathlib.cpp,MathLib.isNullValue:bool(std.string&),<empty>,,false,1291,1308,isNullValue,,,1,bool(std.string&)
111669152788,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"bool MathLib::isOctalDigit(char c)
{
    return (c >= '0' && c <= '7');
}",1,1,lib/mathlib.cpp,MathLib.isOctalDigit:bool(char),<empty>,,false,1310,1313,isOctalDigit,,,1,bool(char)
111669152789,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"MathLib::value operator+(const MathLib::value &v1, const MathLib::value &v2)
{
    return MathLib::value::calc('+',v1,v2);
}",1,1,lib/mathlib.cpp,"+:MathLib.value(MathLib.value&,MathLib.value&)",<empty>,,false,1315,1318,+,,,1,"MathLib.value(MathLib.value&,MathLib.value&)"
111669152790,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"MathLib::value operator-(const MathLib::value &v1, const MathLib::value &v2)
{
    return MathLib::value::calc('-',v1,v2);
}",1,1,lib/mathlib.cpp,"-:MathLib.value(MathLib.value&,MathLib.value&)",<empty>,,false,1320,1323,-,,,1,"MathLib.value(MathLib.value&,MathLib.value&)"
111669152791,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"MathLib::value operator*(const MathLib::value &v1, const MathLib::value &v2)
{
    return MathLib::value::calc('*',v1,v2);
}",1,1,lib/mathlib.cpp,"*:MathLib.value(MathLib.value&,MathLib.value&)",<empty>,,false,1325,1328,*,,,1,"MathLib.value(MathLib.value&,MathLib.value&)"
111669152792,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"MathLib::value operator/(const MathLib::value &v1, const MathLib::value &v2)
{
    return MathLib::value::calc('/',v1,v2);
}",1,1,lib/mathlib.cpp,"/:MathLib.value(MathLib.value&,MathLib.value&)",<empty>,,false,1330,1333,/,,,1,"MathLib.value(MathLib.value&,MathLib.value&)"
111669152793,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"MathLib::value operator%(const MathLib::value &v1, const MathLib::value &v2)
{
    return MathLib::value::calc('%',v1,v2);
}",1,1,lib/mathlib.cpp,"%:MathLib.value(MathLib.value&,MathLib.value&)",<empty>,,false,1335,1338,%,,,1,"MathLib.value(MathLib.value&,MathLib.value&)"
111669152794,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"MathLib::value operator&(const MathLib::value &v1, const MathLib::value &v2)
{
    return MathLib::value::calc('&',v1,v2);
}",1,1,lib/mathlib.cpp,"&:MathLib.value(MathLib.value&,MathLib.value&)",<empty>,,false,1340,1343,&,,,1,"MathLib.value(MathLib.value&,MathLib.value&)"
111669152795,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"MathLib::value operator|(const MathLib::value &v1, const MathLib::value &v2)
{
    return MathLib::value::calc('|',v1,v2);
}",1,1,lib/mathlib.cpp,"|:MathLib.value(MathLib.value&,MathLib.value&)",<empty>,,false,1345,1348,|,,,1,"MathLib.value(MathLib.value&,MathLib.value&)"
111669152796,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"MathLib::value operator^(const MathLib::value &v1, const MathLib::value &v2)
{
    return MathLib::value::calc('^',v1,v2);
}",1,1,lib/mathlib.cpp,"^:MathLib.value(MathLib.value&,MathLib.value&)",<empty>,,false,1350,1353,^,,,1,"MathLib.value(MathLib.value&,MathLib.value&)"
111669152797,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"MathLib::value operator<<(const MathLib::value &v1, const MathLib::value &v2)
{
    return v1.shiftLeft(v2);
}",1,1,lib/mathlib.cpp,"<<:MathLib.value(MathLib.value&,MathLib.value&)",<empty>,,false,1355,1358,<<,,,1,"MathLib.value(MathLib.value&,MathLib.value&)"
111669152798,METHOD,lib/mathlib.cpp:<global>,TYPE_DECL,"MathLib::value operator>>(const MathLib::value &v1, const MathLib::value &v2)
{
    return v1.shiftRight(v2);
}",1,1,lib/mathlib.cpp,">>:MathLib.value(MathLib.value&,MathLib.value&)",<empty>,,false,1360,1363,>>,,,1,"MathLib.value(MathLib.value&,MathLib.value&)"
111669152799,METHOD,lib/mathlib.h:<global>,TYPE_DECL,<global>,1,1,lib/mathlib.h,lib/mathlib.h:<global>,<empty>,,false,1,166,<global>,,,1,
111669152800,METHOD,lib/path.cpp:<global>,TYPE_DECL,"static constexpr bool caseInsensitiveFilesystem()
{
#if defined(_WIN32) || (defined(__APPLE__) && defined(__MACH__))
    // Windows is case insensitive
    // MacOS is case insensitive by default (also supports case sensitivity)
    return true;
#else
    // TODO: Non-windows filesystems might be case insensitive
    // needs to be determined per filesystem and location - e.g. /sys/fs/ext4/features/casefold
    return false;
#endif
}",1,1,lib/path.cpp,caseInsensitiveFilesystem:bool(),<empty>,,false,58,69,caseInsensitiveFilesystem,,,1,bool()
111669152801,METHOD,lib/path.cpp:<global>,TYPE_DECL,<global>,1,1,lib/path.cpp,lib/path.cpp:<global>,<empty>,,false,1,450,<global>,,,1,
111669152802,METHOD,lib/path.cpp:<global>,TYPE_DECL,"std::string Path::toNativeSeparators(std::string path)
{
#if defined(_WIN32)
    constexpr char separ = '/';
    constexpr char native = '\\\\';
#else
    constexpr char separ = '\\\\';
    constexpr char native = '/';
#endif
    std::replace(path.begin(), path.end(), separ, native);
    return path;
}",1,1,lib/path.cpp,Path.toNativeSeparators:string(std.string),<empty>,,false,71,82,toNativeSeparators,,,1,string(std.string)
111669152803,METHOD,lib/path.cpp:<global>,TYPE_DECL,"std::string Path::fromNativeSeparators(std::string path)
{
    constexpr char nonnative = '\\\\';
    constexpr char newsepar = '/';
    std::replace(path.begin(), path.end(), nonnative, newsepar);
    return path;
}",1,1,lib/path.cpp,Path.fromNativeSeparators:string(std.string),<empty>,,false,84,90,fromNativeSeparators,,,1,string(std.string)
111669152804,METHOD,lib/path.cpp:<global>,TYPE_DECL,"std::string Path::simplifyPath(std::string originalPath)
{
    return simplecpp::simplifyPath(std::move(originalPath));
}",1,1,lib/path.cpp,Path.simplifyPath:string(std.string),<empty>,,false,92,95,simplifyPath,,,1,string(std.string)
111669152805,METHOD,lib/path.cpp:<global>,TYPE_DECL,"std::string Path::getPathFromFilename(const std::string &filename)
{
    const std::size_t pos = filename.find_last_of(""\\\\/"");

    if (pos != std::string::npos)
        return filename.substr(0, 1 + pos);

    return """";
}",1,1,lib/path.cpp,Path.getPathFromFilename:string(std.string&),<empty>,,false,97,105,getPathFromFilename,,,1,string(std.string&)
111669152806,METHOD,lib/path.cpp:<global>,TYPE_DECL,"bool Path::sameFileName(const std::string &fname1, const std::string &fname2)
{
    return caseInsensitiveFilesystem() ? (caseInsensitiveStringCompare(fname1, fname2) == 0) : (fname1 == fname2);
}",1,1,lib/path.cpp,"Path.sameFileName:bool(std.string&,std.string&)",<empty>,,false,107,110,sameFileName,,,1,"bool(std.string&,std.string&)"
111669152807,METHOD,lib/path.cpp:<global>,TYPE_DECL,"std::string Path::removeQuotationMarks(std::string path)
{
    path.erase(std::remove(path.begin(), path.end(), '\\""'), path.end());
    return path;
}",1,1,lib/path.cpp,Path.removeQuotationMarks:string(std.string),<empty>,,false,112,116,removeQuotationMarks,,,1,string(std.string)
111669152808,METHOD,lib/path.cpp:<global>,TYPE_DECL,"std::string Path::getFilenameExtension(const std::string &path, bool lowercase)
{
    const std::string::size_type dotLocation = path.find_last_of('.');
    if (dotLocation == std::string::npos)
        return """";

    std::string extension = path.substr(dotLocation);
    if (lowercase || caseInsensitiveFilesystem()) {
        // on a case insensitive filesystem the case doesn't matter so
        // let's return the extension in lowercase
        strTolower(extension);
    }
    return extension;
}",1,1,lib/path.cpp,"Path.getFilenameExtension:string(std.string&,bool)",<empty>,,false,118,131,getFilenameExtension,,,1,"string(std.string&,bool)"
111669152809,METHOD,lib/path.cpp:<global>,TYPE_DECL,"std::string Path::getFilenameExtensionInLowerCase(const std::string &path)
{
    return getFilenameExtension(path, true);
}",1,1,lib/path.cpp,Path.getFilenameExtensionInLowerCase:string(std.string&),<empty>,,false,133,136,getFilenameExtensionInLowerCase,,,1,string(std.string&)
111669152810,METHOD,lib/path.cpp:<global>,TYPE_DECL,"std::string Path::getCurrentPath()
{
    char currentPath[4096];

#ifndef _WIN32
    if (getcwd(currentPath, 4096) != nullptr)
#else
    if (_getcwd(currentPath, 4096) != nullptr)
#endif
        return std::string(currentPath);

    return """";
}",1,1,lib/path.cpp,Path.getCurrentPath:string(),<empty>,,false,138,150,getCurrentPath,,,1,string()
111669152811,METHOD,lib/path.cpp:<global>,TYPE_DECL,"std::string Path::getCurrentExecutablePath(const char* fallback)
{
    char buf[4096] = {};
    bool success{};
#ifdef _WIN32
    success = (GetModuleFileNameA(nullptr, buf, sizeof(buf)) < sizeof(buf));
#elif defined(__APPLE__)
    uint32_t size = sizeof(buf);
    success = (_NSGetExecutablePath(buf, &size) == 0);
#else
    const char* procPath =
#ifdef __SVR4 // Solaris
        ""/proc/self/path/a.out"";
#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)
        ""/proc/curproc/file"";
#else // Linux
        ""/proc/self/exe"";
#endif
    // readlink does not null-terminate the string if the buffer is too small, therefore write bufsize - 1
    success = (readlink(procPath, buf, sizeof(buf) - 1) != -1);
#endif
    return success ? std::string(buf) : std::string(fallback);
}",1,1,lib/path.cpp,Path.getCurrentExecutablePath:string(char*),<empty>,,false,152,174,getCurrentExecutablePath,,,1,string(char*)
111669152812,METHOD,lib/path.cpp:<global>,TYPE_DECL,"bool Path::isAbsolute(const std::string& path)
{
    const std::string& nativePath = toNativeSeparators(path);

#ifdef _WIN32
    if (path.length() < 2)
        return false;

    // On Windows, 'C:\\foo\\bar' is an absolute path, while 'C:foo\\bar' is not
    return startsWith(nativePath, ""\\\\\\\\"") || (std::isalpha(nativePath[0]) != 0 && nativePath.compare(1, 2, "":\\\\"") == 0);
#else
    return !nativePath.empty() && nativePath[0] == '/';
#endif
}",1,1,lib/path.cpp,Path.isAbsolute:bool(std.string&),<empty>,,false,176,189,isAbsolute,,,1,bool(std.string&)
111669152813,METHOD,lib/path.cpp:<global>,TYPE_DECL,"std::string Path::getRelativePath(const std::string& absolutePath, const std::vector<std::string>& basePaths)
{
    for (const std::string &bp : basePaths) {
        if (absolutePath == bp || bp.empty()) // Seems to be a file, or path is empty
            continue;

        if (absolutePath.compare(0, bp.length(), bp) != 0)
            continue;

        if (endsWith(bp,'/'))
            return absolutePath.substr(bp.length());
        if (absolutePath.size() > bp.size() && absolutePath[bp.length()] == '/')
            return absolutePath.substr(bp.length() + 1);
    }
    return absolutePath;
}",1,1,lib/path.cpp,"Path.getRelativePath:string(std.string&,std.vector<std.string>&)",<empty>,,false,191,206,getRelativePath,,,1,"string(std.string&,std.vector<std.string>&)"
111669152814,METHOD,lib/path.cpp:<global>,TYPE_DECL,"bool Path::acceptFile(const std::string &path, const std::set<std::string> &extra, Standards::Language* lang)
{
    bool header = false;
    Standards::Language l = identify(path, false, &header);
    if (lang)
        *lang = l;
    return (l != Standards::Language::None && !header) || extra.find(getFilenameExtension(path)) != extra.end();
}",1,1,lib/path.cpp,"Path.acceptFile:bool(std.string&,std.set<std.string>&,Standards.Language*)",<empty>,,false,220,227,acceptFile,,,1,"bool(std.string&,std.set<std.string>&,Standards.Language*)"
111669152815,METHOD,lib/path.cpp:<global>,TYPE_DECL,"static bool hasEmacsCppMarker(const char* path)
{
    // TODO: identify is called three times for each file
    // Preprocessor::loadFiles() -> createDUI()
    // Preprocessor::preprocess() -> createDUI()
    // TokenList::createTokens() -> TokenList::determineCppC()
#ifdef LOG_EMACS_MARKER
    std::cout << path << '\\n';
#endif

    FILE *fp = fopen(path, ""rt"");
    if (!fp)
        return false;
    std::string buf(128, '\\0');
    {
        // TODO: read the whole first line only
        const char * const res = fgets(const_cast<char*>(buf.data()), buf.size(), fp);
        fclose(fp);
        fp = nullptr;
        if (!res)
            return false; // failed to read file
    }
    // TODO: replace with regular expression
    const auto pos1 = buf.find(""-*-"");
    if (pos1 == std::string::npos)
        return false; // no start marker
    const auto pos_nl = buf.find_first_of(""\\r\\n"");
    if (pos_nl != std::string::npos && (pos_nl < pos1)) {
#ifdef LOG_EMACS_MARKER
        std::cou...",1,1,lib/path.cpp,hasEmacsCppMarker:bool(char*),<empty>,,false,229,316,hasEmacsCppMarker,,,1,bool(char*)
111669152816,METHOD,lib/path.cpp:<global>,TYPE_DECL,"Standards::Language Path::identify(const std::string &path, bool cppHeaderProbe, bool *header)
{
    // cppcheck-suppress uninitvar - TODO: FP
    if (header)
        *header = false;

    std::string ext = getFilenameExtension(path);
    // standard library headers have no extension
    if (cppHeaderProbe && ext.empty()) {
        if (hasEmacsCppMarker(path.c_str())) {
            if (header)
                *header = true;
            return Standards::Language::CPP;
        }
        return Standards::Language::None;
    }
    if (ext == "".C"")
        return Standards::Language::CPP;
    if (c_src_exts.find(ext) != c_src_exts.end())
        return Standards::Language::C;
    // cppcheck-suppress knownConditionTrueFalse - TODO: FP
    if (!caseInsensitiveFilesystem())
        strTolower(ext);
    if (ext == "".h"") {
        if (header)
            *header = true;
        if (cppHeaderProbe && hasEmacsCppMarker(path.c_str()))
            return Standards::Language::CPP;
        retu...",1,1,lib/path.cpp,"Path.identify:Standards.Language(std.string&,bool,bool*)",<empty>,,false,318,356,identify,,,1,"Standards.Language(std.string&,bool,bool*)"
111669152817,METHOD,lib/path.cpp:<global>,TYPE_DECL,"bool Path::isHeader(const std::string &path)
{
    bool header;
    (void)identify(path, false, &header);
    return header;
}",1,1,lib/path.cpp,Path.isHeader:bool(std.string&),<empty>,,false,358,363,isHeader,,,1,bool(std.string&)
111669152818,METHOD,lib/path.cpp:<global>,TYPE_DECL,"std::string Path::getAbsoluteFilePath(const std::string& filePath)
{
    if (filePath.empty())
        return """";

    std::string absolute_path;
#ifdef _WIN32
    char absolute[_MAX_PATH];
    if (_fullpath(absolute, filePath.c_str(), _MAX_PATH))
        absolute_path = absolute;
    if (!absolute_path.empty() && absolute_path.back() == '\\\\')
        absolute_path.pop_back();
#elif defined(__linux__) || defined(__sun) || defined(__hpux) || defined(__GNUC__) || defined(__CPPCHECK__)
    // simplify the path since any non-existent part has to exist even if discarded by ""..""
    std::string spath = Path::simplifyPath(filePath);
    char * absolute = realpath(spath.c_str(), nullptr);
    if (absolute)
        absolute_path = absolute;
    free(absolute);
    // only throw on realpath() fialure to resolve a path when the given one was non-existent
    if (!spath.empty() && absolute_path.empty() && !exists(spath))
        throw std::runtime_error(""path '"" + filePath + ""' does not exist"")...",1,1,lib/path.cpp,Path.getAbsoluteFilePath:string(std.string&),<empty>,,false,365,391,getAbsoluteFilePath,,,1,string(std.string&)
111669152819,METHOD,lib/path.cpp:<global>,TYPE_DECL,"std::string Path::stripDirectoryPart(const std::string &file)
{
#if defined(_WIN32) && !defined(__MINGW32__)
    constexpr char native = '\\\\';
#else
    constexpr char native = '/';
#endif

    const std::string::size_type p = file.rfind(native);
    if (p != std::string::npos) {
        return file.substr(p + 1);
    }
    return file;
}",1,1,lib/path.cpp,Path.stripDirectoryPart:string(std.string&),<empty>,,false,393,406,stripDirectoryPart,,,1,string(std.string&)
111669152820,METHOD,lib/path.cpp:<global>,TYPE_DECL,"static mode_t file_type(const std::string &path)
{
    struct stat file_stat;
    if (stat(path.c_str(), &file_stat) == -1)
        return 0;
    return file_stat.st_mode & S_IFMT;
}",1,1,lib/path.cpp,file_type:mode_t(std.string&),<empty>,,false,412,418,file_type,,,1,mode_t(std.string&)
111669152821,METHOD,lib/path.cpp:<global>,TYPE_DECL,"bool Path::isFile(const std::string &path)
{
    return file_type(path) == S_IFREG;
}",1,1,lib/path.cpp,Path.isFile:bool(std.string&),<empty>,,false,420,423,isFile,,,1,bool(std.string&)
111669152822,METHOD,lib/path.cpp:<global>,TYPE_DECL,"bool Path::isDirectory(const std::string &path)
{
    return file_type(path) == S_IFDIR;
}",1,1,lib/path.cpp,Path.isDirectory:bool(std.string&),<empty>,,false,425,428,isDirectory,,,1,bool(std.string&)
111669152823,METHOD,lib/path.cpp:<global>,TYPE_DECL,"bool Path::exists(const std::string &path, bool* isdir)
{
    const auto type = file_type(path);
    if (type == S_IFDIR)
    {
        if (isdir)
            *isdir = true;
        return true;
    }
    if (isdir)
        *isdir = false;
    return type == S_IFREG;
}",1,1,lib/path.cpp,"Path.exists:bool(std.string&,bool*)",<empty>,,false,430,442,exists,,,1,"bool(std.string&,bool*)"
111669152824,METHOD,lib/path.cpp:<global>,TYPE_DECL,"std::string Path::join(const std::string& path1, const std::string& path2) {
    if (path1.empty() || path2.empty())
        return path1 + path2;
    if (path2.front() == '/')
        return path2;
    return ((path1.back() == '/') ? path1 : (path1 + ""/"")) + path2;
}",1,1,lib/path.cpp,"Path.join:string(std.string&,std.string&)",<empty>,,false,444,450,join,,,1,"string(std.string&,std.string&)"
111669152825,METHOD,lib/path.h:<global>,TYPE_DECL,<global>,1,1,lib/path.h,lib/path.h:<global>,<empty>,,false,1,211,<global>,,,1,
111669152826,METHOD,lib/pathanalysis.cpp:<global>,TYPE_DECL,"const Scope* PathAnalysis::findOuterScope(const Scope * scope)
{
    if (!scope)
        return nullptr;
    if (scope->isLocal() && scope->type != ScopeType::eSwitch)
        return findOuterScope(scope->nestedIn);
    return scope;
}",1,1,lib/pathanalysis.cpp,PathAnalysis.findOuterScope:Scope*(Scope*),<empty>,,false,30,37,findOuterScope,,,1,Scope*(Scope*)
111669152827,METHOD,lib/pathanalysis.cpp:<global>,TYPE_DECL,<global>,1,1,lib/pathanalysis.cpp,lib/pathanalysis.cpp:<global>,<empty>,,false,1,195,<global>,,,1,
111669152828,METHOD,lib/pathanalysis.cpp:<global>,TYPE_DECL,"static const Token* assignExpr(const Token* tok)
{
    while (tok->astParent() && astIsLHS(tok)) {
        if (Token::Match(tok->astParent(), ""%assign%""))
            return tok->astParent();
        tok = tok->astParent();
    }
    return nullptr;
}",1,1,lib/pathanalysis.cpp,assignExpr:Token*(Token*),<empty>,,false,39,47,assignExpr,,,1,Token*(Token*)
111669152829,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
        return v.isIntValue();
    }",74,5,lib/pathanalysis.cpp,lib/pathanalysis.cpp:<global>.PathAnalysis.checkCond.<lambda>0:bool(ValueFlow.Value&),<empty>,,false,55,57,<lambda>0,,,1,bool(ValueFlow.Value&)
111669152830,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
        if (v.isIntValue())
            return v.intvalue == it->intvalue;
        return true;
    }",77,5,lib/pathanalysis.cpp,lib/pathanalysis.cpp:<global>.PathAnalysis.checkCond.<lambda>1:bool(ValueFlow.Value&),<empty>,,false,59,63,<lambda>1,,,1,bool(ValueFlow.Value&)
111669152831,METHOD,lib/pathanalysis.cpp:<global>,TYPE_DECL,"std::pair<bool, bool> PathAnalysis::checkCond(const Token * tok, bool& known)
{
    if (const ValueFlow::Value* v = tok->getKnownValue(ValueFlow::Value::ValueType::INT)) {
        known = true;
        return std::make_pair(!!v->intvalue, !v->intvalue);
    }
    auto it = std::find_if(tok->values().cbegin(), tok->values().cend(), [](const ValueFlow::Value& v) {
        return v.isIntValue();
    });
    // If all possible values are the same, then assume all paths have the same value
    if (it != tok->values().cend() && std::all_of(it, tok->values().cend(), [&](const ValueFlow::Value& v) {
        if (v.isIntValue())
            return v.intvalue == it->intvalue;
        return true;
    })) {
        known = false;
        return std::make_pair(!!it->intvalue, !it->intvalue);
    }
    return std::make_pair(true, true);
}",1,1,lib/pathanalysis.cpp,"PathAnalysis.checkCond:pair<bool,bool>(Token*,bool&)",<empty>,,false,49,68,checkCond,,,1,"pair<bool,bool>(Token*,bool&)"
111669152832,METHOD,lib/pathanalysis.cpp:<global>,TYPE_DECL,"PathAnalysis::Progress PathAnalysis::forwardRecursive(const Token* tok, Info info, const std::function<PathAnalysis::Progress(const Info&)>& f)
{
    if (!tok)
        return Progress::Continue;
    if (tok->astOperand1() && forwardRecursive(tok->astOperand1(), info, f) == Progress::Break)
        return Progress::Break;
    info.tok = tok;
    if (f(info) == Progress::Break)
        return Progress::Break;
    if (tok->astOperand2() && forwardRecursive(tok->astOperand2(), std::move(info), f) == Progress::Break)
        return Progress::Break;
    return Progress::Continue;
}",1,1,lib/pathanalysis.cpp,"PathAnalysis.forwardRecursive:PathAnalysis.Progress(Token*,PathAnalysis.Info,std.function<PathAnalysis.Progress(constInfo&)>&)",<empty>,,false,70,82,forwardRecursive,,,1,"PathAnalysis.Progress(Token*,PathAnalysis.Info,std.function<PathAnalysis.Progress(constInfo&)>&)"
111669152833,METHOD,lib/pathanalysis.cpp:<global>,TYPE_DECL,"PathAnalysis::Progress PathAnalysis::forwardRange(const Token* startToken, const Token* endToken, Info info, const std::function<PathAnalysis::Progress(const Info&)>& f) const
{
    for (const Token *tok = startToken; precedes(tok, endToken); tok = tok->next()) {
        if (Token::Match(tok, ""asm|goto|break|continue""))
            return Progress::Break;
        if (Token::Match(tok, ""return|throw"")) {
            forwardRecursive(tok, std::move(info), f);
            return Progress::Break;
            // Evaluate RHS of assignment before LHS
        }
        if (const Token* assignTok = assignExpr(tok)) {
            if (forwardRecursive(assignTok->astOperand2(), info, f) == Progress::Break)
                return Progress::Break;
            if (forwardRecursive(assignTok->astOperand1(), info, f) == Progress::Break)
                return Progress::Break;
            tok = nextAfterAstRightmostLeaf(assignTok);
            if (!tok)
                return Progress::Break;
      ...",1,1,lib/pathanalysis.cpp,"PathAnalysis.forwardRange<const>:PathAnalysis.Progress(Token*,Token*,PathAnalysis.Info,std.function<PathAnalysis.Progress(constInfo&)>&)",<empty>,,false,84,173,forwardRange,,,1,"PathAnalysis.Progress(Token*,Token*,PathAnalysis.Info,std.function<PathAnalysis.Progress(constInfo&)>&)"
111669152834,METHOD,lib/pathanalysis.cpp:<global>,TYPE_DECL,"void PathAnalysis::forward(const std::function<Progress(const Info&)>& f) const
{
    const Scope * endScope = findOuterScope(start->scope());
    if (!endScope)
        return;
    const Token * endToken = endScope->bodyEnd;
    Info info{start, ErrorPath{}, true};
    forwardRange(start, endToken, std::move(info), f);
}",1,1,lib/pathanalysis.cpp,PathAnalysis.forward<const>:void(std.function<Progress(constInfo&)>&),<empty>,,false,175,183,forward,,,1,void(std.function<Progress(constInfo&)>&)
111669152835,METHOD,<empty>,<empty>,"[&](const PathAnalysis::Info& i) {
        return (i.tok == dest);
    }",72,5,lib/pathanalysis.cpp,lib/pathanalysis.cpp:<global>.reaches.<lambda>2:bool(PathAnalysis.Info&),<empty>,,false,187,189,<lambda>2,,,1,bool(PathAnalysis.Info&)
111669152836,METHOD,lib/pathanalysis.cpp:<global>,TYPE_DECL,"bool reaches(const Token * start, const Token * dest, const Library& library, ErrorPath* errorPath)
{
    PathAnalysis::Info info = PathAnalysis{start, library}.forwardFind([&](const PathAnalysis::Info& i) {
        return (i.tok == dest);
    });
    if (!info.tok)
        return false;
    if (errorPath)
        errorPath->insert(errorPath->end(), info.errorPath.cbegin(), info.errorPath.cend());
    return true;
}",1,1,lib/pathanalysis.cpp,"reaches:bool(Token*,Token*,Library&,ErrorPath*)",<empty>,,false,185,195,reaches,,,1,"bool(Token*,Token*,Library&,ErrorPath*)"
111669152837,METHOD,lib/pathanalysis.h:<global>,TYPE_DECL,<global>,1,1,lib/pathanalysis.h,lib/pathanalysis.h:<global>,<empty>,,false,1,82,<global>,,,1,
111669152838,METHOD,lib/pathmatch.cpp:<global>,TYPE_DECL,"PathMatch::PathMatch(std::vector<std::string> paths, bool caseSensitive)
    : mPaths(std::move(paths)), mCaseSensitive(caseSensitive)
{
    for (std::string& p : mPaths)
    {
        p = Path::fromNativeSeparators(p);
        if (!mCaseSensitive)
            strTolower(p);
    }
    // TODO: also make lowercase?
    mWorkingDirectory.push_back(Path::fromNativeSeparators(Path::getCurrentPath()));
}",1,1,lib/pathmatch.cpp,"PathMatch.PathMatch:ANY(std.vector<std.string>,bool)",<empty>,,false,27,38,PathMatch,,,1,"PathMatch.PathMatch:ANY(std.vector<std.string>,bool)(std.vector<std.string>,bool)"
111669152839,METHOD,lib/pathmatch.cpp:<global>,TYPE_DECL,<global>,1,1,lib/pathmatch.cpp,lib/pathmatch.cpp:<global>,<empty>,,false,1,92,<global>,,,1,
111669152840,METHOD,lib/pathmatch.cpp:<global>,TYPE_DECL,"bool PathMatch::match(const std::string &path) const
{
    if (path.empty())
        return false;

    std::string findpath = Path::fromNativeSeparators(path);
    if (!mCaseSensitive)
        strTolower(findpath);
    std::string finddir;
    if (!endsWith(findpath,'/'))
        finddir = removeFilename(findpath);
    else
        finddir = findpath;

    const bool is_absolute = Path::isAbsolute(path);

    // TODO: align the match logic with ImportProject::ignorePaths()
    for (auto i = mPaths.cbegin(); i != mPaths.cend(); ++i) {
        const std::string pathToMatch((!is_absolute && Path::isAbsolute(*i)) ? Path::getRelativePath(*i, mWorkingDirectory) : *i);

        // Filtering directory name
        if (endsWith(pathToMatch,'/')) {
            if (pathToMatch.length() > finddir.length())
                continue;
            // Match relative paths starting with mask
            // -isrc matches src/foo.cpp
            if (finddir.compare(0, pathToMatch.size(), pathToMatch) ...",1,1,lib/pathmatch.cpp,PathMatch.match<const>:bool(std.string&),<empty>,,false,40,86,match,,,1,bool(std.string&)
111669152841,METHOD,lib/pathmatch.cpp:<global>,TYPE_DECL,"std::string PathMatch::removeFilename(const std::string &path)
{
    const std::size_t ind = path.find_last_of('/');
    return path.substr(0, ind + 1);
}",1,1,lib/pathmatch.cpp,PathMatch.removeFilename:string(std.string&),<empty>,,false,88,92,removeFilename,,,1,string(std.string&)
111669152842,METHOD,lib/pathmatch.h:<global>,TYPE_DECL,<global>,1,1,lib/pathmatch.h,lib/pathmatch.h:<global>,<empty>,,false,1,74,<global>,,,1,
111669152843,METHOD,lib/platform.cpp:<global>,TYPE_DECL,"Platform::Platform()
{
    set(Type::Native);
}",1,1,lib/platform.cpp,Platform.Platform:ANY(),<empty>,,false,30,33,Platform,,,1,ANY()
111669152844,METHOD,lib/platform.cpp:<global>,TYPE_DECL,<global>,1,1,lib/platform.cpp,lib/platform.cpp:<global>,<empty>,,false,1,448,<global>,,,1,
111669152845,METHOD,lib/platform.cpp:<global>,TYPE_DECL,"bool Platform::set(Type t)
{
    switch (t) {
    case Type::Unspecified: // unknown type sizes (sizes etc are set but are not known)
    case Type::Native: // same as system this code was compile on
        type = t;
        sizeof_bool = sizeof(bool);
        sizeof_short = sizeof(short);
        sizeof_int = sizeof(int);
        sizeof_long = sizeof(long);
        sizeof_long_long = sizeof(long long);
        sizeof_float = sizeof(float);
        sizeof_double = sizeof(double);
        sizeof_long_double = sizeof(long double);
        sizeof_wchar_t = sizeof(wchar_t);
        sizeof_size_t = sizeof(std::size_t);
        sizeof_pointer = sizeof(void *);
        if (type == Type::Unspecified) {
            defaultSign = '\\0';
        } else {
            defaultSign = std::numeric_limits<char>::is_signed ? 's' : 'u';
        }
        char_bit = 8;
        short_bit = char_bit * sizeof_short;
        int_bit = char_bit * sizeof_int;
        long_bit = char_bit * sizeof_long;
      ...",1,1,lib/platform.cpp,Platform.set:bool(Platform.Type),<empty>,,false,36,151,set,,,1,bool(Platform.Type)
111669152846,METHOD,lib/platform.cpp:<global>,TYPE_DECL,"bool Platform::set(const std::string& platformstr, std::string& errstr, const std::vector<std::string>& paths, bool debug)
{
    if (platformstr == ""win32A"")
        set(Type::Win32A);
    else if (platformstr == ""win32W"")
        set(Type::Win32W);
    else if (platformstr == ""win64"")
        set(Type::Win64);
    else if (platformstr == ""unix32"")
        set(Type::Unix32);
    else if (platformstr == ""unix64"")
        set(Type::Unix64);
    else if (platformstr == ""native"")
        set(Type::Native);
    else if (platformstr == ""unspecified"")
        set(Type::Unspecified);
    else if (paths.empty()) {
        errstr = ""unrecognized platform: '"" + platformstr + ""' (no lookup)."";
        return false;
    }
    else {
        bool found = false;
        for (const std::string& path : paths) {
            if (debug)
                std::cout << ""looking for platform '"" + platformstr + ""' in '"" + path + ""'"" << std::endl;
            if (loadFromFile(path.c_str(), platformstr, debug)...",1,1,lib/platform.cpp,"Platform.set:bool(std.string&,std.string&,std.vector<std.string>&,bool)",<empty>,,false,153,190,set,,,1,"bool(std.string&,std.string&,std.vector<std.string>&,bool)"
111669152847,METHOD,lib/platform.cpp:<global>,TYPE_DECL,"bool Platform::loadFromFile(const char exename[], const std::string &filename, bool debug)
{
    // TODO: only append .xml if missing
    // TODO: use native separators
    std::vector<std::string> filenames{
        filename,
        filename + "".xml"",
        ""platforms/"" + filename,
        ""platforms/"" + filename + "".xml""
    };
    if (exename && (std::string::npos != Path::fromNativeSeparators(exename).find('/'))) {
        filenames.push_back(Path::getPathFromFilename(Path::fromNativeSeparators(exename)) + filename);
        filenames.push_back(Path::getPathFromFilename(Path::fromNativeSeparators(exename)) + ""platforms/"" + filename);
        filenames.push_back(Path::getPathFromFilename(Path::fromNativeSeparators(exename)) + ""platforms/"" + filename + "".xml"");
    }
#ifdef FILESDIR
    std::string filesdir = FILESDIR;
    if (!filesdir.empty() && filesdir[filesdir.size()-1] != '/')
        filesdir += '/';
    filenames.push_back(filesdir + (""platforms/"" + filename));
    file...",1,1,lib/platform.cpp,"Platform.loadFromFile:bool(char[],std.string&,bool)",<empty>,,false,192,234,loadFromFile,,,1,"bool(char[],std.string&,bool)"
111669152848,METHOD,lib/platform.cpp:<global>,TYPE_DECL,"static unsigned int xmlTextAsUInt(const tinyxml2::XMLElement* node, bool& error)
{
    unsigned int retval = 0;
    if (node->QueryUnsignedText(&retval) != tinyxml2::XML_SUCCESS)
        error = true;
    return retval;
}",1,1,lib/platform.cpp,"xmlTextAsUInt:unsigned int(tinyxml2.XMLElement*,bool&)",<empty>,,false,236,242,xmlTextAsUInt,,,1,"unsigned int(tinyxml2.XMLElement*,bool&)"
111669152849,METHOD,lib/platform.cpp:<global>,TYPE_DECL,"bool Platform::loadFromXmlDocument(const tinyxml2::XMLDocument *doc)
{
    const tinyxml2::XMLElement * const rootnode = doc->FirstChildElement();

    if (!rootnode || std::strcmp(rootnode->Name(), ""platform"") != 0)
        return false;

    bool error = false;
    for (const tinyxml2::XMLElement *node = rootnode->FirstChildElement(); node; node = node->NextSiblingElement()) {
        const char* name = node->Name();
        if (std::strcmp(name, ""default-sign"") == 0) {
            const char* str = node->GetText();
            if (str)
                defaultSign = *str;
            else
                error = true;
        } else if (std::strcmp(name, ""char_bit"") == 0)
            char_bit = xmlTextAsUInt(node, error);
        else if (std::strcmp(name, ""sizeof"") == 0) {
            for (const tinyxml2::XMLElement *sz = node->FirstChildElement(); sz; sz = sz->NextSiblingElement()) {
                const char* szname = sz->Name();
                if (std::strcmp(szname, ""short""...",1,1,lib/platform.cpp,Platform.loadFromXmlDocument:bool(tinyxml2.XMLDocument*),<empty>,,false,244,298,loadFromXmlDocument,,,1,bool(tinyxml2.XMLDocument*)
111669152850,METHOD,lib/platform.cpp:<global>,TYPE_DECL,"std::string Platform::getLimitsDefines(bool c99) const
{
    std::string s;

    // climits / limits.h
    s += ""CHAR_BIT="";
    s += std::to_string(char_bit);
    s += "";SCHAR_MIN="";
    s += std::to_string(min_value(char_bit));
    s += "";SCHAR_MAX="";
    s += std::to_string(max_value(char_bit));
    s += "";UCHAR_MAX="";
    s += std::to_string(max_value(char_bit+1));
    s += "";CHAR_MIN="";
    if (defaultSign == 'u')
        s += std::to_string(min_value(char_bit));
    else
        s += std::to_string(0);
    s += "";CHAR_MAX="";
    if (defaultSign == 'u')
        s += std::to_string(max_value(char_bit+1));
    else
        s += std::to_string(max_value(char_bit));
    // TODO
    //s += "";MB_LEN_MAX="";
    s += "";SHRT_MIN="";
    s += std::to_string(min_value(short_bit));
    s += "";SHRT_MAX="";
    s += std::to_string(max_value(short_bit));
    s += "";USHRT_MAX="";
    s += std::to_string(max_value(short_bit+1));
    s += "";INT_MIN="";
    s += ""(-"" + std::to_string(max_value(int_bi...",1,1,lib/platform.cpp,Platform.getLimitsDefines<const>:string(bool),<empty>,,false,300,438,getLimitsDefines,,,1,string(bool)
111669152851,METHOD,lib/platform.cpp:<global>,TYPE_DECL,"std::string Platform::getLimitsDefines(Standards::cstd_t cstd) const
{
    return getLimitsDefines(cstd >= Standards::cstd_t::C99);
}",1,1,lib/platform.cpp,Platform.getLimitsDefines<const>:string(Standards.cstd_t),<empty>,,false,440,443,getLimitsDefines,,,1,string(Standards.cstd_t)
111669152852,METHOD,lib/platform.cpp:<global>,TYPE_DECL,"std::string Platform::getLimitsDefines(Standards::cppstd_t cppstd) const
{
    return getLimitsDefines(cppstd >= Standards::cppstd_t::CPP11);
}",1,1,lib/platform.cpp,Platform.getLimitsDefines<const>:string(Standards.cppstd_t),<empty>,,false,445,448,getLimitsDefines,,,1,string(Standards.cppstd_t)
111669152853,METHOD,lib/platform.h:<global>,TYPE_DECL,<global>,1,1,lib/platform.h,lib/platform.h:<global>,<empty>,,false,1,207,<global>,,,1,
111669152854,METHOD,lib/precompiled.h:<global>,TYPE_DECL,<global>,1,27,lib/precompiled.h,lib/precompiled.h:<global>,<empty>,,false,1,32,<global>,,,1,
111669152855,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"static bool sameline(const simplecpp::Token *tok1, const simplecpp::Token *tok2)
{
    return tok1 && tok2 && tok1->location.sameline(tok2->location);
}",1,1,lib/preprocessor.cpp,"sameline<duplicate>0:bool(simplecpp.Token*,simplecpp.Token*)",<empty>,,false,41,44,sameline,,,1,"bool(simplecpp.Token*,simplecpp.Token*)"
111669152856,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,<global>,1,1,lib/preprocessor.cpp,lib/preprocessor.cpp:<global>,<empty>,,false,1,1093,<global>,,,1,
111669152857,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"Directive::Directive(const simplecpp::Location & _loc, std::string _str) :
    file(_loc.file()),
    linenr(_loc.line),
    str(std::move(_str))
{}",1,2,lib/preprocessor.cpp,"Directive.Directive:ANY(simplecpp.Location&,std.string)",<empty>,,false,46,50,Directive,,,1,"Directive.Directive:ANY(simplecpp.Location&,std.string)(simplecpp.Location&,std.string)"
111669152858,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"Directive::Directive(std::string _file, const int _linenr, std::string _str) :
    file(std::move(_file)),
    linenr(_linenr),
    str(std::move(_str))
{}",1,2,lib/preprocessor.cpp,"Directive.Directive:ANY(std.string,int,std.string)",<empty>,,false,52,56,Directive,,,1,"Directive.Directive:ANY(std.string,int,std.string)(std.string,int,std.string)"
111669152859,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"Directive::DirectiveToken::DirectiveToken(const simplecpp::Token & _tok) :
    line(_tok.location.line),
    column(_tok.location.col),
    tokStr(_tok.str())
{}",1,2,lib/preprocessor.cpp,Directive.DirectiveToken.DirectiveToken:ANY(simplecpp.Token&),<empty>,,false,58,62,DirectiveToken,,,1,Directive.DirectiveToken.DirectiveToken:ANY(simplecpp.Token&)(simplecpp.Token&)
111669152860,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"Preprocessor::Preprocessor(const Settings& settings, ErrorLogger &errorLogger) : mSettings(settings), mErrorLogger(errorLogger)
{}",1,2,lib/preprocessor.cpp,"Preprocessor.Preprocessor:ANY(Settings&,ErrorLogger&)",<empty>,,false,66,67,Preprocessor,,,1,"Preprocessor.Preprocessor:ANY(Settings&,ErrorLogger&)(Settings&,ErrorLogger&)"
111669152861,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"Preprocessor::~Preprocessor()
{
    for (const std::pair<const std::string, simplecpp::TokenList*>& tokenList : mTokenLists)
        delete tokenList.second;
}",1,1,lib/preprocessor.cpp,Preprocessor.~Preprocessor:ANY(),<empty>,,false,69,73,~Preprocessor,,,1,ANY()
111669152862,METHOD,BadInlineSuppression,TYPE_DECL,"BadInlineSuppression(std::string file, const int line, std::string msg) : file(std::move(file)), line(line), errmsg(std::move(msg)) {}",9,142,lib/preprocessor.cpp,"BadInlineSuppression.BadInlineSuppression:ANY(std.string,int,std.string)",<empty>,,false,77,77,BadInlineSuppression,,,1,"BadInlineSuppression.BadInlineSuppression:ANY(std.string,int,std.string)(std.string,int,std.string)"
111669152863,METHOD,<empty>,<empty>,"[](const SuppressionList::Suppression& s) {
            return !s.errorId.empty();
        }",106,9,lib/preprocessor.cpp,lib/preprocessor.cpp:<global>.parseInlineSuppressionCommentToken.<lambda>0:bool(SuppressionList.Suppression&),<empty>,,false,146,148,<lambda>0,,,1,bool(SuppressionList.Suppression&)
111669152864,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"static bool parseInlineSuppressionCommentToken(const simplecpp::Token *tok, std::list<SuppressionList::Suppression> &inlineSuppressions, std::list<BadInlineSuppression> &bad)
{
    const std::string cppchecksuppress(""cppcheck-suppress"");

    const std::string &comment = tok->str();
    if (comment.size() < cppchecksuppress.size())
        return false;
    const std::string::size_type pos1 = comment.find_first_not_of(""/* \\t"");
    if (pos1 == std::string::npos)
        return false;
    if (pos1 + cppchecksuppress.size() >= comment.size())
        return false;
    if (comment.substr(pos1, cppchecksuppress.size()) != cppchecksuppress)
        return false;

    // check if it has a prefix
    const std::string::size_type posEndComment = comment.find_first_of("" ["", pos1+cppchecksuppress.size());

    // skip spaces after ""cppcheck-suppress"" and its possible prefix
    const std::string::size_type pos2 = comment.find_first_not_of(' ', posEndComment);
    if (pos2 == std::string::npos...",1,1,lib/preprocessor.cpp,"parseInlineSuppressionCommentToken:bool(simplecpp.Token*,std.list<SuppressionList.Suppression>&,std.list<BadInlineSuppression>&)",<empty>,,false,84,168,parseInlineSuppressionCommentToken,,,1,"bool(simplecpp.Token*,std.list<SuppressionList.Suppression>&,std.list<BadInlineSuppression>&)"
111669152865,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"static std::string getRelativeFilename(const simplecpp::Token* tok, const Settings &settings) {
    if (!tok)
        return """";
    std::string relativeFilename(tok->location.file());
    if (settings.relativePaths) {
        for (const std::string & basePath : settings.basePaths) {
            const std::string bp = basePath + ""/"";
            if (relativeFilename.compare(0,bp.size(),bp)==0) {
                relativeFilename = relativeFilename.substr(bp.size());
            }
        }
    }
    return Path::simplifyPath(std::move(relativeFilename));
}",1,1,lib/preprocessor.cpp,"getRelativeFilename:string(simplecpp.Token*,Settings&)",<empty>,,false,170,183,getRelativeFilename,,,1,"string(simplecpp.Token*,Settings&)"
111669152866,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"static void addInlineSuppressions(const simplecpp::TokenList &tokens, const Settings &settings, SuppressionList &suppressions, std::list<BadInlineSuppression> &bad)
{
    std::list<SuppressionList::Suppression> inlineSuppressionsBlockBegin;

    bool onlyComments = true;

    for (const simplecpp::Token *tok = tokens.cfront(); tok; tok = tok->next) {
        if (!tok->comment) {
            onlyComments = false;
            continue;
        }

        std::list<SuppressionList::Suppression> inlineSuppressions;
        if (!parseInlineSuppressionCommentToken(tok, inlineSuppressions, bad))
            continue;

        if (!sameline(tok->previous, tok)) {
            // find code after comment..
            if (tok->next) {
                tok = tok->next;

                while (tok->comment) {
                    parseInlineSuppressionCommentToken(tok, inlineSuppressions, bad);
                    if (tok->next) {
                        tok = tok->next;
                    } else...",1,1,lib/preprocessor.cpp,"addInlineSuppressions:void(simplecpp.TokenList&,Settings&,SuppressionList&,std.list<BadInlineSuppression>&)",<empty>,,false,185,301,addInlineSuppressions,,,1,"void(simplecpp.TokenList&,Settings&,SuppressionList&,std.list<BadInlineSuppression>&)"
111669152867,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"void Preprocessor::inlineSuppressions(const simplecpp::TokenList &tokens, SuppressionList &suppressions)
{
    if (!mSettings.inlineSuppressions)
        return;
    std::list<BadInlineSuppression> err;
    ::addInlineSuppressions(tokens, mSettings, suppressions, err);
    for (auto it = mTokenLists.cbegin(); it != mTokenLists.cend(); ++it) {
        if (it->second)
            ::addInlineSuppressions(*it->second, mSettings, suppressions, err);
    }
    for (const BadInlineSuppression &bad : err) {
        error(bad.file, bad.line, bad.errmsg);
    }
}",1,1,lib/preprocessor.cpp,"Preprocessor.inlineSuppressions:void(simplecpp.TokenList&,SuppressionList&)",<empty>,,false,303,316,inlineSuppressions,,,1,"void(simplecpp.TokenList&,SuppressionList&)"
111669152868,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"std::vector<RemarkComment> Preprocessor::getRemarkComments(const simplecpp::TokenList &tokens) const
{
    std::vector<RemarkComment> ret;
    addRemarkComments(tokens, ret);
    for (auto it = mTokenLists.cbegin(); it != mTokenLists.cend(); ++it) {
        if (it->second)
            addRemarkComments(*it->second, ret);
    }
    return ret;
}",1,1,lib/preprocessor.cpp,Preprocessor.getRemarkComments<const>:vector<RemarkComment>(simplecpp.TokenList&),<empty>,,false,318,327,getRemarkComments,,,1,vector<RemarkComment>(simplecpp.TokenList&)
111669152869,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"std::list<Directive> Preprocessor::createDirectives(const simplecpp::TokenList &tokens) const
{
    // directive list..
    std::list<Directive> directives;

    std::vector<const simplecpp::TokenList *> list;
    list.reserve(1U + mTokenLists.size());
    list.push_back(&tokens);
    for (auto it = mTokenLists.cbegin(); it != mTokenLists.cend(); ++it) {
        list.push_back(it->second);
    }

    for (const simplecpp::TokenList *tokenList : list) {
        for (const simplecpp::Token *tok = tokenList->cfront(); tok; tok = tok->next) {
            if ((tok->op != '#') || (tok->previous && tok->previous->location.line == tok->location.line))
                continue;
            if (tok->next && tok->next->str() == ""endfile"")
                continue;
            Directive directive(tok->location, """");
            for (const simplecpp::Token *tok2 = tok; tok2 && tok2->location.line == directive.linenr; tok2 = tok2->next) {
                if (tok2->comment)
                    con...",1,1,lib/preprocessor.cpp,Preprocessor.createDirectives<const>:list<Directive>(simplecpp.TokenList&),<empty>,,false,329,365,createDirectives,,,1,list<Directive>(simplecpp.TokenList&)
111669152870,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"static std::string readcondition(const simplecpp::Token *iftok, const std::set<std::string> &defined, const std::set<std::string> &undefined)
{
    const simplecpp::Token *cond = iftok->next;
    if (!sameline(iftok,cond))
        return """";

    const simplecpp::Token *next1 = cond->next;
    const simplecpp::Token *next2 = next1 ? next1->next : nullptr;
    const simplecpp::Token *next3 = next2 ? next2->next : nullptr;

    unsigned int len = 1;
    if (sameline(iftok,next1))
        len = 2;
    if (sameline(iftok,next2))
        len = 3;
    if (sameline(iftok,next3))
        len = 4;

    if (len == 1 && cond->str() == ""0"")
        return ""0"";

    if (len == 1 && cond->name) {
        if (defined.find(cond->str()) == defined.end())
            return cond->str();
    }

    if (len == 2 && cond->op == '!' && next1->name) {
        if (defined.find(next1->str()) == defined.end())
            return next1->str() + ""=0"";
    }

    if (len == 3 && cond->op == '(' && next1->name &...",1,1,lib/preprocessor.cpp,"readcondition:string(simplecpp.Token*,std.set<std.string>&,std.set<std.string>&)",<empty>,,false,367,435,readcondition,,,1,"string(simplecpp.Token*,std.set<std.string>&,std.set<std.string>&)"
111669152871,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"static bool hasDefine(const std::string &userDefines, const std::string &cfg)
{
    if (cfg.empty()) {
        return false;
    }

    std::string::size_type pos = 0;
    while (pos < userDefines.size()) {
        pos = userDefines.find(cfg, pos);
        if (pos == std::string::npos)
            break;
        const std::string::size_type pos2 = pos + cfg.size();
        if ((pos == 0 || userDefines[pos-1U] == ';') && (pos2 == userDefines.size() || userDefines[pos2] == '='))
            return true;
        pos = pos2;
    }
    return false;
}",1,1,lib/preprocessor.cpp,"hasDefine:bool(std.string&,std.string&)",<empty>,,false,437,454,hasDefine,,,1,"bool(std.string&,std.string&)"
111669152872,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"static std::string cfg(const std::vector<std::string> &configs, const std::string &userDefines)
{
    std::set<std::string> configs2(configs.cbegin(), configs.cend());
    std::string ret;
    for (const std::string &c : configs2) {
        if (c.empty())
            continue;
        if (c == ""0"")
            return """";
        if (hasDefine(userDefines, c))
            continue;
        if (!ret.empty())
            ret += ';';
        ret += c;
    }
    return ret;
}",1,1,lib/preprocessor.cpp,"cfg:string(std.vector<std.string>&,std.string&)",<empty>,,false,456,472,cfg,,,1,"string(std.vector<std.string>&,std.string&)"
111669152873,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"static bool isUndefined(const std::string &cfg, const std::set<std::string> &undefined)
{
    for (std::string::size_type pos1 = 0U; pos1 < cfg.size();) {
        const std::string::size_type pos2 = cfg.find(';',pos1);
        const std::string def = (pos2 == std::string::npos) ? cfg.substr(pos1) : cfg.substr(pos1, pos2 - pos1);

        const std::string::size_type eq = def.find('=');
        if (eq == std::string::npos && undefined.find(def) != undefined.end())
            return true;
        if (eq != std::string::npos && undefined.find(def.substr(0,eq)) != undefined.end() && def.substr(eq) != ""=0"")
            return true;

        pos1 = (pos2 == std::string::npos) ? pos2 : pos2 + 1U;
    }
    return false;
}",1,1,lib/preprocessor.cpp,"isUndefined:bool(std.string&,std.set<std.string>&)",<empty>,,false,474,489,isUndefined,,,1,"bool(std.string&,std.set<std.string>&)"
111669152874,METHOD,<empty>,<empty>,"[&](const std::string &cfg) {
        return hasDefine(userDefines, cfg);
    }",24,5,lib/preprocessor.cpp,lib/preprocessor.cpp:<global>.getConfigsElseIsFalse.<lambda>1:bool(std.string&),<empty>,,false,494,496,<lambda>1,,,1,bool(std.string&)
111669152875,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"static bool getConfigsElseIsFalse(const std::vector<std::string> &configs_if, const std::string &userDefines)
{
    return std::any_of(configs_if.cbegin(), configs_if.cend(),
                       [&](const std::string &cfg) {
        return hasDefine(userDefines, cfg);
    });
}",1,1,lib/preprocessor.cpp,"getConfigsElseIsFalse:bool(std.vector<std.string>&,std.string&)",<empty>,,false,491,497,getConfigsElseIsFalse,,,1,"bool(std.vector<std.string>&,std.string&)"
111669152876,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"static const simplecpp::Token *gotoEndIf(const simplecpp::Token *cmdtok)
{
    int level = 0;
    while (nullptr != (cmdtok = cmdtok->next)) {
        if (cmdtok->op == '#' && !sameline(cmdtok->previous,cmdtok) && sameline(cmdtok, cmdtok->next)) {
            if (startsWith(cmdtok->next->str(),""if""))
                ++level;
            else if (cmdtok->next->str() == ""endif"") {
                --level;
                if (level < 0)
                    return cmdtok;
            }
        }
    }
    return nullptr;
}",1,1,lib/preprocessor.cpp,gotoEndIf:ANY(simplecpp.Token*),<empty>,,false,499,514,gotoEndIf,,,1,ANY(simplecpp.Token*)
111669152877,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"static void getConfigs(const simplecpp::TokenList &tokens, std::set<std::string> &defined, const std::string &userDefines, const std::set<std::string> &undefined, std::set<std::string> &ret)
{
    std::vector<std::string> configs_if;
    std::vector<std::string> configs_ifndef;
    std::string elseError;

    for (const simplecpp::Token *tok = tokens.cfront(); tok; tok = tok->next) {
        if (tok->op != '#' || sameline(tok->previous, tok))
            continue;
        const simplecpp::Token *cmdtok = tok->next;
        if (!sameline(tok, cmdtok))
            continue;
        if (cmdtok->str() == ""ifdef"" || cmdtok->str() == ""ifndef"" || cmdtok->str() == ""if"") {
            std::string config;
            if (cmdtok->str() == ""ifdef"" || cmdtok->str() == ""ifndef"") {
                const simplecpp::Token *expr1 = cmdtok->next;
                if (sameline(tok,expr1) && expr1->name && !sameline(tok,expr1->next))
                    config = expr1->str();
                if (defined....",1,1,lib/preprocessor.cpp,"getConfigs:void(simplecpp.TokenList&,std.set<std.string>&,std.string&,std.set<std.string>&,std.set<std.string>&)",<empty>,,false,516,656,getConfigs,,,1,"void(simplecpp.TokenList&,std.set<std.string>&,std.string&,std.set<std.string>&,std.set<std.string>&)"
111669152878,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"std::set<std::string> Preprocessor::getConfigs(const simplecpp::TokenList &tokens) const
{
    std::set<std::string> ret = { """" };
    if (!tokens.cfront())
        return ret;

    std::set<std::string> defined = { ""__cplusplus"" };

    ::getConfigs(tokens, defined, mSettings.userDefines, mSettings.userUndefs, ret);

    for (auto it = mTokenLists.cbegin(); it != mTokenLists.cend(); ++it) {
        if (!mSettings.configurationExcluded(it->first))
            ::getConfigs(*(it->second), defined, mSettings.userDefines, mSettings.userUndefs, ret);
    }

    return ret;
}",1,1,lib/preprocessor.cpp,Preprocessor.getConfigs<const>:set<std.string>(simplecpp.TokenList&),<empty>,,false,659,675,getConfigs,,,1,set<std::string>(simplecpp.TokenList&)
111669152879,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"static void splitcfg(const std::string &cfg, std::list<std::string> &defines, const std::string &defaultValue)
{
    for (std::string::size_type defineStartPos = 0U; defineStartPos < cfg.size();) {
        const std::string::size_type defineEndPos = cfg.find(';', defineStartPos);
        std::string def = (defineEndPos == std::string::npos) ? cfg.substr(defineStartPos) : cfg.substr(defineStartPos, defineEndPos - defineStartPos);
        if (!defaultValue.empty() && def.find('=') == std::string::npos)
            def += '=' + defaultValue;
        defines.push_back(std::move(def));
        if (defineEndPos == std::string::npos)
            break;
        defineStartPos = defineEndPos + 1U;
    }
}",1,1,lib/preprocessor.cpp,"splitcfg:void(std.string&,std.list<std.string>&,std.string&)",<empty>,,false,677,689,splitcfg,,,1,"void(std.string&,std.list<std.string>&,std.string&)"
111669152880,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"static simplecpp::DUI createDUI(const Settings &mSettings, const std::string &cfg, const std::string &filename)
{
    // TODO: make it possible to specify platform-dependent sizes
    simplecpp::DUI dui;

    splitcfg(mSettings.userDefines, dui.defines, ""1"");
    if (!cfg.empty())
        splitcfg(cfg, dui.defines, """");

    for (const std::string &def : mSettings.library.defines()) {
        const std::string::size_type pos = def.find_first_of("" ("");
        if (pos == std::string::npos) {
            dui.defines.push_back(def);
            continue;
        }
        std::string s = def;
        if (s[pos] == ' ') {
            s[pos] = '=';
        } else {
            s[s.find(')')+1] = '=';
        }
        dui.defines.push_back(std::move(s));
    }

    dui.undefined = mSettings.userUndefs; // -U
    dui.includePaths = mSettings.includePaths; // -I
    dui.includes = mSettings.userIncludes;  // --include
    // TODO: use mSettings.standards.stdValue instead
    // TODO: error...",1,1,lib/preprocessor.cpp,"createDUI:DUI(Settings&,std.string&,std.string&)",<empty>,,false,691,731,createDUI,,,1,"DUI(Settings&,std.string&,std.string&)"
111669152881,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"bool Preprocessor::hasErrors(const simplecpp::Output &output)
{
    switch (output.type) {
    case simplecpp::Output::ERROR:
    case simplecpp::Output::INCLUDE_NESTED_TOO_DEEPLY:
    case simplecpp::Output::SYNTAX_ERROR:
    case simplecpp::Output::UNHANDLED_CHAR_ERROR:
    case simplecpp::Output::EXPLICIT_INCLUDE_NOT_FOUND:
    case simplecpp::Output::FILE_NOT_FOUND:
    case simplecpp::Output::DUI_ERROR:
        return true;
    case simplecpp::Output::WARNING:
    case simplecpp::Output::MISSING_HEADER:
    case simplecpp::Output::PORTABILITY_BACKSLASH:
        break;
    }
    return false;
}",1,1,lib/preprocessor.cpp,Preprocessor.hasErrors:bool(simplecpp.Output&),<empty>,,false,733,750,hasErrors,,,1,bool(simplecpp.Output&)
111669152882,METHOD,<empty>,<empty>,"[](const simplecpp::Output &output) {
        return hasErrors(output);
    }",74,5,lib/preprocessor.cpp,lib/preprocessor.cpp:<global>.Preprocessor.hasErrors.<lambda>2:bool(simplecpp.Output&),<empty>,,false,754,756,<lambda>2,,,1,bool(simplecpp.Output&)
111669152883,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"bool Preprocessor::hasErrors(const simplecpp::OutputList &outputList)
{
    const auto it = std::find_if(outputList.cbegin(), outputList.cend(), [](const simplecpp::Output &output) {
        return hasErrors(output);
    });
    return it != outputList.cend();
}",1,1,lib/preprocessor.cpp,Preprocessor.hasErrors:bool(simplecpp.OutputList&),<empty>,,false,752,758,hasErrors,,,1,bool(simplecpp.OutputList&)
111669152884,METHOD,<empty>,<empty>,"[](const simplecpp::Output &output){
            return hasErrors(output);
        }",78,9,lib/preprocessor.cpp,lib/preprocessor.cpp:<global>.Preprocessor.handleErrors.<lambda>3:bool(simplecpp.Output&),<empty>,,false,765,767,<lambda>3,,,1,bool(simplecpp.Output&)
111669152885,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"void Preprocessor::handleErrors(const simplecpp::OutputList& outputList, bool throwError)
{
    const bool showerror = (!mSettings.userDefines.empty() && !mSettings.force);
    reportOutput(outputList, showerror);
    if (throwError) {
        const auto it = std::find_if(outputList.cbegin(), outputList.cend(), [](const simplecpp::Output &output){
            return hasErrors(output);
        });
        if (it != outputList.cend()) {
            throw *it;
        }
    }
}",1,1,lib/preprocessor.cpp,"Preprocessor.handleErrors:void(simplecpp.OutputList&,bool)",<empty>,,false,760,772,handleErrors,,,1,"void(simplecpp.OutputList&,bool)"
111669152886,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"bool Preprocessor::loadFiles(const simplecpp::TokenList &rawtokens, std::vector<std::string> &files)
{
    const simplecpp::DUI dui = createDUI(mSettings, """", files[0]);

    simplecpp::OutputList outputList;
    mTokenLists = simplecpp::load(rawtokens, files, dui, &outputList);
    handleErrors(outputList, false);
    return !hasErrors(outputList);
}",1,1,lib/preprocessor.cpp,"Preprocessor.loadFiles:bool(simplecpp.TokenList&,std.vector<std.string>&)",<empty>,,false,774,782,loadFiles,,,1,"bool(simplecpp.TokenList&,std.vector<std.string>&)"
111669152887,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"void Preprocessor::removeComments(simplecpp::TokenList &tokens)
{
    tokens.removeComments();
    for (std::pair<const std::string, simplecpp::TokenList*>& tokenList : mTokenLists) {
        if (tokenList.second)
            tokenList.second->removeComments();
    }
}",1,1,lib/preprocessor.cpp,Preprocessor.removeComments:void(simplecpp.TokenList&),<empty>,,false,784,791,removeComments,,,1,void(simplecpp.TokenList&)
111669152888,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"void Preprocessor::setPlatformInfo(simplecpp::TokenList &tokens, const Settings& settings)
{
    tokens.sizeOfType[""bool""]          = settings.platform.sizeof_bool;
    tokens.sizeOfType[""short""]         = settings.platform.sizeof_short;
    tokens.sizeOfType[""int""]           = settings.platform.sizeof_int;
    tokens.sizeOfType[""long""]          = settings.platform.sizeof_long;
    tokens.sizeOfType[""long long""]     = settings.platform.sizeof_long_long;
    tokens.sizeOfType[""float""]         = settings.platform.sizeof_float;
    tokens.sizeOfType[""double""]        = settings.platform.sizeof_double;
    tokens.sizeOfType[""long double""]   = settings.platform.sizeof_long_double;
    tokens.sizeOfType[""bool *""]        = settings.platform.sizeof_pointer;
    tokens.sizeOfType[""short *""]       = settings.platform.sizeof_pointer;
    tokens.sizeOfType[""int *""]         = settings.platform.sizeof_pointer;
    tokens.sizeOfType[""long *""]        = settings.platform.sizeof_pointer;
    tokens.si...",1,1,lib/preprocessor.cpp,"Preprocessor.setPlatformInfo:void(simplecpp.TokenList&,Settings&)",<empty>,,false,793,811,setPlatformInfo,,,1,"void(simplecpp.TokenList&,Settings&)"
111669152889,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"simplecpp::TokenList Preprocessor::preprocess(const simplecpp::TokenList &tokens1, const std::string &cfg, std::vector<std::string> &files, bool throwError)
{
    const simplecpp::DUI dui = createDUI(mSettings, cfg, files[0]);

    simplecpp::OutputList outputList;
    std::list<simplecpp::MacroUsage> macroUsage;
    std::list<simplecpp::IfCond> ifCond;
    simplecpp::TokenList tokens2(files);
    simplecpp::preprocess(tokens2, tokens1, files, mTokenLists, dui, &outputList, &macroUsage, &ifCond);
    mMacroUsage = std::move(macroUsage);
    mIfCond = std::move(ifCond);

    handleErrors(outputList, throwError);

    tokens2.removeComments();

    return tokens2;
}",1,1,lib/preprocessor.cpp,"Preprocessor.preprocess:TokenList(simplecpp.TokenList&,std.string&,std.vector<std.string>&,bool)",<empty>,,false,813,830,preprocess,,,1,"TokenList(simplecpp.TokenList&,std.string&,std.vector<std.string>&,bool)"
111669152890,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"std::string Preprocessor::getcode(const simplecpp::TokenList &tokens1, const std::string &cfg, std::vector<std::string> &files, const bool writeLocations)
{
    simplecpp::TokenList tokens2 = preprocess(tokens1, cfg, files, false);
    unsigned int prevfile = 0;
    unsigned int line = 1;
    std::ostringstream ret;
    for (const simplecpp::Token *tok = tokens2.cfront(); tok; tok = tok->next) {
        if (writeLocations && tok->location.fileIndex != prevfile) {
            ret << ""\\n#line "" << tok->location.line << "" \\"""" << tok->location.file() << ""\\""\\n"";
            prevfile = tok->location.fileIndex;
            line = tok->location.line;
        }

        if (tok->previous && line >= tok->location.line) // #7912
            ret << ' ';
        while (tok->location.line > line) {
            ret << '\\n';
            line++;
        }
        if (!tok->macro.empty())
            ret << Preprocessor::macroChar;
        ret << tok->str();
    }

    return ret.str();
}",1,1,lib/preprocessor.cpp,"Preprocessor.getcode:string(simplecpp.TokenList&,std.string&,std.vector<std.string>&,bool)",<empty>,,false,832,857,getcode,,,1,"string(simplecpp.TokenList&,std.string&,std.vector<std.string>&,bool)"
111669152891,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"void Preprocessor::reportOutput(const simplecpp::OutputList &outputList, bool showerror)
{
    for (const simplecpp::Output &out : outputList) {
        switch (out.type) {
        case simplecpp::Output::ERROR:
            if (!startsWith(out.msg,""#error"") || showerror)
                error(out.location.file(), out.location.line, out.msg);
            break;
        case simplecpp::Output::WARNING:
        case simplecpp::Output::PORTABILITY_BACKSLASH:
            break;
        case simplecpp::Output::MISSING_HEADER: {
            const std::string::size_type pos1 = out.msg.find_first_of(""<\\"""");
            const std::string::size_type pos2 = out.msg.find_first_of("">\\"""", pos1 + 1U);
            if (pos1 < pos2 && pos2 != std::string::npos)
                missingInclude(out.location.file(), out.location.line, out.msg.substr(pos1+1, pos2-pos1-1), out.msg[pos1] == '\\""' ? UserHeader : SystemHeader);
        }
        break;
        case simplecpp::Output::INCLUDE_NESTED_TOO_DEEPLY:
...",1,1,lib/preprocessor.cpp,"Preprocessor.reportOutput:void(simplecpp.OutputList&,bool)",<empty>,,false,859,889,reportOutput,,,1,"void(simplecpp.OutputList&,bool)"
111669152892,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"void Preprocessor::error(const std::string &filename, unsigned int linenr, const std::string &msg)
{
    std::list<ErrorMessage::FileLocation> locationList;
    if (!filename.empty()) {
        std::string file = Path::fromNativeSeparators(filename);
        if (mSettings.relativePaths)
            file = Path::getRelativePath(file, mSettings.basePaths);

        locationList.emplace_back(file, linenr, 0);
    }
    mErrorLogger.reportErr(ErrorMessage(std::move(locationList),
                                        mFile0,
                                        Severity::error,
                                        msg,
                                        ""preprocessorErrorDirective"",
                                        Certainty::normal));
}",1,1,lib/preprocessor.cpp,"Preprocessor.error:void(std.string&,unsigned int,std.string&)",<empty>,,false,891,907,error,,,1,"void(std.string&,unsigned int,std.string&)"
111669152893,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"void Preprocessor::missingInclude(const std::string &filename, unsigned int linenr, const std::string &header, HeaderTypes headerType)
{
    if (!mSettings.checks.isEnabled(Checks::missingInclude))
        return;

    std::list<ErrorMessage::FileLocation> locationList;
    if (!filename.empty()) {
        locationList.emplace_back(filename, linenr, 0);
    }
    ErrorMessage errmsg(std::move(locationList), mFile0, Severity::information,
                        (headerType==SystemHeader) ?
                        ""Include file: <"" + header + ""> not found. Please note: Cppcheck does not need standard library headers to get proper results."" :
                        ""Include file: \\"""" + header + ""\\"" not found."",
                        (headerType==SystemHeader) ? ""missingIncludeSystem"" : ""missingInclude"",
                        Certainty::normal);
    mErrorLogger.reportErr(errmsg);
}",1,1,lib/preprocessor.cpp,"Preprocessor.missingInclude:void(std.string&,unsigned int,std.string&,Preprocessor.HeaderTypes)",<empty>,,false,910,926,missingInclude,,,1,"void(std.string&,unsigned int,std.string&,Preprocessor.HeaderTypes)"
111669152894,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"void Preprocessor::getErrorMessages(ErrorLogger &errorLogger, const Settings &settings)
{
    Preprocessor preprocessor(settings, errorLogger);
    preprocessor.missingInclude("""", 1, """", UserHeader);
    preprocessor.missingInclude("""", 1, """", SystemHeader);
    preprocessor.error("""", 1, ""#error message"");   // #error ..
}",1,1,lib/preprocessor.cpp,"Preprocessor.getErrorMessages:void(ErrorLogger&,Settings&)",<empty>,,false,928,934,getErrorMessages,,,1,"void(ErrorLogger&,Settings&)"
111669152895,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"void Preprocessor::dump(std::ostream &out) const
{
    // Create a xml dump.

    if (!mMacroUsage.empty()) {
        out << ""  <macro-usage>"" << std::endl;
        for (const simplecpp::MacroUsage &macroUsage: mMacroUsage) {
            out << ""    <macro""
                << "" name=\\"""" << macroUsage.macroName << ""\\""""
                << "" file=\\"""" << ErrorLogger::toxml(macroUsage.macroLocation.file()) << ""\\""""
                << "" line=\\"""" << macroUsage.macroLocation.line << ""\\""""
                << "" column=\\"""" << macroUsage.macroLocation.col << ""\\""""
                << "" usefile=\\"""" << ErrorLogger::toxml(macroUsage.useLocation.file()) << ""\\""""
                << "" useline=\\"""" << macroUsage.useLocation.line << ""\\""""
                << "" usecolumn=\\"""" << macroUsage.useLocation.col << ""\\""""
                << "" is-known-value=\\"""" << bool_to_string(macroUsage.macroValueKnown) << ""\\""""
                << ""/>"" << std::endl;
        }
        out << ""  </macro-usage>"" << std::endl;
    }

    i...",1,1,lib/preprocessor.cpp,Preprocessor.dump<const>:void(std.ostream&),<empty>,,false,936,970,dump,,,1,void(std.ostream&)
111669152896,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"std::size_t Preprocessor::calculateHash(const simplecpp::TokenList &tokens1, const std::string &toolinfo) const
{
    std::string hashData = toolinfo;
    for (const simplecpp::Token *tok = tokens1.cfront(); tok; tok = tok->next) {
        if (!tok->comment) {
            hashData += tok->str();
            hashData += static_cast<char>(tok->location.line);
            hashData += static_cast<char>(tok->location.col);
        }
    }
    for (auto it = mTokenLists.cbegin(); it != mTokenLists.cend(); ++it) {
        for (const simplecpp::Token *tok = it->second->cfront(); tok; tok = tok->next) {
            if (!tok->comment) {
                hashData += tok->str();
                hashData += static_cast<char>(tok->location.line);
                hashData += static_cast<char>(tok->location.col);
            }
        }
    }
    return (std::hash<std::string>{})(hashData);
}",1,1,lib/preprocessor.cpp,"Preprocessor.calculateHash<const>:size_t(simplecpp.TokenList&,std.string&)",<empty>,,false,972,992,calculateHash,,,1,"size_t(simplecpp.TokenList&,std.string&)"
111669152897,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"void Preprocessor::simplifyPragmaAsm(simplecpp::TokenList &tokenList) const
{
    Preprocessor::simplifyPragmaAsmPrivate(tokenList);
    for (const std::pair<const std::string, simplecpp::TokenList*>& list : mTokenLists) {
        Preprocessor::simplifyPragmaAsmPrivate(*list.second);
    }
}",1,1,lib/preprocessor.cpp,Preprocessor.simplifyPragmaAsm<const>:void(simplecpp.TokenList&),<empty>,,false,994,1000,simplifyPragmaAsm,,,1,void(simplecpp.TokenList&)
111669152898,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"void Preprocessor::simplifyPragmaAsmPrivate(simplecpp::TokenList &tokenList)
{
    // assembler code..
    for (simplecpp::Token *tok = tokenList.front(); tok; tok = tok->next) {
        if (tok->op != '#')
            continue;
        if (sameline(tok, tok->previousSkipComments()))
            continue;

        const simplecpp::Token * const tok2 = tok->nextSkipComments();
        if (!tok2 || !sameline(tok, tok2) || tok2->str() != ""pragma"")
            continue;

        const simplecpp::Token * const tok3 = tok2->nextSkipComments();
        if (!tok3 || !sameline(tok, tok3) || tok3->str() != ""asm"")
            continue;

        const simplecpp::Token *endasm = tok3;
        while ((endasm = endasm->next) != nullptr) {
            if (endasm->op != '#' || sameline(endasm,endasm->previousSkipComments()))
                continue;
            const simplecpp::Token * const endasm2 = endasm->nextSkipComments();
            if (!endasm2 || !sameline(endasm, endasm2) || endasm2->str...",1,1,lib/preprocessor.cpp,Preprocessor.simplifyPragmaAsmPrivate:void(simplecpp.TokenList&),<empty>,,false,1002,1042,simplifyPragmaAsmPrivate,,,1,void(simplecpp.TokenList&)
111669152899,METHOD,lib/preprocessor.cpp:<global>,TYPE_DECL,"void Preprocessor::addRemarkComments(const simplecpp::TokenList &tokens, std::vector<RemarkComment> &remarkComments) const
{
    for (const simplecpp::Token *tok = tokens.cfront(); tok; tok = tok->next) {
        if (!tok->comment)
            continue;

        const std::string& comment = tok->str();

        // is it a remark comment?
        const std::string::size_type pos1 = comment.find_first_not_of(""/* \\t"");
        if (pos1 == std::string::npos)
            continue;
        const std::string::size_type pos2 = comment.find_first_of("": \\t"", pos1);
        if (pos2 != pos1 + 6 || comment.compare(pos1, 6, ""REMARK"") != 0)
            continue;
        const std::string::size_type pos3 = comment.find_first_not_of("": \\t"", pos2);
        if (pos3 == std::string::npos)
            continue;
        if (comment.compare(0,2,""/*"") == 0 && pos3 + 2 >= tok->str().size())
            continue;

        const std::string::size_type pos4 = (comment.compare(0,2,""/*"") == 0) ? comment.size()-...",1,1,lib/preprocessor.cpp,"Preprocessor.addRemarkComments<const>:void(simplecpp.TokenList&,std.vector<RemarkComment>&)",<empty>,,false,1045,1093,addRemarkComments,,,1,"void(simplecpp.TokenList&,std.vector<RemarkComment>&)"
111669152900,METHOD,lib/preprocessor.h:<global>,TYPE_DECL,<global>,1,1,lib/preprocessor.h,lib/preprocessor.h:<global>,<empty>,,false,1,191,<global>,,,1,
111669152901,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"ExprIdToken::ExprIdToken(const Token* tok) : tok(tok), exprid(tok ? tok->exprId() : 0) {}",1,89,lib/programmemory.cpp,ExprIdToken.ExprIdToken:ANY(Token*),<empty>,,false,48,48,ExprIdToken,,,1,ExprIdToken.ExprIdToken:ANY(Token*)(Token*)
111669152902,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,<global>,1,1,lib/programmemory.cpp,lib/programmemory.cpp:<global>,<empty>,,false,1,1837,<global>,,,1,
111669152903,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"int ExprIdToken::getExpressionId() const {
    return tok ? tok->exprId() : exprid;
}",8,1,lib/programmemory.cpp,ExprIdToken.getExpressionId<const>:int(),<empty>,,false,50,52,getExpressionId,,,1,int()
111669152904,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"std::size_t ExprIdToken::Hash::operator()(ExprIdToken etok) const
{
    return std::hash<nonneg int>()(etok.getExpressionId());
}",1,21,lib/programmemory.cpp,ExprIdToken.Hash.()<const>:size_t(ExprIdToken),<empty>,,false,54,57,(),,,1,size_t(ExprIdToken)
111669152905,METHOD,<empty>,<empty>,"[&](const Token* tok) -> std::vector<MathLib::bigint> {
        if (const ValueFlow::Value* v = tok->getKnownValue(ValueFlow::Value::ValueType::INT))
            return {v->intvalue};
        MathLib::bigint result = 0;
        if (getIntValue(tok->exprId(), result))
            return {result};
        return {};
    }",9,5,lib/programmemory.cpp,lib/programmemory.cpp:<global>.ProgramMemory.setValue.<lambda>0:vector<MathLib::bigint>(Token*),<empty>,,false,66,73,<lambda>0,,,1,vector<MathLib::bigint>(Token*)
111669152906,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"void ProgramMemory::setValue(const Token* expr, const ValueFlow::Value& value) {
    copyOnWrite();

    (*mValues)[expr] = value;
    ValueFlow::Value subvalue = value;
    const Token* subexpr = solveExprValue(
        expr,
        [&](const Token* tok) -> std::vector<MathLib::bigint> {
        if (const ValueFlow::Value* v = tok->getKnownValue(ValueFlow::Value::ValueType::INT))
            return {v->intvalue};
        MathLib::bigint result = 0;
        if (getIntValue(tok->exprId(), result))
            return {result};
        return {};
    },
        subvalue);
    if (subexpr)
        (*mValues)[subexpr] = std::move(subvalue);
}",1,1,lib/programmemory.cpp,"ProgramMemory.setValue:void(Token*,ValueFlow.Value&)",<empty>,,false,59,77,setValue,,,1,"void(Token*,ValueFlow.Value&)"
111669152907,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"const ValueFlow::Value* ProgramMemory::getValue(nonneg int exprid, bool impossible) const
{
    const auto it = utils::as_const(*mValues).find(exprid);
    const bool found = it != mValues->cend() && (impossible || !it->second.isImpossible());
    if (found)
        return &it->second;
    return nullptr;
}",1,48,lib/programmemory.cpp,"ProgramMemory.getValue<const>:ValueFlow.Value*(int,bool)",<empty>,,false,78,85,getValue,,,1,"ValueFlow.Value*(int,bool)"
111669152908,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"bool ProgramMemory::getIntValue(nonneg int exprid, MathLib::bigint& result) const
{
    const ValueFlow::Value* value = getValue(exprid);
    if (value && value->isIntValue()) {
        result = value->intvalue;
        return true;
    }
    return false;
}",1,32,lib/programmemory.cpp,"ProgramMemory.getIntValue<const>:bool(int,MathLib.bigint&)",<empty>,,false,88,96,getIntValue,,,1,"bool(int,MathLib.bigint&)"
111669152909,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"void ProgramMemory::setIntValue(const Token* expr, MathLib::bigint value, bool impossible)
{
    ValueFlow::Value v(value);
    if (impossible)
        v.setImpossible();
    setValue(expr, v);
}",1,1,lib/programmemory.cpp,"ProgramMemory.setIntValue:void(Token*,MathLib.bigint,bool)",<empty>,,false,98,104,setIntValue,,,1,"void(Token*,MathLib.bigint,bool)"
111669152910,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"bool ProgramMemory::getTokValue(nonneg int exprid, const Token*& result) const
{
    const ValueFlow::Value* value = getValue(exprid);
    if (value && value->isTokValue()) {
        result = value->tokvalue;
        return true;
    }
    return false;
}",1,32,lib/programmemory.cpp,"ProgramMemory.getTokValue<const>:bool(int,Token*&)",<empty>,,false,106,114,getTokValue,,,1,"bool(int,Token*&)"
111669152911,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"bool ProgramMemory::getContainerSizeValue(nonneg int exprid, MathLib::bigint& result) const
{
    const ValueFlow::Value* value = getValue(exprid);
    if (value && value->isContainerSizeValue()) {
        result = value->intvalue;
        return true;
    }
    return false;
}",1,42,lib/programmemory.cpp,"ProgramMemory.getContainerSizeValue<const>:bool(int,MathLib.bigint&)",<empty>,,false,117,125,getContainerSizeValue,,,1,"bool(int,MathLib.bigint&)"
111669152912,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"bool ProgramMemory::getContainerEmptyValue(nonneg int exprid, MathLib::bigint& result) const
{
    const ValueFlow::Value* value = getValue(exprid, true);
    if (value && value->isContainerSizeValue()) {
        if (value->isImpossible() && value->intvalue == 0) {
            result = false;
            return true;
        }
        if (!value->isImpossible()) {
            result = (value->intvalue == 0);
            return true;
        }
    }
    return false;
}",1,43,lib/programmemory.cpp,"ProgramMemory.getContainerEmptyValue<const>:bool(int,MathLib.bigint&)",<empty>,,false,126,140,getContainerEmptyValue,,,1,"bool(int,MathLib.bigint&)"
111669152913,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"void ProgramMemory::setContainerSizeValue(const Token* expr, MathLib::bigint value, bool isEqual)
{
    ValueFlow::Value v(value);
    v.valueType = ValueFlow::Value::ValueType::CONTAINER_SIZE;
    if (!isEqual)
        v.valueKind = ValueFlow::Value::ValueKind::Impossible;
    setValue(expr, v);
}",1,1,lib/programmemory.cpp,"ProgramMemory.setContainerSizeValue:void(Token*,MathLib.bigint,bool)",<empty>,,false,142,149,setContainerSizeValue,,,1,"void(Token*,MathLib.bigint,bool)"
111669152914,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"void ProgramMemory::setUnknown(const Token* expr) {
    copyOnWrite();

    (*mValues)[expr].valueType = ValueFlow::Value::ValueType::UNINIT;
}",1,1,lib/programmemory.cpp,ProgramMemory.setUnknown:void(Token*),<empty>,,false,151,155,setUnknown,,,1,void(Token*)
111669152915,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"bool ProgramMemory::hasValue(nonneg int exprid)
{
    return mValues->find(exprid) != mValues->end();
}",1,29,lib/programmemory.cpp,ProgramMemory.hasValue:bool(int),<empty>,,false,157,160,hasValue,,,1,bool(int)
111669152916,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"const ValueFlow::Value& ProgramMemory::at(nonneg int exprid) const {
    return mValues->at(exprid);
}",1,42,lib/programmemory.cpp,ProgramMemory.at<const>:ValueFlow.Value&(int),<empty>,,false,162,164,at,,,1,ValueFlow.Value&(int)
111669152917,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"ValueFlow::Value& ProgramMemory::at(nonneg int exprid) {
    copyOnWrite();

    return mValues->at(exprid);
}",1,36,lib/programmemory.cpp,ProgramMemory.at:ValueFlow.Value&(int),<empty>,,false,165,169,at,,,1,ValueFlow.Value&(int)
111669152918,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"void ProgramMemory::erase_if(const std::function<bool(const ExprIdToken&)>& pred)
{
    if (mValues->empty())
        return;

    // TODO: how to delay until we actuallly modify?
    copyOnWrite();

    for (auto it = mValues->begin(); it != mValues->end();) {
        if (pred(it->first))
            it = mValues->erase(it);
        else
            ++it;
    }
}",1,1,lib/programmemory.cpp,ProgramMemory.erase_if:void(std.function<bool(constExprIdToken&)>&),<empty>,,false,171,185,erase_if,,,1,void(std.function<bool(constExprIdToken&)>&)
111669152919,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"void ProgramMemory::swap(ProgramMemory &pm) NOEXCEPT
{
    mValues.swap(pm.mValues);
}",1,44,lib/programmemory.cpp,ProgramMemory.swap:void(ProgramMemory&),<empty>,,false,187,190,swap,,,1,void(ProgramMemory&)
111669152920,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"void ProgramMemory::clear()
{
    if (mValues->empty())
        return;

    copyOnWrite();

    mValues->clear();
}",1,1,lib/programmemory.cpp,ProgramMemory.clear:void(),<empty>,,false,192,200,clear,,,1,void()
111669152921,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"bool ProgramMemory::empty() const
{
    return mValues->empty();
}",1,1,lib/programmemory.cpp,ProgramMemory.empty<const>:bool(),<empty>,,false,202,205,empty,,,1,bool()
111669152922,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"void ProgramMemory::replace(ProgramMemory pm)
{
    if (pm.empty())
        return;

    copyOnWrite();

    for (auto&& p : (*pm.mValues)) {
        (*mValues)[p.first] = std::move(p.second);
    }
}",1,1,lib/programmemory.cpp,ProgramMemory.replace:void(ProgramMemory),<empty>,,false,208,218,replace,,,1,void(ProgramMemory)
111669152923,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"void ProgramMemory::copyOnWrite()
{
    if (mValues.use_count() == 1)
        return;

    mValues = std::make_shared<Map>(*mValues);
}",1,1,lib/programmemory.cpp,ProgramMemory.copyOnWrite:void(),<empty>,,false,220,226,copyOnWrite,,,1,void()
111669152924,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static bool evaluateCondition(MathLib::bigint r, const Token* condition, ProgramMemory& pm, const Settings& settings)
{
    if (!condition)
        return false;
    MathLib::bigint result = 0;
    bool error = false;
    execute(condition, pm, &result, &error, settings);
    return !error && result == r;
}",1,1,lib/programmemory.cpp,"evaluateCondition:bool(MathLib.bigint,Token*,ProgramMemory&,Settings&)",<empty>,,false,230,238,evaluateCondition,,,1,"bool(MathLib.bigint,Token*,ProgramMemory&,Settings&)"
111669152925,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"bool conditionIsFalse(const Token* condition, ProgramMemory pm, const Settings& settings)
{
    return evaluateCondition(0, condition, pm, settings);
}",1,1,lib/programmemory.cpp,"conditionIsFalse:bool(Token*,ProgramMemory,Settings&)",<empty>,,false,240,243,conditionIsFalse,,,1,"bool(Token*,ProgramMemory,Settings&)"
111669152926,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"bool conditionIsTrue(const Token* condition, ProgramMemory pm, const Settings& settings)
{
    return evaluateCondition(1, condition, pm, settings);
}",1,1,lib/programmemory.cpp,"conditionIsTrue:bool(Token*,ProgramMemory,Settings&)",<empty>,,false,245,248,conditionIsTrue,,,1,"bool(Token*,ProgramMemory,Settings&)"
111669152927,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static bool frontIs(const std::vector<MathLib::bigint>& v, bool i)
{
    if (v.empty())
        return false;
    if (v.front())
        return i;
    return !i;
}",1,1,lib/programmemory.cpp,"frontIs:bool(std.vector<MathLib.bigint>&,bool)",<empty>,,false,250,257,frontIs,,,1,"bool(std.vector<MathLib.bigint>&,bool)"
111669152928,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static bool isTrue(const ValueFlow::Value& v)
{
    if (v.isUninitValue())
        return false;
    if (v.isImpossible())
        return v.intvalue == 0;
    return v.intvalue != 0;
}",1,1,lib/programmemory.cpp,isTrue:bool(ValueFlow.Value&),<empty>,,false,259,266,isTrue,,,1,bool(ValueFlow.Value&)
111669152929,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static bool isFalse(const ValueFlow::Value& v)
{
    if (v.isUninitValue())
        return false;
    if (v.isImpossible())
        return false;
    return v.intvalue == 0;
}",1,1,lib/programmemory.cpp,isFalse:bool(ValueFlow.Value&),<empty>,,false,268,275,isFalse,,,1,bool(ValueFlow.Value&)
111669152930,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static bool isTrueOrFalse(const ValueFlow::Value& v, bool b)
{
    if (b)
        return isTrue(v);
    return isFalse(v);
}",1,1,lib/programmemory.cpp,"isTrueOrFalse:bool(ValueFlow.Value&,bool)",<empty>,,false,277,282,isTrueOrFalse,,,1,"bool(ValueFlow.Value&,bool)"
111669152931,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static bool isBasicForLoop(const Token* tok)
{
    if (!tok)
        return false;
    if (Token::simpleMatch(tok, ""}""))
        return isBasicForLoop(tok->link());
    if (!Token::simpleMatch(tok->previous(), "") {""))
        return false;
    const Token* start = tok->linkAt(-1);
    if (!start)
        return false;
    if (!Token::simpleMatch(start->previous(), ""for (""))
        return false;
    if (!Token::simpleMatch(start->astOperand2(), "";""))
        return false;
    return true;
}",1,1,lib/programmemory.cpp,isBasicForLoop:bool(Token*),<empty>,,false,285,301,isBasicForLoop,,,1,bool(Token*)
111669152932,METHOD,<empty>,<empty>,"[&](const Token* t) -> std::vector<MathLib::bigint> {
        if (!t)
            return std::vector<MathLib::bigint>{};
        if (const ValueFlow::Value* v = t->getKnownValue(ValueFlow::Value::ValueType::INT))
            return {v->intvalue};
        MathLib::bigint result = 0;
        bool error = false;
        execute(t, pm, &result, &error, settings);
        if (!error)
            return {result};
        return std::vector<MathLib::bigint>{};
    }",17,5,lib/programmemory.cpp,lib/programmemory.cpp:<global>.programMemoryParseCondition.<lambda>1:vector<MathLib::bigint>(Token*),<empty>,,false,305,316,<lambda>1,,,1,vector<MathLib::bigint>(Token*)
111669152933,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static void programMemoryParseCondition(ProgramMemory& pm, const Token* tok, const Token* endTok, const Settings& settings, bool then)
{
    auto eval = [&](const Token* t) -> std::vector<MathLib::bigint> {
        if (!t)
            return std::vector<MathLib::bigint>{};
        if (const ValueFlow::Value* v = t->getKnownValue(ValueFlow::Value::ValueType::INT))
            return {v->intvalue};
        MathLib::bigint result = 0;
        bool error = false;
        execute(t, pm, &result, &error, settings);
        if (!error)
            return {result};
        return std::vector<MathLib::bigint>{};
    };
    if (Token::Match(tok, ""==|>=|<=|<|>|!="")) {
        ValueFlow::Value truevalue;
        ValueFlow::Value falsevalue;
        const Token* vartok = parseCompareInt(tok, truevalue, falsevalue, eval);
        if (!vartok)
            return;
        if (vartok->exprId() == 0)
            return;
        if (!truevalue.isIntValue())
            return;
        if (endTok && fi...",1,1,lib/programmemory.cpp,"programMemoryParseCondition:void(ProgramMemory&,Token*,Token*,Settings&,bool)",<empty>,,false,303,362,programMemoryParseCondition,,,1,"void(ProgramMemory&,Token*,Token*,Settings&,bool)"
111669152934,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static void fillProgramMemoryFromConditions(ProgramMemory& pm, const Scope* scope, const Token* endTok, const Settings& settings)
{
    if (!scope)
        return;
    if (!scope->isLocal())
        return;
    assert(scope != scope->nestedIn);
    fillProgramMemoryFromConditions(pm, scope->nestedIn, endTok, settings);
    if (scope->type == ScopeType::eIf || scope->type == ScopeType::eWhile || scope->type == ScopeType::eElse || scope->type == ScopeType::eFor) {
        const Token* condTok = getCondTokFromEnd(scope->bodyEnd);
        if (!condTok)
            return;
        MathLib::bigint result = 0;
        bool error = false;
        execute(condTok, pm, &result, &error, settings);
        if (error)
            programMemoryParseCondition(pm, condTok, endTok, settings, scope->type != ScopeType::eElse);
    }
}",1,1,lib/programmemory.cpp,"fillProgramMemoryFromConditions:void(ProgramMemory&,Scope*,Token*,Settings&)",<empty>,,false,364,382,fillProgramMemoryFromConditions,,,1,"void(ProgramMemory&,Scope*,Token*,Settings&)"
111669152935,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static void fillProgramMemoryFromConditions(ProgramMemory& pm, const Token* tok, const Settings& settings)
{
    fillProgramMemoryFromConditions(pm, tok->scope(), tok, settings);
}",1,1,lib/programmemory.cpp,"fillProgramMemoryFromConditions:void(ProgramMemory&,Token*,Settings&)",<empty>,,false,384,387,fillProgramMemoryFromConditions,,,1,"void(ProgramMemory&,Token*,Settings&)"
111669152936,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static void fillProgramMemoryFromAssignments(ProgramMemory& pm, const Token* tok, const Settings& settings, const ProgramMemory& state, const ProgramMemory::Map& vars)
{
    int indentlevel = 0;
    for (const Token *tok2 = tok; tok2; tok2 = tok2->previous()) {
        if ((Token::simpleMatch(tok2, ""="") || Token::Match(tok2->previous(), ""%var% (|{"")) && tok2->astOperand1() &&
            tok2->astOperand2()) {
            bool setvar = false;
            const Token* vartok = tok2->astOperand1();
            for (const auto& p:vars) {
                if (p.first != vartok->exprId())
                    continue;
                if (vartok == tok)
                    continue;
                pm.setValue(vartok, p.second);
                setvar = true;
            }
            if (!setvar) {
                if (!pm.hasValue(vartok->exprId())) {
                    const Token* valuetok = tok2->astOperand2();
                    pm.setValue(vartok, execute(valuetok, pm, settings));
...",1,1,lib/programmemory.cpp,"fillProgramMemoryFromAssignments:void(ProgramMemory&,Token*,Settings&,ProgramMemory&,ProgramMemory.Map&)",<empty>,,false,389,447,fillProgramMemoryFromAssignments,,,1,"void(ProgramMemory&,Token*,Settings&,ProgramMemory&,ProgramMemory.Map&)"
111669152937,METHOD,<empty>,<empty>,"[&](const ExprIdToken& e) {
        return isVariableChanged(origin, tok, e.getExpressionId(), false, settings);
    }",17,5,lib/programmemory.cpp,lib/programmemory.cpp:<global>.removeModifiedVars.<lambda>2:bool(ExprIdToken&),<empty>,,false,451,453,<lambda>2,,,1,bool(ExprIdToken&)
111669152938,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static void removeModifiedVars(ProgramMemory& pm, const Token* tok, const Token* origin, const Settings& settings)
{
    pm.erase_if([&](const ExprIdToken& e) {
        return isVariableChanged(origin, tok, e.getExpressionId(), false, settings);
    });
}",1,1,lib/programmemory.cpp,"removeModifiedVars:void(ProgramMemory&,Token*,Token*,Settings&)",<empty>,,false,449,454,removeModifiedVars,,,1,"void(ProgramMemory&,Token*,Token*,Settings&)"
111669152939,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static ProgramMemory getInitialProgramState(const Token* tok,
                                            const Token* origin,
                                            const Settings& settings,
                                            const ProgramMemory::Map& vars = ProgramMemory::Map {})
{
    ProgramMemory pm;
    if (origin) {
        fillProgramMemoryFromConditions(pm, origin, settings);
        const ProgramMemory state = pm;
        fillProgramMemoryFromAssignments(pm, tok, settings, state, vars);
        removeModifiedVars(pm, tok, origin, settings);
    }
    return pm;
}",1,1,lib/programmemory.cpp,"getInitialProgramState:ProgramMemory(Token*,Token*,Settings&,ProgramMemory.Map&)",<empty>,,false,456,469,getInitialProgramState,,,1,"ProgramMemory(Token*,Token*,Settings&,ProgramMemory.Map&)"
111669152940,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"ProgramMemoryState::ProgramMemoryState(const Settings& s) : settings(s)
{}",1,2,lib/programmemory.cpp,ProgramMemoryState.ProgramMemoryState:ANY(Settings&),<empty>,,false,471,472,ProgramMemoryState,,,1,ProgramMemoryState.ProgramMemoryState:ANY(Settings&)(Settings&)
111669152941,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"void ProgramMemoryState::replace(ProgramMemory pm, const Token* origin)
{
    if (origin)
        for (const auto& p : pm)
            origins[p.first.getExpressionId()] = origin;
    state.replace(std::move(pm));
}",1,1,lib/programmemory.cpp,"ProgramMemoryState.replace:void(ProgramMemory,Token*)",<empty>,,false,474,480,replace,,,1,"void(ProgramMemory,Token*)"
111669152942,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static void addVars(ProgramMemory& pm, const ProgramMemory::Map& vars)
{
    for (const auto& p:vars) {
        const ValueFlow::Value &value = p.second;
        pm.setValue(p.first.tok, value);
    }
}",1,1,lib/programmemory.cpp,"addVars:void(ProgramMemory&,ProgramMemory.Map&)",<empty>,,false,482,488,addVars,,,1,"void(ProgramMemory&,ProgramMemory.Map&)"
111669152943,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"void ProgramMemoryState::addState(const Token* tok, const ProgramMemory::Map& vars)
{
    ProgramMemory pm = state;
    addVars(pm, vars);
    fillProgramMemoryFromConditions(pm, tok, settings);
    ProgramMemory local = pm;
    fillProgramMemoryFromAssignments(pm, tok, settings, local, vars);
    addVars(pm, vars);
    replace(std::move(pm), tok);
}",1,1,lib/programmemory.cpp,"ProgramMemoryState.addState:void(Token*,ProgramMemory.Map&)",<empty>,,false,490,499,addState,,,1,"void(Token*,ProgramMemory.Map&)"
111669152944,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"void ProgramMemoryState::assume(const Token* tok, bool b, bool isEmpty)
{
    ProgramMemory pm = state;
    if (isEmpty)
        pm.setContainerSizeValue(tok, 0, b);
    else
        programMemoryParseCondition(pm, tok, nullptr, settings, b);
    const Token* origin = tok;
    const Token* top = tok->astTop();
    if (Token::Match(top->previous(), ""for|while|if ("") && !Token::simpleMatch(tok->astParent(), ""?"")) {
        origin = top->link()->next();
        if (!b && origin->link()) {
            origin = origin->link();
        }
    }
    replace(std::move(pm), origin);
}",1,1,lib/programmemory.cpp,"ProgramMemoryState.assume:void(Token*,bool,bool)",<empty>,,false,501,517,assume,,,1,"void(Token*,bool,bool)"
111669152945,METHOD,<empty>,<empty>,"[&](const Token* cond) -> std::vector<MathLib::bigint> {
        ProgramMemory pm2 = pm;
        auto result = execute(cond, pm2, settings);
        if (isTrue(result))
            return {1};
        if (isFalse(result))
            return {0};
        return {};
    }",17,5,lib/programmemory.cpp,lib/programmemory.cpp:<global>.ProgramMemoryState.removeModifiedVars.<lambda>3:vector<MathLib::bigint>(Token*),<empty>,,false,522,530,<lambda>3,,,1,vector<MathLib::bigint>(Token*)
111669152946,METHOD,<empty>,<empty>,"[&](const ExprIdToken& e) {
        const Token* start = origins[e.getExpressionId()];
        const Token* expr = e.tok;
        if (!expr || findExpressionChangedSkipDeadCode(expr, start, tok, settings, eval)) {
            origins.erase(e.getExpressionId());
            return true;
        }
        return false;
    }",20,5,lib/programmemory.cpp,lib/programmemory.cpp:<global>.ProgramMemoryState.removeModifiedVars.<lambda>4:bool(ExprIdToken&),<empty>,,false,531,539,<lambda>4,,,1,bool(ExprIdToken&)
111669152947,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"void ProgramMemoryState::removeModifiedVars(const Token* tok)
{
    const ProgramMemory& pm = state;
    auto eval = [&](const Token* cond) -> std::vector<MathLib::bigint> {
        ProgramMemory pm2 = pm;
        auto result = execute(cond, pm2, settings);
        if (isTrue(result))
            return {1};
        if (isFalse(result))
            return {0};
        return {};
    };
    state.erase_if([&](const ExprIdToken& e) {
        const Token* start = origins[e.getExpressionId()];
        const Token* expr = e.tok;
        if (!expr || findExpressionChangedSkipDeadCode(expr, start, tok, settings, eval)) {
            origins.erase(e.getExpressionId());
            return true;
        }
        return false;
    });
}",1,1,lib/programmemory.cpp,ProgramMemoryState.removeModifiedVars:void(Token*),<empty>,,false,519,540,removeModifiedVars,,,1,void(Token*)
111669152948,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"ProgramMemory ProgramMemoryState::get(const Token* tok, const Token* ctx, const ProgramMemory::Map& vars) const
{
    ProgramMemoryState local = *this;
    if (ctx)
        local.addState(ctx, vars);
    const Token* start = previousBeforeAstLeftmostLeaf(tok);
    if (!start)
        start = tok;

    if (!ctx || precedes(start, ctx)) {
        local.removeModifiedVars(start);
        local.addState(start, vars);
    } else {
        local.removeModifiedVars(ctx);
    }
    return local.state;
}",1,1,lib/programmemory.cpp,"ProgramMemoryState.get<const>:ProgramMemory(Token*,Token*,ProgramMemory.Map&)",<empty>,,false,542,558,get,,,1,"ProgramMemory(Token*,Token*,ProgramMemory.Map&)"
111669152949,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"ProgramMemory getProgramMemory(const Token* tok, const Token* expr, const ValueFlow::Value& value, const Settings& settings)
{
    ProgramMemory programMemory;
    programMemory.replace(getInitialProgramState(tok, value.tokvalue, settings));
    programMemory.replace(getInitialProgramState(tok, value.condition, settings));
    fillProgramMemoryFromConditions(programMemory, tok, settings);
    programMemory.setValue(expr, value);
    const ProgramMemory state = programMemory;
    fillProgramMemoryFromAssignments(programMemory, tok, settings, state, {{expr, value}});
    return programMemory;
}",1,1,lib/programmemory.cpp,"getProgramMemory:ProgramMemory(Token*,Token*,ValueFlow.Value&,Settings&)",<empty>,,false,560,570,getProgramMemory,,,1,"ProgramMemory(Token*,Token*,ValueFlow.Value&,Settings&)"
111669152950,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static bool isNumericValue(const ValueFlow::Value& value) {
    return value.isIntValue() || value.isFloatValue();
}",1,1,lib/programmemory.cpp,isNumericValue:bool(ValueFlow.Value&),<empty>,,false,572,574,isNumericValue,,,1,bool(ValueFlow.Value&)
111669152951,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static double asFloat(const ValueFlow::Value& value)
{
    return value.isFloatValue() ? value.floatValue : static_cast<double>(value.intvalue);
}",1,1,lib/programmemory.cpp,asFloat:double(ValueFlow.Value&),<empty>,,false,576,579,asFloat,,,1,double(ValueFlow.Value&)
111669152952,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static MathLib::bigint asInt(const ValueFlow::Value& value)
{
    return value.isFloatValue() ? static_cast<MathLib::bigint>(value.floatValue) : value.intvalue;
}",1,1,lib/programmemory.cpp,asInt:longlongint(ValueFlow.Value&),<empty>,,false,581,584,asInt,,,1,longlongint(ValueFlow.Value&)
111669152953,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static std::string removeAssign(const std::string& assign) {
    return std::string{assign.cbegin(), assign.cend() - 1};
}",1,1,lib/programmemory.cpp,removeAssign:string(std.string&),<empty>,,false,586,588,removeAssign,,,1,string(std.string&)
111669152954,METHOD,assign,TYPE_DECL,"void operator()(T& x, const U& y) const
        {
            x = static_cast<T>(y);
        }",9,9,lib/programmemory.cpp,"assign.()<const>:void(T&,U&)",<empty>,,false,593,596,(),,,1,"void(T&,U&)"
111669152955,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static bool isIntegralValue(const ValueFlow::Value& value)
{
    return value.isIntValue() || value.isIteratorValue() || value.isSymbolicValue();
}",1,1,lib/programmemory.cpp,isIntegralValue:bool(ValueFlow.Value&),<empty>,,false,600,603,isIntegralValue,,,1,bool(ValueFlow.Value&)
111669152956,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static ValueFlow::Value evaluate(const std::string& op, const ValueFlow::Value& lhs, const ValueFlow::Value& rhs)
{
    ValueFlow::Value result;
    if (lhs.isImpossible() && rhs.isImpossible())
        return ValueFlow::Value::unknown();
    if (lhs.isImpossible() || rhs.isImpossible()) {
        // noninvertible
        if (contains({""%"", ""/"", ""&"", ""|""}, op))
            return ValueFlow::Value::unknown();
        result.setImpossible();
    }
    if (isNumericValue(lhs) && isNumericValue(rhs)) {
        if (lhs.isFloatValue() || rhs.isFloatValue()) {
            result.valueType = ValueFlow::Value::ValueType::FLOAT;
            bool error = false;
            result.floatValue = calculate(op, asFloat(lhs), asFloat(rhs), &error);
            if (error)
                return ValueFlow::Value::unknown();
            return result;
        }
    }
    // Must be integral types
    if (!isIntegralValue(lhs) && !isIntegralValue(rhs))
        return ValueFlow::Value::unknown();
    // ...",1,1,lib/programmemory.cpp,"evaluate:ValueFlow.Value(std.string&,ValueFlow.Value&,ValueFlow.Value&)",<empty>,,false,605,670,evaluate,,,1,"ValueFlow.Value(std.string&,ValueFlow.Value&,ValueFlow.Value&)"
111669152957,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!(v.isTokValue() && v.tokvalue->tokType() == Token::eString))
            return ValueFlow::Value::unknown();
        v.valueType = ValueFlow::Value::ValueType::INT;
        v.intvalue = Token::getStrLength(v.tokvalue);
        v.tokvalue = nullptr;
        return v;
    }",27,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>5:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,676,686,<lambda>5,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152958,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 2)
            return ValueFlow::Value::unknown();
        const ValueFlow::Value& lhs = args[0];
        if (!(lhs.isTokValue() && lhs.tokvalue->tokType() == Token::eString))
            return ValueFlow::Value::unknown();
        const ValueFlow::Value& rhs = args[1];
        if (!(rhs.isTokValue() && rhs.tokvalue->tokType() == Token::eString))
            return ValueFlow::Value::unknown();
        ValueFlow::Value v(getStringLiteral(lhs.tokvalue->str()).compare(getStringLiteral(rhs.tokvalue->str())));
        ValueFlow::combineValueProperties(lhs, rhs, v);
        return v;
    }",27,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>6:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,687,699,<lambda>6,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152959,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 3)
            return ValueFlow::Value::unknown();
        const ValueFlow::Value& lhs = args[0];
        if (!(lhs.isTokValue() && lhs.tokvalue->tokType() == Token::eString))
            return ValueFlow::Value::unknown();
        const ValueFlow::Value& rhs = args[1];
        if (!(rhs.isTokValue() && rhs.tokvalue->tokType() == Token::eString))
            return ValueFlow::Value::unknown();
        const ValueFlow::Value& len = args[2];
        if (!len.isIntValue())
            return ValueFlow::Value::unknown();
        ValueFlow::Value v(getStringLiteral(lhs.tokvalue->str())
                           .compare(0, len.intvalue, getStringLiteral(rhs.tokvalue->str()), 0, len.intvalue));
        ValueFlow::combineValueProperties(lhs, rhs, v);
        return v;
    }",28,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>7:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,700,716,<lambda>7,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152960,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::sin(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",24,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>8:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,717,726,<lambda>8,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152961,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::lgamma(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",27,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>9:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,727,736,<lambda>9,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152962,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::cos(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",24,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>10:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,737,746,<lambda>10,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152963,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::tan(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",24,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>11:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,747,756,<lambda>11,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152964,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::asin(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",25,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>12:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,757,766,<lambda>12,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152965,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::acos(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",25,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>13:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,767,776,<lambda>13,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152966,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::atan(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",25,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>14:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,777,786,<lambda>14,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152967,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }",74,9,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>15.<lambda>16:bool(ValueFlow.Value&)",<empty>,,false,788,790,<lambda>16,,,1,bool(ValueFlow.Value&)
111669152968,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 2 || !std::all_of(args.cbegin(), args.cend(), [](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }))
            return ValueFlow::Value::unknown();
        ValueFlow::Value v;
        combineValueProperties(args[0], args[1], v);
        v.floatValue = std::atan2(asFloat(args[0]), asFloat(args[1]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",26,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>15:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,787,797,<lambda>15,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152969,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }",74,9,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>17.<lambda>18:bool(ValueFlow.Value&)",<empty>,,false,799,801,<lambda>18,,,1,bool(ValueFlow.Value&)
111669152970,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 2 || !std::all_of(args.cbegin(), args.cend(), [](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }))
            return ValueFlow::Value::unknown();
        ValueFlow::Value v;
        combineValueProperties(args[0], args[1], v);
        v.floatValue = std::remainder(asFloat(args[0]), asFloat(args[1]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",30,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>17:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,798,808,<lambda>17,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152971,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }",74,9,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>19.<lambda>20:bool(ValueFlow.Value&)",<empty>,,false,810,812,<lambda>20,,,1,bool(ValueFlow.Value&)
111669152972,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 2 || !std::all_of(args.cbegin(), args.cend(), [](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }))
            return ValueFlow::Value::unknown();
        ValueFlow::Value v;
        combineValueProperties(args[0], args[1], v);
        v.floatValue = std::nextafter(asFloat(args[0]), asFloat(args[1]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",30,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>19:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,809,819,<lambda>19,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152973,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }",74,9,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>21.<lambda>22:bool(ValueFlow.Value&)",<empty>,,false,821,823,<lambda>22,,,1,bool(ValueFlow.Value&)
111669152974,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 2 || !std::all_of(args.cbegin(), args.cend(), [](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }))
            return ValueFlow::Value::unknown();
        ValueFlow::Value v;
        combineValueProperties(args[0], args[1], v);
        v.floatValue = std::nexttoward(asFloat(args[0]), asFloat(args[1]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",31,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>21:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,820,830,<lambda>21,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152975,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }",74,9,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>23.<lambda>24:bool(ValueFlow.Value&)",<empty>,,false,832,834,<lambda>24,,,1,bool(ValueFlow.Value&)
111669152976,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 2 || !std::all_of(args.cbegin(), args.cend(), [](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }))
            return ValueFlow::Value::unknown();
        ValueFlow::Value v;
        combineValueProperties(args[0], args[1], v);
        v.floatValue = std::hypot(asFloat(args[0]), asFloat(args[1]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",26,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>23:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,831,841,<lambda>23,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152977,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }",74,9,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>25.<lambda>26:bool(ValueFlow.Value&)",<empty>,,false,843,845,<lambda>26,,,1,bool(ValueFlow.Value&)
111669152978,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 2 || !std::all_of(args.cbegin(), args.cend(), [](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }))
            return ValueFlow::Value::unknown();
        ValueFlow::Value v;
        combineValueProperties(args[0], args[1], v);
        v.floatValue = std::fdim(asFloat(args[0]), asFloat(args[1]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",25,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>25:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,842,852,<lambda>25,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152979,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }",74,9,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>27.<lambda>28:bool(ValueFlow.Value&)",<empty>,,false,854,856,<lambda>28,,,1,bool(ValueFlow.Value&)
111669152980,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 2 || !std::all_of(args.cbegin(), args.cend(), [](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }))
            return ValueFlow::Value::unknown();
        ValueFlow::Value v;
        combineValueProperties(args[0], args[1], v);
        v.floatValue = std::fmax(asFloat(args[0]), asFloat(args[1]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",25,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>27:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,853,863,<lambda>27,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152981,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }",74,9,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>29.<lambda>30:bool(ValueFlow.Value&)",<empty>,,false,865,867,<lambda>30,,,1,bool(ValueFlow.Value&)
111669152982,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 2 || !std::all_of(args.cbegin(), args.cend(), [](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }))
            return ValueFlow::Value::unknown();
        ValueFlow::Value v;
        combineValueProperties(args[0], args[1], v);
        v.floatValue = std::fmin(asFloat(args[0]), asFloat(args[1]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",25,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>29:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,864,874,<lambda>29,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152983,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }",74,9,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>31.<lambda>32:bool(ValueFlow.Value&)",<empty>,,false,876,878,<lambda>32,,,1,bool(ValueFlow.Value&)
111669152984,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 2 || !std::all_of(args.cbegin(), args.cend(), [](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }))
            return ValueFlow::Value::unknown();
        ValueFlow::Value v;
        combineValueProperties(args[0], args[1], v);
        v.floatValue = std::fmod(asFloat(args[0]), asFloat(args[1]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",25,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>31:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,875,885,<lambda>31,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152985,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }",74,9,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>33.<lambda>34:bool(ValueFlow.Value&)",<empty>,,false,887,889,<lambda>34,,,1,bool(ValueFlow.Value&)
111669152986,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 2 || !std::all_of(args.cbegin(), args.cend(), [](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }))
            return ValueFlow::Value::unknown();
        ValueFlow::Value v;
        combineValueProperties(args[0], args[1], v);
        v.floatValue = std::pow(asFloat(args[0]), asFloat(args[1]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",24,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>33:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,886,896,<lambda>33,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152987,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }",74,9,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>35.<lambda>36:bool(ValueFlow.Value&)",<empty>,,false,898,900,<lambda>36,,,1,bool(ValueFlow.Value&)
111669152988,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 2 || !std::all_of(args.cbegin(), args.cend(), [](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }))
            return ValueFlow::Value::unknown();
        ValueFlow::Value v;
        combineValueProperties(args[0], args[1], v);
        v.floatValue = std::scalbln(asFloat(args[0]), asInt(args[1]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",28,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>35:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,897,907,<lambda>35,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152989,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }",74,9,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>37.<lambda>38:bool(ValueFlow.Value&)",<empty>,,false,909,911,<lambda>38,,,1,bool(ValueFlow.Value&)
111669152990,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 2 || !std::all_of(args.cbegin(), args.cend(), [](const ValueFlow::Value& v) {
            return v.isFloatValue() || v.isIntValue();
        }))
            return ValueFlow::Value::unknown();
        ValueFlow::Value v;
        combineValueProperties(args[0], args[1], v);
        v.floatValue = std::ldexp(asFloat(args[0]), asInt(args[1]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",26,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>37:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,908,918,<lambda>37,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152991,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.intvalue = std::ilogb(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::INT;
        return v;
    }",26,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>39:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,919,928,<lambda>39,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152992,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::erf(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",24,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>40:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,929,938,<lambda>40,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152993,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::erfc(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",25,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>41:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,939,948,<lambda>41,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152994,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::floor(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",26,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>42:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,949,958,<lambda>42,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152995,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::sqrt(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",25,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>43:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,959,968,<lambda>43,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152996,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::cbrt(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",25,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>44:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,969,978,<lambda>44,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152997,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::ceil(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",25,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>45:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,979,988,<lambda>45,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152998,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::exp(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",24,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>46:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,989,998,<lambda>46,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669152999,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::exp2(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",25,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>47:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,999,1008,<lambda>47,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669153000,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::expm1(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",26,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>48:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,1009,1018,<lambda>48,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669153001,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::fabs(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",25,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>49:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,1019,1028,<lambda>49,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669153002,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::log(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",24,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>50:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,1029,1038,<lambda>50,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669153003,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::log10(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",26,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>51:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,1039,1048,<lambda>51,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669153004,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::log1p(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",26,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>52:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,1049,1058,<lambda>52,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669153005,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::log2(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",25,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>53:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,1059,1068,<lambda>53,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669153006,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::logb(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",25,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>54:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,1069,1078,<lambda>54,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669153007,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::nearbyint(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",30,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>55:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,1079,1088,<lambda>55,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669153008,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::sinh(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",25,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>56:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,1089,1098,<lambda>56,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669153009,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::cosh(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",25,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>57:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,1099,1108,<lambda>57,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669153010,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::tanh(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",25,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>58:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,1109,1118,<lambda>58,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669153011,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::asinh(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",26,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>59:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,1119,1128,<lambda>59,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669153012,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::acosh(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",26,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>60:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,1129,1138,<lambda>60,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669153013,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::atanh(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",26,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>61:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,1139,1148,<lambda>61,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669153014,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::round(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",26,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>62:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,1149,1158,<lambda>62,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669153015,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::tgamma(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",27,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>63:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,1159,1168,<lambda>63,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669153016,METHOD,<empty>,<empty>,"[](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!v.isFloatValue() && !v.isIntValue())
            return ValueFlow::Value::unknown();
        v.floatValue = std::trunc(asFloat(args[0]));
        v.valueType = ValueFlow::Value::ValueType::FLOAT;
        return v;
    }",26,5,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>().<lambda>64:ValueFlow.Value(std.vector<ValueFlow.Value>&)",<empty>,,false,1169,1178,<lambda>64,,,1,ValueFlow.Value(std.vector<ValueFlow.Value>&)
111669153017,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static std::unordered_map<std::string, BuiltinLibraryFunction> createBuiltinLibraryFunctions()
{
    std::unordered_map<std::string, BuiltinLibraryFunction> functions;
    functions[""strlen""] = [](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 1)
            return ValueFlow::Value::unknown();
        ValueFlow::Value v = args[0];
        if (!(v.isTokValue() && v.tokvalue->tokType() == Token::eString))
            return ValueFlow::Value::unknown();
        v.valueType = ValueFlow::Value::ValueType::INT;
        v.intvalue = Token::getStrLength(v.tokvalue);
        v.tokvalue = nullptr;
        return v;
    };
    functions[""strcmp""] = [](const std::vector<ValueFlow::Value>& args) {
        if (args.size() != 2)
            return ValueFlow::Value::unknown();
        const ValueFlow::Value& lhs = args[0];
        if (!(lhs.isTokValue() && lhs.tokvalue->tokType() == Token::eString))
            return ValueFlow::Value::unknown();
        const ValueFlow::Va...",1,1,lib/programmemory.cpp,"createBuiltinLibraryFunctions:unordered_map<std.string,BuiltinLibraryFunction>()",<empty>,,false,673,1180,createBuiltinLibraryFunctions,,,1,"unordered_map<std::string,BuiltinLibraryFunction>()"
111669153018,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static BuiltinLibraryFunction getBuiltinLibraryFunction(const std::string& name)
{
    static const std::unordered_map<std::string, BuiltinLibraryFunction> functions = createBuiltinLibraryFunctions();
    auto it = functions.find(name);
    if (it == functions.end())
        return nullptr;
    return it->second;
}",1,1,lib/programmemory.cpp,getBuiltinLibraryFunction:BuiltinLibraryFunction(std.string&),<empty>,,false,1182,1189,getBuiltinLibraryFunction,,,1,BuiltinLibraryFunction(std.string&)
111669153019,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static bool TokenExprIdCompare(const Token* tok1, const Token* tok2) {
    return tok1->exprId() < tok2->exprId();
}",1,1,lib/programmemory.cpp,"TokenExprIdCompare:bool(Token*,Token*)",<empty>,,false,1190,1192,TokenExprIdCompare,,,1,"bool(Token*,Token*)"
111669153020,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static bool TokenExprIdEqual(const Token* tok1, const Token* tok2) {
    return tok1->exprId() == tok2->exprId();
}",1,1,lib/programmemory.cpp,"TokenExprIdEqual:bool(Token*,Token*)",<empty>,,false,1193,1195,TokenExprIdEqual,,,1,"bool(Token*,Token*)"
111669153021,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static std::vector<const Token*> setDifference(const std::vector<const Token*>& v1, const std::vector<const Token*>& v2)
{
    std::vector<const Token*> result;
    std::set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), std::back_inserter(result), &TokenExprIdCompare);
    return result;
}",1,1,lib/programmemory.cpp,"setDifference:vector<constToken*>(std.vector<constToken*>&,std.vector<constToken*>&)",<empty>,,false,1197,1202,setDifference,,,1,"vector<const Token*>(std.vector<constToken*>&,std.vector<constToken*>&)"
111669153022,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static bool evalSameCondition(const ProgramMemory& state,
                              const Token* storedValue,
                              const Token* cond,
                              const Settings& settings)
{
    assert(!conditionIsTrue(cond, state, settings));
    ProgramMemory pm = state;
    programMemoryParseCondition(pm, storedValue, nullptr, settings, true);
    if (pm == state)
        return false;
    return conditionIsTrue(cond, std::move(pm), settings);
}",1,1,lib/programmemory.cpp,"evalSameCondition:bool(ProgramMemory&,Token*,Token*,Settings&)",<empty>,,false,1204,1215,evalSameCondition,,,1,"bool(ProgramMemory&,Token*,Token*,Settings&)"
111669153023,METHOD,<empty>,<empty>,"[&](const Token* cond) {
        if (cond->exprId() == 0)
            return false;
        auto it = state.find(cond->exprId());
        if (it == state.end())
            return false;
        const ValueFlow::Value& v = it->second;
        return isTrueOrFalse(v, !b);
    }",32,5,lib/programmemory.cpp,lib/programmemory.cpp:<global>.pruneConditions.<lambda>65:bool(Token*),<empty>,,false,1223,1231,<lambda>65,,,1,bool(Token*)
111669153024,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static void pruneConditions(std::vector<const Token*>& conds,
                            bool b,
                            const std::unordered_map<nonneg int, ValueFlow::Value>& state)
{
    conds.erase(std::remove_if(conds.begin(),
                               conds.end(),
                               [&](const Token* cond) {
        if (cond->exprId() == 0)
            return false;
        auto it = state.find(cond->exprId());
        if (it == state.end())
            return false;
        const ValueFlow::Value& v = it->second;
        return isTrueOrFalse(v, !b);
    }),
                conds.end());
}",1,53,lib/programmemory.cpp,"pruneConditions:void(std.vector<constToken*>&,bool,std.unordered_map<int,ValueFlow.Value>&)",<empty>,,false,1217,1233,pruneConditions,,,1,"void(std.vector<constToken*>&,bool,std.unordered_map<int,ValueFlow.Value>&)"
111669153025,METHOD,<empty>,<empty>,"[](const Token* child) {
                return Token::Match(child, ""&&|%oror%"");
            }",67,13,lib/programmemory.cpp,lib/programmemory.cpp:<global>.Executor.sortConditions.<lambda>66:bool(Token*),<empty>,,false,1275,1277,<lambda>66,,,1,bool(Token*)
111669153026,METHOD,<empty>,<empty>,"[&](const Token* cond2) {
                            return evalSameCondition(*pm, cond2, cond1, settings);
                        }",96,25,lib/programmemory.cpp,lib/programmemory.cpp:<global>.Executor.executeMultiCondition.<lambda>67:bool(Token*),<empty>,,false,1355,1357,<lambda>67,,,1,bool(Token*)
111669153027,METHOD,<empty>,<empty>,"[&](const Token* tok) {
                        return execute(tok);
                    }",73,21,lib/programmemory.cpp,lib/programmemory.cpp:<global>.Executor.executeImpl.<lambda>68:ValueFlow.Value(Token*),<empty>,,false,1560,1562,<lambda>68,,,1,ValueFlow.Value(Token*)
111669153028,METHOD,<empty>,<empty>,"[&](const Token* child) {
                    if (child->exprId() > 0 && pm->hasValue(child->exprId())) {
                        ValueFlow::Value& v = pm->at(child->exprId());
                        if (v.valueType == ValueFlow::Value::ValueType::CONTAINER_SIZE) {
                            if (ValueFlow::isContainerSizeChanged(child, v.indirect, settings))
                                v = unknown();
                        } else if (v.valueType != ValueFlow::Value::ValueType::UNINIT) {
                            if (isVariableChanged(child, v.indirect, settings))
                                v = unknown();
                        }
                    }
                    return ChildrenToVisit::op1_and_op2;
                }",52,17,lib/programmemory.cpp,lib/programmemory.cpp:<global>.Executor.executeImpl.<lambda>69:ChildrenToVisit(Token*),<empty>,,false,1598,1610,<lambda>69,,,1,ChildrenToVisit(Token*)
111669153029,METHOD,<empty>,<empty>,"[](const ValueFlow::Value* x, const ValueFlow::Value* y) {
                return x->intvalue < y->intvalue;
            }",64,13,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.Executor.getImpossibleValue.<lambda>70:bool(ValueFlow.Value*,ValueFlow.Value*)",<empty>,,false,1629,1631,<lambda>70,,,1,"bool(ValueFlow.Value*,ValueFlow.Value*)"
111669153030,METHOD,<empty>,<empty>,"[&] {
                    depth++;
                }",27,17,lib/programmemory.cpp,lib/programmemory.cpp:<global>.Executor.execute.<lambda>71:void(),<empty>,,false,1648,1650,<lambda>71,,,1,void()
111669153031,METHOD,Executor,TYPE_DECL,"Executor(ProgramMemory* pm, const Settings& settings) : pm(pm), settings(settings)
        {
            assert(pm != nullptr);
        }",9,9,lib/programmemory.cpp,"Executor.Executor:ANY(ProgramMemory*,Settings&)",<empty>,,false,1242,1245,Executor,,,5,"Executor.Executor:ANY(ProgramMemory*,Settings&)(ProgramMemory*,Settings&)"
111669153032,METHOD,Executor,TYPE_DECL,"static ValueFlow::Value unknown() {
            return ValueFlow::Value::unknown();
        }",9,9,lib/programmemory.cpp,Executor.unknown:ValueFlow.Value(),<empty>,,false,1247,1249,unknown,,,6,ValueFlow.Value()
111669153033,METHOD,Executor,TYPE_DECL,"std::unordered_map<nonneg int, ValueFlow::Value> executeAll(const std::vector<const Token*>& toks,
                                                                    const bool* b = nullptr) const
        {
            std::unordered_map<nonneg int, ValueFlow::Value> result;
            auto state = *this;
            for (const Token* tok : toks) {
                ValueFlow::Value r = state.execute(tok);
                if (r.isUninitValue())
                    continue;
                const bool brk = b && isTrueOrFalse(r, *b);
                result.emplace(tok->exprId(), std::move(r));
                // Short-circuit evaluation
                if (brk)
                    break;
            }
            return result;
        }",9,27,lib/programmemory.cpp,"Executor.executeAll<const>:unordered_map<int,ValueFlow.Value>(std.vector<constToken*>&,bool*)",<empty>,,false,1251,1267,executeAll,,,7,"unordered_map<int,ValueFlow::Value>(std.vector<constToken*>&,bool*)"
111669153034,METHOD,Executor,TYPE_DECL,"static std::vector<const Token*> flattenConditions(const Token* tok)
        {
            return astFlatten(tok, tok->str().c_str());
        }",9,9,lib/programmemory.cpp,Executor.flattenConditions:vector<constToken*>(Token*),<empty>,,false,1269,1272,flattenConditions,,,8,vector<const Token*>(Token*)
111669153035,METHOD,Executor,TYPE_DECL,"static bool sortConditions(std::vector<const Token*>& conditions)
        {
            if (std::any_of(conditions.begin(), conditions.end(), [](const Token* child) {
                return Token::Match(child, ""&&|%oror%"");
            }))
                return false;
            std::sort(conditions.begin(), conditions.end(), &TokenExprIdCompare);
            conditions.erase(std::unique(conditions.begin(), conditions.end(), &TokenExprIdCompare), conditions.end());
            return !conditions.empty() && conditions.front()->exprId() != 0;
        }",9,9,lib/programmemory.cpp,Executor.sortConditions:bool(std.vector<constToken*>&),<empty>,,false,1273,1282,sortConditions,,,9,bool(std.vector<constToken*>&)
111669153036,METHOD,Executor,TYPE_DECL,"ValueFlow::Value executeMultiCondition(bool b, const Token* expr)
        {
            if (pm->hasValue(expr->exprId())) {
                const ValueFlow::Value& v = utils::as_const(*pm).at(expr->exprId());
                if (v.isIntValue())
                    return v;
            }

            // Evaluate recursively if there are no exprids
            if ((expr->astOperand1() && expr->astOperand1()->exprId() == 0) ||
                (expr->astOperand2() && expr->astOperand2()->exprId() == 0)) {
                ValueFlow::Value lhs = execute(expr->astOperand1());
                if (isTrueOrFalse(lhs, b))
                    return lhs;
                ValueFlow::Value rhs = execute(expr->astOperand2());
                if (isTrueOrFalse(rhs, b))
                    return rhs;
                if (isTrueOrFalse(lhs, !b) && isTrueOrFalse(rhs, !b))
                    return lhs;
                return unknown();
            }

            nonneg int n = astCount(expr, expr->st...",9,12,lib/programmemory.cpp,"Executor.executeMultiCondition:ValueFlow.Value(bool,Token*)",<empty>,,false,1284,1367,executeMultiCondition,,,10,"ValueFlow.Value(bool,Token*)"
111669153037,METHOD,Executor,TYPE_DECL,"ValueFlow::Value executeImpl(const Token* expr)
        {
            const ValueFlow::Value* value = nullptr;
            if (!expr)
                return unknown();
            if (expr->hasKnownIntValue() && !expr->isAssignmentOp() && expr->str() != "","")
                return *expr->getKnownValue(ValueFlow::Value::ValueType::INT);
            if ((value = expr->getKnownValue(ValueFlow::Value::ValueType::FLOAT)) ||
                (value = expr->getKnownValue(ValueFlow::Value::ValueType::TOK)) ||
                (value = expr->getKnownValue(ValueFlow::Value::ValueType::ITERATOR_START)) ||
                (value = expr->getKnownValue(ValueFlow::Value::ValueType::ITERATOR_END)) ||
                (value = expr->getKnownValue(ValueFlow::Value::ValueType::CONTAINER_SIZE))) {
                return *value;
            }
            if (expr->isNumber()) {
                if (MathLib::isFloat(expr->str()))
                    return unknown();
                MathLib::bigint i = MathL...",9,47,lib/programmemory.cpp,Executor.executeImpl:ValueFlow.Value(Token*),<empty>,,false,1369,1615,executeImpl,,,11,ValueFlow.Value(Token*)
111669153038,METHOD,Executor,TYPE_DECL,"static const ValueFlow::Value* getImpossibleValue(const Token* tok)
        {
            if (!tok)
                return nullptr;
            std::vector<const ValueFlow::Value*> values;
            for (const ValueFlow::Value& v : tok->values()) {
                if (!v.isImpossible())
                    continue;
                if (v.isContainerSizeValue() || v.isIntValue()) {
                    values.push_back(std::addressof(v));
                }
            }
            auto it =
                std::max_element(values.begin(), values.end(), [](const ValueFlow::Value* x, const ValueFlow::Value* y) {
                return x->intvalue < y->intvalue;
            });
            if (it == values.end())
                return nullptr;
            return *it;
        }",9,9,lib/programmemory.cpp,Executor.getImpossibleValue:ValueFlow.Value*(Token*),<empty>,,false,1616,1635,getImpossibleValue,,,12,ValueFlow.Value*(Token*)
111669153039,METHOD,Executor,TYPE_DECL,"static bool updateValue(ValueFlow::Value& v, ValueFlow::Value x)
        {
            const bool returnValue = !x.isUninitValue() && !x.isImpossible();
            if (v.isUninitValue() || returnValue)
                v = std::move(x);
            return returnValue;
        }",9,9,lib/programmemory.cpp,"Executor.updateValue:bool(ValueFlow.Value&,ValueFlow.Value)",<empty>,,false,1637,1643,updateValue,,,13,"bool(ValueFlow.Value&,ValueFlow.Value)"
111669153040,METHOD,Executor,TYPE_DECL,"ValueFlow::Value execute(const Token* expr)
        {
            depth--;
            OnExit onExit{[&] {
                    depth++;
                }};
            if (depth < 0)
                return unknown();
            ValueFlow::Value v = unknown();
            if (updateValue(v, executeImpl(expr)))
                return v;
            if (!expr)
                return v;
            if (expr->exprId() > 0 && pm->hasValue(expr->exprId())) {
                if (updateValue(v, utils::as_const(*pm).at(expr->exprId())))
                    return v;
            }
            // Find symbolic values
            for (const ValueFlow::Value& value : expr->values()) {
                if (!value.isSymbolicValue())
                    continue;
                if (!value.isKnown())
                    continue;
                if (value.tokvalue->exprId() > 0 && !pm->hasValue(value.tokvalue->exprId()))
                    continue;
                const ValueFlow::Value& v_ref = u...",9,9,lib/programmemory.cpp,Executor.execute:ValueFlow.Value(Token*),<empty>,,false,1645,1682,execute,,,14,ValueFlow.Value(Token*)
111669153041,METHOD,Executor,TYPE_DECL,"std::vector<ValueFlow::Value> execute(const Scope* scope)
        {
            if (!scope)
                return {unknown()};
            if (!scope->bodyStart)
                return {unknown()};
            for (const Token* tok = scope->bodyStart->next(); precedes(tok, scope->bodyEnd); tok = tok->next()) {
                const Token* top = tok->astTop();

                if (Token::simpleMatch(top, ""return"") && top->astOperand1())
                    return {execute(top->astOperand1())};

                if (Token::Match(top, ""%op%"")) {
                    if (execute(top).isUninitValue())
                        return {unknown()};
                    const Token* next = nextAfterAstRightmostLeaf(top);
                    if (!next)
                        return {unknown()};
                    tok = next;
                } else if (Token::simpleMatch(top->previous(), ""if ("")) {
                    const Token* condTok = top->astOperand2();
                    ValueFlow::Val...",9,9,lib/programmemory.cpp,Executor.execute:vector<ValueFlow.Value>(Scope*),<empty>,,false,1684,1732,execute,,,15,vector<ValueFlow::Value>(Scope*)
111669153042,METHOD,<empty>,<empty>,<empty>,5,,lib/programmemory.cpp,Executor.<clinit>,<empty>,,false,1236,,<clinit>,,,16,
111669153043,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static ValueFlow::Value execute(const Token* expr, ProgramMemory& pm, const Settings& settings)
{
    Executor ex{&pm, settings};
    return ex.execute(expr);
}",1,1,lib/programmemory.cpp,"execute:ValueFlow.Value(Token*,ProgramMemory&,Settings&)",<empty>,,false,1736,1740,execute,,,1,"ValueFlow.Value(Token*,ProgramMemory&,Settings&)"
111669153044,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"std::vector<ValueFlow::Value> execute(const Scope* scope, ProgramMemory& pm, const Settings& settings)
{
    Executor ex{&pm, settings};
    return ex.execute(scope);
}",1,1,lib/programmemory.cpp,"execute:vector<ValueFlow.Value>(Scope*,ProgramMemory&,Settings&)",<empty>,,false,1742,1746,execute,,,1,"vector<ValueFlow::Value>(Scope*,ProgramMemory&,Settings&)"
111669153045,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"static std::shared_ptr<Token> createTokenFromExpression(const std::string& returnValue,
                                                        const Settings& settings,
                                                        bool cpp,
                                                        std::unordered_map<nonneg int, const Token*>& lookupVarId)
{
    std::shared_ptr<TokenList> tokenList = std::make_shared<TokenList>(&settings);
    {
        const std::string code = ""return "" + returnValue + "";"";
        std::istringstream istr(code);
        if (!tokenList->createTokens(istr, cpp ? Standards::Language::CPP : Standards::Language::C))
            return nullptr;
    }

    // TODO: put in a helper?
    // combine operators, set links, etc..
    std::stack<Token*> lpar;
    for (Token* tok2 = tokenList->front(); tok2; tok2 = tok2->next()) {
        if (Token::Match(tok2, ""[!<>=] ="")) {
            tok2->str(tok2->str() + ""="");
            tok2->deleteNext();
        } else if (tok...",1,75,lib/programmemory.cpp,"createTokenFromExpression:shared_ptr<Token>(std.string&,Settings&,bool,std.unordered_map<int,constToken*>&)",<empty>,,false,1748,1794,createTokenFromExpression,,,1,"shared_ptr<Token>(std.string&,Settings&,bool,std.unordered_map<int,constToken*>&)"
111669153046,METHOD,<empty>,<empty>,"[lookupVarId, expr](const std::unordered_map<nonneg int, ValueFlow::Value>& xargs, const Settings& settings) {
            if (!expr)
                return ValueFlow::Value::unknown();
            ProgramMemory pm{};
            for (const auto& p : xargs) {
                auto it = lookupVarId.find(p.first);
                if (it != lookupVarId.end())
                    pm.setValue(it->second, p.second);
            }
            return execute(expr.get(), pm, settings);
        }",13,57,lib/programmemory.cpp,"lib/programmemory.cpp:<global>.evaluateLibraryFunction.<lambda>72:ValueFlow.Value(std.unordered_map<int,ValueFlow.Value>&,Settings&)",<empty>,,false,1810,1820,<lambda>72,,,1,"ValueFlow.Value(std.unordered_map<int,ValueFlow.Value>&,Settings&)"
111669153047,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"ValueFlow::Value evaluateLibraryFunction(const std::unordered_map<nonneg int, ValueFlow::Value>& args,
                                         const std::string& returnValue,
                                         const Settings& settings,
                                         bool cpp)
{
    thread_local static std::unordered_map<std::string,
                                           std::function<ValueFlow::Value(const std::unordered_map<nonneg int, ValueFlow::Value>&, const Settings&)>>
    functions = {};
    if (functions.count(returnValue) == 0) {

        std::unordered_map<nonneg int, const Token*> lookupVarId;
        std::shared_ptr<Token> expr = createTokenFromExpression(returnValue, settings, cpp, lookupVarId);

        functions[returnValue] =
            [lookupVarId, expr](const std::unordered_map<nonneg int, ValueFlow::Value>& xargs, const Settings& settings) {
            if (!expr)
                return ValueFlow::Value::unknown();
            ProgramMemory...",1,66,lib/programmemory.cpp,"evaluateLibraryFunction:ValueFlow.Value(std.unordered_map<int,ValueFlow.Value>&,std.string&,Settings&,bool)",<empty>,,false,1796,1823,evaluateLibraryFunction,,,1,"ValueFlow.Value(std.unordered_map<int,ValueFlow.Value>&,std.string&,Settings&,bool)"
111669153048,METHOD,lib/programmemory.cpp:<global>,TYPE_DECL,"void execute(const Token* expr,
             ProgramMemory& programMemory,
             MathLib::bigint* result,
             bool* error,
             const Settings& settings)
{
    ValueFlow::Value v = execute(expr, programMemory, settings);
    if (!v.isIntValue() || v.isImpossible()) {
        if (error)
            *error = true;
    } else if (result)
        *result = v.intvalue;
}",1,1,lib/programmemory.cpp,"execute:void(Token*,ProgramMemory&,MathLib.bigint*,bool*,Settings&)",<empty>,,false,1825,1837,execute,,,1,"void(Token*,ProgramMemory&,MathLib.bigint*,bool*,Settings&)"
111669153049,METHOD,<empty>,<empty>,<empty>,1,,lib/programmemory.h,ExprIdToken.<clinit>,<empty>,,false,40,,<clinit>,,,17,
111669153050,METHOD,lib/programmemory.h:<global>,TYPE_DECL,<global>,1,1,lib/programmemory.h,lib/programmemory.h:<global>,<empty>,,false,1,209,<global>,,,1,
111669153051,METHOD,<empty>,<empty>,"[](MathLib::bigint x) {
                return x == 1;
            }",80,13,lib/reverseanalyzer.cpp,lib/reverseanalyzer.cpp:<global>.ReverseTraversal.evalCond<const>.<lambda>0:bool(MathLib.bigint),<empty>,,false,51,53,<lambda>0,,,1,bool(MathLib.bigint)
111669153052,METHOD,<empty>,<empty>,"[](MathLib::bigint x) {
                return x == 0;
            }",80,13,lib/reverseanalyzer.cpp,lib/reverseanalyzer.cpp:<global>.ReverseTraversal.evalCond<const>.<lambda>1:bool(MathLib.bigint),<empty>,,false,54,56,<lambda>1,,,1,bool(MathLib.bigint)
111669153053,METHOD,<empty>,<empty>,"[&](Token* tok) {
                const Token* parent = tok->astParent();
                while (Token::simpleMatch(parent, "":""))
                    parent = parent->astParent();
                if (isUnevaluated(tok) || isDeadCode(tok, parent))
                    return ChildrenToVisit::none;
                continueB &= update(tok);
                if (continueB)
                    return ChildrenToVisit::op1_and_op2;
                return ChildrenToVisit::done;
            }",34,13,lib/reverseanalyzer.cpp,lib/reverseanalyzer.cpp:<global>.ReverseTraversal.updateRecursive.<lambda>2:ChildrenToVisit(Token*),<empty>,,false,122,132,<lambda>2,,,1,ChildrenToVisit(Token*)
111669153054,METHOD,<empty>,<empty>,"[&](const Token* tok) {
                result |= analyzer->analyze(tok, Analyzer::Direction::Reverse);
                if (result.isModified())
                    return ChildrenToVisit::done;
                return ChildrenToVisit::op1_and_op2;
            }",34,13,lib/reverseanalyzer.cpp,lib/reverseanalyzer.cpp:<global>.ReverseTraversal.analyzeRecursive<const>.<lambda>3:ChildrenToVisit(Token*),<empty>,,false,138,143,<lambda>3,,,1,ChildrenToVisit(Token*)
111669153055,METHOD,ReverseTraversal,TYPE_DECL,"ReverseTraversal(const ValuePtr<Analyzer>& analyzer, const TokenList& tokenlist, ErrorLogger& errorLogger, const Settings& settings)
            : analyzer(analyzer), tokenlist(tokenlist), errorLogger(errorLogger), settings(settings)
        {}",9,10,lib/reverseanalyzer.cpp,"ReverseTraversal.ReverseTraversal:ANY(ValuePtr<Analyzer>&,TokenList&,ErrorLogger&,Settings&)",<empty>,,false,40,42,ReverseTraversal,,,1,"ReverseTraversal.ReverseTraversal:ANY(ValuePtr<Analyzer>&,TokenList&,ErrorLogger&,Settings&)(ValuePtr<Analyzer>&,TokenList&,ErrorLogger&,Settings&)"
111669153056,METHOD,ReverseTraversal,TYPE_DECL,"std::pair<bool, bool> evalCond(const Token* tok) const {
            std::vector<MathLib::bigint> result = analyzer->evaluate(tok);
            // TODO: We should convert to bool
            const bool checkThen = std::any_of(result.cbegin(), result.cend(), [](MathLib::bigint x) {
                return x == 1;
            });
            const bool checkElse = std::any_of(result.cbegin(), result.cend(), [](MathLib::bigint x) {
                return x == 0;
            });
            return std::make_pair(checkThen, checkElse);
        }",9,9,lib/reverseanalyzer.cpp,"ReverseTraversal.evalCond<const>:pair<bool,bool>(Token*)",<empty>,,false,48,58,evalCond,,,6,"pair<bool,bool>(Token*)"
111669153057,METHOD,ReverseTraversal,TYPE_DECL,"bool update(Token* tok) {
            Analyzer::Action action = analyzer->analyze(tok, Analyzer::Direction::Reverse);
            if (action.isInconclusive() && !analyzer->lowerToInconclusive())
                return false;
            if (action.isInvalid())
                return false;
            if (!action.isNone())
                analyzer->update(tok, action, Analyzer::Direction::Reverse);
            return true;
        }",9,9,lib/reverseanalyzer.cpp,ReverseTraversal.update:bool(Token*),<empty>,,false,60,69,update,,,7,bool(Token*)
111669153058,METHOD,ReverseTraversal,TYPE_DECL,"static Token* getParentFunction(Token* tok)
        {
            if (!tok)
                return nullptr;
            if (!tok->astParent())
                return nullptr;
            int argn = -1;
            if (Token* ftok = getTokenArgumentFunction(tok, argn)) {
                while (!Token::Match(ftok, ""(|{"")) {
                    if (!ftok)
                        return nullptr;
                    if (ftok->index() >= tok->index())
                        return nullptr;
                    if (!ftok->link() || ftok->str() == "")"")
                        ftok = ftok->next();
                    else
                        ftok = ftok->link()->next();
                }
                if (ftok == tok)
                    return nullptr;
                return ftok;
            }
            return nullptr;
        }",9,9,lib/reverseanalyzer.cpp,ReverseTraversal.getParentFunction:Token*(Token*),<empty>,,false,71,94,getParentFunction,,,8,Token*(Token*)
111669153059,METHOD,ReverseTraversal,TYPE_DECL,"static Token* getTopFunction(Token* tok)
        {
            if (!tok)
                return nullptr;
            if (!tok->astParent())
                return tok;
            Token* parent = tok;
            Token* top = tok;
            while ((parent = getParentFunction(parent)))
                top = parent;
            return top;
        }",9,9,lib/reverseanalyzer.cpp,ReverseTraversal.getTopFunction:Token*(Token*),<empty>,,false,96,107,getTopFunction,,,9,Token*(Token*)
111669153060,METHOD,ReverseTraversal,TYPE_DECL,"static Token* jumpToStart(Token* tok)
        {
            if (Token::simpleMatch(tok->tokAt(-2), ""} else {""))
                tok = tok->linkAt(-2);
            if (Token::simpleMatch(tok->previous(), "") {""))
                return tok->linkAt(-1);
            if (Token::simpleMatch(tok->previous(), ""do {""))
                return tok->previous();
            return tok;
        }",9,9,lib/reverseanalyzer.cpp,ReverseTraversal.jumpToStart:Token*(Token*),<empty>,,false,109,118,jumpToStart,,,10,Token*(Token*)
111669153061,METHOD,ReverseTraversal,TYPE_DECL,"bool updateRecursive(Token* start) {
            bool continueB = true;
            visitAstNodes(start, [&](Token* tok) {
                const Token* parent = tok->astParent();
                while (Token::simpleMatch(parent, "":""))
                    parent = parent->astParent();
                if (isUnevaluated(tok) || isDeadCode(tok, parent))
                    return ChildrenToVisit::none;
                continueB &= update(tok);
                if (continueB)
                    return ChildrenToVisit::op1_and_op2;
                return ChildrenToVisit::done;
            });
            return continueB;
        }",9,9,lib/reverseanalyzer.cpp,ReverseTraversal.updateRecursive:bool(Token*),<empty>,,false,120,134,updateRecursive,,,11,bool(Token*)
111669153062,METHOD,ReverseTraversal,TYPE_DECL,"Analyzer::Action analyzeRecursive(const Token* start) const {
            Analyzer::Action result = Analyzer::Action::None;
            visitAstNodes(start, [&](const Token* tok) {
                result |= analyzer->analyze(tok, Analyzer::Direction::Reverse);
                if (result.isModified())
                    return ChildrenToVisit::done;
                return ChildrenToVisit::op1_and_op2;
            });
            return result;
        }",9,9,lib/reverseanalyzer.cpp,ReverseTraversal.analyzeRecursive<const>:Analyzer.Action(Token*),<empty>,,false,136,145,analyzeRecursive,,,12,Analyzer.Action(Token*)
111669153063,METHOD,ReverseTraversal,TYPE_DECL,"Analyzer::Action analyzeRange(const Token* start, const Token* end) const {
            Analyzer::Action result = Analyzer::Action::None;
            for (const Token* tok = start; tok && tok != end; tok = tok->next()) {
                Analyzer::Action action = analyzer->analyze(tok, Analyzer::Direction::Reverse);
                if (action.isModified())
                    return action;
                result |= action;
            }
            return result;
        }",9,9,lib/reverseanalyzer.cpp,"ReverseTraversal.analyzeRange<const>:Analyzer.Action(Token*,Token*)",<empty>,,false,147,156,analyzeRange,,,13,"Analyzer.Action(Token*,Token*)"
111669153064,METHOD,ReverseTraversal,TYPE_DECL,"Token* isDeadCode(Token* tok, const Token* end = nullptr) const {
            int opSide = 0;
            for (; tok && tok->astParent(); tok = tok->astParent()) {
                if (tok == end)
                    break;
                Token* parent = tok->astParent();
                if (Token::simpleMatch(parent, "":"")) {
                    if (astIsLHS(tok))
                        opSide = 1;
                    else if (astIsRHS(tok))
                        opSide = 2;
                    else
                        opSide = 0;
                }
                if (tok != parent->astOperand2())
                    continue;
                if (Token::simpleMatch(parent, "":""))
                    parent = parent->astParent();
                if (!Token::Match(parent, ""%oror%|&&|?""))
                    continue;
                const Token* condTok = parent->astOperand1();
                if (!condTok)
                    continue;
                bool checkThen, checkElse;...",9,9,lib/reverseanalyzer.cpp,"ReverseTraversal.isDeadCode<const>:Token*(Token*,Token*)",<empty>,,false,158,196,isDeadCode,,,14,"Token*(Token*,Token*)"
111669153065,METHOD,ReverseTraversal,TYPE_DECL,"void traverse(Token* start, const Token* end = nullptr) {
            if (start == end)
                return;
            std::size_t i = start->index();
            for (Token* tok = start->previous(); succeeds(tok, end); tok = tok->previous()) {
                if (tok->index() >= i)
                    throw InternalError(tok, ""Cyclic reverse analysis."");
                i = tok->index();
                if (tok == start || (tok->str() == ""{"" && (tok->scope()->type == ScopeType::eFunction ||
                                                           tok->scope()->type == ScopeType::eLambda))) {
                    const Function* f = tok->scope()->function;
                    if (f && f->isConstructor()) {
                        if (const Token* initList = f->constructorMemberInitialization())
                            traverse(tok->previous(), tok->tokAt(initList->index() - tok->index()));
                    }
                    break;
                }
                i...",9,9,lib/reverseanalyzer.cpp,"ReverseTraversal.traverse:void(Token*,Token*)",<empty>,,false,198,380,traverse,,,15,"void(Token*,Token*)"
111669153066,METHOD,ReverseTraversal,TYPE_DECL,"static Token* assignExpr(Token* tok) {
            if (Token::Match(tok, "")|}""))
                tok = tok->link();
            while (tok->astParent() && (astIsRHS(tok) || !tok->astParent()->isBinaryOp())) {
                if (tok->astParent()->isAssignmentOp())
                    return tok->astParent();
                tok = tok->astParent();
            }
            return nullptr;
        }",9,9,lib/reverseanalyzer.cpp,ReverseTraversal.assignExpr:Token*(Token*),<empty>,,false,382,391,assignExpr,,,16,Token*(Token*)
111669153067,METHOD,ReverseTraversal,TYPE_DECL,"static Token* isUnevaluated(Token* tok) {
            if (Token::Match(tok, "")|>"") && tok->link()) {
                Token* start = tok->link();
                if (::isUnevaluated(start->previous()))
                    return start->previous();
                if (Token::simpleMatch(start, ""<""))
                    return start;
            }
            return nullptr;
        }",9,9,lib/reverseanalyzer.cpp,ReverseTraversal.isUnevaluated:Token*(Token*),<empty>,,false,393,402,isUnevaluated,,,17,Token*(Token*)
111669153068,METHOD,lib/reverseanalyzer.cpp:<global>,TYPE_DECL,"void valueFlowGenericReverse(Token* start, const Token* end, const ValuePtr<Analyzer>& a, const TokenList& tokenlist, ErrorLogger& errorLogger, const Settings& settings)
{
    if (a->invalid())
        return;
    ReverseTraversal rt{a, tokenlist, errorLogger, settings};
    rt.traverse(start, end);
}",1,1,lib/reverseanalyzer.cpp,"valueFlowGenericReverse:void(Token*,Token*,ValuePtr<Analyzer>&,TokenList&,ErrorLogger&,Settings&)",<empty>,,false,406,412,valueFlowGenericReverse,,,1,"void(Token*,Token*,ValuePtr<Analyzer>&,TokenList&,ErrorLogger&,Settings&)"
111669153069,METHOD,lib/reverseanalyzer.cpp:<global>,TYPE_DECL,<global>,1,1,lib/reverseanalyzer.cpp,lib/reverseanalyzer.cpp:<global>,<empty>,,false,1,412,<global>,,,1,
111669153070,METHOD,lib/reverseanalyzer.h:<global>,TYPE_DECL,<global>,1,6,lib/reverseanalyzer.h,lib/reverseanalyzer.h:<global>,<empty>,,false,1,32,<global>,,,1,
111669153071,METHOD,lib/settings.cpp:<global>,TYPE_DECL,"static int getPid()
{
#ifndef _WIN32
    return getpid();
#else
    return _getpid();
#endif
}",1,1,lib/settings.cpp,getPid:int(),<empty>,,false,50,57,getPid,,,1,int()
111669153072,METHOD,lib/settings.cpp:<global>,TYPE_DECL,<global>,1,1,lib/settings.cpp,lib/settings.cpp:<global>,<empty>,,false,1,705,<global>,,,1,
111669153073,METHOD,lib/settings.cpp:<global>,TYPE_DECL,"Settings::Settings()
{
    severity.setEnabled(Severity::error, true);
    certainty.setEnabled(Certainty::normal, true);
    setCheckLevel(Settings::CheckLevel::exhaustive);
    executor = defaultExecutor();
    pid = getPid();
}",1,1,lib/settings.cpp,Settings.Settings:ANY(),<empty>,,false,59,66,Settings,,,1,ANY()
111669153074,METHOD,lib/settings.cpp:<global>,TYPE_DECL,"std::string Settings::loadCppcheckCfg(Settings& settings, Suppressions& suppressions, bool debug)
{
    // TODO: this always needs to be run *after* the Settings has been filled
    static const std::string cfgFilename = ""cppcheck.cfg"";
    std::string fileName;
#ifdef FILESDIR
    {
        const std::string filesdirCfg = Path::join(FILESDIR, cfgFilename);
        if (debug)
            std::cout << ""looking for '"" << filesdirCfg << ""'"" << std::endl;
        if (Path::isFile(filesdirCfg))
            fileName = filesdirCfg;
    }
#endif
    // cppcheck-suppress knownConditionTrueFalse
    if (fileName.empty()) {
        // TODO: make sure that exename is set
        fileName = Path::getPathFromFilename(settings.exename) + cfgFilename;
        if (debug)
            std::cout << ""looking for '"" << fileName << ""'"" << std::endl;
        if (!Path::isFile(fileName))
        {
            if (debug)
                std::cout << ""no configuration found"" << std::endl;
            return ""...",1,1,lib/settings.cpp,"Settings.loadCppcheckCfg:string(Settings&,Suppressions&,bool)",<empty>,,false,68,171,loadCppcheckCfg,,,1,"string(Settings&,Suppressions&,bool)"
111669153075,METHOD,lib/settings.cpp:<global>,TYPE_DECL,"std::pair<std::string, std::string> Settings::getNameAndVersion(const std::string& productName) {
    if (productName.empty())
        return {};
    const std::string::size_type pos1 = productName.rfind(' ');
    if (pos1 == std::string::npos)
        return {};
    if (pos1 + 2 >= productName.length())
        return {};
    for (auto pos2 = pos1 + 1; pos2 < productName.length(); ++pos2) {
        const char c = productName[pos2];
        const char prev = productName[pos2-1];
        if (std::isdigit(c))
            continue;
        if (c == '.' && std::isdigit(prev))
            continue;
        if (c == 's' && pos2 + 1 == productName.length() && std::isdigit(prev))
            continue;
        return {};
    }
    return {productName.substr(0, pos1), productName.substr(pos1+1)};
}",1,1,lib/settings.cpp,"Settings.getNameAndVersion:pair<std.string,std.string>(std.string&)",<empty>,,false,173,193,getNameAndVersion,,,1,"pair<std::string,std::string>(std.string&)"
111669153076,METHOD,lib/settings.cpp:<global>,TYPE_DECL,"std::string Settings::parseEnabled(const std::string &str, std::tuple<SimpleEnableGroup<Severity>, SimpleEnableGroup<Checks>> &groups)
{
    // Enable parameters may be comma separated...
    if (str.find(',') != std::string::npos) {
        std::string::size_type prevPos = 0;
        std::string::size_type pos = 0;
        while ((pos = str.find(',', pos)) != std::string::npos) {
            if (pos == prevPos)
                return std::string(""--enable parameter is empty"");
            std::string errmsg(parseEnabled(str.substr(prevPos, pos - prevPos), groups));
            if (!errmsg.empty())
                return errmsg;
            ++pos;
            prevPos = pos;
        }
        if (prevPos >= str.length())
            return std::string(""--enable parameter is empty"");
        return parseEnabled(str.substr(prevPos), groups);
    }

    auto& severity = std::get<0>(groups);
    auto& checks = std::get<1>(groups);

    if (str == ""all"") {
        // ""error"" is always ena...",1,1,lib/settings.cpp,"Settings.parseEnabled:string(std.string&,std.tuple<SimpleEnableGroup<Severity>,SimpleEnableGroup<Checks>>&)",<empty>,,false,195,254,parseEnabled,,,1,"string(std.string&,std.tuple<SimpleEnableGroup<Severity>,SimpleEnableGroup<Checks>>&)"
111669153077,METHOD,lib/settings.cpp:<global>,TYPE_DECL,"std::string Settings::addEnabled(const std::string &str)
{
    return applyEnabled(str, true);
}",1,1,lib/settings.cpp,Settings.addEnabled:string(std.string&),<empty>,,false,256,259,addEnabled,,,1,string(std.string&)
111669153078,METHOD,lib/settings.cpp:<global>,TYPE_DECL,"std::string Settings::removeEnabled(const std::string &str)
{
    return applyEnabled(str, false);
}",1,1,lib/settings.cpp,Settings.removeEnabled:string(std.string&),<empty>,,false,261,264,removeEnabled,,,1,string(std.string&)
111669153079,METHOD,lib/settings.cpp:<global>,TYPE_DECL,"std::string Settings::applyEnabled(const std::string &str, bool enable)
{
    std::tuple<SimpleEnableGroup<Severity>, SimpleEnableGroup<Checks>> groups;
    std::string errmsg = parseEnabled(str, groups);
    if (!errmsg.empty())
        return (enable ? ""--enable"" : ""--disable"") + errmsg;

    const auto s = std::get<0>(groups);
    const auto c = std::get<1>(groups);
    if (enable) {
        severity.enable(s);
        checks.enable(c);
    }
    else {
        severity.disable(s);
        checks.disable(c);
    }
    // FIXME: hack to make sure ""error"" is always enabled
    severity.enable(Severity::error);
    return errmsg;
}",1,1,lib/settings.cpp,"Settings.applyEnabled:string(std.string&,bool)",<empty>,,false,266,286,applyEnabled,,,1,"string(std.string&,bool)"
111669153080,METHOD,lib/settings.cpp:<global>,TYPE_DECL,"bool Settings::isEnabled(const ValueFlow::Value *value, bool inconclusiveCheck) const
{
    if (!severity.isEnabled(Severity::warning) && (value->condition || value->defaultArg))
        return false;
    if (!certainty.isEnabled(Certainty::inconclusive) && (inconclusiveCheck || value->isInconclusive()))
        return false;
    return true;
}",1,1,lib/settings.cpp,"Settings.isEnabled<const>:bool(ValueFlow.Value*,bool)",<empty>,,false,288,295,isEnabled,,,1,"bool(ValueFlow.Value*,bool)"
111669153081,METHOD,lib/settings.cpp:<global>,TYPE_DECL,"void Settings::loadSummaries()
{
    Summaries::loadReturn(buildDir, summaryReturn);
}",1,1,lib/settings.cpp,Settings.loadSummaries:void(),<empty>,,false,297,300,loadSummaries,,,1,void()
111669153082,METHOD,lib/settings.cpp:<global>,TYPE_DECL,"void Settings::setCheckLevel(CheckLevel level)
{
    if (level == CheckLevel::reduced) {
        // Checking should finish quickly.
        checkLevel = level;
        vfOptions.maxSubFunctionArgs = 8;
        vfOptions.maxIfCount = 100;
        vfOptions.doConditionExpressionAnalysis = false;
        vfOptions.maxForwardBranches = 4;
        vfOptions.maxIterations = 1;
    }
    else if (level == CheckLevel::normal) {
        // Checking should finish in reasonable time.
        checkLevel = level;
        vfOptions.maxSubFunctionArgs = 8;
        vfOptions.maxIfCount = 100;
        vfOptions.doConditionExpressionAnalysis = false;
        vfOptions.maxForwardBranches = 4;
    }
    else if (level == CheckLevel::exhaustive) {
        // Checking can take a little while. ~ 10 times slower than normal analysis is OK.
        checkLevel = CheckLevel::exhaustive;
        vfOptions.maxIfCount = -1;
        vfOptions.maxSubFunctionArgs = 256;
        vfOptions.doConditionExpressionAnalys...",1,1,lib/settings.cpp,Settings.setCheckLevel:void(Settings.CheckLevel),<empty>,,false,302,329,setCheckLevel,,,1,void(Settings.CheckLevel)
111669153083,METHOD,lib/settings.cpp:<global>,TYPE_DECL,"bool Settings::isPremiumEnabled(const char id[]) const
{
    if (premiumArgs.find(""autosar"") != std::string::npos && autosarCheckers.count(id))
        return true;
    if (premiumArgs.find(""cert-c-"") != std::string::npos && certCCheckers.count(id))
        return true;
    if (premiumArgs.find(""cert-c++"") != std::string::npos && certCppCheckers.count(id))
        return true;
    if (premiumArgs.find(""misra-c-"") != std::string::npos && (misrac2012Checkers.count(id) || misrac2023Checkers.count(id)))
        return true;
    if (premiumArgs.find(""misra-c++-2008"") != std::string::npos && misracpp2008Checkers.count(id))
        return true;
    if (premiumArgs.find(""misra-c++-2023"") != std::string::npos && misracpp2023Checkers.count(id))
        return true;
    return false;
}",1,1,lib/settings.cpp,Settings.isPremiumEnabled<const>:bool(char[]),<empty>,,false,634,649,isPremiumEnabled,,,1,bool(char[])
111669153084,METHOD,<empty>,<empty>,"[](const AddonInfo& a) {
            return a.name == ""premiumaddon.json"";
        }",78,9,lib/settings.cpp,lib/settings.cpp:<global>.Settings.setMisraRuleTexts.<lambda>0:bool(AddonInfo&),<empty>,,false,654,656,<lambda>0,,,1,bool(AddonInfo&)
111669153085,METHOD,lib/settings.cpp:<global>,TYPE_DECL,"void Settings::setMisraRuleTexts(const ExecuteCmdFn& executeCommand)
{
    if (premiumArgs.find(""--misra-c-20"") != std::string::npos) {
        const auto it = std::find_if(addonInfos.cbegin(), addonInfos.cend(), [](const AddonInfo& a) {
            return a.name == ""premiumaddon.json"";
        });
        if (it != addonInfos.cend()) {
            std::string arg;
            if (premiumArgs.find(""--misra-c-2023"") != std::string::npos)
                arg = ""--misra-c-2023-rule-texts"";
            else
                arg = ""--misra-c-2012-rule-texts"";
            std::string output;
            executeCommand(it->executable, {std::move(arg)}, ""2>&1"", output);
            setMisraRuleTexts(output);
        }
    }
}",1,1,lib/settings.cpp,Settings.setMisraRuleTexts:void(Settings.ExecuteCmdFn&),<empty>,,false,651,668,setMisraRuleTexts,,,1,void(Settings.ExecuteCmdFn&)
111669153086,METHOD,lib/settings.cpp:<global>,TYPE_DECL,"void Settings::setMisraRuleTexts(const std::string& data)
{
    mMisraRuleTexts.clear();
    std::istringstream istr(data);
    std::string line;
    while (std::getline(istr, line)) {
        std::string::size_type pos = line.find(' ');
        if (pos == std::string::npos)
            continue;
        std::string id = line.substr(0, pos);
        std::string text = line.substr(pos + 1);
        if (id.empty() || text.empty())
            continue;
        if (text[text.size() -1] == '\\r')
            text.erase(text.size() -1);
        mMisraRuleTexts[id] = std::move(text);
    }
}",1,1,lib/settings.cpp,Settings.setMisraRuleTexts:void(std.string&),<empty>,,false,670,687,setMisraRuleTexts,,,1,void(std.string&)
111669153087,METHOD,lib/settings.cpp:<global>,TYPE_DECL,"std::string Settings::getMisraRuleText(const std::string& id, const std::string& text) const {
    if (id.compare(0, 9, ""misra-c20"") != 0)
        return text;
    const auto it = mMisraRuleTexts.find(id.substr(id.rfind('-') + 1));
    return it != mMisraRuleTexts.end() ? it->second : text;
}",1,1,lib/settings.cpp,"Settings.getMisraRuleText<const>:string(std.string&,std.string&)",<empty>,,false,689,694,getMisraRuleText,,,1,"string(std.string&,std.string&)"
111669153088,METHOD,lib/settings.cpp:<global>,TYPE_DECL,"Settings::ExecutorType Settings::defaultExecutor()
{
    static constexpr ExecutorType defaultExecutor =
#if defined(HAS_THREADING_MODEL_FORK)
        ExecutorType::Process;
#elif defined(HAS_THREADING_MODEL_THREAD)
        ExecutorType::Thread;
#endif
    return defaultExecutor;
}",1,1,lib/settings.cpp,Settings.defaultExecutor:Settings.ExecutorType(),<empty>,,false,696,705,defaultExecutor,,,1,Settings.ExecutorType()
111669153089,METHOD,lib/settings.h:<global>,TYPE_DECL,<global>,1,1,lib/settings.h,lib/settings.h:<global>,<empty>,,false,1,545,<global>,,,1,
111669153090,METHOD,lib/smallvector.h:<global>,TYPE_DECL,<global>,1,6,lib/smallvector.h,lib/smallvector.h:<global>,<empty>,,false,1,71,<global>,,,1,
111669153091,METHOD,SourceLocation,TYPE_DECL,"static SourceLocation current() {
        return SourceLocation();
    }",5,5,lib/sourcelocation.h,current,<empty>,,false,75,77,current,,,2,SourceLocation()
111669153092,METHOD,<empty>,<empty>,<empty>,1,,lib/sourcelocation.h,SourceLocation.<clinit>,<empty>,,false,60,,<clinit>,,,13,
111669153093,METHOD,lib/sourcelocation.h:<global>,TYPE_DECL,<global>,1,1,lib/sourcelocation.h,lib/sourcelocation.h:<global>,<empty>,,false,1,98,<global>,,,1,
111669153094,METHOD,lib/standards.cpp:<global>,TYPE_DECL,"static Standards::cstd_t mapC(simplecpp::cstd_t cstd) {
    switch (cstd)
    {
    case simplecpp::C89:
        return Standards::C89;
    case simplecpp::C99:
        return Standards::C99;
    case simplecpp::C11:
        return Standards::C11;
    case simplecpp::C17:
        return Standards::C17;
    case simplecpp::C23:
        return Standards::C23;
    case simplecpp::CUnknown:
        return Standards::CLatest;
    }
    cppcheck::unreachable();
}",1,1,lib/standards.cpp,mapC:Standards.cstd_t(simplecpp.cstd_t),<empty>,,false,26,43,mapC,,,1,Standards.cstd_t(simplecpp.cstd_t)
111669153095,METHOD,lib/standards.cpp:<global>,TYPE_DECL,<global>,1,1,lib/standards.cpp,lib/standards.cpp:<global>,<empty>,,false,1,155,<global>,,,1,
111669153096,METHOD,lib/standards.cpp:<global>,TYPE_DECL,"bool Standards::setC(std::string str)
{
    if (str.empty())
        return false;
    const simplecpp::cstd_t c_new = simplecpp::getCStd(str);
    const bool b = (c_new != simplecpp::CUnknown);
    if (b) {
        c = mapC(c_new);
        stdValueC = std::move(str);
    }
    return b;
}",1,1,lib/standards.cpp,Standards.setC:bool(std.string),<empty>,,false,45,56,setC,,,1,bool(std.string)
111669153097,METHOD,lib/standards.cpp:<global>,TYPE_DECL,"std::string Standards::getC() const
{
    return getC(c);
}",1,1,lib/standards.cpp,Standards.getC<const>:string(),<empty>,,false,58,61,getC,,,1,string()
111669153098,METHOD,lib/standards.cpp:<global>,TYPE_DECL,"std::string Standards::getC(cstd_t c_std)
{
    switch (c_std) {
    case C89:
        return ""c89"";
    case C99:
        return ""c99"";
    case C11:
        return ""c11"";
    case C17:
        return ""c17"";
    case C23:
        return ""c23"";
    }
    return """";
}",1,1,lib/standards.cpp,Standards.getC:string(Standards.cstd_t),<empty>,,false,63,78,getC,,,1,string(Standards.cstd_t)
111669153099,METHOD,lib/standards.cpp:<global>,TYPE_DECL,"Standards::cstd_t Standards::getC(const std::string &std)
{
    return mapC(simplecpp::getCStd(std));
}",1,1,lib/standards.cpp,Standards.getC:Standards.cstd_t(std.string&),<empty>,,false,80,83,getC,,,1,Standards.cstd_t(std.string&)
111669153100,METHOD,lib/standards.cpp:<global>,TYPE_DECL,"static Standards::cppstd_t mapCPP(simplecpp::cppstd_t cppstd) {
    switch (cppstd)
    {
    case simplecpp::CPP03:
        return Standards::CPP03;
    case simplecpp::CPP11:
        return Standards::CPP11;
    case simplecpp::CPP14:
        return Standards::CPP14;
    case simplecpp::CPP17:
        return Standards::CPP17;
    case simplecpp::CPP20:
        return Standards::CPP20;
    case simplecpp::CPP23:
        return Standards::CPP23;
    case simplecpp::CPP26:
        return Standards::CPP26;
    case simplecpp::CPPUnknown:
        return Standards::CPPLatest;
    }
    cppcheck::unreachable();
}",1,1,lib/standards.cpp,mapCPP:Standards.cppstd_t(simplecpp.cppstd_t),<empty>,,false,85,106,mapCPP,,,1,Standards.cppstd_t(simplecpp.cppstd_t)
111669153101,METHOD,lib/standards.cpp:<global>,TYPE_DECL,"bool Standards::setCPP(std::string str)
{
    if (str.empty())
        return false;
    const simplecpp::cppstd_t cpp_new = simplecpp::getCppStd(str);
    const bool b = (cpp_new != simplecpp::CPPUnknown);
    if (b) {
        cpp = mapCPP(cpp_new);
        stdValueCPP = std::move(str);
    }
    return b;
}",1,1,lib/standards.cpp,Standards.setCPP:bool(std.string),<empty>,,false,108,119,setCPP,,,1,bool(std.string)
111669153102,METHOD,lib/standards.cpp:<global>,TYPE_DECL,"std::string Standards::getCPP() const
{
    return getCPP(cpp);
}",1,1,lib/standards.cpp,Standards.getCPP<const>:string(),<empty>,,false,121,124,getCPP,,,1,string()
111669153103,METHOD,lib/standards.cpp:<global>,TYPE_DECL,"std::string Standards::getCPP(cppstd_t std)
{
    switch (std) {
    case CPP03:
        return ""c++03"";
    case CPP11:
        return ""c++11"";
    case CPP14:
        return ""c++14"";
    case CPP17:
        return ""c++17"";
    case CPP20:
        return ""c++20"";
    case CPP23:
        return ""c++23"";
    case CPP26:
        return ""c++26"";
    }
    return """";
}",1,1,lib/standards.cpp,Standards.getCPP:string(Standards.cppstd_t),<empty>,,false,126,145,getCPP,,,1,string(Standards.cppstd_t)
111669153104,METHOD,lib/standards.cpp:<global>,TYPE_DECL,"Standards::cppstd_t Standards::getCPP(const std::string &std)
{
    return mapCPP(simplecpp::getCppStd(std));
}",1,1,lib/standards.cpp,Standards.getCPP:Standards.cppstd_t(std.string&),<empty>,,false,147,150,getCPP,,,1,Standards.cppstd_t(std.string&)
111669153105,METHOD,lib/standards.cpp:<global>,TYPE_DECL,"bool Standards::setStd(const std::string& str)
{
    return setC(str) || setCPP(str);
}",1,1,lib/standards.cpp,Standards.setStd:bool(std.string&),<empty>,,false,152,155,setStd,,,1,bool(std.string&)
111669153106,METHOD,<empty>,<empty>,<empty>,1,,lib/standards.h,Standards.<clinit>,<empty>,,false,37,,<clinit>,,,17,
111669153107,METHOD,lib/standards.h:<global>,TYPE_DECL,<global>,1,1,lib/standards.h,lib/standards.h:<global>,<empty>,,false,1,65,<global>,,,1,
111669153108,METHOD,<empty>,<empty>,"[](const std::set<std::string> &data) -> std::string {
            std::string ret;
            const char *sep = """";
            for (const std::string &d: data)
            {
                ret += sep + d;
                sep = "","";
            }
            return ret;
        }",21,9,lib/summaries.cpp,lib/summaries.cpp:<global>.Summaries.create.<lambda>0:string(std.set<std.string>&),<empty>,,false,63,72,<lambda>0,,,1,string(std.set<std.string>&)
111669153109,METHOD,lib/summaries.cpp:<global>,TYPE_DECL,"std::string Summaries::create(const Tokenizer &tokenizer, const std::string &cfg)
{
    const SymbolDatabase *symbolDatabase = tokenizer.getSymbolDatabase();
    const Settings &settings = tokenizer.getSettings();

    std::ostringstream ostr;
    for (const Scope *scope : symbolDatabase->functionScopes) {
        const Function *f = scope->function;
        if (!f)
            continue;

        // Summarize function
        std::set<std::string> noreturn;
        std::set<std::string> globalVars;
        std::set<std::string> calledFunctions;
        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {
            if (tok->variable() && tok->variable()->isGlobal())
                globalVars.insert(tok->variable()->name());
            if (Token::Match(tok, ""%name% ("") && !Token::simpleMatch(tok->linkAt(1), "") {"")) {
                calledFunctions.insert(tok->str());
                if (Token::simpleMatch(tok->linkAt(1), "") ; }""))
                ...",1,1,lib/summaries.cpp,"Summaries.create:string(Tokenizer&,std.string&)",<empty>,,false,37,95,create,,,1,"string(Tokenizer&,std.string&)"
111669153110,METHOD,lib/summaries.cpp:<global>,TYPE_DECL,<global>,1,1,lib/summaries.cpp,lib/summaries.cpp:<global>,<empty>,,false,1,196,<global>,,,1,
111669153111,METHOD,lib/summaries.cpp:<global>,TYPE_DECL,"static std::vector<std::string> getSummaryFiles(const std::string &filename)
{
    std::vector<std::string> ret;
    std::ifstream fin(filename);
    if (!fin.is_open())
        return ret;
    std::string line;
    while (std::getline(fin, line)) {
        const std::string::size_type dotA = line.find("".a"");
        const std::string::size_type colon = line.find(':');
        if (colon > line.size() || dotA > colon)
            continue;
        std::string f = line.substr(0,colon);
        f[dotA + 1] = 's';
        ret.push_back(std::move(f));
    }
    return ret;
}",1,1,lib/summaries.cpp,getSummaryFiles:vector<std.string>(std.string&),<empty>,,false,100,117,getSummaryFiles,,,1,vector<std::string>(std.string&)
111669153112,METHOD,lib/summaries.cpp:<global>,TYPE_DECL,"static std::vector<std::string> getSummaryData(const std::string &line, const std::string &data)
{
    std::vector<std::string> ret;
    const std::string::size_type start = line.find("" "" + data + "":["");
    if (start == std::string::npos)
        return ret;
    const std::string::size_type end = line.find(']', start);
    if (end >= line.size())
        return ret;

    std::string::size_type pos1 = start + 3 + data.size();
    while (pos1 < end) {
        const std::string::size_type pos2 = line.find_first_of("",]"",pos1);
        ret.push_back(line.substr(pos1, pos2-pos1-1));
        pos1 = pos2 + 1;
    }

    return ret;
}",1,1,lib/summaries.cpp,"getSummaryData:vector<std.string>(std.string&,std.string&)",<empty>,,false,119,137,getSummaryData,,,1,"vector<std::string>(std.string&,std.string&)"
111669153113,METHOD,lib/summaries.cpp:<global>,TYPE_DECL,"static void removeFunctionCalls(const std::string& calledFunction,
                                std::map<std::string, std::vector<std::string>> &functionCalledBy,
                                std::map<std::string, std::vector<std::string>> &functionCalls,
                                std::vector<std::string> &add)
{
    std::vector<std::string> calledBy = functionCalledBy[calledFunction];
    functionCalledBy.erase(calledFunction);
    for (const std::string &c: calledBy) {
        std::vector<std::string> &calls = functionCalls[c];
        calls.erase(std::remove(calls.begin(), calls.end(), calledFunction), calls.end());
        if (calls.empty()) {
            add.push_back(calledFunction);
            removeFunctionCalls(c, functionCalledBy, functionCalls, add);
        }
    }
}",1,1,lib/summaries.cpp,"removeFunctionCalls:void(std.string&,std.map<std.string,std.vector<std.string>>&,std.map<std.string,std.vector<std.string>>&,std.vector<std.string>&)",<empty>,,false,139,154,removeFunctionCalls,,,1,"void(std.string&,std.map<std.string,std.vector<std.string>>&,std.map<std.string,std.vector<std.string>>&,std.vector<std.string>&)"
111669153114,METHOD,lib/summaries.cpp:<global>,TYPE_DECL,"void Summaries::loadReturn(const std::string &buildDir, std::set<std::string> &summaryReturn)
{
    if (buildDir.empty())
        return;

    std::vector<std::string> return1;
    std::map<std::string, std::vector<std::string>> functionCalls;
    std::map<std::string, std::vector<std::string>> functionCalledBy;

    // extract ""functionNoreturn"" and ""functionCalledBy"" from summaries
    std::vector<std::string> summaryFiles = getSummaryFiles(buildDir + ""/files.txt"");
    for (const std::string &filename: summaryFiles) {
        std::ifstream fin(buildDir + '/' + filename);
        if (!fin.is_open())
            continue;
        std::string line;
        while (std::getline(fin, line)) {
            // Get function name
            constexpr std::string::size_type pos1 = 0;
            const std::string::size_type pos2 = line.find(' ', pos1);
            std::string functionName = (pos2 == std::string::npos) ? line : line.substr(0, pos2);
            std::vector<std::string> call ...",1,1,lib/summaries.cpp,"Summaries.loadReturn:void(std.string&,std.set<std.string>&)",<empty>,,false,156,196,loadReturn,,,1,"void(std.string&,std.set<std.string>&)"
111669153115,METHOD,lib/summaries.h:<global>,TYPE_DECL,<global>,1,1,lib/summaries.h,lib/summaries.h:<global>,<empty>,,false,1,38,<global>,,,1,
111669153116,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"SuppressionList::ErrorMessage SuppressionList::ErrorMessage::fromErrorMessage(const ::ErrorMessage &msg, const std::set<std::string> &macroNames)
{
    SuppressionList::ErrorMessage ret;
    ret.hash = msg.hash;
    ret.errorId = msg.id;
    if (!msg.callStack.empty()) {
        ret.setFileName(msg.callStack.back().getfile(false));
        ret.lineNumber = msg.callStack.back().line;
    } else {
        ret.setFileName(msg.file0);
        ret.lineNumber = SuppressionList::Suppression::NO_LINE;
    }
    ret.certainty = msg.certainty;
    ret.symbolNames = msg.symbolNames();
    ret.macroNames = macroNames;
    return ret;
}",1,1,lib/suppressions.cpp,"SuppressionList.ErrorMessage.fromErrorMessage:SuppressionList.ErrorMessage(ErrorMessage&,std.set<std.string>&)",<empty>,,false,42,58,fromErrorMessage,,,1,"SuppressionList.ErrorMessage(ErrorMessage&,std.set<std.string>&)"
111669153117,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,<global>,1,1,lib/suppressions.cpp,lib/suppressions.cpp:<global>,<empty>,,false,1,670,<global>,,,1,
111669153118,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"static bool isAcceptedErrorIdChar(char c)
{
    switch (c) {
    case '_':
    case '-':
    case '.':
    case '*':
        return true;
    default:
        return c > 0 && std::isalnum(c);
    }
}",1,1,lib/suppressions.cpp,isAcceptedErrorIdChar:bool(char),<empty>,,false,60,71,isAcceptedErrorIdChar,,,1,bool(char)
111669153119,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"std::string SuppressionList::parseFile(std::istream &istr)
{
    // Change '\\r' to '\\n' in the istr
    std::string filedata;
    std::string line;
    while (std::getline(istr, line))
        filedata += line + ""\\n"";
    std::replace(filedata.begin(), filedata.end(), '\\r', '\\n');

    // Parse filedata..
    std::istringstream istr2(filedata);
    while (std::getline(istr2, line)) {
        // Skip empty lines
        if (line.empty())
            continue;

        std::string::size_type pos = 0;
        while (pos < line.size() && std::isspace(line[pos]))
            ++pos;
        if (pos == line.size())
            continue;

        // Skip comments
        if (line[pos] == '#')
            continue;
        if (pos < line.size() - 1 && line[pos] == '/' && line[pos + 1] == '/')
            continue;

        const std::string errmsg(addSuppressionLine(line));
        if (!errmsg.empty())
            return errmsg;
    }

    return """";
}",1,1,lib/suppressions.cpp,SuppressionList.parseFile:string(std.istream&),<empty>,,false,73,107,parseFile,,,1,string(std.istream&)
111669153120,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"std::string SuppressionList::parseXmlFile(const char *filename)
{
    tinyxml2::XMLDocument doc;
    const tinyxml2::XMLError error = doc.LoadFile(filename);
    if (error != tinyxml2::XML_SUCCESS)
        return std::string(""failed to load suppressions XML '"") + filename + ""' ("" + tinyxml2::XMLDocument::ErrorIDToName(error) + "")."";

    const tinyxml2::XMLElement * const rootnode = doc.FirstChildElement();
    if (!rootnode)
        return std::string(""failed to load suppressions XML '"") + filename + ""' (no root node found)."";
    // TODO: check for proper root node 'suppressions'
    for (const tinyxml2::XMLElement * e = rootnode->FirstChildElement(); e; e = e->NextSiblingElement()) {
        if (std::strcmp(e->Name(), ""suppress"") != 0)
            return std::string(""invalid suppression xml file '"") + filename + ""', expected 'suppress' element but got a '"" + e->Name() + ""'."";

        Suppression s;
        for (const tinyxml2::XMLElement * e2 = e->FirstChildElement(); e2; e2 = e...",1,1,lib/suppressions.cpp,SuppressionList.parseXmlFile:string(char*),<empty>,,false,110,149,parseXmlFile,,,1,string(char*)
111669153121,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"std::vector<SuppressionList::Suppression> SuppressionList::parseMultiSuppressComment(const std::string &comment, std::string *errorMessage)
{
    std::vector<Suppression> suppressions;

    // If this function is called we assume that comment starts with ""cppcheck-suppress["".
    const std::string::size_type start_position = comment.find('[');
    const std::string::size_type end_position = comment.find(']', start_position);
    if (end_position == std::string::npos) {
        if (errorMessage && errorMessage->empty())
            *errorMessage = ""Bad multi suppression '"" + comment + ""'. legal format is cppcheck-suppress[errorId, errorId symbolName=arr, ...]"";
        return suppressions;
    }

    // parse all suppressions
    for (std::string::size_type pos = start_position; pos < end_position;) {
        const std::string::size_type pos1 = pos + 1;
        pos = comment.find(',', pos1);
        const std::string::size_type pos2 = (pos < end_position) ? pos : end_position;
      ...",1,1,lib/suppressions.cpp,"SuppressionList.parseMultiSuppressComment:vector<SuppressionList.Suppression>(std.string&,std.string*)",<empty>,,false,151,206,parseMultiSuppressComment,,,1,"vector<SuppressionList::Suppression>(std.string&,std.string*)"
111669153122,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"SuppressionList::Suppression SuppressionList::parseLine(const std::string &line)
{
    std::istringstream lineStream;
    SuppressionList::Suppression suppression;

    // Strip any end of line comments
    std::string::size_type endpos = std::min(line.find('#'), line.find(""//""));
    if (endpos != std::string::npos) {
        while (endpos > 0 && std::isspace(line[endpos-1])) {
            endpos--;
        }
        lineStream.str(line.substr(0, endpos));
    } else {
        lineStream.str(line);
    }

    if (std::getline(lineStream, suppression.errorId, ':')) {
        if (std::getline(lineStream, suppression.fileName)) {
            // If there is not a dot after the last colon in ""file"" then
            // the colon is a separator and the contents after the colon
            // is a line number..

            // Get position of last colon
            const std::string::size_type pos = suppression.fileName.rfind(':');

            // if a colon is found and there is no dot af...",1,1,lib/suppressions.cpp,SuppressionList.parseLine:SuppressionList.Suppression(std.string&),<empty>,,false,208,254,parseLine,,,1,SuppressionList.Suppression(std.string&)
111669153123,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"std::string SuppressionList::addSuppressionLine(const std::string &line)
{
    return addSuppression(parseLine(line));
}",1,1,lib/suppressions.cpp,SuppressionList.addSuppressionLine:string(std.string&),<empty>,,false,256,259,addSuppressionLine,,,1,string(std.string&)
111669153124,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"std::string SuppressionList::addSuppression(SuppressionList::Suppression suppression)
{
    std::lock_guard<std::mutex> lg(mSuppressionsSync);

    // Check if suppression is already in list
    auto foundSuppression = std::find_if(mSuppressions.begin(), mSuppressions.end(),
                                         std::bind(&Suppression::isSameParameters, &suppression, std::placeholders::_1));
    if (foundSuppression != mSuppressions.end()) {
        return ""suppression '"" + suppression.toString() + ""' already exists"";
    }

    // Check that errorId is valid..
    if (suppression.errorId.empty() && suppression.hash == 0)
        return ""Failed to add suppression. No id."";

    for (std::string::size_type pos = 0; pos < suppression.errorId.length(); ++pos) {
        if (!isAcceptedErrorIdChar(suppression.errorId[pos])) {
            return ""Failed to add suppression. Invalid id \\"""" + suppression.errorId + ""\\"""";
        }
        if (pos == 0 && std::isdigit(suppression.errorId[po...",1,1,lib/suppressions.cpp,SuppressionList.addSuppression:string(SuppressionList.Suppression),<empty>,,false,261,293,addSuppression,,,1,string(SuppressionList.Suppression)
111669153125,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"std::string SuppressionList::addSuppressions(std::list<Suppression> suppressions)
{
    for (auto &newSuppression : suppressions) {
        auto errmsg = addSuppression(std::move(newSuppression));
        if (!errmsg.empty())
            return errmsg;
    }
    return """";
}",1,1,lib/suppressions.cpp,SuppressionList.addSuppressions:string(std.list<Suppression>),<empty>,,false,295,303,addSuppressions,,,1,string(std.list<Suppression>)
111669153126,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"bool SuppressionList::updateSuppressionState(const SuppressionList::Suppression& suppression)
{
    std::lock_guard<std::mutex> lg(mSuppressionsSync);

    // Check if suppression is already in list
    auto foundSuppression = std::find_if(mSuppressions.begin(), mSuppressions.end(),
                                         std::bind(&Suppression::isSameParameters, &suppression, std::placeholders::_1));
    if (foundSuppression != mSuppressions.end()) {
        // Update matched state of existing global suppression
        if (!suppression.isLocal() && suppression.matched)
            foundSuppression->matched = suppression.matched;
        return true;
    }

    return false;
}",1,1,lib/suppressions.cpp,SuppressionList.updateSuppressionState:bool(SuppressionList.Suppression&),<empty>,,false,306,321,updateSuppressionState,,,1,bool(SuppressionList.Suppression&)
111669153127,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"void SuppressionList::ErrorMessage::setFileName(std::string s)
{
    mFileName = Path::simplifyPath(std::move(s));
}",1,1,lib/suppressions.cpp,SuppressionList.ErrorMessage.setFileName:void(std.string),<empty>,,false,323,326,setFileName,,,1,void(std.string)
111669153128,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"bool SuppressionList::Suppression::parseComment(std::string comment, std::string *errorMessage)
{
    if (comment.size() < 2)
        return false;

    if (comment.find(';') != std::string::npos)
        comment.erase(comment.find(';'));

    if (comment.find(""//"", 2) != std::string::npos)
        comment.erase(comment.find(""//"",2));

    if (comment.compare(comment.size() - 2, 2, ""*/"") == 0)
        comment.erase(comment.size() - 2, 2);

    const std::set<std::string> cppchecksuppress{
        ""cppcheck-suppress"",
        ""cppcheck-suppress-begin"",
        ""cppcheck-suppress-end"",
        ""cppcheck-suppress-file"",
        ""cppcheck-suppress-macro""
    };

    std::istringstream iss(comment.substr(2));
    std::string word;
    iss >> word;
    if (!cppchecksuppress.count(word))
        return false;

    iss >> errorId;
    if (!iss)
        return false;

    const std::string symbolNameString = ""symbolName="";

    while (iss) {
        iss >> word;
        if (!iss)
           ...",1,1,lib/suppressions.cpp,"SuppressionList.Suppression.parseComment:bool(std.string,std.string*)",<empty>,,false,328,374,parseComment,,,1,"bool(std.string,std.string*)"
111669153129,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"bool SuppressionList::Suppression::isSuppressed(const SuppressionList::ErrorMessage &errmsg) const
{
    if (hash > 0 && hash != errmsg.hash)
        return false;
    if (!errorId.empty() && !matchglob(errorId, errmsg.errorId))
        return false;
    if (type == SuppressionList::Type::macro) {
        if (errmsg.macroNames.count(macroName) == 0)
            return false;
    } else {
        if (!fileName.empty() && !matchglob(fileName, errmsg.getFileName()))
            return false;
        if ((SuppressionList::Type::unique == type) && (lineNumber != NO_LINE) && (lineNumber != errmsg.lineNumber)) {
            if (!thisAndNextLine || lineNumber + 1 != errmsg.lineNumber)
                return false;
        }
        if ((SuppressionList::Type::block == type) && ((errmsg.lineNumber < lineBegin) || (errmsg.lineNumber > lineEnd)))
            return false;
    }
    if (!symbolName.empty()) {
        for (std::string::size_type pos = 0; pos < errmsg.symbolNames.size();) {
     ...",1,1,lib/suppressions.cpp,SuppressionList.Suppression.isSuppressed<const>:bool(SuppressionList.ErrorMessage&),<empty>,,false,376,412,isSuppressed,,,1,bool(SuppressionList.ErrorMessage&)
111669153130,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"bool SuppressionList::Suppression::isMatch(const SuppressionList::ErrorMessage &errmsg)
{
    if (!isSuppressed(errmsg))
        return false;
    matched = true;
    checked = true;
    return true;
}",1,1,lib/suppressions.cpp,SuppressionList.Suppression.isMatch:bool(SuppressionList.ErrorMessage&),<empty>,,false,414,421,isMatch,,,1,bool(SuppressionList.ErrorMessage&)
111669153131,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"std::string SuppressionList::Suppression::getText() const
{
    std::string ret;
    if (!errorId.empty())
        ret = errorId;
    if (!fileName.empty())
        ret += "" fileName="" + fileName;
    if (lineNumber != NO_LINE)
        ret += "" lineNumber="" + std::to_string(lineNumber);
    if (!symbolName.empty())
        ret += "" symbolName="" + symbolName;
    if (hash > 0)
        ret += "" hash="" + std::to_string(hash);
    if (startsWith(ret,"" ""))
        return ret.substr(1);
    return ret;
}",1,1,lib/suppressions.cpp,SuppressionList.Suppression.getText<const>:string(),<empty>,,false,424,440,getText,,,1,string()
111669153132,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"bool SuppressionList::isSuppressed(const SuppressionList::ErrorMessage &errmsg, bool global)
{
    std::lock_guard<std::mutex> lg(mSuppressionsSync);

    const bool unmatchedSuppression(errmsg.errorId == ""unmatchedSuppression"");
    bool returnValue = false;
    for (Suppression &s : mSuppressions) {
        if (!global && !s.isLocal())
            continue;
        if (unmatchedSuppression && s.errorId != errmsg.errorId)
            continue;
        if (s.isMatch(errmsg))
            returnValue = true;
    }
    return returnValue;
}",1,1,lib/suppressions.cpp,"SuppressionList.isSuppressed:bool(SuppressionList.ErrorMessage&,bool)",<empty>,,false,442,457,isSuppressed,,,1,"bool(SuppressionList.ErrorMessage&,bool)"
111669153133,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"bool SuppressionList::isSuppressedExplicitly(const SuppressionList::ErrorMessage &errmsg, bool global)
{
    std::lock_guard<std::mutex> lg(mSuppressionsSync);

    for (Suppression &s : mSuppressions) {
        if (!global && !s.isLocal())
            continue;
        if (s.errorId != errmsg.errorId) // Error id must match exactly
            continue;
        if (s.isMatch(errmsg))
            return true;
    }
    return false;
}",1,1,lib/suppressions.cpp,"SuppressionList.isSuppressedExplicitly:bool(SuppressionList.ErrorMessage&,bool)",<empty>,,false,459,472,isSuppressedExplicitly,,,1,"bool(SuppressionList.ErrorMessage&,bool)"
111669153134,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"bool SuppressionList::isSuppressed(const ::ErrorMessage &errmsg, const std::set<std::string>& macroNames)
{
    {
        std::lock_guard<std::mutex> lg(mSuppressionsSync);

        if (mSuppressions.empty())
            return false;
    }
    return isSuppressed(SuppressionList::ErrorMessage::fromErrorMessage(errmsg, macroNames));
}",1,1,lib/suppressions.cpp,"SuppressionList.isSuppressed:bool(ErrorMessage&,std.set<std.string>&)",<empty>,,false,474,483,isSuppressed,,,1,"bool(ErrorMessage&,std.set<std.string>&)"
111669153135,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"void SuppressionList::dump(std::ostream & out) const
{
    std::lock_guard<std::mutex> lg(mSuppressionsSync);

    out << ""  <suppressions>"" << std::endl;
    for (const Suppression &suppression : mSuppressions) {
        out << ""    <suppression"";
        out << "" errorId=\\"""" << ErrorLogger::toxml(suppression.errorId) << '""';
        if (!suppression.fileName.empty())
            out << "" fileName=\\"""" << ErrorLogger::toxml(suppression.fileName) << '""';
        if (suppression.lineNumber != Suppression::NO_LINE)
            out << "" lineNumber=\\"""" << suppression.lineNumber << '""';
        if (!suppression.symbolName.empty())
            out << "" symbolName=\\"""" << ErrorLogger::toxml(suppression.symbolName) << '\\""';
        if (suppression.hash > 0)
            out << "" hash=\\"""" << suppression.hash << '\\""';
        if (suppression.lineBegin != Suppression::NO_LINE)
            out << "" lineBegin=\\"""" << suppression.lineBegin << '""';
        if (suppression.lineEnd != Suppression::NO_LI...",1,1,lib/suppressions.cpp,SuppressionList.dump<const>:void(std.ostream&),<empty>,,false,485,518,dump,,,1,void(std.ostream&)
111669153136,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"std::list<SuppressionList::Suppression> SuppressionList::getUnmatchedLocalSuppressions(const FileWithDetails &file, const bool includeUnusedFunction) const
{
    std::lock_guard<std::mutex> lg(mSuppressionsSync);

    std::list<Suppression> result;
    for (const Suppression &s : mSuppressions) {
        if (s.isInline)
            continue;
        if (s.matched || ((s.lineNumber != Suppression::NO_LINE) && !s.checked))
            continue;
        if (s.type == SuppressionList::Type::macro)
            continue;
        if (s.hash > 0)
            continue;
        if (s.errorId == ID_CHECKERSREPORT)
            continue;
        if (!includeUnusedFunction && s.errorId == ID_UNUSEDFUNCTION)
            continue;
        if (!s.isLocal() || s.fileName != file.spath())
            continue;
        result.push_back(s);
    }
    return result;
}",1,1,lib/suppressions.cpp,"SuppressionList.getUnmatchedLocalSuppressions<const>:list<SuppressionList.Suppression>(FileWithDetails&,bool)",<empty>,,false,520,543,getUnmatchedLocalSuppressions,,,1,"list<SuppressionList::Suppression>(FileWithDetails&,bool)"
111669153137,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"std::list<SuppressionList::Suppression> SuppressionList::getUnmatchedGlobalSuppressions(const bool includeUnusedFunction) const
{
    std::lock_guard<std::mutex> lg(mSuppressionsSync);

    std::list<Suppression> result;
    for (const Suppression &s : mSuppressions) {
        if (s.isInline)
            continue;
        if (s.matched || ((s.lineNumber != Suppression::NO_LINE) && !s.checked))
            continue;
        if (s.hash > 0)
            continue;
        if (!includeUnusedFunction && s.errorId == ID_UNUSEDFUNCTION)
            continue;
        if (s.errorId == ID_CHECKERSREPORT)
            continue;
        if (s.isLocal())
            continue;
        result.push_back(s);
    }
    return result;
}",1,1,lib/suppressions.cpp,SuppressionList.getUnmatchedGlobalSuppressions<const>:list<SuppressionList.Suppression>(bool),<empty>,,false,545,566,getUnmatchedGlobalSuppressions,,,1,list<SuppressionList::Suppression>(bool)
111669153138,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"std::list<SuppressionList::Suppression> SuppressionList::getUnmatchedInlineSuppressions(const bool includeUnusedFunction) const
{
    std::list<SuppressionList::Suppression> result;
    for (const SuppressionList::Suppression &s : SuppressionList::mSuppressions) {
        if (!s.isInline)
            continue;
        if (!s.checked)
            continue;
        if (s.matched)
            continue;
        if (s.hash > 0)
            continue;
        if (!includeUnusedFunction && s.errorId == ID_UNUSEDFUNCTION)
            continue;
        result.push_back(s);
    }
    return result;
}",1,1,lib/suppressions.cpp,SuppressionList.getUnmatchedInlineSuppressions<const>:list<SuppressionList.Suppression>(bool),<empty>,,false,568,585,getUnmatchedInlineSuppressions,,,1,list<SuppressionList::Suppression>(bool)
111669153139,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"std::list<SuppressionList::Suppression> SuppressionList::getSuppressions() const
{
    std::lock_guard<std::mutex> lg(mSuppressionsSync);

    return mSuppressions;
}",1,1,lib/suppressions.cpp,SuppressionList.getSuppressions<const>:list<SuppressionList.Suppression>(),<empty>,,false,587,592,getSuppressions,,,1,list<SuppressionList::Suppression>()
111669153140,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"void SuppressionList::markUnmatchedInlineSuppressionsAsChecked(const Tokenizer &tokenizer) {
    std::lock_guard<std::mutex> lg(mSuppressionsSync);

    int currLineNr = -1;
    int currFileIdx = -1;
    for (const Token *tok = tokenizer.tokens(); tok; tok = tok->next()) {
        if (currFileIdx != tok->fileIndex() || currLineNr != tok->linenr()) {
            currLineNr = tok->linenr();
            currFileIdx = tok->fileIndex();
            for (auto &suppression : mSuppressions) {
                if (suppression.type == SuppressionList::Type::unique) {
                    if (!suppression.checked && (suppression.lineNumber == currLineNr) && (suppression.fileName == tokenizer.list.file(tok))) {
                        suppression.checked = true;
                    }
                } else if (suppression.type == SuppressionList::Type::block) {
                    if ((!suppression.checked && (suppression.lineBegin <= currLineNr) && (suppression.lineEnd >= currLineNr) && (suppres...",1,1,lib/suppressions.cpp,SuppressionList.markUnmatchedInlineSuppressionsAsChecked:void(Tokenizer&),<empty>,,false,594,618,markUnmatchedInlineSuppressionsAsChecked,,,1,void(Tokenizer&)
111669153141,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"bool SuppressionList::reportUnmatchedSuppressions(const std::list<SuppressionList::Suppression> &unmatched, ErrorLogger &errorLogger)
{
    bool err = false;
    // Report unmatched suppressions
    for (const SuppressionList::Suppression &s : unmatched) {
        // don't report ""unmatchedSuppression"" as unmatched
        if (s.errorId == ""unmatchedSuppression"")
            continue;

        // check if this unmatched suppression is suppressed
        bool suppressed = false;
        for (const SuppressionList::Suppression &s2 : unmatched) {
            if (s2.errorId == ""unmatchedSuppression"") {
                if ((s2.fileName.empty() || s2.fileName == ""*"" || s2.fileName == s.fileName) &&
                    (s2.lineNumber == SuppressionList::Suppression::NO_LINE || s2.lineNumber == s.lineNumber)) {
                    suppressed = true;
                    break;
                }
            }
        }

        if (suppressed)
            continue;

        std::list<::ErrorM...",1,1,lib/suppressions.cpp,"SuppressionList.reportUnmatchedSuppressions:bool(std.list<SuppressionList.Suppression>&,ErrorLogger&)",<empty>,,false,620,651,reportUnmatchedSuppressions,,,1,"bool(std.list<SuppressionList.Suppression>&,ErrorLogger&)"
111669153142,METHOD,lib/suppressions.cpp:<global>,TYPE_DECL,"std::string SuppressionList::Suppression::toString() const
{
    std::string s;
    s+= errorId;
    if (!fileName.empty()) {
        s += ':';
        s += fileName;
        if (lineNumber != -1) {
            s += ':';
            s += std::to_string(lineNumber);
        }
    }
    if (!symbolName.empty()) {
        s += ':';
        s += symbolName;
    }
    return s;
}",1,1,lib/suppressions.cpp,SuppressionList.Suppression.toString<const>:string(),<empty>,,false,653,670,toString,,,1,string()
111669153143,METHOD,lib/suppressions.h:<global>,TYPE_DECL,<global>,1,1,lib/suppressions.h,lib/suppressions.h:<global>,<empty>,,false,1,298,<global>,,,1,
111669153144,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"SymbolDatabase::SymbolDatabase(Tokenizer& tokenizer, const Settings& settings, ErrorLogger& errorLogger)
    : mTokenizer(tokenizer), mSettings(settings), mErrorLogger(errorLogger)
{
    if (!mTokenizer.tokens())
        return;

    if (mSettings.platform.defaultSign == 's' || mSettings.platform.defaultSign == 'S')
        mDefaultSignedness = ValueType::SIGNED;
    else if (mSettings.platform.defaultSign == 'u' || mSettings.platform.defaultSign == 'U')
        mDefaultSignedness = ValueType::UNSIGNED;
    else
        mDefaultSignedness = ValueType::UNKNOWN_SIGN;

    createSymbolDatabaseFindAllScopes();
    createSymbolDatabaseClassInfo();
    createSymbolDatabaseVariableInfo();
    createSymbolDatabaseCopyAndMoveConstructors();
    createSymbolDatabaseFunctionScopes();
    createSymbolDatabaseClassAndStructScopes();
    createSymbolDatabaseFunctionReturnTypes();
    createSymbolDatabaseNeedInitialization();
    createSymbolDatabaseVariableSymbolTable();
    createSymbolDatabaseS...",1,1,lib/symboldatabase.cpp,"SymbolDatabase.SymbolDatabase:ANY(Tokenizer&,Settings&,ErrorLogger&)",<empty>,,false,56,90,SymbolDatabase,,,1,"SymbolDatabase.SymbolDatabase:ANY(Tokenizer&,Settings&,ErrorLogger&)(Tokenizer&,Settings&,ErrorLogger&)"
111669153145,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,<global>,1,78,lib/symboldatabase.cpp,lib/symboldatabase.cpp:<global>,<empty>,,false,1,8384,<global>,,,1,
111669153146,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static const Token* skipScopeIdentifiers(const Token* tok)
{
    if (Token::Match(tok, "":: %name%""))
        tok = tok->next();
    while (Token::Match(tok, ""%name% ::"") ||
           (Token::Match(tok, ""%name% <"") && Token::Match(tok->linkAt(1), "">|>> ::""))) {
        if (tok->strAt(1) == ""::"")
            tok = tok->tokAt(2);
        else
            tok = tok->linkAt(1)->tokAt(2);
    }

    return tok;
}",1,1,lib/symboldatabase.cpp,skipScopeIdentifiers:Token*(Token*),<empty>,,false,92,105,skipScopeIdentifiers,,,1,Token*(Token*)
111669153147,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static bool isExecutableScope(const Token* tok)
{
    if (!Token::simpleMatch(tok, ""{""))
        return false;
    const Token * tok2 = tok->link()->previous();
    if (Token::simpleMatch(tok2, ""; }""))
        return true;
    if (tok2 == tok)
        return false;
    if (Token::simpleMatch(tok2, ""} }"")) { // inner scope
        const Token* startTok = tok2->link();
        if (Token::Match(startTok->previous(), ""do|try|else {""))
            return true;
        if (Token::Match(startTok->previous(), "")|] {""))
            return !findLambdaStartToken(tok2);
        return isExecutableScope(startTok);
    }
    return false;
}",1,1,lib/symboldatabase.cpp,isExecutableScope:bool(Token*),<empty>,,false,107,125,isExecutableScope,,,1,bool(Token*)
111669153148,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Token* SymbolDatabase::isEnumDefinition(const Token* tok)
{
    if (!Token::Match(tok, ""enum class| %name%| {|:""))
        return nullptr;
    while (!Token::Match(tok, ""[{:]""))
        tok = tok->next();
    if (tok->str() == ""{"")
        return tok;
    tok = tok->next(); // skip ':'
    while (Token::Match(tok, ""%name%|::""))
        tok = tok->next();
    return Token::simpleMatch(tok, ""{"") ? tok : nullptr;
}",1,1,lib/symboldatabase.cpp,SymbolDatabase.isEnumDefinition:Token*(Token*),<empty>,,false,127,139,isEnumDefinition,,,1,Token*(Token*)
111669153149,METHOD,<empty>,<empty>,"[&] {
        if (endInitList.empty())
            return false;
        return endInitList.top().second == scope;
    }",23,5,lib/symboldatabase.cpp,lib/symboldatabase.cpp:<global>.SymbolDatabase.createSymbolDatabaseFindAllScopes.<lambda>0:bool(),<empty>,,false,151,155,<lambda>0,,,1,bool()
111669153150,METHOD,<empty>,<empty>,"[this, &scope](const Token* tok, const Token* lambdaEndToken) -> const Token* {
        const Token* lambdaStartToken = lambdaEndToken->link();
        const Token* argStart = lambdaStartToken->astParent();
        const Token* funcStart = Token::simpleMatch(argStart, ""["") ? argStart : argStart->astParent();
        const Function* function = addGlobalFunction(scope, tok, argStart, funcStart);
        if (!function)
            mTokenizer.syntaxError(tok);
        return lambdaStartToken;
    }",22,5,lib/symboldatabase.cpp,"lib/symboldatabase.cpp:<global>.SymbolDatabase.createSymbolDatabaseFindAllScopes.<lambda>1:Token(Token*,Token*)",<empty>,,false,159,167,<lambda>1,,,1,"Token(Token*,Token*)"
111669153151,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::createSymbolDatabaseFindAllScopes()
{
    // create global scope
    scopeList.emplace_back(this, nullptr, nullptr);

    // pointer to current scope
    Scope *scope = &scopeList.back();

    // Store the ending of init lists
    std::stack<std::pair<const Token*, const Scope*>> endInitList;
    auto inInitList = [&] {
        if (endInitList.empty())
            return false;
        return endInitList.top().second == scope;
    };

    std::stack<const Token*> inIfCondition;

    auto addLambda = [this, &scope](const Token* tok, const Token* lambdaEndToken) -> const Token* {
        const Token* lambdaStartToken = lambdaEndToken->link();
        const Token* argStart = lambdaStartToken->astParent();
        const Token* funcStart = Token::simpleMatch(argStart, ""["") ? argStart : argStart->astParent();
        const Function* function = addGlobalFunction(scope, tok, argStart, funcStart);
        if (!function)
            mTokenizer.syntaxError(tok);
        re...",1,1,lib/symboldatabase.cpp,SymbolDatabase.createSymbolDatabaseFindAllScopes:void(),<empty>,,false,141,801,createSymbolDatabaseFindAllScopes,,,1,void()
111669153152,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::createSymbolDatabaseClassInfo()
{
    if (mTokenizer.isC())
        return;

    // fill in using info
    for (Scope& scope : scopeList) {
        for (Scope::UsingInfo& usingInfo : scope.usingList) {
            // only find if not already found
            if (usingInfo.scope == nullptr) {
                // check scope for match
                const Scope * const found = findScope(usingInfo.start->tokAt(2), &scope);
                if (found) {
                    // set found scope
                    usingInfo.scope = found;
                    break;
                }
            }
        }
    }

    // fill in base class info
    for (Type& type : typeList) {
        // finish filling in base class info
        for (Type::BaseInfo & i : type.derivedFrom) {
            const Type* found = findType(i.nameTok, type.enclosingScope, /*lookOutside*/ true);
            if (found && found->findDependency(&type)) {
                // circular dependency
      ...",1,1,lib/symboldatabase.cpp,SymbolDatabase.createSymbolDatabaseClassInfo:void(),<empty>,,false,803,844,createSymbolDatabaseClassInfo,,,1,void()
111669153153,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::createSymbolDatabaseVariableInfo()
{
    // fill in variable info
    for (Scope& scope : scopeList) {
        // find variables
        scope.getVariableList(mSettings);
    }

    // fill in function arguments
    for (Scope& scope : scopeList) {
        for (auto func = scope.functionList.begin(); func != scope.functionList.end(); ++func) {
            // add arguments
            func->addArguments(this, &scope);
        }
    }
}",1,1,lib/symboldatabase.cpp,SymbolDatabase.createSymbolDatabaseVariableInfo:void(),<empty>,,false,847,862,createSymbolDatabaseVariableInfo,,,1,void()
111669153154,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::createSymbolDatabaseCopyAndMoveConstructors()
{
    // fill in class and struct copy/move constructors
    for (Scope& scope : scopeList) {
        if (!scope.isClassOrStruct())
            continue;

        for (auto func = scope.functionList.begin(); func != scope.functionList.end(); ++func) {
            if (!func->isConstructor() || func->minArgCount() != 1)
                continue;

            const Variable* firstArg = func->getArgumentVar(0);
            if (firstArg->type() == scope.definedType) {
                if (firstArg->isRValueReference())
                    func->type = FunctionType::eMoveConstructor;
                else if (firstArg->isReference() && !firstArg->isPointer())
                    func->type = FunctionType::eCopyConstructor;
            }

            if (func->type == FunctionType::eCopyConstructor ||
                func->type == FunctionType::eMoveConstructor)
                scope.numCopyOrMoveConstructors++;
        }
   ...",1,1,lib/symboldatabase.cpp,SymbolDatabase.createSymbolDatabaseCopyAndMoveConstructors:void(),<empty>,,false,864,888,createSymbolDatabaseCopyAndMoveConstructors,,,1,void()
111669153155,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::createSymbolDatabaseFunctionScopes()
{
    // fill in function scopes
    for (const Scope & scope : scopeList) {
        if (scope.type == ScopeType::eFunction)
            functionScopes.push_back(&scope);
    }
}",1,1,lib/symboldatabase.cpp,SymbolDatabase.createSymbolDatabaseFunctionScopes:void(),<empty>,,false,890,897,createSymbolDatabaseFunctionScopes,,,1,void()
111669153156,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::createSymbolDatabaseClassAndStructScopes()
{
    // fill in class and struct scopes
    for (const Scope& scope : scopeList) {
        if (scope.isClassOrStruct())
            classAndStructScopes.push_back(&scope);
    }
}",1,1,lib/symboldatabase.cpp,SymbolDatabase.createSymbolDatabaseClassAndStructScopes:void(),<empty>,,false,899,906,createSymbolDatabaseClassAndStructScopes,,,1,void()
111669153157,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::createSymbolDatabaseFunctionReturnTypes()
{
    // fill in function return types
    for (Scope& scope : scopeList) {
        for (auto func = scope.functionList.begin(); func != scope.functionList.end(); ++func) {
            // add return types
            if (func->retDef) {
                const Token *type = func->retDef;
                while (Token::Match(type, ""static|const|struct|union|enum""))
                    type = type->next();
                if (type) {
                    func->retType = findVariableTypeInBase(&scope, type);
                    if (!func->retType)
                        func->retType = findTypeInNested(type, func->nestedIn);
                }
            }
        }
    }
}",1,1,lib/symboldatabase.cpp,SymbolDatabase.createSymbolDatabaseFunctionReturnTypes:void(),<empty>,,false,908,926,createSymbolDatabaseFunctionReturnTypes,,,1,void()
111669153158,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::createSymbolDatabaseNeedInitialization()
{
    if (mTokenizer.isC()) {
        // For C code it is easy, as there are no constructors and no default values
        for (const Scope& scope : scopeList) {
            if (scope.definedType)
                scope.definedType->needInitialization = Type::NeedInitialization::True;
        }
    } else {
        // For C++, it is more difficult: Determine if user defined type needs initialization...
        unsigned int unknowns = 0; // stop checking when there are no unknowns
        unsigned int retry = 0;    // bail if we don't resolve all the variable types for some reason

        do {
            unknowns = 0;

            for (Scope& scope : scopeList) {
                if (!scope.isClassOrStructOrUnion())
                    continue;
                if (scope.classDef && Token::simpleMatch(scope.classDef->previous(), "">"")) // skip uninstantiated template
                    continue;

                if (!scope...",1,1,lib/symboldatabase.cpp,SymbolDatabase.createSymbolDatabaseNeedInitialization:void(),<empty>,,false,928,1029,createSymbolDatabaseNeedInitialization,,,1,void()
111669153159,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::createSymbolDatabaseVariableSymbolTable()
{
    // create variable symbol table
    mVariableList.resize(mTokenizer.varIdCount() + 1);
    std::fill_n(mVariableList.begin(), mVariableList.size(), nullptr);

    // check all scopes for variables
    for (Scope& scope : scopeList) {
        // add all variables
        for (Variable& var: scope.varlist) {
            const int varId = var.declarationId();
            if (varId)
                mVariableList[varId] = &var;
            // fix up variables without type
            if (!var.type() && !var.typeStartToken()->isStandardType()) {
                const Type *type = findType(var.typeStartToken(), &scope);
                if (type)
                    var.type(type);
            }
        }

        // add all function parameters
        for (Function& func : scope.functionList) {
            for (Variable& arg: func.argumentList) {
                // check for named parameters
                if (arg.nameTo...",1,1,lib/symboldatabase.cpp,SymbolDatabase.createSymbolDatabaseVariableSymbolTable:void(),<empty>,,false,1031,1094,createSymbolDatabaseVariableSymbolTable,,,1,void()
111669153160,METHOD,<empty>,<empty>,"[](const Scope &scope, const Token *bodyStart, const Token *bodyEnd) {
        assert(bodyStart);
        assert(bodyEnd);

        const_cast<Token *>(bodyEnd)->scope(&scope);

        for (auto* tok = const_cast<Token *>(bodyStart); tok != bodyEnd; tok = tok->next()) {
            if (bodyStart != bodyEnd && tok->str() == ""{"") {
                bool isEndOfScope = false;
                for (Scope* innerScope: scope.nestedList) {
                    const auto &list = innerScope->bodyStartList;
                    if (std::find(list.cbegin(), list.cend(), tok) != list.cend()) {     // Is begin of inner scope
                        tok = tok->link();
                        if (tok->next() == bodyEnd || !tok->next()) {
                            isEndOfScope = true;
                            break;
                        }
                        tok = tok->next();
                        break;
                    }
                }
                if (isEndOfScope)
        ...",29,5,lib/symboldatabase.cpp,"lib/symboldatabase.cpp:<global>.SymbolDatabase.createSymbolDatabaseSetScopePointers.<lambda>2:void(Scope&,Token*,Token*)",<empty>,,false,1098,1124,<lambda>2,,,1,"void(Scope&,Token*,Token*)"
111669153161,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::createSymbolDatabaseSetScopePointers()
{
    auto setScopePointers = [](const Scope &scope, const Token *bodyStart, const Token *bodyEnd) {
        assert(bodyStart);
        assert(bodyEnd);

        const_cast<Token *>(bodyEnd)->scope(&scope);

        for (auto* tok = const_cast<Token *>(bodyStart); tok != bodyEnd; tok = tok->next()) {
            if (bodyStart != bodyEnd && tok->str() == ""{"") {
                bool isEndOfScope = false;
                for (Scope* innerScope: scope.nestedList) {
                    const auto &list = innerScope->bodyStartList;
                    if (std::find(list.cbegin(), list.cend(), tok) != list.cend()) {     // Is begin of inner scope
                        tok = tok->link();
                        if (tok->next() == bodyEnd || !tok->next()) {
                            isEndOfScope = true;
                            break;
                        }
                        tok = tok->next();
                       ...",1,1,lib/symboldatabase.cpp,SymbolDatabase.createSymbolDatabaseSetScopePointers:void(),<empty>,,false,1096,1135,createSymbolDatabaseSetScopePointers,,,1,void()
111669153162,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::createSymbolDatabaseSetFunctionPointers(bool firstPass)
{
    if (firstPass) {
        // Set function definition and declaration pointers
        for (const Scope& scope: scopeList) {
            for (const Function& func: scope.functionList) {
                if (func.tokenDef)
                    const_cast<Token *>(func.tokenDef)->function(&func);

                if (func.token)
                    const_cast<Token *>(func.token)->function(&func);
            }
        }
    }

    // Set function call pointers
    const Token* inTemplateArg = nullptr;
    for (Token* tok = mTokenizer.list.front(); tok != mTokenizer.list.back(); tok = tok->next()) {
        if (inTemplateArg == nullptr && tok->link() && tok->str() == ""<"")
            inTemplateArg = tok->link();
        if (inTemplateArg == tok)
            inTemplateArg = nullptr;
        if (tok->isName() && !tok->function() && tok->varId() == 0 && ((tok->astParent() && tok->astParent()->isComparisonOp())...",1,1,lib/symboldatabase.cpp,SymbolDatabase.createSymbolDatabaseSetFunctionPointers:void(bool),<empty>,,false,1137,1206,createSymbolDatabaseSetFunctionPointers,,,1,void(bool)
111669153163,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::createSymbolDatabaseSetTypePointers()
{
    std::unordered_set<std::string> typenames;
    for (const Type &t : typeList) {
        typenames.insert(t.name());
    }

    // Set type pointers
    for (Token* tok = mTokenizer.list.front(); tok != mTokenizer.list.back(); tok = tok->next()) {
        if (!tok->isName() || tok->varId() || tok->function() || tok->type() || tok->enumerator())
            continue;

        if (Token::simpleMatch(tok->next(), ""<""))
            continue;

        if (typenames.find(tok->str()) == typenames.end())
            continue;

        const Type *type = findVariableType(tok->scope(), tok);
        if (type)
            tok->type(type);
    }
}",1,1,lib/symboldatabase.cpp,SymbolDatabase.createSymbolDatabaseSetTypePointers:void(),<empty>,,false,1208,1230,createSymbolDatabaseSetTypePointers,,,1,void()
111669153164,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::createSymbolDatabaseSetSmartPointerType()
{
    for (Scope &scope: scopeList) {
        for (Variable &var: scope.varlist) {
            if (var.valueType() && var.valueType()->smartPointerTypeToken && !var.valueType()->smartPointerType) {
                ValueType vt(*var.valueType());
                vt.smartPointerType = vt.smartPointerTypeToken->type();
                var.setValueType(vt);
            }
        }
    }
}",1,1,lib/symboldatabase.cpp,SymbolDatabase.createSymbolDatabaseSetSmartPointerType:void(),<empty>,,false,1232,1243,createSymbolDatabaseSetSmartPointerType,,,1,void()
111669153165,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::fixVarId(VarIdMap & varIds, const Token * vartok, Token * membertok, const Variable * membervar)
{
    auto varId = varIds.find(vartok->varId());
    if (varId == varIds.end()) {
        MemberIdMap memberId;
        if (membertok->varId() == 0) {
            memberId[membervar->nameToken()->varId()] = mTokenizer.newVarId();
            mVariableList.push_back(membervar);
        } else
            mVariableList[membertok->varId()] = membervar;
        varIds.emplace(vartok->varId(), memberId);
        varId = varIds.find(vartok->varId());
    }
    auto memberId = utils::as_const(varId->second).find(membervar->nameToken()->varId());
    if (memberId == varId->second.cend()) {
        if (membertok->varId() == 0) {
            varId->second.emplace(membervar->nameToken()->varId(), mTokenizer.newVarId());
            mVariableList.push_back(membervar);
            memberId = varId->second.find(membervar->nameToken()->varId());
        } else
            mVariable...",1,1,lib/symboldatabase.cpp,"SymbolDatabase.fixVarId:void(SymbolDatabase.VarIdMap&,Token*,Token*,Variable*)",<empty>,,false,1245,1269,fixVarId,,,1,"void(SymbolDatabase.VarIdMap&,Token*,Token*,Variable*)"
111669153166,METHOD,<empty>,<empty>,"[&](const Variable* membervar, Token* membertok, const Token* vartok) -> void {
        if (membervar) {
            membertok->variable(membervar);
            if (vartok && (membertok->varId() == 0 || mVariableList[membertok->varId()] == nullptr))
                fixVarId(varIds, vartok, membertok, membervar);
        }
    }",25,5,lib/symboldatabase.cpp,"lib/symboldatabase.cpp:<global>.SymbolDatabase.createSymbolDatabaseSetVariablePointers.<lambda>3:void(Variable*,Token*,Token*)",<empty>,,false,1277,1283,<lambda>3,,,1,"void(Variable*,Token*,Token*)"
111669153167,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::createSymbolDatabaseSetVariablePointers()
{
    VarIdMap varIds;

    auto setMemberVar = [&](const Variable* membervar, Token* membertok, const Token* vartok) -> void {
        if (membervar) {
            membertok->variable(membervar);
            if (vartok && (membertok->varId() == 0 || mVariableList[membertok->varId()] == nullptr))
                fixVarId(varIds, vartok, membertok, membervar);
        }
    };

    // Set variable pointers
    for (Token* tok = mTokenizer.list.front(); tok != mTokenizer.list.back(); tok = tok->next()) {
        if (!tok->isName() || tok->isKeyword() || tok->isStandardType())
            continue;
        if (tok->varId())
            tok->variable(getVariableFromVarId(tok->varId()));

        // Set Token::variable pointer for array member variable
        // Since it doesn't point at a fixed location it doesn't have varid
        const bool isVar = tok->variable() && (tok->variable()->typeScope() || tok->variable()->isSm...",1,1,lib/symboldatabase.cpp,SymbolDatabase.createSymbolDatabaseSetVariablePointers:void(),<empty>,,false,1273,1406,createSymbolDatabaseSetVariablePointers,,,1,void()
111669153168,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::createSymbolDatabaseEnums()
{
    // fill in enumerators in enum
    for (const Scope &scope : scopeList) {
        if (scope.type != ScopeType::eEnum)
            continue;

        // add enumerators to enumerator tokens
        for (const Enumerator & i : scope.enumeratorList)
            const_cast<Token *>(i.name)->enumerator(&i);
    }

    std::set<std::string> tokensThatAreNotEnumeratorValues;

    for (const Scope &scope : scopeList) {
        if (scope.type != ScopeType::eEnum)
            continue;

        for (const Enumerator & enumerator : scope.enumeratorList) {
            // look for initialization tokens that can be converted to enumerators and convert them
            if (enumerator.start) {
                if (!enumerator.end)
                    mTokenizer.syntaxError(enumerator.start);
                for (const Token * tok3 = enumerator.start; tok3 && tok3 != enumerator.end->next(); tok3 = tok3->next()) {
                    if (tok3->tok...",1,1,lib/symboldatabase.cpp,SymbolDatabase.createSymbolDatabaseEnums:void(),<empty>,,false,1408,1454,createSymbolDatabaseEnums,,,1,void()
111669153169,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::createSymbolDatabaseIncompleteVars()
{
    for (Token* tok = mTokenizer.list.front(); tok != mTokenizer.list.back(); tok = tok->next()) {
        const Scope * scope = tok->scope();
        if (!scope)
            continue;
        if (!scope->isExecutable())
            continue;
        if (tok->varId() != 0)
            continue;
        if (tok->isCast() && !isCPPCast(tok) && tok->link() && tok->str() == ""("") {
            tok = tok->link();
            continue;
        }
        if (tok->isCpp()) {
            if (Token::Match(tok, ""catch|typeid ("") ||
                Token::Match(tok, ""static_cast|dynamic_cast|const_cast|reinterpret_cast"")) {
                tok = tok->linkAt(1);
                continue;
            }
            if (tok->str() == ""using"") {
                tok = Token::findsimplematch(tok, "";"");
                continue;
            }
        }
        if (tok->str() == ""NULL"")
            continue;
        if (tok->isKeyword() || !tok-...",1,1,lib/symboldatabase.cpp,SymbolDatabase.createSymbolDatabaseIncompleteVars:void(),<empty>,,false,1456,1524,createSymbolDatabaseIncompleteVars,,,1,void()
111669153170,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::createSymbolDatabaseEscapeFunctions()
{
    for (const Scope& scope : scopeList) {
        if (scope.type != ScopeType::eFunction)
            continue;
        Function * function = scope.function;
        if (!function)
            continue;
        if (Token::findsimplematch(scope.bodyStart, ""return"", scope.bodyEnd))
            continue;
        function->isEscapeFunction(isReturnScope(scope.bodyEnd, mSettings.library, nullptr, true));
    }
}",1,1,lib/symboldatabase.cpp,SymbolDatabase.createSymbolDatabaseEscapeFunctions:void(),<empty>,,false,1526,1538,createSymbolDatabaseEscapeFunctions,,,1,void()
111669153171,METHOD,<empty>,<empty>,"[&](const Token* tok2) {
            const Variable* var = tok2->variable();
            if (!var)
                return false;
            return var->nameToken() == tok2;
        }",48,9,lib/symboldatabase.cpp,lib/symboldatabase.cpp:<global>.isExpression.<lambda>4:bool(Token*),<empty>,,false,1550,1555,<lambda>4,,,1,bool(Token*)
111669153172,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static bool isExpression(const Token* tok)
{
    if (!tok)
        return false;
    if (Token::simpleMatch(tok, ""{"") && tok->scope() && tok->scope()->bodyStart != tok &&
        (tok->astOperand1() || tok->astOperand2()))
        return true;
    if (!Token::Match(tok, ""(|.|[|::|?|:|++|--|%cop%|%assign%""))
        return false;
    if (Token::Match(tok, ""*|&|&&"")) {
        const Token* vartok = findAstNode(tok, [&](const Token* tok2) {
            const Variable* var = tok2->variable();
            if (!var)
                return false;
            return var->nameToken() == tok2;
        });
        if (vartok)
            return false;
    }
    return true;
}",1,1,lib/symboldatabase.cpp,isExpression:bool(Token*),<empty>,,false,1540,1560,isExpression,,,1,bool(Token*)
111669153173,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static std::string getIncompleteNameID(const Token* tok)
{
    std::string result = tok->str() + ""@"";
    while (Token::Match(tok->astParent(), "".|::""))
        tok = tok->astParent();
    return result + tok->expressionString();
}",1,1,lib/symboldatabase.cpp,getIncompleteNameID:string(Token*),<empty>,,false,1562,1568,getIncompleteNameID,,,1,string(Token*)
111669153174,METHOD,ExprIdKey,TYPE_DECL,"bool operator<(const ExprIdKey& k) const {
            return std::tie(parentOp, operand1, operand2) < std::tie(k.parentOp, k.operand1, k.operand2);
        }",9,9,lib/symboldatabase.cpp,ExprIdKey.<<const>:bool(ExprIdKey&),<empty>,,false,1575,1577,<,,,4,bool(ExprIdKey&)
111669153175,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void setParentExprId(Token* tok, ExprIdMap& exprIdMap, nonneg int &id) {
        for (;;) {
            if (!tok->astParent() || tok->astParent()->isControlFlowKeyword())
                break;
            const Token* op1 = tok->astParent()->astOperand1();
            if (op1 && op1->exprId() == 0 && !Token::Match(op1, ""[{[]""))
                break;
            const Token* op2 = tok->astParent()->astOperand2();
            if (op2 && op2->exprId() == 0 &&
                !((tok->astParent()->astParent() && tok->astParent()->isAssignmentOp() && tok->astParent()->astParent()->isAssignmentOp()) ||
                  isLambdaCaptureList(op2) ||
                  (op2->str() == ""("" && isLambdaCaptureList(op2->astOperand1())) ||
                  Token::simpleMatch(op2, ""{ }"") ||
                  (Token::simpleMatch(tok->astParent(), ""["") && op2->str() == ""{"")))
                break;

            if (tok->astParent()->isExpandedMacro() || Token::Match(tok->astParent(), ""++|--"")) {
   ...",5,59,lib/symboldatabase.cpp,"setParentExprId:void(Token*,ExprIdMap&,int&)",<empty>,,false,1580,1660,setParentExprId,,,1,"void(Token*,ExprIdMap&,int&)"
111669153176,METHOD,<empty>,<empty>,"[](const Scope* scope) {
        return scope && (scope->type == ScopeType::eLambda || scope->type == ScopeType::eNamespace);
    }",124,5,lib/symboldatabase.cpp,lib/symboldatabase.cpp:<global>.SymbolDatabase.createSymbolDatabaseExprIds.<lambda>5:bool(Scope*),<empty>,,false,1696,1698,<lambda>5,,,1,bool(Scope*)
111669153177,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::createSymbolDatabaseExprIds()
{
    // Find highest varId
    nonneg int maximumVarId = 0;
    for (const Token* tok = mTokenizer.list.front(); tok; tok = tok->next()) {
        maximumVarId = std::max(tok->varId(), maximumVarId);
    }
    nonneg int id = maximumVarId + 1;
    // Find incomplete vars that are used in constant context
    std::unordered_map<std::string, nonneg int> unknownConstantIds;
    const Token* inConstExpr = nullptr;
    for (const Token* tok = mTokenizer.list.front(); tok != mTokenizer.list.back(); tok = tok->next()) {
        if (Token::Match(tok, ""decltype|sizeof|typeof ("") && tok->linkAt(1)) {
            tok = tok->linkAt(1)->previous();
        } else if (tok == inConstExpr) {
            inConstExpr = nullptr;
        } else if (inConstExpr) {
            if (!tok->isIncompleteVar())
                continue;
            if (!isExpression(tok->astParent()))
                continue;
            const std::string& name = getIncomple...",1,4,lib/symboldatabase.cpp,SymbolDatabase.createSymbolDatabaseExprIds:void(),<empty>,,false,1663,1787,createSymbolDatabaseExprIds,,,1,void()
111669153178,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::setArrayDimensionsUsingValueFlow()
{
    // set all unknown array dimensions
    for (const Variable *var : mVariableList) {
        // check each array variable
        if (!var || !var->isArray())
            continue;
        // check each array dimension
        for (const Dimension &const_dimension : var->dimensions()) {
            auto &dimension = const_cast<Dimension &>(const_dimension);
            if (dimension.num != 0 || !dimension.tok)
                continue;

            if (Token::Match(dimension.tok->previous(), ""[<,]"")) {
                if (dimension.known)
                    continue;
                if (!Token::Match(dimension.tok->previous(), ""[<,]""))
                    continue;

                // In template arguments, there might not be AST
                // Determine size by using the ""raw tokens""
                TokenList tokenList(&mSettings);
                tokenList.setLang(dimension.tok->isCpp() ? Standards::Language::CPP : ...",1,1,lib/symboldatabase.cpp,SymbolDatabase.setArrayDimensionsUsingValueFlow:void(),<empty>,,false,1789,1888,setArrayDimensionsUsingValueFlow,,,1,void()
111669153179,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"SymbolDatabase::~SymbolDatabase()
{
    // Clear scope, type, function and variable pointers
    for (Token* tok = mTokenizer.list.front(); tok; tok = tok->next()) {
        tok->scope(nullptr);
        tok->type(nullptr);
        tok->function(nullptr);
        tok->variable(nullptr);
        tok->enumerator(nullptr);
        tok->setValueType(nullptr);
    }
}",1,1,lib/symboldatabase.cpp,SymbolDatabase.~SymbolDatabase:ANY(),<empty>,,false,1890,1901,~SymbolDatabase,,,1,ANY()
111669153180,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool SymbolDatabase::isFunction(const Token *tok, const Scope* outerScope, const Token *&funcStart, const Token *&argStart, const Token*& declEnd) const
{
    if (tok->varId())
        return false;

    // function returning function pointer? '... ( ... %name% ( ... ))( ... ) {'
    // function returning reference to array '... ( & %name% ( ... ))[ ... ] {'
    // TODO: Activate this again
    if ((false) && tok->str() == ""("" && tok->strAt(1) != ""*"" && // NOLINT(readability-simplify-boolean-expr)
        (tok->link()->strAt(-1) == "")"" || Token::simpleMatch(tok->link()->tokAt(-2), "") const""))) {
        const Token* tok2 = tok->link()->next();
        if (tok2 && tok2->str() == ""("" && Token::Match(tok2->link()->next(), ""{|;|const|="")) {
            const Token* argStartTok;
            if (tok->link()->strAt(-1) == ""const"")
                argStartTok = tok->link()->linkAt(-2);
            else
                argStartTok = tok->link()->linkAt(-1);
            funcStart = argStartTo...",1,1,lib/symboldatabase.cpp,"SymbolDatabase.isFunction<const>:bool(Token*,Scope*,Token*&,Token*&,Token*&)",<empty>,,false,1903,2100,isFunction,,,1,"bool(Token*,Scope*,Token*&,Token*&,Token*&)"
111669153181,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::validateExecutableScopes() const
{
    const std::size_t functions = functionScopes.size();
    for (std::size_t i = 0; i < functions; ++i) {
        const Scope* const scope = functionScopes[i];
        const Function* const function = scope->function;
        if (scope->isExecutable() && !function) {
            const std::list<const Token*> callstack(1, scope->classDef);
            const std::string msg = std::string(""Executable scope '"") + scope->classDef->str() + ""' with unknown function."";
            const ErrorMessage errmsg(callstack, &mTokenizer.list, Severity::debug,
                                      ""symbolDatabaseWarning"",
                                      msg,
                                      Certainty::normal);
            mErrorLogger.reportErr(errmsg);
        }
    }
}",1,1,lib/symboldatabase.cpp,SymbolDatabase.validateExecutableScopes<const>:void(),<empty>,,false,2102,2118,validateExecutableScopes,,,1,void()
111669153182,METHOD,<empty>,<empty>,"[&](const Function& function) {
                for (nonneg int arg = 0; arg < function.argCount(); ++arg) {
                    if (var == function.getArgumentVar(arg))
                        return true;
                }
                return false;
            }",92,21,lib/symboldatabase.cpp,lib/symboldatabase.cpp:<global>.getFunctionForArgumentvariable.<lambda>6:bool(Function&),<empty>,,false,2124,2130,<lambda>6,,,1,bool(Function&)
111669153183,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Function* getFunctionForArgumentvariable(const Variable * const var)
    {
        if (const Scope* scope = var->nameToken()->scope()) {
            auto it = std::find_if(scope->functionList.begin(), scope->functionList.end(), [&](const Function& function) {
                for (nonneg int arg = 0; arg < function.argCount(); ++arg) {
                    if (var == function.getArgumentVar(arg))
                        return true;
                }
                return false;
            });
            if (it != scope->functionList.end())
                return &*it;
        }
        return nullptr;
    }",5,21,lib/symboldatabase.cpp,getFunctionForArgumentvariable:Function*(Variable*),<empty>,,false,2121,2135,getFunctionForArgumentvariable,,,1,Function*(Variable*)
111669153184,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::validateVariables() const
{
    for (auto iter = mVariableList.cbegin(); iter!=mVariableList.cend(); ++iter) {
        const Variable * const var = *iter;
        if (var) {
            if (!var->scope()) {
                const Function* function = getFunctionForArgumentvariable(var);
                if (!var->isArgument() || (!function || function->hasBody())) { // variables which only appear in a function declaration do not have a scope
                    throw InternalError(var->nameToken(), ""Analysis failed (variable without scope). If the code is valid then please report this failure."", InternalError::INTERNAL);
                }
            }
        }
    }
}",1,1,lib/symboldatabase.cpp,SymbolDatabase.validateVariables<const>:void(),<empty>,,false,2138,2151,validateVariables,,,1,void()
111669153185,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::validate() const
{
    if (mSettings.debugwarnings) {
        validateExecutableScopes();
    }
    validateVariables();
}",1,1,lib/symboldatabase.cpp,SymbolDatabase.validate<const>:void(),<empty>,,false,2153,2159,validate,,,1,void()
111669153186,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::clangSetVariables(const std::vector<const Variable *> &variableList)
{
    mVariableList = variableList;
}",1,1,lib/symboldatabase.cpp,SymbolDatabase.clangSetVariables:void(std.vector<constVariable*>&),<empty>,,false,2161,2164,clangSetVariables,,,1,void(std.vector<constVariable*>&)
111669153187,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::debugSymbolDatabase() const
{
    if (!mSettings.debugnormal && !mSettings.debugwarnings)
        return;
    for (const Token* tok = mTokenizer.list.front(); tok != mTokenizer.list.back(); tok = tok->next()) {
        if (tok->astParent() && tok->astParent()->getTokenDebug() == tok->getTokenDebug())
            continue;
        if (tok->getTokenDebug() == TokenDebug::ValueType) {

            std::string msg = ""Value type is "";
            ErrorPath errorPath;
            if (tok->valueType()) {
                msg += tok->valueType()->str();
                errorPath.insert(errorPath.end(), tok->valueType()->debugPath.cbegin(), tok->valueType()->debugPath.cend());

            } else {
                msg += ""missing"";
            }
            errorPath.emplace_back(tok, """");
            mErrorLogger.reportErr(
                {errorPath, &mTokenizer.list, Severity::debug, ""valueType"", msg, CWE{0}, Certainty::normal});
        }
    }
}",1,1,lib/symboldatabase.cpp,SymbolDatabase.debugSymbolDatabase<const>:void(),<empty>,,false,2166,2189,debugSymbolDatabase,,,1,void()
111669153188,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"Variable::Variable(const Token *name_, const std::string &clangType, const Token *typeStart,
                   const Token *typeEnd, nonneg int index_, AccessControl access_,
                   const Type *type_, const Scope *scope_)
    : mNameToken(name_),
    mTypeStartToken(typeStart),
    mTypeEndToken(typeEnd),
    mIndex(index_),
    mAccess(access_),
    mFlags(0),
    mType(type_),
    mScope(scope_)
{
    if (!mTypeStartToken && mTypeEndToken) {
        mTypeStartToken = mTypeEndToken;
        while (Token::Match(mTypeStartToken->previous(), ""%type%|*|&""))
            mTypeStartToken = mTypeStartToken->previous();
    }

    while (Token::Match(mTypeStartToken, ""const|struct|static"")) {
        if (mTypeStartToken->str() == ""static"")
            setFlag(fIsStatic, true);
        mTypeStartToken = mTypeStartToken->next();
    }

    if (Token::simpleMatch(mTypeEndToken, ""&""))
        setFlag(fIsReference, true);
    else if (Token::simpleMatch(mTypeEndToken, ""&&"")) {
     ...",1,41,lib/symboldatabase.cpp,"Variable.Variable:ANY(Token*,std.string&,Token*,Token*,int,AccessControl,Type*,Scope*)",<empty>,,false,2191,2246,Variable,,,1,"Variable.Variable:ANY(Token*,std.string&,Token*,Token*,int,AccessControl,Type*,Scope*)(Token*,std.string&,Token*,Token*,int,AccessControl,Type*,Scope*)"
111669153189,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"Variable::Variable(const Variable &var, const Scope *scope)
{
    *this = var;
    mScope = scope;
}",1,1,lib/symboldatabase.cpp,"Variable.Variable:ANY(Variable&,Scope*)",<empty>,,false,2248,2252,Variable,,,1,"ANY(Variable&,Scope*)"
111669153190,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"Variable::Variable(const Variable &var)
{
    *this = var;
}",1,1,lib/symboldatabase.cpp,Variable.Variable:ANY(Variable&),<empty>,,false,2254,2257,Variable,,,1,ANY(Variable&)
111669153191,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"Variable::~Variable()
{
    delete mValueType;
}",1,1,lib/symboldatabase.cpp,Variable.~Variable:ANY(),<empty>,,false,2259,2262,~Variable,,,1,ANY()
111669153192,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"Variable& Variable::operator=(const Variable &var) &
{
    if (this == &var)
        return *this;

    ValueType* vt = nullptr;
    if (var.mValueType)
        vt = new ValueType(*var.mValueType);

    mNameToken = var.mNameToken;
    mTypeStartToken = var.mTypeStartToken;
    mTypeEndToken = var.mTypeEndToken;
    mIndex = var.mIndex;
    mAccess = var.mAccess;
    mFlags = var.mFlags;
    mType = var.mType;
    mScope = var.mScope;
    mDimensions = var.mDimensions;
    delete mValueType;
    mValueType = vt;

    return *this;
}",1,1,lib/symboldatabase.cpp,Variable.=:Variable&(Variable&),<empty>,,false,2264,2286,=,,,1,Variable&(Variable&)
111669153193,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Variable::isMember() const {
    return mScope && mScope->isClassOrStructOrUnion();
}",1,1,lib/symboldatabase.cpp,Variable.isMember<const>:bool(),<empty>,,false,2288,2290,isMember,,,1,bool()
111669153194,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Variable::isPointerArray() const
{
    return isArray() && nameToken() && nameToken()->previous() && (nameToken()->strAt(-1) == ""*"");
}",1,1,lib/symboldatabase.cpp,Variable.isPointerArray<const>:bool(),<empty>,,false,2292,2295,isPointerArray,,,1,bool()
111669153195,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Variable::isUnsigned() const
{
    return mValueType ? (mValueType->sign == ValueType::Sign::UNSIGNED) : mTypeStartToken->isUnsigned();
}",1,1,lib/symboldatabase.cpp,Variable.isUnsigned<const>:bool(),<empty>,,false,2297,2300,isUnsigned,,,1,bool()
111669153196,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Token * Variable::declEndToken() const
{
    Token const * declEnd = typeStartToken();
    if (declEnd->tokAt(-1) && Token::simpleMatch(declEnd->tokAt(-2), ""for (""))
        declEnd = nameToken();
    while (declEnd && !Token::Match(declEnd, ""[;:,)={]"")) {
        if (declEnd->link() && Token::Match(declEnd,""(|[|<""))
            declEnd = declEnd->link();
        declEnd = declEnd->next();
    }
    return declEnd;
}",1,1,lib/symboldatabase.cpp,Variable.declEndToken<const>:Token*(),<empty>,,false,2302,2313,declEndToken,,,1,Token*()
111669153197,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void Variable::evaluate(const Settings& settings)
{
    // Is there initialization in variable declaration
    const Token *initTok = mNameToken ? mNameToken->next() : nullptr;
    while (Token::Match(initTok, ""["")) {
        initTok = initTok->link()->next();
        if (Token::simpleMatch(initTok, "")""))
            initTok = initTok->next();
    }
    if (Token::Match(initTok, ""[={(]"") || (initTok && initTok->isSplittedVarDeclEq()))
        setFlag(fIsInit, true);

    const Library & lib = settings.library;

    bool isContainer = false;
    if (mNameToken)
        setFlag(fIsArray, arrayDimensions(settings, isContainer));

    if (mTypeStartToken)
        setValueType(ValueType::parseDecl(mTypeStartToken,settings));

    const Token* tok = mTypeStartToken;
    while (tok && tok->previous() && tok->previous()->isName())
        tok = tok->previous();
    const Token* end = mTypeEndToken;
    if (end)
        end = end->next();
    while (tok != end) {
        if (tok->str() == ""s...",1,1,lib/symboldatabase.cpp,Variable.evaluate:void(Settings&),<empty>,,false,2315,2426,evaluate,,,1,void(Settings&)
111669153198,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void Variable::setValueType(const ValueType &valueType)
{
    if (valueType.type == ValueType::Type::UNKNOWN_TYPE) {
        const Token *declType = Token::findsimplematch(mTypeStartToken, ""decltype ("", mTypeEndToken);
        if (declType && !declType->next()->valueType())
            return;
    }
    auto* vt = new ValueType(valueType);
    delete mValueType;
    mValueType = vt;
    if ((mValueType->pointer > 0) && (!isArray() || Token::Match(mNameToken->previous(), ""( * %name% )"")))
        setFlag(fIsPointer, true);
    setFlag(fIsConst, mValueType->constness & (1U << mValueType->pointer));
    setFlag(fIsVolatile, mValueType->volatileness & (1U << mValueType->pointer));
    if (mValueType->smartPointerType)
        setFlag(fIsSmartPointer, true);
}",1,1,lib/symboldatabase.cpp,Variable.setValueType:void(ValueType&),<empty>,,false,2428,2444,setValueType,,,1,void(ValueType&)
111669153199,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Type* Variable::smartPointerType() const
{
    if (!isSmartPointer())
        return nullptr;

    if (mValueType->smartPointerType)
        return mValueType->smartPointerType;

    // TODO: Cache result, handle more complex type expression
    const Token* typeTok = typeStartToken();
    while (Token::Match(typeTok, ""%name%|::""))
        typeTok = typeTok->next();
    if (Token::Match(typeTok, ""< %name% >"")) {
        // cppcheck-suppress shadowFunction - TODO: fix this
        const Scope* scope = typeTok->scope();
        const Type* ptrType{};
        while (scope && !ptrType) {
            ptrType = scope->findType(typeTok->strAt(1));
            scope = scope->nestedIn;
        }
        return ptrType;
    }
    return nullptr;
}",1,1,lib/symboldatabase.cpp,Variable.smartPointerType<const>:Type*(),<empty>,,false,2446,2469,smartPointerType,,,1,Type*()
111669153200,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Type* Variable::iteratorType() const
{
    if (!mValueType || mValueType->type != ValueType::ITERATOR)
        return nullptr;

    if (mValueType->containerTypeToken)
        return mValueType->containerTypeToken->type();

    return nullptr;
}",1,1,lib/symboldatabase.cpp,Variable.iteratorType<const>:Type*(),<empty>,,false,2471,2480,iteratorType,,,1,Type*()
111669153201,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Variable::isStlStringViewType() const
{
    return getFlag(fIsStlType) && valueType() && valueType()->container && valueType()->container->stdStringLike && valueType()->container->view;
}",1,1,lib/symboldatabase.cpp,Variable.isStlStringViewType<const>:bool(),<empty>,,false,2482,2485,isStlStringViewType,,,1,bool()
111669153202,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"std::string Variable::getTypeName() const
{
    std::string ret;
    // TODO: For known types, generate the full type name
    for (const Token *typeTok = mTypeStartToken; Token::Match(typeTok, ""%name%|::"") && typeTok->varId() == 0; typeTok = typeTok->next()) {
        ret += typeTok->str();
        if (Token::simpleMatch(typeTok->next(), ""<"") && typeTok->linkAt(1)) // skip template arguments
            typeTok = typeTok->linkAt(1);
    }
    return ret;
}",1,1,lib/symboldatabase.cpp,Variable.getTypeName<const>:string(),<empty>,,false,2487,2497,getTypeName,,,1,string()
111669153203,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static bool isOperator(const Token *tokenDef)
{
    if (!tokenDef)
        return false;
    if (tokenDef->isOperatorKeyword())
        return true;
    const std::string &name = tokenDef->str();
    return name.size() > 8 && startsWith(name,""operator"") && std::strchr(""+-*/%&|~^<>!=[("", name[8]);
}",1,1,lib/symboldatabase.cpp,isOperator:bool(Token*),<empty>,,false,2499,2507,isOperator,,,1,bool(Token*)
111669153204,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static bool isTrailingReturnType(const Token* tok)
{
    while (tok && tok->isKeyword())
        tok = tok->next();
    return Token::Match(tok, ""&|&&| ."");
}",1,1,lib/symboldatabase.cpp,isTrailingReturnType:bool(Token*),<empty>,,false,2509,2514,isTrailingReturnType,,,1,bool(Token*)
111669153205,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"Function::Function(const Token *tok,
                   const Scope *scope,
                   const Token *tokDef,
                   const Token *tokArgDef)
    : tokenDef(tokDef),
    argDef(tokArgDef),
    nestedIn(scope)
{
    // operator function
    if (::isOperator(tokenDef)) {
        isOperator(true);

        // 'operator =' is special
        if (tokenDef->str() == ""operator="")
            type = FunctionType::eOperatorEqual;
    }

    else if (tokenDef->str() == ""["") {
        type = FunctionType::eLambda;
    }

    // class constructor/destructor
    else if (scope->isClassOrStructOrUnion() &&
             ((tokenDef->str() == scope->className) ||
              (tokenDef->str().substr(0, scope->className.size()) == scope->className &&
               tokenDef->str().size() > scope->className.size() + 1 &&
               tokenDef->str()[scope->className.size() + 1] == '<'))) {
        // destructor
        if (tokenDef->strAt(-1) == ""~"") {
            type = FunctionTy...",1,1,lib/symboldatabase.cpp,"Function.Function:ANY(Token*,Scope*,Token*,Token*)",<empty>,,false,2516,2626,Function,,,1,"Function.Function:ANY(Token*,Scope*,Token*,Token*)(Token*,Scope*,Token*,Token*)"
111669153206,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"Function::Function(const Token *tokenDef, const std::string &clangType)
    : tokenDef(tokenDef)
{
    // operator function
    if (::isOperator(tokenDef)) {
        isOperator(true);

        // 'operator =' is special
        if (tokenDef->str() == ""operator="")
            type = FunctionType::eOperatorEqual;
    }

    setFlags(tokenDef, tokenDef->scope());

    if (endsWith(clangType, "" const""))
        isConst(true);
}",1,1,lib/symboldatabase.cpp,"Function.Function:ANY(Token*,std.string&)",<empty>,,false,2628,2644,Function,,,1,"Function.Function:ANY(Token*,std.string&)(Token*,std.string&)"
111669153207,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Token *Function::setFlags(const Token *tok1, const Scope *scope)
{
    if (tok1->isInline())
        isInlineKeyword(true);

    if (tok1->isExternC())
        isExtern(true);

    // look for end of previous statement
    while (tok1->previous() && !Token::Match(tok1->previous(), "";|}|{|public:|protected:|private:"")) {
        tok1 = tok1->previous();

        if (tok1->isInline())
            isInlineKeyword(true);

        // extern function
        if (tok1->str() == ""extern"") {
            isExtern(true);
        }

        // virtual function
        else if (tok1->str() == ""virtual"") {
            hasVirtualSpecifier(true);
        }

        // static function
        else if (tok1->str() == ""static"") {
            isStatic(true);
            if (scope->type == ScopeType::eNamespace || scope->type == ScopeType::eGlobal)
                isStaticLocal(true);
        }

        // friend function
        else if (tok1->str() == ""friend"") {
            isFriend(true);
    ...",1,1,lib/symboldatabase.cpp,"Function.setFlags:Token*(Token*,Scope*)",<empty>,,false,2646,2703,setFlags,,,1,"Token*(Token*,Scope*)"
111669153208,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"std::string Function::fullName() const
{
    std::string ret = name();
    for (const Scope *s = nestedIn; s; s = s->nestedIn) {
        if (!s->className.empty())
            ret = s->className + ""::"" + ret;
    }
    ret += ""("";
    for (const Variable &a : argumentList)
        ret += (a.index() == 0 ? """" : "","") + a.name();
    return ret + "")"";
}",1,1,lib/symboldatabase.cpp,Function.fullName<const>:string(),<empty>,,false,2705,2716,fullName,,,1,string()
111669153209,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static std::string qualifiedName(const Scope *scope)
{
    std::string name = scope->className;
    while (scope->nestedIn) {
        if (!scope->nestedIn->className.empty())
            name = (scope->nestedIn->className + "" :: "") + name;
        scope = scope->nestedIn;
    }
    return name;
}",1,1,lib/symboldatabase.cpp,qualifiedName:string(Scope*),<empty>,,false,2718,2727,qualifiedName,,,1,string(Scope*)
111669153210,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static bool usingNamespace(const Scope *scope, const Token *first, const Token *second, int &offset)
{
    // check if qualifications match first before checking if using is needed
    const Token *tok1 = first;
    const Token *tok2 = second;
    bool match = false;
    while (Token::Match(tok1, ""%type% :: %type%"") && Token::Match(tok2, ""%type% :: %type%"")) {
        if (tok1->str() == tok2->str()) {
            tok1 = tok1->tokAt(2);
            tok2 = tok2->tokAt(2);
            match = true;
        } else {
            match = false;
            break;
        }
    }

    if (match)
        return false;

    offset = 0;
    std::string name = first->str();

    while (Token::Match(first, ""%type% :: %type%"")) {
        if (offset)
            name += ("" :: "" + first->str());
        offset += 2;
        first = first->tokAt(2);
        if (first->str() == second->str()) {
            break;
        }
    }

    if (offset) {
        while (scope) {
            for (const auto ...",1,1,lib/symboldatabase.cpp,"usingNamespace:bool(Scope*,Token*,Token*,int&)",<empty>,,false,2729,2788,usingNamespace,,,1,"bool(Scope*,Token*,Token*,int&)"
111669153211,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static bool typesMatch(
    const Scope *first_scope,
    const Token *first_token,
    const Scope *second_scope,
    const Token *second_token,
    const Token *&new_first,
    const Token *&new_second)
{
    // get first type
    const Type* first_type = first_scope->check->findType(first_token, first_scope, /*lookOutside*/ true);
    if (first_type) {
        // get second type
        const Type* second_type = second_scope->check->findType(second_token, second_scope, /*lookOutside*/ true);
        // check if types match
        if (first_type == second_type) {
            const Token* tok1 = first_token;
            while (tok1 && tok1->str() != first_type->name())
                tok1 = tok1->next();
            const Token *tok2 = second_token;
            while (tok2 && tok2->str() != second_type->name())
                tok2 = tok2->next();
            // update parser token positions
            if (tok1 && tok2) {
                new_first = tok1->previous();
           ...",1,1,lib/symboldatabase.cpp,"typesMatch:bool(Scope*,Token*,Scope*,Token*,Token*&,Token*&)",<empty>,,false,2790,2820,typesMatch,,,1,"bool(Scope*,Token*,Scope*,Token*,Token*&,Token*&)"
111669153212,METHOD,<empty>,<empty>,"[](const Token* start) -> const Token* {
        const Token* tok = start->next();
        if (Token::simpleMatch(tok, ""const"")) {
            tok = tok->next();
            while (Token::Match(tok, ""%name%|%type%|::""))
                tok = tok->next();
            if (Token::Match(tok, "",|)|=""))
                return start->next();
        }
        return start;
    }",30,5,lib/symboldatabase.cpp,lib/symboldatabase.cpp:<global>.Function.argsMatch<const>.<lambda>7:Token(Token*),<empty>,,false,2836,2846,<lambda>7,,,1,Token(Token*)
111669153213,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Function::argsMatch(const Scope *scope, const Token *first, const Token *second, const std::string &path, nonneg int path_length) const
{
    if (!first->isCpp()) // C does not support overloads
        return true;

    int arg_path_length = path_length;
    int offset = 0;
    int openParen = 0;

    // check for () == (void) and (void) == ()
    if ((Token::simpleMatch(first, ""( )"") && Token::simpleMatch(second, ""( void )"")) ||
        (Token::simpleMatch(first, ""( void )"") && Token::simpleMatch(second, ""( )"")))
        return true;

    auto skipTopLevelConst = [](const Token* start) -> const Token* {
        const Token* tok = start->next();
        if (Token::simpleMatch(tok, ""const"")) {
            tok = tok->next();
            while (Token::Match(tok, ""%name%|%type%|::""))
                tok = tok->next();
            if (Token::Match(tok, "",|)|=""))
                return start->next();
        }
        return start;
    };

    while (first->str() == second->str() &&...",1,111,lib/symboldatabase.cpp,"Function.argsMatch<const>:bool(Scope*,Token*,Token*,std.string&,int)",<empty>,,false,2822,3061,argsMatch,,,1,"bool(Scope*,Token*,Token*,std.string&,int)"
111669153214,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static bool isUnknownType(const Token* start, const Token* end)
{
    while (Token::Match(start, ""const|volatile""))
        start = start->next();
    start = skipScopeIdentifiers(start);
    if (start->tokAt(1) == end && !start->type() && !start->isStandardType())
        return true;
    // TODO: Try to deduce the type of the expression
    if (Token::Match(start, ""decltype|typeof""))
        return true;
    return false;
}",1,1,lib/symboldatabase.cpp,"isUnknownType:bool(Token*,Token*)",<empty>,,false,3063,3074,isUnknownType,,,1,"bool(Token*,Token*)"
111669153215,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static const Token* getEnableIfReturnType(const Token* start)
{
    if (!start)
        return nullptr;
    for (const Token* tok = start->next(); precedes(tok, start->link()); tok = tok->next()) {
        if (tok->link() && Token::Match(tok, ""(|[|{|<"")) {
            tok = tok->link();
            continue;
        }
        if (Token::simpleMatch(tok, "",""))
            return tok->next();
    }
    return nullptr;
}",1,1,lib/symboldatabase.cpp,getEnableIfReturnType:Token*(Token*),<empty>,,false,3076,3089,getEnableIfReturnType,,,1,Token*(Token*)
111669153216,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static bool checkReturns(const Function* function, bool unknown, bool emptyEnableIf, Predicate pred)
{
    if (!function)
        return false;
    if (function->type != FunctionType::eFunction && function->type != FunctionType::eOperatorEqual && function->type != FunctionType::eLambda)
        return false;
    const Token* defStart = function->retDef;
    if (!defStart)
        return unknown;
    const Token* defEnd = function->returnDefEnd();
    if (!defEnd)
        return unknown;
    if (defEnd == defStart)
        return unknown;
    if (pred(defStart, defEnd))
        return true;
    if (Token::Match(defEnd->tokAt(-1), ""*|&|&&""))
        return false;
    // void STDCALL foo()
    while (defEnd->previous() != defStart && Token::Match(defEnd->tokAt(-2), ""%name%|> %name%"") &&
           !Token::Match(defEnd->tokAt(-2), ""const|volatile""))
        defEnd = defEnd->previous();
    // enable_if
    const Token* enableIfEnd = nullptr;
    if (Token::simpleMatch(defEnd->previous()...",1,1,lib/symboldatabase.cpp,"checkReturns:bool(Function*,bool,bool,Predicate)",<empty>,,false,3092,3135,checkReturns,,,1,"bool(Function*,bool,bool,Predicate)"
111669153217,METHOD,<empty>,<empty>,"[](const Token* defStart, const Token* defEnd) {
        return Token::findsimplematch(defStart, ""const"", defEnd);
    }",51,5,lib/symboldatabase.cpp,"lib/symboldatabase.cpp:<global>.Function.returnsConst.<lambda>8:ANY(Token*,Token*)",<empty>,,false,3139,3141,<lambda>8,,,1,"ANY(Token*,Token*)"
111669153218,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Function::returnsConst(const Function* function, bool unknown)
{
    return checkReturns(function, unknown, false, [](const Token* defStart, const Token* defEnd) {
        return Token::findsimplematch(defStart, ""const"", defEnd);
    });
}",1,1,lib/symboldatabase.cpp,"Function.returnsConst:bool(Function*,bool)",<empty>,,false,3137,3142,returnsConst,,,1,"bool(Function*,bool)"
111669153219,METHOD,<empty>,<empty>,"[includeRValueRef](const Token* /*defStart*/, const Token* defEnd) {
        return includeRValueRef ? Token::Match(defEnd->previous(), ""&|&&"") : Token::simpleMatch(defEnd->previous(), ""&"");
    }",51,5,lib/symboldatabase.cpp,"lib/symboldatabase.cpp:<global>.Function.returnsReference.<lambda>9:ANY(Token*,Token*)",<empty>,,false,3146,3148,<lambda>9,,,1,"ANY(Token*,Token*)"
111669153220,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Function::returnsReference(const Function* function, bool unknown, bool includeRValueRef)
{
    return checkReturns(function, unknown, false, [includeRValueRef](const Token* /*defStart*/, const Token* defEnd) {
        return includeRValueRef ? Token::Match(defEnd->previous(), ""&|&&"") : Token::simpleMatch(defEnd->previous(), ""&"");
    });
}",1,1,lib/symboldatabase.cpp,"Function.returnsReference:bool(Function*,bool,bool)",<empty>,,false,3144,3149,returnsReference,,,1,"bool(Function*,bool,bool)"
111669153221,METHOD,<empty>,<empty>,"[](const Token* /*defStart*/, const Token* defEnd) {
        return Token::simpleMatch(defEnd->previous(), ""*"");
    }",51,5,lib/symboldatabase.cpp,"lib/symboldatabase.cpp:<global>.Function.returnsPointer.<lambda>10:ANY(Token*,Token*)",<empty>,,false,3153,3155,<lambda>10,,,1,"ANY(Token*,Token*)"
111669153222,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Function::returnsPointer(const Function* function, bool unknown)
{
    return checkReturns(function, unknown, false, [](const Token* /*defStart*/, const Token* defEnd) {
        return Token::simpleMatch(defEnd->previous(), ""*"");
    });
}",1,1,lib/symboldatabase.cpp,"Function.returnsPointer:bool(Function*,bool)",<empty>,,false,3151,3156,returnsPointer,,,1,"bool(Function*,bool)"
111669153223,METHOD,<empty>,<empty>,"[](const Token* /*defStart*/, const Token* defEnd) {
        return defEnd->previous() && defEnd->previous()->isStandardType();
    }",50,5,lib/symboldatabase.cpp,"lib/symboldatabase.cpp:<global>.Function.returnsStandardType.<lambda>11:bool(Token*,Token*)",<empty>,,false,3160,3162,<lambda>11,,,1,"bool(Token*,Token*)"
111669153224,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Function::returnsStandardType(const Function* function, bool unknown)
{
    return checkReturns(function, unknown, true, [](const Token* /*defStart*/, const Token* defEnd) {
        return defEnd->previous() && defEnd->previous()->isStandardType();
    });
}",1,1,lib/symboldatabase.cpp,"Function.returnsStandardType:bool(Function*,bool)",<empty>,,false,3158,3163,returnsStandardType,,,1,"bool(Function*,bool)"
111669153225,METHOD,<empty>,<empty>,"[](const Token* /*defStart*/, const Token* defEnd) {
        return Token::simpleMatch(defEnd->previous(), ""void"");
    }",50,5,lib/symboldatabase.cpp,"lib/symboldatabase.cpp:<global>.Function.returnsVoid.<lambda>12:ANY(Token*,Token*)",<empty>,,false,3167,3169,<lambda>12,,,1,"ANY(Token*,Token*)"
111669153226,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Function::returnsVoid(const Function* function, bool unknown)
{
    return checkReturns(function, unknown, true, [](const Token* /*defStart*/, const Token* defEnd) {
        return Token::simpleMatch(defEnd->previous(), ""void"");
    });
}",1,1,lib/symboldatabase.cpp,"Function.returnsVoid:bool(Function*,bool)",<empty>,,false,3165,3170,returnsVoid,,,1,"bool(Function*,bool)"
111669153227,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"std::vector<const Token*> Function::findReturns(const Function* f)
{
    std::vector<const Token*> result;
    if (!f)
        return result;
    const Scope* scope = f->functionScope;
    if (!scope)
        return result;
    if (!scope->bodyStart)
        return result;
    for (const Token* tok = scope->bodyStart->next(); tok && tok != scope->bodyEnd; tok = tok->next()) {
        if (tok->str() == ""{"" && tok->scope() &&
            (tok->scope()->type == ScopeType::eLambda || tok->scope()->type == ScopeType::eClass)) {
            tok = tok->link();
            continue;
        }
        if (Token::simpleMatch(tok->astParent(), ""return"")) {
            result.push_back(tok);
        }
        // Skip lambda functions since the scope may not be set correctly
        const Token* lambdaEndToken = findLambdaEndToken(tok);
        if (lambdaEndToken) {
            tok = lambdaEndToken;
        }
    }
    return result;
}",1,1,lib/symboldatabase.cpp,Function.findReturns:vector<constToken*>(Function*),<empty>,,false,3172,3198,findReturns,,,1,vector<const Token*>(Function*)
111669153228,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Token * Function::constructorMemberInitialization() const
{
    if (!isConstructor() || !arg)
        return nullptr;
    if (Token::simpleMatch(arg->link(), "") :""))
        return arg->link()->next();
    if (Token::simpleMatch(arg->link(), "") noexcept ("") && arg->link()->linkAt(2)->strAt(1) == "":"")
        return arg->link()->linkAt(2)->next();
    return nullptr;
}",1,1,lib/symboldatabase.cpp,Function.constructorMemberInitialization<const>:Token*(),<empty>,,false,3200,3209,constructorMemberInitialization,,,1,Token*()
111669153229,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Function::isSafe(const Settings &settings) const
{
    if (settings.safeChecks.externalFunctions) {
        if (nestedIn->type == ScopeType::eNamespace && token->fileIndex() != 0)
            return true;
        if (nestedIn->type == ScopeType::eGlobal && (token->fileIndex() != 0 || !isStatic()))
            return true;
    }

    if (settings.safeChecks.internalFunctions) {
        if (nestedIn->type == ScopeType::eNamespace && token->fileIndex() == 0)
            return true;
        if (nestedIn->type == ScopeType::eGlobal && (token->fileIndex() == 0 || isStatic()))
            return true;
    }

    if (settings.safeChecks.classes && access == AccessControl::Public && (nestedIn->type == ScopeType::eClass || nestedIn->type == ScopeType::eStruct))
        return true;

    return false;
}",1,1,lib/symboldatabase.cpp,Function.isSafe<const>:bool(Settings&),<empty>,,false,3211,3231,isSafe,,,1,bool(Settings&)
111669153230,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"Function* SymbolDatabase::addGlobalFunction(Scope*& scope, const Token*& tok, const Token *argStart, const Token* funcStart)
{
    Function* function = nullptr;
    // Lambda functions are always unique
    if (tok->str() != ""["") {
        auto range = scope->functionMap.equal_range(tok->str());
        for (std::multimap<std::string, const Function*>::const_iterator it = range.first; it != range.second; ++it) {
            const Function *f = it->second;
            if (f->hasBody())
                continue;
            if (f->argsMatch(scope, f->argDef, argStart, emptyString, 0)) {
                function = const_cast<Function *>(it->second);
                break;
            }
        }
    }

    if (!function)
        function = addGlobalFunctionDecl(scope, tok, argStart, funcStart);

    function->arg = argStart;
    function->token = funcStart;
    function->hasBody(true);

    addNewFunction(scope, tok);

    if (scope) {
        scope->function = function;
        functi...",1,1,lib/symboldatabase.cpp,"SymbolDatabase.addGlobalFunction:Function*(Scope*&,Token*&,Token*,Token*)",<empty>,,false,3233,3265,addGlobalFunction,,,1,"Function*(Scope*&,Token*&,Token*,Token*)"
111669153231,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"Function* SymbolDatabase::addGlobalFunctionDecl(Scope*& scope, const Token *tok, const Token *argStart, const Token* funcStart)
{
    Function function(tok, scope, funcStart, argStart);
    scope->addFunction(std::move(function));
    return &scope->functionList.back();
}",1,1,lib/symboldatabase.cpp,"SymbolDatabase.addGlobalFunctionDecl:Function*(Scope*&,Token*,Token*,Token*)",<empty>,,false,3267,3272,addGlobalFunctionDecl,,,1,"Function*(Scope*&,Token*,Token*,Token*)"
111669153232,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::addClassFunction(Scope *&scope, const Token *&tok, const Token *argStart)
{
    const bool destructor(tok->strAt(-1) == ""~"");
    const bool has_const(argStart->link()->strAt(1) == ""const"");
    const bool lval(argStart->link()->strAt(has_const ? 2 : 1) == ""&"");
    const bool rval(argStart->link()->strAt(has_const ? 2 : 1) == ""&&"");
    int count = 0;
    std::string path;
    unsigned int path_length = 0;
    const Token *tok1 = tok;

    if (destructor)
        tok1 = tok1->previous();

    // back up to head of path
    while (tok1 && tok1->previous() && tok1->strAt(-1) == ""::"" && tok1->tokAt(-2) &&
           ((tok1->tokAt(-2)->isName() && !tok1->tokAt(-2)->isStandardType()) ||
            (tok1->strAt(-2) == "">"" && tok1->linkAt(-2) && Token::Match(tok1->linkAt(-2)->previous(), ""%name%"")))) {
        count++;
        const Token * tok2 = tok1->tokAt(-2);
        if (tok2->str() == "">"")
            tok2 = tok2->link()->previous();

        if (tok2) {
      ...",1,1,lib/symboldatabase.cpp,"SymbolDatabase.addClassFunction:void(Scope*&,Token*&,Token*)",<empty>,,false,3274,3447,addClassFunction,,,1,"void(Scope*&,Token*&,Token*)"
111669153233,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::addNewFunction(Scope *&scope, const Token *&tok)
{
    const Token *tok1 = tok;
    scopeList.emplace_back(this, tok1, scope);
    Scope *newScope = &scopeList.back();

    // find start of function '{'
    bool foundInitList = false;
    while (tok1 && tok1->str() != ""{"" && tok1->str() != "";"") {
        if (tok1->link() && Token::Match(tok1, ""(|[|<"")) {
            tok1 = tok1->link();
        } else if (foundInitList && Token::Match(tok1, ""%name%|> {"") && Token::Match(tok1->linkAt(1), ""} ,|{"")) {
            tok1 = tok1->linkAt(1);
        } else {
            if (tok1->str() == "":"")
                foundInitList = true;
            tok1 = tok1->next();
        }
    }

    if (tok1 && tok1->str() == ""{"") {
        newScope->setBodyStartEnd(tok1);

        // syntax error?
        if (!newScope->bodyEnd) {
            mTokenizer.unmatchedToken(tok1);
        } else {
            scope->nestedList.push_back(newScope);
            scope = newScope;
        }
   ...",1,1,lib/symboldatabase.cpp,"SymbolDatabase.addNewFunction:void(Scope*&,Token*&)",<empty>,,false,3449,3485,addNewFunction,,,1,"void(Scope*&,Token*&)"
111669153234,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Type::isClassType() const
{
    return classScope && classScope->type == ScopeType::eClass;
}",1,1,lib/symboldatabase.cpp,Type.isClassType<const>:bool(),<empty>,,false,3487,3490,isClassType,,,1,bool()
111669153235,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Type::isEnumType() const
{
    //We explicitly check for ""enum"" because a forward declared enum doesn't get its own scope
    return (classDef && classDef->str() == ""enum"") ||
           (classScope && classScope->type == ScopeType::eEnum);
}",1,1,lib/symboldatabase.cpp,Type.isEnumType<const>:bool(),<empty>,,false,3492,3497,isEnumType,,,1,bool()
111669153236,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Type::isStructType() const
{
    return classScope && classScope->type == ScopeType::eStruct;
}",1,1,lib/symboldatabase.cpp,Type.isStructType<const>:bool(),<empty>,,false,3499,3502,isStructType,,,1,bool()
111669153237,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Type::isUnionType() const
{
    return classScope && classScope->type == ScopeType::eUnion;
}",1,1,lib/symboldatabase.cpp,Type.isUnionType<const>:bool(),<empty>,,false,3504,3507,isUnionType,,,1,bool()
111669153238,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Token *Type::initBaseInfo(const Token *tok, const Token *tok1)
{
    // goto initial '{'
    const Token *tok2 = tok1;
    while (tok2 && tok2->str() != ""{"") {
        // skip unsupported templates
        if (tok2->str() == ""<"")
            tok2 = tok2->link();

        // check for base classes
        else if (Token::Match(tok2, "":|,"")) {
            tok2 = tok2->next();

            // check for invalid code
            if (!tok2 || !tok2->next())
                return nullptr;

            Type::BaseInfo base;

            if (tok2->str() == ""virtual"") {
                base.isVirtual = true;
                tok2 = tok2->next();
            }

            if (tok2->str() == ""public"") {
                base.access = AccessControl::Public;
                tok2 = tok2->next();
            } else if (tok2->str() == ""protected"") {
                base.access = AccessControl::Protected;
                tok2 = tok2->next();
            } else if (tok2->str() == ""private"") {
   ...",1,1,lib/symboldatabase.cpp,"Type.initBaseInfo:Token*(Token*,Token*)",<empty>,,false,3509,3591,initBaseInfo,,,1,"Token*(Token*,Token*)"
111669153239,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"std::string Type::name() const
{
    const Token* start = classDef->next();
    if (classScope && classScope->enumClass && isEnumType())
        start = start->tokAt(1);
    else if (start->str() == ""class"")
        start = start->tokAt(1);
    else if (!start->isName())
        return emptyString;
    const Token* next = start;
    while (Token::Match(next, ""::|<|>|(|)|[|]|*|&|&&|%name%"")) {
        if (Token::Match(next, ""<|(|["") && next->link())
            next = next->link();
        next = next->next();
    }
    std::string result;
    for (const Token* tok = start; tok != next; tok = tok->next()) {
        if (!result.empty())
            result += ' ';
        result += tok->str();
    }
    return result;
}",1,1,lib/symboldatabase.cpp,Type.name<const>:string(),<empty>,,false,3593,3615,name,,,1,string()
111669153240,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::debugMessage(const Token *tok, const std::string &type, const std::string &msg) const
{
    if (tok && mSettings.debugwarnings) {
        const std::list<const Token*> locationList(1, tok);
        const ErrorMessage errmsg(locationList, &mTokenizer.list,
                                  Severity::debug,
                                  type,
                                  msg,
                                  Certainty::normal);
        mErrorLogger.reportErr(errmsg);
    }
}",1,1,lib/symboldatabase.cpp,"SymbolDatabase.debugMessage<const>:void(Token*,std.string&,std.string&)",<empty>,,false,3617,3628,debugMessage,,,1,"void(Token*,std.string&,std.string&)"
111669153241,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::returnImplicitIntError(const Token *tok) const
{
    if (tok && mSettings.severity.isEnabled(Severity::portability) && (tok->isC() && mSettings.standards.c != Standards::C89)) {
        const std::list<const Token*> locationList(1, tok);
        const ErrorMessage errmsg(locationList, &mTokenizer.list,
                                  Severity::portability,
                                  ""returnImplicitInt"",
                                  ""Omitted return type of function '"" + tok->str() + ""' defaults to int, this is not supported by ISO C99 and later standards."",
                                  Certainty::normal);
        mErrorLogger.reportErr(errmsg);
    }
}",1,1,lib/symboldatabase.cpp,SymbolDatabase.returnImplicitIntError<const>:void(Token*),<empty>,,false,3630,3641,returnImplicitIntError,,,1,void(Token*)
111669153242,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Function* Type::getFunction(const std::string& funcName) const
{
    if (classScope) {
        const auto it = utils::as_const(classScope->functionMap).find(funcName);
        if (it != classScope->functionMap.end())
            return it->second;
    }

    for (const Type::BaseInfo & i : derivedFrom) {
        if (i.type) {
            const Function* const func = i.type->getFunction(funcName);
            if (func)
                return func;
        }
    }
    return nullptr;
}",1,1,lib/symboldatabase.cpp,Type.getFunction<const>:Function*(std.string&),<empty>,,false,3643,3659,getFunction,,,1,Function*(std.string&)
111669153243,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Type::hasCircularDependencies(std::set<BaseInfo>* ancestors) const
{
    std::set<BaseInfo> knownAncestors;
    if (!ancestors) {
        ancestors=&knownAncestors;
    }
    for (auto parent=derivedFrom.cbegin(); parent!=derivedFrom.cend(); ++parent) {
        if (!parent->type)
            continue;
        if (this==parent->type)
            return true;
        if (ancestors->find(*parent)!=ancestors->end())
            return true;

        ancestors->insert(*parent);
        if (parent->type->hasCircularDependencies(ancestors))
            return true;
    }
    return false;
}",1,1,lib/symboldatabase.cpp,Type.hasCircularDependencies<const>:bool(std.set<BaseInfo>*),<empty>,,false,3661,3680,hasCircularDependencies,,,1,bool(std.set<BaseInfo>*)
111669153244,METHOD,<empty>,<empty>,"[&](const BaseInfo& d) {
        return d.type && (d.type == this || d.type->findDependency(ancestor));
    }",86,5,lib/symboldatabase.cpp,lib/symboldatabase.cpp:<global>.Type.findDependency<const>.<lambda>13:bool(Type.BaseInfo&),<empty>,,false,3684,3686,<lambda>13,,,1,bool(Type.BaseInfo&)
111669153245,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Type::findDependency(const Type* ancestor) const
{
    return this == ancestor || std::any_of(derivedFrom.cbegin(), derivedFrom.cend(), [&](const BaseInfo& d) {
        return d.type && (d.type == this || d.type->findDependency(ancestor));
    });
}",1,1,lib/symboldatabase.cpp,Type.findDependency<const>:bool(Type*),<empty>,,false,3682,3687,findDependency,,,1,bool(Type*)
111669153246,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Type::isDerivedFrom(const std::string & ancestor) const
{
    for (auto parent=derivedFrom.cbegin(); parent!=derivedFrom.cend(); ++parent) {
        if (parent->name == ancestor)
            return true;
        if (parent->type && parent->type->isDerivedFrom(ancestor))
            return true;
    }
    return false;
}",1,1,lib/symboldatabase.cpp,Type.isDerivedFrom<const>:bool(std.string&),<empty>,,false,3689,3698,isDerivedFrom,,,1,bool(std.string&)
111669153247,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Variable::arrayDimensions(const Settings& settings, bool& isContainer)
{
    isContainer = false;
    const Library::Container* container = (mTypeStartToken && mTypeStartToken->isCpp()) ? settings.library.detectContainer(mTypeStartToken) : nullptr;
    if (container && container->arrayLike_indexOp && container->size_templateArgNo > 0) {
        const Token* tok = Token::findsimplematch(mTypeStartToken, ""<"");
        if (tok) {
            isContainer = true;
            Dimension dimension_;
            tok = tok->next();
            for (int i = 0; i < container->size_templateArgNo && tok; i++) {
                tok = tok->nextTemplateArgument();
            }
            if (Token::Match(tok, ""%num% [,>]"")) {
                dimension_.tok = tok;
                dimension_.known = true;
                dimension_.num = MathLib::toBigNumber(tok);
            } else if (tok) {
                dimension_.tok = tok;
                dimension_.known = false;
            }
        ...",1,1,lib/symboldatabase.cpp,"Variable.arrayDimensions:bool(Settings&,bool&)",<empty>,,false,3700,3764,arrayDimensions,,,1,"bool(Settings&,bool&)"
111669153248,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static std::string scopeTypeToString(ScopeType type)
{
    switch (type) {
    case ScopeType::eGlobal:
        return ""Global"";
    case ScopeType::eClass:
        return ""Class"";
    case ScopeType::eStruct:
        return ""Struct"";
    case ScopeType::eUnion:
        return ""Union"";
    case ScopeType::eNamespace:
        return ""Namespace"";
    case ScopeType::eFunction:
        return ""Function"";
    case ScopeType::eIf:
        return ""If"";
    case ScopeType::eElse:
        return ""Else"";
    case ScopeType::eFor:
        return ""For"";
    case ScopeType::eWhile:
        return ""While"";
    case ScopeType::eDo:
        return ""Do"";
    case ScopeType::eSwitch:
        return ""Switch"";
    case ScopeType::eTry:
        return ""Try"";
    case ScopeType::eCatch:
        return ""Catch"";
    case ScopeType::eUnconditional:
        return ""Unconditional"";
    case ScopeType::eLambda:
        return ""Lambda"";
    case ScopeType::eEnum:
        return ""Enum"";
    }
    return ""Unknow...",1,1,lib/symboldatabase.cpp,scopeTypeToString:string(ScopeType),<empty>,,false,3766,3805,scopeTypeToString,,,1,string(ScopeType)
111669153249,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static std::ostream & operator << (std::ostream & s, ScopeType type)
{
    s << scopeTypeToString(type);
    return s;
}",1,1,lib/symboldatabase.cpp,"<<:ostream(std.ostream&,ScopeType)",<empty>,,false,3807,3811,<<,,,1,"ostream(std.ostream&,ScopeType)"
111669153250,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static std::string accessControlToString(AccessControl access)
{
    switch (access) {
    case AccessControl::Public:
        return ""Public"";
    case AccessControl::Protected:
        return ""Protected"";
    case AccessControl::Private:
        return ""Private"";
    case AccessControl::Global:
        return ""Global"";
    case AccessControl::Namespace:
        return ""Namespace"";
    case AccessControl::Argument:
        return ""Argument"";
    case AccessControl::Local:
        return ""Local"";
    case AccessControl::Throw:
        return ""Throw"";
    }
    return ""Unknown"";
}",1,1,lib/symboldatabase.cpp,accessControlToString:string(AccessControl),<empty>,,false,3813,3834,accessControlToString,,,1,string(AccessControl)
111669153251,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static const char* functionTypeToString(FunctionType type)
{
    switch (type) {
    case FunctionType::eConstructor:
        return ""Constructor"";
    case FunctionType::eCopyConstructor:
        return ""CopyConstructor"";
    case FunctionType::eMoveConstructor:
        return ""MoveConstructor"";
    case FunctionType::eOperatorEqual:
        return ""OperatorEqual"";
    case FunctionType::eDestructor:
        return ""Destructor"";
    case FunctionType::eFunction:
        return ""Function"";
    case FunctionType::eLambda:
        return ""Lambda"";
    default:
        return ""Unknown"";
    }
}",1,1,lib/symboldatabase.cpp,functionTypeToString:char*(FunctionType),<empty>,,false,3836,3856,functionTypeToString,,,1,char*(FunctionType)
111669153252,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static std::string tokenToString(const Token* tok, const Tokenizer& tokenizer)
{
    std::ostringstream oss;
    if (tok) {
        oss << tok->str() << "" "";
        oss << tokenizer.list.fileLine(tok) << "" "";
    }
    oss << tok;
    return oss.str();
}",1,1,lib/symboldatabase.cpp,"tokenToString:string(Token*,Tokenizer&)",<empty>,,false,3858,3867,tokenToString,,,1,"string(Token*,Tokenizer&)"
111669153253,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static std::string scopeToString(const Scope* scope, const Tokenizer& tokenizer)
{
    std::ostringstream oss;
    if (scope) {
        oss << scope->type << "" "";
        if (!scope->className.empty())
            oss << scope->className << "" "";
        if (scope->classDef)
            oss << tokenizer.list.fileLine(scope->classDef) << "" "";
    }
    oss << scope;
    return oss.str();
}",1,1,lib/symboldatabase.cpp,"scopeToString:string(Scope*,Tokenizer&)",<empty>,,false,3869,3881,scopeToString,,,1,"string(Scope*,Tokenizer&)"
111669153254,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static std::string tokenType(const Token * tok)
{
    std::ostringstream oss;
    if (tok) {
        if (tok->isUnsigned())
            oss << ""unsigned "";
        else if (tok->isSigned())
            oss << ""signed "";
        if (tok->isComplex())
            oss << ""_Complex "";
        if (tok->isLong())
            oss << ""long "";
        oss << tok->str();
    }
    return oss.str();
}",1,1,lib/symboldatabase.cpp,tokenType:string(Token*),<empty>,,false,3883,3898,tokenType,,,1,string(Token*)
111669153255,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::printVariable(const Variable *var, const char *indent) const
{
    std::cout << indent << ""mNameToken: "" << tokenToString(var->nameToken(), mTokenizer) << std::endl;
    if (var->nameToken()) {
        std::cout << indent << ""    declarationId: "" << var->declarationId() << std::endl;
    }
    std::cout << indent << ""mTypeStartToken: "" << tokenToString(var->typeStartToken(), mTokenizer) << std::endl;
    std::cout << indent << ""mTypeEndToken: "" << tokenToString(var->typeEndToken(), mTokenizer) << std::endl;

    if (var->typeStartToken()) {
        const Token * autoTok = nullptr;
        std::cout << indent << ""   "";
        for (const Token * tok = var->typeStartToken(); tok != var->typeEndToken()->next(); tok = tok->next()) {
            std::cout << "" "" << tokenType(tok);
            if (tok->str() == ""auto"")
                autoTok = tok;
        }
        std::cout << std::endl;
        if (autoTok) {
            const ValueType * valueType = autoTok->valu...",1,1,lib/symboldatabase.cpp,"SymbolDatabase.printVariable<const>:void(Variable*,char*)",<empty>,,false,3900,3968,printVariable,,,1,"void(Variable*,char*)"
111669153256,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::printOut(const char *title) const
{
    std::cout << std::setiosflags(std::ios::boolalpha);
    if (title)
        std::cout << ""\\n### "" << title << "" ###\\n"";

    for (auto scope = scopeList.cbegin(); scope != scopeList.cend(); ++scope) {
        std::cout << ""Scope: "" << &*scope << "" "" << scope->type << std::endl;
        std::cout << ""    className: "" << scope->className << std::endl;
        std::cout << ""    classDef: "" << tokenToString(scope->classDef, mTokenizer) << std::endl;
        std::cout << ""    bodyStart: "" << tokenToString(scope->bodyStart, mTokenizer) << std::endl;
        std::cout << ""    bodyEnd: "" << tokenToString(scope->bodyEnd, mTokenizer) << std::endl;

        // find the function body if not implemented inline
        for (auto func = scope->functionList.cbegin(); func != scope->functionList.cend(); ++func) {
            std::cout << ""    Function: "" << &*func << std::endl;
            std::cout << ""        name: "" << tokenToString(func...",1,1,lib/symboldatabase.cpp,SymbolDatabase.printOut<const>:void(char*),<empty>,,false,3970,4196,printOut,,,1,void(char*)
111669153257,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::printXml(std::ostream &out) const
{
    std::string outs;

    std::set<const Variable *> variables;

    // Scopes..
    outs += ""  <scopes>\\n"";
    for (auto scope = scopeList.cbegin(); scope != scopeList.cend(); ++scope) {
        outs += ""    <scope"";
        outs += "" id=\\"""";
        outs += id_string(&*scope);
        outs += ""\\"""";
        outs += "" type=\\"""";
        outs += scopeTypeToString(scope->type);
        outs += ""\\"""";
        if (!scope->className.empty()) {
            outs += "" className=\\"""";
            outs += ErrorLogger::toxml(scope->className);
            outs += ""\\"""";
        }
        if (scope->bodyStart) {
            outs += "" bodyStart=\\"""";
            outs += id_string(scope->bodyStart);
            outs += '\\""';
        }
        if (scope->bodyEnd) {
            outs += "" bodyEnd=\\"""";
            outs += id_string(scope->bodyEnd);
            outs += '\\""';
        }
        if (scope->nestedIn) {
            outs += "" nestedIn=\\""...",1,1,lib/symboldatabase.cpp,SymbolDatabase.printXml<const>:void(std.ostream&),<empty>,,false,4198,4428,printXml,,,1,void(std.ostream&)
111669153258,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static const Type* findVariableTypeIncludingUsedNamespaces(const SymbolDatabase* symbolDatabase, const Scope* scope, const Token* typeTok)
{
    const Type* argType = symbolDatabase->findVariableType(scope, typeTok);
    if (argType)
        return argType;

    // look for variable type in any using namespace in this scope or above
    while (scope) {
        for (const Scope::UsingInfo &ui : scope->usingList) {
            if (ui.scope) {
                argType = symbolDatabase->findVariableType(ui.scope, typeTok);
                if (argType)
                    return argType;
            }
        }
        scope = scope->nestedIn;
    }
    return nullptr;
}",1,1,lib/symboldatabase.cpp,"findVariableTypeIncludingUsedNamespaces:Type*(SymbolDatabase*,Scope*,Token*)",<empty>,,false,4432,4450,findVariableTypeIncludingUsedNamespaces,,,1,"Type*(SymbolDatabase*,Scope*,Token*)"
111669153259,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void Function::addArguments(const SymbolDatabase *symbolDatabase, const Scope *scope)
{
    // check for non-empty argument list ""( ... )""
    const Token * start = arg ? arg : argDef;
    if (!Token::simpleMatch(start, ""(""))
        return;
    if (!(start && start->link() != start->next() && !Token::simpleMatch(start, ""( void )"")))
        return;

    unsigned int count = 0;

    for (const Token* tok = start->next(); tok; tok = tok->next()) {
        if (Token::Match(tok, "",|)""))
            return; // Syntax error

        const Token* startTok = tok;
        const Token* endTok   = nullptr;
        const Token* nameTok  = nullptr;

        do {
            if (Token::simpleMatch(tok, ""decltype ("")) {
                tok = tok->linkAt(1)->next();
                continue;
            }
            if (tok != startTok && !nameTok && Token::Match(tok, ""( & %var% ) ["")) {
                nameTok = tok->tokAt(2);
                endTok = nameTok->previous();
                tok = t...",1,1,lib/symboldatabase.cpp,"Function.addArguments:void(SymbolDatabase*,Scope*)",<empty>,,false,4454,4594,addArguments,,,1,"void(SymbolDatabase*,Scope*)"
111669153260,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Function::isImplicitlyVirtual(bool defaultVal, bool* pFoundAllBaseClasses) const
{
    if (hasVirtualSpecifier() || hasOverrideSpecifier() || hasFinalSpecifier())
        return true;
    bool foundAllBaseClasses = true;
    if (getOverriddenFunction(&foundAllBaseClasses)) //If it overrides a base class's method then it's virtual
        return true;
    if (pFoundAllBaseClasses)
        *pFoundAllBaseClasses = foundAllBaseClasses;
    if (foundAllBaseClasses) //If we've seen all the base classes and none of the above were true then it must not be virtual
        return false;
    return defaultVal; //If we can't see all the bases classes then we can't say conclusively
}",1,1,lib/symboldatabase.cpp,"Function.isImplicitlyVirtual<const>:bool(bool,bool*)",<empty>,,false,4596,4608,isImplicitlyVirtual,,,1,"bool(bool,bool*)"
111669153261,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"std::vector<const Function*> Function::getOverloadedFunctions() const
{
    std::vector<const Function*> result;
    const Scope* scope = nestedIn;

    while (scope) {
        const bool isMemberFunction = scope->isClassOrStruct() && !isStatic();
        for (auto it = utils::as_const(scope->functionMap).find(tokenDef->str());
             it != scope->functionMap.end() && it->first == tokenDef->str();
             ++it) {
            const Function* func = it->second;
            if (isMemberFunction && isMemberFunction == func->isStatic())
                continue;
            result.push_back(func);
        }
        if (isMemberFunction)
            break;
        scope = scope->nestedIn;
    }

    return result;
}",1,1,lib/symboldatabase.cpp,Function.getOverloadedFunctions<const>:vector<constFunction*>(),<empty>,,false,4610,4631,getOverloadedFunctions,,,1,vector<const Function*>()
111669153262,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Function *Function::getOverriddenFunction(bool *foundAllBaseClasses) const
{
    if (foundAllBaseClasses)
        *foundAllBaseClasses = true;
    if (!nestedIn->isClassOrStruct())
        return nullptr;
    return getOverriddenFunctionRecursive(nestedIn->definedType, foundAllBaseClasses);
}",1,1,lib/symboldatabase.cpp,Function.getOverriddenFunction<const>:Function*(bool*),<empty>,,false,4633,4640,getOverriddenFunction,,,1,Function*(bool*)
111669153263,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static bool isDerivedFromItself(const std::string& thisName, const std::string& baseName)
{
    if (thisName.back() != '>')
        return false;
    const auto pos = thisName.find('<');
    if (pos == std::string::npos)
        return false;
    return thisName.compare(0, pos + 1, baseName, 0, pos + 1) == 0;
}",1,1,lib/symboldatabase.cpp,"isDerivedFromItself:bool(std.string&,std.string&)",<empty>,,false,4643,4651,isDerivedFromItself,,,1,"bool(std.string&,std.string&)"
111669153264,METHOD,<empty>,<empty>,"[](const Function& f) {
                return f.isDestructor() && f.isImplicitlyVirtual();
            }",94,13,lib/symboldatabase.cpp,lib/symboldatabase.cpp:<global>.Function.getOverriddenFunctionRecursive<const>.<lambda>14:bool(Function&),<empty>,,false,4706,4708,<lambda>14,,,1,bool(Function&)
111669153265,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Function * Function::getOverriddenFunctionRecursive(const ::Type* baseType, bool *foundAllBaseClasses) const
{
    // check each base class
    for (const ::Type::BaseInfo & i : baseType->derivedFrom) {
        const ::Type* derivedFromType = i.type;
        // check if base class exists in database
        if (!derivedFromType || !derivedFromType->classScope) {
            if (foundAllBaseClasses)
                *foundAllBaseClasses = false;
            continue;
        }

        const Scope *parent = derivedFromType->classScope;

        // check if function defined in base class
        auto range = utils::as_const(parent->functionMap).equal_range(tokenDef->str());
        for (auto it = range.first; it != range.second; ++it) {
            const Function * func = it->second;
            if (func->isImplicitlyVirtual()) { // Base is virtual and of same name
                const Token *temp1 = func->tokenDef->previous();
                const Token *temp2 = tokenDef->prev...",1,1,lib/symboldatabase.cpp,"Function.getOverriddenFunctionRecursive<const>:Function*(Type*,bool*)",<empty>,,false,4653,4723,getOverriddenFunctionRecursive,,,1,"Function*(Type*,bool*)"
111669153266,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Variable* Function::getArgumentVar(nonneg int num) const
{
    if (num < argumentList.size()) {
        auto it = argumentList.begin();
        std::advance(it, num);
        return &*it;
    }
    return nullptr;
}",1,41,lib/symboldatabase.cpp,Function.getArgumentVar<const>:Variable*(int),<empty>,,false,4725,4733,getArgumentVar,,,1,Variable*(int)
111669153267,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"Scope::Scope(const SymbolDatabase *check_, const Token *classDef_, const Scope *nestedIn_, ScopeType type_, const Token *start_) :
    check(check_),
    classDef(classDef_),
    nestedIn(nestedIn_),
    type(type_)
{
    setBodyStartEnd(start_);
}",1,1,lib/symboldatabase.cpp,"Scope.Scope:ANY(SymbolDatabase*,Token*,Scope*,ScopeType,Token*)",<empty>,,false,4738,4745,Scope,,,1,"Scope.Scope:ANY(SymbolDatabase*,Token*,Scope*,ScopeType,Token*)(SymbolDatabase*,Token*,Scope*,ScopeType,Token*)"
111669153268,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"Scope::Scope(const SymbolDatabase *check_, const Token *classDef_, const Scope *nestedIn_) :
    check(check_),
    classDef(classDef_),
    nestedIn(nestedIn_)
{
    const Token *nameTok = classDef;
    if (!classDef) {
        type = ScopeType::eGlobal;
    } else if (classDef->str() == ""class"" && classDef->isCpp()) {
        type = ScopeType::eClass;
        nameTok = nameTok->next();
    } else if (classDef->str() == ""struct"") {
        type = ScopeType::eStruct;
        nameTok = nameTok->next();
    } else if (classDef->str() == ""union"") {
        type = ScopeType::eUnion;
        nameTok = nameTok->next();
    } else if (classDef->str() == ""namespace"") {
        type = ScopeType::eNamespace;
        nameTok = nameTok->next();
    } else if (classDef->str() == ""enum"") {
        type = ScopeType::eEnum;
        nameTok = nameTok->next();
        if (nameTok->str() == ""class"") {
            enumClass = true;
            nameTok = nameTok->next();
        }
    } else if (classDe...",1,1,lib/symboldatabase.cpp,"Scope.Scope:ANY(SymbolDatabase*,Token*,Scope*)",<empty>,,false,4747,4783,Scope,,,1,"Scope.Scope:ANY(SymbolDatabase*,Token*,Scope*)(SymbolDatabase*,Token*,Scope*)"
111669153269,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"AccessControl Scope::defaultAccess() const
{
    switch (type) {
    case ScopeType::eGlobal:
        return AccessControl::Global;
    case ScopeType::eClass:
        return AccessControl::Private;
    case ScopeType::eStruct:
        return AccessControl::Public;
    case ScopeType::eUnion:
        return AccessControl::Public;
    case ScopeType::eNamespace:
        return AccessControl::Namespace;
    default:
        return AccessControl::Local;
    }
}",1,1,lib/symboldatabase.cpp,Scope.defaultAccess<const>:AccessControl(),<empty>,,false,4785,4801,defaultAccess,,,1,AccessControl()
111669153270,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void Scope::addVariable(const Token *token_, const Token *start_, const Token *end_,
                        AccessControl access_, const Type *type_, const Scope *scope_, const Settings& settings)
{
    // keep possible size_t -> int truncation outside emplace_back() to have a single line
    // C4267 VC++ warning instead of several dozens lines
    const int varIndex = varlist.size();
    varlist.emplace_back(token_, start_, end_, varIndex, access_, type_, scope_, settings);
}",1,1,lib/symboldatabase.cpp,"Scope.addVariable:void(Token*,Token*,Token*,AccessControl,Type*,Scope*,Settings&)",<empty>,,false,4803,4810,addVariable,,,1,"void(Token*,Token*,Token*,AccessControl,Type*,Scope*,Settings&)"
111669153271,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void Scope::getVariableList(const Settings& settings)
{
    if (!bodyStartList.empty()) {
        for (const Token *bs: bodyStartList)
            getVariableList(settings, bs->next(), bs->link());
    }

    // global scope
    else if (type == ScopeType::eGlobal)
        getVariableList(settings, check->mTokenizer.tokens(), nullptr);

    // forward declaration
    else
        return;
}",1,1,lib/symboldatabase.cpp,Scope.getVariableList:void(Settings&),<empty>,,false,4813,4827,getVariableList,,,1,void(Settings&)
111669153272,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void Scope::getVariableList(const Settings& settings, const Token* start, const Token* end)
{
    // Variable declared in condition: if (auto x = bar())
    if (Token::Match(classDef, ""if|while ( %type%"") && Token::simpleMatch(classDef->next()->astOperand2(), ""="")) {
        checkVariable(classDef->tokAt(2), defaultAccess(), settings);
    }

    AccessControl varaccess = defaultAccess();
    for (const Token *tok = start; tok && tok != end; tok = tok->next()) {
        // syntax error?
        if (tok->next() == nullptr)
            break;

        // Is it a function?
        if (tok->str() == ""{"") {
            tok = tok->link();
            continue;
        }

        // Is it a nested class or structure?
        if (tok->isKeyword() && Token::Match(tok, ""class|struct|union|namespace %type% :|{"")) {
            tok = tok->tokAt(2);
            while (tok && tok->str() != ""{"")
                tok = tok->next();
            if (tok) {
                // skip implementation
      ...",1,1,lib/symboldatabase.cpp,"Scope.getVariableList:void(Settings&,Token*,Token*)",<empty>,,false,4829,4935,getVariableList,,,1,"void(Settings&,Token*,Token*)"
111669153273,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Token *Scope::checkVariable(const Token *tok, AccessControl varaccess, const Settings& settings)
{
    // Is it a throw..?
    if (tok->isKeyword() && Token::Match(tok, ""throw %any% ("") &&
        Token::simpleMatch(tok->linkAt(2), "") ;"")) {
        return tok->linkAt(2);
    }

    if (tok->isKeyword() && Token::Match(tok, ""throw %any% :: %any% ("") &&
        Token::simpleMatch(tok->linkAt(4), "") ;"")) {
        return tok->linkAt(4);
    }

    // friend?
    if (tok->isKeyword() && Token::Match(tok, ""friend %type%"") && tok->next()->varId() == 0) {
        const Token *next = Token::findmatch(tok->tokAt(2), "";|{"");
        if (next && next->str() == ""{"")
            next = next->link();
        return next;
    }

    // skip const|volatile|static|mutable|extern
    while (tok && tok->isKeyword() && Token::Match(tok, ""const|constexpr|volatile|static|mutable|extern"")) {
        tok = tok->next();
    }

    // the start of the type tokens does not include the above modifiers
 ...",1,1,lib/symboldatabase.cpp,"Scope.checkVariable:Token*(Token*,AccessControl,Settings&)",<empty>,,false,4937,5029,checkVariable,,,1,"Token*(Token*,AccessControl,Settings&)"
111669153274,METHOD,<empty>,<empty>,"[&varname](const Variable& var) {
        return var.name() == varname;
    }",60,5,lib/symboldatabase.cpp,lib/symboldatabase.cpp:<global>.Scope.getVariable<const>.<lambda>15:bool(Variable&),<empty>,,false,5033,5035,<lambda>15,,,1,bool(Variable&)
111669153275,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Variable *Scope::getVariable(const std::string &varname) const
{
    auto it = std::find_if(varlist.begin(), varlist.end(), [&varname](const Variable& var) {
        return var.name() == varname;
    });
    if (it != varlist.end())
        return &*it;

    if (definedType) {
        for (const Type::BaseInfo& baseInfo: definedType->derivedFrom) {
            if (baseInfo.type && baseInfo.type->classScope) {
                if (const Variable* var = baseInfo.type->classScope->getVariable(varname))
                    return var;
            }
        }
    }
    return nullptr;
}",1,1,lib/symboldatabase.cpp,Scope.getVariable<const>:Variable*(std.string&),<empty>,,false,5031,5048,getVariable,,,1,Variable*(std.string&)
111669153276,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static const Token* skipPointers(const Token* tok)
{
    while (Token::Match(tok, ""*|&|&&"") || (Token::Match(tok, ""( [*&]"") && Token::Match(tok->link()->next(), ""(|[""))) {
        tok = tok->next();
        if (tok && tok->strAt(-1) == ""("" && Token::Match(tok, ""%type% ::""))
            tok = tok->tokAt(2);
    }

    if (Token::simpleMatch(tok, ""( *"") && Token::simpleMatch(tok->link()->previous(), ""] ) ;"") &&
        (tok->tokAt(-1)->isStandardType() || tok->tokAt(-1)->isKeyword() || tok->strAt(-1) == ""*"")) {
        const Token *tok2 = skipPointers(tok->next());
        if (Token::Match(tok2, ""%name% ["") && Token::simpleMatch(tok2->linkAt(1), ""] ) ;""))
            return tok2;
    }

    return tok;
}",1,1,lib/symboldatabase.cpp,skipPointers:Token*(Token*),<empty>,,false,5050,5066,skipPointers,,,1,Token*(Token*)
111669153277,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static const Token* skipPointersAndQualifiers(const Token* tok)
{
    tok = skipPointers(tok);
    while (Token::Match(tok, ""const|static|volatile"")) {
        tok = tok->next();
        tok = skipPointers(tok);
    }

    return tok;
}",1,1,lib/symboldatabase.cpp,skipPointersAndQualifiers:Token*(Token*),<empty>,,false,5068,5077,skipPointersAndQualifiers,,,1,Token*(Token*)
111669153278,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Scope::isVariableDeclaration(const Token* const tok, const Token*& vartok, const Token*& typetok) const
{
    if (!tok)
        return false;

    const bool isCPP = tok->isCpp();

    if (isCPP && Token::Match(tok, ""throw|new""))
        return false;

    const bool isCPP11 = isCPP && check->mSettings.standards.cpp >= Standards::CPP11;

    if (isCPP11 && tok->str() == ""using"")
        return false;

    const Token* localTypeTok = skipScopeIdentifiers(tok);
    const Token* localVarTok = nullptr;

    while (Token::simpleMatch(localTypeTok, ""alignas ("") && Token::Match(localTypeTok->linkAt(1), "") %name%""))
        localTypeTok = localTypeTok->linkAt(1)->next();

    if (Token::Match(localTypeTok, ""%type% <"")) {
        if (Token::Match(tok, ""const_cast|dynamic_cast|reinterpret_cast|static_cast <""))
            return false;

        const Token* closeTok = localTypeTok->linkAt(1);
        if (closeTok) {
            localVarTok = skipPointers(closeTok->next());

            i...",1,1,lib/symboldatabase.cpp,"Scope.isVariableDeclaration<const>:bool(Token*,Token*&,Token*&)",<empty>,,false,5079,5150,isVariableDeclaration,,,1,"bool(Token*,Token*&,Token*&)"
111669153279,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Token * Scope::addEnum(const Token * tok)
{
    const Token * tok2 = tok->next();

    // skip over class if present
    if (tok2->isCpp() && tok2->str() == ""class"")
        tok2 = tok2->next();

    // skip over name
    tok2 = tok2->next();

    // save type if present
    if (tok2->str() == "":"") {
        tok2 = tok2->next();

        enumType = tok2;
        while (Token::Match(tok2, ""%name%|::""))
            tok2 = tok2->next();
    }

    // add enumerators
    if (tok2->str() == ""{"") {
        const Token * end = tok2->link();
        tok2 = tok2->next();

        while (Token::Match(tok2, ""%name% =|,|}"") ||
               (Token::Match(tok2, ""%name% ("") && Token::Match(tok2->linkAt(1), "") ,|}""))) {
            Enumerator enumerator(this);

            // save enumerator name
            enumerator.name = tok2;

            // skip over name
            tok2 = tok2->next();

            if (tok2->str() == ""="") {
                // skip over ""=""
                tok2 = to...",1,1,lib/symboldatabase.cpp,Scope.addEnum:Token*(Token*),<empty>,,false,5152,5227,addEnum,,,1,Token*(Token*)
111669153280,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static const Scope* findEnumScopeInBase(const Scope* scope, const std::string& tokStr)
{
    if (scope->definedType) {
        const std::vector<Type::BaseInfo>& derivedFrom = scope->definedType->derivedFrom;
        for (const Type::BaseInfo& i : derivedFrom) {
            const Type *derivedFromType = i.type;
            if (derivedFromType && derivedFromType->classScope) {
                if (const Scope* enumScope = derivedFromType->classScope->findRecordInNestedList(tokStr))
                    return enumScope;
            }
        }
    }
    return nullptr;
}",1,1,lib/symboldatabase.cpp,"findEnumScopeInBase:Scope*(Scope*,std.string&)",<empty>,,false,5229,5242,findEnumScopeInBase,,,1,"Scope*(Scope*,std.string&)"
111669153281,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static const Enumerator* findEnumeratorInUsingList(const Scope* scope, const std::string& name)
{
    for (const auto& u : scope->usingList) {
        if (!u.scope)
            continue;
        for (const Scope* nested : u.scope->nestedList) {
            if (nested->type != ScopeType::eEnum)
                continue;
            const Enumerator* e = nested->findEnumerator(name);
            if (e && !(e->scope && e->scope->enumClass))
                return e;
        }
    }
    return nullptr;
}",1,1,lib/symboldatabase.cpp,"findEnumeratorInUsingList:Enumerator*(Scope*,std.string&)",<empty>,,false,5244,5258,findEnumeratorInUsingList,,,1,"Enumerator*(Scope*,std.string&)"
111669153282,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Enumerator * SymbolDatabase::findEnumerator(const Token * tok, std::set<std::string>& tokensThatAreNotEnumeratorValues) const
{
    if (tok->isKeyword())
        return nullptr;

    const std::string& tokStr = tok->str();
    const Scope* scope = tok->scope();

    // check for qualified name
    if (tok->strAt(-1) == ""::"") {
        // find first scope
        const Token *tok1 = tok;
        while (Token::Match(tok1->tokAt(-2), ""%name% ::""))
            tok1 = tok1->tokAt(-2);

        if (tok1->strAt(-1) == ""::"")
            scope = &scopeList.front();
        else {
            const Scope* temp = nullptr;
            if (scope)
                temp = scope->findRecordInNestedList(tok1->str());
            // find first scope
            while (scope && scope->nestedIn) {
                if (!temp)
                    temp = scope->nestedIn->findRecordInNestedList(tok1->str());
                if (!temp && scope->functionOf) {
                    temp = scope->functionOf-...",1,1,lib/symboldatabase.cpp,"SymbolDatabase.findEnumerator<const>:Enumerator*(Token*,std.set<std.string>&)",<empty>,,false,5260,5411,findEnumerator,,,1,"Enumerator*(Token*,std.set<std.string>&)"
111669153283,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Type* SymbolDatabase::findVariableTypeInBase(const Scope* scope, const Token* typeTok)
{
    if (scope && scope->definedType && !scope->definedType->derivedFrom.empty()) {
        const std::vector<Type::BaseInfo> &derivedFrom = scope->definedType->derivedFrom;
        for (const Type::BaseInfo & i : derivedFrom) {
            const Type *base = i.type;
            if (base && base->classScope) {
                if (base->classScope == scope)
                    return nullptr;
                const Type * type = base->classScope->findType(typeTok->str());
                if (type)
                    return type;
                type = findVariableTypeInBase(base->classScope, typeTok);
                if (type)
                    return type;
            }
        }
    }

    return nullptr;
}",1,1,lib/symboldatabase.cpp,"SymbolDatabase.findVariableTypeInBase:Type*(Scope*,Token*)",<empty>,,false,5415,5435,findVariableTypeInBase,,,1,"Type*(Scope*,Token*)"
111669153284,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Type* SymbolDatabase::findVariableType(const Scope *start, const Token *typeTok) const
{
    const Scope *scope = start;

    // check if type does not have a namespace
    if (typeTok->strAt(-1) != ""::"" && typeTok->strAt(1) != ""::"") {
        // check if type same as scope
        if (start->isClassOrStruct() && typeTok->str() == start->className)
            return start->definedType;

        while (scope) {
            // look for type in this scope
            const Type * type = scope->findType(typeTok->str());

            if (type)
                return type;

            // look for type in base classes if possible
            if (scope->isClassOrStruct()) {
                type = findVariableTypeInBase(scope, typeTok);

                if (type)
                    return type;
            }

            // check if in member function class to see if it's present in class
            if (scope->type == ScopeType::eFunction && scope->functionOf) {
                con...",1,1,lib/symboldatabase.cpp,"SymbolDatabase.findVariableType<const>:Type*(Scope*,Token*)",<empty>,,false,5439,5551,findVariableType,,,1,"Type*(Scope*,Token*)"
111669153285,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static bool hasEmptyCaptureList(const Token* tok) {
    if (!Token::simpleMatch(tok, ""{""))
        return false;
    const Token* listTok = tok->astParent();
    if (Token::simpleMatch(listTok, ""(""))
        listTok = listTok->astParent();
    return Token::simpleMatch(listTok, ""[ ]"");
}",1,1,lib/symboldatabase.cpp,hasEmptyCaptureList:bool(Token*),<empty>,,false,5553,5560,hasEmptyCaptureList,,,1,bool(Token*)
111669153286,METHOD,<empty>,<empty>,"[&](const Scope* s) {
        // Inline function
        if (s->type == ScopeType::eUnconditional && Token::simpleMatch(s->bodyStart->previous(), "") {"")) {
            if (tokStart)
                *tokStart = nullptr; // bailout for e.g. loop-like macros
            return true;
        }
        // Lambda function
        if (!onlyInline && s->type == ScopeType::eLambda && !hasEmptyCaptureList(s->bodyStart)) {
            if (tokStart)
                *tokStart = s->bodyStart;
            return true;
        }
        if (s->hasInlineOrLambdaFunction(tokStart, onlyInline))
            return true;
        return false;
    }",62,5,lib/symboldatabase.cpp,lib/symboldatabase.cpp:<global>.Scope.hasInlineOrLambdaFunction<const>.<lambda>16:bool(Scope*),<empty>,,false,5564,5580,<lambda>16,,,1,bool(Scope*)
111669153287,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool Scope::hasInlineOrLambdaFunction(const Token** tokStart, bool onlyInline) const
{
    return std::any_of(nestedList.begin(), nestedList.end(), [&](const Scope* s) {
        // Inline function
        if (s->type == ScopeType::eUnconditional && Token::simpleMatch(s->bodyStart->previous(), "") {"")) {
            if (tokStart)
                *tokStart = nullptr; // bailout for e.g. loop-like macros
            return true;
        }
        // Lambda function
        if (!onlyInline && s->type == ScopeType::eLambda && !hasEmptyCaptureList(s->bodyStart)) {
            if (tokStart)
                *tokStart = s->bodyStart;
            return true;
        }
        if (s->hasInlineOrLambdaFunction(tokStart, onlyInline))
            return true;
        return false;
    });
}",1,1,lib/symboldatabase.cpp,"Scope.hasInlineOrLambdaFunction<const>:bool(Token**,bool)",<empty>,,false,5562,5581,hasInlineOrLambdaFunction,,,1,"bool(Token**,bool)"
111669153288,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void Scope::findFunctionInBase(const std::string & name, nonneg int args, std::vector<const Function *> & matches) const
{
    if (isClassOrStruct() && definedType && !definedType->derivedFrom.empty()) {
        const std::vector<Type::BaseInfo> &derivedFrom = definedType->derivedFrom;
        for (const Type::BaseInfo & i : derivedFrom) {
            const Type *base = i.type;
            if (base && base->classScope) {
                if (base->classScope == this) // Ticket #5120, #5125: Recursive class; tok should have been found already
                    continue;

                auto range = utils::as_const(base->classScope->functionMap).equal_range(name);
                for (auto it = range.first; it != range.second; ++it) {
                    const Function *func = it->second;
                    if ((func->isVariadic() && args >= (func->argCount() - 1)) ||
                        (args == func->argCount() || (args < func->argCount() && args >= func->minArgCount()))) {
 ...",1,57,lib/symboldatabase.cpp,"Scope.findFunctionInBase<const>:void(std.string&,int,std.vector<constFunction*>&)",<empty>,,false,5583,5606,findFunctionInBase,,,1,"void(std.string&,int,std.vector<constFunction*>&)"
111669153289,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Scope *Scope::findRecordInBase(const std::string & name) const
{
    if (isClassOrStruct() && definedType && !definedType->derivedFrom.empty()) {
        const std::vector<Type::BaseInfo> &derivedFrom = definedType->derivedFrom;
        for (const Type::BaseInfo & i : derivedFrom) {
            const Type *base = i.type;
            if (base && base->classScope) {
                if (base->classScope == this) // Recursive class; tok should have been found already
                    continue;

                if (base->name() == name) {
                    return base->classScope;
                }

                const ::Type * t = base->classScope->findType(name);
                if (t)
                    return t->classScope;
            }
        }
    }

    return nullptr;
}",1,1,lib/symboldatabase.cpp,Scope.findRecordInBase<const>:Scope*(std.string&),<empty>,,false,5608,5630,findRecordInBase,,,1,Scope*(std.string&)
111669153290,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"std::vector<const Scope*> Scope::findAssociatedScopes() const
{
    std::vector<const Scope*> result = {this};
    if (isClassOrStruct() && definedType && !definedType->derivedFrom.empty()) {
        const std::vector<Type::BaseInfo>& derivedFrom = definedType->derivedFrom;
        for (const Type::BaseInfo& i : derivedFrom) {
            const Type* base = i.type;
            if (base && base->classScope) {
                if (contains(result, base->classScope))
                    continue;
                std::vector<const Scope*> baseScopes = base->classScope->findAssociatedScopes();
                result.insert(result.end(), baseScopes.cbegin(), baseScopes.cend());
            }
        }
    }
    return result;
}",1,1,lib/symboldatabase.cpp,Scope.findAssociatedScopes<const>:vector<constScope*>(),<empty>,,false,5632,5648,findAssociatedScopes,,,1,vector<const Scope*>()
111669153291,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static void checkVariableCallMatch(const Variable* callarg, const Variable* funcarg, size_t& same, size_t& fallback1, size_t& fallback2)
{
    if (callarg) {
        const ValueType::MatchResult res = ValueType::matchParameter(callarg->valueType(), callarg, funcarg);
        if (res == ValueType::MatchResult::SAME) {
            same++;
            return;
        }
        if (res == ValueType::MatchResult::FALLBACK1) {
            fallback1++;
            return;
        }
        if (res == ValueType::MatchResult::FALLBACK2) {
            fallback2++;
            return;
        }
        if (res == ValueType::MatchResult::NOMATCH)
            return;

        const bool ptrequals = callarg->isArrayOrPointer() == funcarg->isArrayOrPointer();
        const bool constEquals = !callarg->isArrayOrPointer() || ((callarg->typeStartToken()->strAt(-1) == ""const"") == (funcarg->typeStartToken()->strAt(-1) == ""const""));
        if (ptrequals && constEquals &&
            callarg->typeStartT...",1,1,lib/symboldatabase.cpp,"checkVariableCallMatch:void(Variable*,Variable*,size_t&,size_t&,size_t&)",<empty>,,false,5652,5694,checkVariableCallMatch,,,1,"void(Variable*,Variable*,size_t&,size_t&,size_t&)"
111669153292,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static std::string getTypeString(const Token *typeToken)
{
    if (!typeToken)
        return """";
    while (Token::Match(typeToken, ""%name%|*|&|::"")) {
        if (typeToken->str() == ""::"") {
            std::string ret;
            while (Token::Match(typeToken, "":: %name%"")) {
                ret += ""::"" + typeToken->strAt(1);
                typeToken = typeToken->tokAt(2);
                if (typeToken->str() == ""<"") {
                    for (const Token *tok = typeToken; tok != typeToken->link(); tok = tok->next())
                        ret += tok->str();
                    ret += "">"";
                    typeToken = typeToken->link()->next();
                }
            }
            return ret;
        }
        if (Token::Match(typeToken, ""%name% const| %var%|*|&"")) {
            return typeToken->str();
        }
        typeToken = typeToken->next();
    }
    return """";
}",1,1,lib/symboldatabase.cpp,getTypeString:string(Token*),<empty>,,false,5696,5721,getTypeString,,,1,string(Token*)
111669153293,METHOD,<empty>,<empty>,"[&](const Function& f) {
        if (!f.isConstructor() || f.argCount() != 1 || !f.getArgumentVar(0))
            return false;
        const ValueType* vt = f.getArgumentVar(0)->valueType();
        return vt &&
        vt->type == argType->type &&
        (argType->sign == ValueType::Sign::UNKNOWN_SIGN || vt->sign == argType->sign) &&
        vt->pointer == argType->pointer &&
        (vt->constness & 1) >= (argType->constness & 1) &&
        (vt->volatileness & 1) >= (argType->volatileness & 1);
    }",24,5,lib/symboldatabase.cpp,lib/symboldatabase.cpp:<global>.hasMatchingConstructor.<lambda>17:bool(Function&),<empty>,,false,5728,5738,<lambda>17,,,1,bool(Function&)
111669153294,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static bool hasMatchingConstructor(const Scope* classScope, const ValueType* argType) {
    if (!classScope || !argType)
        return false;
    return std::any_of(classScope->functionList.cbegin(),
                       classScope->functionList.cend(),
                       [&](const Function& f) {
        if (!f.isConstructor() || f.argCount() != 1 || !f.getArgumentVar(0))
            return false;
        const ValueType* vt = f.getArgumentVar(0)->valueType();
        return vt &&
        vt->type == argType->type &&
        (argType->sign == ValueType::Sign::UNKNOWN_SIGN || vt->sign == argType->sign) &&
        vt->pointer == argType->pointer &&
        (vt->constness & 1) >= (argType->constness & 1) &&
        (vt->volatileness & 1) >= (argType->volatileness & 1);
    });
}",1,1,lib/symboldatabase.cpp,"hasMatchingConstructor:bool(Scope*,ValueType*)",<empty>,,false,5723,5739,hasMatchingConstructor,,,1,"bool(Scope*,ValueType*)"
111669153295,METHOD,<empty>,<empty>,"[&](const Scope *scope) {
        auto range = utils::as_const(scope->functionMap).equal_range(tok->str());
        for (auto it = range.first; it != range.second; ++it) {
            const Function *func = it->second;
            if (ref == Reference::LValue && func->hasRvalRefQualifier())
                continue;
            if (ref == Reference::None && func->hasRvalRefQualifier()) {
                if (Token::simpleMatch(tok->astParent(), ""."")) {
                    const Token* obj = tok->astParent()->astOperand1();
                    while (obj && obj->str() == ""["")
                        obj = obj->astOperand1();
                    if (!obj || obj->isName())
                        continue;
                }
            }
            if (func->isDestructor() && !Token::simpleMatch(tok->tokAt(-1), ""~""))
                continue;
            if (!isCall || args == func->argCount() ||
                (func->isVariadic() && args >= (func->minArgCount() - 1)) ||
             ...",33,5,lib/symboldatabase.cpp,lib/symboldatabase.cpp:<global>.Scope.findFunction<const>.<lambda>18:void(Scope*),<empty>,,false,5752,5775,<lambda>18,,,1,void(Scope*)
111669153296,METHOD,<empty>,<empty>,"[](const Token *typeToken) -> ValueType {
                        ValueType ret;
                        while (Token::Match(typeToken->previous(), ""%name%""))
                            typeToken = typeToken->previous();
                        while (Token::Match(typeToken, ""%name%|*|&|::|<""))
                        {
                            if (typeToken->str() == ""const"")
                                ret.constness |= (1 << ret.pointer);
                            else if (typeToken->str() == ""volatile"")
                                ret.volatileness |= (1 << ret.pointer);
                            else if (typeToken->str() == ""*"")
                                ret.pointer++;
                            else if (typeToken->str() == ""<"") {
                                if (!typeToken->link())
                                    break;
                                typeToken = typeToken->link();
                            }
                            typeToken ...",38,21,lib/symboldatabase.cpp,lib/symboldatabase.cpp:<global>.Scope.findFunction<const>.<lambda>19:ValueType(Token*),<empty>,,false,5852,5872,<lambda>19,,,1,ValueType(Token*)
111669153297,METHOD,<empty>,<empty>,"[](const std::pair<const Function*, size_t>& a, const std::pair<const Function*, size_t>& b) {
        return a.second > b.second;
    }",20,5,lib/symboldatabase.cpp,"lib/symboldatabase.cpp:<global>.Scope.findFunction<const>.<lambda>20:bool(std.pair<constFunction*,size_t>&,std.pair<constFunction*,size_t>&)",<empty>,,false,5986,5988,<lambda>20,,,1,"bool(std.pair<constFunction*,size_t>&,std.pair<constFunction*,size_t>&)"
111669153298,METHOD,<empty>,<empty>,"[](const Function* m) {
        return m->isPure();
    }",64,5,lib/symboldatabase.cpp,lib/symboldatabase.cpp:<global>.Scope.findFunction<const>.<lambda>21:bool(Function*),<empty>,,false,6009,6011,<lambda>21,,,1,bool(Function*)
111669153299,METHOD,<empty>,<empty>,"[&](const Function* m) {
        return m->isImplicitlyVirtual() && m != *itPure;
    }",80,5,lib/symboldatabase.cpp,lib/symboldatabase.cpp:<global>.Scope.findFunction<const>.<lambda>22:bool(Function*),<empty>,,false,6012,6014,<lambda>22,,,1,bool(Function*)
111669153300,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Function* Scope::findFunction(const Token *tok, bool requireConst, Reference ref) const
{
    const bool isCall = Token::Match(tok->next(), ""(|{"");

    const std::vector<const Token *> arguments = getArguments(tok);

    std::vector<const Function *> matches;

    // find all the possible functions that could match
    const std::size_t args = arguments.size();

    auto addMatchingFunctions = [&](const Scope *scope) {
        auto range = utils::as_const(scope->functionMap).equal_range(tok->str());
        for (auto it = range.first; it != range.second; ++it) {
            const Function *func = it->second;
            if (ref == Reference::LValue && func->hasRvalRefQualifier())
                continue;
            if (ref == Reference::None && func->hasRvalRefQualifier()) {
                if (Token::simpleMatch(tok->astParent(), ""."")) {
                    const Token* obj = tok->astParent()->astOperand1();
                    while (obj && obj->str() == ""["")
            ...",1,1,lib/symboldatabase.cpp,"Scope.findFunction<const>:Function*(Token*,bool,Reference)",<empty>,,false,5741,6041,findFunction,,,1,"Function*(Token*,bool,Reference)"
111669153301,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Function* SymbolDatabase::findFunction(const Token* const tok) const
{
    if (tok->tokType() == Token::Type::eEnumerator)
        return nullptr;

    // find the scope this function is in
    const Scope *currScope = tok->scope();
    while (currScope && currScope->isExecutable()) {
        if (const Function* f = currScope->findFunction(tok)) {
            return f;
        }
        if (currScope->functionOf)
            currScope = currScope->functionOf;
        else
            currScope = currScope->nestedIn;
    }

    // check for a qualified name and use it when given
    if (tok->strAt(-1) == ""::"") {
        // find start of qualified function name
        const Token *tok1 = tok;

        while (Token::Match(tok1->tokAt(-2), "">|%type% ::"")) {
            if (tok1->strAt(-2) == "">"") {
                if (tok1->linkAt(-2))
                    tok1 = tok1->linkAt(-2)->tokAt(-1);
                else
                    break;
            } else
                tok1 = ...",1,1,lib/symboldatabase.cpp,SymbolDatabase.findFunction<const>:Function*(Token*),<empty>,,false,6045,6189,findFunction,,,1,Function*(Token*)
111669153302,METHOD,<empty>,<empty>,"[&](const Scope& s) {
        return s.className == name;
    }",66,5,lib/symboldatabase.cpp,lib/symboldatabase.cpp:<global>.SymbolDatabase.findScopeByName<const>.<lambda>23:bool(Scope&),<empty>,,false,6195,6197,<lambda>23,,,1,bool(Scope&)
111669153303,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Scope *SymbolDatabase::findScopeByName(const std::string& name) const
{
    auto it = std::find_if(scopeList.cbegin(), scopeList.cend(), [&](const Scope& s) {
        return s.className == name;
    });
    return it == scopeList.end() ? nullptr : &*it;
}",1,1,lib/symboldatabase.cpp,SymbolDatabase.findScopeByName<const>:Scope*(std.string&),<empty>,,false,6193,6199,findScopeByName,,,1,Scope*(std.string&)
111669153304,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static S* findRecordInNestedListImpl(S& thisScope, const std::string& name, bool isC, std::set<const Scope*>& visited)
{
    for (S* scope: thisScope.nestedList) {
        if (scope->className == name && scope->type != ScopeType::eFunction)
            return scope;
        if (isC) {
            S* nestedScope = scope->findRecordInNestedList(name, isC);
            if (nestedScope)
                return nestedScope;
        }
    }

    for (const auto& u : thisScope.usingList) {
        if (!u.scope || u.scope == &thisScope || visited.find(u.scope) != visited.end())
            continue;
        visited.emplace(u.scope);
        S* nestedScope = findRecordInNestedListImpl<S, T>(const_cast<S&>(*u.scope), name, false, visited);
        if (nestedScope)
            return nestedScope;
    }

    T * nested_type = thisScope.findType(name);

    if (nested_type) {
        if (nested_type->isTypeAlias()) {
            if (nested_type->typeStart == nested_type->typeEnd)
                ...",1,1,lib/symboldatabase.cpp,"findRecordInNestedListImpl:S(S&,std.string&,bool,std.set<constScope*>&)",<empty>,,false,6204,6236,findRecordInNestedListImpl,,,1,"S(S&,std.string&,bool,std.set<constScope*>&)"
111669153305,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Scope* Scope::findRecordInNestedList(const std::string & name, bool isC) const
{
    std::set<const Scope*> visited;
    return findRecordInNestedListImpl<const Scope, const Type>(*this, name, isC, visited);
}",1,1,lib/symboldatabase.cpp,"Scope.findRecordInNestedList<const>:Scope*(std.string&,bool)",<empty>,,false,6238,6242,findRecordInNestedList,,,1,"Scope*(std.string&,bool)"
111669153306,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"Scope* Scope::findRecordInNestedList(const std::string & name, bool isC)
{
    std::set<const Scope*> visited;
    return findRecordInNestedListImpl<Scope, Type>(*this, name, isC, visited);
}",1,1,lib/symboldatabase.cpp,"Scope.findRecordInNestedList:Scope*(std.string&,bool)",<empty>,,false,6244,6248,findRecordInNestedList,,,1,"Scope*(std.string&,bool)"
111669153307,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static T* findTypeImpl(S& thisScope, const std::string & name)
{
    auto it = thisScope.definedTypesMap.find(name);

    // Type was found
    if (thisScope.definedTypesMap.end() != it)
        return it->second;

    // is type defined in anonymous namespace..
    it = thisScope.definedTypesMap.find(emptyString);
    if (it != thisScope.definedTypesMap.end()) {
        for (S *scope : thisScope.nestedList) {
            if (scope->className.empty() && (scope->type == ScopeType::eNamespace || scope->isClassOrStructOrUnion())) {
                T *t = scope->findType(name);
                if (t)
                    return t;
            }
        }
    }

    // Type was not found
    return nullptr;
}",1,1,lib/symboldatabase.cpp,"findTypeImpl:T(S&,std.string&)",<empty>,,false,6253,6275,findTypeImpl,,,1,"T(S&,std.string&)"
111669153308,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Type* Scope::findType(const std::string& name) const
{
    return findTypeImpl<const Scope, const Type>(*this, name);
}",1,1,lib/symboldatabase.cpp,Scope.findType<const>:Type*(std.string&),<empty>,,false,6277,6280,findType,,,1,Type*(std.string&)
111669153309,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"Type* Scope::findType(const std::string& name)
{
    return findTypeImpl<Scope, Type>(*this, name);
}",1,1,lib/symboldatabase.cpp,Scope.findType:Type*(std.string&),<empty>,,false,6282,6285,findType,,,1,Type*(std.string&)
111669153310,METHOD,<empty>,<empty>,"[&](const Scope* s) {
        return s->className == name;
    }",68,5,lib/symboldatabase.cpp,lib/symboldatabase.cpp:<global>.Scope.findInNestedListRecursive.<lambda>24:bool(Scope*),<empty>,,false,6291,6293,<lambda>24,,,1,bool(Scope*)
111669153311,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"Scope *Scope::findInNestedListRecursive(const std::string & name)
{
    auto it = std::find_if(nestedList.cbegin(), nestedList.cend(), [&](const Scope* s) {
        return s->className == name;
    });
    if (it != nestedList.end())
        return *it;

    for (Scope* scope: nestedList) {
        Scope *child = scope->findInNestedListRecursive(name);
        if (child)
            return child;
    }
    return nullptr;
}",1,1,lib/symboldatabase.cpp,Scope.findInNestedListRecursive:Scope*(std.string&),<empty>,,false,6289,6303,findInNestedListRecursive,,,1,Scope*(std.string&)
111669153312,METHOD,<empty>,<empty>,"[](const Function& f) {
        return f.type == FunctionType::eDestructor;
    }",72,5,lib/symboldatabase.cpp,lib/symboldatabase.cpp:<global>.Scope.getDestructor<const>.<lambda>25:bool(Function&),<empty>,,false,6309,6311,<lambda>25,,,1,bool(Function&)
111669153313,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Function *Scope::getDestructor() const
{
    auto it = std::find_if(functionList.cbegin(), functionList.cend(), [](const Function& f) {
        return f.type == FunctionType::eDestructor;
    });
    return it == functionList.end() ? nullptr : &*it;
}",1,1,lib/symboldatabase.cpp,Scope.getDestructor<const>:Function*(),<empty>,,false,6307,6313,getDestructor,,,1,Function*()
111669153314,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Scope *SymbolDatabase::findScope(const Token *tok, const Scope *startScope) const
{
    const Scope *scope = nullptr;
    // absolute path
    if (tok->str() == ""::"") {
        tok = tok->next();
        scope = &scopeList.front();
    }
    // relative path
    else if (tok->isName()) {
        scope = startScope;
    }

    while (scope && tok && tok->isName()) {
        if (tok->strAt(1) == ""::"") {
            scope = scope->findRecordInNestedList(tok->str());
            tok = tok->tokAt(2);
        } else if (tok->strAt(1) == ""<"")
            return nullptr;
        else
            return scope->findRecordInNestedList(tok->str());
    }

    // not a valid path
    return nullptr;
}",1,1,lib/symboldatabase.cpp,"SymbolDatabase.findScope<const>:Scope*(Token*,Scope*)",<empty>,,false,6317,6342,findScope,,,1,"Scope*(Token*,Scope*)"
111669153315,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Type* SymbolDatabase::findType(const Token *startTok, const Scope *startScope, bool lookOutside) const
{
    // skip over struct or union
    if (Token::Match(startTok, ""struct|union""))
        startTok = startTok->next();

    // type same as scope
    if (startTok->str() == startScope->className && startScope->isClassOrStruct() && startTok->strAt(1) != ""::"")
        return startScope->definedType;

    if (startTok->isC()) {
        const Scope* scope = startScope;
        while (scope) {
            if (startTok->str() == scope->className && scope->isClassOrStruct())
                return scope->definedType;
            const Scope* typeScope = scope->findRecordInNestedList(startTok->str(), /*isC*/ true);
            if (typeScope) {
                if (startTok->str() == typeScope->className && typeScope->isClassOrStruct()) {
                    if (const Type* type = typeScope->definedType)
                        return type;
                }
            }
            ...",1,1,lib/symboldatabase.cpp,"SymbolDatabase.findType<const>:Type*(Token*,Scope*,bool)",<empty>,,false,6346,6457,findType,,,1,"Type*(Token*,Scope*,bool)"
111669153316,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Type* SymbolDatabase::findTypeInNested(const Token *startTok, const Scope *startScope) const
{
    // skip over struct or union
    if (Token::Match(startTok, ""struct|union|enum""))
        startTok = startTok->next();

    // type same as scope
    if (startScope->isClassOrStruct() && startTok->str() == startScope->className && !Token::simpleMatch(startTok->next(), ""::""))
        return startScope->definedType;

    bool hasPath = false;

    // absolute path - directly start in global scope
    if (startTok->str() == ""::"") {
        hasPath = true;
        startTok = startTok->next();
        startScope = &scopeList.front();
    }

    const Token* tok = startTok;
    const Scope* scope = startScope;

    while (scope && tok && tok->isName()) {
        if (tok->strAt(1) == ""::"" || (tok->strAt(1) == ""<"" && Token::simpleMatch(tok->linkAt(1), ""> ::""))) {
            hasPath = true;
            scope = scope->findRecordInNestedList(tok->str());
            if (scope) {
          ...",1,1,lib/symboldatabase.cpp,"SymbolDatabase.findTypeInNested<const>:Type*(Token*,Scope*)",<empty>,,false,6461,6512,findTypeInNested,,,1,"Type*(Token*,Scope*)"
111669153317,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"const Scope * SymbolDatabase::findNamespace(const Token * tok, const Scope * scope) const
{
    const Scope * s = findScope(tok, scope);

    if (s)
        return s;
    if (scope->nestedIn)
        return findNamespace(tok, scope->nestedIn);

    return nullptr;
}",1,1,lib/symboldatabase.cpp,"SymbolDatabase.findNamespace<const>:Scope*(Token*,Scope*)",<empty>,,false,6516,6526,findNamespace,,,1,"Scope*(Token*,Scope*)"
111669153318,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"Function * SymbolDatabase::findFunctionInScope(const Token *func, const Scope *ns, const std::string & path, nonneg int path_length)
{
    const Function * function = nullptr;
    const bool destructor = func->strAt(-1) == ""~"";

    auto range = utils::as_const(ns->functionMap).equal_range(func->str());
    for (auto it = range.first; it != range.second; ++it) {
        if (it->second->argsMatch(ns, it->second->argDef, func->next(), path, path_length) &&
            it->second->isDestructor() == destructor) {
            function = it->second;
            break;
        }
    }

    if (!function) {
        const Scope * scope = ns->findRecordInNestedList(func->str());
        if (scope && Token::Match(func->tokAt(1), ""::|<"")) {
            if (func->strAt(1) == ""::"")
                func = func->tokAt(2);
            else if (func->linkAt(1))
                func = func->linkAt(1)->tokAt(2);
            else
                return nullptr;
            if (func->str() == ""~"")
      ...",1,109,lib/symboldatabase.cpp,"SymbolDatabase.findFunctionInScope:Function*(Token*,Scope*,std.string&,int)",<empty>,,false,6530,6560,findFunctionInScope,,,1,"Function*(Token*,Scope*,std.string&,int)"
111669153319,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool SymbolDatabase::isReservedName(const Token* tok)
{
    const std::string& iName = tok->str();
    if (tok->isCpp()) {
        static const auto& cpp_keywords = Keywords::getAll(Standards::cppstd_t::CPPLatest);
        return cpp_keywords.find(iName) != cpp_keywords.cend();
    }
    static const auto& c_keywords = Keywords::getAll(Standards::cstd_t::CLatest);
    return c_keywords.find(iName) != c_keywords.cend();
}",1,1,lib/symboldatabase.cpp,SymbolDatabase.isReservedName:bool(Token*),<empty>,,false,6564,6573,isReservedName,,,1,bool(Token*)
111669153320,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"int SymbolDatabase::sizeOfType(const Token *type) const
{
    int size = mTokenizer.sizeOfType(type);

    if (size == 0 && type->type() && type->type()->isEnumType() && type->type()->classScope) {
        size = mSettings.platform.sizeof_int;
        const Token * enum_type = type->type()->classScope->enumType;
        if (enum_type)
            size = mTokenizer.sizeOfType(enum_type);
    }

    return size;
}",8,1,lib/symboldatabase.cpp,SymbolDatabase.sizeOfType<const>:int(Token*),<empty>,,false,6575,6587,sizeOfType,,,1,int(Token*)
111669153321,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::setValueType(Token* tok, const Variable& var, const SourceLocation &loc)
{
    ValueType valuetype;
    if (mSettings.debugnormal || mSettings.debugwarnings)
        valuetype.setDebugPath(tok, loc);
    if (var.nameToken())
        valuetype.bits = var.nameToken()->bits();

    valuetype.pointer = var.dimensions().size();
    // HACK: don't set pointer for plain std::array
    if (var.valueType() && var.valueType()->container && Token::simpleMatch(var.typeStartToken(), ""std :: array"") && !Token::simpleMatch(var.nameToken()->next(), ""[""))
        valuetype.pointer = 0;

    valuetype.typeScope = var.typeScope();
    if (var.valueType()) {
        valuetype.container = var.valueType()->container;
        valuetype.containerTypeToken = var.valueType()->containerTypeToken;
    }
    valuetype.smartPointerType = var.smartPointerType();
    if (parsedecl(var.typeStartToken(), &valuetype, mDefaultSignedness, mSettings)) {
        if (tok->str() == ""."" && tok->astOpera...",1,1,lib/symboldatabase.cpp,"SymbolDatabase.setValueType:void(Token*,Variable&,SourceLocation&)",<empty>,,false,6595,6632,setValueType,,,1,"void(Token*,Variable&,SourceLocation&)"
111669153322,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::setValueType(Token* tok, const Enumerator& enumerator, const SourceLocation &loc)
{
    ValueType valuetype;
    if (mSettings.debugnormal || mSettings.debugwarnings)
        valuetype.setDebugPath(tok, loc);
    valuetype.typeScope = enumerator.scope;
    const Token * type = enumerator.scope->enumType;
    if (type && type->astParent())
        type = type->astParent();
    if (type) {
        valuetype.type = ValueType::typeFromString(type->str(), type->isLong());
        if (valuetype.type == ValueType::Type::UNKNOWN_TYPE)
            valuetype.fromLibraryType(type->expressionString(), mSettings);

        if (valuetype.isIntegral()) {
            if (type->isSigned())
                valuetype.sign = ValueType::Sign::SIGNED;
            else if (type->isUnsigned())
                valuetype.sign = ValueType::Sign::UNSIGNED;
            else if (valuetype.type == ValueType::Type::CHAR)
                valuetype.sign = mDefaultSignedness;
            else
   ...",1,1,lib/symboldatabase.cpp,"SymbolDatabase.setValueType:void(Token*,Enumerator&,SourceLocation&)",<empty>,,false,6636,6667,setValueType,,,1,"void(Token*,Enumerator&,SourceLocation&)"
111669153323,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static void setAutoTokenProperties(Token * const autoTok)
{
    const ValueType *valuetype = autoTok->valueType();
    if (valuetype->isIntegral() || valuetype->isFloat())
        autoTok->isStandardType(true);
}",1,1,lib/symboldatabase.cpp,setAutoTokenProperties:void(Token*),<empty>,,false,6669,6674,setAutoTokenProperties,,,1,void(Token*)
111669153324,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static bool isContainerYieldElement(Library::Container::Yield yield)
{
    return yield == Library::Container::Yield::ITEM || yield == Library::Container::Yield::AT_INDEX ||
           yield == Library::Container::Yield::BUFFER || yield == Library::Container::Yield::BUFFER_NT;
}",1,1,lib/symboldatabase.cpp,isContainerYieldElement:bool(Library.Container.Yield),<empty>,,false,6676,6680,isContainerYieldElement,,,1,bool(Library.Container.Yield)
111669153325,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static bool isContainerYieldPointer(Library::Container::Yield yield)
{
    return yield == Library::Container::Yield::BUFFER || yield == Library::Container::Yield::BUFFER_NT;
}",1,1,lib/symboldatabase.cpp,isContainerYieldPointer:bool(Library.Container.Yield),<empty>,,false,6682,6685,isContainerYieldPointer,,,1,bool(Library.Container.Yield)
111669153326,METHOD,<empty>,<empty>,"[&name](const Variable& v) {
                return v.nameToken()->str() == name;
            }",90,13,lib/symboldatabase.cpp,lib/symboldatabase.cpp:<global>.SymbolDatabase.setValueType.<lambda>26:bool(Variable&),<empty>,,false,6900,6902,<lambda>26,,,1,bool(Variable&)
111669153327,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::setValueType(Token* tok, const ValueType& valuetype, const SourceLocation &loc)
{
    auto* valuetypePtr = new ValueType(valuetype);
    if (mSettings.debugnormal || mSettings.debugwarnings)
        valuetypePtr->setDebugPath(tok, loc);
    tok->setValueType(valuetypePtr);
    Token *parent = tok->astParent();
    if (!parent || parent->valueType())
        return;
    if (!parent->astOperand1())
        return;

    const ValueType *vt1 = parent->astOperand1()->valueType();
    const ValueType *vt2 = parent->astOperand2() ? parent->astOperand2()->valueType() : nullptr;

    if (vt1 && Token::Match(parent, ""<<|>>"")) {
        if (!parent->isCpp() || (vt2 && vt2->isIntegral())) {
            if (vt1->type < ValueType::Type::BOOL || vt1->type >= ValueType::Type::INT) {
                ValueType vt(*vt1);
                vt.reference = Reference::None;
                setValueType(parent, vt);
            } else {
                ValueType vt(*vt1);
               ...",1,1,lib/symboldatabase.cpp,"SymbolDatabase.setValueType:void(Token*,ValueType&,SourceLocation&)",<empty>,,false,6687,7183,setValueType,,,1,"void(Token*,ValueType&,SourceLocation&)"
111669153328,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static ValueType::Type getEnumType(const Scope* scope, const Platform& platform) // TODO: also determine sign?
{
    ValueType::Type type = ValueType::Type::INT;
    for (const Token* tok = scope->bodyStart; tok && tok != scope->bodyEnd; tok = tok->next()) {
        if (const Token* lam = findLambdaEndToken(tok)) {
            tok = lam;
            continue;
        }
        if (!tok->isAssignmentOp())
            continue;
        const Token* vTok = tok->astOperand2();
        if (!vTok->hasKnownIntValue()) {
            if (!vTok->isLiteral())
                continue;
            if (const ValueType* vt = vTok->valueType()) {
                if ((vt->type > type && (vt->type == ValueType::Type::LONG || vt->type == ValueType::Type::LONGLONG)))
                    type = vt->type;
            }
            continue;
        }
        const MathLib::bigint value = vTok->getKnownIntValue();
        if (!platform.isIntValue(value)) {
            type = ValueType::Type::LONG;
      ...",1,1,lib/symboldatabase.cpp,"getEnumType:ValueType.Type(Scope*,Platform&)",<empty>,,false,7185,7213,getEnumType,,,1,"ValueType.Type(Scope*,Platform&)"
111669153329,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static const Token* parsedecl(const Token* type,
                              ValueType* const valuetype,
                              ValueType::Sign defaultSignedness,
                              const Settings& settings,
                              SourceLocation loc)
{
    if (settings.debugnormal || settings.debugwarnings)
        valuetype->setDebugPath(type, loc);
    const Token * const previousType = type;
    const int pointer0 = valuetype->pointer;
    while (Token::Match(type->previous(), ""%name%"") && !endsWith(type->strAt(-1), ':'))
        type = type->previous();
    valuetype->sign = ValueType::Sign::UNKNOWN_SIGN;
    if (!valuetype->typeScope && !valuetype->smartPointerType)
        valuetype->type = ValueType::Type::UNKNOWN_TYPE;
    else if (valuetype->smartPointerType)
        valuetype->type = ValueType::Type::SMART_POINTER;
    else if (valuetype->typeScope->type == ScopeType::eEnum) {
        const Token * enum_type = valuetype->typeScope->enumType;
    ...",1,1,lib/symboldatabase.cpp,"parsedecl:Token*(Token*,ValueType*,ValueType.Sign,Settings&,SourceLocation)",<empty>,,false,7215,7439,parsedecl,,,1,"Token*(Token*,ValueType*,ValueType.Sign,Settings&,SourceLocation)"
111669153330,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static const Scope *getClassScope(const Token *tok)
{
    return tok && tok->valueType() && tok->valueType()->typeScope && tok->valueType()->typeScope->isClassOrStruct() ?
           tok->valueType()->typeScope :
           nullptr;
}",1,1,lib/symboldatabase.cpp,getClassScope:Scope*(Token*),<empty>,,false,7441,7446,getClassScope,,,1,Scope*(Token*)
111669153331,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static const Function *getOperatorFunction(const Token * const tok)
{
    const std::string functionName(""operator"" + tok->str());

    const Scope *classScope = getClassScope(tok->astOperand1());
    if (classScope) {
        auto it = utils::as_const(classScope->functionMap).find(functionName);
        if (it != classScope->functionMap.end())
            return it->second;
    }

    classScope = getClassScope(tok->astOperand2());
    if (classScope) {
        auto it = utils::as_const(classScope->functionMap).find(functionName);
        if (it != classScope->functionMap.end())
            return it->second;
    }

    return nullptr;
}",1,1,lib/symboldatabase.cpp,getOperatorFunction:Function*(Token*),<empty>,,false,7448,7467,getOperatorFunction,,,1,Function*(Token*)
111669153332,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"static const Function* getFunction(const Token* tok) {
    if (!tok)
        return nullptr;
    if (tok->function() && tok->function()->retDef)
        return tok->function();
    if (const Variable* lvar = tok->variable()) { // lambda
        const Function* lambda{};
        if (Token::Match(lvar->nameToken()->next(), ""; %varid% = ["", lvar->declarationId()))
            lambda = lvar->nameToken()->tokAt(4)->function();
        else if (Token::simpleMatch(lvar->nameToken()->next(), ""{ [""))
            lambda = lvar->nameToken()->tokAt(2)->function();
        if (lambda && lambda->retDef)
            return lambda;
    }
    return nullptr;
}",1,1,lib/symboldatabase.cpp,getFunction:Function*(Token*),<empty>,,false,7469,7484,getFunction,,,1,Function*(Token*)
111669153333,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void SymbolDatabase::setValueTypeInTokenList(bool reportDebugWarnings, Token *tokens)
{
    if (!tokens)
        tokens = mTokenizer.list.front();

    for (Token *tok = tokens; tok; tok = tok->next())
        tok->setValueType(nullptr);

    for (Token *tok = tokens; tok; tok = tok->next()) {
        if (tok->isNumber()) {
            if (MathLib::isFloat(tok->str())) {
                ValueType::Type type = ValueType::Type::DOUBLE;
                const char suffix = tok->str()[tok->str().size() - 1];
                if (suffix == 'f' || suffix == 'F')
                    type = ValueType::Type::FLOAT;
                else if (suffix == 'L' || suffix == 'l')
                    type = ValueType::Type::LONGDOUBLE;
                setValueType(tok, ValueType(ValueType::Sign::UNKNOWN_SIGN, type, 0U));
            } else if (MathLib::isInt(tok->str())) {
                const std::string tokStr = MathLib::abs(tok->str());
                const bool unsignedSuffix = (tokStr.find_last_o...",1,12,lib/symboldatabase.cpp,"SymbolDatabase.setValueTypeInTokenList:void(bool,Token*)",<empty>,,false,7486,7918,setValueTypeInTokenList,,,1,"void(bool,Token*)"
111669153334,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"ValueType ValueType::parseDecl(const Token *type, const Settings &settings)
{
    ValueType vt;
    parsedecl(type, &vt, settings.platform.defaultSign == 'u' ? Sign::UNSIGNED : Sign::SIGNED, settings);
    return vt;
}",1,1,lib/symboldatabase.cpp,"ValueType.parseDecl:ValueType(Token*,Settings&)",<empty>,,false,7920,7925,parseDecl,,,1,"ValueType(Token*,Settings&)"
111669153335,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"ValueType::Type ValueType::typeFromString(const std::string &typestr, bool longType)
{
    if (typestr == ""void"")
        return ValueType::Type::VOID;
    if (typestr == ""bool"" || typestr == ""_Bool"")
        return ValueType::Type::BOOL;
    if (typestr== ""char"")
        return ValueType::Type::CHAR;
    if (typestr == ""short"")
        return ValueType::Type::SHORT;
    if (typestr == ""wchar_t"")
        return ValueType::Type::WCHAR_T;
    if (typestr == ""int"")
        return ValueType::Type::INT;
    if (typestr == ""long"")
        return longType ? ValueType::Type::LONGLONG : ValueType::Type::LONG;
    if (typestr == ""float"")
        return ValueType::Type::FLOAT;
    if (typestr == ""double"")
        return longType ? ValueType::Type::LONGDOUBLE : ValueType::Type::DOUBLE;
    return ValueType::Type::UNKNOWN_TYPE;
}",1,1,lib/symboldatabase.cpp,"ValueType.typeFromString:ValueType.Type(std.string&,bool)",<empty>,,false,7927,7948,typeFromString,,,1,"ValueType.Type(std.string&,bool)"
111669153336,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool ValueType::fromLibraryType(const std::string &typestr, const Settings &settings)
{
    const Library::PodType* podtype = settings.library.podtype(typestr);
    if (podtype && (podtype->sign == 's' || podtype->sign == 'u')) {
        if (podtype->size == 1)
            type = ValueType::Type::CHAR;
        else if (podtype->size == settings.platform.sizeof_int)
            type = ValueType::Type::INT;
        else if (podtype->size == settings.platform.sizeof_short)
            type = ValueType::Type::SHORT;
        else if (podtype->size == settings.platform.sizeof_long)
            type = ValueType::Type::LONG;
        else if (podtype->size == settings.platform.sizeof_long_long)
            type = ValueType::Type::LONGLONG;
        else if (podtype->stdtype == Library::PodType::Type::BOOL)
            type = ValueType::Type::BOOL;
        else if (podtype->stdtype == Library::PodType::Type::CHAR)
            type = ValueType::Type::CHAR;
        else if (podtype->stdtype == L...",1,1,lib/symboldatabase.cpp,"ValueType.fromLibraryType:bool(std.string&,Settings&)",<empty>,,false,7950,8026,fromLibraryType,,,1,"bool(std.string&,Settings&)"
111669153337,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"std::string ValueType::dump() const
{
    std::string ret;
    switch (type) {
    case UNKNOWN_TYPE:
        return """";
    case NONSTD:
        ret += ""valueType-type=\\""nonstd\\"""";
        break;
    case POD:
        ret += ""valueType-type=\\""pod\\"""";
        break;
    case RECORD:
        ret += ""valueType-type=\\""record\\"""";
        break;
    case SMART_POINTER:
        ret += ""valueType-type=\\""smart-pointer\\"""";
        break;
    case CONTAINER: {
        ret += ""valueType-type=\\""container\\"""";
        ret += "" valueType-containerId=\\"""";
        ret += id_string(container);
        ret += ""\\"""";
        break;
    }
    case ITERATOR:
        ret += ""valueType-type=\\""iterator\\"""";
        break;
    case VOID:
        ret += ""valueType-type=\\""void\\"""";
        break;
    case BOOL:
        ret += ""valueType-type=\\""bool\\"""";
        break;
    case CHAR:
        ret += ""valueType-type=\\""char\\"""";
        break;
    case SHORT:
        ret += ""valueType-type=\\""short\\"""";
        break;
  ...",1,1,lib/symboldatabase.cpp,ValueType.dump<const>:string(),<empty>,,false,8028,8149,dump,,,1,string()
111669153338,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool ValueType::isConst(nonneg int indirect) const
{
    if (indirect > pointer)
        return false;
    return constness & (1 << (pointer - indirect));
}",1,24,lib/symboldatabase.cpp,ValueType.isConst<const>:bool(int),<empty>,,false,8151,8156,isConst,,,1,bool(int)
111669153339,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool ValueType::isVolatile(nonneg int indirect) const
{
    if (indirect > pointer)
        return false;
    return volatileness & (1 << (pointer - indirect));
}",1,27,lib/symboldatabase.cpp,ValueType.isVolatile<const>:bool(int),<empty>,,false,8158,8163,isVolatile,,,1,bool(int)
111669153340,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"MathLib::bigint ValueType::typeSize(const Platform &platform, bool p) const
{
    if (p && pointer)
        return platform.sizeof_pointer;

    if (typeScope && typeScope->definedType && typeScope->definedType->sizeOf)
        return typeScope->definedType->sizeOf;

    switch (type) {
    case ValueType::Type::BOOL:
        return platform.sizeof_bool;
    case ValueType::Type::CHAR:
        return 1;
    case ValueType::Type::SHORT:
        return platform.sizeof_short;
    case ValueType::Type::WCHAR_T:
        return platform.sizeof_wchar_t;
    case ValueType::Type::INT:
        return platform.sizeof_int;
    case ValueType::Type::LONG:
        return platform.sizeof_long;
    case ValueType::Type::LONGLONG:
        return platform.sizeof_long_long;
    case ValueType::Type::FLOAT:
        return platform.sizeof_float;
    case ValueType::Type::DOUBLE:
        return platform.sizeof_double;
    case ValueType::Type::LONGDOUBLE:
        return platform.sizeof_long_double;
    ...",1,1,lib/symboldatabase.cpp,"ValueType.typeSize<const>:longlongint(Platform&,bool)",<empty>,,false,8164,8199,typeSize,,,1,"longlongint(Platform&,bool)"
111669153341,METHOD,<empty>,<empty>,"[](const ValueType* vt) {
        return std::tie(vt->type, vt->container, vt->pointer, vt->typeScope, vt->smartPointer);
    }",16,5,lib/symboldatabase.cpp,lib/symboldatabase.cpp:<global>.ValueType.isTypeEqual<const>.<lambda>27:ANY(ValueType*),<empty>,,false,8205,8207,<lambda>27,,,1,ANY(ValueType*)
111669153342,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"bool ValueType::isTypeEqual(const ValueType* that) const
{
    if (!that)
        return false;
    auto tie = [](const ValueType* vt) {
        return std::tie(vt->type, vt->container, vt->pointer, vt->typeScope, vt->smartPointer);
    };
    return tie(this) == tie(that);
}",1,1,lib/symboldatabase.cpp,ValueType.isTypeEqual<const>:bool(ValueType*),<empty>,,false,8201,8209,isTypeEqual,,,1,bool(ValueType*)
111669153343,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"std::string ValueType::str() const
{
    std::string ret;
    if (constness & 1)
        ret = "" const"";
    if (volatileness & 1)
        ret = "" volatile"";
    if (type == VOID)
        ret += "" void"";
    else if (isIntegral()) {
        if (sign == SIGNED)
            ret += "" signed"";
        else if (sign == UNSIGNED)
            ret += "" unsigned"";
        if (type == BOOL)
            ret += "" bool"";
        else if (type == CHAR)
            ret += "" char"";
        else if (type == SHORT)
            ret += "" short"";
        else if (type == WCHAR_T)
            ret += "" wchar_t"";
        else if (type == INT)
            ret += "" int"";
        else if (type == LONG)
            ret += "" long"";
        else if (type == LONGLONG)
            ret += "" long long"";
        else if (type == UNKNOWN_INT)
            ret += "" unknown_int"";
    } else if (type == FLOAT)
        ret += "" float"";
    else if (type == DOUBLE)
        ret += "" double"";
    else if (type == LONGDOUBLE)
...",1,1,lib/symboldatabase.cpp,ValueType.str<const>:string(),<empty>,,false,8211,8277,str,,,1,string()
111669153344,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"void ValueType::setDebugPath(const Token* tok, SourceLocation ctx, const SourceLocation &local)
{
    std::string file = ctx.file_name();
    if (file.empty())
        return;
    std::string s = Path::stripDirectoryPart(file) + "":"" + std::to_string(ctx.line()) + "": "" + ctx.function_name() +
                    "" => "" + local.function_name();
    debugPath.emplace_back(tok, std::move(s));
}",1,1,lib/symboldatabase.cpp,"ValueType.setDebugPath:void(Token*,SourceLocation,SourceLocation&)",<empty>,,false,8279,8287,setDebugPath,,,1,"void(Token*,SourceLocation,SourceLocation&)"
111669153345,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"ValueType::MatchResult ValueType::matchParameter(const ValueType *call, const ValueType *func)
{
    if (!call || !func)
        return ValueType::MatchResult::UNKNOWN;
    if (call->pointer != func->pointer) {
        if (call->pointer > 1 && func->pointer == 1 && func->type == ValueType::Type::VOID)
            return ValueType::MatchResult::FALLBACK1;
        if (call->pointer == 1 && func->pointer == 0 && func->isIntegral() && func->sign != ValueType::Sign::SIGNED)
            return ValueType::MatchResult::FALLBACK1;
        if (call->pointer == 1 && call->type == ValueType::Type::CHAR && func->pointer == 0 && func->container && func->container->stdStringLike)
            return ValueType::MatchResult::FALLBACK2;
        return ValueType::MatchResult::NOMATCH; // TODO
    }
    if (call->pointer > 0) {
        if ((call->constness | func->constness) != func->constness)
            return ValueType::MatchResult::NOMATCH;
        if ((call->volatileness | func->volatileness) != f...",1,1,lib/symboldatabase.cpp,"ValueType.matchParameter:ValueType.MatchResult(ValueType*,ValueType*)",<empty>,,false,8289,8353,matchParameter,,,1,"ValueType.MatchResult(ValueType*,ValueType*)"
111669153346,METHOD,lib/symboldatabase.cpp:<global>,TYPE_DECL,"ValueType::MatchResult ValueType::matchParameter(const ValueType *call, const Variable *callVar, const Variable *funcVar)
{
    ValueType vt;
    const ValueType* pvt = funcVar->valueType();
    if (pvt && funcVar->isArray() && !(funcVar->isStlType() && Token::simpleMatch(funcVar->typeStartToken(), ""std :: array""))) { // std::array doesn't decay to a pointer
        vt = *pvt;
        if (vt.pointer == 0) // don't bump array of pointers
            vt.pointer = funcVar->dimensions().size();
        pvt = &vt;
    }
    ValueType cvt;
    if (call && callVar && callVar->isArray() && !(callVar->isStlType() && Token::simpleMatch(callVar->typeStartToken(), ""std :: array""))) {
        cvt = *call;
        if (cvt.pointer == 0) // don't bump array of pointers
            cvt.pointer = callVar->dimensions().size();
        call = &cvt;
    }
    const ValueType::MatchResult res = ValueType::matchParameter(call, pvt);
    if (callVar && ((res == ValueType::MatchResult::SAME && call->contain...",1,1,lib/symboldatabase.cpp,"ValueType.matchParameter:ValueType.MatchResult(ValueType*,Variable*,Variable*)",<empty>,,false,8355,8384,matchParameter,,,1,"ValueType.MatchResult(ValueType*,Variable*,Variable*)"
111669153347,METHOD,<empty>,<empty>,<empty>,1,,lib/symboldatabase.h,Dimension.<clinit>,<empty>,,false,66,,<clinit>,,,4,
111669153348,METHOD,lib/symboldatabase.h:<global>,TYPE_DECL,<global>,1,1,lib/symboldatabase.h,lib/symboldatabase.h:<global>,<empty>,,false,1,1495,<global>,,,1,
111669153349,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static Token *skipRequires(Token *tok)
{
    if (!Token::simpleMatch(tok, ""requires""))
        return tok;

    while (Token::Match(tok, ""%oror%|&&|requires %name%|("")) {
        Token *after = tok->next();
        if (after->str() == ""("") {
            tok = after->link()->next();
            continue;
        }
        if (Token::simpleMatch(after, ""requires ("") && Token::simpleMatch(after->linkAt(1), "") {"")) {
            tok = after->linkAt(1)->linkAt(1)->next();
            continue;
        }
        while (Token::Match(after, ""%name% :: %name%""))
            after = after->tokAt(2);
        if (Token::Match(after, ""%name% <"")) {
            after = after->next()->findClosingBracket();
            tok = after ? after->next() : nullptr;
        } else
            break;
    }
    return tok;
}",1,1,lib/templatesimplifier.cpp,skipRequires:Token*(Token*),<empty>,,false,40,64,skipRequires,,,1,Token*(Token*)
111669153350,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,<global>,1,1,lib/templatesimplifier.cpp,lib/templatesimplifier.cpp:<global>,<empty>,,false,1,4065,<global>,,,1,
111669153351,METHOD,FindToken,TYPE_DECL,explicit FindToken(const Token *token) : mToken(token) {},9,65,lib/templatesimplifier.cpp,FindToken.FindToken:ANY(Token*),<empty>,,false,69,69,FindToken,,,1,FindToken.FindToken:ANY(Token*)(Token*)
111669153352,METHOD,FindToken,TYPE_DECL,"bool operator()(const TemplateSimplifier::TokenAndName &tokenAndName) const {
            return tokenAndName.token() == mToken;
        }",9,9,lib/templatesimplifier.cpp,FindToken.()<const>:bool(TemplateSimplifier.TokenAndName&),<empty>,,false,70,72,(),,,2,bool(TemplateSimplifier.TokenAndName&)
111669153353,METHOD,FindName,TYPE_DECL,explicit FindName(std::string name) : mName(std::move(name)) {},9,71,lib/templatesimplifier.cpp,FindName.FindName:ANY(std.string),<empty>,,false,79,79,FindName,,,1,FindName.FindName:ANY(std.string)(std.string)
111669153354,METHOD,FindName,TYPE_DECL,"bool operator()(const TemplateSimplifier::TokenAndName &tokenAndName) const {
            return tokenAndName.name() == mName;
        }",9,9,lib/templatesimplifier.cpp,FindName.()<const>:bool(TemplateSimplifier.TokenAndName&),<empty>,,false,80,82,(),,,2,bool(TemplateSimplifier.TokenAndName&)
111669153355,METHOD,FindFullName,TYPE_DECL,explicit FindFullName(std::string fullName) : mFullName(std::move(fullName)) {},9,87,lib/templatesimplifier.cpp,FindFullName.FindFullName:ANY(std.string),<empty>,,false,89,89,FindFullName,,,1,FindFullName.FindFullName:ANY(std.string)(std.string)
111669153356,METHOD,FindFullName,TYPE_DECL,"bool operator()(const TemplateSimplifier::TokenAndName &tokenAndName) const {
            return tokenAndName.fullName() == mFullName;
        }",9,9,lib/templatesimplifier.cpp,FindFullName.()<const>:bool(TemplateSimplifier.TokenAndName&),<empty>,,false,90,92,(),,,2,bool(TemplateSimplifier.TokenAndName&)
111669153357,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"TemplateSimplifier::TokenAndName::TokenAndName(Token *token, std::string scope) :
    mToken(token), mScope(std::move(scope)), mName(mToken ? mToken->str() : """"),
    mFullName(mScope.empty() ? mName : (mScope + "" :: "" + mName)),
    mNameToken(nullptr), mParamEnd(nullptr), mFlags(0)
{
    if (mToken) {
        if (mToken->strAt(1) == ""<"") {
            const Token *end = mToken->next()->findClosingBracket();
            if (end && end->strAt(1) == ""("") {
                isFunction(true);
            }
        }
        mToken->templateSimplifierPointer(this);
    }
}",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.TokenAndName.TokenAndName:ANY(Token*,std.string)",<empty>,,false,98,112,TokenAndName,,,1,"TemplateSimplifier.TokenAndName.TokenAndName:ANY(Token*,std.string)(Token*,std.string)"
111669153358,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"TemplateSimplifier::TokenAndName::TokenAndName(Token *token, std::string scope, const Token *nameToken, const Token *paramEnd) :
    mToken(token), mScope(std::move(scope)), mName(nameToken->str()),
    mFullName(mScope.empty() ? mName : (mScope + "" :: "" + mName)),
    mNameToken(nameToken), mParamEnd(paramEnd), mFlags(0)
{
    // only set flags for declaration
    if (mToken && mNameToken && mParamEnd) {
        isSpecialization(Token::simpleMatch(mToken, ""template < >""));

        if (!isSpecialization()) {
            if (Token::simpleMatch(mToken->next()->findClosingBracket(), ""> template <"")) {
                const Token * temp = mNameToken->tokAt(-2);
                while (Token::Match(temp, "">|%name% ::"")) {
                    if (temp->str() == "">"")
                        temp = temp->findOpeningBracket()->previous();
                    else
                        temp = temp->tokAt(-2);
                }
                isPartialSpecialization(temp->strAt(1) == ""<"");
...",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.TokenAndName.TokenAndName:ANY(Token*,std.string,Token*,Token*)",<empty>,,false,114,228,TokenAndName,,,1,"TemplateSimplifier.TokenAndName.TokenAndName:ANY(Token*,std.string,Token*,Token*)(Token*,std.string,Token*,Token*)"
111669153359,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"TemplateSimplifier::TokenAndName::TokenAndName(const TokenAndName& other) :
    mToken(other.mToken), mScope(other.mScope), mName(other.mName), mFullName(other.mFullName),
    mNameToken(other.mNameToken), mParamEnd(other.mParamEnd), mFlags(other.mFlags)
{
    if (mToken)
        mToken->templateSimplifierPointer(this);
}",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.TokenAndName.TokenAndName:ANY(TemplateSimplifier.TokenAndName&),<empty>,,false,230,236,TokenAndName,,,1,TemplateSimplifier.TokenAndName.TokenAndName:ANY(TemplateSimplifier.TokenAndName&)(TemplateSimplifier.TokenAndName&)
111669153360,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"TemplateSimplifier::TokenAndName::~TokenAndName()
{
    if (mToken && mToken->templateSimplifierPointers())
        mToken->templateSimplifierPointers()->erase(this);
}",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.TokenAndName.~TokenAndName:ANY(),<empty>,,false,238,242,~TokenAndName,,,1,ANY()
111669153361,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"std::string TemplateSimplifier::TokenAndName::dump(const std::vector<std::string>& fileNames) const {
    std::string ret = ""    <TokenAndName name=\\"""" + ErrorLogger::toxml(mName) + ""\\"" file=\\"""" + ErrorLogger::toxml(fileNames.at(mToken->fileIndex())) + ""\\"" line=\\"""" + std::to_string(mToken->linenr()) + ""\\"">\\n"";
    for (const Token* tok = mToken; tok && !Token::Match(tok, ""[;{}]""); tok = tok->next())
        ret += ""      <template-token str=\\"""" + ErrorLogger::toxml(tok->str()) + ""\\""/>\\n"";
    return ret + ""    </TokenAndName>\\n"";
}",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.TokenAndName.dump<const>:string(std.vector<std.string>&),<empty>,,false,244,249,dump,,,1,string(std.vector<std.string>&)
111669153362,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"const Token * TemplateSimplifier::TokenAndName::aliasStartToken() const
{
    if (mParamEnd)
        return mParamEnd->tokAt(4);
    return nullptr;
}",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.TokenAndName.aliasStartToken<const>:Token*(),<empty>,,false,251,256,aliasStartToken,,,1,Token*()
111669153363,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"const Token * TemplateSimplifier::TokenAndName::aliasEndToken() const
{
    if (aliasStartToken())
        return Token::findsimplematch(aliasStartToken(), "";"");
    return nullptr;
}",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.TokenAndName.aliasEndToken<const>:Token*(),<empty>,,false,258,263,aliasEndToken,,,1,Token*()
111669153364,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"bool TemplateSimplifier::TokenAndName::isAliasToken(const Token *tok) const
{
    const Token *end = aliasEndToken();

    for (const Token *tok1 = aliasStartToken(); tok1 != end; tok1 = tok1->next()) {
        if (tok1 == tok)
            return true;
    }
    return false;
}",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.TokenAndName.isAliasToken<const>:bool(Token*),<empty>,,false,265,274,isAliasToken,,,1,bool(Token*)
111669153365,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"TemplateSimplifier::TemplateSimplifier(Tokenizer &tokenizer)
    : mTokenizer(tokenizer), mTokenList(mTokenizer.list), mSettings(mTokenizer.getSettings()),
    mErrorLogger(mTokenizer.mErrorLogger)
{}",1,2,lib/templatesimplifier.cpp,TemplateSimplifier.TemplateSimplifier:ANY(Tokenizer&),<empty>,,false,276,279,TemplateSimplifier,,,1,TemplateSimplifier.TemplateSimplifier:ANY(Tokenizer&)(Tokenizer&)
111669153366,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"void TemplateSimplifier::checkComplicatedSyntaxErrorsInTemplates()
{
    // check for more complicated syntax errors when using templates..
    for (const Token *tok = mTokenList.front(); tok; tok = tok->next()) {
        // skip executing scopes (ticket #3183)..
        if (Token::simpleMatch(tok, ""( {"")) {
            tok = tok->link();
            if (!tok)
                syntaxError(nullptr);
        }
        // skip executing scopes..
        const Token *start = Tokenizer::startOfExecutableScope(tok);
        if (start) {
            tok = start->link();
        }

        // skip executing scopes (ticket #1985)..
        else if (Token::simpleMatch(tok, ""try {"")) {
            tok = tok->linkAt(1);
            while (Token::simpleMatch(tok, ""} catch ("")) {
                tok = tok->linkAt(2);
                if (Token::simpleMatch(tok, "") {""))
                    tok = tok->linkAt(1);
            }
        }

        if (!tok)
            syntaxError(nullptr);
        // n...",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.checkComplicatedSyntaxErrorsInTemplates:void(),<empty>,,false,281,384,checkComplicatedSyntaxErrorsInTemplates,,,1,void()
111669153367,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"unsigned int TemplateSimplifier::templateParameters(const Token *tok)
{
    unsigned int numberOfParameters = 1;

    if (!tok)
        return 0;
    if (tok->str() != ""<"")
        return 0;
    if (Token::Match(tok->previous(), ""%var% <""))
        return 0;
    tok = tok->next();
    if (!tok || tok->str() == "">"")
        return 0;

    unsigned int level = 0;

    while (tok) {
        // skip template template
        if (level == 0 && Token::simpleMatch(tok, ""template <"")) {
            const Token *closing = tok->next()->findClosingBracket();
            if (closing) {
                if (closing->str() == "">>"")
                    return numberOfParameters;
                tok = closing->next();
                if (!tok)
                    syntaxError(tok);
                if (Token::Match(tok, "">|>>|>>=""))
                    return numberOfParameters;
                if (tok->str() == "","") {
                    ++numberOfParameters;
                    tok = tok->next();
  ...",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.templateParameters:unsigned int(Token*),<empty>,,false,386,556,templateParameters,,,1,unsigned int(Token*)
111669153368,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static T *findTemplateDeclarationEndImpl(T *tok)
{
    if (Token::simpleMatch(tok, ""template <"")) {
        tok = tok->next()->findClosingBracket();
        if (tok)
            tok = tok->next();
    }

    if (!tok)
        return nullptr;

    T * tok2 = tok;
    bool in_init = false;
    while (tok2 && !Token::Match(tok2, "";|{"")) {
        if (tok2->str() == ""<"")
            tok2 = tok2->findClosingBracket();
        else if (Token::Match(tok2, ""(|["") && tok2->link())
            tok2 = tok2->link();
        else if (tok2->str() == "":"")
            in_init = true;
        else if (in_init && Token::Match(tok2, ""%name% (|{"")) {
            tok2 = tok2->linkAt(1);
            if (tok2->strAt(1) == ""{"")
                in_init = false;
        }
        if (tok2)
            tok2 = tok2->next();
    }
    if (tok2 && tok2->str() == ""{"") {
        tok = tok2->link();
        if (tok && tok->strAt(1) == "";"")
            tok = tok->next();
    } else if (tok2 && tok2->str() == "";"")
  ...",1,1,lib/templatesimplifier.cpp,findTemplateDeclarationEndImpl:T(T*),<empty>,,false,559,597,findTemplateDeclarationEndImpl,,,1,T(T*)
111669153369,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"Token *TemplateSimplifier::findTemplateDeclarationEnd(Token *tok)
{
    return findTemplateDeclarationEndImpl(tok);
}",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.findTemplateDeclarationEnd:Token*(Token*),<empty>,,false,599,602,findTemplateDeclarationEnd,,,1,Token*(Token*)
111669153370,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"const Token *TemplateSimplifier::findTemplateDeclarationEnd(const Token *tok)
{
    return findTemplateDeclarationEndImpl(tok);
}",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.findTemplateDeclarationEnd<duplicate>0:Token*(Token*),<empty>,,false,604,607,findTemplateDeclarationEnd,,,1,Token*(Token*)
111669153371,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"void TemplateSimplifier::eraseTokens(Token *begin, const Token *end)
{
    if (!begin || begin == end)
        return;

    while (begin->next() && begin->next() != end) {
        begin->deleteNext();
    }
}",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.eraseTokens:void(Token*,Token*)",<empty>,,false,609,617,eraseTokens,,,1,"void(Token*,Token*)"
111669153372,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"void TemplateSimplifier::deleteToken(Token *tok)
{
    if (tok->next())
        tok->next()->deletePrevious();
    else
        tok->deleteThis();
}",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.deleteToken:void(Token*),<empty>,,false,619,625,deleteToken,,,1,void(Token*)
111669153373,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static void invalidateForwardDecls(const Token* beg, const Token* end, std::map<Token*, Token*>* forwardDecls) {
    if (!forwardDecls)
        return;
    for (auto& fwd : *forwardDecls) {
        for (const Token* tok = beg; tok != end; tok = tok->next())
            if (fwd.second == tok) {
                fwd.second = nullptr;
                break;
            }
    }
}",1,1,lib/templatesimplifier.cpp,"invalidateForwardDecls:void(Token*,Token*,std.map<Token*,Token*>*)",<empty>,,false,627,637,invalidateForwardDecls,,,1,"void(Token*,Token*,std.map<Token*,Token*>*)"
111669153374,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"bool TemplateSimplifier::removeTemplate(Token *tok, std::map<Token*, Token*>* forwardDecls)
{
    if (!Token::simpleMatch(tok, ""template <""))
        return false;

    Token *end = findTemplateDeclarationEnd(tok);
    if (end && end->next()) {
        invalidateForwardDecls(tok, end->next(), forwardDecls);
        eraseTokens(tok, end->next());
        deleteToken(tok);
        return true;
    }

    return false;
}",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.removeTemplate:bool(Token*,std.map<Token*,Token*>*)",<empty>,,false,639,653,removeTemplate,,,1,"bool(Token*,std.map<Token*,Token*>*)"
111669153375,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"bool TemplateSimplifier::getTemplateDeclarations()
{
    bool codeWithTemplates = false;
    for (Token *tok = mTokenList.front(); tok; tok = tok->next()) {
        if (!Token::simpleMatch(tok, ""template <""))
            continue;
        // ignore template template parameter
        if (tok->strAt(-1) == ""<"" || tok->strAt(-1) == "","")
            continue;
        // ignore nested template
        if (tok->strAt(-1) == "">"")
            continue;
        // skip to last nested template parameter
        const Token *tok1 = tok;
        while (tok1 && tok1->next()) {
            const Token *closing = tok1->next()->findClosingBracket();
            if (!Token::simpleMatch(closing, ""> template <""))
                break;
            tok1 = closing->next();
        }
        if (!Token::Match(tok, ""%any% %any%""))
            syntaxError(tok);
        if (tok->strAt(2)==""typename"" &&
            !Token::Match(tok->tokAt(3), ""%name%|...|,|=|>""))
            syntaxError(tok->next());
     ...",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.getTemplateDeclarations:bool(),<empty>,,false,655,710,getTemplateDeclarations,,,1,bool()
111669153376,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"void TemplateSimplifier::addInstantiation(Token *token, const std::string &scope)
{
    simplifyTemplateArgs(token->tokAt(2), token->next()->findClosingBracket());

    TokenAndName instantiation(token, scope);

    // check if instantiation already exists before adding it
    const auto it = std::find(mTemplateInstantiations.cbegin(),
                              mTemplateInstantiations.cend(),
                              instantiation);

    if (it == mTemplateInstantiations.cend())
        mTemplateInstantiations.emplace_back(std::move(instantiation));
}",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.addInstantiation:void(Token*,std.string&)",<empty>,,false,712,725,addInstantiation,,,1,"void(Token*,std.string&)"
111669153377,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static const Token* getFunctionToken(const Token* nameToken)
{
    if (Token::Match(nameToken, ""%name% (""))
        return nameToken->next();

    if (Token::Match(nameToken, ""%name% <"")) {
        const Token* end = nameToken->next()->findClosingBracket();
        if (Token::simpleMatch(end, ""> (""))
            return end->next();
    }

    return nullptr;
}",1,1,lib/templatesimplifier.cpp,getFunctionToken:Token*(Token*),<empty>,,false,727,739,getFunctionToken,,,1,Token*(Token*)
111669153378,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static void getFunctionArguments(const Token* nameToken, std::vector<const Token*>& args)
{
    const Token* functionToken = getFunctionToken(nameToken);
    if (!functionToken)
        return;

    const Token* argToken = functionToken->next();

    if (argToken->str() == "")"")
        return;

    args.push_back(argToken);

    while ((argToken = argToken->nextArgumentBeforeCreateLinks2()))
        args.push_back(argToken);
}",1,1,lib/templatesimplifier.cpp,"getFunctionArguments:void(Token*,std.vector<constToken*>&)",<empty>,,false,741,756,getFunctionArguments,,,1,"void(Token*,std.vector<constToken*>&)"
111669153379,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static bool isConstMethod(const Token* nameToken)
{
    const Token* functionToken = getFunctionToken(nameToken);
    if (!functionToken)
        return false;
    const Token* endToken = functionToken->link();
    return Token::simpleMatch(endToken, "") const"");
}",1,1,lib/templatesimplifier.cpp,isConstMethod:bool(Token*),<empty>,,false,758,765,isConstMethod,,,1,bool(Token*)
111669153380,METHOD,<empty>,<empty>,"[](const Token* param) {
        return Token::Match(param->previous(), ""typename|class %name% ,|>"");
    }",56,5,lib/templatesimplifier.cpp,lib/templatesimplifier.cpp:<global>.areAllParamsTypes.<lambda>0:bool(Token*),<empty>,,false,772,774,<lambda>0,,,1,bool(Token*)
111669153381,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static bool areAllParamsTypes(const std::vector<const Token *> &params)
{
    if (params.empty())
        return false;

    return std::all_of(params.cbegin(), params.cend(), [](const Token* param) {
        return Token::Match(param->previous(), ""typename|class %name% ,|>"");
    });
}",1,1,lib/templatesimplifier.cpp,areAllParamsTypes:bool(std.vector<constToken*>&),<empty>,,false,767,775,areAllParamsTypes,,,1,bool(std.vector<constToken*>&)
111669153382,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static bool isTemplateInstantion(const Token* tok)
{
    if (!tok->isName() || (tok->isKeyword() && !tok->isOperatorKeyword()))
        return false;
    if (Token::Match(tok->tokAt(-1), ""%type% %name% ::|<""))
        return true;
    if (Token::Match(tok->tokAt(-2), ""[,:] private|protected|public %name% ::|<""))
        return true;
    if (Token::Match(tok->tokAt(-1), ""(|{|}|;|=|>|<<|:|.|*|&|return|<|,|!|[ %name% ::|<|(""))
        return true;
    return Token::Match(tok->tokAt(-2), ""(|{|}|;|=|<<|:|.|*|&|return|<|,|!|[ :: %name% ::|<|("");
}",1,1,lib/templatesimplifier.cpp,isTemplateInstantion:bool(Token*),<empty>,,false,777,788,isTemplateInstantion,,,1,bool(Token*)
111669153383,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"void TemplateSimplifier::getTemplateInstantiations()
{
    std::multimap<std::string, const TokenAndName *> functionNameMap;

    for (const auto & decl : mTemplateDeclarations) {
        if (decl.isFunction())
            functionNameMap.emplace(decl.name(), &decl);
    }

    for (const auto & decl : mTemplateForwardDeclarations) {
        if (decl.isFunction())
            functionNameMap.emplace(decl.name(), &decl);
    }

    const Token *skip = nullptr;

    for (Token *tok = mTokenList.front(); tok; tok = tok->next()) {

        // template definition.. skip it
        if (Token::simpleMatch(tok, ""template <"")) {
            tok = tok->next()->findClosingBracket();
            if (!tok)
                break;

            const bool isUsing = tok->strAt(1) == ""using"";
            if (isUsing && Token::Match(tok->tokAt(2), ""%name% <"")) {
                // Can't have specialized type alias so ignore it
                Token *tok2 = Token::findsimplematch(tok->tokAt(3), "";"");
 ...",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.getTemplateInstantiations:void(),<empty>,,false,790,1042,getTemplateInstantiations,,,1,void()
111669153384,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"void TemplateSimplifier::useDefaultArgumentValues()
{
    for (TokenAndName &declaration : mTemplateDeclarations)
        useDefaultArgumentValues(declaration);

    for (TokenAndName &declaration : mTemplateForwardDeclarations)
        useDefaultArgumentValues(declaration);
}",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.useDefaultArgumentValues:void(),<empty>,,false,1045,1052,useDefaultArgumentValues,,,1,void()
111669153385,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"void TemplateSimplifier::useDefaultArgumentValues(TokenAndName &declaration)
{
    // Ticket #5762: Skip specialization tokens
    if (declaration.isSpecialization() || declaration.isAlias() || declaration.isFriend())
        return;

    // template parameters with default value has syntax such as:
    //     x = y
    // this list will contain all the '=' tokens for such arguments
    struct Default {
        Token *eq;
        Token *end;
    };
    std::list<Default> eq;
    // and this set the position of parameters with a default value
    std::set<std::size_t> defaultedArgPos;

    // parameter number. 1,2,3,..
    std::size_t templatepar = 1;

    // parameter depth
    std::size_t templateParmDepth = 0;

    // map type parameter name to index
    std::map<std::string, unsigned int> typeParameterNames;

    // Scan template declaration..
    for (Token *tok = declaration.token()->next(); tok; tok = tok->next()) {
        if (Token::simpleMatch(tok, ""template <"")) {
        ...",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.useDefaultArgumentValues:void(TemplateSimplifier.TokenAndName&),<empty>,,false,1054,1282,useDefaultArgumentValues,,,1,void(TemplateSimplifier.TokenAndName&)
111669153386,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"void TemplateSimplifier::simplifyTemplateAliases()
{
    for (auto it1 = mTemplateDeclarations.cbegin(); it1 != mTemplateDeclarations.cend();) {
        const TokenAndName &aliasDeclaration = *it1;

        if (!aliasDeclaration.isAlias()) {
            ++it1;
            continue;
        }

        // alias parameters..
        std::vector<const Token *> aliasParameters;
        getTemplateParametersInDeclaration(aliasDeclaration.token()->tokAt(2), aliasParameters);
        std::map<std::string, unsigned int> aliasParameterNames;
        for (unsigned int argnr = 0; argnr < aliasParameters.size(); ++argnr)
            aliasParameterNames[aliasParameters[argnr]->str()] = argnr;

        // Look for alias usages..
        bool found = false;
        for (auto it2 = mTemplateInstantiations.cbegin(); it2 != mTemplateInstantiations.cend();) {
            const TokenAndName &aliasUsage = *it2;
            if (!aliasUsage.token() || aliasUsage.fullName() != aliasDeclaration.fullName()) {...",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.simplifyTemplateAliases:void(),<empty>,,false,1284,1408,simplifyTemplateAliases,,,1,void()
111669153387,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"bool TemplateSimplifier::instantiateMatch(const Token *instance, const std::size_t numberOfArguments, bool variadic, const char patternAfter[])
{
    assert(instance->strAt(1) == ""<"");

    auto n = templateParameters(instance->next());
    if (variadic ? (n + 1 < numberOfArguments) : (numberOfArguments != n))
        return false;

    if (patternAfter) {
        const Token *tok = instance->next()->findClosingBracket();
        if (!tok || !Token::Match(tok->next(), patternAfter))
            return false;
    }

    // nothing mismatching was found..
    return true;
}",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.instantiateMatch:bool(Token*,std.size_t,bool,char[])",<empty>,,false,1410,1426,instantiateMatch,,,1,"bool(Token*,std.size_t,bool,char[])"
111669153388,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"bool TemplateSimplifier::getTemplateNamePositionTemplateFunction(const Token *tok, int &namepos)
{
    namepos = 1;
    while (tok && tok->next()) {
        if (Token::Match(tok->next(), "";|{""))
            return false;
        // skip decltype(...)
        if (Token::simpleMatch(tok->next(), ""decltype ("")) {
            const Token * end = tok->linkAt(2)->previous();
            while (tok->next() && tok != end) {
                tok = tok->next();
                namepos++;
            }
        } else if (Token::Match(tok->next(), ""%type% <"")) {
            const Token *closing = tok->tokAt(2)->findClosingBracket();
            if (closing) {
                if (closing->strAt(1) == ""("" && TokenList::isFunctionHead(closing->next(), "";{:""))
                    return true;
                while (tok->next() && tok->next() != closing) {
                    tok = tok->next();
                    namepos++;
                }
            }
        } else if (Token::Match(tok->next(),...",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.getTemplateNamePositionTemplateFunction:bool(Token*,int&)",<empty>,,false,1429,1459,getTemplateNamePositionTemplateFunction,,,1,"bool(Token*,int&)"
111669153389,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"bool TemplateSimplifier::getTemplateNamePositionTemplateVariable(const Token *tok, int &namepos)
{
    namepos = 1;
    while (tok && tok->next()) {
        if (Token::Match(tok->next(), "";|{|(|using""))
            return false;
        // skip decltype(...)
        if (Token::simpleMatch(tok->next(), ""decltype ("")) {
            const Token * end = tok->linkAt(2);
            while (tok->next() && tok != end) {
                tok = tok->next();
                namepos++;
            }
        } else if (Token::Match(tok->next(), ""%type% <"")) {
            const Token *closing = tok->tokAt(2)->findClosingBracket();
            if (closing) {
                if (Token::Match(closing->next(), ""=|;""))
                    return true;
                while (tok->next() && tok->next() != closing) {
                    tok = tok->next();
                    namepos++;
                }
            }
        } else if (Token::Match(tok->next(), ""%type% =|;"")) {
            return true;
  ...",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.getTemplateNamePositionTemplateVariable:bool(Token*,int&)",<empty>,,false,1461,1491,getTemplateNamePositionTemplateVariable,,,1,"bool(Token*,int&)"
111669153390,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"bool TemplateSimplifier::getTemplateNamePositionTemplateClass(const Token *tok, int &namepos)
{
    if (Token::Match(tok, ""> friend| class|struct|union %type% :|<|;|{|::"")) {
        namepos = tok->strAt(1) == ""friend"" ? 3 : 2;
        tok = tok->tokAt(namepos);
        while (Token::Match(tok, ""%type% :: %type%"") ||
               (Token::Match(tok, ""%type% <"") && Token::Match(tok->next()->findClosingBracket(), ""> :: %type%""))) {
            if (tok->strAt(1) == ""::"") {
                tok = tok->tokAt(2);
                namepos += 2;
            } else {
                const Token *end = tok->next()->findClosingBracket();
                if (!end || !end->tokAt(2)) {
                    // syntax error
                    namepos = -1;
                    return true;
                }
                end = end->tokAt(2);
                do {
                    tok = tok->next();
                    namepos += 1;
                } while (tok && tok != end);
            }
      ...",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.getTemplateNamePositionTemplateClass:bool(Token*,int&)",<empty>,,false,1493,1520,getTemplateNamePositionTemplateClass,,,1,"bool(Token*,int&)"
111669153391,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"int TemplateSimplifier::getTemplateNamePosition(const Token *tok)
{
    if (!tok || tok->str() != "">"")
        syntaxError(tok);

    auto it = mTemplateNamePos.find(tok);
    if (!mSettings.debugtemplate && it != mTemplateNamePos.end()) {
        return it->second;
    }
    // get the position of the template name
    int namepos = 0;
    if (getTemplateNamePositionTemplateClass(tok, namepos))
        ;
    else if (Token::Match(tok, ""> using %name% ="")) {
        // types may not be defined in alias template declarations
        if (!Token::Match(tok->tokAt(4), ""class|struct|union|enum %name%| {""))
            namepos = 2;
    } else if (getTemplateNamePositionTemplateVariable(tok, namepos))
        ;
    else if (!getTemplateNamePositionTemplateFunction(tok, namepos))
        namepos = -1; // Name not found
    mTemplateNamePos[tok] = namepos;
    return namepos;
}",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.getTemplateNamePosition:int(Token*),<empty>,,false,1522,1545,getTemplateNamePosition,,,1,int(Token*)
111669153392,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"void TemplateSimplifier::addNamespace(const TokenAndName &templateDeclaration, const Token *tok)
{
    // find start of qualification
    const Token * tokStart = tok;
    int offset = 0;
    while (Token::Match(tokStart->tokAt(-2), ""%name% ::"")) {
        tokStart = tokStart->tokAt(-2);
        offset -= 2;
    }
    // decide if namespace needs to be inserted in or appended to token list
    const bool insert = tokStart != tok;

    std::string::size_type start = 0;
    std::string::size_type end = 0;
    bool inTemplate = false;
    int level = 0;
    while ((end = templateDeclaration.scope().find(' ', start)) != std::string::npos) {
        std::string token = templateDeclaration.scope().substr(start, end - start);
        // done if scopes overlap
        if (token == tokStart->str() && tok->strAt(-1) != ""::"")
            break;
        if (token == ""<"") {
            inTemplate = true;
            ++level;
        }
        if (inTemplate) {
            if (insert)
           ...",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.addNamespace:void(TemplateSimplifier.TokenAndName&,Token*)",<empty>,,false,1547,1607,addNamespace,,,1,"void(TemplateSimplifier.TokenAndName&,Token*)"
111669153393,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"bool TemplateSimplifier::alreadyHasNamespace(const TokenAndName &templateDeclaration, const Token *tok)
{
    const std::string& scope = templateDeclaration.scope();

    // get the length in tokens of the namespace
    std::string::size_type pos = 0;
    int offset = -2;

    while ((pos = scope.find(""::"", pos)) != std::string::npos) {
        offset -= 2;
        pos += 2;
    }

    return Token::simpleMatch(tok->tokAt(offset), scope.c_str(), scope.size());
}",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.alreadyHasNamespace:bool(TemplateSimplifier.TokenAndName&,Token*)",<empty>,,false,1609,1623,alreadyHasNamespace,,,1,"bool(TemplateSimplifier.TokenAndName&,Token*)"
111669153394,METHOD,newInstantiation,TYPE_DECL,"newInstantiation(Token* t, std::string s) : token(t), scope(std::move(s)) {}",5,80,lib/templatesimplifier.cpp,"newInstantiation.newInstantiation:ANY(Token*,std.string)",<empty>,,false,1626,1626,newInstantiation,,,1,"newInstantiation.newInstantiation:ANY(Token*,std.string)(Token*,std.string)"
111669153395,METHOD,<empty>,<empty>,"[&](const TokenAndName& inst) {
                                return Token::simpleMatch(inst.token(), name.c_str(), name.size());
                            }",111,29,lib/templatesimplifier.cpp,lib/templatesimplifier.cpp:<global>.TemplateSimplifier.expandTemplate.<lambda>1:ANY(TemplateSimplifier.TokenAndName&),<empty>,,false,1827,1829,<lambda>1,,,1,ANY(TemplateSimplifier.TokenAndName&)
111669153396,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"void TemplateSimplifier::expandTemplate(
    const TokenAndName &templateDeclaration,
    const TokenAndName &templateInstantiation,
    const std::vector<const Token *> &typeParametersInDeclaration,
    const std::string &newName,
    bool copy)
{
    bool inTemplateDefinition = false;
    const Token *startOfTemplateDeclaration = nullptr;
    const Token *endOfTemplateDefinition = nullptr;
    const Token * const templateDeclarationNameToken = templateDeclaration.nameToken();
    const Token * const templateDeclarationToken = templateDeclaration.paramEnd();
    const bool isClass = templateDeclaration.isClass();
    const bool isFunction = templateDeclaration.isFunction();
    const bool isSpecialization = templateDeclaration.isSpecialization();
    const bool isVariable = templateDeclaration.isVariable();

    std::vector<newInstantiation> newInstantiations;

    // add forward declarations
    if (copy && isClass) {
        templateDeclaration.token()->insertTokenBefore(template...",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.expandTemplate:void(TemplateSimplifier.TokenAndName&,TemplateSimplifier.TokenAndName&,std.vector<constToken*>&,std.string&,bool)",<empty>,,false,1631,2313,expandTemplate,,,1,"void(TemplateSimplifier.TokenAndName&,TemplateSimplifier.TokenAndName&,std.vector<constToken*>&,std.string&,bool)"
111669153397,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static bool isLowerThanLogicalAnd(const Token *lower)
{
    return lower->isAssignmentOp() || Token::Match(lower, ""}|;|(|[|]|)|,|?|:|%oror%|return|throw|case"");
}",1,1,lib/templatesimplifier.cpp,isLowerThanLogicalAnd:bool(Token*),<empty>,,false,2315,2318,isLowerThanLogicalAnd,,,1,bool(Token*)
111669153398,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static bool isLowerThanOr(const Token* lower)
{
    return isLowerThanLogicalAnd(lower) || lower->str() == ""&&"";
}",1,1,lib/templatesimplifier.cpp,isLowerThanOr:bool(Token*),<empty>,,false,2319,2322,isLowerThanOr,,,1,bool(Token*)
111669153399,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static bool isLowerThanXor(const Token* lower)
{
    return isLowerThanOr(lower) || lower->str() == ""|"";
}",1,1,lib/templatesimplifier.cpp,isLowerThanXor:bool(Token*),<empty>,,false,2323,2326,isLowerThanXor,,,1,bool(Token*)
111669153400,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static bool isLowerThanAnd(const Token* lower)
{
    return isLowerThanXor(lower) || lower->str() == ""^"";
}",1,1,lib/templatesimplifier.cpp,isLowerThanAnd:bool(Token*),<empty>,,false,2327,2330,isLowerThanAnd,,,1,bool(Token*)
111669153401,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static bool isLowerThanShift(const Token* lower)
{
    return isLowerThanAnd(lower) || lower->str() == ""&"";
}",1,1,lib/templatesimplifier.cpp,isLowerThanShift:bool(Token*),<empty>,,false,2331,2334,isLowerThanShift,,,1,bool(Token*)
111669153402,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static bool isLowerThanPlusMinus(const Token* lower)
{
    return isLowerThanShift(lower) || Token::Match(lower, ""%comp%|<<|>>"");
}",1,1,lib/templatesimplifier.cpp,isLowerThanPlusMinus:bool(Token*),<empty>,,false,2335,2338,isLowerThanPlusMinus,,,1,bool(Token*)
111669153403,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static bool isLowerThanMulDiv(const Token* lower)
{
    return isLowerThanPlusMinus(lower) || Token::Match(lower, ""+|-"");
}",1,1,lib/templatesimplifier.cpp,isLowerThanMulDiv:bool(Token*),<empty>,,false,2339,2342,isLowerThanMulDiv,,,1,bool(Token*)
111669153404,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static bool isLowerEqualThanMulDiv(const Token* lower)
{
    return isLowerThanMulDiv(lower) || Token::Match(lower, ""[*/%]"");
}",1,1,lib/templatesimplifier.cpp,isLowerEqualThanMulDiv:bool(Token*),<empty>,,false,2343,2346,isLowerEqualThanMulDiv,,,1,bool(Token*)
111669153405,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"bool TemplateSimplifier::simplifyNumericCalculations(Token *tok, bool isTemplate)
{
    bool ret = false;
    // (1-2)
    while (tok->tokAt(3) && tok->isNumber() && tok->tokAt(2)->isNumber()) { // %any% %num% %any% %num% %any%
        const Token *before = tok->previous();
        if (!before)
            break;
        const Token* op = tok->next();
        const Token* after = tok->tokAt(3);
        const std::string &num1 = op->strAt(-1);
        const std::string &num2 = op->strAt(1);
        if (Token::Match(before, ""* %num% /"") && (num2 != ""0"") && num1 == MathLib::multiply(num2, MathLib::divide(num1, num2))) {
            // Division where result is a whole number
        } else if (!((op->str() == ""*"" && (isLowerThanMulDiv(before) || before->str() == ""*"") && isLowerEqualThanMulDiv(after)) || // associative
                     (Token::Match(op, ""[/%]"") && isLowerThanMulDiv(before) && isLowerEqualThanMulDiv(after)) || // NOT associative
                     (Token::Match(op, ...",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.simplifyNumericCalculations:bool(Token*,bool)",<empty>,,false,2349,2441,simplifyNumericCalculations,,,1,"bool(Token*,bool)"
111669153406,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static Token *skipTernaryOp(Token *tok, const Token *backToken)
{
    unsigned int colonLevel = 1;
    while (nullptr != (tok = tok->next())) {
        if (tok->str() == ""?"") {
            ++colonLevel;
        } else if (tok->str() == "":"") {
            --colonLevel;
            if (colonLevel == 0) {
                tok = tok->next();
                break;
            }
        }
        if (tok->link() && tok->str() == ""("")
            tok = tok->link();
        else if (Token::Match(tok->next(), ""[{};)]"") || tok->next() == backToken)
            break;
    }
    if (colonLevel > 0) // Ticket #5214: Make sure the ':' matches the proper '?'
        return nullptr;
    return tok;
}",1,1,lib/templatesimplifier.cpp,"skipTernaryOp:Token*(Token*,Token*)",<empty>,,false,2443,2464,skipTernaryOp,,,1,"Token*(Token*,Token*)"
111669153407,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static void invalidateInst(const Token* beg, const Token* end, std::vector<newInstantiation>* newInst) {
    if (!newInst)
        return;
    for (auto& inst : *newInst) {
        for (const Token* tok = beg; tok != end; tok = tok->next())
            if (inst.token == tok) {
                inst.token = nullptr;
                break;
            }
    }
}",1,1,lib/templatesimplifier.cpp,"invalidateInst:void(Token*,Token*,std.vector<newInstantiation>*)",<empty>,,false,2466,2476,invalidateInst,,,1,"void(Token*,Token*,std.vector<newInstantiation>*)"
111669153408,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"void TemplateSimplifier::simplifyTemplateArgs(Token *start, const Token *end, std::vector<newInstantiation>* newInst)
{
    // start could be erased so use the token before start if available
    Token * first = (start && start->previous()) ? start->previous() : mTokenList.front();
    bool again = true;

    while (again) {
        again = false;

        for (Token *tok = first->next(); tok && tok != end; tok = tok->next()) {
            if (tok->str() == ""sizeof"") {
                // sizeof('x')
                if (Token::Match(tok->next(), ""( %char% )"")) {
                    tok->deleteNext();
                    tok->deleteThis();
                    tok->deleteNext();
                    tok->str(std::to_string(1));
                    again = true;
                }

                // sizeof (""text"")
                else if (Token::Match(tok->next(), ""( %str% )"")) {
                    tok->deleteNext();
                    tok->deleteThis();
                    tok->delet...",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.simplifyTemplateArgs:void(Token*,Token*,std.vector<newInstantiation>*)",<empty>,,false,2478,2640,simplifyTemplateArgs,,,1,"void(Token*,Token*,std.vector<newInstantiation>*)"
111669153409,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static bool validTokenStart(bool bounded, const Token *tok, const Token *frontToken, int offset)
{
    if (!bounded)
        return true;

    if (frontToken)
        frontToken = frontToken->previous();

    while (tok && offset <= 0) {
        if (tok == frontToken)
            return false;
        ++offset;
        tok = tok->previous();
    }

    return tok && offset > 0;
}",1,1,lib/templatesimplifier.cpp,"validTokenStart:bool(bool,Token*,Token*,int)",<empty>,,false,2642,2658,validTokenStart,,,1,"bool(bool,Token*,Token*,int)"
111669153410,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static bool validTokenEnd(bool bounded, const Token *tok, const Token *backToken, int offset)
{
    if (!bounded)
        return true;

    while (tok && offset >= 0) {
        if (tok == backToken)
            return false;
        --offset;
        tok = tok->next();
    }

    return tok && offset < 0;
}",1,1,lib/templatesimplifier.cpp,"validTokenEnd:bool(bool,Token*,Token*,int)",<empty>,,false,2660,2673,validTokenEnd,,,1,"bool(bool,Token*,Token*,int)"
111669153411,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"bool TemplateSimplifier::simplifyCalculations(Token* frontToken, const Token *backToken, bool isTemplate)
{
    bool ret = false;
    const bool bounded = frontToken || backToken;
    if (!frontToken) {
        frontToken = mTokenList.front();
    }
    for (Token *tok = frontToken; tok && tok != backToken; tok = tok->next()) {
        // Remove parentheses around variable..
        // keep parentheses here: dynamic_cast<Fred *>(p);
        // keep parentheses here: A operator * (int);
        // keep parentheses here: int ( * ( * f ) ( ... ) ) (int) ;
        // keep parentheses here: int ( * * ( * compilerHookVector ) (void) ) ( ) ;
        // keep parentheses here: operator new [] (size_t);
        // keep parentheses here: Functor()(a ... )
        // keep parentheses here: ) ( var ) ;
        if (validTokenEnd(bounded, tok, backToken, 4) &&
            (Token::Match(tok->next(), ""( %name% ) ;|)|,|]"") ||
             (Token::Match(tok->next(), ""( %name% ) %cop%"") &&
            ...",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.simplifyCalculations:bool(Token*,Token*,bool)",<empty>,,false,2677,2934,simplifyCalculations,,,1,"bool(Token*,Token*,bool)"
111669153412,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"void TemplateSimplifier::getTemplateParametersInDeclaration(
    const Token * tok,
    std::vector<const Token *> & typeParametersInDeclaration)
{
    assert(tok->strAt(-1) == ""<"");

    typeParametersInDeclaration.clear();
    const Token *end = tok->previous()->findClosingBracket();
    bool inDefaultValue = false;
    for (; tok && tok!= end; tok = tok->next()) {
        if (Token::simpleMatch(tok, ""template <"")) {
            const Token *closing = tok->next()->findClosingBracket();
            if (closing)
                tok = closing->next();
        } else if (tok->link() && Token::Match(tok, ""{|(|[""))
            tok = tok->link();
        else if (Token::Match(tok, ""%name% ,|>|="")) {
            if (!inDefaultValue) {
                typeParametersInDeclaration.push_back(tok);
                if (tok->strAt(1) == ""="")
                    inDefaultValue = true;
            }
        } else if (inDefaultValue) {
            if (tok->str() == "","")
                inDefaultVa...",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.getTemplateParametersInDeclaration:void(Token*,std.vector<constToken*>&)",<empty>,,false,2936,2968,getTemplateParametersInDeclaration,,,1,"void(Token*,std.vector<constToken*>&)"
111669153413,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"bool TemplateSimplifier::matchSpecialization(
    const Token *templateDeclarationNameToken,
    const Token *templateInstantiationNameToken,
    const std::list<const Token *> & specializations)
{
    // Is there a matching specialization?
    for (auto it = specializations.cbegin(); it != specializations.cend(); ++it) {
        if (!Token::Match(*it, ""%name% <""))
            continue;
        const Token *startToken = (*it);
        while (startToken->previous() && !Token::Match(startToken->previous(), ""[;{}]""))
            startToken = startToken->previous();
        if (!Token::simpleMatch(startToken, ""template <""))
            continue;
        // cppcheck-suppress shadowFunction - TODO: fix this
        std::vector<const Token *> templateParameters;
        getTemplateParametersInDeclaration(startToken->tokAt(2), templateParameters);

        const Token *instToken = templateInstantiationNameToken->tokAt(2);
        const Token *declToken = (*it)->tokAt(2);
        const Token...",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.matchSpecialization:bool(Token*,Token*,std.list<constToken*>&)",<empty>,,false,2970,3018,matchSpecialization,,,1,"bool(Token*,Token*,std.list<constToken*>&)"
111669153414,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"std::string TemplateSimplifier::getNewName(
    Token *tok2,
    std::list<std::string> &typeStringsUsedInTemplateInstantiation)
{
    std::string typeForNewName;
    unsigned int indentlevel = 0;
    const Token * endToken = tok2->next()->findClosingBracket();
    for (Token *tok3 = tok2->tokAt(2); tok3 != endToken && (indentlevel > 0 || tok3->str() != "">""); tok3 = tok3->next()) {
        // #2721 - unhandled [ => bail out
        if (tok3->str() == ""["" && !Token::Match(tok3->next(), ""%num%| ]"")) {
            typeForNewName.clear();
            break;
        }
        if (!tok3->next()) {
            typeForNewName.clear();
            break;
        }
        if (Token::Match(tok3->tokAt(-2), ""<|,|:: %name% <"") && (tok3->strAt(1) == "">"" || templateParameters(tok3)))
            ++indentlevel;
        else if (indentlevel > 0 && Token::Match(tok3, ""> ,|>|::""))
            --indentlevel;
        else if (indentlevel == 0 && Token::Match(tok3->previous(), ""[<,]"")) {
            mTy...",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.getNewName:string(Token*,std.list<std.string>&)",<empty>,,false,3020,3074,getNewName,,,1,"string(Token*,std.list<std.string>&)"
111669153415,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"bool TemplateSimplifier::simplifyTemplateInstantiations(
    const TokenAndName &templateDeclaration,
    const std::list<const Token *> &specializations,
    const std::time_t maxtime,
    std::set<std::string> &expandedtemplates)
{
    // this variable is not used at the moment. The intention was to
    // allow continuous instantiations until all templates has been expanded
    //bool done = false;

    // Contains tokens such as ""T""
    std::vector<const Token *> typeParametersInDeclaration;
    getTemplateParametersInDeclaration(templateDeclaration.token()->tokAt(2), typeParametersInDeclaration);
    const bool printDebug = mSettings.debugwarnings;
    const bool specialized = templateDeclaration.isSpecialization();
    const bool isfunc = templateDeclaration.isFunction();
    const bool isVar = templateDeclaration.isVariable();

    // locate template usage..
    std::string::size_type numberOfTemplateInstantiations = mTemplateInstantiations.size();
    unsigned int recursiveC...",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.simplifyTemplateInstantiations:bool(TemplateSimplifier.TokenAndName&,std.list<constToken*>&,std.time_t,std.set<std.string>&)",<empty>,,false,3076,3338,simplifyTemplateInstantiations,,,1,"bool(TemplateSimplifier.TokenAndName&,std.list<constToken*>&,std.time_t,std.set<std.string>&)"
111669153416,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static bool matchTemplateParameters(const Token *nameTok, const std::list<std::string> &strings)
{
    const Token *tok = nameTok->tokAt(2);
    const Token *end = nameTok->next()->findClosingBracket();
    if (!end)
        return false;
    auto it = strings.cbegin();
    while (tok && tok != end && it != strings.cend()) {
        if (tok->isUnsigned()) {
            if (*it != ""unsigned"")
                return false;

            ++it;
            if (it == strings.cend())
                return false;
        } else if (tok->isSigned()) {
            if (*it != ""signed"")
                return false;

            ++it;
            if (it == strings.cend())
                return false;
        }
        if (tok->isLong()) {
            if (*it != ""long"")
                return false;

            ++it;
            if (it == strings.cend())
                return false;
        }
        if (*it != tok->str())
            return false;
        tok = tok->next();
        ++it;
  ...",1,1,lib/templatesimplifier.cpp,"matchTemplateParameters:bool(Token*,std.list<std.string>&)",<empty>,,false,3340,3377,matchTemplateParameters,,,1,"bool(Token*,std.list<std.string>&)"
111669153417,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"void TemplateSimplifier::replaceTemplateUsage(
    const TokenAndName &instantiation,
    const std::list<std::string> &typeStringsUsedInTemplateInstantiation,
    const std::string &newName)
{
    std::list<std::pair<Token *, Token *>> removeTokens;
    for (Token *nameTok = mTokenList.front(); nameTok; nameTok = nameTok->next()) {
        if (!Token::Match(nameTok, ""%name% <"") ||
            Token::Match(nameTok, ""template|const_cast|dynamic_cast|reinterpret_cast|static_cast""))
            continue;

        std::set<TemplateSimplifier::TokenAndName*>* pointers = nameTok->templateSimplifierPointers();

        // check if instantiation matches token instantiation from pointer
        if (pointers && !pointers->empty()) {
            // check full name
            if (instantiation.fullName() != (*pointers->begin())->fullName()) {
                // FIXME:  fallback to just matching name
                if (nameTok->str() != instantiation.name())
                    continue;
     ...",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.replaceTemplateUsage:void(TemplateSimplifier.TokenAndName&,std.list<std.string>&,std.string&)",<empty>,,false,3379,3443,replaceTemplateUsage,,,1,"void(TemplateSimplifier.TokenAndName&,std.list<std.string>&,std.string&)"
111669153418,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"static bool specMatch(
    const TemplateSimplifier::TokenAndName &spec,
    const TemplateSimplifier::TokenAndName &decl)
{
    // make sure decl is really a declaration
    if (decl.isPartialSpecialization() || decl.isSpecialization() || decl.isAlias() || decl.isFriend())
        return false;

    if (!spec.isSameFamily(decl))
        return false;

    // make sure the scopes and names match
    if (spec.fullName() == decl.fullName()) {
        if (spec.isFunction()) {
            std::vector<const Token*> specArgs;
            std::vector<const Token*> declArgs;
            getFunctionArguments(spec.nameToken(), specArgs);
            getFunctionArguments(decl.nameToken(), declArgs);

            if (specArgs.size() == declArgs.size()) {
                // @todo make sure function parameters also match
                return true;
            }
        } else
            return true;
    }

    return false;
}",1,1,lib/templatesimplifier.cpp,"specMatch:bool(TemplateSimplifier.TokenAndName&,TemplateSimplifier.TokenAndName&)",<empty>,,false,3445,3473,specMatch,,,1,"bool(TemplateSimplifier.TokenAndName&,TemplateSimplifier.TokenAndName&)"
111669153419,METHOD,<empty>,<empty>,"[&](const TokenAndName& decl) {
                return specMatch(spec, decl);
            }",98,13,lib/templatesimplifier.cpp,lib/templatesimplifier.cpp:<global>.TemplateSimplifier.getSpecializations.<lambda>2:ANY(TemplateSimplifier.TokenAndName&),<empty>,,false,3480,3482,<lambda>2,,,1,ANY(TemplateSimplifier.TokenAndName&)
111669153420,METHOD,<empty>,<empty>,"[&](const TokenAndName& decl) {
                    return specMatch(spec, decl);
                }",111,17,lib/templatesimplifier.cpp,lib/templatesimplifier.cpp:<global>.TemplateSimplifier.getSpecializations.<lambda>3:ANY(TemplateSimplifier.TokenAndName&),<empty>,,false,3486,3488,<lambda>3,,,1,ANY(TemplateSimplifier.TokenAndName&)
111669153421,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"void TemplateSimplifier::getSpecializations()
{
    // try to locate a matching declaration for each user defined specialization
    for (const auto& spec : mTemplateDeclarations) {
        if (spec.isSpecialization()) {
            auto it = std::find_if(mTemplateDeclarations.cbegin(), mTemplateDeclarations.cend(), [&](const TokenAndName& decl) {
                return specMatch(spec, decl);
            });
            if (it != mTemplateDeclarations.cend())
                mTemplateSpecializationMap[spec.token()] = it->token();
            else {
                it = std::find_if(mTemplateForwardDeclarations.cbegin(), mTemplateForwardDeclarations.cend(), [&](const TokenAndName& decl) {
                    return specMatch(spec, decl);
                });
                if (it != mTemplateForwardDeclarations.cend())
                    mTemplateSpecializationMap[spec.token()] = it->token();
            }
        }
    }
}",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.getSpecializations:void(),<empty>,,false,3475,3494,getSpecializations,,,1,void()
111669153422,METHOD,<empty>,<empty>,"[&](const TokenAndName& decl) {
                return specMatch(spec, decl);
            }",98,13,lib/templatesimplifier.cpp,lib/templatesimplifier.cpp:<global>.TemplateSimplifier.getPartialSpecializations.<lambda>4:ANY(TemplateSimplifier.TokenAndName&),<empty>,,false,3501,3503,<lambda>4,,,1,ANY(TemplateSimplifier.TokenAndName&)
111669153423,METHOD,<empty>,<empty>,"[&](const TokenAndName& decl) {
                    return specMatch(spec, decl);
                }",111,17,lib/templatesimplifier.cpp,lib/templatesimplifier.cpp:<global>.TemplateSimplifier.getPartialSpecializations.<lambda>5:ANY(TemplateSimplifier.TokenAndName&),<empty>,,false,3507,3509,<lambda>5,,,1,ANY(TemplateSimplifier.TokenAndName&)
111669153424,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"void TemplateSimplifier::getPartialSpecializations()
{
    // try to locate a matching declaration for each user defined partial specialization
    for (const auto& spec : mTemplateDeclarations) {
        if (spec.isPartialSpecialization()) {
            auto it = std::find_if(mTemplateDeclarations.cbegin(), mTemplateDeclarations.cend(), [&](const TokenAndName& decl) {
                return specMatch(spec, decl);
            });
            if (it != mTemplateDeclarations.cend())
                mTemplatePartialSpecializationMap[spec.token()] = it->token();
            else {
                it = std::find_if(mTemplateForwardDeclarations.cbegin(), mTemplateForwardDeclarations.cend(), [&](const TokenAndName& decl) {
                    return specMatch(spec, decl);
                });
                if (it != mTemplateForwardDeclarations.cend())
                    mTemplatePartialSpecializationMap[spec.token()] = it->token();
            }
        }
    }
}",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.getPartialSpecializations:void(),<empty>,,false,3496,3515,getPartialSpecializations,,,1,void()
111669153425,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"void TemplateSimplifier::fixForwardDeclaredDefaultArgumentValues()
{
    // try to locate a matching declaration for each forward declaration
    for (const auto & forwardDecl : mTemplateForwardDeclarations) {
        std::vector<const Token *> params1;

        getTemplateParametersInDeclaration(forwardDecl.token()->tokAt(2), params1);

        for (auto & decl : mTemplateDeclarations) {
            // skip partializations, type aliases and friends
            if (decl.isPartialSpecialization() || decl.isAlias() || decl.isFriend())
                continue;

            std::vector<const Token *> params2;

            getTemplateParametersInDeclaration(decl.token()->tokAt(2), params2);

            // make sure the number of arguments match
            if (params1.size() == params2.size()) {
                // make sure the scopes and names match
                if (forwardDecl.fullName() == decl.fullName()) {
                    // save forward declaration for lookup later
       ...",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.fixForwardDeclaredDefaultArgumentValues:void(),<empty>,,false,3517,3567,fixForwardDeclaredDefaultArgumentValues,,,1,void()
111669153426,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"void TemplateSimplifier::printOut(const TokenAndName &tokenAndName, const std::string &indent) const
{
    std::cout << indent << ""token: "";
    if (tokenAndName.token())
        std::cout << ""\\"""" << tokenAndName.token()->str() << ""\\"" "" << mTokenList.fileLine(tokenAndName.token());
    else
        std::cout << ""nullptr"";
    std::cout << std::endl;
    std::cout << indent << ""scope: \\"""" << tokenAndName.scope() << ""\\"""" << std::endl;
    std::cout << indent << ""name: \\"""" << tokenAndName.name() << ""\\"""" << std::endl;
    std::cout << indent << ""fullName: \\"""" << tokenAndName.fullName() << ""\\"""" << std::endl;
    std::cout << indent << ""nameToken: "";
    if (tokenAndName.nameToken())
        std::cout << ""\\"""" << tokenAndName.nameToken()->str() << ""\\"" "" << mTokenList.fileLine(tokenAndName.nameToken());
    else
        std::cout << ""nullptr"";
    std::cout << std::endl;
    std::cout << indent << ""paramEnd: "";
    if (tokenAndName.paramEnd())
        std::cout << ""\\"""" << tokenAndName.param...",1,1,lib/templatesimplifier.cpp,"TemplateSimplifier.printOut<const>:void(TemplateSimplifier.TokenAndName&,std.string&)",<empty>,,false,3569,3639,printOut,,,1,"void(TemplateSimplifier.TokenAndName&,std.string&)"
111669153427,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"void TemplateSimplifier::printOut(const std::string & text) const
{
    std::cout << std::endl;
    std::cout << text << std::endl;
    std::cout << std::endl;
    std::cout << ""mTemplateDeclarations: "" << mTemplateDeclarations.size() << std::endl;
    int count = 0;
    for (const auto & decl : mTemplateDeclarations) {
        std::cout << ""mTemplateDeclarations["" << count++ << ""]:"" << std::endl;
        printOut(decl);
    }
    std::cout << ""mTemplateForwardDeclarations: "" << mTemplateForwardDeclarations.size() << std::endl;
    count = 0;
    for (const auto & decl : mTemplateForwardDeclarations) {
        std::cout << ""mTemplateForwardDeclarations["" << count++ << ""]:"" << std::endl;
        printOut(decl);
    }
    std::cout << ""mTemplateForwardDeclarationsMap: "" << mTemplateForwardDeclarationsMap.size() << std::endl;
    unsigned int mapIndex = 0;
    for (const auto & mapItem : mTemplateForwardDeclarationsMap) {
        unsigned int declIndex = 0;
        for (const auto & de...",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.printOut<const>:void(std.string&),<empty>,,false,3641,3756,printOut,,,1,void(std.string&)
111669153428,METHOD,<empty>,<empty>,"[&](const Token* arg) {
            int i = 0;
            for (const Token* tok = arg; tok; tok = tok->next()) {
                if (tok->str() == "","")
                    return i;
                if (tok->link() && Token::Match(tok, ""(|{|[""))
                    tok = tok->link();
                else if (tok->str() == ""<"") {
                    const Token* temp = tok->findClosingBracket();
                    if (temp)
                        tok = temp;
                } else if (Token::Match(tok, "")|;""))
                    return i;
                else if (Token::simpleMatch(tok, ""const""))
                    i--;
            }
            return 0;
        }",22,9,lib/templatesimplifier.cpp,lib/templatesimplifier.cpp:<global>.TemplateSimplifier.simplifyTemplates.<lambda>6:int(Token*),<empty>,,false,3876,3893,<lambda>6,,,1,int(Token*)
111669153429,METHOD,<empty>,<empty>,"[&](const Token* xarg, const Token* yarg) {
                    if (xarg != yarg)
                        return score(xarg) < score(yarg);
                    return false;
                }",53,17,lib/templatesimplifier.cpp,"lib/templatesimplifier.cpp:<global>.TemplateSimplifier.simplifyTemplates.<lambda>7.<lambda>8:bool(Token*,Token*)",<empty>,,false,3911,3915,<lambda>8,,,1,"bool(Token*,Token*)"
111669153430,METHOD,<empty>,<empty>,"[&](const TokenAndName& x, const TokenAndName& y) {
            if (x.fullName() != y.fullName())
                return nameOrdinal.at(x.fullName()) < nameOrdinal.at(y.fullName());
            if (x.isFunction() && y.isFunction()) {
                std::vector<const Token*> xargs;
                getFunctionArguments(x.nameToken(), xargs);
                std::vector<const Token*> yargs;
                getFunctionArguments(y.nameToken(), yargs);
                if (xargs.size() != yargs.size())
                    return xargs.size() < yargs.size();
                if (isConstMethod(x.nameToken()) != isConstMethod(y.nameToken()))
                    return isConstMethod(x.nameToken());
                return std::lexicographical_compare(xargs.begin(),
                                                    xargs.end(),
                                                    yargs.begin(),
                                                    yargs.end(),
                                    ...",36,9,lib/templatesimplifier.cpp,"lib/templatesimplifier.cpp:<global>.TemplateSimplifier.simplifyTemplates.<lambda>7:bool(TemplateSimplifier.TokenAndName&,TemplateSimplifier.TokenAndName&)",<empty>,,false,3895,3918,<lambda>7,,,1,"bool(TemplateSimplifier.TokenAndName&,TemplateSimplifier.TokenAndName&)"
111669153431,METHOD,<empty>,<empty>,"[&it](const TokenAndName& decl) {
                return decl.token() == it->token();
            }",98,13,lib/templatesimplifier.cpp,lib/templatesimplifier.cpp:<global>.TemplateSimplifier.simplifyTemplates.<lambda>9:bool(TemplateSimplifier.TokenAndName&),<empty>,,false,3948,3950,<lambda>9,,,1,bool(TemplateSimplifier.TokenAndName&)
111669153432,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"void TemplateSimplifier::simplifyTemplates(const std::time_t maxtime)
{
    // convert ""sizeof ..."" to ""sizeof...""
    for (Token *tok = mTokenList.front(); tok; tok = tok->next()) {
        if (Token::simpleMatch(tok, ""sizeof ..."")) {
            tok->str(""sizeof..."");
            tok->deleteNext();
        }
    }

    // Remove ""typename"" unless used in template arguments or using type alias..
    for (Token *tok = mTokenList.front(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""typename %name%"") && !Token::Match(tok->tokAt(-3), ""using %name% =""))
            tok->deleteThis();

        if (Token::simpleMatch(tok, ""template <"")) {
            tok = tok->next()->findClosingBracket();
            if (!tok)
                break;
        }
    }

    if (mSettings.standards.cpp >= Standards::CPP20) {
        // Remove concepts/requires
        // TODO concepts are not removed yet
        for (Token *tok = mTokenList.front(); tok; tok = tok->next()) {
            if (!Tok...",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.simplifyTemplates:void(std.time_t),<empty>,,false,3758,4060,simplifyTemplates,,,1,void(std.time_t)
111669153433,METHOD,lib/templatesimplifier.cpp:<global>,TYPE_DECL,"void TemplateSimplifier::syntaxError(const Token *tok)
{
    throw InternalError(tok, ""syntax error"", InternalError::SYNTAX);
}",1,1,lib/templatesimplifier.cpp,TemplateSimplifier.syntaxError:void(Token*),<empty>,,false,4062,4065,syntaxError,,,1,void(Token*)
111669153434,METHOD,lib/templatesimplifier.h:<global>,TYPE_DECL,<global>,1,1,lib/templatesimplifier.h,lib/templatesimplifier.h:<global>,<empty>,,false,1,517,<global>,,,1,
111669153435,METHOD,lib/timer.cpp:<global>,TYPE_DECL,"bool more_second_sec(const dataElementType& lhs, const dataElementType& rhs)
    {
        return lhs.second.seconds() > rhs.second.seconds();
    }",5,5,lib/timer.cpp,"more_second_sec:bool(dataElementType&,dataElementType&)",<empty>,,false,30,33,more_second_sec,,,1,"bool(dataElementType&,dataElementType&)"
111669153436,METHOD,<empty>,<empty>,"[iter,pos](const dataElementType& d) {
                    return d.first.size() == pos && iter->first.compare(0, d.first.size(), d.first) == 0;
                }",69,17,lib/timer.cpp,lib/timer.cpp:<global>.TimerResults.showResults<const>.<lambda>0:bool(dataElementType&),<empty>,,false,75,77,<lambda>0,,,1,bool(dataElementType&)
111669153437,METHOD,lib/timer.cpp:<global>,TYPE_DECL,"void TimerResults::showResults(SHOWTIME_MODES mode) const
{
    if (mode == SHOWTIME_MODES::SHOWTIME_NONE || mode == SHOWTIME_MODES::SHOWTIME_FILE_TOTAL)
        return;

    TimerResultsData overallData;
    std::vector<dataElementType> data;

    {
        std::lock_guard<std::mutex> l(mResultsSync);

        data.reserve(mResults.size());
        data.insert(data.begin(), mResults.cbegin(), mResults.cend());
    }
    std::sort(data.begin(), data.end(), more_second_sec);

    // lock the whole logging operation to avoid multiple threads printing their results at the same time
    std::lock_guard<std::mutex> l(stdCoutLock);

    std::cout << std::endl;

    size_t ordinal = 1; // maybe it would be nice to have an ordinal in output later!
    for (auto iter=data.cbegin(); iter!=data.cend(); ++iter) {
        const double sec = iter->second.seconds();
        const double secAverage = sec / (double)(iter->second.mNumberOfResults);
        bool hasParent = false;
        {
          ...",1,1,lib/timer.cpp,TimerResults.showResults<const>:void(SHOWTIME_MODES),<empty>,,false,41,89,showResults,,,1,void(SHOWTIME_MODES)
111669153438,METHOD,lib/timer.cpp:<global>,TYPE_DECL,<global>,1,1,lib/timer.cpp,lib/timer.cpp:<global>,<empty>,,false,1,144,<global>,,,1,
111669153439,METHOD,lib/timer.cpp:<global>,TYPE_DECL,"void TimerResults::addResults(const std::string& str, std::clock_t clocks)
{
    std::lock_guard<std::mutex> l(mResultsSync);

    mResults[str].mClocks += clocks;
    mResults[str].mNumberOfResults++;
}",1,1,lib/timer.cpp,"TimerResults.addResults:void(std.string&,std.clock_t)",<empty>,,false,91,97,addResults,,,1,"void(std.string&,std.clock_t)"
111669153440,METHOD,lib/timer.cpp:<global>,TYPE_DECL,"void TimerResults::reset()
{
    std::lock_guard<std::mutex> l(mResultsSync);
    mResults.clear();
}",1,1,lib/timer.cpp,TimerResults.reset:void(),<empty>,,false,99,103,reset,,,1,void()
111669153441,METHOD,lib/timer.cpp:<global>,TYPE_DECL,"Timer::Timer(std::string str, SHOWTIME_MODES showtimeMode, TimerResultsIntf* timerResults)
    : mStr(std::move(str))
    , mTimerResults(timerResults)
    , mStart(std::clock())
    , mShowTimeMode(showtimeMode)
    , mStopped(showtimeMode == SHOWTIME_MODES::SHOWTIME_NONE || showtimeMode == SHOWTIME_MODES::SHOWTIME_FILE_TOTAL)
{}",1,2,lib/timer.cpp,"Timer.Timer:ANY(std.string,SHOWTIME_MODES,TimerResultsIntf*)",<empty>,,false,105,111,Timer,,,1,"Timer.Timer:ANY(std.string,SHOWTIME_MODES,TimerResultsIntf*)(std.string,SHOWTIME_MODES,TimerResultsIntf*)"
111669153442,METHOD,lib/timer.cpp:<global>,TYPE_DECL,"Timer::Timer(bool fileTotal, std::string filename)
    : mStr(std::move(filename))
    , mStopped(!fileTotal)
{}",1,2,lib/timer.cpp,"Timer.Timer:ANY(bool,std.string)",<empty>,,false,113,116,Timer,,,1,"Timer.Timer:ANY(bool,std.string)(bool,std.string)"
111669153443,METHOD,lib/timer.cpp:<global>,TYPE_DECL,"Timer::~Timer()
{
    stop();
}",1,1,lib/timer.cpp,Timer.~Timer:ANY(),<empty>,,false,118,121,~Timer,,,1,ANY()
111669153444,METHOD,lib/timer.cpp:<global>,TYPE_DECL,"void Timer::stop()
{
    if ((mShowTimeMode != SHOWTIME_MODES::SHOWTIME_NONE) && !mStopped) {
        const std::clock_t end = std::clock();
        const std::clock_t diff = end - mStart;

        if (mShowTimeMode == SHOWTIME_MODES::SHOWTIME_FILE) {
            const double sec = (double)diff / CLOCKS_PER_SEC;
            std::lock_guard<std::mutex> l(stdCoutLock);
            std::cout << mStr << "": "" << sec << ""s"" << std::endl;
        } else if (mShowTimeMode == SHOWTIME_MODES::SHOWTIME_FILE_TOTAL) {
            const double sec = (double)diff / CLOCKS_PER_SEC;
            std::lock_guard<std::mutex> l(stdCoutLock);
            std::cout << ""Check time: "" << mStr << "": "" << sec << ""s"" << std::endl;
        } else {
            if (mTimerResults)
                mTimerResults->addResults(mStr, diff);
        }
    }

    mStopped = true;
}",1,1,lib/timer.cpp,Timer.stop:void(),<empty>,,false,123,144,stop,,,1,void()
111669153445,METHOD,lib/timer.h:<global>,TYPE_DECL,<global>,1,1,lib/timer.h,lib/timer.h:<global>,<empty>,,false,1,97,<global>,,,1,
111669153446,METHOD,less,TYPE_DECL,"bool operator()(const T &x, const U &y) const {
            return x < y;
        }",9,9,lib/token.cpp,"less.()<const>:bool(T&,U&)",<empty>,,false,54,56,(),,,1,"bool(T&,U&)"
111669153447,METHOD,lib/token.cpp:<global>,TYPE_DECL,"Token::Token(TokensFrontBack &tokensFrontBack)
    : mTokensFrontBack(tokensFrontBack)
    , mIsC(mTokensFrontBack.list.isC())
    , mIsCpp(mTokensFrontBack.list.isCPP())
{
    mImpl = new TokenImpl();
}",1,1,lib/token.cpp,Token.Token:ANY(TokensFrontBack&),<empty>,,false,63,69,Token,,,1,Token.Token:ANY(TokensFrontBack&)(TokensFrontBack&)
111669153448,METHOD,lib/token.cpp:<global>,TYPE_DECL,<global>,1,1,lib/token.cpp,lib/token.cpp:<global>,<empty>,,false,1,2719,<global>,,,1,
111669153449,METHOD,lib/token.cpp:<global>,TYPE_DECL,"Token::Token(const Token* tok)
    : Token(const_cast<Token*>(tok)->mTokensFrontBack)
{
    fileIndex(tok->fileIndex());
    linenr(tok->linenr());
}",1,1,lib/token.cpp,Token.Token:ANY(Token*),<empty>,,false,71,76,Token,,,1,Token.Token:ANY(Token*)(Token*)
111669153450,METHOD,lib/token.cpp:<global>,TYPE_DECL,"Token::~Token()
{
    delete mImpl;
}",1,1,lib/token.cpp,Token.~Token:ANY(),<empty>,,false,78,81,~Token,,,1,ANY()
111669153451,METHOD,lib/token.cpp:<global>,TYPE_DECL,"ConstTokenRange Token::until(const Token* t) const
{
    return ConstTokenRange(this, t);
}",1,1,lib/token.cpp,Token.until<const>:ConstTokenRange(Token*),<empty>,,false,89,92,until,,,1,ConstTokenRange(Token*)
111669153452,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::update_property_info()
{
    setFlag(fIsControlFlowKeyword, false);
    // TODO: clear fIsLong
    isStandardType(false);

    if (!mStr.empty()) {
        if (mStr == ""true"" || mStr == ""false"")
            tokType(eBoolean);
        else if (isStringLiteral(mStr)) {
            tokType(eString);
            isLong(isPrefixStringCharLiteral(mStr, '""', ""L""));
        }
        else if (isCharLiteral(mStr)) {
            tokType(eChar);
            isLong(isPrefixStringCharLiteral(mStr, '\\'', ""L""));
        }
        else if (std::isalpha((unsigned char)mStr[0]) || mStr[0] == '_' || mStr[0] == '$') { // Name
            if (mImpl->mVarId)
                tokType(eVariable);
            else if (mTokensFrontBack.list.isKeyword(mStr)) {
                tokType(eKeyword);
                update_property_isStandardType();
                if (mTokType != eType) // cannot be a control-flow keyword when it is a type
                    setFlag(fIsControlFlowKeyword, controlFlowKe...",1,1,lib/token.cpp,Token.update_property_info:void(),<empty>,,false,108,189,update_property_info,,,1,void()
111669153453,METHOD,lib/token.cpp:<global>,TYPE_DECL,"bool Token::isStandardType(const std::string& str)
{
    return stdTypes.find(str) != stdTypes.end();
}",1,1,lib/token.cpp,Token.isStandardType:bool(std.string&),<empty>,,false,206,209,isStandardType,,,1,bool(std.string&)
111669153454,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::update_property_isStandardType()
{
    if (mStr.size() < 3 || mStr.size() > 7)
        return;

    if (isStandardType(mStr)) {
        isStandardType(true);
        tokType(eType);
    }
}",1,1,lib/token.cpp,Token.update_property_isStandardType:void(),<empty>,,false,211,220,update_property_isStandardType,,,1,void()
111669153455,METHOD,<empty>,<empty>,"[](char c) {
        return std::islower(c);
    }",51,5,lib/token.cpp,lib/token.cpp:<global>.Token.isUpperCaseName<const>.<lambda>0:ANY(char),<empty>,,false,226,228,<lambda>0,,,1,ANY(char)
111669153456,METHOD,lib/token.cpp:<global>,TYPE_DECL,"bool Token::isUpperCaseName() const
{
    if (!isName())
        return false;
    return std::none_of(mStr.begin(), mStr.end(), [](char c) {
        return std::islower(c);
    });
}",1,1,lib/token.cpp,Token.isUpperCaseName<const>:bool(),<empty>,,false,222,229,isUpperCaseName,,,1,bool()
111669153457,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::concatStr(std::string const& b)
{
    mStr.pop_back();
    mStr.append(getStringLiteral(b) + ""\\"""");

    if (isCChar() && isStringLiteral(b) && b[0] != '""') {
        mStr.insert(0, b.substr(0, b.find('""')));
    }
    update_property_info();
}",1,1,lib/token.cpp,Token.concatStr:void(std.string&),<empty>,,false,231,240,concatStr,,,1,void(std.string&)
111669153458,METHOD,lib/token.cpp:<global>,TYPE_DECL,"std::string Token::strValue() const
{
    assert(mTokType == eString);
    std::string ret(getStringLiteral(mStr));
    std::string::size_type pos = 0U;
    while ((pos = ret.find('\\\\', pos)) != std::string::npos) {
        ret.erase(pos,1U);
        if (ret[pos] >= 'a') {
            if (ret[pos] == 'n')
                ret[pos] = '\\n';
            else if (ret[pos] == 'r')
                ret[pos] = '\\r';
            else if (ret[pos] == 't')
                ret[pos] = '\\t';
        }
        if (ret[pos] == '0')
            return ret.substr(0,pos);
        pos++;
    }
    return ret;
}",1,1,lib/token.cpp,Token.strValue<const>:string(),<empty>,,false,242,262,strValue,,,1,string()
111669153459,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::deleteNext(nonneg int count)
{
    while (mNext && count > 0) {
        Token *n = mNext;

        // #8154 we are about to be unknown -> destroy the link to us
        if (n->mLink && n->mLink->mLink == n)
            n->mLink->link(nullptr);

        mNext = n->next();
        delete n;
        --count;
    }

    if (mNext)
        mNext->previous(this);
    else
        mTokensFrontBack.back = this;
}",1,23,lib/token.cpp,Token.deleteNext:void(int),<empty>,,false,264,282,deleteNext,,,1,void(int)
111669153460,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::deletePrevious(nonneg int count)
{
    while (mPrevious && count > 0) {
        Token *p = mPrevious;

        // #8154 we are about to be unknown -> destroy the link to us
        if (p->mLink && p->mLink->mLink == p)
            p->mLink->link(nullptr);

        mPrevious = p->previous();
        delete p;
        --count;
    }

    if (mPrevious)
        mPrevious->next(this);
    else
        mTokensFrontBack.front = this;
}",1,27,lib/token.cpp,Token.deletePrevious:void(int),<empty>,,false,284,302,deletePrevious,,,1,void(int)
111669153461,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::swapWithNext()
{
    if (mNext) {
        std::swap(mStr, mNext->mStr);
        std::swap(mTokType, mNext->mTokType);
        std::swap(mFlags, mNext->mFlags);
        std::swap(mImpl, mNext->mImpl);
        if (mImpl->mTemplateSimplifierPointers)
            // cppcheck-suppress shadowFunction - TODO: fix this
            for (auto *templateSimplifierPointer : *mImpl->mTemplateSimplifierPointers) {
                templateSimplifierPointer->token(this);
            }

        if (mNext->mImpl->mTemplateSimplifierPointers)
            // cppcheck-suppress shadowFunction - TODO: fix this
            for (auto *templateSimplifierPointer : *mNext->mImpl->mTemplateSimplifierPointers) {
                templateSimplifierPointer->token(mNext);
            }
        if (mNext->mLink)
            mNext->mLink->mLink = this;
        if (this->mLink)
            this->mLink->mLink = mNext;
        std::swap(mLink, mNext->mLink);
    }
}",1,1,lib/token.cpp,Token.swapWithNext:void(),<empty>,,false,304,328,swapWithNext,,,1,void()
111669153462,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::takeData(Token *fromToken)
{
    mStr = fromToken->mStr;
    tokType(fromToken->mTokType);
    mFlags = fromToken->mFlags;
    delete mImpl;
    mImpl = fromToken->mImpl;
    fromToken->mImpl = nullptr;
    if (mImpl->mTemplateSimplifierPointers)
        // cppcheck-suppress shadowFunction - TODO: fix this
        for (auto *templateSimplifierPointer : *mImpl->mTemplateSimplifierPointers) {
            templateSimplifierPointer->token(this);
        }
    mLink = fromToken->mLink;
    if (mLink)
        mLink->link(this);
}",1,1,lib/token.cpp,Token.takeData:void(Token*),<empty>,,false,330,346,takeData,,,1,void(Token*)
111669153463,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::deleteThis()
{
    if (mNext) { // Copy next to this and delete next
        takeData(mNext);
        mNext->link(nullptr); // mark as unlinked
        deleteNext();
    } else if (mPrevious) { // Copy previous to this and delete previous
        takeData(mPrevious);
        mPrevious->link(nullptr);
        deletePrevious();
    } else {
        // We are the last token in the list, we can't delete
        // ourselves, so just make us empty
        str("";"");
    }
}",1,1,lib/token.cpp,Token.deleteThis:void(),<empty>,,false,348,363,deleteThis,,,1,void()
111669153464,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::replace(Token *replaceThis, Token *start, Token *end)
{
    // Fix the whole in the old location of start and end
    if (start->previous())
        start->previous()->next(end->next());

    if (end->next())
        end->next()->previous(start->previous());

    // Move start and end to their new location
    if (replaceThis->previous())
        replaceThis->previous()->next(start);

    if (replaceThis->next())
        replaceThis->next()->previous(end);

    start->previous(replaceThis->previous());
    end->next(replaceThis->next());

    if (end->mTokensFrontBack.back == end) {
        while (end->next())
            end = end->next();
        end->mTokensFrontBack.back = end;
    }

    // Update mProgressValue, fileIndex and linenr
    for (Token *tok = start; tok != end->next(); tok = tok->next())
        tok->mImpl->mProgressValue = replaceThis->mImpl->mProgressValue;

    // Delete old token, which is replaced
    delete replaceThis;
}",1,1,lib/token.cpp,"Token.replace:void(Token*,Token*,Token*)",<empty>,,false,365,396,replace,,,1,"void(Token*,Token*,Token*)"
111669153465,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static
#if defined(__GNUC__)
// GCC does not inline this by itself
// need to use the old syntax since the C++11 [[xxx:always_inline]] cannot be used here
inline __attribute__((always_inline))
#endif
int multiComparePercent(const Token *tok, const char*& haystack, nonneg int varid)
{
    ++haystack;
    // Compare only the first character of the string for optimization reasons
    switch (haystack[0]) {
    case 'v':
        if (haystack[3] == '%') { // %var%
            haystack += 4;
            if (tok->varId() != 0)
                return 1;
        } else { // %varid%
            if (varid == 0) {
                throw InternalError(tok, ""Internal error. Token::Match called with varid 0. Please report this to Cppcheck developers"");
            }

            haystack += 6;

            if (tok->varId() == varid)
                return 1;
        }
        break;
    case 't':
        // Type (%type%)
    {
        haystack += 5;
        if (tok->isName() && tok->varId() == 0)
 ...",1,65,lib/token.cpp,"multiComparePercent:int(Token*,char*&,int)",<empty>,,false,398,534,multiComparePercent,,,1,"int(Token*,char*&,int)"
111669153466,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static
#if defined(__GNUC__)
// need to use the old syntax since the C++11 [[xxx:always_inline]] cannot be used here
inline __attribute__((always_inline))
#endif
int multiCompareImpl(const Token *tok, const char *haystack, nonneg int varid)
{
    const char *needle = tok->str().c_str();
    const char *needlePointer = needle;
    for (;;) {
        if (needlePointer == needle && haystack[0] == '%' && haystack[1] != '|' && haystack[1] != '\\0' && haystack[1] != ' ') {
            const int ret = multiComparePercent(tok, haystack, varid);
            if (ret < 2)
                return ret;
        } else if (*haystack == '|') {
            if (*needlePointer == 0) {
                // If needle is at the end, we have a match.
                return 1;
            }

            needlePointer = needle;
            ++haystack;
        } else if (*needlePointer == *haystack) {
            if (*needlePointer == '\\0')
                return 1;
            ++needlePointer;
            ++hay...",1,61,lib/token.cpp,"multiCompareImpl:int(Token*,char*,int)",<empty>,,false,536,592,multiCompareImpl,,,1,"int(Token*,char*,int)"
111669153467,METHOD,lib/token.cpp:<global>,TYPE_DECL,"int Token::multiCompare(const Token *tok, const char *haystack, nonneg int varid)
{
    return multiCompareImpl(tok, haystack, varid);
}",1,64,lib/token.cpp,"Token.multiCompare:int(Token*,char*,int)",<empty>,,false,595,598,multiCompare,,,1,"int(Token*,char*,int)"
111669153468,METHOD,lib/token.cpp:<global>,TYPE_DECL,"bool Token::simpleMatch(const Token *tok, const char pattern[], size_t pattern_len)
{
    if (!tok)
        return false; // shortcut
    const char *current = pattern;
    const char *end = pattern + pattern_len;
    // cppcheck-suppress shadowFunction - TODO: fix this
    const char *next = static_cast<const char*>(std::memchr(pattern, ' ', pattern_len));
    if (!next)
        next = end;

    while (*current) {
        const std::size_t length = next - current;

        if (!tok || length != tok->mStr.length() || std::strncmp(current, tok->mStr.c_str(), length) != 0)
            return false;

        current = next;
        if (*next) {
            next = std::strchr(++current, ' ');
            if (!next)
                next = end;
        }
        tok = tok->next();
    }

    return true;
}",1,1,lib/token.cpp,"Token.simpleMatch:bool(Token*,char[],size_t)",<empty>,,false,600,627,simpleMatch,,,1,"bool(Token*,char[],size_t)"
111669153469,METHOD,lib/token.cpp:<global>,TYPE_DECL,"bool Token::firstWordEquals(const char *str, const char *word)
{
    for (;;) {
        if (*str != *word)
            return (*str == ' ' && *word == 0);
        if (*str == 0)
            break;

        ++str;
        ++word;
    }

    return true;
}",1,1,lib/token.cpp,"Token.firstWordEquals:bool(char*,char*)",<empty>,,false,629,642,firstWordEquals,,,1,"bool(char*,char*)"
111669153470,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const char *Token::chrInFirstWord(const char *str, char c)
{
    for (;;) {
        if (*str == ' ' || *str == 0)
            return nullptr;

        if (*str == c)
            return str;

        ++str;
    }
}",1,1,lib/token.cpp,"Token.chrInFirstWord:char*(char*,char)",<empty>,,false,644,655,chrInFirstWord,,,1,"char*(char*,char)"
111669153471,METHOD,lib/token.cpp:<global>,TYPE_DECL,"bool Token::Match(const Token *tok, const char pattern[], nonneg int varid)
{
    if (!(*pattern))
        return true;

    const char *p = pattern;
    while (true) {
        // Skip spaces in pattern..
        while (*p == ' ')
            ++p;

        // No token => Success!
        if (*p == '\\0')
            break;

        if (!tok) {
            // If we have no tokens, pattern ""!!else"" should return true
            if (p[0] == '!' && p[1] == '!' && p[2] != '\\0') {
                while (*p && *p != ' ')
                    ++p;
                continue;
            }

            return false;
        }

        // [.. => search for a one-character token..
        if (p[0] == '[' && chrInFirstWord(p, ']')) {
            if (tok->str().length() != 1)
                return false;

            const char *temp = p+1;
            bool chrFound = false;
            int count = 0;
            while (*temp && *temp != ' ') {
                if (*temp == ']') {
                 ...",1,58,lib/token.cpp,"Token.Match:bool(Token*,char[],int)",<empty>,,false,657,744,Match,,,1,"bool(Token*,char[],int)"
111669153472,METHOD,lib/token.cpp:<global>,TYPE_DECL,"int Token::getStrLength(const Token *tok)
{
    assert(tok != nullptr);
    assert(tok->mTokType == eString);

    const std::string s(replaceEscapeSequences(getStringLiteral(tok->str())));

    const auto pos = s.find('\\0');
    return pos < s.size() ? pos : s.size();
}",8,1,lib/token.cpp,Token.getStrLength:int(Token*),<empty>,,false,746,755,getStrLength,,,1,int(Token*)
111669153473,METHOD,lib/token.cpp:<global>,TYPE_DECL,"int Token::getStrArraySize(const Token *tok)
{
    assert(tok != nullptr);
    assert(tok->tokType() == eString);
    // cppcheck-suppress shadowFunction - TODO: fix this
    const std::string str(getStringLiteral(tok->str()));
    int sizeofstring = 1;
    for (int i = 0; i < (int)str.size(); i++) {
        if (str[i] == '\\\\')
            ++i;
        ++sizeofstring;
    }
    return sizeofstring;
}",8,1,lib/token.cpp,Token.getStrArraySize:int(Token*),<empty>,,false,757,770,getStrArraySize,,,1,int(Token*)
111669153474,METHOD,lib/token.cpp:<global>,TYPE_DECL,"int Token::getStrSize(const Token *tok, const Settings &settings)
{
    assert(tok != nullptr && tok->tokType() == eString);
    nonneg int sizeofType = 1;
    if (tok->valueType()) {
        ValueType vt(*tok->valueType());
        vt.pointer = 0;
        sizeofType = ValueFlow::getSizeOf(vt, settings);
    }
    return getStrArraySize(tok) * sizeofType;
}",8,4,lib/token.cpp,"Token.getStrSize:int(Token*,Settings&)",<empty>,,false,772,782,getStrSize,,,1,"int(Token*,Settings&)"
111669153475,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::move(Token *srcStart, Token *srcEnd, Token *newLocation)
{
    /**[newLocation] -> b -> c -> [srcStart] -> [srcEnd] -> f */

    // Fix the gap, which tokens to be moved will leave
    srcStart->previous()->next(srcEnd->next());
    srcEnd->next()->previous(srcStart->previous());

    // Fix the tokens to be moved
    srcEnd->next(newLocation->next());
    srcStart->previous(newLocation);

    // Fix the tokens at newLocation
    newLocation->next()->previous(srcEnd);
    newLocation->next(srcStart);

    // Update _progressValue
    for (Token *tok = srcStart; tok != srcEnd->next(); tok = tok->next())
        tok->mImpl->mProgressValue = newLocation->mImpl->mProgressValue;
}",1,1,lib/token.cpp,"Token.move:void(Token*,Token*,Token*)",<empty>,,false,784,803,move,,,1,"void(Token*,Token*,Token*)"
111669153476,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static T* nextArgumentImpl(T *thisTok)
{
    for (T* tok = thisTok; tok; tok = tok->next()) {
        if (tok->str() == "","")
            return tok->next();
        if (tok->link() && Token::Match(tok, ""(|{|[|<""))
            tok = tok->link();
        else if (Token::Match(tok, "")|;""))
            return nullptr;
    }
    return nullptr;
}",1,1,lib/token.cpp,nextArgumentImpl:T(T*),<empty>,,false,806,817,nextArgumentImpl,,,1,T(T*)
111669153477,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const Token* Token::nextArgument() const
{
    return nextArgumentImpl(this);
}",1,1,lib/token.cpp,Token.nextArgument<const>:Token*(),<empty>,,false,819,822,nextArgument,,,1,Token*()
111669153478,METHOD,lib/token.cpp:<global>,TYPE_DECL,"Token *Token::nextArgument()
{
    return nextArgumentImpl(this);
}",1,1,lib/token.cpp,Token.nextArgument:Token*(),<empty>,,false,824,827,nextArgument,,,1,Token*()
111669153479,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const Token* Token::nextArgumentBeforeCreateLinks2() const
{
    for (const Token* tok = this; tok; tok = tok->next()) {
        if (tok->str() == "","")
            return tok->next();
        if (tok->link() && Token::Match(tok, ""(|{|[""))
            tok = tok->link();
        else if (tok->str() == ""<"") {
            const Token* temp = tok->findClosingBracket();
            if (temp)
                tok = temp;
        } else if (Token::Match(tok, "")|;""))
            return nullptr;
    }
    return nullptr;
}",1,1,lib/token.cpp,Token.nextArgumentBeforeCreateLinks2<const>:Token*(),<empty>,,false,829,844,nextArgumentBeforeCreateLinks2,,,1,Token*()
111669153480,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const Token* Token::nextTemplateArgument() const
{
    for (const Token* tok = this; tok; tok = tok->next()) {
        if (tok->str() == "","")
            return tok->next();
        if (tok->link() && Token::Match(tok, ""(|{|[|<""))
            tok = tok->link();
        else if (Token::Match(tok, "">|;""))
            return nullptr;
    }
    return nullptr;
}",1,1,lib/token.cpp,Token.nextTemplateArgument<const>:Token*(),<empty>,,false,846,857,nextTemplateArgument,,,1,Token*()
111669153481,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static bool isOperator(const Token *tok)
{
    if (tok->link())
        tok = tok->link();
    // TODO handle multi token operators
    return tok->strAt(-1) == ""operator"";
}",1,1,lib/token.cpp,isOperator<duplicate>0:bool(Token*),<empty>,,false,859,865,isOperator,,,1,bool(Token*)
111669153482,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const Token * Token::findClosingBracket() const
{
    if (mStr != ""<"")
        return nullptr;

    if (!mPrevious)
        return nullptr;

    if (!(mPrevious->isName() || Token::simpleMatch(mPrevious, ""]"") ||
          Token::Match(mPrevious->previous(), ""operator %op% <"") ||
          Token::Match(mPrevious->tokAt(-2), ""operator [([] [)]] <"")))
        return nullptr;

    const Token *closing = nullptr;
    const bool templateParameter(strAt(-1) == ""template"");
    std::set<std::string> templateParameters;

    bool isDecl = true;
    for (const Token *prev = previous(); prev; prev = prev->previous()) {
        if (prev->str() == ""="")
            isDecl = false;
        if (Token::simpleMatch(prev, ""template <""))
            isDecl = true;
        if (Token::Match(prev, ""[;{}]""))
            break;
    }

    unsigned int depth = 0;
    for (closing = this; closing != nullptr; closing = closing->next()) {
        if (Token::Match(closing, ""{|[|("")) {
            closing = closi...",1,1,lib/token.cpp,Token.findClosingBracket<const>:Token*(),<empty>,,false,867,924,findClosingBracket,,,1,Token*()
111669153483,METHOD,lib/token.cpp:<global>,TYPE_DECL,"Token * Token::findClosingBracket()
{
    // return value of const function
    return const_cast<Token*>(static_cast<const Token*>(this)->findClosingBracket());
}",1,1,lib/token.cpp,Token.findClosingBracket:Token*(),<empty>,,false,926,930,findClosingBracket,,,1,Token*()
111669153484,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const Token * Token::findOpeningBracket() const
{
    if (mStr != "">"")
        return nullptr;

    const Token *opening = nullptr;

    unsigned int depth = 0;
    for (opening = this; opening != nullptr; opening = opening->previous()) {
        if (Token::Match(opening, ""}|]|)"")) {
            opening = opening->link();
            if (!opening)
                return nullptr;
        } else if (Token::Match(opening, ""{|{|(|;""))
            return nullptr;
        else if (opening->str() == "">"")
            ++depth;
        else if (opening->str() == ""<"") {
            if (--depth == 0)
                return opening;
        }
    }

    return opening;
}",1,1,lib/token.cpp,Token.findOpeningBracket<const>:Token*(),<empty>,,false,932,956,findOpeningBracket,,,1,Token*()
111669153485,METHOD,lib/token.cpp:<global>,TYPE_DECL,"Token * Token::findOpeningBracket()
{
    // return value of const function
    return const_cast<Token*>(static_cast<const Token*>(this)->findOpeningBracket());
}",1,1,lib/token.cpp,Token.findOpeningBracket:Token*(),<empty>,,false,958,962,findOpeningBracket,,,1,Token*()
111669153486,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static T *findsimplematchImpl(T * const startTok, const char pattern[], size_t pattern_len)
{
    for (T* tok = startTok; tok; tok = tok->next()) {
        if (Token::simpleMatch(tok, pattern, pattern_len))
            return tok;
    }
    return nullptr;
}",1,1,lib/token.cpp,"findsimplematchImpl:T(T*,char[],size_t)",<empty>,,false,967,974,findsimplematchImpl,,,1,"T(T*,char[],size_t)"
111669153487,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const Token *Token::findsimplematch(const Token * const startTok, const char pattern[], size_t pattern_len)
{
    return findsimplematchImpl(startTok, pattern, pattern_len);
}",1,1,lib/token.cpp,"Token.findsimplematch:Token*(Token*,char[],size_t)",<empty>,,false,976,979,findsimplematch,,,1,"Token*(Token*,char[],size_t)"
111669153488,METHOD,lib/token.cpp:<global>,TYPE_DECL,"Token *Token::findsimplematch(Token * const startTok, const char pattern[], size_t pattern_len)
{
    return findsimplematchImpl(startTok, pattern, pattern_len);
}",1,1,lib/token.cpp,"Token.findsimplematch<duplicate>0:Token*(Token*,char[],size_t)",<empty>,,false,981,984,findsimplematch,,,1,"Token*(Token*,char[],size_t)"
111669153489,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static T *findsimplematchImpl(T * const startTok, const char pattern[], size_t pattern_len, const Token * const end)
{
    for (T* tok = startTok; tok && tok != end; tok = tok->next()) {
        if (Token::simpleMatch(tok, pattern, pattern_len))
            return tok;
    }
    return nullptr;
}",1,1,lib/token.cpp,"findsimplematchImpl:T(T*,char[],size_t,Token*)",<empty>,,false,987,994,findsimplematchImpl,,,1,"T(T*,char[],size_t,Token*)"
111669153490,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const Token *Token::findsimplematch(const Token * const startTok, const char pattern[], size_t pattern_len, const Token * const end)
{
    return findsimplematchImpl(startTok, pattern, pattern_len, end);
}",1,1,lib/token.cpp,"Token.findsimplematch<duplicate>0:Token*(Token*,char[],size_t,Token*)",<empty>,,false,996,999,findsimplematch,,,1,"Token*(Token*,char[],size_t,Token*)"
111669153491,METHOD,lib/token.cpp:<global>,TYPE_DECL,"Token *Token::findsimplematch(Token * const startTok, const char pattern[], size_t pattern_len, const Token * const end) {
    return findsimplematchImpl(startTok, pattern, pattern_len, end);
}",1,1,lib/token.cpp,"Token.findsimplematch:Token*(Token*,char[],size_t,Token*)",<empty>,,false,1001,1003,findsimplematch,,,1,"Token*(Token*,char[],size_t,Token*)"
111669153492,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static T *findmatchImpl(T * const startTok, const char pattern[], const nonneg int varId)
{
    for (T* tok = startTok; tok; tok = tok->next()) {
        if (Token::Match(tok, pattern, varId))
            return tok;
    }
    return nullptr;
}",1,72,lib/token.cpp,"findmatchImpl:T(T*,char[],int)",<empty>,,false,1006,1013,findmatchImpl,,,1,"T(T*,char[],int)"
111669153493,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const Token *Token::findmatch(const Token * const startTok, const char pattern[], const nonneg int varId)
{
    return findmatchImpl(startTok, pattern, varId);
}",1,88,lib/token.cpp,"Token.findmatch:Token*(Token*,char[],int)",<empty>,,false,1015,1018,findmatch,,,1,"Token*(Token*,char[],int)"
111669153494,METHOD,lib/token.cpp:<global>,TYPE_DECL,"Token *Token::findmatch(Token * const startTok, const char pattern[], const nonneg int varId) {
    return findmatchImpl(startTok, pattern, varId);
}",1,76,lib/token.cpp,"Token.findmatch<duplicate>0:Token*(Token*,char[],int)",<empty>,,false,1020,1022,findmatch,,,1,"Token*(Token*,char[],int)"
111669153495,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static T *findmatchImpl(T * const startTok, const char pattern[], const Token * const end, const nonneg int varId)
{
    for (T* tok = startTok; tok && tok != end; tok = tok->next()) {
        if (Token::Match(tok, pattern, varId))
            return tok;
    }
    return nullptr;
}",1,97,lib/token.cpp,"findmatchImpl:T(T*,char[],Token*,int)",<empty>,,false,1025,1032,findmatchImpl,,,1,"T(T*,char[],Token*,int)"
111669153496,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const Token *Token::findmatch(const Token * const startTok, const char pattern[], const Token * const end, const nonneg int varId)
{
    return findmatchImpl(startTok, pattern, end, varId);
}",1,113,lib/token.cpp,"Token.findmatch:Token*(Token*,char[],Token*,int)",<empty>,,false,1034,1037,findmatch,,,1,"Token*(Token*,char[],Token*,int)"
111669153497,METHOD,lib/token.cpp:<global>,TYPE_DECL,"Token *Token::findmatch(Token * const startTok, const char pattern[], const Token * const end, const nonneg int varId) {
    return findmatchImpl(startTok, pattern, end, varId);
}",1,101,lib/token.cpp,"Token.findmatch<duplicate>0:Token*(Token*,char[],Token*,int)",<empty>,,false,1039,1041,findmatch,,,1,"Token*(Token*,char[],Token*,int)"
111669153498,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::function(const Function *f)
{
    mImpl->mFunction = f;
    if (f) {
        if (f->isLambda())
            tokType(eLambda);
        else
            tokType(eFunction);
    } else if (mTokType == eFunction)
        tokType(eName);
}",1,1,lib/token.cpp,Token.function:void(Function*),<empty>,,false,1043,1053,function,,,1,void(Function*)
111669153499,METHOD,lib/token.cpp:<global>,TYPE_DECL,"Token* Token::insertToken(const std::string& tokenStr, const std::string& originalNameStr, const std::string& macroNameStr, bool prepend)
{
    Token *newToken;
    if (mStr.empty())
        newToken = this;
    else
        newToken = new Token(mTokensFrontBack);
    newToken->str(tokenStr);
    if (!originalNameStr.empty())
        newToken->originalName(originalNameStr);
    if (!macroNameStr.empty())
        newToken->setMacroName(macroNameStr);

    if (newToken != this) {
        newToken->mImpl->mLineNumber = mImpl->mLineNumber;
        newToken->mImpl->mFileIndex = mImpl->mFileIndex;
        newToken->mImpl->mProgressValue = mImpl->mProgressValue;

        if (prepend) {
            if (this->previous()) {
                newToken->previous(this->previous());
                newToken->previous()->next(newToken);
            } else {
                mTokensFrontBack.front = newToken;
            }
            this->previous(newToken);
            newToken->next(this);
       ...",1,1,lib/token.cpp,"Token.insertToken:Token*(std.string&,std.string&,std.string&,bool)",<empty>,,false,1055,1190,insertToken,,,1,"Token*(std.string&,std.string&,std.string&,bool)"
111669153500,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::eraseTokens(Token *begin, const Token *end)
{
    if (!begin || begin == end)
        return;

    while (begin->next() && begin->next() != end) {
        begin->deleteNext();
    }
}",1,1,lib/token.cpp,"Token.eraseTokens:void(Token*,Token*)",<empty>,,false,1192,1200,eraseTokens,,,1,"void(Token*,Token*)"
111669153501,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::createMutualLinks(Token *begin, Token *end)
{
    assert(begin != nullptr);
    assert(end != nullptr);
    assert(begin != end);
    begin->link(end);
    end->link(begin);
}",1,1,lib/token.cpp,"Token.createMutualLinks:void(Token*,Token*)",<empty>,,false,1202,1209,createMutualLinks,,,1,"void(Token*,Token*)"
111669153502,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::printOut() const
{
    printOut(std::cout, """");
}",1,1,lib/token.cpp,Token.printOut<const>:void(),<empty>,,false,1211,1214,printOut,,,1,void()
111669153503,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::printOut(std::ostream& out, const char *title) const
{
    if (title && title[0])
        out << ""\\n### "" << title << "" ###\\n"";
    out << stringifyList(stringifyOptions::forPrintOut(), nullptr, nullptr) << std::endl;
}",1,1,lib/token.cpp,"Token.printOut<const>:void(std.ostream&,char*)",<empty>,,false,1216,1221,printOut,,,1,"void(std.ostream&,char*)"
111669153504,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::printOut(std::ostream& out, bool xml, const char *title, const std::vector<std::string> &fileNames) const
{
    if (xml)
    {
        out << ""<file>"" << std::endl;
        out << ""<![CDATA["";
    }
    if (title && title[0])
        out << ""\\n### "" << title << "" ###\\n"";
    out << stringifyList(stringifyOptions::forPrintOut(), &fileNames, nullptr) << std::endl;
    if (xml)
    {
        out << ""]]>"" << std::endl;
        out << ""</file>"" << std::endl;
    }
}",1,1,lib/token.cpp,"Token.printOut<const>:void(std.ostream&,bool,char*,std.vector<std.string>&)",<empty>,,false,1223,1238,printOut,,,1,"void(std.ostream&,bool,char*,std.vector<std.string>&)"
111669153505,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::printLines(std::ostream& out, int lines) const
{
    const Token *end = this;
    while (end && end->linenr() < lines + linenr())
        end = end->next();
    out << stringifyList(stringifyOptions::forDebugExprId(), nullptr, end) << std::endl;
}",1,1,lib/token.cpp,"Token.printLines<const>:void(std.ostream&,int)",<empty>,,false,1241,1247,printLines,,,1,"void(std.ostream&,int)"
111669153506,METHOD,lib/token.cpp:<global>,TYPE_DECL,"std::string Token::stringify(const stringifyOptions& options) const
{
    std::string ret;
    if (options.attributes) {
        if (isUnsigned())
            ret += ""unsigned "";
        else if (isSigned())
            ret += ""signed "";
        if (isComplex())
            ret += ""_Complex "";
        if (isLong()) {
            if (!(mTokType == eString || mTokType == eChar))
                ret += ""long "";
        }
    }
    if (options.macro && isExpandedMacro())
        ret += '$';
    if (isName() && mStr.find(' ') != std::string::npos) {
        for (const char i : mStr) {
            if (i != ' ')
                ret += i;
        }
    } else if (mStr[0] != '\\""' || mStr.find('\\0') == std::string::npos)
        ret += mStr;
    else {
        for (const char i : mStr) {
            if (i == '\\0')
                ret += ""\\\\0"";
            else
                ret += i;
        }
    }
    if (options.varid && mImpl->mVarId != 0) {
        ret += '@';
        ret += (options.i...",1,1,lib/token.cpp,Token.stringify<const>:string(Token.stringifyOptions&),<empty>,,false,1249,1295,stringify,,,1,string(Token.stringifyOptions&)
111669153507,METHOD,lib/token.cpp:<global>,TYPE_DECL,"std::string Token::stringify(bool varid, bool attributes, bool macro) const
{
    stringifyOptions options;
    options.varid = varid;
    options.attributes = attributes;
    options.macro = macro;
    return stringify(options);
}",1,1,lib/token.cpp,"Token.stringify<const>:string(bool,bool,bool)",<empty>,,false,1297,1304,stringify,,,1,"string(bool,bool,bool)"
111669153508,METHOD,lib/token.cpp:<global>,TYPE_DECL,"std::string Token::stringifyList(const stringifyOptions& options, const std::vector<std::string>* fileNames, const Token* end) const
{
    if (this == end)
        return """";

    std::string ret;

    unsigned int lineNumber = mImpl->mLineNumber - (options.linenumbers ? 1U : 0U);
    // cppcheck-suppress shadowFunction - TODO: fix this
    unsigned int fileIndex = options.files ? ~0U : mImpl->mFileIndex;
    std::map<int, unsigned int> lineNumbers;
    for (const Token *tok = this; tok != end; tok = tok->next()) {
        assert(tok && ""end precedes token"");
        if (!tok)
            return ret;
        bool fileChange = false;
        if (tok->mImpl->mFileIndex != fileIndex) {
            if (fileIndex != ~0U) {
                lineNumbers[fileIndex] = tok->mImpl->mFileIndex;
            }

            fileIndex = tok->mImpl->mFileIndex;
            if (options.files) {
                ret += ""\\n\\n##file "";
                if (fileNames && fileNames->size() > tok->mImpl->mFile...",1,1,lib/token.cpp,"Token.stringifyList<const>:string(Token.stringifyOptions&,std.vector<std.string>*,Token*)",<empty>,,false,1306,1383,stringifyList,,,1,"string(Token.stringifyOptions&,std.vector<std.string>*,Token*)"
111669153509,METHOD,lib/token.cpp:<global>,TYPE_DECL,"std::string Token::stringifyList(bool varid, bool attributes, bool linenumbers, bool linebreaks, bool files, const std::vector<std::string>* fileNames, const Token* end) const
{
    stringifyOptions options;
    options.varid = varid;
    options.attributes = attributes;
    options.macro = attributes;
    options.linenumbers = linenumbers;
    options.linebreaks = linebreaks;
    options.files = files;
    return stringifyList(options, fileNames, end);
}",1,1,lib/token.cpp,"Token.stringifyList<const>:string(bool,bool,bool,bool,bool,std.vector<std.string>*,Token*)",<empty>,,false,1384,1394,stringifyList,,,1,"string(bool,bool,bool,bool,bool,std.vector<std.string>*,Token*)"
111669153510,METHOD,lib/token.cpp:<global>,TYPE_DECL,"std::string Token::stringifyList(const Token* end, bool attributes) const
{
    return stringifyList(false, attributes, false, false, false, nullptr, end);
}",1,1,lib/token.cpp,"Token.stringifyList<const>:string(Token*,bool)",<empty>,,false,1396,1399,stringifyList,,,1,"string(Token*,bool)"
111669153511,METHOD,lib/token.cpp:<global>,TYPE_DECL,"std::string Token::stringifyList(bool varid) const
{
    return stringifyList(varid, false, true, true, true, nullptr, nullptr);
}",1,1,lib/token.cpp,Token.stringifyList<const>:string(bool),<empty>,,false,1401,1404,stringifyList,,,1,string(bool)
111669153512,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::astParent(Token* tok)
{
    const Token* tok2 = tok;
    while (tok2) {
        if (this == tok2)
            throw InternalError(this, ""Internal error. AST cyclic dependency."");
        tok2 = tok2->astParent();
    }
    // Clear children to avoid nodes referenced twice
    if (this->astParent()) {
        Token* parent = this->astParent();
        if (parent->astOperand1() == this)
            parent->mImpl->mAstOperand1 = nullptr;
        if (parent->astOperand2() == this)
            parent->mImpl->mAstOperand2 = nullptr;
    }
    mImpl->mAstParent = tok;
}",1,1,lib/token.cpp,Token.astParent:void(Token*),<empty>,,false,1406,1423,astParent,,,1,void(Token*)
111669153513,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::astOperand1(Token *tok)
{
    if (mImpl->mAstOperand1)
        mImpl->mAstOperand1->astParent(nullptr);
    // goto parent operator
    if (tok) {
        tok = tok->astTop();
        tok->astParent(this);
    }
    mImpl->mAstOperand1 = tok;
}",1,1,lib/token.cpp,Token.astOperand1:void(Token*),<empty>,,false,1425,1435,astOperand1,,,1,void(Token*)
111669153514,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::astOperand2(Token *tok)
{
    if (mImpl->mAstOperand2)
        mImpl->mAstOperand2->astParent(nullptr);
    // goto parent operator
    if (tok) {
        tok = tok->astTop();
        tok->astParent(this);
    }
    mImpl->mAstOperand2 = tok;
}",1,1,lib/token.cpp,Token.astOperand2:void(Token*),<empty>,,false,1437,1447,astOperand2,,,1,void(Token*)
111669153515,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static const Token* goToLeftParenthesis(const Token* start, const Token* end)
{
    // move start to lpar in such expression: '(*it).x'
    int par = 0;
    for (const Token *tok = start; tok && tok != end; tok = tok->next()) {
        if (tok->str() == ""("")
            ++par;
        else if (tok->str() == "")"") {
            if (par == 0)
                start = tok->link();
            else
                --par;
        }
    }
    return start;
}",1,1,lib/token.cpp,"goToLeftParenthesis:Token*(Token*,Token*)",<empty>,,false,1449,1464,goToLeftParenthesis,,,1,"Token*(Token*,Token*)"
111669153516,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static const Token* goToRightParenthesis(const Token* start, const Token* end)
{
    // move end to rpar in such expression: '2>(x+1)'
    int par = 0;
    for (const Token *tok = end; tok && tok != start; tok = tok->previous()) {
        if (tok->str() == "")"")
            ++par;
        else if (tok->str() == ""("") {
            if (par == 0)
                end = tok->link();
            else
                --par;
        }
    }
    return end;
}",1,1,lib/token.cpp,"goToRightParenthesis:Token*(Token*,Token*)",<empty>,,false,1466,1481,goToRightParenthesis,,,1,"Token*(Token*,Token*)"
111669153517,METHOD,lib/token.cpp:<global>,TYPE_DECL,"std::pair<const Token *, const Token *> Token::findExpressionStartEndTokens() const
{
    const Token * const top = this;

    // find start node in AST tree
    const Token *start = top;
    while (start->astOperand1() && precedes(start->astOperand1(), start))
        start = start->astOperand1();

    // find end node in AST tree
    const Token *end = top;
    while (end->astOperand1() && (end->astOperand2() || end->isUnaryPreOp())) {
        // lambda..
        if (end->str() == ""["") {
            const Token *lambdaEnd = findLambdaEndToken(end);
            if (lambdaEnd) {
                end = lambdaEnd;
                break;
            }
        }
        if (Token::Match(end,""(|[|{"") &&
            !(Token::Match(end, ""( ::| %type%"") && !end->astOperand2())) {
            end = end->link();
            break;
        }
        end = end->astOperand2() ? end->astOperand2() : end->astOperand1();
    }

    // skip parentheses
    start = goToLeftParenthesis(start, end);
   ...",1,1,lib/token.cpp,"Token.findExpressionStartEndTokens<const>:pair<constToken*,constToken*>()",<empty>,,false,1483,1523,findExpressionStartEndTokens,,,1,"pair<const Token*,const Token*>()"
111669153518,METHOD,lib/token.cpp:<global>,TYPE_DECL,"bool Token::isCalculation() const
{
    if (!Token::Match(this, ""%cop%|++|--""))
        return false;

    if (Token::Match(this, ""*|&"")) {
        // dereference or address-of?
        if (!this->astOperand2())
            return false;

        if (this->astOperand2()->str() == ""["")
            return false;

        // type specification?
        std::stack<const Token *> operands;
        operands.push(this);
        while (!operands.empty()) {
            const Token *op = operands.top();
            operands.pop();
            if (op->isNumber() || op->varId() > 0)
                return true;
            if (op->astOperand1())
                operands.push(op->astOperand1());
            if (op->astOperand2())
                operands.push(op->astOperand2());
            else if (Token::Match(op, ""*|&""))
                return false;
        }

        // type specification => return false
        return false;
    }

    return true;
}",1,1,lib/token.cpp,Token.isCalculation<const>:bool(),<empty>,,false,1525,1559,isCalculation,,,1,bool()
111669153519,METHOD,lib/token.cpp:<global>,TYPE_DECL,"bool Token::isUnaryPreOp() const
{
    if (!astOperand1() || astOperand2())
        return false;
    if (this->tokType() != Token::eIncDecOp)
        return true;
    const Token *tokbefore = mPrevious;
    const Token *tokafter = mNext;
    for (int distance = 1; distance < 10 && tokbefore; distance++) {
        if (tokbefore == mImpl->mAstOperand1)
            return false;
        if (tokafter == mImpl->mAstOperand1)
            return true;
        tokbefore = tokbefore->mPrevious;
        tokafter  = tokafter->mPrevious;
    }
    return false; // <- guess
}",1,1,lib/token.cpp,Token.isUnaryPreOp<const>:bool(),<empty>,,false,1561,1578,isUnaryPreOp,,,1,bool()
111669153520,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static std::string stringFromTokenRange(const Token* start, const Token* end)
{
    std::string ret;
    if (end)
        end = end->next();
    for (const Token *tok = start; tok && tok != end; tok = tok->next()) {
        if (tok->isUnsigned())
            ret += ""unsigned "";
        if (tok->isLong() && !tok->isLiteral())
            ret += ""long "";
        if (tok->tokType() == Token::eString) {
            for (const unsigned char c: tok->str()) {
                if (c == '\\n')
                    ret += ""\\\\n"";
                else if (c == '\\r')
                    ret += ""\\\\r"";
                else if (c == '\\t')
                    ret += ""\\\\t"";
                else if (c >= ' ' && c <= 126)
                    ret += c;
                else {
                    char str[10];
                    sprintf(str, ""\\\\x%02x"", c);
                    ret += str;
                }
            }
        } else if (tok->originalName().empty() || tok->isUnsigned() || tok->isLong()) {
 ...",1,1,lib/token.cpp,"stringFromTokenRange:string(Token*,Token*)",<empty>,,false,1580,1614,stringFromTokenRange,,,1,"string(Token*,Token*)"
111669153521,METHOD,lib/token.cpp:<global>,TYPE_DECL,"std::string Token::expressionString() const
{
    const auto tokens = findExpressionStartEndTokens();
    return stringFromTokenRange(tokens.first, tokens.second);
}",1,1,lib/token.cpp,Token.expressionString<const>:string(),<empty>,,false,1616,1620,expressionString,,,1,string()
111669153522,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static void astStringXml(const Token *tok, nonneg int indent, std::ostream &out)
{
    const std::string strindent(indent, ' ');

    out << strindent << ""<token str=\\"""" << tok->str() << '\\""';
    if (tok->varId())
        out << "" varId=\\"""" << tok->varId() << '\\""';
    if (tok->variable())
        out << "" variable=\\"""" << tok->variable() << '\\""';
    if (tok->function())
        out << "" function=\\"""" << tok->function() << '\\""';
    if (!tok->values().empty())
        out << "" values=\\"""" << &tok->values() << '\\""';

    if (!tok->astOperand1() && !tok->astOperand2()) {
        out << ""/>"" << std::endl;
    }

    else {
        out << '>' << std::endl;
        if (tok->astOperand1())
            astStringXml(tok->astOperand1(), indent+2U, out);
        if (tok->astOperand2())
            astStringXml(tok->astOperand2(), indent+2U, out);
        out << strindent << ""</token>"" << std::endl;
    }
}",1,43,lib/token.cpp,"astStringXml:void(Token*,int,std.ostream&)",<empty>,,false,1622,1648,astStringXml,,,1,"void(Token*,int,std.ostream&)"
111669153523,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::printAst(bool verbose, bool xml, const std::vector<std::string> &fileNames, std::ostream &out) const
{
    if (!xml)
        out << ""\\n\\n##AST"" << std::endl;

    std::set<const Token *> printed;
    for (const Token *tok = this; tok; tok = tok->next()) {
        if (!tok->mImpl->mAstParent && tok->mImpl->mAstOperand1) {
            if (printed.find(tok) != printed.end())
                continue;
            printed.insert(tok);

            if (xml) {
                out << ""<ast scope=\\"""" << tok->scope() << ""\\"" fileIndex=\\"""" << tok->fileIndex() << ""\\"" linenr=\\"""" << tok->linenr()
                    << ""\\"" column=\\"""" << tok->column() << ""\\"">"" << std::endl;
                astStringXml(tok, 2U, out);
                out << ""</ast>"" << std::endl;
            } else if (verbose)
                out << ""["" << fileNames[tok->fileIndex()] << "":"" << tok->linenr() << ""]"" << std::endl << tok->astStringVerbose() << std::endl;
            else
                out << tok->astStrin...",1,1,lib/token.cpp,"Token.printAst<const>:void(bool,bool,std.vector<std.string>&,std.ostream&)",<empty>,,false,1650,1675,printAst,,,1,"void(bool,bool,std.vector<std.string>&,std.ostream&)"
111669153524,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static void indent(std::string &str, const nonneg int indent1, const nonneg int indent2)
{
    for (int i = 0; i < indent1; ++i)
        str += ' ';
    for (int i = indent1; i < indent2; i += 2)
        str += ""| "";
}",1,43,lib/token.cpp,"indent:void(std.string&,int,int)",<empty>,,false,1677,1683,indent,,,1,"void(std.string&,int,int)"
111669153525,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::astStringVerboseRecursive(std::string& ret, const nonneg int indent1, const nonneg int indent2) const
{
    if (isExpandedMacro())
        ret += '$';
    ret += mStr;
    if (mImpl->mValueType)
        ret += "" \\'"" + mImpl->mValueType->str() + '\\'';
    if (function()) {
        std::ostringstream ostr;
        ostr << std::hex << function();
        ret += "" f:"" + ostr.str();
    }
    ret += '\\n';

    if (mImpl->mAstOperand1) {
        int i1 = indent1, i2 = indent2 + 2;
        if (indent1 == indent2 && !mImpl->mAstOperand2)
            i1 += 2;
        indent(ret, indent1, indent2);
        ret += mImpl->mAstOperand2 ? ""|-"" : ""`-"";
        mImpl->mAstOperand1->astStringVerboseRecursive(ret, i1, i2);
    }
    if (mImpl->mAstOperand2) {
        int i1 = indent1, i2 = indent2 + 2;
        if (indent1 == indent2)
            i1 += 2;
        indent(ret, indent1, indent2);
        ret += ""`-"";
        mImpl->mAstOperand2->astStringVerboseRecursive(ret, i1, i2);
    }
}",1,62,lib/token.cpp,"Token.astStringVerboseRecursive<const>:void(std.string&,int,int)",<empty>,,false,1685,1715,astStringVerboseRecursive,,,1,"void(std.string&,int,int)"
111669153526,METHOD,lib/token.cpp:<global>,TYPE_DECL,"std::string Token::astStringVerbose() const
{
    std::string ret;
    astStringVerboseRecursive(ret);
    return ret;
}",1,1,lib/token.cpp,Token.astStringVerbose<const>:string(),<empty>,,false,1717,1722,astStringVerbose,,,1,string()
111669153527,METHOD,lib/token.cpp:<global>,TYPE_DECL,"std::string Token::astStringZ3() const
{
    if (!astOperand1())
        return str();
    if (!astOperand2())
        return ""("" + str() + "" "" + astOperand1()->astStringZ3() + "")"";
    return ""("" + str() + "" "" + astOperand1()->astStringZ3() + "" "" + astOperand2()->astStringZ3() + "")"";
}",1,1,lib/token.cpp,Token.astStringZ3<const>:string(),<empty>,,false,1725,1732,astStringZ3,,,1,string()
111669153528,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& value) {
                return value.valueKind == valueKind;
            }",75,13,lib/token.cpp,lib/token.cpp:<global>.Token.printValueFlow<const>.<lambda>1:bool(ValueFlow.Value&),<empty>,,false,1775,1777,<lambda>1,,,1,bool(ValueFlow.Value&)
111669153529,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::printValueFlow(bool xml, std::ostream &out) const
{
    std::string outs;

    // cppcheck-suppress shadowFunction
    int fileIndex = -1;
    int line = 0;
    if (xml)
        outs += ""  <valueflow>\\n"";
    else
        outs += ""\\n\\n##Value flow\\n"";
    for (const Token *tok = this; tok; tok = tok->next()) {
        // cppcheck-suppress shadowFunction - TODO: fix this
        const auto* const values = tok->mImpl->mValues;
        if (!values)
            continue;
        if (values->empty()) // Values might be removed by removeContradictions
            continue;
        if (xml) {
            outs += ""    <values id=\\"""";
            outs += id_string(values);
            outs +=  ""\\"">"";
            outs += '\\n';
        }
        else {
            if (fileIndex != tok->fileIndex()) {
                outs += ""File "";
                outs += tok->mTokensFrontBack.list.getFiles()[tok->fileIndex()];
                outs += '\\n';
                line = 0;
            }
...",1,1,lib/token.cpp,"Token.printValueFlow<const>:void(bool,std.ostream&)",<empty>,,false,1734,1912,printValueFlow,,,1,"void(bool,std.ostream&)"
111669153530,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
        return !v.isImpossible() && v.isIntValue() && v.intvalue <= val;
    }",60,5,lib/token.cpp,lib/token.cpp:<global>.Token.getValueLE<const>.<lambda>2:bool(ValueFlow.Value&),<empty>,,false,1918,1920,<lambda>2,,,1,bool(ValueFlow.Value&)
111669153531,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const ValueFlow::Value * Token::getValueLE(const MathLib::bigint val, const Settings &settings) const
{
    if (!mImpl->mValues)
        return nullptr;
    return ValueFlow::findValue(*mImpl->mValues, settings, [&](const ValueFlow::Value& v) {
        return !v.isImpossible() && v.isIntValue() && v.intvalue <= val;
    });
}",1,1,lib/token.cpp,"Token.getValueLE<const>:ValueFlow.Value*(MathLib.bigint,Settings&)",<empty>,,false,1914,1921,getValueLE,,,1,"ValueFlow.Value*(MathLib.bigint,Settings&)"
111669153532,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
        return !v.isImpossible() && v.isIntValue() && v.intvalue >= val;
    }",60,5,lib/token.cpp,lib/token.cpp:<global>.Token.getValueGE<const>.<lambda>3:bool(ValueFlow.Value&),<empty>,,false,1927,1929,<lambda>3,,,1,bool(ValueFlow.Value&)
111669153533,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const ValueFlow::Value * Token::getValueGE(const MathLib::bigint val, const Settings &settings) const
{
    if (!mImpl->mValues)
        return nullptr;
    return ValueFlow::findValue(*mImpl->mValues, settings, [&](const ValueFlow::Value& v) {
        return !v.isImpossible() && v.isIntValue() && v.intvalue >= val;
    });
}",1,1,lib/token.cpp,"Token.getValueGE<const>:ValueFlow.Value*(MathLib.bigint,Settings&)",<empty>,,false,1923,1930,getValueGE,,,1,"ValueFlow.Value*(MathLib.bigint,Settings&)"
111669153534,METHOD,<empty>,<empty>,"[=](const ValueFlow::Value& value) {
        return value.isIntValue() && !value.isImpossible() && value.intvalue != val;
    }",84,5,lib/token.cpp,lib/token.cpp:<global>.Token.getValueNE<const>.<lambda>4:bool(ValueFlow.Value&),<empty>,,false,1936,1938,<lambda>4,,,1,bool(ValueFlow.Value&)
111669153535,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const ValueFlow::Value * Token::getValueNE(MathLib::bigint val) const
{
    if (!mImpl->mValues)
        return nullptr;
    const auto it = std::find_if(mImpl->mValues->cbegin(), mImpl->mValues->cend(), [=](const ValueFlow::Value& value) {
        return value.isIntValue() && !value.isImpossible() && value.intvalue != val;
    });
    return it == mImpl->mValues->end() ? nullptr : &*it;
}",1,1,lib/token.cpp,Token.getValueNE<const>:ValueFlow.Value*(MathLib.bigint),<empty>,,false,1932,1940,getValueNE,,,1,ValueFlow.Value*(MathLib.bigint)
111669153536,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const ValueFlow::Value * Token::getInvalidValue(const Token *ftok, nonneg int argnr, const Settings &settings) const
{
    if (!mImpl->mValues)
        return nullptr;
    const ValueFlow::Value *ret = nullptr;
    for (auto it = mImpl->mValues->begin(); it != mImpl->mValues->end(); ++it) {
        if (it->isImpossible())
            continue;
        if ((it->isIntValue() && !settings.library.isIntArgValid(ftok, argnr, it->intvalue)) ||
            (it->isFloatValue() && !settings.library.isFloatArgValid(ftok, argnr, it->floatValue))) {
            if (!ret || ret->isInconclusive() || (ret->condition && !it->isInconclusive()))
                ret = &(*it);
            if (!ret->isInconclusive() && !ret->condition)
                break;
        }
    }
    if (ret) {
        if (ret->isInconclusive() && !settings.certainty.isEnabled(Certainty::inconclusive))
            return nullptr;
        if (ret->condition && !settings.severity.isEnabled(Severity::warning))
            return...",1,67,lib/token.cpp,"Token.getInvalidValue<const>:ValueFlow.Value*(Token*,int,Settings&)",<empty>,,false,1942,1965,getInvalidValue,,,1,"ValueFlow.Value*(Token*,int,Settings&)"
111669153537,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const Token *Token::getValueTokenMinStrSize(const Settings &settings, MathLib::bigint* path) const
{
    if (!mImpl->mValues)
        return nullptr;
    const Token *ret = nullptr;
    int minsize = INT_MAX;
    for (auto it = mImpl->mValues->begin(); it != mImpl->mValues->end(); ++it) {
        if (it->isTokValue() && it->tokvalue && it->tokvalue->tokType() == Token::eString) {
            const int size = getStrSize(it->tokvalue, settings);
            if (!ret || size < minsize) {
                minsize = size;
                ret = it->tokvalue;
                if (path)
                    *path = it->path;
            }
        }
    }
    return ret;
}",1,1,lib/token.cpp,"Token.getValueTokenMinStrSize<const>:Token*(Settings&,MathLib.bigint*)",<empty>,,false,1967,1985,getValueTokenMinStrSize,,,1,"Token*(Settings&,MathLib.bigint*)"
111669153538,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const Token *Token::getValueTokenMaxStrLength() const
{
    if (!mImpl->mValues)
        return nullptr;
    const Token *ret = nullptr;
    int maxlength = 0;
    for (auto it = mImpl->mValues->cbegin(); it != mImpl->mValues->end(); ++it) {
        if (it->isTokValue() && it->tokvalue && it->tokvalue->tokType() == Token::eString) {
            const int length = getStrLength(it->tokvalue);
            if (!ret || length > maxlength) {
                maxlength = length;
                ret = it->tokvalue;
            }
        }
    }
    return ret;
}",1,1,lib/token.cpp,Token.getValueTokenMaxStrLength<const>:Token*(),<empty>,,false,1987,2003,getValueTokenMaxStrLength,,,1,Token*()
111669153539,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static bool isAdjacent(const ValueFlow::Value& x, const ValueFlow::Value& y)
{
    if (x.bound != ValueFlow::Value::Bound::Point && x.bound == y.bound)
        return true;
    if (x.valueType == ValueFlow::Value::ValueType::FLOAT)
        return false;
    return std::abs(x.intvalue - y.intvalue) == 1;
}",1,1,lib/token.cpp,"isAdjacent:bool(ValueFlow.Value&,ValueFlow.Value&)",<empty>,,false,2005,2012,isAdjacent,,,1,"bool(ValueFlow.Value&,ValueFlow.Value&)"
111669153540,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static bool removePointValue(std::list<ValueFlow::Value>& values, std::list<ValueFlow::Value>::iterator& x)
{
    const bool isPoint = x->bound == ValueFlow::Value::Bound::Point;
    if (!isPoint)
        x->decreaseRange();
    else
        x = values.erase(x);
    return isPoint;
}",1,1,lib/token.cpp,"removePointValue:bool(std.list<ValueFlow.Value>&,std.list<ValueFlow.Value>.iterator&)",<empty>,,false,2014,2022,removePointValue,,,1,"bool(std.list<ValueFlow.Value>&,std.list<ValueFlow.Value>.iterator&)"
111669153541,METHOD,<empty>,<empty>,"[](const std::list<ValueFlow::Value>::const_iterator& x, const std::list<ValueFlow::Value>::const_iterator& y) {
                    return x->compareValue(*y, less{});
                }",32,17,lib/token.cpp,"lib/token.cpp:<global>.removeContradiction.<lambda>5:ANY(std.list<ValueFlow.Value>.const_iterator&,std.list<ValueFlow.Value>.const_iterator&)",<empty>,,false,2045,2047,<lambda>5,,,1,"ANY(std.list<ValueFlow.Value>.const_iterator&,std.list<ValueFlow.Value>.const_iterator&)"
111669153542,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static bool removeContradiction(std::list<ValueFlow::Value>& values)
{
    bool result = false;
    for (auto itx = values.begin(); itx != values.end(); ++itx) {
        if (itx->isNonValue())
            continue;

        auto ity = itx;
        ++ity;
        for (; ity != values.end(); ++ity) {
            if (ity->isNonValue())
                continue;
            if (*itx == *ity)
                continue;
            if (itx->valueType != ity->valueType)
                continue;
            if (itx->isImpossible() == ity->isImpossible())
                continue;
            if (itx->isSymbolicValue() && !ValueFlow::Value::sameToken(itx->tokvalue, ity->tokvalue))
                continue;
            if (!itx->equalValue(*ity)) {
                auto compare = [](const std::list<ValueFlow::Value>::const_iterator& x, const std::list<ValueFlow::Value>::const_iterator& y) {
                    return x->compareValue(*y, less{});
                };
                auto itMax = ...",1,1,lib/token.cpp,removeContradiction:bool(std.list<ValueFlow.Value>&),<empty>,,false,2024,2082,removeContradiction,,,1,bool(std.list<ValueFlow.Value>&)
111669153543,METHOD,<empty>,<empty>,"[](ValueIterator x, ValueIterator y) {
        return !isAdjacent(*x, *y);
    }",47,5,lib/token.cpp,"lib/token.cpp:<global>.removeAdjacentValues.<lambda>6:bool(ValueIterator,ValueIterator)",<empty>,,false,2092,2094,<lambda>6,,,1,"bool(ValueIterator,ValueIterator)"
111669153544,METHOD,<empty>,<empty>,"[&](ValueIterator y) {
        values.erase(y);
    }",52,5,lib/token.cpp,lib/token.cpp:<global>.removeAdjacentValues.<lambda>7:void(ValueIterator),<empty>,,false,2098,2100,<lambda>7,,,1,void(ValueIterator)
111669153545,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static ValueIterator removeAdjacentValues(std::list<ValueFlow::Value>& values, ValueIterator x, Iterator start, Iterator last)
{
    if (!isAdjacent(*x, **start))
        return std::next(x);
    auto it = std::adjacent_find(start, last, [](ValueIterator x, ValueIterator y) {
        return !isAdjacent(*x, *y);
    });
    if (it == last)
        it--;
    (*it)->bound = x->bound;
    std::for_each(std::move(start), std::move(it), [&](ValueIterator y) {
        values.erase(y);
    });
    return values.erase(x);
}",1,1,lib/token.cpp,"removeAdjacentValues:ValueIterator(std.list<ValueFlow.Value>&,ValueIterator,Iterator,Iterator)",<empty>,,false,2088,2102,removeAdjacentValues,,,1,"ValueIterator(std.list<ValueFlow.Value>&,ValueIterator,Iterator,Iterator)"
111669153546,METHOD,<empty>,<empty>,"[&values](ValueIterator xx, ValueIterator yy) {
            (void)values;
            assert(xx != values.end() && yy != values.end());
            return xx->compareValue(*yy, less{});
        }",55,9,lib/token.cpp,"lib/token.cpp:<global>.mergeAdjacent.<lambda>8:ANY(ValueIterator,ValueIterator)",<empty>,,false,2148,2152,<lambda>8,,,1,"ANY(ValueIterator,ValueIterator)"
111669153547,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static void mergeAdjacent(std::list<ValueFlow::Value>& values)
{
    for (auto x = values.begin(); x != values.end();) {
        if (x->isNonValue()) {
            x++;
            continue;
        }
        if (x->bound == ValueFlow::Value::Bound::Point) {
            x++;
            continue;
        }
        std::vector<ValueIterator> adjValues;
        for (auto y = values.begin(); y != values.end(); y++) {
            if (x == y)
                continue;
            if (y->isNonValue())
                continue;
            if (x->valueType != y->valueType)
                continue;
            if (x->valueKind != y->valueKind)
                continue;
            if (x->isSymbolicValue() && !ValueFlow::Value::sameToken(x->tokvalue, y->tokvalue))
                continue;
            if (x->bound != y->bound) {
                if (y->bound != ValueFlow::Value::Bound::Point && isAdjacent(*x, *y)) {
                    adjValues.clear();
                    break;
          ...",1,1,lib/token.cpp,mergeAdjacent:void(std.list<ValueFlow.Value>&),<empty>,,false,2104,2158,mergeAdjacent,,,1,void(std.list<ValueFlow.Value>&)
111669153548,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& y) {
            if (y.isNonValue())
                return false;
            if (&x == &y)
                return false;
            if (x.valueType != y.valueType)
                return false;
            if (x.valueKind != y.valueKind)
                return false;
            // TODO: Remove points covered in a lower or upper bound
            // TODO: Remove lower or upper bound already covered by a lower and upper bound
            if (!x.equalValue(y))
                return false;
            if (x.bound != y.bound)
                return false;
            return true;
        }",26,9,lib/token.cpp,lib/token.cpp:<global>.removeOverlaps.<lambda>9:bool(ValueFlow.Value&),<empty>,,false,2165,2181,<lambda>9,,,1,bool(ValueFlow.Value&)
111669153549,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static void removeOverlaps(std::list<ValueFlow::Value>& values)
{
    for (const ValueFlow::Value& x : values) {
        if (x.isNonValue())
            continue;
        values.remove_if([&](const ValueFlow::Value& y) {
            if (y.isNonValue())
                return false;
            if (&x == &y)
                return false;
            if (x.valueType != y.valueType)
                return false;
            if (x.valueKind != y.valueKind)
                return false;
            // TODO: Remove points covered in a lower or upper bound
            // TODO: Remove lower or upper bound already covered by a lower and upper bound
            if (!x.equalValue(y))
                return false;
            if (x.bound != y.bound)
                return false;
            return true;
        });
    }
    mergeAdjacent(values);
}",1,1,lib/token.cpp,removeOverlaps:void(std.list<ValueFlow.Value>&),<empty>,,false,2160,2184,removeOverlaps,,,1,void(std.list<ValueFlow.Value>&)
111669153550,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static void removeContradictions(std::list<ValueFlow::Value>& values)
{
    removeOverlaps(values);
    for (int i = 0; i < 4; i++) {
        if (!removeContradiction(values))
            return;
        removeOverlaps(values);
    }
}",1,1,lib/token.cpp,removeContradictions:void(std.list<ValueFlow.Value>&),<empty>,,false,2188,2196,removeContradictions,,,1,void(std.list<ValueFlow.Value>&)
111669153551,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static bool sameValueType(const ValueFlow::Value& x, const ValueFlow::Value& y)
{
    if (x.valueType != y.valueType)
        return false;
    // Symbolic are the same type if they share the same tokvalue
    if (x.isSymbolicValue())
        return x.tokvalue->exprId() == 0 || x.tokvalue->exprId() == y.tokvalue->exprId();
    return true;
}",1,1,lib/token.cpp,"sameValueType:bool(ValueFlow.Value&,ValueFlow.Value&)",<empty>,,false,2198,2206,sameValueType,,,1,"bool(ValueFlow.Value&,ValueFlow.Value&)"
111669153552,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& x) {
            return sameValueType(x, value);
        }",35,9,lib/token.cpp,lib/token.cpp:<global>.Token.addValue.<lambda>10:bool(ValueFlow.Value&),<empty>,,false,2212,2214,<lambda>10,,,1,bool(ValueFlow.Value&)
111669153553,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& x) {
        return x.isKnown() && sameValueType(x, value) && !x.equalValue(value);
    }",69,5,lib/token.cpp,lib/token.cpp:<global>.Token.addValue.<lambda>11:bool(ValueFlow.Value&),<empty>,,false,2219,2221,<lambda>11,,,1,bool(ValueFlow.Value&)
111669153554,METHOD,lib/token.cpp:<global>,TYPE_DECL,"bool Token::addValue(const ValueFlow::Value &value)
{
    if (value.isKnown() && mImpl->mValues) {
        // Clear all other values of the same type since value is known
        mImpl->mValues->remove_if([&](const ValueFlow::Value& x) {
            return sameValueType(x, value);
        });
    }

    // Don't add a value if its already known
    if (!value.isKnown() && mImpl->mValues &&
        std::any_of(mImpl->mValues->begin(), mImpl->mValues->end(), [&](const ValueFlow::Value& x) {
        return x.isKnown() && sameValueType(x, value) && !x.equalValue(value);
    }))
        return false;

    // assert(value.isKnown() || !mImpl->mValues || std::none_of(mImpl->mValues->begin(), mImpl->mValues->end(),
    // [&](const ValueFlow::Value& x) {
    //     return x.isKnown() && sameValueType(x, value);
    // }));

    if (mImpl->mValues) {
        // Don't handle more than 10 values for performance reasons
        // TODO: add setting?
        if (mImpl->mValues->size() >= 10U)
  ...",1,1,lib/token.cpp,Token.addValue:bool(ValueFlow.Value&),<empty>,,false,2208,2285,addValue,,,1,bool(ValueFlow.Value&)
111669153555,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::assignProgressValues(Token *tok)
{
    int total_count = 0;
    for (Token *tok2 = tok; tok2; tok2 = tok2->next())
        ++total_count;
    int count = 0;
    for (Token *tok2 = tok; tok2; tok2 = tok2->next())
        tok2->mImpl->mProgressValue = count++ *100 / total_count;
}",1,1,lib/token.cpp,Token.assignProgressValues:void(Token*),<empty>,,false,2287,2295,assignProgressValues,,,1,void(Token*)
111669153556,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::assignIndexes()
{
    // cppcheck-suppress shadowFunction - TODO: fix this
    int index = (mPrevious ? mPrevious->mImpl->mIndex : 0) + 1;
    for (Token *tok = this; tok; tok = tok->next())
        tok->mImpl->mIndex = index++;
}",1,1,lib/token.cpp,Token.assignIndexes:void(),<empty>,,false,2297,2303,assignIndexes,,,1,void()
111669153557,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::setValueType(ValueType *vt)
{
    if (vt != mImpl->mValueType) {
        delete mImpl->mValueType;
        mImpl->mValueType = vt;
    }
}",1,1,lib/token.cpp,Token.setValueType:void(ValueType*),<empty>,,false,2305,2311,setValueType,,,1,void(ValueType*)
111669153558,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const ValueType *Token::argumentType() const {
    const Token *top = this;
    while (top && !Token::Match(top->astParent(), "",|(""))
        top = top->astParent();
    return top ? top->mImpl->mValueType : nullptr;
}",1,1,lib/token.cpp,Token.argumentType<const>:ValueType*(),<empty>,,false,2313,2318,argumentType,,,1,ValueType*()
111669153559,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::type(const ::Type *t)
{
    mImpl->mType = t;
    if (t) {
        tokType(eType);
        isEnumType(mImpl->mType->isEnumType());
    } else if (mTokType == eType)
        tokType(eName);
}",1,1,lib/token.cpp,Token.type:void(Type*),<empty>,,false,2320,2328,type,,,1,void(Type*)
111669153560,METHOD,<empty>,<empty>,"[&](const Variable* var) {
            return var->type() == vars.front()->type();
        }",45,9,lib/token.cpp,lib/token.cpp:<global>.Token.typeOf.<lambda>12:bool(Variable*),<empty>,,false,2375,2377,<lambda>12,,,1,bool(Variable*)
111669153561,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const ::Type* Token::typeOf(const Token* tok, const Token** typeTok)
{
    if (!tok)
        return nullptr;
    if (typeTok != nullptr)
        *typeTok = tok;
    const Token* lhsVarTok{};
    if (tok->type())
        return tok->type();
    if (tok->variable())
        return tok->variable()->type();
    if (tok->function())
        return tok->function()->retType;
    if (Token::simpleMatch(tok, ""return"")) {
        // cppcheck-suppress shadowFunction - TODO: fix this
        const Scope *scope = tok->scope();
        if (!scope)
            return nullptr;
        // cppcheck-suppress shadowFunction - TODO: fix this
        const Function *function = scope->function;
        if (!function)
            return nullptr;
        return function->retType;
    }
    if (Token::Match(tok->previous(), ""%type%|= (|{""))
        return typeOf(tok->previous(), typeTok);
    if (Token::simpleMatch(tok, ""="") && (lhsVarTok = getLHSVariableToken(tok)) != tok->next())
        return Token::type...",1,1,lib/token.cpp,"Token.typeOf:Type*(Token*,Token**)",<empty>,,false,2330,2382,typeOf,,,1,"Type*(Token*,Token**)"
111669153562,METHOD,lib/token.cpp:<global>,TYPE_DECL,"std::pair<const Token*, const Token*> Token::typeDecl(const Token* tok, bool pointedToType)
{
    if (!tok)
        return {};
    if (tok->type())
        return {tok, tok->next()};
    if (tok->variable()) {
        const Variable *var = tok->variable();
        if (!var->typeStartToken() || !var->typeEndToken())
            return {};
        if (pointedToType && astIsSmartPointer(var->nameToken())) {
            const ValueType* vt = var->valueType();
            if (vt && vt->smartPointerTypeToken)
                return { vt->smartPointerTypeToken, vt->smartPointerTypeToken->linkAt(-1) };
        }
        if (pointedToType && astIsIterator(var->nameToken())) {
            const ValueType* vt = var->valueType();
            if (vt && vt->containerTypeToken)
                return { vt->containerTypeToken, vt->containerTypeToken->linkAt(-1) };
        }
        std::pair<const Token*, const Token*> result;
        if (Token::simpleMatch(var->typeStartToken(), ""auto"")) {
       ...",1,1,lib/token.cpp,"Token.typeDecl:pair<constToken*,constToken*>(Token*,bool)",<empty>,,false,2384,2482,typeDecl,,,1,"pair<const Token*,const Token*>(Token*,bool)"
111669153563,METHOD,lib/token.cpp:<global>,TYPE_DECL,"std::string Token::typeStr(const Token* tok)
{
    if (tok->valueType()) {
        const ValueType * vt = tok->valueType();
        std::string ret = vt->str();
        if (!ret.empty())
            return ret;
    }
    std::pair<const Token*, const Token*> r = Token::typeDecl(tok);
    if (!r.first || !r.second)
        return """";
    return r.first->stringifyList(r.second, false);
}",1,1,lib/token.cpp,Token.typeStr:string(Token*),<empty>,,false,2483,2495,typeStr,,,1,string(Token*)
111669153564,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void Token::scopeInfo(std::shared_ptr<ScopeInfo2> newScopeInfo)
{
    mImpl->mScopeInfo = std::move(newScopeInfo);
}",1,1,lib/token.cpp,Token.scopeInfo:void(std.shared_ptr<ScopeInfo2>),<empty>,,false,2497,2500,scopeInfo,,,1,void(std.shared_ptr<ScopeInfo2>)
111669153565,METHOD,lib/token.cpp:<global>,TYPE_DECL,"std::shared_ptr<ScopeInfo2> Token::scopeInfo() const
{
    return mImpl->mScopeInfo;
}",1,1,lib/token.cpp,Token.scopeInfo<const>:shared_ptr<ScopeInfo2>(),<empty>,,false,2501,2504,scopeInfo,,,1,shared_ptr<ScopeInfo2>()
111669153566,METHOD,lib/token.cpp:<global>,TYPE_DECL,"bool Token::hasKnownIntValue() const
{
    if (!mImpl->mValues)
        return false;
    if (mImpl->mValues->empty())
        return false;
    const ValueFlow::Value& value = mImpl->mValues->front();
    return value.isIntValue() && value.isKnown();
}",1,1,lib/token.cpp,Token.hasKnownIntValue<const>:bool(),<empty>,,false,2507,2515,hasKnownIntValue,,,1,bool()
111669153567,METHOD,lib/token.cpp:<global>,TYPE_DECL,"bool Token::hasKnownValue() const
{
    return mImpl->mValues && std::any_of(mImpl->mValues->begin(), mImpl->mValues->end(), std::mem_fn(&ValueFlow::Value::isKnown));
}",1,1,lib/token.cpp,Token.hasKnownValue<const>:bool(),<empty>,,false,2517,2520,hasKnownValue,,,1,bool()
111669153568,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& value) {
        return value.isKnown() && value.valueType == t;
    }",72,5,lib/token.cpp,lib/token.cpp:<global>.Token.hasKnownValue<const>.<lambda>13:bool(ValueFlow.Value&),<empty>,,false,2525,2527,<lambda>13,,,1,bool(ValueFlow.Value&)
111669153569,METHOD,lib/token.cpp:<global>,TYPE_DECL,"bool Token::hasKnownValue(ValueFlow::Value::ValueType t) const
{
    return mImpl->mValues &&
           std::any_of(mImpl->mValues->begin(), mImpl->mValues->end(), [&](const ValueFlow::Value& value) {
        return value.isKnown() && value.valueType == t;
    });
}",1,1,lib/token.cpp,Token.hasKnownValue<const>:bool(ValueFlow.Value.ValueType),<empty>,,false,2522,2528,hasKnownValue,,,1,bool(ValueFlow.Value.ValueType)
111669153570,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& value) {
        return value.isKnown() && value.isSymbolicValue() && value.tokvalue &&
        value.tokvalue->exprId() == tok->exprId();
    }",72,5,lib/token.cpp,lib/token.cpp:<global>.Token.hasKnownSymbolicValue<const>.<lambda>14:bool(ValueFlow.Value&),<empty>,,false,2535,2538,<lambda>14,,,1,bool(ValueFlow.Value&)
111669153571,METHOD,lib/token.cpp:<global>,TYPE_DECL,"bool Token::hasKnownSymbolicValue(const Token* tok) const
{
    if (tok->exprId() == 0)
        return false;
    return mImpl->mValues &&
           std::any_of(mImpl->mValues->begin(), mImpl->mValues->end(), [&](const ValueFlow::Value& value) {
        return value.isKnown() && value.isSymbolicValue() && value.tokvalue &&
        value.tokvalue->exprId() == tok->exprId();
    });
}",1,1,lib/token.cpp,Token.hasKnownSymbolicValue<const>:bool(Token*),<empty>,,false,2530,2539,hasKnownSymbolicValue,,,1,bool(Token*)
111669153572,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& value) {
        return value.isKnown() && value.valueType == t;
    }",76,5,lib/token.cpp,lib/token.cpp:<global>.Token.getKnownValue<const>.<lambda>15:bool(ValueFlow.Value&),<empty>,,false,2554,2556,<lambda>15,,,1,bool(ValueFlow.Value&)
111669153573,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const ValueFlow::Value* Token::getKnownValue(ValueFlow::Value::ValueType t) const
{
    if (!mImpl->mValues)
        return nullptr;
    if (mImpl->mValues->empty())
        return nullptr;
    // known INT values are always the first entry
    if (t == ValueFlow::Value::ValueType::INT) {
        const auto& v = mImpl->mValues->front();
        if (!v.isKnown() || !v.isIntValue())
            return nullptr;
        return &v;
    }
    auto it = std::find_if(mImpl->mValues->begin(), mImpl->mValues->end(), [&](const ValueFlow::Value& value) {
        return value.isKnown() && value.valueType == t;
    });
    return it == mImpl->mValues->end() ? nullptr : &*it;
}",1,1,lib/token.cpp,Token.getKnownValue<const>:ValueFlow.Value*(ValueFlow.Value.ValueType),<empty>,,false,2541,2558,getKnownValue,,,1,ValueFlow.Value*(ValueFlow.Value.ValueType)
111669153574,METHOD,<empty>,<empty>,"[=](const ValueFlow::Value& value) {
        return value.isIntValue() && !value.isImpossible() && value.intvalue == val;
    }",82,5,lib/token.cpp,lib/token.cpp:<global>.Token.getValue<const>.<lambda>16:bool(ValueFlow.Value&),<empty>,,false,2564,2566,<lambda>16,,,1,bool(ValueFlow.Value&)
111669153575,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const ValueFlow::Value* Token::getValue(const MathLib::bigint val) const
{
    if (!mImpl->mValues)
        return nullptr;
    const auto it = std::find_if(mImpl->mValues->begin(), mImpl->mValues->end(), [=](const ValueFlow::Value& value) {
        return value.isIntValue() && !value.isImpossible() && value.intvalue == val;
    });
    return it == mImpl->mValues->end() ? nullptr : &*it;
}",1,1,lib/token.cpp,Token.getValue<const>:ValueFlow.Value*(MathLib.bigint),<empty>,,false,2560,2568,getValue,,,1,ValueFlow.Value*(MathLib.bigint)
111669153576,METHOD,lib/token.cpp:<global>,TYPE_DECL,"static const ValueFlow::Value* getCompareValue(const std::list<ValueFlow::Value>& values,
                                               bool condition,
                                               MathLib::bigint path,
                                               Compare compare)
{
    const ValueFlow::Value* ret = nullptr;
    for (const ValueFlow::Value& value : values) {
        if (!value.isIntValue())
            continue;
        if (value.isImpossible())
            continue;
        if (path > -0 && value.path != 0 && value.path != path)
            continue;
        if ((!ret || compare(value.intvalue, ret->intvalue)) && ((value.condition != nullptr) == condition))
            ret = &value;
    }
    return ret;
}",1,1,lib/token.cpp,"getCompareValue:Value(std.list<ValueFlow.Value>&,bool,MathLib.bigint,Compare)",<empty>,,false,2571,2588,getCompareValue,,,1,"Value(std.list<ValueFlow.Value>&,bool,MathLib.bigint,Compare)"
111669153577,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const ValueFlow::Value* Token::getMaxValue(bool condition, MathLib::bigint path) const
{
    if (!mImpl->mValues)
        return nullptr;
    return getCompareValue(*mImpl->mValues, condition, path, std::greater<MathLib::bigint>{});
}",1,1,lib/token.cpp,"Token.getMaxValue<const>:ValueFlow.Value*(bool,MathLib.bigint)",<empty>,,false,2590,2595,getMaxValue,,,1,"ValueFlow.Value*(bool,MathLib.bigint)"
111669153578,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const ValueFlow::Value* Token::getMinValue(bool condition, MathLib::bigint path) const
{
    if (!mImpl->mValues)
        return nullptr;
    return getCompareValue(*mImpl->mValues, condition, path, std::less<MathLib::bigint>{});
}",1,1,lib/token.cpp,"Token.getMinValue<const>:ValueFlow.Value*(bool,MathLib.bigint)",<empty>,,false,2597,2602,getMinValue,,,1,"ValueFlow.Value*(bool,MathLib.bigint)"
111669153579,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& value) {
        return value.isMovedValue() && !value.isImpossible() &&
        value.moveKind != ValueFlow::Value::MoveKind::NonMovedVariable;
    }",82,5,lib/token.cpp,lib/token.cpp:<global>.Token.getMovedValue<const>.<lambda>17:bool(ValueFlow.Value&),<empty>,,false,2608,2611,<lambda>17,,,1,bool(ValueFlow.Value&)
111669153580,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const ValueFlow::Value* Token::getMovedValue() const
{
    if (!mImpl->mValues)
        return nullptr;
    const auto it = std::find_if(mImpl->mValues->begin(), mImpl->mValues->end(), [](const ValueFlow::Value& value) {
        return value.isMovedValue() && !value.isImpossible() &&
        value.moveKind != ValueFlow::Value::MoveKind::NonMovedVariable;
    });
    return it == mImpl->mValues->end() ? nullptr : &*it;
}",1,1,lib/token.cpp,Token.getMovedValue<const>:ValueFlow.Value*(),<empty>,,false,2604,2613,getMovedValue,,,1,ValueFlow.Value*()
111669153581,METHOD,<empty>,<empty>,"[=](const ValueFlow::Value& value) {
        return value.isContainerSizeValue() && !value.isImpossible() && value.intvalue == val;
    }",82,5,lib/token.cpp,lib/token.cpp:<global>.Token.getContainerSizeValue<const>.<lambda>18:bool(ValueFlow.Value&),<empty>,,false,2620,2622,<lambda>18,,,1,bool(ValueFlow.Value&)
111669153582,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const ValueFlow::Value* Token::getContainerSizeValue(const MathLib::bigint val) const
{
    if (!mImpl->mValues)
        return nullptr;
    const auto it = std::find_if(mImpl->mValues->begin(), mImpl->mValues->end(), [=](const ValueFlow::Value& value) {
        return value.isContainerSizeValue() && !value.isImpossible() && value.intvalue == val;
    });
    return it == mImpl->mValues->end() ? nullptr : &*it;
}",1,1,lib/token.cpp,Token.getContainerSizeValue<const>:ValueFlow.Value*(MathLib.bigint),<empty>,,false,2616,2624,getContainerSizeValue,,,1,ValueFlow.Value*(MathLib.bigint)
111669153583,METHOD,lib/token.cpp:<global>,TYPE_DECL,"TokenImpl::~TokenImpl()
{
    delete mMacroName;
    delete mOriginalName;
    delete mValueType;
    delete mValues;

    if (mTemplateSimplifierPointers) {
        for (auto *templateSimplifierPointer : *mTemplateSimplifierPointers) {
            templateSimplifierPointer->token(nullptr);
        }
    }
    delete mTemplateSimplifierPointers;

    while (mCppcheckAttributes) {
        CppcheckAttributes *c = mCppcheckAttributes;
        mCppcheckAttributes = mCppcheckAttributes->next;
        delete c;
    }
}",1,1,lib/token.cpp,TokenImpl.~TokenImpl:ANY(),<empty>,,false,2626,2645,~TokenImpl,,,1,ANY()
111669153584,METHOD,lib/token.cpp:<global>,TYPE_DECL,"void TokenImpl::setCppcheckAttribute(TokenImpl::CppcheckAttributes::Type type, MathLib::bigint value)
{
    CppcheckAttributes *attr = mCppcheckAttributes;
    while (attr && attr->type != type)
        attr = attr->next;
    if (attr)
        attr->value = value;
    else {
        attr = new CppcheckAttributes;
        attr->type = type;
        attr->value = value;
        attr->next = mCppcheckAttributes;
        mCppcheckAttributes = attr;
    }
}",1,1,lib/token.cpp,"TokenImpl.setCppcheckAttribute:void(TokenImpl.CppcheckAttributes.Type,MathLib.bigint)",<empty>,,false,2647,2661,setCppcheckAttribute,,,1,"void(TokenImpl.CppcheckAttributes.Type,MathLib.bigint)"
111669153585,METHOD,lib/token.cpp:<global>,TYPE_DECL,"bool TokenImpl::getCppcheckAttribute(TokenImpl::CppcheckAttributes::Type type, MathLib::bigint &value) const
{
    CppcheckAttributes *attr = mCppcheckAttributes;
    while (attr && attr->type != type)
        attr = attr->next;
    if (attr)
        value = attr->value;
    return attr != nullptr;
}",1,1,lib/token.cpp,"TokenImpl.getCppcheckAttribute<const>:bool(TokenImpl.CppcheckAttributes.Type,MathLib.bigint&)",<empty>,,false,2663,2671,getCppcheckAttribute,,,1,"bool(TokenImpl.CppcheckAttributes.Type,MathLib.bigint&)"
111669153586,METHOD,lib/token.cpp:<global>,TYPE_DECL,"Token* findTypeEnd(Token* tok)
{
    while (Token::Match(tok, ""%name%|.|::|*|&|&&|<|(|template|decltype|sizeof"")) {
        if (Token::Match(tok, ""(|<""))
            tok = tok->link();
        if (!tok)
            return nullptr;
        tok = tok->next();
    }
    return tok;
}",1,1,lib/token.cpp,findTypeEnd:Token*(Token*),<empty>,,false,2673,2683,findTypeEnd,,,1,Token*(Token*)
111669153587,METHOD,lib/token.cpp:<global>,TYPE_DECL,"Token* findLambdaEndScope(Token* tok)
{
    if (!Token::simpleMatch(tok, ""[""))
        return nullptr;
    tok = tok->link();
    if (!Token::Match(tok, ""] (|{""))
        return nullptr;
    tok = tok->linkAt(1);
    if (Token::simpleMatch(tok, ""}""))
        return tok;
    if (Token::simpleMatch(tok, "") {""))
        return tok->linkAt(1);
    if (!Token::simpleMatch(tok, "")""))
        return nullptr;
    tok = tok->next();
    while (Token::Match(tok, ""mutable|constexpr|consteval|noexcept|."")) {
        if (Token::simpleMatch(tok, ""noexcept (""))
            tok = tok->linkAt(1);
        if (Token::simpleMatch(tok, ""."")) {
            tok = findTypeEnd(tok);
            break;
        }
        tok = tok->next();
    }
    if (Token::simpleMatch(tok, ""{""))
        return tok->link();
    return nullptr;
}",1,1,lib/token.cpp,findLambdaEndScope:Token*(Token*),<empty>,,false,2685,2712,findLambdaEndScope,,,1,Token*(Token*)
111669153588,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const Token* findLambdaEndScope(const Token* tok) {
    return findLambdaEndScope(const_cast<Token*>(tok));
}",1,1,lib/token.cpp,findLambdaEndScope<duplicate>0:Token*(Token*),<empty>,,false,2713,2715,findLambdaEndScope,,,1,Token*(Token*)
111669153589,METHOD,lib/token.cpp:<global>,TYPE_DECL,"const std::string& Token::fileName() const {
    return mTokensFrontBack.list.getFiles()[mImpl->mFileIndex];
}",1,1,lib/token.cpp,Token.fileName<const>:ANY(),<empty>,,false,2717,2719,fileName,,,1,ANY()
111669153590,METHOD,lib/token.h:<global>,TYPE_DECL,<global>,1,1,lib/token.h,lib/token.h:<global>,<empty>,,false,1,1598,<global>,,,1,
111669153591,METHOD,<empty>,<empty>,<empty>,5,,lib/token.h,TokenImpl.CppcheckAttributes.<clinit>,<empty>,,false,120,,<clinit>,,,5,
111669153592,METHOD,VarIdScopeInfo,TYPE_DECL,VarIdScopeInfo() = default;,9,35,lib/tokenize.cpp,VarIdScopeInfo.VarIdScopeInfo:ANY(),<empty>,,false,69,69,VarIdScopeInfo,,,1,ANY()
111669153593,METHOD,VarIdScopeInfo,TYPE_DECL,"VarIdScopeInfo(bool isExecutable, bool isStructInit, bool isEnum, nonneg int startVarid)
            : isExecutable(isExecutable), isStructInit(isStructInit), isEnum(isEnum), startVarid(startVarid) {}",9,74,lib/tokenize.cpp,"VarIdScopeInfo.VarIdScopeInfo:ANY(bool,bool,bool,int)",<empty>,,false,70,71,VarIdScopeInfo,,,2,"VarIdScopeInfo.VarIdScopeInfo:ANY(bool,bool,bool,int)(bool,bool,bool,int)"
111669153594,METHOD,<empty>,<empty>,<empty>,5,,lib/tokenize.cpp,VarIdScopeInfo.<clinit>,<empty>,,false,68,,<clinit>,,,7,
111669153595,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static bool isEnumStart(const Token* tok)
{
    if (!Token::simpleMatch(tok, ""{""))
        return false;
    tok = tok->previous();
    while (tok && (!tok->isKeyword() || Token::isStandardType(tok->str())) && Token::Match(tok, ""%name%|::|:""))
        tok = tok->previous();
    if (Token::simpleMatch(tok, ""class""))
        tok = tok->previous();
    return Token::simpleMatch(tok, ""enum"");
}",1,1,lib/tokenize.cpp,isEnumStart:bool(Token*),<empty>,,false,81,91,isEnumStart,,,1,bool(Token*)
111669153596,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,<global>,1,78,lib/tokenize.cpp,lib/tokenize.cpp:<global>,<empty>,,false,1,10941,<global>,,,1,
111669153597,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static void skipEnumBody(T *&tok)
{
    T *defStart = tok;
    while (Token::Match(defStart, ""%name%|::|:""))
        defStart = defStart->next();
    if (defStart && defStart->str() == ""{"")
        tok = defStart->link()->next();
}",1,1,lib/tokenize.cpp,skipEnumBody:void(T*&),<empty>,,false,94,101,skipEnumBody,,,1,void(T*&)
111669153598,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static bool isClassStructUnionEnumStart(const Token * tok)
{
    if (!Token::Match(tok->previous(), ""class|struct|union|enum|%name%|>|>> {""))
        return false;
    const Token * tok2 = tok->previous();
    while (tok2 && !Token::Match(tok2, ""class|struct|union|enum|{|}|;""))
        tok2 = tok2->previous();
    return Token::Match(tok2, ""class|struct|union|enum"");
}",1,1,lib/tokenize.cpp,isClassStructUnionEnumStart:bool(Token*),<empty>,,false,106,114,isClassStructUnionEnumStart,,,1,bool(Token*)
111669153599,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"Tokenizer::Tokenizer(const Settings &settings, ErrorLogger &errorLogger) :
    list(&settings),
    mSettings(settings),
    mErrorLogger(errorLogger),
    mTemplateSimplifier(new TemplateSimplifier(*this))
{}",1,2,lib/tokenize.cpp,"Tokenizer.Tokenizer:ANY(Settings&,ErrorLogger&)",<empty>,,false,118,123,Tokenizer,,,1,"Tokenizer.Tokenizer:ANY(Settings&,ErrorLogger&)(Settings&,ErrorLogger&)"
111669153600,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"Tokenizer::~Tokenizer()
{
    delete mSymbolDatabase;
    delete mTemplateSimplifier;
}",1,1,lib/tokenize.cpp,Tokenizer.~Tokenizer:ANY(),<empty>,,false,125,129,~Tokenizer,,,1,ANY()
111669153601,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"int Tokenizer::sizeOfType(const std::string& type) const
{
    const auto it = utils::as_const(mTypeSize).find(type);
    if (it == mTypeSize.end()) {
        const Library::PodType* podtype = mSettings.library.podtype(type);
        if (!podtype)
            return 0;

        return podtype->size;
    }
    return it->second;
}",8,1,lib/tokenize.cpp,Tokenizer.sizeOfType<const>:int(std.string&),<empty>,,false,136,147,sizeOfType,,,1,int(std.string&)
111669153602,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"int Tokenizer::sizeOfType(const Token *type) const
{
    if (!type || type->str().empty())
        return 0;

    if (type->tokType() == Token::eString)
        return Token::getStrLength(type) + 1U;

    const auto it = utils::as_const(mTypeSize).find(type->str());
    if (it == mTypeSize.end()) {
        const Library::PodType* podtype = mSettings.library.podtype(type->str());
        if (!podtype)
            return 0;

        return podtype->size;
    }
    if (type->isLong()) {
        if (type->str() == ""double"")
            return mSettings.platform.sizeof_long_double;
        if (type->str() == ""long"")
            return mSettings.platform.sizeof_long_long;
    }

    return it->second;
}",8,1,lib/tokenize.cpp,Tokenizer.sizeOfType<const>:int(Token*),<empty>,,false,149,173,sizeOfType,,,1,int(Token*)
111669153603,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"bool Tokenizer::duplicateTypedef(Token *&tokPtr, const Token *name, const Token *typeDef) const
{
    // check for an end of definition
    Token * tok = tokPtr;
    if (tok && Token::Match(tok->next(), "";|,|[|=|)|>|(|{"")) {
        Token * end = tok->next();

        if (end->str() == ""["") {
            if (!end->link())
                syntaxError(end); // invalid code
            end = end->link()->next();
        } else if (end->str() == "","") {
            // check for derived class
            if (Token::Match(tok->previous(), ""public|private|protected""))
                return false;

            // find end of definition
            while (end && end->next() && !Token::Match(end->next(), "";|)|>"")) {
                if (end->strAt(1) == ""("")
                    end = end->linkAt(1);

                end = (end)?end->next():nullptr;
            }
            if (end)
                end = end->next();
        } else if (end->str() == ""("") {
            if (startsWith(tok->strAt...",1,1,lib/tokenize.cpp,"Tokenizer.duplicateTypedef<const>:bool(Token*&,Token*,Token*)",<empty>,,false,177,293,duplicateTypedef,,,1,"bool(Token*&,Token*,Token*)"
111669153604,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::unsupportedTypedef(const Token *tok) const
{
    if (!mSettings.debugwarnings)
        return;

    std::ostringstream str;
    const Token *tok1 = tok;
    int level = 0;
    while (tok) {
        if (level == 0 && tok->str() == "";"")
            break;
        if (tok->str() == ""{"")
            ++level;
        else if (tok->str() == ""}"") {
            if (level == 0)
                break;
            --level;
        }

        if (tok != tok1)
            str << "" "";
        str << tok->str();
        tok = tok->next();
    }
    if (tok)
        str << "" ;"";

    reportError(tok1, Severity::debug, ""simplifyTypedef"",
                ""Failed to parse \\'"" + str.str() + ""\\'. The checking continues anyway."");
}",1,1,lib/tokenize.cpp,Tokenizer.unsupportedTypedef<const>:void(Token*),<empty>,,false,295,324,unsupportedTypedef,,,1,void(Token*)
111669153605,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"Token * Tokenizer::deleteInvalidTypedef(Token *typeDef)
{
    Token *tok = nullptr;

    // remove typedef but leave ;
    while (typeDef->next()) {
        if (typeDef->strAt(1) == "";"") {
            typeDef->deleteNext();
            break;
        }
        if (typeDef->strAt(1) == ""{"")
            Token::eraseTokens(typeDef, typeDef->linkAt(1));
        else if (typeDef->strAt(1) == ""}"")
            break;
        typeDef->deleteNext();
    }

    if (typeDef != list.front()) {
        tok = typeDef->previous();
        tok->deleteNext();
    } else {
        list.front()->deleteThis();
        tok = list.front();
    }

    return tok;
}",1,1,lib/tokenize.cpp,Tokenizer.deleteInvalidTypedef:Token*(Token*),<empty>,,false,326,352,deleteInvalidTypedef,,,1,Token*(Token*)
111669153606,METHOD,<empty>,<empty>,<empty>,5,,lib/tokenize.cpp,Space.<clinit>,<empty>,,false,355,,<clinit>,,,6,
111669153607,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static Token *splitDefinitionFromTypedef(Token *tok, nonneg int *unnamedCount)
{
    std::string name;
    std::set<std::string> qualifiers;

    while (Token::Match(tok->next(), ""const|volatile"")) {
        qualifiers.insert(tok->strAt(1));
        tok->deleteNext();
    }

    // skip ""class|struct|union|enum""
    Token *tok1 = tok->tokAt(2);

    const bool hasName = Token::Match(tok1, ""%name%"");

    // skip name
    if (hasName) {
        name = tok1->str();
        tok1 = tok1->next();
    }

    // skip base classes if present
    if (tok1->str() == "":"") {
        tok1 = tok1->next();
        while (tok1 && tok1->str() != ""{"")
            tok1 = tok1->next();
        if (!tok1)
            return nullptr;
    }

    // skip to end
    tok1 = tok1->link();

    if (!hasName) { // unnamed
        if (tok1->next()) {
            // use typedef name if available
            if (Token::Match(tok1->next(), ""%type%""))
                name = tok1->strAt(1);
            else // create...",1,53,lib/tokenize.cpp,"splitDefinitionFromTypedef:Token*(Token*,int*)",<empty>,,false,364,431,splitDefinitionFromTypedef,,,1,"Token*(Token*,int*)"
111669153608,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"const Token *Tokenizer::processFunc(const Token *tok2, bool inOperator) const
{
    if (tok2->next() && tok2->strAt(1) != "")"" &&
        tok2->strAt(1) != "","") {
        // skip over tokens for some types of canonicalization
        if (Token::Match(tok2->next(), ""( * %type% ) (""))
            tok2 = tok2->linkAt(5);
        else if (Token::Match(tok2->next(), ""* ( * %type% ) (""))
            tok2 = tok2->linkAt(6);
        else if (Token::Match(tok2->next(), ""* ( * %type% ) ;""))
            tok2 = tok2->tokAt(5);
        else if (Token::Match(tok2->next(), ""* ( %type% ["") &&
                 Token::Match(tok2->linkAt(4), ""] ) ;|=""))
            tok2 = tok2->linkAt(4)->next();
        else if (Token::Match(tok2->next(), ""* ( * %type% (""))
            tok2 = tok2->linkAt(5)->next();
        else if (Token::simpleMatch(tok2->next(), ""* ["") &&
                 Token::simpleMatch(tok2->linkAt(2), ""] ;""))
            tok2 = tok2->next();
        else {
            if (tok2->strAt(1) == ""...",1,1,lib/tokenize.cpp,"Tokenizer.processFunc<const>:Token*(Token*,bool)",<empty>,,false,438,499,processFunc,,,1,"Token*(Token*,bool)"
111669153609,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"Token *Tokenizer::processFunc(Token *tok2, bool inOperator)
{
    return const_cast<Token*>(processFunc(const_cast<const Token*>(tok2), inOperator));
}",1,1,lib/tokenize.cpp,"Tokenizer.processFunc:Token*(Token*,bool)",<empty>,,false,501,504,processFunc,,,1,"Token*(Token*,bool)"
111669153610,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyUsingToTypedef()
{
    if (!isCPP() || mSettings.standards.cpp < Standards::CPP11)
        return;

    for (Token *tok = list.front(); tok; tok = tok->next()) {
        // using a::b;  =>   typedef  a::b  b;
        if ((Token::Match(tok, ""[;{}] using %name% :: %name% ::|;"") && !tok->tokAt(2)->isKeyword()) ||
            (Token::Match(tok, ""[;{}] using :: %name% :: %name% ::|;"") && !tok->tokAt(3)->isKeyword())) {
            Token *endtok = tok->tokAt(5);
            if (Token::Match(endtok, ""%name%""))
                endtok = endtok->next();
            while (Token::Match(endtok, "":: %name%""))
                endtok = endtok->tokAt(2);
            if (endtok && endtok->str() == "";"") {
                if (endtok->strAt(-1) == endtok->strAt(-3))
                    continue;
                tok->next()->str(""typedef"");
                endtok = endtok->previous();
                endtok->insertToken(endtok->str());
            }
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.simplifyUsingToTypedef:void(),<empty>,,false,506,529,simplifyUsingToTypedef,,,1,void()
111669153611,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyTypedefLHS()
{
    if (!list.front())
        return;

    for (Token* tok = list.front()->next(); tok; tok = tok->next()) {
        if (tok->str() == ""typedef"") {
            bool doSimplify = !Token::Match(tok->previous(), "";|{|}|:|public:|private:|protected:"");
            if (doSimplify && Token::simpleMatch(tok->previous(), "")"") && Token::Match(tok->linkAt(-1)->previous(), ""if|for|while""))
                doSimplify = false;
            bool haveStart = false;
            Token* start{};
            if (!doSimplify && Token::simpleMatch(tok->previous(), ""}"")) {
                start = tok->linkAt(-1)->previous();
                while (Token::Match(start, ""%name%"")) {
                    if (Token::Match(start, ""class|struct|union|enum"")) {
                        start = start->previous();
                        doSimplify = true;
                        haveStart = true;
                        break;
                    }
                    start = ...",1,1,lib/tokenize.cpp,Tokenizer.simplifyTypedefLHS:void(),<empty>,,false,531,570,simplifyTypedefLHS,,,1,void()
111669153612,METHOD,TypedefSimplifier,TYPE_DECL,"explicit TypedefSimplifier(Token* typedefToken) : mTypedefToken(typedefToken) {
            Token* start = typedefToken->next();
            if (Token::simpleMatch(start, ""typename""))
                start = start->next();

            // TODO handle unnamed structs etc
            if (Token::Match(start, ""const| enum|struct|union|class %name%| {"")) {
                const std::pair<Token*, Token*> rangeBefore(start, Token::findsimplematch(start, ""{""));

                // find typedef name token
                Token* nameToken = rangeBefore.second->link()->next();
                while (Token::Match(nameToken, ""%name%|* %name%|*""))
                    nameToken = nameToken->next();
                const std::pair<Token*, Token*> rangeQualifiers(rangeBefore.second->link()->next(), nameToken);

                if (Token::Match(nameToken, ""%name% ;"")) {
                    if (Token::Match(rangeBefore.second->previous(), ""enum|struct|union|class {""))
                        rangeBefo...",9,9,lib/tokenize.cpp,TypedefSimplifier.TypedefSimplifier:ANY(Token*),<empty>,,false,586,662,TypedefSimplifier,,,10,TypedefSimplifier.TypedefSimplifier:ANY(Token*)(Token*)
111669153613,METHOD,TypedefSimplifier,TYPE_DECL,"const Token* getTypedefToken() const {
            return mTypedefToken;
        }",9,9,lib/tokenize.cpp,TypedefSimplifier.getTypedefToken<const>:Token*(),<empty>,,false,664,666,getTypedefToken,,,11,Token*()
111669153614,METHOD,TypedefSimplifier,TYPE_DECL,"bool isUsed() const {
            return mUsed;
        }",9,9,lib/tokenize.cpp,TypedefSimplifier.isUsed<const>:bool(),<empty>,,false,668,670,isUsed,,,12,bool()
111669153615,METHOD,TypedefSimplifier,TYPE_DECL,"bool isInvalidConstFunctionType(const std::map<std::string, TypedefSimplifier>& m) const {
            if (!Token::Match(mTypedefToken, ""typedef const %name% %name% ;""))
                return false;
            const auto it = m.find(mTypedefToken->strAt(2));
            if (it == m.end())
                return false;
            return Token::Match(it->second.mNameToken, ""%name% ("");
        }",9,9,lib/tokenize.cpp,"TypedefSimplifier.isInvalidConstFunctionType<const>:bool(std.map<std.string,TypedefSimplifier>&)",<empty>,,false,672,679,isInvalidConstFunctionType,,,13,"bool(std.map<std.string,TypedefSimplifier>&)"
111669153616,METHOD,TypedefSimplifier,TYPE_DECL,"bool fail() const {
            return mFail;
        }",9,9,lib/tokenize.cpp,TypedefSimplifier.fail<const>:bool(),<empty>,,false,681,683,fail,,,14,bool()
111669153617,METHOD,TypedefSimplifier,TYPE_DECL,"bool replaceFailed() const {
            return mReplaceFailed;
        }",9,9,lib/tokenize.cpp,TypedefSimplifier.replaceFailed<const>:bool(),<empty>,,false,685,687,replaceFailed,,,15,bool()
111669153618,METHOD,TypedefSimplifier,TYPE_DECL,"bool isStructEtc() const {
            return mRangeType.second && mRangeType.second->str() == ""{"";
        }",9,9,lib/tokenize.cpp,TypedefSimplifier.isStructEtc<const>:bool(),<empty>,,false,689,691,isStructEtc,,,16,bool()
111669153619,METHOD,TypedefSimplifier,TYPE_DECL,"std::string name() const {
            return mNameToken ? mNameToken->str() : """";
        }",9,9,lib/tokenize.cpp,TypedefSimplifier.name<const>:string(),<empty>,,false,693,695,name,,,17,string()
111669153620,METHOD,TypedefSimplifier,TYPE_DECL,"void replace(Token* tok) {
            if (tok == mNameToken)
                return;

            mUsed = true;
            const bool isFunctionPointer = Token::Match(mNameToken, ""%name% )"");

            // Special handling for T(...) when T is a pointer
            if (Token::Match(tok, ""%name% [({]"") && !isFunctionPointer && !Token::simpleMatch(tok->linkAt(1), "") ("")) {
                bool pointerType = false;
                for (const Token* type = mRangeType.first; type != mRangeType.second; type = type->next()) {
                    if (type->str() == ""*"" || type->str() == ""&"") {
                        pointerType = true;
                        break;
                    }
                }
                for (const Token* type = mRangeTypeQualifiers.first; type != mRangeTypeQualifiers.second; type = type->next()) {
                    if (type->str() == ""*"" || type->str() == ""&"") {
                        pointerType = true;
                        break;
             ...",9,9,lib/tokenize.cpp,TypedefSimplifier.replace:void(Token*),<empty>,,false,697,904,replace,,,18,void(Token*)
111669153621,METHOD,TypedefSimplifier,TYPE_DECL,"void removeDeclaration() {
            if (Token::simpleMatch(mRangeType.second, ""{"")) {
                while (Token::Match(mTypedefToken, ""typedef|const""))
                    mTypedefToken->deleteThis();
                Token::eraseTokens(mRangeType.second->link(), mEndToken);
            } else {
                Token::eraseTokens(mTypedefToken, mEndToken);
                mTypedefToken->deleteThis();
            }
        }",9,9,lib/tokenize.cpp,TypedefSimplifier.removeDeclaration:void(),<empty>,,false,906,915,removeDeclaration,,,19,void()
111669153622,METHOD,TypedefSimplifier,TYPE_DECL,"static int canReplaceStatic(const Token* tok) {
            if (!Token::Match(tok, ""%name% %name%|*|&|&&|;|(|)|,|::"")) {
                if (Token::Match(tok->previous(), ""( %name% ="") && Token::Match(tok->linkAt(-1), "") %name%|{"") && !tok->tokAt(-2)->isKeyword())
                    return true;
                if (Token::Match(tok->previous(), "", %name% =""))
                    return true;
                if (Token::Match(tok->previous(), ""new %name% [""))
                    return true;
                if (Token::Match(tok->previous(), ""< %name%"") && tok->previous()->findClosingBracket())
                    return true;
                if (Token::Match(tok->previous(), "", %name% >|>>"")) {
                    for (const Token* prev = tok->previous(); prev; prev = prev->previous()) {
                        if (Token::Match(prev, ""[;{}(]""))
                            break;
                        if (prev->str() == ""<"" && prev->findClosingBracket() == tok->next())
             ...",9,9,lib/tokenize.cpp,TypedefSimplifier.canReplaceStatic:int(Token*),<empty>,,false,917,955,canReplaceStatic,,,20,int(Token*)
111669153623,METHOD,TypedefSimplifier,TYPE_DECL,"bool canReplace(const Token* tok) {
            if (mNameToken == tok)
                return false;
            if (!Token::Match(tok->previous(), ""%name%|;|{|}|(|,|<"") && !Token::Match(tok->previous(), ""!!. %name% (""))
                return false;
            {
                const int res = canReplaceStatic(tok);
                if (res == 0 || res == 1)
                    return res != 0;
            }
            if (Token::Match(tok->previous(), ""%name%"") && !tok->previous()->isKeyword())
                return false;
            if (Token::simpleMatch(tok->next(), ""("") && Token::Match(tok->linkAt(1), "") %name%|{""))
                return false;
            if (Token::Match(tok->previous(), ""struct|union|class|enum %name% %name%"") &&
                Token::simpleMatch(mRangeType.second, ""{"") &&
                tok->str() != mRangeType.second->strAt(-1))
                return true;
            if (Token::Match(tok->previous(), ""; %name% ;""))
                return false;
  ...",9,9,lib/tokenize.cpp,TypedefSimplifier.canReplace:bool(Token*),<empty>,,false,957,1002,canReplace,,,21,bool(Token*)
111669153624,METHOD,TypedefSimplifier,TYPE_DECL,"Token* endToken() const {
            return mEndToken;
        }",9,9,lib/tokenize.cpp,TypedefSimplifier.endToken<const>:Token*(),<empty>,,false,1004,1006,endToken,,,22,Token*()
111669153625,METHOD,TypedefSimplifier,TYPE_DECL,"Token* nameToken() const {
            return mNameToken;
        }",9,9,lib/tokenize.cpp,TypedefSimplifier.nameToken<const>:Token*(),<empty>,,false,1008,1010,nameToken,,,23,Token*()
111669153626,METHOD,TypedefSimplifier,TYPE_DECL,"static bool isCast(const Token* tok) {
            if (Token::Match(tok, ""( %name% ) (|%name%|%num%""))
                return !tok->tokAt(3)->isKeyword();
            if (Token::Match(tok, ""< %name% > ("") && tok->previous() && endsWith(tok->strAt(-1), ""_cast"", 5))
                return true;
            return false;
        }",9,9,lib/tokenize.cpp,TypedefSimplifier.isCast:bool(Token*),<empty>,,false,1013,1019,isCast,,,24,bool(Token*)
111669153627,METHOD,TypedefSimplifier,TYPE_DECL,"static Token* insertTokens(Token* to, std::pair<Token*,Token*> range) {
            for (const Token* from = range.first; from != range.second; from = from->next()) {
                to->insertToken(from->str());
                to->next()->column(to->column());
                to = to->next();
                to->isSimplifiedTypedef(true);
                to->isExternC(from->isExternC());
            }
            return to;
        }",9,9,lib/tokenize.cpp,"TypedefSimplifier.insertTokens:Token*(Token*,std.pair<Token*,Token*>)",<empty>,,false,1021,1030,insertTokens,,,25,"Token*(Token*,std.pair<Token*,Token*>)"
111669153628,METHOD,TypedefSimplifier,TYPE_DECL,"static void printTypedef(const Token *tok, std::ostream& out) {
            int indent = 0;
            while (tok && (indent > 0 || tok->str() != "";"")) {
                if (tok->str() == ""{"")
                    ++indent;
                else if (tok->str() == ""}"")
                    --indent;
                out << "" "" << tok->str();
                tok = tok->next();
            }
            out << ""\\n"";
        }",9,9,lib/tokenize.cpp,"TypedefSimplifier.printTypedef:void(Token*,std.ostream&)",<empty>,,false,1032,1043,printTypedef,,,26,"void(Token*,std.ostream&)"
111669153629,METHOD,<empty>,<empty>,<empty>,5,,lib/tokenize.cpp,TypedefSimplifier.<clinit>,<empty>,,false,573,,<clinit>,,,27,
111669153630,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyTypedef()
{
    // Simplify global typedefs that are not redefined with the fast 1-pass simplification.
    // Then use the slower old typedef simplification.
    std::map<std::string, int> numberOfTypedefs;
    for (Token* tok = list.front(); tok; tok = tok->next()) {
        if (tok->str() == ""typedef"") {
            TypedefSimplifier ts(tok);
            if (!ts.fail())
                numberOfTypedefs[ts.name()]++;
            continue;
        }
    }

    int indentlevel = 0;
    std::map<std::string, TypedefSimplifier> typedefs;
    for (Token* tok = list.front(); tok; tok = tok->next()) {
        if (!tok->isName()) {
            if (tok->str()[0] == '{')
                ++indentlevel;
            else if (tok->str()[0] == '}')
                --indentlevel;
            continue;
        }

        if (indentlevel == 0 && tok->str() == ""typedef"") {
            TypedefSimplifier ts(tok);
            if (!ts.fail() && numberOfTypedefs[ts.name()] == 1 &&...",1,1,lib/tokenize.cpp,Tokenizer.simplifyTypedef:void(),<empty>,,false,1047,1128,simplifyTypedef,,,1,void()
111669153631,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static Token* simplifyTypedefCopyTokens(Token* to, const Token* fromStart, const Token* toEnd, const Token* location) {
    Token* ret = TokenList::copyTokens(to, fromStart, toEnd);
    for (Token* tok = to->next(); tok != ret->next(); tok = tok->next()) {
        tok->linenr(location->linenr());
        tok->column(location->column());
        tok->isSimplifiedTypedef(true);
    }
    return ret;
}",1,1,lib/tokenize.cpp,"simplifyTypedefCopyTokens:Token*(Token*,Token*,Token*,Token*)",<empty>,,false,1130,1138,simplifyTypedefCopyTokens,,,1,"Token*(Token*,Token*,Token*,Token*)"
111669153632,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static Token* simplifyTypedefInsertToken(Token* tok, const std::string& str, const Token* location) {
    tok = tok->insertToken(str);
    tok->linenr(location->linenr());
    tok->column(location->column());
    tok->isSimplifiedTypedef(true);
    return tok;
}",1,1,lib/tokenize.cpp,"simplifyTypedefInsertToken:Token*(Token*,std.string&,Token*)",<empty>,,false,1140,1146,simplifyTypedefInsertToken,,,1,"Token*(Token*,std.string&,Token*)"
111669153633,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyTypedefCpp()
{
    const bool cpp = isCPP();
    bool isNamespace = false;
    std::string className, fullClassName;
    bool hasClass = false;
    bool goback = false;

    // add global namespace
    std::vector<Space> spaceInfo(1);

    // Convert ""using a::b;"" to corresponding typedef statements
    simplifyUsingToTypedef();

    const std::time_t maxTime = mSettings.typedefMaxTime > 0 ? std::time(nullptr) + mSettings.typedefMaxTime: 0;
    const bool doProgress = (mSettings.reportProgress != -1) && !list.getFiles().empty();

    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (doProgress)
            mErrorLogger.reportProgress(list.getFiles()[0], ""Tokenize (typedef)"", tok->progressValue());

        if (Settings::terminated())
            return;

        if (maxTime > 0 && std::time(nullptr) > maxTime) {
            if (mSettings.debugwarnings) {
                ErrorMessage::FileLocation loc(list.getFiles()[0], 0, 0);
            ...",1,1,lib/tokenize.cpp,Tokenizer.simplifyTypedefCpp:void(),<empty>,,false,1149,2378,simplifyTypedefCpp,,,1,void()
111669153634,METHOD,<empty>,<empty>,"[&](const ScopeInfo3& child) {
                return child.name == childName;
            }",68,13,lib/tokenize.cpp,lib/tokenize.cpp:<global>.ScopeInfo3.hasChild<const>.<lambda>0:bool(ScopeInfo3&),<empty>,,false,2414,2416,<lambda>0,,,1,bool(ScopeInfo3&)
111669153635,METHOD,<empty>,<empty>,"[&](const ScopeInfo3& child) {
                    return &child != this && child.type == Record && (child.name == scope || child.fullName == scope);
                }",98,17,lib/tokenize.cpp,lib/tokenize.cpp:<global>.ScopeInfo3.findScope<const>.<lambda>1:bool(ScopeInfo3&),<empty>,,false,2435,2437,<lambda>1,,,1,bool(ScopeInfo3&)
111669153636,METHOD,ScopeInfo3,TYPE_DECL,"ScopeInfo3() : parent(nullptr), type(Global), bodyStart(nullptr), bodyEnd(nullptr) {}",9,93,lib/tokenize.cpp,ScopeInfo3.ScopeInfo3:ANY(),<empty>,,false,2383,2383,ScopeInfo3,,,2,ScopeInfo3.ScopeInfo3:ANY()()
111669153637,METHOD,ScopeInfo3,TYPE_DECL,"ScopeInfo3(ScopeInfo3 *parent_, Type type_, std::string name_, const Token *bodyStart_, const Token *bodyEnd_)
            : parent(parent_), type(type_), name(std::move(name_)), bodyStart(bodyStart_), bodyEnd(bodyEnd_) {
            if (name.empty())
                return;
            fullName = name;
            ScopeInfo3 *scope = parent;
            while (scope && scope->parent) {
                if (scope->name.empty())
                    break;
                fullName = scope->name + "" :: "" + fullName;
                scope = scope->parent;
            }
        }",9,9,lib/tokenize.cpp,"ScopeInfo3.ScopeInfo3:ANY(ScopeInfo3*,ScopeInfo3.Type,std.string,Token*,Token*)",<empty>,,false,2384,2396,ScopeInfo3,,,3,"ScopeInfo3.ScopeInfo3:ANY(ScopeInfo3*,ScopeInfo3.Type,std.string,Token*,Token*)(ScopeInfo3*,ScopeInfo3.Type,std.string,Token*,Token*)"
111669153638,METHOD,ScopeInfo3,TYPE_DECL,"ScopeInfo3 *addChild(Type scopeType, const std::string &scopeName, const Token *bodyStartToken, const Token *bodyEndToken) {
            children.emplace_back(this, scopeType, scopeName, bodyStartToken, bodyEndToken);
            return &children.back();
        }",9,9,lib/tokenize.cpp,"ScopeInfo3.addChild:ScopeInfo3*(ScopeInfo3.Type,std.string&,Token*,Token*)",<empty>,,false,2408,2411,addChild,,,14,"ScopeInfo3*(ScopeInfo3.Type,std.string&,Token*,Token*)"
111669153639,METHOD,ScopeInfo3,TYPE_DECL,"bool hasChild(const std::string &childName) const {
            return std::any_of(children.cbegin(), children.cend(), [&](const ScopeInfo3& child) {
                return child.name == childName;
            });
        }",9,9,lib/tokenize.cpp,ScopeInfo3.hasChild<const>:bool(std.string&),<empty>,,false,2413,2417,hasChild,,,15,bool(std.string&)
111669153640,METHOD,ScopeInfo3,TYPE_DECL,"const ScopeInfo3 * findInChildren(const std::string & scope) const {
            for (const auto & child : children) {
                if (child.type == Record && (child.name == scope || child.fullName == scope))
                    return &child;

                const ScopeInfo3 * temp = child.findInChildren(scope);
                if (temp)
                    return temp;
            }
            return nullptr;
        }",9,9,lib/tokenize.cpp,ScopeInfo3.findInChildren<const>:ScopeInfo3*(std.string&),<empty>,,false,2419,2429,findInChildren,,,16,ScopeInfo3*(std.string&)
111669153641,METHOD,ScopeInfo3,TYPE_DECL,"const ScopeInfo3 * findScope(const std::string & scope) const {
            const ScopeInfo3 * tempScope = this;
            while (tempScope) {
                // check children
                auto it = std::find_if(tempScope->children.cbegin(), tempScope->children.cend(), [&](const ScopeInfo3& child) {
                    return &child != this && child.type == Record && (child.name == scope || child.fullName == scope);
                });
                if (it != tempScope->children.end())
                    return &*it;
                // check siblings for same name
                if (tempScope->parent) {
                    for (const auto &sibling : tempScope->parent->children) {
                        if (sibling.name == tempScope->name && &sibling != this) {
                            const ScopeInfo3 * temp = sibling.findInChildren(scope);
                            if (temp)
                                return temp;
                        }
                    }...",9,9,lib/tokenize.cpp,ScopeInfo3.findScope<const>:ScopeInfo3*(std.string&),<empty>,,false,2431,2453,findScope,,,17,ScopeInfo3*(std.string&)
111669153642,METHOD,ScopeInfo3,TYPE_DECL,"bool findTypeInBase(const std::string &scope) const {
            if (scope.empty())
                return false;
            // check in base types first
            if (baseTypes.find(scope) != baseTypes.end())
                return true;
            // check in base types base types
            for (const std::string & base : baseTypes) {
                const ScopeInfo3 * baseScope = findScope(base);
                // bail on uninstantiated recursive template
                if (baseScope == this)
                    return false;
                if (baseScope && baseScope->fullName == scope)
                    return true;
                if (baseScope && baseScope->findTypeInBase(scope))
                    return true;
            }
            return false;
        }",9,9,lib/tokenize.cpp,ScopeInfo3.findTypeInBase<const>:bool(std.string&),<empty>,,false,2455,2473,findTypeInBase,,,18,bool(std.string&)
111669153643,METHOD,ScopeInfo3,TYPE_DECL,"ScopeInfo3 * findScope(const ScopeInfo3 * scope) {
            if (scope->bodyStart == bodyStart)
                return this;
            for (auto & child : children) {
                ScopeInfo3 * temp = child.findScope(scope);
                if (temp)
                    return temp;
            }
            return nullptr;
        }",9,9,lib/tokenize.cpp,ScopeInfo3.findScope:ScopeInfo3*(ScopeInfo3*),<empty>,,false,2475,2484,findScope,,,19,ScopeInfo3*(ScopeInfo3*)
111669153644,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void setScopeInfo(Token *tok, ScopeInfo3 *&scopeInfo, bool debug=false)
    {
        if (!tok)
            return;
        if (tok->str() == ""{"" && scopeInfo->parent && tok == scopeInfo->bodyStart)
            return;
        if (tok->str() == ""}"") {
            if (scopeInfo->parent && tok == scopeInfo->bodyEnd)
                scopeInfo = scopeInfo->parent;
            else {
                // Try to find parent scope
                ScopeInfo3 *parent = scopeInfo->parent;
                while (parent && parent->bodyEnd != tok)
                    parent = parent->parent;
                if (parent) {
                    scopeInfo = parent;
                    if (debug)
                        throw std::runtime_error(""Internal error: unmatched }"");
                }
            }
            return;
        }
        if (!Token::Match(tok, ""namespace|class|struct|union %name% {|:|::|<"")) {
            // check for using namespace
            if (Token::Match(tok, ""using names...",5,5,lib/tokenize.cpp,"setScopeInfo:void(Token*,ScopeInfo3*&,bool)",<empty>,,false,2487,2627,setScopeInfo,,,1,"void(Token*,ScopeInfo3*&,bool)"
111669153645,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"Token *findSemicolon(Token *tok)
    {
        int level = 0;

        for (; tok && (level > 0 || tok->str() != "";""); tok = tok->next()) {
            if (tok->str() == ""{"")
                ++level;
            else if (level > 0 && tok->str() == ""}"")
                --level;
        }

        return tok;
    }",5,5,lib/tokenize.cpp,findSemicolon:Token*(Token*),<empty>,,false,2629,2641,findSemicolon,,,1,Token*(Token*)
111669153646,METHOD,<empty>,<empty>,"[&](const std::string& ns) {
                        return scope == ns + suffix;
                    }",71,21,lib/tokenize.cpp,lib/tokenize.cpp:<global>.usingMatch.<lambda>2:bool(std.string&),<empty>,,false,2729,2731,<lambda>2,,,1,bool(std.string&)
111669153647,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"bool usingMatch(
        const Token *nameToken,
        const std::string &scope,
        Token *&tok,
        const std::string &scope1,
        const ScopeInfo3 *currentScope,
        const ScopeInfo3 *memberClassScope)
    {
        Token *tok1 = tok;

        if (tok1 && tok1->str() != nameToken->str())
            return false;

        // skip this using
        if (tok1 == nameToken) {
            tok = findSemicolon(tok1);
            return false;
        }

        // skip other using with this name
        if (tok1->strAt(-1) == ""using"") {
            // fixme: this is wrong
            // skip to end of scope
            if (currentScope->bodyEnd)
                tok = const_cast<Token*>(currentScope->bodyEnd->previous());
            return false;
        }

        if (Token::Match(tok1->tokAt(-1), ""class|struct|union|enum|namespace"")) {
            // fixme
            return false;
        }

        // get qualification
        std::string qualification;
        co...",5,5,lib/tokenize.cpp,"usingMatch:bool(Token*,std.string&,Token*&,std.string&,ScopeInfo3*,ScopeInfo3*)",<empty>,,false,2643,2759,usingMatch,,,1,"bool(Token*,std.string&,Token*&,std.string&,ScopeInfo3*,ScopeInfo3*)"
111669153648,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"std::string memberFunctionScope(const Token *tok)
    {
        std::string qualification;
        const Token *qualTok = tok->strAt(-2) == ""~"" ? tok->tokAt(-4) : tok->tokAt(-3);
        while (Token::Match(qualTok, ""%type% ::"")) {
            if (!qualification.empty())
                qualification = "" :: "" + qualification;
            qualification = qualTok->str() + qualification;
            qualTok = qualTok->tokAt(-2);
        }
        return qualification;
    }",5,5,lib/tokenize.cpp,memberFunctionScope:string(Token*),<empty>,,false,2761,2772,memberFunctionScope,,,1,string(Token*)
111669153649,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"const Token * memberFunctionEnd(const Token *tok)
    {
        if (tok->str() != ""("")
            return nullptr;
        const Token *end = tok->link()->next();
        while (end) {
            if (end->str() == ""{"" && !Token::Match(end->tokAt(-2), "":|, %name%""))
                return end;
            if (end->str() == "";"")
                break;
            end = end->next();
        }
        return nullptr;
    }",5,5,lib/tokenize.cpp,memberFunctionEnd:Token*(Token*),<empty>,,false,2774,2787,memberFunctionEnd,,,1,Token*(Token*)
111669153650,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"bool Tokenizer::isMemberFunction(const Token *openParen)
{
    return (Token::Match(openParen->tokAt(-2), "":: %name% ("") ||
            Token::Match(openParen->tokAt(-3), "":: ~ %name% ("")) &&
           TokenList::isFunctionHead(openParen, ""{:"");
}",1,1,lib/tokenize.cpp,Tokenizer.isMemberFunction:bool(Token*),<empty>,,false,2790,2795,isMemberFunction,,,1,bool(Token*)
111669153651,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static bool scopesMatch(const std::string &scope1, const std::string &scope2, const ScopeInfo3 *globalScope)
{
    if (scope1.empty() || scope2.empty())
        return false;

    // check if scopes match
    if (scope1 == scope2)
        return true;

    // check if scopes only differ by global qualification
    if (scope1 == ("":: "" + scope2)) {
        std::string::size_type end = scope2.find_first_of(' ');
        if (end == std::string::npos)
            end = scope2.size();
        if (globalScope->hasChild(scope2.substr(0, end)))
            return true;
    } else if (scope2 == ("":: "" + scope1)) {
        std::string::size_type end = scope1.find_first_of(' ');
        if (end == std::string::npos)
            end = scope1.size();
        if (globalScope->hasChild(scope1.substr(0, end)))
            return true;
    }

    return false;
}",1,1,lib/tokenize.cpp,"scopesMatch:bool(std.string&,std.string&,ScopeInfo3*)",<empty>,,false,2797,2822,scopesMatch,,,1,"bool(std.string&,std.string&,ScopeInfo3*)"
111669153652,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static unsigned int tokDistance(const Token* tok1, const Token* tok2) { // use when index() is not available yet
    unsigned int dist = 0;
    const Token* tok = tok1;
    while (tok != tok2) {
        ++dist;
        tok = tok->next();
    }
    return dist;
}",1,1,lib/tokenize.cpp,"tokDistance:unsigned int(Token*,Token*)",<empty>,,false,2824,2832,tokDistance,,,1,"unsigned int(Token*,Token*)"
111669153653,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static const Token* skipConstVolatileBackwards(const Token* tok) {
    while (Token::Match(tok, ""const|volatile""))
        tok = tok->previous();
    return tok;
}",1,1,lib/tokenize.cpp,skipConstVolatileBackwards:Token*(Token*),<empty>,,false,2834,2838,skipConstVolatileBackwards,,,1,Token*(Token*)
111669153654,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"bool Tokenizer::simplifyUsing()
{
    if (!isCPP() || mSettings.standards.cpp < Standards::CPP11)
        return false;

    // simplify using N::x; to using x = N::x;
    for (Token* tok = list.front(); tok; tok = tok->next()) {
        if (!Token::Match(tok, ""using ::| %name% ::""))
            continue;
        const Token* ns = tok->tokAt(tok->strAt(1) == ""::"" ? 2 : 1);
        if (ns->isKeyword())
            continue;
        Token* end = tok->tokAt(3);
        while (end && !Token::Match(end, ""[;,]"")) {
            if (end->str() == ""<"") // skip template args
                end = end->findClosingBracket();
            else
                end = end->next();
        }
        if (!end)
            continue;
        if (!end->tokAt(-1)->isNameOnly() || end->tokAt(-2)->isLiteral()) // e.g. operator=, operator""""sv
            continue;
        tok->insertToken(end->strAt(-1))->insertToken(""="")->isSimplifiedTypedef(true);
        if (end->str() == "","") { // comma-separated list
  ...",1,1,lib/tokenize.cpp,Tokenizer.simplifyUsing:bool(),<empty>,,false,2840,3360,simplifyUsing,,,1,bool()
111669153655,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyUsingError(const Token* usingStart, const Token* usingEnd)
{
    if (mSettings.debugwarnings) {
        std::string str;
        for (const Token *tok = usingStart; tok && tok != usingEnd; tok = tok->next()) {
            if (!str.empty())
                str += ' ';
            str += tok->str();
        }
        str += "" ;"";
        std::list<const Token *> callstack(1, usingStart);
        mErrorLogger.reportErr(ErrorMessage(callstack, &list, Severity::debug, ""simplifyUsing"",
                                            ""Failed to parse \\'"" + str + ""\\'. The checking continues anyway."", Certainty::normal));
    }
}",1,1,lib/tokenize.cpp,"Tokenizer.simplifyUsingError:void(Token*,Token*)",<empty>,,false,3362,3376,simplifyUsingError,,,1,"void(Token*,Token*)"
111669153656,METHOD,<empty>,<empty>,"[&]() {
        list.createAst();
        list.validateAst(mSettings.debugnormal);
    }",82,5,lib/tokenize.cpp,lib/tokenize.cpp:<global>.Tokenizer.simplifyTokens1.<lambda>3:void(),<empty>,,false,3396,3399,<lambda>3,,,1,void()
111669153657,METHOD,<empty>,<empty>,"[&]() {
        createSymbolDatabase();
    }",93,5,lib/tokenize.cpp,lib/tokenize.cpp:<global>.Tokenizer.simplifyTokens1.<lambda>4:void(),<empty>,,false,3401,3403,<lambda>4,,,1,void()
111669153658,METHOD,<empty>,<empty>,"[&]() {
        mSymbolDatabase->setValueTypeInTokenList(false);
        mSymbolDatabase->setValueTypeInTokenList(true);
    }",85,5,lib/tokenize.cpp,lib/tokenize.cpp:<global>.Tokenizer.simplifyTokens1.<lambda>5:void(),<empty>,,false,3405,3408,<lambda>5,,,1,void()
111669153659,METHOD,<empty>,<empty>,"[&]() {
            ValueFlow::setValues(list, *mSymbolDatabase, mErrorLogger, mSettings, mTimerResults);
        }",86,9,lib/tokenize.cpp,lib/tokenize.cpp:<global>.Tokenizer.simplifyTokens1.<lambda>6:void(),<empty>,,false,3420,3422,<lambda>6,,,1,void()
111669153660,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"bool Tokenizer::simplifyTokens1(const std::string &configuration)
{
    // Fill the map mTypeSize..
    fillTypeSizes();

    mConfiguration = configuration;

    if (mTimerResults) {
        Timer t(""Tokenizer::simplifyTokens1::simplifyTokenList1"", mSettings.showtime, mTimerResults);
        if (!simplifyTokenList1(list.getFiles().front().c_str()))
            return false;
    } else {
        if (!simplifyTokenList1(list.getFiles().front().c_str()))
            return false;
    }

    const SHOWTIME_MODES showTime = mTimerResults ? mSettings.showtime : SHOWTIME_MODES::SHOWTIME_NONE;

    Timer::run(""Tokenizer::simplifyTokens1::createAst"", showTime, mTimerResults, [&]() {
        list.createAst();
        list.validateAst(mSettings.debugnormal);
    });

    Timer::run(""Tokenizer::simplifyTokens1::createSymbolDatabase"", showTime, mTimerResults, [&]() {
        createSymbolDatabase();
    });

    Timer::run(""Tokenizer::simplifyTokens1::setValueType"", showTime, mTimerResults, [&](...",1,1,lib/tokenize.cpp,Tokenizer.simplifyTokens1:bool(std.string&),<empty>,,false,3378,3447,simplifyTokens1,,,1,bool(std.string&)
111669153661,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::findComplicatedSyntaxErrorsInTemplates()
{
    validate();
    mTemplateSimplifier->checkComplicatedSyntaxErrorsInTemplates();
}",1,1,lib/tokenize.cpp,Tokenizer.findComplicatedSyntaxErrorsInTemplates:void(),<empty>,,false,3451,3455,findComplicatedSyntaxErrorsInTemplates,,,1,void()
111669153662,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::checkForEnumsWithTypedef()
{
    for (const Token *tok = list.front(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""enum %name% {"")) {
            tok = tok->tokAt(2);
            const Token *tok2 = Token::findsimplematch(tok, ""typedef"", tok->link());
            if (tok2)
                syntaxError(tok2);
            tok = tok->link();
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.checkForEnumsWithTypedef:void(),<empty>,,false,3457,3468,checkForEnumsWithTypedef,,,1,void()
111669153663,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::fillTypeSizes()
{
    mTypeSize.clear();
    mTypeSize[""char""] = 1;
    mTypeSize[""_Bool""] = mSettings.platform.sizeof_bool;
    mTypeSize[""bool""] = mSettings.platform.sizeof_bool;
    mTypeSize[""short""] = mSettings.platform.sizeof_short;
    mTypeSize[""int""] = mSettings.platform.sizeof_int;
    mTypeSize[""long""] = mSettings.platform.sizeof_long;
    mTypeSize[""long long""] = mSettings.platform.sizeof_long_long;
    mTypeSize[""float""] = mSettings.platform.sizeof_float;
    mTypeSize[""double""] = mSettings.platform.sizeof_double;
    mTypeSize[""long double""] = mSettings.platform.sizeof_long_double;
    mTypeSize[""wchar_t""] = mSettings.platform.sizeof_wchar_t;
    mTypeSize[""size_t""] = mSettings.platform.sizeof_size_t;
    mTypeSize[""*""] = mSettings.platform.sizeof_pointer;
}",1,1,lib/tokenize.cpp,Tokenizer.fillTypeSizes:void(),<empty>,,false,3470,3486,fillTypeSizes,,,1,void()
111669153664,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::combineOperators()
{
    const bool cpp = isCPP();

    // Combine tokens..
    for (Token *tok = list.front(); tok && tok->next(); tok = tok->next()) {
        const char c1 = tok->str()[0];

        if (tok->str().length() == 1 && tok->strAt(1).length() == 1) {
            const char c2 = tok->strAt(1)[0];

            // combine +-*/ and =
            if (c2 == '=' && (std::strchr(""+-*/%|^=!<>"", c1)) && !Token::Match(tok->previous(), ""%type% *"")) {
                // skip templates
                if (cpp && (tok->str() == "">"" || Token::simpleMatch(tok->previous(), ""> *""))) {
                    const Token* opening =
                        tok->str() == "">"" ? tok->findOpeningBracket() : tok->previous()->findOpeningBracket();
                    if (opening && Token::Match(opening->previous(), ""%name%""))
                        continue;
                }
                tok->str(tok->str() + c2);
                tok->deleteNext();
                continue;
     ...",1,1,lib/tokenize.cpp,Tokenizer.combineOperators:void(),<empty>,,false,3488,3553,combineOperators,,,1,void()
111669153665,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::combineStringAndCharLiterals()
{
    // Combine strings
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (!isStringLiteral(tok->str()))
            continue;

        tok->str(simplifyString(tok->str()));

        while (Token::Match(tok->next(), ""%str%"") || Token::Match(tok->next(), ""_T|_TEXT|TEXT ( %str% )"")) {
            if (tok->next()->isName()) {
                if (!mSettings.platform.isWindows())
                    break;
                tok->deleteNext(2);
                tok->next()->deleteNext();
            }
            // Two strings after each other, combine them
            tok->concatStr(simplifyString(tok->strAt(1)));
            tok->deleteNext();
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.combineStringAndCharLiterals:void(),<empty>,,false,3555,3576,combineStringAndCharLiterals,,,1,void()
111669153666,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::concatenateNegativeNumberAndAnyPositive()
{
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (!Token::Match(tok, ""?|:|,|(|[|{|return|case|sizeof|%op% +|-"") || tok->tokType() == Token::eIncDecOp)
            continue;

        while (tok->str() != "">"" && tok->next() && tok->strAt(1) == ""+"" && (!Token::Match(tok->tokAt(2), ""%name% (|;"") || Token::Match(tok, ""%op%"")))
            tok->deleteNext();

        if (Token::Match(tok->next(), ""+|- %num%"")) {
            // cppcheck-suppress redundantCopyLocalConst - cannot make it a reference because it is deleted afterwards
            std::string prefix = tok->strAt(1);
            tok->deleteNext();
            tok->next()->str(prefix + tok->strAt(1));
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.concatenateNegativeNumberAndAnyPositive:void(),<empty>,,false,3578,3594,concatenateNegativeNumberAndAnyPositive,,,1,void()
111669153667,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyExternC()
{
    if (isC())
        return;

    // Add attributes to all tokens within `extern ""C""` inlines and blocks, and remove the `extern ""C""` tokens.
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""extern \\""C\\""|\\""C++\\"""")) {
            Token *tok2 = tok->next();
            const bool isExtC = tok->strAt(1).size() == 3;
            if (tok->strAt(2) == ""{"") {
                tok2 = tok2->next(); // skip {
                while ((tok2 = tok2->next()) && tok2 != tok->linkAt(2))
                    tok2->isExternC(isExtC);
                tok->linkAt(2)->deleteThis(); // }
                tok->deleteNext(2); // ""C"" {
            } else {
                while ((tok2 = tok2->next()) && !Token::Match(tok2, ""[;{]""))
                    tok2->isExternC(isExtC);
                tok->deleteNext(); // ""C""
            }
            tok->deleteThis(); // extern
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.simplifyExternC:void(),<empty>,,false,3596,3620,simplifyExternC,,,1,void()
111669153668,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyCompoundStatements()
{
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        while (Token::Match(tok, ""[;{}:] ( {"") &&
               Token::simpleMatch(tok->linkAt(2), ""} ) ;"")) {
            if (tok->str() == "":"" && !Token::Match(tok->tokAt(-2),""[;{}] %type% :""))
                break;
            Token *end = tok->linkAt(2)->tokAt(-3);
            if (Token::Match(end, ""[;{}] %num%|%str% ;""))
                end->deleteNext(2);
            tok->linkAt(2)->previous()->deleteNext(3);
            tok->deleteNext(2);
        }
        if (Token::Match(tok, ""( { %bool%|%char%|%num%|%str%|%name% ; } )"")) {
            tok->deleteNext();
            tok->deleteThis();
            tok->deleteNext(3);
        }
        else if (tok->str() == ""("")
            tok = tok->link();
    }
}",1,1,lib/tokenize.cpp,Tokenizer.simplifyCompoundStatements:void(),<empty>,,false,3622,3643,simplifyCompoundStatements,,,1,void()
111669153669,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifySQL()
{
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (!Token::simpleMatch(tok, ""__CPPCHECK_EMBEDDED_SQL_EXEC__ SQL""))
            continue;

        const Token *end = findSQLBlockEnd(tok);
        if (end == nullptr)
            syntaxError(nullptr);

        const std::string instruction = tok->stringifyList(end);
        // delete all tokens until the embedded SQL block end
        Token::eraseTokens(tok, end);

        // insert ""asm ( ""instruction"" ) ;""
        tok->str(""asm"");
        // it can happen that 'end' is NULL when wrong code is inserted
        if (!tok->next())
            tok->insertToken("";"");
        tok->insertToken("")"");
        tok->insertToken(""\\"""" + instruction + ""\\"""");
        tok->insertToken(""("");
        // jump to ';' and continue
        tok = tok->tokAt(3);
    }
}",1,1,lib/tokenize.cpp,Tokenizer.simplifySQL:void(),<empty>,,false,3645,3670,simplifySQL,,,1,void()
111669153670,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyParenthesizedLibraryFunctions()
{
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (!Token::simpleMatch(tok, "") (""))
            continue;
        Token *rpar = tok, *lpar = tok->link();
        if (!lpar || Token::Match(lpar->previous(), ""%name%""))
            continue;
        const Token *ftok = rpar->previous();
        if (mSettings.library.isNotLibraryFunction(ftok))
            continue;
        lpar->deleteThis();
        rpar->deleteThis();
    }
}",1,1,lib/tokenize.cpp,Tokenizer.simplifyParenthesizedLibraryFunctions:void(),<empty>,,false,3672,3686,simplifyParenthesizedLibraryFunctions,,,1,void()
111669153671,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyArrayAccessSyntax()
{
    // 0[a] -> a[0]
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (tok->isNumber() && Token::Match(tok, ""%num% [ %name% ]"")) {
            const std::string number(tok->str());
            Token* indexTok = tok->tokAt(2);
            tok->str(indexTok->str());
            tok->varId(indexTok->varId());
            indexTok->str(number);
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.simplifyArrayAccessSyntax:void(),<empty>,,false,3688,3700,simplifyArrayAccessSyntax,,,1,void()
111669153672,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyParameterVoid()
{
    for (Token* tok = list.front(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""%name% ( void )"") && !Token::Match(tok, ""sizeof|decltype|typeof|return"")) {
            tok->next()->deleteNext();
            tok->next()->setRemovedVoidParameter(true);
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.simplifyParameterVoid:void(),<empty>,,false,3702,3710,simplifyParameterVoid,,,1,void()
111669153673,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyRedundantConsecutiveBraces()
{
    // Remove redundant consecutive braces, i.e. '.. { { .. } } ..' -> '.. { .. } ..'.
    for (Token *tok = list.front(); tok;) {
        if (Token::simpleMatch(tok, ""= {"")) {
            tok = tok->linkAt(1);
        } else if (Token::simpleMatch(tok, ""{ {"") && Token::simpleMatch(tok->linkAt(1), ""} }"")) {
            //remove internal parentheses
            tok->linkAt(1)->deleteThis();
            tok->deleteNext();
        } else
            tok = tok->next();
    }
}",1,1,lib/tokenize.cpp,Tokenizer.simplifyRedundantConsecutiveBraces:void(),<empty>,,false,3712,3725,simplifyRedundantConsecutiveBraces,,,1,void()
111669153674,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyDoublePlusAndDoubleMinus()
{
    // Convert - - into + and + - into -
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        while (tok->next()) {
            if (tok->str() == ""+"") {
                if (tok->strAt(1)[0] == '-') {
                    tok = tok->next();
                    if (tok->str().size() == 1) {
                        tok = tok->previous();
                        tok->str(""-"");
                        tok->deleteNext();
                    } else if (tok->isNumber()) {
                        tok->str(tok->str().substr(1));
                        tok = tok->previous();
                        tok->str(""-"");
                    }
                    continue;
                }
            } else if (tok->str() == ""-"") {
                if (tok->strAt(1)[0] == '-') {
                    tok = tok->next();
                    if (tok->str().size() == 1) {
                        tok = tok->previous();
                    ...",1,1,lib/tokenize.cpp,Tokenizer.simplifyDoublePlusAndDoubleMinus:void(),<empty>,,false,3727,3765,simplifyDoublePlusAndDoubleMinus,,,1,void()
111669153675,METHOD,<empty>,<empty>,"[](Token* tok, bool addLength, Token*& endStmt) -> Token* {
        if (addLength) {
            endStmt = tok->tokAt(5);
            return tok->tokAt(4);
        }
        if (Token::Match(tok, ""%var% [ ] ="")) {
            tok = tok->tokAt(4);
            int parCount = 0;
            while (Token::simpleMatch(tok, ""("")) {
                ++parCount;
                tok = tok->next();
            }
            if (Token::Match(tok, ""%str%"")) {
                endStmt = tok->tokAt(parCount + 1);
                return tok;
            }
        }
        return nullptr;
    }",22,5,lib/tokenize.cpp,"lib/tokenize.cpp:<global>.Tokenizer.arraySize.<lambda>7:Token(Token*,bool,Token*&)",<empty>,,false,3771,3789,<lambda>7,,,1,"Token(Token*,bool,Token*&)"
111669153676,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::arraySize()
{
    auto getStrTok = [](Token* tok, bool addLength, Token*& endStmt) -> Token* {
        if (addLength) {
            endStmt = tok->tokAt(5);
            return tok->tokAt(4);
        }
        if (Token::Match(tok, ""%var% [ ] ="")) {
            tok = tok->tokAt(4);
            int parCount = 0;
            while (Token::simpleMatch(tok, ""("")) {
                ++parCount;
                tok = tok->next();
            }
            if (Token::Match(tok, ""%str%"")) {
                endStmt = tok->tokAt(parCount + 1);
                return tok;
            }
        }
        return nullptr;
    };

    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (!tok->isName() || !Token::Match(tok, ""%var% [ ] =""))
            continue;
        bool addlength = false;
        if (Token::Match(tok->previous(), ""!!* %var% [ ] = { %str% } ;"")) {
            Token *t = tok->tokAt(3);
            t->deleteNext();
            t->next()->deleteNext()...",1,1,lib/tokenize.cpp,Tokenizer.arraySize:void(),<empty>,,false,3769,3840,arraySize,,,1,void()
111669153677,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::arraySizeAfterValueFlow()
{
    // After ValueFlow, adjust array sizes.
    for (const Variable* var: mSymbolDatabase->variableList()) {
        if (!var || !var->isArray())
            continue;
        if (!Token::Match(var->nameToken(), ""%name% [ ] = { [""))
            continue;
        MathLib::bigint maxIndex = -1;
        const Token* const startToken = var->nameToken()->tokAt(4);
        const Token* const endToken = startToken->link();
        for (const Token* tok = startToken; tok != endToken; tok = tok->next()) {
            if (!Token::Match(tok, ""[{,] ["") || !Token::simpleMatch(tok->linkAt(1), ""] =""))
                continue;
            const Token* expr = tok->next()->astOperand1();
            if (expr && expr->hasKnownIntValue())
                maxIndex = std::max(maxIndex, expr->getKnownIntValue());
        }
        if (maxIndex >= 0) {
            // insert array size
            auto* tok = const_cast<Token*>(var->nameToken()->next());
        ...",1,1,lib/tokenize.cpp,Tokenizer.arraySizeAfterValueFlow:void(),<empty>,,false,3842,3879,arraySizeAfterValueFlow,,,1,void()
111669153678,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static Token *skipTernaryOp(Token *tok)
{
    int colonLevel = 1;
    while (nullptr != (tok = tok->next())) {
        if (tok->str() == ""?"") {
            ++colonLevel;
        } else if (tok->str() == "":"") {
            --colonLevel;
            if (colonLevel == 0) {
                tok = tok->next();
                break;
            }
        }
        if (tok->link() && Token::Match(tok, ""[(<]""))
            tok = tok->link();
        else if (Token::Match(tok->next(), ""[{};)]""))
            break;
    }
    if (colonLevel > 0) // Ticket #5214: Make sure the ':' matches the proper '?'
        return nullptr;
    return tok;
}",1,1,lib/tokenize.cpp,skipTernaryOp:Token*(Token*),<empty>,,false,3881,3902,skipTernaryOp,,,1,Token*(Token*)
111669153679,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static Token *skipCaseLabel(Token *tok)
{
    assert(tok->str() == ""case"");
    while (nullptr != (tok = tok->next())) {
        if (Token::Match(tok, ""(|[""))
            tok = tok->link();
        else if (tok->str() == ""?"") {
            Token * tok1 = skipTernaryOp(tok);
            if (!tok1)
                return tok;
            tok = tok1;
        }
        if (Token::Match(tok, ""[:{};]""))
            return tok;
    }
    return nullptr;
}",1,1,lib/tokenize.cpp,skipCaseLabel:Token*(Token*),<empty>,,false,3907,3923,skipCaseLabel,,,1,Token*(Token*)
111669153680,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"const Token * Tokenizer::startOfExecutableScope(const Token * tok)
{
    if (tok->str() != "")"")
        return nullptr;

    tok = TokenList::isFunctionHead(tok, "":{"");

    if (Token::Match(tok, "": %name% [({]"")) {
        while (Token::Match(tok, ""[:,] %name% [({]""))
            tok = tok->linkAt(2)->next();
    }

    return (tok && tok->str() == ""{"") ? tok : nullptr;
}",1,1,lib/tokenize.cpp,Tokenizer.startOfExecutableScope:Token*(Token*),<empty>,,false,3925,3938,startOfExecutableScope,,,1,Token*(Token*)
111669153681,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyLabelsCaseDefault()
{
    const bool cpp = isCPP();
    bool executablescope = false;
    int indentLevel = 0;
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        // Simplify labels in the executable scope..
        auto *start = const_cast<Token *>(startOfExecutableScope(tok));
        if (start) {
            tok = start;
            executablescope = true;
        }

        if (!executablescope)
            continue;

        if (tok->str() == ""{"") {
            if (tok->strAt(-1) == ""="")
                tok = tok->link();
            else
                ++indentLevel;
        } else if (tok->str() == ""}"") {
            --indentLevel;
            if (indentLevel == 0) {
                executablescope = false;
                continue;
            }
        } else if (Token::Match(tok, ""(|[""))
            tok = tok->link();

        if (Token::Match(tok, ""[;{}:] case"")) {
            tok = skipCaseLabel(tok->next());
            if (!to...",1,1,lib/tokenize.cpp,Tokenizer.simplifyLabelsCaseDefault:void(),<empty>,,false,3943,3990,simplifyLabelsCaseDefault,,,1,void()
111669153682,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyCaseRange()
{
    for (Token* tok = list.front(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""case %num%|%char% ... %num%|%char% :"")) {
            const MathLib::bigint start = MathLib::toBigNumber(tok->tokAt(1));
            MathLib::bigint end = MathLib::toBigNumber(tok->tokAt(3));
            end = std::min(start + 50, end); // Simplify it 50 times at maximum
            if (start < end) {
                tok = tok->tokAt(2);
                tok->str("":"");
                tok->insertToken(""case"");
                for (MathLib::bigint i = end-1; i > start; i--) {
                    tok->insertToken("":"");
                    tok->insertToken(MathLib::toString(i));
                    tok->insertToken(""case"");
                }
            }
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.simplifyCaseRange:void(),<empty>,,false,3993,4012,simplifyCaseRange,,,1,void()
111669153683,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::calculateScopes()
{
    for (auto *tok = list.front(); tok; tok = tok->next())
        tok->scopeInfo(nullptr);

    std::string nextScopeNameAddition;
    std::shared_ptr<ScopeInfo2> primaryScope = std::make_shared<ScopeInfo2>("""", nullptr);
    list.front()->scopeInfo(std::move(primaryScope));

    for (Token* tok = list.front(); tok; tok = tok->next()) {
        if (tok == list.front() || !tok->scopeInfo()) {
            if (tok != list.front())
                tok->scopeInfo(tok->previous()->scopeInfo());

            if (Token::Match(tok, ""using namespace %name% ::|<|;"")) {
                std::string usingNamespaceName;
                for (const Token* namespaceNameToken = tok->tokAt(2);
                     namespaceNameToken && namespaceNameToken->str() != "";"";
                     namespaceNameToken = namespaceNameToken->next()) {
                    usingNamespaceName += namespaceNameToken->str();
                    usingNamespaceName += "" "";
             ...",1,1,lib/tokenize.cpp,Tokenizer.calculateScopes:void(),<empty>,,false,4014,4103,calculateScopes,,,1,void()
111669153684,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyTemplates()
{
    if (isC())
        return;

    const std::time_t maxTime = mSettings.templateMaxTime > 0 ? std::time(nullptr) + mSettings.templateMaxTime : 0;
    mTemplateSimplifier->simplifyTemplates(
        maxTime);
}",1,1,lib/tokenize.cpp,Tokenizer.simplifyTemplates:void(),<empty>,,false,4105,4113,simplifyTemplates,,,1,void()
111669153685,METHOD,VariableMap,TYPE_DECL,VariableMap() = default;,9,32,lib/tokenize.cpp,VariableMap.VariableMap:ANY(),<empty>,,false,4126,4126,VariableMap,,,5,ANY()
111669153686,METHOD,VariableMap,TYPE_DECL,"bool hasVariable(const std::string& varname) const {
            return mVariableId.find(varname) != mVariableId.end();
        }",9,9,lib/tokenize.cpp,VariableMap.hasVariable<const>:bool(std.string&),<empty>,,false,4130,4132,hasVariable,,,6,bool(std.string&)
111669153687,METHOD,VariableMap,TYPE_DECL,"const std::unordered_map<std::string, nonneg int>& map(bool global) const {
            return global ? mVariableId_global : mVariableId;
        }",9,46,lib/tokenize.cpp,VariableMap.map<const>:ANY(bool),<empty>,,false,4134,4136,map,,,7,ANY(bool)
111669153688,METHOD,VariableMap,TYPE_DECL,"int& getVarId() {
            return mVarId;
        }",16,9,lib/tokenize.cpp,VariableMap.getVarId:int&(),<empty>,,false,4137,4139,getVarId,,,8,int&()
111669153689,METHOD,<empty>,<empty>,<empty>,5,,lib/tokenize.cpp,VariableMap.<clinit>,<empty>,,false,4119,,<clinit>,,,9,
111669153690,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void VariableMap::enterScope()
{
    mScopeInfo.emplace(/*std::vector<std::pair<std::string, nonneg int>>()*/);
}",1,1,lib/tokenize.cpp,VariableMap.enterScope:void(),<empty>,,false,4144,4147,enterScope,,,1,void()
111669153691,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"bool VariableMap::leaveScope()
{
    if (mScopeInfo.empty())
        return false;

    for (const std::pair<std::string, nonneg int>& outerVariable : mScopeInfo.top()) {
        if (outerVariable.second != 0)
            mVariableId[outerVariable.first] = outerVariable.second;
        else
            mVariableId.erase(outerVariable.first);
    }
    mScopeInfo.pop();
    return true;
}",1,38,lib/tokenize.cpp,VariableMap.leaveScope:bool(),<empty>,,false,4149,4162,leaveScope,,,1,bool()
111669153692,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void VariableMap::addVariable(const std::string& varname, bool globalNamespace)
{
    if (mScopeInfo.empty()) {
        mVariableId[varname] = ++mVarId;
        if (globalNamespace)
            mVariableId_global[varname] = mVariableId[varname];
        return;
    }
    const auto it = mVariableId.find(varname);
    if (it == mVariableId.end()) {
        mScopeInfo.top().emplace_back(varname, 0);
        mVariableId[varname] = ++mVarId;
        if (globalNamespace)
            mVariableId_global[varname] = mVariableId[varname];
        return;
    }
    mScopeInfo.top().emplace_back(varname, it->second);
    it->second = ++mVarId;
}",1,1,lib/tokenize.cpp,"VariableMap.addVariable:void(std.string&,bool)",<empty>,,false,4164,4182,addVariable,,,1,"void(std.string&,bool)"
111669153693,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static bool setVarIdParseDeclaration(Token*& tok, const VariableMap& variableMap, bool executableScope)
{
    const Token* const tok1 = tok;
    Token* tok2 = tok;
    if (!tok2->isName())
        return false;

    nonneg int typeCount = 0;
    nonneg int singleNameCount = 0;
    bool hasstruct = false;   // Is there a ""struct"" or ""class""?
    bool bracket = false;
    bool ref = false;
    while (tok2) {
        if (tok2->isName()) {
            if (Token::simpleMatch(tok2, ""alignas ("")) {
                tok2 = tok2->linkAt(1)->next();
                continue;
            }
            if (tok2->isCpp() && Token::Match(tok2, ""namespace|public|private|protected""))
                return false;
            if (tok2->isCpp() && Token::simpleMatch(tok2, ""decltype ("")) {
                typeCount = 1;
                tok2 = tok2->linkAt(1)->next();
                continue;
            }
            if (Token::Match(tok2, ""struct|union|enum"") || (tok2->isCpp() && Token::Match(tok2, ""...",1,4,lib/tokenize.cpp,"setVarIdParseDeclaration:bool(Token*&,VariableMap&,bool)",<empty>,,false,4184,4323,setVarIdParseDeclaration,,,1,"bool(Token*&,VariableMap&,bool)"
111669153694,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static void setVarIdStructMembers(Token *&tok1,
                                  std::map<nonneg int, std::map<std::string, nonneg int>>& structMembers,
                                  nonneg int &varId)
{
    Token *tok = tok1;

    if (Token::Match(tok, ""%name% = { . %name% =|{"")) {
        const nonneg int struct_varid = tok->varId();
        if (struct_varid == 0)
            return;

        std::map<std::string, nonneg int>& members = structMembers[struct_varid];

        tok = tok->tokAt(3);
        while (tok->str() != ""}"") {
            if (Token::Match(tok, ""{|[|(""))
                tok = tok->link();
            if (Token::Match(tok->previous(), ""[,{] . %name% =|{"")) {
                tok = tok->next();
                const auto it = utils::as_const(members).find(tok->str());
                if (it == members.cend()) {
                    members[tok->str()] = ++varId;
                    tok->varId(varId);
                } else {
                    tok->varId(it->s...",1,43,lib/tokenize.cpp,"setVarIdStructMembers:void(Token*&,std.map<int,std.map<std.string,int>>&,int&)",<empty>,,false,4326,4389,setVarIdStructMembers,,,1,"void(Token*&,std.map<int,std.map<std.string,int>>&,int&)"
111669153695,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static bool setVarIdClassDeclaration(Token* const startToken,
                                     VariableMap& variableMap,
                                     const nonneg int scopeStartVarId,
                                     std::map<nonneg int, std::map<std::string, nonneg int>>& structMembers)
{
    // end of scope
    const Token* const endToken = startToken->link();

    // determine class name
    std::string className;
    for (const Token *tok = startToken->previous(); tok; tok = tok->previous()) {
        if (!tok->isName() && tok->str() != "":"")
            break;
        if (Token::Match(tok, ""class|struct|enum %type% [:{]"")) {
            className = tok->strAt(1);
            break;
        }
    }

    // replace varids..
    int indentlevel = 0;
    bool initList = false;
    bool inEnum = false;
    const Token *initListArgLastToken = nullptr;
    for (Token *tok = startToken->next(); tok != endToken; tok = tok->next()) {
        if (!tok)
            return fa...",1,43,lib/tokenize.cpp,"setVarIdClassDeclaration:bool(Token*,VariableMap&,int,std.map<int,std.map<std.string,int>>&)",<empty>,,false,4391,4464,setVarIdClassDeclaration,,,1,"bool(Token*,VariableMap&,int,std.map<int,std.map<std.string,int>>&)"
111669153696,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::setVarIdClassFunction(const std::string &classname,
                                      Token * const startToken,
                                      const Token * const endToken,
                                      const std::map<std::string, nonneg int> &varlist,
                                      std::map<nonneg int, std::map<std::string, nonneg int>>& structMembers,
                                      nonneg int &varId_)
{
    const auto pos = classname.rfind(' '); // TODO handle multiple scopes
    const std::string lastScope = classname.substr(pos == std::string::npos ? 0 : pos + 1);
    for (Token *tok2 = startToken; tok2 && tok2 != endToken; tok2 = tok2->next()) {
        if (tok2->varId() != 0 || !tok2->isName())
            continue;
        if (Token::Match(tok2->tokAt(-2), (""!!"" + lastScope + "" ::"").c_str()))
            continue;
        if (Token::Match(tok2->tokAt(-4), ""%name% :: %name% ::"")) // Currently unsupported
            continue;
  ...",1,66,lib/tokenize.cpp,"Tokenizer.setVarIdClassFunction:void(std.string&,Token*,Token*,std.map<std.string,int>&,std.map<int,std.map<std.string,int>>&,int&)",<empty>,,false,4470,4497,setVarIdClassFunction,,,1,"void(std.string&,Token*,Token*,std.map<std.string,int>&,std.map<int,std.map<std.string,int>>&,int&)"
111669153697,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::setVarId()
{
    // Clear all variable ids
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (tok->isName())
            tok->varId(0);
    }

    setVarIdPass1();

    setPodTypes();

    setVarIdPass2();
}",1,1,lib/tokenize.cpp,Tokenizer.setVarId:void(),<empty>,,false,4501,4514,setVarId,,,1,void()
111669153698,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::setVarIdPass1()
{
    const bool cpp = isCPP();
    // Variable declarations can't start with ""return"" etc.
    const std::unordered_set<std::string>& notstart = (isC()) ? notstart_c : notstart_cpp;

    VariableMap variableMap;
    std::map<nonneg int, std::map<std::string, nonneg int>> structMembers;

    std::stack<VarIdScopeInfo> scopeStack;

    scopeStack.emplace(/*VarIdScopeInfo()*/);
    std::stack<const Token *> functionDeclEndStack;
    const Token *functionDeclEndToken = nullptr;
    bool initlist = false;
    bool inlineFunction = false;
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (tok->isOp())
            continue;
        if (cpp && Token::simpleMatch(tok, ""template <"")) {
            Token* closingBracket = tok->next()->findClosingBracket();
            if (closingBracket)
                tok = closingBracket;
            continue;
        }

        if (tok == functionDeclEndToken) {
            functionDeclEndStack.pop();...",1,13,lib/tokenize.cpp,Tokenizer.setVarIdPass1:void(),<empty>,,false,4524,4893,setVarIdPass1,,,1,void()
111669153699,METHOD,Member,TYPE_DECL,"Member(std::list<std::string> s, std::list<const Token *> ns, Token *t) : usingnamespaces(std::move(ns)), scope(std::move(s)), tok(t) {}",9,144,lib/tokenize.cpp,"Member.Member:ANY(std.list<std.string>,std.list<constToken*>,Token*)",<empty>,,false,4897,4897,Member,,,1,"Member.Member:ANY(std.list<std.string>,std.list<constToken*>,Token*)(std.list<std.string>,std.list<constToken*>,Token*)"
111669153700,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static std::string getScopeName(const std::list<ScopeInfo2> &scopeInfo)
{
    std::string ret;
    for (const ScopeInfo2 &si : scopeInfo)
        ret += (ret.empty() ? """" : "" :: "") + (si.name);
    return ret;
}",1,1,lib/tokenize.cpp,getScopeName:string(std.list<ScopeInfo2>&),<empty>,,false,4904,4910,getScopeName,,,1,string(std.list<ScopeInfo2>&)
111669153701,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static Token * matchMemberName(const std::list<std::string> &scope, const Token *nsToken, Token *memberToken, const std::list<ScopeInfo2> &scopeInfo)
{
    auto scopeIt = scopeInfo.cbegin();

    // Current scope..
    for (auto it = scope.cbegin(); it != scope.cend(); ++it) {
        if (scopeIt == scopeInfo.cend() || scopeIt->name != *it)
            return nullptr;
        ++scopeIt;
    }

    // using namespace..
    if (nsToken) {
        while (Token::Match(nsToken, ""%name% ::"")) {
            if (scopeIt != scopeInfo.end() && nsToken->str() == scopeIt->name) {
                nsToken = nsToken->tokAt(2);
                ++scopeIt;
            } else {
                return nullptr;
            }
        }
        if (!Token::Match(nsToken, ""%name% ;""))
            return nullptr;
        if (scopeIt == scopeInfo.end() || nsToken->str() != scopeIt->name)
            return nullptr;
        ++scopeIt;
    }

    // Parse member tokens..
    while (scopeIt != scopeInfo.end()) ...",1,1,lib/tokenize.cpp,"matchMemberName:Token*(std.list<std.string>&,Token*,Token*,std.list<ScopeInfo2>&)",<empty>,,false,4912,4956,matchMemberName,,,1,"Token*(std.list<std.string>&,Token*,Token*,std.list<ScopeInfo2>&)"
111669153702,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static Token * matchMemberName(const Member &member, const std::list<ScopeInfo2> &scopeInfo)
{
    if (scopeInfo.empty())
        return nullptr;

    // Does this member match without ""using namespace""..
    Token *ret = matchMemberName(member.scope, nullptr, member.tok, scopeInfo);
    if (ret)
        return ret;

    // Try to match member using the ""using namespace ..."" namespaces..
    for (const Token *ns : member.usingnamespaces) {
        ret = matchMemberName(member.scope, ns, member.tok, scopeInfo);
        if (ret)
            return ret;
    }

    return nullptr;
}",1,1,lib/tokenize.cpp,"matchMemberName:Token*(Member&,std.list<ScopeInfo2>&)",<empty>,,false,4958,4976,matchMemberName,,,1,"Token*(Member&,std.list<ScopeInfo2>&)"
111669153703,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static Token * matchMemberVarName(const Member &var, const std::list<ScopeInfo2> &scopeInfo)
{
    Token *tok = matchMemberName(var, scopeInfo);
    if (Token::Match(tok, ""%name%"")) {
        if (!tok->next() || tok->strAt(1) != ""("" || (tok->tokAt(2) && tok->tokAt(2)->isLiteral()))
            return tok;
    }
    return nullptr;
}",1,1,lib/tokenize.cpp,"matchMemberVarName:Token*(Member&,std.list<ScopeInfo2>&)",<empty>,,false,4978,4986,matchMemberVarName,,,1,"Token*(Member&,std.list<ScopeInfo2>&)"
111669153704,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static Token * matchMemberFunctionName(const Member &func, const std::list<ScopeInfo2> &scopeInfo)
{
    Token *tok = matchMemberName(func, scopeInfo);
    return Token::Match(tok, ""~| %name% ("") ? tok : nullptr;
}",1,1,lib/tokenize.cpp,"matchMemberFunctionName:Token*(Member&,std.list<ScopeInfo2>&)",<empty>,,false,4988,4992,matchMemberFunctionName,,,1,"Token*(Member&,std.list<ScopeInfo2>&)"
111669153705,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static T* skipInitializerList(T* tok)
{
    T* const start = tok;
    while (Token::Match(tok, ""[:,] ::| %name%"")) {
        tok = tok->tokAt(tok->strAt(1) == ""::"" ? 1 : 2);
        while (Token::Match(tok, "":: %name%""))
            tok = tok->tokAt(2);
        if (!Token::Match(tok, ""[({<]"") || !tok->link())
            return start;
        const bool isTemplate = tok->str() == ""<"";
        tok = tok->link()->next();
        if (isTemplate && tok && tok->link())
            tok = tok->link()->next();
    }
    return tok;
}",1,1,lib/tokenize.cpp,skipInitializerList:T(T*),<empty>,,false,4995,5010,skipInitializerList,,,1,T(T*)
111669153706,METHOD,<empty>,<empty>,"[&](const Token* tok) {
            return ScopeInfo2(tok->str(), tokStart->link());
        }",105,9,lib/tokenize.cpp,lib/tokenize.cpp:<global>.Tokenizer.setVarIdPass2.<lambda>8:ScopeInfo2(Token*),<empty>,,false,5154,5156,<lambda>8,,,1,ScopeInfo2(Token*)
111669153707,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::setVarIdPass2()
{
    std::map<nonneg int, std::map<std::string, nonneg int>> structMembers;

    // Member functions and variables in this source
    std::list<Member> allMemberFunctions;
    std::list<Member> allMemberVars;
    if (!isC()) {
        std::map<const Token *, std::string> endOfScope;
        std::list<std::string> scope;
        std::list<const Token *> usingnamespaces;
        for (Token *tok = list.front(); tok; tok = tok->next()) {
            if (!tok->previous() || Token::Match(tok->previous(), ""[;{}]"")) {
                if (Token::Match(tok, ""using namespace %name% ::|;"")) {
                    Token *endtok = tok->tokAt(2);
                    while (Token::Match(endtok, ""%name% ::""))
                        endtok = endtok->tokAt(2);
                    if (Token::Match(endtok, ""%name% ;""))
                        usingnamespaces.push_back(tok->tokAt(2));
                    tok = endtok;
                    continue;
                }
      ...",1,13,lib/tokenize.cpp,Tokenizer.setVarIdPass2:void(),<empty>,,false,5012,5258,setVarIdPass2,,,1,void()
111669153708,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static void linkBrackets(const Tokenizer & tokenizer, std::stack<const Token*>& type, std::stack<Token*>& links, Token * const token, const char open, const char close)
{
    if (token->str()[0] == open) {
        links.push(token);
        type.push(token);
    } else if (token->str()[0] == close) {
        if (links.empty()) {
            // Error, { and } don't match.
            tokenizer.unmatchedToken(token);
        }
        if (type.top()->str()[0] != open) {
            tokenizer.unmatchedToken(type.top());
        }
        type.pop();

        Token::createMutualLinks(links.top(), token);
        links.pop();
    }
}",1,1,lib/tokenize.cpp,"linkBrackets:void(Tokenizer&,std.stack<constToken*>&,std.stack<Token*>&,Token*,char,char)",<empty>,,false,5260,5278,linkBrackets,,,1,"void(Tokenizer&,std.stack<constToken*>&,std.stack<Token*>&,Token*,char,char)"
111669153709,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::createLinks()
{
    std::stack<const Token*> type;
    std::stack<Token*> links1;
    std::stack<Token*> links2;
    std::stack<Token*> links3;
    for (Token *token = list.front(); token; token = token->next()) {
        if (token->link()) {
            token->link(nullptr);
        }

        linkBrackets(*this, type, links1, token, '{', '}');

        linkBrackets(*this, type, links2, token, '(', ')');

        linkBrackets(*this, type, links3, token, '[', ']');
    }

    if (!links1.empty()) {
        // Error, { and } don't match.
        unmatchedToken(links1.top());
    }

    if (!links2.empty()) {
        // Error, ( and ) don't match.
        unmatchedToken(links2.top());
    }

    if (!links3.empty()) {
        // Error, [ and ] don't match.
        unmatchedToken(links3.top());
    }
}",1,1,lib/tokenize.cpp,Tokenizer.createLinks:void(),<empty>,,false,5280,5312,createLinks,,,1,void()
111669153710,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::createLinks2()
{
    if (isC())
        return;

    bool isStruct = false;

    std::stack<Token*> type;
    std::stack<Token*> templateTokens;
    for (Token *token = list.front(); token; token = token->next()) {
        if (Token::Match(token, ""%name%|> %name% [:<]""))
            isStruct = true;
        else if (Token::Match(token, ""[;{}]""))
            isStruct = false;

        if (token->link()) {
            if (Token::Match(token, ""{|[|(""))
                type.push(token);
            else if (!type.empty() && Token::Match(token, ""}|]|)"")) {
                while (type.top()->str() == ""<"") {
                    if (!templateTokens.empty() && templateTokens.top()->next() == type.top())
                        templateTokens.pop();
                    type.pop();
                }
                type.pop();
            }
        } else if (templateTokens.empty() && !isStruct && Token::Match(token, ""%oror%|&&|;"")) {
            if (Token::Match(token, ""&& [,>...",1,1,lib/tokenize.cpp,Tokenizer.createLinks2:void(),<empty>,,false,5314,5430,createLinks2,,,1,void()
111669153711,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::markCppCasts()
{
    if (isC())
        return;
    for (Token* tok = list.front(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""const_cast|dynamic_cast|reinterpret_cast|static_cast"")) {
            if (!Token::simpleMatch(tok->next(), ""<"") || !Token::simpleMatch(tok->linkAt(1), ""> (""))
                syntaxError(tok);
            tok = tok->linkAt(1)->next();
            tok->isCast(true);
        }
    }

}",1,1,lib/tokenize.cpp,Tokenizer.markCppCasts:void(),<empty>,,false,5432,5445,markCppCasts,,,1,void()
111669153712,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::sizeofAddParentheses()
{
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (!Token::Match(tok, ""sizeof !!(""))
            continue;
        if (tok->next()->isLiteral() || Token::Match(tok->next(), ""%name%|*|~|!|&"")) {
            Token *endToken = tok->next();
            while (Token::simpleMatch(endToken, ""* *""))
                endToken = endToken->next();
            while (Token::Match(endToken->next(), ""%name%|%num%|%str%|[|(|.|::|++|--|!|~"") || (Token::Match(endToken, ""%type% * %op%|?|:|const|;|,""))) {
                if (Token::Match(endToken->next(), ""(|[""))
                    endToken = endToken->linkAt(1);
                else
                    endToken = endToken->next();
            }

            // Add ( after sizeof and ) behind endToken
            tok->insertToken(""("");
            endToken->insertToken("")"");
            Token::createMutualLinks(tok->next(), endToken->next());
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.sizeofAddParentheses:void(),<empty>,,false,5447,5469,sizeofAddParentheses,,,1,void()
111669153713,METHOD,<empty>,<empty>,"[&]() {
        findGarbageCode();
    }",108,5,lib/tokenize.cpp,lib/tokenize.cpp:<global>.Tokenizer.simplifyTokenList1.<lambda>9:void(),<empty>,,false,5551,5553,<lambda>9,,,1,void()
111669153714,METHOD,<empty>,<empty>,"[&]() {
        simplifyTypedef();
    }",108,5,lib/tokenize.cpp,lib/tokenize.cpp:<global>.Tokenizer.simplifyTokenList1.<lambda>10:void(),<empty>,,false,5708,5710,<lambda>10,,,1,void()
111669153715,METHOD,<empty>,<empty>,"[&]() {
            simplifyTemplates();
        }",114,9,lib/tokenize.cpp,lib/tokenize.cpp:<global>.Tokenizer.simplifyTokenList1.<lambda>11:void(),<empty>,,false,5802,5804,<lambda>11,,,1,void()
111669153716,METHOD,<empty>,<empty>,"[&](){
        setVarId();
    }",101,5,lib/tokenize.cpp,lib/tokenize.cpp:<global>.Tokenizer.simplifyTokenList1.<lambda>12:void(),<empty>,,false,5829,5831,<lambda>12,,,1,void()
111669153717,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"bool Tokenizer::simplifyTokenList1(const char FileName[])
{
    if (Settings::terminated())
        return false;

    // if MACRO
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""if|for|while %name% ("")) {
            if (Token::simpleMatch(tok, ""for each"")) {
                // 'for each (x in y )' -> 'for (x : y)'
                if (Token* in = Token::findsimplematch(tok->tokAt(2), ""in"", tok->linkAt(2)))
                    in->str("":"");
                tok->deleteNext();
            } else if (tok->strAt(1) == ""constexpr"") {
                tok->deleteNext();
                tok->isConstexpr(true);
            } else {
                syntaxError(tok);
            }
        }
    }

    // Is there C++ code in C file?
    validateC();

    // Combine strings and character literals, e.g. L""string"", L'c', ""string1"" ""string2""
    combineStringAndCharLiterals();

    // replace inline SQL with ""asm()"" (Oracle PRO*C). Ticket: #1959
    sim...",1,1,lib/tokenize.cpp,Tokenizer.simplifyTokenList1:bool(char[]),<empty>,,false,5471,5875,simplifyTokenList1,,,1,bool(char[])
111669153718,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::printDebugOutput(int simplification, std::ostream &out) const
{
    const bool debug = (simplification != 1U && mSettings.debugSimplified) ||
                       (simplification != 2U && mSettings.debugnormal);

    if (debug && list.front()) {
        const bool xml = (mSettings.outputFormat == Settings::OutputFormat::xml);

        if (!xml)
            list.front()->printOut(out, xml, nullptr, list.getFiles());

        if (xml)
        {
            out << ""<debug>"" << std::endl;
            list.front()->printOut(out, xml, nullptr, list.getFiles());
        }

        if (mSymbolDatabase) {
            if (xml)
                mSymbolDatabase->printXml(out);
            else if (mSettings.verbose) {
                mSymbolDatabase->printOut(""Symbol database"");
            }
        }

        if (mSettings.verbose)
            list.front()->printAst(mSettings.verbose, xml, list.getFiles(), out);

        list.front()->printValueFlow(xml, out);

        if (xm...",1,1,lib/tokenize.cpp,"Tokenizer.printDebugOutput<const>:void(int,std.ostream&)",<empty>,,false,5878,5932,printDebugOutput,,,1,"void(int,std.ostream&)"
111669153719,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::dump(std::ostream &out) const
{
    // Create a xml data dump.
    // The idea is not that this will be readable for humans. It's a
    // data dump that 3rd party tools could load and get useful info from.

    std::string outs;

    std::set<const Library::Container*> containers;

    outs += ""  <directivelist>"";
    outs += '\\n';
    for (const Directive &dir : mDirectives) {
        outs += ""    <directive "";
        outs += ""file=\\"""";
        outs += ErrorLogger::toxml(Path::getRelativePath(dir.file, mSettings.basePaths));
        outs += ""\\"" "";
        outs += ""linenr=\\"""";
        outs += std::to_string(dir.linenr);
        outs += ""\\"" "";
        // str might contain characters such as '""', '<' or '>' which
        // could result in invalid XML, so run it through toxml().
        outs += ""str=\\"""";
        outs += ErrorLogger::toxml(dir.str);
        outs +=""\\"">"";
        outs += '\\n';
        for (const auto & strToken : dir.strTokens) {
            outs += "" ...",1,1,lib/tokenize.cpp,Tokenizer.dump<const>:void(std.ostream&),<empty>,,false,5934,6173,dump,,,1,void(std.ostream&)
111669153720,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"std::string Tokenizer::dumpTypedefInfo() const
{
    if (mTypedefInfo.empty())
        return """";
    std::string outs = ""  <typedef-info>"";
    outs += '\\n';
    for (const TypedefInfo &typedefInfo: mTypedefInfo) {
        outs += ""    <info"";

        outs += "" name=\\"""";
        outs += typedefInfo.name;
        outs += ""\\"""";

        outs += "" file=\\"""";
        outs += ErrorLogger::toxml(typedefInfo.filename);
        outs += ""\\"""";

        outs += "" line=\\"""";
        outs += std::to_string(typedefInfo.lineNumber);
        outs += ""\\"""";

        outs += "" column=\\"""";
        outs += std::to_string(typedefInfo.column);
        outs += ""\\"""";

        outs += "" used=\\"""";
        outs += std::to_string(typedefInfo.used?1:0);
        outs += ""\\"""";

        outs += "" isFunctionPointer=\\"""";
        outs += std::to_string(typedefInfo.isFunctionPointer);
        outs += ""\\"""";

        outs += ""/>"";
        outs += '\\n';
    }
    outs += ""  </typedef-info>"";
    outs += '\\n';

    return ...",1,1,lib/tokenize.cpp,Tokenizer.dumpTypedefInfo<const>:string(),<empty>,,false,6175,6215,dumpTypedefInfo,,,1,string()
111669153721,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyHeadersAndUnusedTemplates()
{
    if (mSettings.checkHeaders && mSettings.checkUnusedTemplates)
        // Full analysis. All information in the headers are kept.
        return;

    const bool checkHeaders = mSettings.checkHeaders;
    const bool removeUnusedIncludedFunctions = !mSettings.checkHeaders;
    const bool removeUnusedIncludedClasses   = !mSettings.checkHeaders;
    const bool removeUnusedIncludedTemplates = !mSettings.checkUnusedTemplates || !mSettings.checkHeaders;
    const bool removeUnusedTemplates = !mSettings.checkUnusedTemplates;

    // checkHeaders:
    //
    // If it is true then keep all code in the headers. It's possible
    // to remove unused types/variables if false positives / false
    // negatives can be avoided.
    //
    // If it is false, then we want to remove selected stuff from the
    // headers but not *everything*. The intention here is to not damage
    // the analysis of the source file. You should get all warnings...",1,1,lib/tokenize.cpp,Tokenizer.simplifyHeadersAndUnusedTemplates:void(),<empty>,,false,6217,6340,simplifyHeadersAndUnusedTemplates,,,1,void()
111669153722,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::removeExtraTemplateKeywords()
{
    if (isCPP()) {
        for (Token *tok = list.front(); tok; tok = tok->next()) {
            if (Token::Match(tok, ""%name%|>|) .|:: template %name%"")) {
                tok->next()->deleteNext();
                Token* templateName = tok->tokAt(2);
                while (Token::Match(templateName, ""%name%|::"")) {
                    templateName->isTemplate(true);
                    templateName = templateName->next();
                }
                if (!templateName)
                    syntaxError(tok);
                if (Token::Match(templateName->previous(), ""operator %op%|("")) {
                    templateName->isTemplate(true);
                    if (templateName->str() == ""("" && templateName->link())
                        templateName->link()->isTemplate(true);
                }
            }
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.removeExtraTemplateKeywords:void(),<empty>,,false,6342,6363,removeExtraTemplateKeywords,,,1,void()
111669153723,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static std::string getExpression(const Token *tok)
{
    std::string line;
    for (const Token *prev = tok->previous(); prev && !Token::Match(prev, ""[;{}]""); prev = prev->previous())
        line = prev->str() + "" "" + line;
    line += ""!!!"" + tok->str() + ""!!!"";
    for (const Token *next = tok->next(); next && !Token::Match(next, ""[;{}]""); next = next->next())
        line += "" "" + next->str();
    return line;
}",1,1,lib/tokenize.cpp,getExpression:string(Token*),<empty>,,false,6365,6374,getExpression,,,1,string(Token*)
111669153724,METHOD,<empty>,<empty>,"[scopeLevel](const std::pair<std::string, int>& v) {
                return v.second == scopeLevel;
            }",65,13,lib/tokenize.cpp,"lib/tokenize.cpp:<global>.Tokenizer.splitTemplateRightAngleBrackets.<lambda>13:bool(std.pair<std.string,int>&)",<empty>,,false,6385,6387,<lambda>13,,,1,"bool(std.pair<std.string,int>&)"
111669153725,METHOD,<empty>,<empty>,"[&](const std::pair<std::string, int>& v) {
            return v.first == tok->strAt(-1);
        }",139,9,lib/tokenize.cpp,"lib/tokenize.cpp:<global>.Tokenizer.splitTemplateRightAngleBrackets.<lambda>14:bool(std.pair<std.string,int>&)",<empty>,,false,6394,6396,<lambda>14,,,1,"bool(std.pair<std.string,int>&)"
111669153726,METHOD,<empty>,<empty>,"[&](const std::pair<std::string, int>& v) {
            return v.first == tok->strAt(1);
        }",140,9,lib/tokenize.cpp,"lib/tokenize.cpp:<global>.Tokenizer.splitTemplateRightAngleBrackets.<lambda>15:bool(std.pair<std.string,int>&)",<empty>,,false,6411,6413,<lambda>15,,,1,"bool(std.pair<std.string,int>&)"
111669153727,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::splitTemplateRightAngleBrackets(bool check)
{
    std::vector<std::pair<std::string, int>> vars;

    int scopeLevel = 0;
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (tok->str() == ""{"")
            ++scopeLevel;
        else if (tok->str() == ""}"") {
            vars.erase(std::remove_if(vars.begin(), vars.end(), [scopeLevel](const std::pair<std::string, int>& v) {
                return v.second == scopeLevel;
            }), vars.end());
            --scopeLevel;
        }
        if (Token::Match(tok, ""[;{}] %type% %type% [;,=]"") && tok->next()->isStandardType())
            vars.emplace_back(tok->strAt(2), scopeLevel);

        // Ticket #6181: normalize C++11 template parameter list closing syntax
        if (tok->previous() && tok->str() == ""<"" && TemplateSimplifier::templateParameters(tok) && std::none_of(vars.begin(), vars.end(), [&](const std::pair<std::string, int>& v) {
            return v.first == tok->strAt(-1);
        })) {...",1,1,lib/tokenize.cpp,Tokenizer.splitTemplateRightAngleBrackets:void(bool),<empty>,,false,6376,6426,splitTemplateRightAngleBrackets,,,1,void(bool)
111669153728,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::removeMacrosInGlobalScope()
{
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (tok->str() == ""("") {
            tok = tok->link();
            if (Token::Match(tok, "") %type% {"") &&
                !tok->next()->isStandardType() &&
                !tok->next()->isKeyword() &&
                !Token::Match(tok->next(), ""override|final"") &&
                tok->next()->isUpperCaseName())
                tok->deleteNext();
        }

        if (Token::Match(tok, ""%type%"") && tok->isUpperCaseName() &&
            (!tok->previous() || Token::Match(tok->previous(), ""[;{}]"") || (tok->previous()->isName() && endsWith(tok->strAt(-1), ':')))) {
            const Token *tok2 = tok->next();
            if (tok2 && tok2->str() == ""("")
                tok2 = tok2->link()->next();

            // Several unknown macros...
            while (Token::Match(tok2, ""%type% ("") && tok2->isUpperCaseName())
                tok2 = tok2->linkAt(1)->next();

         ...",1,1,lib/tokenize.cpp,Tokenizer.removeMacrosInGlobalScope:void(),<empty>,,false,6428,6503,removeMacrosInGlobalScope,,,1,void()
111669153729,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::removePragma()
{
    if (isC() && mSettings.standards.c == Standards::C89)
        return;
    if (isCPP() && mSettings.standards.cpp == Standards::CPP03)
        return;
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        while (Token::simpleMatch(tok, ""_Pragma ("")) {
            Token::eraseTokens(tok, tok->linkAt(1)->next());
            tok->deleteThis();
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.removePragma:void(),<empty>,,false,6507,6519,removePragma,,,1,void()
111669153730,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::removeMacroInClassDef()
{
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (!Token::Match(tok, ""class|struct %name% %name% final| {|:""))
            continue;

        const bool nextIsUppercase = tok->next()->isUpperCaseName();
        const bool afterNextIsUppercase = tok->tokAt(2)->isUpperCaseName();
        if (nextIsUppercase && !afterNextIsUppercase)
            tok->deleteNext();
        else if (!nextIsUppercase && afterNextIsUppercase)
            tok->next()->deleteNext();
    }
}",1,1,lib/tokenize.cpp,Tokenizer.removeMacroInClassDef:void(),<empty>,,false,6523,6536,removeMacroInClassDef,,,1,void()
111669153731,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::addSemicolonAfterUnknownMacro()
{
    if (!isCPP())
        return;
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (tok->str() != "")"")
            continue;
        const Token *macro = tok->link() ? tok->link()->previous() : nullptr;
        if (!macro || !macro->isName())
            continue;
        if (Token::simpleMatch(tok, "") try"") && !Token::Match(macro, ""if|for|while""))
            tok->insertToken("";"");
        else if (Token::simpleMatch(tok, "") using""))
            tok->insertToken("";"");
    }
}",1,1,lib/tokenize.cpp,Tokenizer.addSemicolonAfterUnknownMacro:void(),<empty>,,false,6540,6555,addSemicolonAfterUnknownMacro,,,1,void()
111669153732,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyEmptyNamespaces()
{
    if (isC())
        return;

    bool goback = false;
    for (Token *tok = list.front(); tok; tok = tok ? tok->next() : nullptr) {
        if (goback) {
            tok = tok->previous();
            goback = false;
        }
        if (Token::Match(tok, ""(|[|{"")) {
            tok = tok->link();
            continue;
        }
        if (!Token::Match(tok, ""namespace %name%| {""))
            continue;
        const bool isAnonymousNS = tok->strAt(1) == ""{"";
        if (tok->strAt(3 - isAnonymousNS) == ""}"") {
            tok->deleteNext(3 - isAnonymousNS); // remove '%name%| { }'
            if (!tok->previous()) {
                // remove 'namespace' or replace it with ';' if isolated
                tok->deleteThis();
                goback = true;
            } else {                    // '%any% namespace %any%'
                tok = tok->previous();  // goto previous token
                tok->deleteNext();      // remove next ...",1,1,lib/tokenize.cpp,Tokenizer.simplifyEmptyNamespaces:void(),<empty>,,false,6558,6595,simplifyEmptyNamespaces,,,1,void()
111669153733,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::removeRedundantSemicolons()
{
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (tok->link() && tok->str() == ""("") {
            tok = tok->link();
            continue;
        }
        for (;;) {
            if (Token::simpleMatch(tok, ""; ;"")) {
                tok->deleteNext();
            } else if (Token::simpleMatch(tok, ""; { ; }"")) {
                tok->deleteNext(3);
            } else {
                break;
            }
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.removeRedundantSemicolons:void(),<empty>,,false,6597,6614,removeRedundantSemicolons,,,1,void()
111669153734,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"bool Tokenizer::simplifyAddBraces()
{
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        Token const * tokRet=simplifyAddBracesToCommand(tok);
        if (!tokRet)
            return false;
    }
    return true;
}",1,1,lib/tokenize.cpp,Tokenizer.simplifyAddBraces:bool(),<empty>,,false,6617,6625,simplifyAddBraces,,,1,bool()
111669153735,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"Token *Tokenizer::simplifyAddBracesToCommand(Token *tok)
{
    Token * tokEnd=tok;
    if (Token::Match(tok,""for|switch|BOOST_FOREACH"")) {
        tokEnd=simplifyAddBracesPair(tok,true);
    } else if (tok->str()==""while"") {
        Token *tokPossibleDo=tok->previous();
        if (Token::simpleMatch(tok->previous(), ""{""))
            tokPossibleDo = nullptr;
        else if (Token::simpleMatch(tokPossibleDo,""}""))
            tokPossibleDo = tokPossibleDo->link();
        if (!tokPossibleDo || tokPossibleDo->strAt(-1) != ""do"")
            tokEnd=simplifyAddBracesPair(tok,true);
    } else if (tok->str()==""do"") {
        tokEnd=simplifyAddBracesPair(tok,false);
        if (tokEnd!=tok) {
            // walk on to next token, i.e. ""while""
            // such that simplifyAddBracesPair does not close other braces
            // before the ""while""
            if (tokEnd) {
                tokEnd=tokEnd->next();
                if (!tokEnd || tokEnd->str()!=""while"") // no while
         ...",1,1,lib/tokenize.cpp,Tokenizer.simplifyAddBracesToCommand:Token*(Token*),<empty>,,false,6627,6669,simplifyAddBracesToCommand,,,1,Token*(Token*)
111669153736,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"Token *Tokenizer::simplifyAddBracesPair(Token *tok, bool commandWithCondition)
{
    Token * tokCondition=tok->next();
    if (!tokCondition) // Missing condition
        return tok;

    Token *tokAfterCondition=tokCondition;
    if (commandWithCondition) {
        if (tokCondition->str()==""("")
            tokAfterCondition=tokCondition->link();
        else
            syntaxError(tok); // Bad condition

        if (!tokAfterCondition || tokAfterCondition->strAt(1) == ""]"")
            syntaxError(tok); // Bad condition

        tokAfterCondition=tokAfterCondition->next();
        if (!tokAfterCondition || Token::Match(tokAfterCondition, "")|}|,"")) {
            // No tokens left where to add braces around
            return tok;
        }
    }
    // Skip labels
    Token * tokStatement = tokAfterCondition;
    while (true) {
        if (Token::Match(tokStatement, ""%name% :""))
            tokStatement = tokStatement->tokAt(2);
        else if (tokStatement->str() == ""case"") {
    ...",1,1,lib/tokenize.cpp,"Tokenizer.simplifyAddBracesPair:Token*(Token*,bool)",<empty>,,false,6671,6768,simplifyAddBracesPair,,,1,"Token*(Token*,bool)"
111669153737,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyFunctionParameters()
{
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (tok->link() && Token::Match(tok, ""{|[|("")) {
            tok = tok->link();
        }

        // Find the function e.g. foo( x ) or foo( x, y )
        else if (Token::Match(tok, ""%name% ( %name% [,)]"") &&
                 !(tok->strAt(-1) == "":"" || tok->strAt(-1) == "","" || tok->strAt(-1) == ""::"")) {
            // We have found old style function, now we need to change it

            // First step: Get list of argument names in parentheses
            std::map<std::string, Token *> argumentNames;
            bool bailOut = false;
            const Token * tokparam = nullptr;

            //take count of the function name..
            const std::string& funcName(tok->str());

            //floating token used to check for parameters
            Token *tok1 = tok;

            while (nullptr != (tok1 = tok1->tokAt(2))) {
                if (!Token::Match(tok1, ""...",1,1,lib/tokenize.cpp,Tokenizer.simplifyFunctionParameters:void(),<empty>,,false,6770,6940,simplifyFunctionParameters,,,1,void()
111669153738,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyPointerToStandardType()
{
    if (!isC())
        return;

    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (!Token::Match(tok, ""& %name% [ 0 ] !![""))
            continue;

        if (!Token::Match(tok->previous(), ""[,(=]""))
            continue;

        // Remove '[ 0 ]' suffix
        Token::eraseTokens(tok->next(), tok->tokAt(5));
        // Remove '&' prefix
        tok = tok->previous();
        if (!tok)
            break;
        tok->deleteNext();
    }
}",1,1,lib/tokenize.cpp,Tokenizer.simplifyPointerToStandardType:void(),<empty>,,false,6942,6962,simplifyPointerToStandardType,,,1,void()
111669153739,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyFunctionPointers()
{
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        // #2873 - do not simplify function pointer usage here:
        // (void)(xy(*p)(0));
        if (Token::simpleMatch(tok, "") ("")) {
            tok = tok->linkAt(1);
            continue;
        }

        // check for function pointer cast
        if (Token::Match(tok, ""( %type% %type%| *| *| ( * ) ("") ||
            Token::Match(tok, ""static_cast < %type% %type%| *| *| ( * ) ("")) {
            Token *tok1 = tok;

            if (tok1->isCpp() && tok1->str() == ""static_cast"")
                tok1 = tok1->next();

            tok1 = tok1->next();

            if (Token::Match(tok1->next(), ""%type%""))
                tok1 = tok1->next();

            while (tok1->strAt(1) == ""*"")
                tok1 = tok1->next();

            // check that the cast ends
            if (!Token::Match(tok1->linkAt(4), "") )|>""))
                continue;

            // ok simplify this...",1,1,lib/tokenize.cpp,Tokenizer.simplifyFunctionPointers:void(),<empty>,,false,6964,7083,simplifyFunctionPointers,,,1,void()
111669153740,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyVarDecl(const bool only_k_r_fpar)
{
    simplifyVarDecl(list.front(), nullptr, only_k_r_fpar);
}",1,1,lib/tokenize.cpp,Tokenizer.simplifyVarDecl:void(bool),<empty>,,false,7085,7088,simplifyVarDecl,,,1,void(bool)
111669153741,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyVarDecl(Token * tokBegin, const Token * const tokEnd, const bool only_k_r_fpar)
{
    const bool cpp = isCPP();
    const bool isCPP11 = cpp && (mSettings.standards.cpp >= Standards::CPP11);

    // Split up variable declarations..
    // ""int a=4;"" => ""int a; a=4;""
    bool finishedwithkr = true;
    bool scopeDecl = false;
    for (Token *tok = tokBegin; tok != tokEnd; tok = tok->next()) {
        if (Token::Match(tok, ""{|;""))
            scopeDecl = false;
        if (cpp) {
            if (Token::Match(tok, ""class|struct|namespace|union""))
                scopeDecl = true;
            if (Token::Match(tok, ""decltype|noexcept ("")) {
                tok = tok->linkAt(1);
                // skip decltype(...){...}
                if (tok && Token::simpleMatch(tok->previous(), "") {""))
                    tok = tok->link();
            } else if (Token::simpleMatch(tok, ""= {"") ||
                       (!scopeDecl && Token::Match(tok, ""%name%|> {"") &&
        ...",1,1,lib/tokenize.cpp,"Tokenizer.simplifyVarDecl:void(Token*,Token*,bool)",<empty>,,false,7090,7449,simplifyVarDecl,,,1,"void(Token*,Token*,bool)"
111669153742,METHOD,<empty>,<empty>,"[&](const std::string& q) {
                    return q == leftTok->str();
                }",93,17,lib/tokenize.cpp,lib/tokenize.cpp:<global>.Tokenizer.simplifyStaticConst.<lambda>16:bool(std.string&),<empty>,,false,7471,7473,<lambda>16,,,1,bool(std.string&)
111669153743,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyStaticConst()
{
    // This function will simplify the token list so that the qualifiers ""extern"", ""static""
    // and ""const"" appear in the same order as in the array below.
    static const std::array<std::string, 3> qualifiers = {""extern"", ""static"", ""const""};

    // Move 'const' before all other qualifiers and types and then
    // move 'static' before all other qualifiers and types, ...
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        bool continue2 = false;
        for (std::size_t i = 0; i < qualifiers.size(); i++) {

            // Keep searching for a qualifier
            if (!tok->next() || tok->strAt(1) != qualifiers[i])
                continue;

            // Look backwards to find the beginning of the declaration
            Token* leftTok = tok;
            bool behindOther = false;
            for (; leftTok; leftTok = leftTok->previous()) {
                behindOther = std::any_of(qualifiers.cbegin(), qualifiers.cbegin...",1,1,lib/tokenize.cpp,Tokenizer.simplifyStaticConst:void(),<empty>,,false,7451,7515,simplifyStaticConst,,,1,void()
111669153744,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyVariableMultipleAssign()
{
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""%name% = %name% = %num%|%name% ;"")) {
            // skip intermediate assignments
            Token *tok2 = tok->previous();
            while (tok2 &&
                   tok2->str() == ""="" &&
                   Token::Match(tok2->previous(), ""%name%"")) {
                tok2 = tok2->tokAt(-2);
            }

            if (!tok2 || tok2->str() != "";"") {
                continue;
            }

            Token *stopAt = tok->tokAt(2);
            const Token *valueTok = stopAt->tokAt(2);
            const std::string& value(valueTok->str());
            tok2 = tok2->next();

            while (tok2 != stopAt) {
                tok2->next()->insertToken("";"");
                tok2->next()->insertToken(value);
                tok2 = tok2->tokAt(4);
            }
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.simplifyVariableMultipleAssign:void(),<empty>,,false,7517,7545,simplifyVariableMultipleAssign,,,1,void()
111669153745,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"bool Tokenizer::simplifyCAlternativeTokens()
{
    /* executable scope level */
    int executableScopeLevel = 0;

    std::vector<Token *> alt;
    bool replaceAll = false;  // replace all or none

    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (tok->str() == "")"") {
            if (const Token *end = TokenList::isFunctionHead(tok, ""{"")) {
                ++executableScopeLevel;
                tok = const_cast<Token *>(end);
                continue;
            }
        }

        if (tok->str() == ""{"") {
            if (executableScopeLevel > 0)
                ++executableScopeLevel;
            continue;
        }

        if (tok->str() == ""}"") {
            if (executableScopeLevel > 0)
                --executableScopeLevel;
            continue;
        }

        if (!tok->isName())
            continue;

        const auto cOpIt = utils::as_const(cAlternativeTokens).find(tok->str());
        if (cOpIt != cAlternativeTokens.end()) {
            a...",1,1,lib/tokenize.cpp,Tokenizer.simplifyCAlternativeTokens:bool(),<empty>,,false,7572,7656,simplifyCAlternativeTokens,,,1,bool()
111669153746,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyInitVar()
{
    if (isC())
        return;

    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (!tok->isName() || (tok->previous() && !Token::Match(tok->previous(), ""[;{}]"")))
            continue;

        if (tok->str() == ""return"")
            continue;

        if (Token::Match(tok, ""%type% *|&| %name% (|{"")) {
            while (tok && !Token::Match(tok, ""(|{""))
                tok = tok->next();
            if (tok)
                tok->isInitBracket(true);
            /* tok = initVar(tok);
               } else if (Token::Match(tok, ""%type% *| %name% ( %type% ("")) {
               const Token* tok2 = tok->tokAt(2);
               if (!tok2->link())
                tok2 = tok2->next();
               if (!tok2->link() || (tok2->link()->strAt(1) == "";"" && !Token::simpleMatch(tok2->linkAt(2), "") ("")))
                tok = initVar(tok);
               } else if (Token::Match(tok, ""class|struct|union| %type% *| %name% ( &| %any% ) ,""...",1,1,lib/tokenize.cpp,Tokenizer.simplifyInitVar:void(),<empty>,,false,7660,7695,simplifyInitVar,,,1,void()
111669153747,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"Token * Tokenizer::initVar(Token * tok)
{
    // call constructor of class => no simplification
    if (Token::Match(tok, ""class|struct|union"")) {
        if (tok->strAt(2) != ""*"")
            return tok;

        tok = tok->next();
    } else if (!tok->isStandardType() && tok->str() != ""auto"" && tok->strAt(1) != ""*"")
        return tok;

    // goto variable name..
    tok = tok->next();
    if (tok->str() == ""*"")
        tok = tok->next();

    // sizeof is not a variable name..
    if (tok->str() == ""sizeof"")
        return tok;

    // check initializer..
    if (tok->tokAt(2)->isStandardType() || tok->strAt(2) == ""void"")
        return tok;
    if (!tok->tokAt(2)->isNumber() && !Token::Match(tok->tokAt(2), ""%type% (|{"") && tok->strAt(2) != ""&"" && tok->tokAt(2)->varId() == 0)
        return tok;

    // insert '; var ='
    tok->insertToken("";"");
    tok->next()->insertToken(tok->str());
    tok->next()->isSplittedVarDeclEq(true);
    tok->tokAt(2)->varId(tok->varId());
    tok ...",1,1,lib/tokenize.cpp,Tokenizer.initVar:Token*(Token*),<empty>,,false,7697,7741,initVar,,,1,Token*(Token*)
111669153748,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::elseif()
{
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (tok->str() != ""else"")
            continue;

        if (!Token::Match(tok->previous(), "";|}""))
            syntaxError(tok->previous());

        if (!Token::Match(tok->next(), ""%name%""))
            continue;

        if (tok->strAt(1) != ""if"")
            unknownMacroError(tok->next());

        for (Token *tok2 = tok; tok2; tok2 = tok2->next()) {
            if (Token::Match(tok2, ""(|{|[""))
                tok2 = tok2->link();

            if (Token::Match(tok2, ""}|;"")) {
                if (tok2->next() && tok2->strAt(1) != ""else"") {
                    tok->insertToken(""{"");
                    tok2->insertToken(""}"");
                    Token::createMutualLinks(tok->next(), tok2->next());
                    break;
                }
            }
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.elseif:void(),<empty>,,false,7743,7772,elseif,,,1,void()
111669153749,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyIfSwitchForInit()
{
    if (!isCPP() || mSettings.standards.cpp < Standards::CPP17)
        return;

    const bool forInit = (mSettings.standards.cpp >= Standards::CPP20);

    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (!Token::Match(tok, ""if|switch|for (""))
            continue;

        Token *semicolon = tok->tokAt(2);
        while (!Token::Match(semicolon, ""[;)]"")) {
            if (Token::Match(semicolon, ""(|{|["") && semicolon->link())
                semicolon = semicolon->link();
            semicolon = semicolon->next();
        }
        if (semicolon->str() != "";"")
            continue;

        if (tok->str() ==  ""for"") {
            if (!forInit)
                continue;

            // Is it a for range..
            const Token *tok2 = semicolon->next();
            bool rangeFor = false;
            while (!Token::Match(tok2, ""[;)]"")) {
                if (tok2->str() == ""("")
                    tok2 = tok2->link()...",1,1,lib/tokenize.cpp,Tokenizer.simplifyIfSwitchForInit:void(),<empty>,,false,7775,7833,simplifyIfSwitchForInit,,,1,void()
111669153750,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"bool Tokenizer::simplifyRedundantParentheses()
{
    bool ret = false;
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (tok->str() != ""("")
            continue;

        if (tok->isCpp() && Token::simpleMatch(tok->previous(), ""} ("")) {
            const Token* plp = tok->linkAt(-1)->previous();
            if (Token::Match(plp, ""%name%|>|] {"") || (Token::simpleMatch(plp, "")"") && Token::simpleMatch(plp->link()->previous(), ""]"")))
                continue;
        }

        if (Token::simpleMatch(tok, ""( {""))
            continue;

        if (Token::Match(tok->link(), "") %num%"")) {
            tok = tok->link();
            continue;
        }

        // Do not simplify if there is comma inside parentheses..
        if (Token::Match(tok->previous(), ""%op% ("") || Token::Match(tok->link(), "") %op%"")) {
            bool innerComma = false;
            for (const Token *inner = tok->link()->previous(); inner != tok; inner = inner->previous()) {
                ...",1,1,lib/tokenize.cpp,Tokenizer.simplifyRedundantParentheses:bool(),<empty>,,false,7836,7994,simplifyRedundantParentheses,,,1,bool()
111669153751,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyTypeIntrinsics()
{
    static const std::unordered_map<std::string, std::string> intrinsics = {
        { ""__has_nothrow_assign"", ""has_nothrow_assign"" },
        { ""__has_nothrow_constructor"", ""has_nothrow_constructor"" },
        { ""__has_nothrow_copy"", ""has_nothrow_copy"" },
        { ""__has_trivial_assign"", ""has_trivial_assign"" },
        { ""__has_trivial_constructor"", ""has_trivial_constructor"" },
        { ""__has_trivial_copy"", ""has_trivial_copy"" },
        { ""__has_trivial_destructor"", ""has_trivial_destructor"" },
        { ""__has_virtual_destructor"", ""has_virtual_destructor"" },
        { ""__is_abstract"", ""is_abstract"" },
        { ""__is_aggregate"", ""is_aggregate"" },
        { ""__is_assignable"", ""is_assignable"" },
        { ""__is_base_of"", ""is_base_of"" },
        { ""__is_class"", ""is_class"" },
        { ""__is_constructible"", ""is_constructible"" },
        { ""__is_convertible_to"", ""is_convertible_to"" },
        { ""__is_destructible"", ""is_destructible"" },
     ...",1,1,lib/tokenize.cpp,Tokenizer.simplifyTypeIntrinsics:void(),<empty>,,false,7996,8044,simplifyTypeIntrinsics,,,1,void()
111669153752,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"bool Tokenizer::isScopeNoReturn(const Token *endScopeToken, bool *unknown) const
{
    std::string unknownFunc;
    const bool ret = mSettings.library.isScopeNoReturn(endScopeToken,&unknownFunc);
    if (!unknownFunc.empty() && mSettings.summaryReturn.find(unknownFunc) != mSettings.summaryReturn.end()) {
        return false;
    }
    if (unknown)
        *unknown = !unknownFunc.empty();
    if (!unknownFunc.empty() && mSettings.checkLibrary) {
        bool warn = true;
        if (Token::simpleMatch(endScopeToken->tokAt(-2), "") ; }"")) {
            const Token * const ftok = endScopeToken->linkAt(-2)->previous();
            if (ftok && (ftok->type() || ftok->function() || ftok->variable())) // constructor call
                warn = false;
        }

        if (warn) {
            reportError(endScopeToken->previous(),
                        Severity::information,
                        ""checkLibraryNoReturn"",
                        ""--check-library: Function "" + unknownFunc ...",1,1,lib/tokenize.cpp,"Tokenizer.isScopeNoReturn<const>:bool(Token*,bool*)",<empty>,,false,8052,8077,isScopeNoReturn,,,1,"bool(Token*,bool*)"
111669153753,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::syntaxError(const Token *tok, const std::string &code) const
{
    printDebugOutput(0, std::cout);
    throw InternalError(tok, code.empty() ? ""syntax error"" : ""syntax error: "" + code, InternalError::SYNTAX);
}",1,1,lib/tokenize.cpp,"Tokenizer.syntaxError<const>:void(Token*,std.string&)",<empty>,,false,8081,8085,syntaxError,,,1,"void(Token*,std.string&)"
111669153754,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::unmatchedToken(const Token *tok) const
{
    printDebugOutput(0, std::cout);
    throw InternalError(tok,
                        ""Unmatched '"" + tok->str() + ""'. Configuration: '"" + mConfiguration + ""'."",
                        InternalError::SYNTAX);
}",1,1,lib/tokenize.cpp,Tokenizer.unmatchedToken<const>:void(Token*),<empty>,,false,8087,8093,unmatchedToken,,,1,void(Token*)
111669153755,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::syntaxErrorC(const Token *tok, const std::string &what) const
{
    printDebugOutput(0, std::cout);
    throw InternalError(tok, ""Code '""+what+""' is invalid C code."", ""Use --std, -x or --language to enforce C++. Or --cpp-header-probe to identify C++ headers via the Emacs marker."", InternalError::SYNTAX);
}",1,1,lib/tokenize.cpp,"Tokenizer.syntaxErrorC<const>:void(Token*,std.string&)",<empty>,,false,8095,8099,syntaxErrorC,,,1,"void(Token*,std.string&)"
111669153756,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::unknownMacroError(const Token *tok1) const
{
    printDebugOutput(0, std::cout);
    throw InternalError(tok1, ""There is an unknown macro here somewhere. Configuration is required. If "" + tok1->str() + "" is a macro then please configure it."", InternalError::UNKNOWN_MACRO);
}",1,1,lib/tokenize.cpp,Tokenizer.unknownMacroError<const>:void(Token*),<empty>,,false,8101,8105,unknownMacroError,,,1,void(Token*)
111669153757,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::unhandled_macro_class_x_y(const Token *tok, const std::string& type, const std::string& x, const std::string& y, const std::string& bracket) const
{
    reportError(tok,
                Severity::information,
                ""class_X_Y"",
                ""The code '"" +
                type + "" "" +
                x + "" "" +
                y + "" "" +
                bracket + ""' is not handled. You can use -I or --include to add handling of this code."");
}",1,1,lib/tokenize.cpp,"Tokenizer.unhandled_macro_class_x_y<const>:void(Token*,std.string&,std.string&,std.string&,std.string&)",<empty>,,false,8107,8117,unhandled_macro_class_x_y,,,1,"void(Token*,std.string&,std.string&,std.string&,std.string&)"
111669153758,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::macroWithSemicolonError(const Token *tok, const std::string &macroName) const
{
    reportError(tok,
                Severity::information,
                ""macroWithSemicolon"",
                ""Ensure that '"" + macroName + ""' is defined either using -I, --include or -D."");
}",1,1,lib/tokenize.cpp,"Tokenizer.macroWithSemicolonError<const>:void(Token*,std.string&)",<empty>,,false,8119,8125,macroWithSemicolonError,,,1,"void(Token*,std.string&)"
111669153759,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::invalidConstFunctionTypeError(const Token *tok) const
{
    reportError(tok,
                Severity::portability,
                ""invalidConstFunctionType"",
                ""It is unspecified behavior to const qualify a function type."");
}",1,1,lib/tokenize.cpp,Tokenizer.invalidConstFunctionTypeError<const>:void(Token*),<empty>,,false,8127,8133,invalidConstFunctionTypeError,,,1,void(Token*)
111669153760,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::cppcheckError(const Token *tok) const
{
    printDebugOutput(0, std::cout);
    throw InternalError(tok, ""Analysis failed. If the code is valid then please report this failure."", InternalError::INTERNAL);
}",1,1,lib/tokenize.cpp,Tokenizer.cppcheckError<const>:void(Token*),<empty>,,false,8135,8139,cppcheckError,,,1,void(Token*)
111669153761,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::unhandledCharLiteral(const Token *tok, const std::string& msg) const
{
    std::string s = tok ? ("" "" + tok->str()) : """";
    for (std::size_t i = 0; i < s.size(); ++i) {
        if ((unsigned char)s[i] >= 0x80)
            s.clear();
    }

    reportError(tok,
                Severity::portability,
                ""nonStandardCharLiteral"",
                ""Non-standard character literal"" + s + "". "" + msg);
}",1,1,lib/tokenize.cpp,"Tokenizer.unhandledCharLiteral<const>:void(Token*,std.string&)",<empty>,,false,8141,8153,unhandledCharLiteral,,,1,"void(Token*,std.string&)"
111669153762,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static bool isNumberOneOf(const std::string &s, MathLib::bigint intConstant, const char* floatConstant)
{
    if (MathLib::isInt(s)) {
        if (MathLib::toBigNumber(s) == intConstant)
            return true;
    } else if (MathLib::isFloat(s)) {
        if (MathLib::toString(MathLib::toDoubleNumber(s)) == floatConstant)
            return true;
    }
    return false;
}",1,1,lib/tokenize.cpp,"isNumberOneOf:bool(std.string&,MathLib.bigint,char*)",<empty>,,false,8163,8173,isNumberOneOf,,,1,"bool(std.string&,MathLib.bigint,char*)"
111669153763,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"bool Tokenizer::isOneNumber(const std::string &s)
{
    if (!MathLib::isPositive(s))
        return false;
    return isNumberOneOf(s, 1L, ""1.0"");
}",1,1,lib/tokenize.cpp,Tokenizer.isOneNumber:bool(std.string&),<empty>,,false,8180,8185,isOneNumber,,,1,bool(std.string&)
111669153764,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::checkConfiguration() const
{
    if (!mSettings.checkConfiguration)
        return;
    for (const Token *tok = tokens(); tok; tok = tok->next()) {
        if (!Token::Match(tok, ""%name% (""))
            continue;
        if (tok->isControlFlowKeyword())
            continue;
        for (const Token *tok2 = tok->tokAt(2); tok2 && tok2->str() != "")""; tok2 = tok2->next()) {
            if (tok2->str() == "";"") {
                macroWithSemicolonError(tok, tok->str());
                break;
            }
            if (Token::Match(tok2, ""(|{""))
                tok2 = tok2->link();
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.checkConfiguration<const>:void(),<empty>,,false,8187,8205,checkConfiguration,,,1,void()
111669153765,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::validateC() const
{
    if (isCPP())
        return;
    for (const Token *tok = tokens(); tok; tok = tok->next()) {
        // That might trigger false positives, but it's much faster to have this truncated pattern
        if (Token::Match(tok, ""const_cast|dynamic_cast|reinterpret_cast|static_cast <""))
            syntaxErrorC(tok, ""C++ cast <..."");
        // Template function..
        if (Token::Match(tok, ""%name% < %name% > ("")) {
            const Token *tok2 = tok->tokAt(5);
            while (tok2 && !Token::Match(tok2, ""[()]""))
                tok2 = tok2->next();
            if (Token::simpleMatch(tok2, "") {""))
                syntaxErrorC(tok, tok->str() + '<' + tok->strAt(2) + "">() {}"");
        }
        if (tok->previous() && !Token::Match(tok->previous(), ""[;{}]""))
            continue;
        if (Token::Match(tok, ""using namespace %name% ;""))
            syntaxErrorC(tok, ""using namespace "" + tok->strAt(2));
        if (Token::Match(tok, ""template < ...",1,1,lib/tokenize.cpp,Tokenizer.validateC<const>:void(),<empty>,,false,8207,8234,validateC,,,1,void()
111669153766,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::validate() const
{
    std::stack<const Token *> linkTokens;
    const Token *lastTok = nullptr;
    for (const Token *tok = tokens(); tok; tok = tok->next()) {
        lastTok = tok;
        if (Token::Match(tok, ""[{([]"") || (tok->str() == ""<"" && tok->link())) {
            if (tok->link() == nullptr)
                cppcheckError(tok);

            linkTokens.push(tok);
        }

        else if (Token::Match(tok, ""[})]]"") || (Token::Match(tok, "">|>>"") && tok->link())) {
            if (tok->link() == nullptr)
                cppcheckError(tok);

            if (linkTokens.empty())
                cppcheckError(tok);

            if (tok->link() != linkTokens.top())
                cppcheckError(tok);

            if (tok != tok->link()->link())
                cppcheckError(tok);

            linkTokens.pop();
        }

        else if (tok->link() != nullptr)
            cppcheckError(tok);
    }

    if (!linkTokens.empty())
        cppcheckError(linkTokens.to...",1,1,lib/tokenize.cpp,Tokenizer.validate<const>:void(),<empty>,,false,8236,8275,validate,,,1,void()
111669153767,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static const Token *findUnmatchedTernaryOp(const Token * const begin, const Token * const end, int depth = 0)
{
    std::stack<const Token *> ternaryOp;
    for (const Token *tok = begin; tok != end && tok->str() != "";""; tok = tok->next()) {
        if (tok->str() == ""?"")
            ternaryOp.push(tok);
        else if (!ternaryOp.empty() && tok->str() == "":"")
            ternaryOp.pop();
        else if (depth < 100 && Token::Match(tok,""(|["")) {
            const Token *inner = findUnmatchedTernaryOp(tok->next(), tok->link(), depth+1);
            if (inner)
                return inner;
            tok = tok->link();
        }
    }
    return ternaryOp.empty() ? nullptr : ternaryOp.top();
}",1,1,lib/tokenize.cpp,"findUnmatchedTernaryOp:Token*(Token*,Token*,int)",<empty>,,false,8277,8293,findUnmatchedTernaryOp,,,1,"Token*(Token*,Token*,int)"
111669153768,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static bool isCPPAttribute(const Token * tok)
{
    return Token::simpleMatch(tok, ""[ ["") && tok->link() && tok->link()->previous() == tok->linkAt(1);
}",1,1,lib/tokenize.cpp,isCPPAttribute:bool(Token*),<empty>,,false,8295,8298,isCPPAttribute,,,1,bool(Token*)
111669153769,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static bool isAlignAttribute(const Token * tok)
{
    return Token::simpleMatch(tok, ""alignas ("") && tok->linkAt(1);
}",1,1,lib/tokenize.cpp,isAlignAttribute:bool(Token*),<empty>,,false,8300,8303,isAlignAttribute,,,1,bool(Token*)
111669153770,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static T* skipCPPOrAlignAttribute(T * tok)
{
    if (isCPPAttribute(tok))
        return tok->link();
    if (isAlignAttribute(tok)) {
        return tok->linkAt(1);
    }
    return tok;
}",1,1,lib/tokenize.cpp,skipCPPOrAlignAttribute:T(T*),<empty>,,false,8306,8314,skipCPPOrAlignAttribute,,,1,T(T*)
111669153771,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static bool isNonMacro(const Token* tok)
{
    if (tok->isKeyword() || tok->isStandardType())
        return true;
    if (cAlternativeTokens.count(tok->str()) > 0)
        return true;
    if (startsWith(tok->str(), ""__"")) // attribute/annotation
        return true;
    if (Token::simpleMatch(tok, ""alignas (""))
        return true;
    return false;
}",1,1,lib/tokenize.cpp,isNonMacro:bool(Token*),<empty>,,false,8316,8327,isNonMacro,,,1,bool(Token*)
111669153772,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::reportUnknownMacros() const
{
    // Report unknown macros used in expressions ""%name% %num%""
    for (const Token *tok = tokens(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""%name% %num%"")) {
            // A keyword is not an unknown macro
            if (tok->isKeyword())
                continue;

            if (Token::Match(tok->previous(), ""%op%|(""))
                unknownMacroError(tok);
        }
    }

    // Report unknown macros before } ""{ .. if (x) MACRO }""
    for (const Token *tok = tokens(); tok; tok = tok->next()) {
        if (Token::Match(tok, "")|; %name% } !!)"")) {
            if (tok->link() && !Token::simpleMatch(tok->link()->tokAt(-1), ""if""))
                continue;
            const Token* prev = tok->linkAt(2);
            while (Token::simpleMatch(prev, ""{""))
                prev = prev->previous();
            if (Token::Match(prev, "";|)""))
                unknownMacroError(tok->next());
        }
    }

    // Report unkn...",1,1,lib/tokenize.cpp,Tokenizer.reportUnknownMacros<const>:void(),<empty>,,false,8329,8468,reportUnknownMacros,,,1,void()
111669153773,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::findGarbageCode() const
{
    const bool cpp = isCPP();
    const bool isCPP11 = cpp && mSettings.standards.cpp >= Standards::CPP11;

    static const std::unordered_set<std::string> nonConsecutiveKeywords{ ""break"",
                                                                         ""continue"",
                                                                         ""for"",
                                                                         ""goto"",
                                                                         ""if"",
                                                                         ""return"",
                                                                         ""switch"",
                                                                         ""throw"",
                                                                         ""typedef"",
                                                                         ""while"" };

    for (const Token *t...",1,1,lib/tokenize.cpp,Tokenizer.findGarbageCode<const>:void(),<empty>,,false,8470,8919,findGarbageCode,,,1,void()
111669153774,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"bool Tokenizer::isGarbageExpr(const Token *start, const Token *end, bool allowSemicolon)
{
    for (const Token *tok = start; tok != end; tok = tok->next()) {
        if (tok->isControlFlowKeyword())
            return true;
        if (!allowSemicolon && tok->str() == "";"")
            return true;
        if (tok->str() == ""{"")
            tok = tok->link();
    }
    return false;
}",1,1,lib/tokenize.cpp,"Tokenizer.isGarbageExpr:bool(Token*,Token*,bool)",<empty>,,false,8922,8933,isGarbageExpr,,,1,"bool(Token*,Token*,bool)"
111669153775,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"std::string Tokenizer::simplifyString(const std::string &source)
{
    std::string str = source;

    for (std::string::size_type i = 0; i + 1U < str.size(); ++i) {
        if (str[i] != '\\\\')
            continue;

        int c = 'a';   // char
        int sz = 0;    // size of stringdata
        if (str[i+1] == 'x') {
            sz = 2;
            while (sz < 4 && std::isxdigit((unsigned char)str[i+sz]))
                sz++;
            if (sz > 2) {
                std::istringstream istr(str.substr(i+2, sz-2));
                istr >> std::hex >> c;
            }
        } else if (MathLib::isOctalDigit(str[i+1])) {
            sz = 2;
            while (sz < 4 && MathLib::isOctalDigit(str[i+sz]))
                sz++;
            std::istringstream istr(str.substr(i+1, sz-1));
            istr >> std::oct >> c;
            str = str.replace(i, sz, std::string(1U, (char)c));
            continue;
        }

        if (sz <= 2)
            i++;
        else if (i+sz < str.si...",1,1,lib/tokenize.cpp,Tokenizer.simplifyString:string(std.string&),<empty>,,false,8935,8972,simplifyString,,,1,string(std.string&)
111669153776,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyFunctionTryCatch()
{
    if (!isCPP())
        return;

    for (Token * tok = list.front(); tok; tok = tok->next()) {
        if (!Token::Match(tok, ""try {|:""))
            continue;
        if (!TokenList::isFunctionHead(tok->previous(), ""try"")) // TODO: this is supposed to a list of characters and not strings
            continue;

        Token* tryStartToken = skipInitializerList(tok->next());

        if (!Token::simpleMatch(tryStartToken, ""{""))
            syntaxError(tryStartToken, ""Invalid function-try-catch block code. Did not find '{' for try body."");

        // find the end of the last catch block
        Token * const tryEndToken = tryStartToken->link();
        Token * endToken = tryEndToken;
        while (Token::simpleMatch(endToken, ""} catch ("")) {
            endToken = endToken->linkAt(2)->next();
            if (!endToken)
                break;
            if (endToken->str() != ""{"") {
                endToken = nullptr;
                ...",1,1,lib/tokenize.cpp,Tokenizer.simplifyFunctionTryCatch:void(),<empty>,,false,8974,9010,simplifyFunctionTryCatch,,,1,void()
111669153777,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static bool isAnonymousEnum(const Token* tok)
{
    if (!Token::Match(tok, ""enum {|:""))
        return false;
    if (tok->index() > 2 && Token::Match(tok->tokAt(-3), ""using %name% =""))
        return false;
    const Token* end = tok->next();
    if (end->str() == "":"") {
        end = end->next();
        while (Token::Match(end, ""%name%|::""))
            end = end->next();
    }
    return end && Token::Match(end->link(), ""} (| %type%| )| [,;[({=]"");
}",1,1,lib/tokenize.cpp,isAnonymousEnum:bool(Token*),<empty>,,false,9012,9025,isAnonymousEnum,,,1,bool(Token*)
111669153778,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyStructDecl()
{
    const bool cpp = isCPP();

    // A counter that is used when giving unique names for anonymous structs.
    int count = 0;

    // Add names for anonymous structs
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (!tok->isName())
            continue;
        // check for anonymous struct/union
        if (Token::Match(tok, ""struct|union {"")) {
            if (Token::Match(tok->linkAt(1), ""} const| *|&| const| %type% ,|;|[|(|{|="")) {
                tok->insertToken(""Anonymous"" + std::to_string(count++));
            }
        }
        // check for derived anonymous class/struct
        else if (cpp && Token::Match(tok, ""class|struct :"")) {
            const Token *tok1 = Token::findsimplematch(tok, ""{"");
            if (tok1 && Token::Match(tok1->link(), ""} const| *|&| const| %type% ,|;|[|(|{"")) {
                tok->insertToken(""Anonymous"" + std::to_string(count++));
            }
        }
        // check for a...",1,1,lib/tokenize.cpp,Tokenizer.simplifyStructDecl:void(),<empty>,,false,9027,9173,simplifyStructDecl,,,1,void()
111669153779,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyCallingConvention()
{
    const bool windows = mSettings.platform.isWindows();

    for (Token *tok = list.front(); tok; tok = tok->next()) {
        while (Token::Match(tok, ""__cdecl|__stdcall|__fastcall|__thiscall|__clrcall|__syscall|__pascal|__fortran|__far|__near"") || (windows && Token::Match(tok, ""WINAPI|APIENTRY|CALLBACK""))) {
            tok->deleteThis();
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.simplifyCallingConvention:void(),<empty>,,false,9175,9184,simplifyCallingConvention,,,1,void()
111669153780,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static bool isAttribute(const Token* tok, bool gcc) {
    return gcc ? Token::Match(tok, ""__attribute__|__attribute ("") : Token::Match(tok, ""__declspec|_declspec ("");
}",1,1,lib/tokenize.cpp,"isAttribute:bool(Token*,bool)",<empty>,,false,9186,9188,isAttribute,,,1,"bool(Token*,bool)"
111669153781,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static Token* getTokenAfterAttributes(Token* tok, bool gccattr) {
    Token* after = tok;
    while (isAttribute(after, gccattr))
        after = after->linkAt(1)->next();
    return after;
}",1,1,lib/tokenize.cpp,"getTokenAfterAttributes:Token*(Token*,bool)",<empty>,,false,9190,9195,getTokenAfterAttributes,,,1,"Token*(Token*,bool)"
111669153782,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static Token* getVariableTokenAfterAttributes(Token* tok) {
    Token *vartok = nullptr;
    Token *after = getTokenAfterAttributes(tok, true);

    // check if after variable name
    if (Token::Match(after, "";|="")) {
        Token *prev = tok->previous();
        while (Token::simpleMatch(prev, ""]""))
            prev = prev->link()->previous();
        if (Token::Match(prev, ""%type%""))
            vartok = prev;
    }

    // check if before variable name
    else if (Token::Match(after, ""%type%""))
        vartok = after;

    return vartok;
}",1,1,lib/tokenize.cpp,getVariableTokenAfterAttributes:Token*(Token*),<empty>,,false,9197,9215,getVariableTokenAfterAttributes,,,1,Token*(Token*)
111669153783,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"Token* Tokenizer::getAttributeFuncTok(Token* tok, bool gccattr) const {
    if (!Token::Match(tok, ""%name% (""))
        return nullptr;
    Token* const after = getTokenAfterAttributes(tok, gccattr);
    if (!after)
        syntaxError(tok);

    if (Token::Match(after, ""%name%|*|&|("")) {
        Token *ftok = after;
        while (Token::Match(ftok, ""%name%|::|<|*|& !!("")) {
            if (ftok->str() == ""<"") {
                ftok = ftok->findClosingBracket();
                if (!ftok)
                    break;
            }
            ftok = ftok->next();
        }
        if (Token::simpleMatch(ftok, ""( *""))
            ftok = ftok->tokAt(2);
        if (Token::Match(ftok, ""%name% (|)""))
            return ftok;
    } else if (Token::Match(after, ""[;{=:]"")) {
        Token *prev = tok->previous();
        while (Token::Match(prev, ""%name%""))
            prev = prev->previous();
        if (Token::simpleMatch(prev, "")"")) {
            if (Token::Match(prev->link()->previous()...",1,1,lib/tokenize.cpp,"Tokenizer.getAttributeFuncTok<const>:Token*(Token*,bool)",<empty>,,false,9217,9254,getAttributeFuncTok,,,1,"Token*(Token*,bool)"
111669153784,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyDeclspec()
{
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        while (isAttribute(tok, false)) {
            if (Token::Match(tok->tokAt(2), ""noreturn|nothrow|dllexport"")) {
                Token *functok = getAttributeFuncTok(tok, false);
                if (functok) {
                    if (tok->strAt(2) == ""noreturn"")
                        functok->isAttributeNoreturn(true);
                    else if (tok->strAt(2) == ""nothrow"")
                        functok->isAttributeNothrow(true);
                    else
                        functok->isAttributeExport(true);
                }
            } else if (tok->strAt(2) == ""property"")
                tok->linkAt(1)->insertToken(""__property"");

            Token::eraseTokens(tok, tok->linkAt(1)->next());
            tok->deleteThis();
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.simplifyDeclspec:void(),<empty>,,false,9256,9277,simplifyDeclspec,,,1,void()
111669153785,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyAttribute()
{
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (!tok->isKeyword() && Token::Match(tok, ""%type% ("") && !mSettings.library.isNotLibraryFunction(tok)) {
            if (mSettings.library.isFunctionConst(tok->str(), true))
                tok->isAttributePure(true);
            if (mSettings.library.isFunctionConst(tok->str(), false))
                tok->isAttributeConst(true);
        }
        while (isAttribute(tok, true)) {
            Token *functok = getAttributeFuncTok(tok, true);

            for (Token *attr = tok->tokAt(2); attr->str() != "")""; attr = attr->next()) {
                if (Token::Match(attr, ""%name% (""))
                    attr = attr->linkAt(1);

                if (Token::Match(attr, ""[(,] constructor|__constructor__ [,()]"")) {
                    if (!functok)
                        syntaxError(tok);
                    functok->isAttributeConstructor(true);
                }

                el...",1,1,lib/tokenize.cpp,Tokenizer.simplifyAttribute:void(),<empty>,,false,9279,9354,simplifyAttribute,,,1,void()
111669153786,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyCppcheckAttribute()
{
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (tok->str() != ""("")
            continue;
        if (!tok->previous())
            continue;
        const std::string &attr = tok->strAt(-1);
        if (!startsWith(attr, ""__cppcheck_""))
            continue;
        if (attr.compare(attr.size()-2, 2, ""__"") != 0) // TODO: ends_with(""__"")
            continue;

        Token *vartok = tok->link();
        while (Token::Match(vartok->next(), ""%name%|*|&|::"")) {
            vartok = vartok->next();
            if (Token::Match(vartok, ""%name% ("") && startsWith(vartok->str(),""__cppcheck_""))
                vartok = vartok->linkAt(1);
        }

        if (vartok->isName()) {
            if (Token::Match(tok->previous(), ""__cppcheck_low__ ( %num% )""))
                vartok->setCppcheckAttribute(TokenImpl::CppcheckAttributes::Type::LOW,
                                             MathLib::toBigNumber(tok->tokAt(1)))...",1,1,lib/tokenize.cpp,Tokenizer.simplifyCppcheckAttribute:void(),<empty>,,false,9356,9395,simplifyCppcheckAttribute,,,1,void()
111669153787,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyCPPAttribute()
{
    // According to cppreference alignas is a c21 feature however the macro is often available when compiling c11
    const bool hasAlignas = ((isCPP() && mSettings.standards.cpp >= Standards::CPP11) || (isC() && mSettings.standards.c >= Standards::C11));
    const bool hasCppAttribute = ((isCPP() && mSettings.standards.cpp >= Standards::CPP11) || (isC() && mSettings.standards.c >= Standards::C23));
    const bool hasMaybeUnused =((isCPP() && mSettings.standards.cpp >= Standards::CPP17) || (isC() && mSettings.standards.c >= Standards::C23));
    const bool hasMaybeUnusedUnderscores = (isC() && mSettings.standards.c >= Standards::C23);

    if (!hasAlignas && !hasCppAttribute)
        return;

    for (Token *tok = list.front(); tok;) {
        if (!isCPPAttribute(tok) && !isAlignAttribute(tok)) {
            tok = tok->next();
            continue;
        }
        if (isCPPAttribute(tok)) {
            if (!hasCppAttribute) {
              ...",1,1,lib/tokenize.cpp,Tokenizer.simplifyCPPAttribute:void(),<empty>,,false,9397,9503,simplifyCPPAttribute,,,1,void()
111669153788,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifySpaceshipOperator()
{
    if (isCPP() && mSettings.standards.cpp >= Standards::CPP20) {
        for (Token *tok = list.front(); tok && tok->next(); tok = tok->next()) {
            if (Token::simpleMatch(tok, ""<= >"")) {
                tok->str(""<=>"");
                tok->deleteNext();
            }
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.simplifySpaceshipOperator:void(),<empty>,,false,9505,9515,simplifySpaceshipOperator,,,1,void()
111669153789,METHOD,<empty>,<empty>,"[tok]() {
                std::vector<Token*> ret;
                for (Token *temp = tok; Token::Match(temp, ""%name%""); temp = temp->previous()) {
                    if (!temp->isKeyword())
                        ret.emplace_back(temp);
                }
                for (Token *temp = tok->next(); Token::Match(temp, ""%name%""); temp = temp->next()) {
                    if (!temp->isKeyword())
                        ret.emplace_back(temp);
                }
                return ret;
            }",34,13,lib/tokenize.cpp,lib/tokenize.cpp:<global>.Tokenizer.simplifyKeyword.<lambda>17:ANY(),<empty>,,false,9572,9583,<lambda>17,,,1,ANY()
111669153790,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyKeyword()
{
    // FIXME: There is a risk that ""keywords"" are removed by mistake. This
    // code should be fixed so it doesn't remove variables etc. Nonstandard
    // keywords should be defined with a library instead. For instance the
    // linux kernel code at least uses ""_inline"" as struct member name at some
    // places.

    const bool c99 = isC() && mSettings.standards.c >= Standards::C99;
    const bool cpp11 = isCPP() && mSettings.standards.cpp >= Standards::CPP11;
    const bool cpp20 = isCPP() && mSettings.standards.cpp >= Standards::CPP20;

    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (keywords.find(tok->str()) != keywords.end()) {
            // Don't remove struct members
            if (!Token::simpleMatch(tok->previous(), ""."")) {
                const bool isinline = (tok->str().find(""inline"") != std::string::npos);
                const bool isrestrict = (tok->str().find(""restrict"") != std::string::npos);
     ...",1,1,lib/tokenize.cpp,Tokenizer.simplifyKeyword:void(),<empty>,,false,9531,9656,simplifyKeyword,,,1,void()
111669153791,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static Token* setTokenDebug(Token* start, TokenDebug td)
{
    if (!start->link())
        return nullptr;
    Token* end = start->link();
    start->deleteThis();
    for (Token* tok = start; tok != end; tok = tok->next()) {
        tok->setTokenDebug(td);
    }
    end->deleteThis();
    return end;
}",1,1,lib/tokenize.cpp,"setTokenDebug:Token*(Token*,TokenDebug)",<empty>,,false,9658,9669,setTokenDebug,,,1,"Token*(Token*,TokenDebug)"
111669153792,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyDebug()
{
    if (!mSettings.debugnormal && !mSettings.debugwarnings)
        return;
    static const std::unordered_map<std::string, TokenDebug> m = {{""debug_valueflow"", TokenDebug::ValueFlow},
        {""debug_valuetype"", TokenDebug::ValueType}};
    for (Token* tok = list.front(); tok; tok = tok->next()) {
        if (!Token::Match(tok, ""%name% (""))
            continue;
        auto it = m.find(tok->str());
        if (it != m.end()) {
            tok->deleteThis();
            tok = setTokenDebug(tok, it->second);
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.simplifyDebug:void(),<empty>,,false,9671,9686,simplifyDebug,,,1,void()
111669153793,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyAssignmentBlock()
{
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""[;{}] %name% = ( {"")) {
            const std::string &varname = tok->strAt(1);

            // goto the ""} )""
            int indentlevel = 0;
            Token *tok2 = tok;
            while (nullptr != (tok2 = tok2->next())) {
                if (Token::Match(tok2, ""(|{""))
                    ++indentlevel;
                else if (Token::Match(tok2, "")|}"")) {
                    if (indentlevel <= 2)
                        break;
                    --indentlevel;
                } else if (indentlevel == 2 && tok2->str() == varname && Token::Match(tok2->previous(), ""%type%|*""))
                    // declaring variable in inner scope with same name as lhs variable
                    break;
            }
            if (indentlevel == 2 && Token::simpleMatch(tok2, ""} )"")) {
                tok2 = tok2->tokAt(-3);
                if (Token::Ma...",1,1,lib/tokenize.cpp,Tokenizer.simplifyAssignmentBlock:void(),<empty>,,false,9688,9720,simplifyAssignmentBlock,,,1,void()
111669153794,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyAsm()
{
    std::string instruction;
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""__asm|_asm|asm {"") &&
            tok->linkAt(1)->next()) {
            instruction = tok->tokAt(2)->stringifyList(tok->linkAt(1));
            Token::eraseTokens(tok, tok->linkAt(1)->next());
        }

        else if (Token::Match(tok, ""asm|__asm|__asm__ volatile|__volatile|__volatile__| ("")) {
            // Goto ""(""
            Token *partok = tok->next();
            if (partok->str() != ""("")
                partok = partok->next();
            instruction = partok->next()->stringifyList(partok->link());
            Token::eraseTokens(tok, partok->link()->next());
        }

        else if (Token::Match(tok, ""_asm|__asm"")) {
            Token *endasm = tok->next();
            const Token *firstSemiColon = nullptr;
            int comment = 0;
            while (Token::Match(endasm, ""%num%|%name%|,|:|;"") || (endasm && endasm...",1,1,lib/tokenize.cpp,Tokenizer.simplifyAsm:void(),<empty>,,false,9723,9803,simplifyAsm,,,1,void()
111669153795,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyAsm2()
{
    // Block declarations: ^{}
    // A C extension used to create lambda like closures.

    // Put ^{} statements in asm()
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (tok->str() != ""^"")
            continue;

        if (Token::simpleMatch(tok, ""^ {"") || (Token::simpleMatch(tok->linkAt(1), "") {"") && tok->strAt(-1) != ""operator"")) {
            Token * start = tok;
            while (start && !Token::Match(start, ""[,(;{}=]"")) {
                if (start->link() && Token::Match(start, "")|]|>""))
                    start = start->link();
                start = start->previous();
            }

            const Token *last = tok->linkAt(1);
            if (Token::simpleMatch(last, "") {""))
                last = last->linkAt(1);
            last = last->next();
            while (last && !Token::Match(last, ""%cop%|,|;|{|}|)"")) {
                if (Token::Match(last, ""(|[""))
                    last = last->link();
      ...",1,1,lib/tokenize.cpp,Tokenizer.simplifyAsm2:void(),<empty>,,false,9805,9851,simplifyAsm2,,,1,void()
111669153796,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyAt()
{
    std::set<std::string> var;

    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""%name%|]|) @ %num%|%name%|%str%|("")) {
            const Token *end = tok->tokAt(2);
            if (end->isLiteral())
                end = end->next();
            else if (end->str() == ""("") {
                int par = 0;
                while ((end = end->next()) != nullptr) {
                    if (end->str() == ""("")
                        par++;
                    else if (end->str() == "")"") {
                        if (--par < 0)
                            break;
                    }
                }
                end = end ? end->next() : nullptr;
            } else if (var.find(end->str()) != var.end())
                end = end->next();
            else
                continue;

            if (Token::Match(end, "": %num% ;""))
                end = end->tokAt(2);

            if (Token::Match(end, ""[;=]"")) {
  ...",1,1,lib/tokenize.cpp,Tokenizer.simplifyAt:void(),<empty>,,false,9853,9896,simplifyAt,,,1,void()
111669153797,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyBitfields()
{
    bool goback = false;
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (goback) {
            goback = false;
            tok = tok->previous();
        }
        Token *last = nullptr;

        if (Token::simpleMatch(tok, ""for (""))
            tok = tok->linkAt(1);

        if (!Token::Match(tok, "";|{|}|public:|protected:|private:""))
            continue;

        bool isEnum = false;
        if (tok->str() == ""}"") {
            const Token *type = tok->link()->previous();
            while (type && type->isName()) {
                if (type->str() == ""enum"") {
                    isEnum = true;
                    break;
                }
                type = type->previous();
            }
        }

        Token* typeTok = tok->next();
        while (Token::Match(typeTok, ""const|volatile""))
            typeTok = typeTok->next();
        if (Token::Match(typeTok, ""%type% %name% :"") &&
            !Token::Match(to...",1,1,lib/tokenize.cpp,Tokenizer.simplifyBitfields:void(),<empty>,,false,9899,9972,simplifyBitfields,,,1,void()
111669153798,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static bool isStdContainerOrIterator(const Token* tok, const Settings& settings)
{
    const Library::Container* ctr = settings.library.detectContainerOrIterator(tok, nullptr, /*withoutStd*/ true);
    return ctr && startsWith(ctr->startPattern, ""std ::"");
}",1,1,lib/tokenize.cpp,"isStdContainerOrIterator:bool(Token*,Settings&)",<empty>,,false,9974,9978,isStdContainerOrIterator,,,1,"bool(Token*,Settings&)"
111669153799,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static bool isStdSmartPointer(const Token* tok, const Settings& settings)
{
    const Library::SmartPointer* ptr = settings.library.detectSmartPointer(tok, /*withoutStd*/ true);
    return ptr && startsWith(ptr->name, ""std::"");
}",1,1,lib/tokenize.cpp,"isStdSmartPointer:bool(Token*,Settings&)",<empty>,,false,9980,9984,isStdSmartPointer,,,1,"bool(Token*,Settings&)"
111669153800,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyNamespaceStd()
{
    if (!isCPP())
        return;

    std::set<std::string> userFunctions;

    for (Token* tok = Token::findsimplematch(list.front(), ""using namespace std ;""); tok; tok = tok->next()) {
        bool insert = false;
        if (Token::Match(tok, ""enum class|struct| %name%| :|{"")) { // Don't replace within enum definitions
            skipEnumBody(tok);
        }
        if (!tok->isName() || tok->isKeyword() || tok->isStandardType() || tok->varId())
            continue;
        if (Token::Match(tok->previous(), "".|::|namespace""))
            continue;
        if (Token::simpleMatch(tok->next(), ""("")) {
            if (TokenList::isFunctionHead(tok->next(), ""{""))
                userFunctions.insert(tok->str());
            else if (TokenList::isFunctionHead(tok->next(), "";"")) {
                const Token *start = tok;
                while (Token::Match(start->previous(), ""%type%|*|&""))
                    start = start->previous();
      ...",1,1,lib/tokenize.cpp,Tokenizer.simplifyNamespaceStd:void(),<empty>,,false,9987,10037,simplifyNamespaceStd,,,1,void()
111669153801,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyMicrosoftMemoryFunctions()
{
    // skip if not Windows
    if (!mSettings.platform.isWindows())
        return;

    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (tok->strAt(1) != ""("")
            continue;

        if (Token::Match(tok, ""CopyMemory|RtlCopyMemory|RtlCopyBytes"")) {
            tok->str(""memcpy"");
        } else if (Token::Match(tok, ""MoveMemory|RtlMoveMemory"")) {
            tok->str(""memmove"");
        } else if (Token::Match(tok, ""FillMemory|RtlFillMemory|RtlFillBytes"")) {
            // FillMemory(dst, len, val) -> memset(dst, val, len)
            tok->str(""memset"");

            Token *tok1 = tok->tokAt(2);
            if (tok1)
                tok1 = tok1->nextArgument(); // Second argument
            if (tok1) {
                Token *tok2 = tok1->nextArgument(); // Third argument

                if (tok2)
                    Token::move(tok1->previous(), tok2->tokAt(-2), tok->linkAt(1)->previous()); // Swap t...",1,1,lib/tokenize.cpp,Tokenizer.simplifyMicrosoftMemoryFunctions:void(),<empty>,,false,10040,10091,simplifyMicrosoftMemoryFunctions,,,1,void()
111669153802,METHOD,triplet,TYPE_DECL,"triplet(const char* m, const char* u) :  mbcs(m), unicode(u) {}",9,71,lib/tokenize.cpp,"triplet.triplet:ANY(char*,char*)",<empty>,,false,10095,10095,triplet,,,1,"triplet.triplet:ANY(char*,char*)(char*,char*)"
111669153803,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyMicrosoftStringFunctions()
{
    // skip if not Windows
    if (!mSettings.platform.isWindows())
        return;

    const bool ansi = mSettings.platform.type == Platform::Type::Win32A;
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (tok->strAt(1) != ""("")
            continue;

        const auto match = utils::as_const(apis).find(tok->str());
        if (match!=apis.end()) {
            tok->str(ansi ? match->second.mbcs : match->second.unicode);
            tok->originalName(match->first);
        } else if (Token::Match(tok, ""_T|_TEXT|TEXT ( %char%|%str% )"")) {
            tok->deleteNext();
            tok->deleteThis();
            tok->deleteNext();
            if (!ansi) {
                tok->isLong(true);
                if (tok->str()[0] != 'L')
                    tok->str(""L"" + tok->str());
            }
            while (Token::Match(tok->next(), ""_T|_TEXT|TEXT ( %char%|%str% )"")) {
                tok->next()->deleteN...",1,1,lib/tokenize.cpp,Tokenizer.simplifyMicrosoftStringFunctions:void(),<empty>,,false,10135,10168,simplifyMicrosoftStringFunctions,,,1,void()
111669153804,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyBorland()
{
    // skip if not Windows
    if (!mSettings.platform.isWindows())
        return;
    if (isC())
        return;
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""( __closure * %name% )"")) {
            tok->deleteNext();
        }
    }

    // I think that these classes are always declared at the outer scope
    // I save some time by ignoring inner classes.
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (tok->str() == ""{"" && !Token::Match(tok->tokAt(-2), ""namespace %type%"")) {
            tok = tok->link();
            if (!tok)
                break;
        } else if (Token::Match(tok, ""class %name% :|{"")) {
            while (tok && tok->str() != ""{"" && tok->str() != "";"")
                tok = tok->next();
            if (!tok)
                break;
            if (tok->str() == "";"")
                continue;

            const Token* end = tok->link()->next();
         ...",1,1,lib/tokenize.cpp,Tokenizer.simplifyBorland:void(),<empty>,,false,10171,10220,simplifyBorland,,,1,void()
111669153805,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::createSymbolDatabase()
{
    if (!mSymbolDatabase)
        mSymbolDatabase = new SymbolDatabase(*this, mSettings, mErrorLogger);
    mSymbolDatabase->validate();
}",1,1,lib/tokenize.cpp,Tokenizer.createSymbolDatabase:void(),<empty>,,false,10222,10227,createSymbolDatabase,,,1,void()
111669153806,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"bool Tokenizer::operatorEnd(const Token * tok)
{
    if (tok && tok->str() == "")"") {
        if (TokenList::isFunctionHead(tok, ""{;?:[""))
            return true;

        tok = tok->next();
        while (tok && !Token::Match(tok, ""[=;{),]"")) {
            if (Token::Match(tok, ""const|volatile|override"")) {
                tok = tok->next();
            } else if (tok->str() == ""noexcept"") {
                tok = tok->next();
                if (tok && tok->str() == ""("") {
                    tok = tok->link()->next();
                }
            } else if (tok->str() == ""throw"" && tok->next() && tok->strAt(1) == ""("") {
                tok = tok->linkAt(1)->next();
            }
            // unknown macros "") MACRO {"" and "") MACRO(...) {""
            else if (tok->isUpperCaseName()) {
                tok = tok->next();
                if (tok && tok->str() == ""("") {
                    tok = tok->link()->next();
                }
            } else if (Token::Match(tok, ""%op% !...",1,1,lib/tokenize.cpp,Tokenizer.operatorEnd:bool(Token*),<empty>,,false,10229,10264,operatorEnd,,,1,bool(Token*)
111669153807,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyOperatorName()
{
    if (isC())
        return;

    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""using|:: operator %op%|%name% ;"")) {
            tok->next()->str(""operator"" + tok->strAt(2));
            tok->next()->deleteNext();
            continue;
        }

        if (tok->str() != ""operator"")
            continue;
        // operator op
        if (Token::Match(tok, ""operator %op% ("") && !operatorEnd(tok->linkAt(2))) {
            tok->str(tok->str() + tok->strAt(1));
            tok->deleteNext();
            continue;
        }
        std::string op;
        Token *par = tok->next();
        bool done = false;
        while (!done && par) {
            done = true;
            if (par->isName()) {
                op += par->str();
                par = par->next();
                // merge namespaces eg. 'operator std :: string () const {'
                if (Token::Match(par, "":: %name%|%op%|."")) {
    ...",1,1,lib/tokenize.cpp,Tokenizer.simplifyOperatorName:void(),<empty>,,false,10266,10393,simplifyOperatorName,,,1,void()
111669153808,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyOverloadedOperators()
{
    if (isC())
        return;
    std::set<std::string> classNames;
    std::set<nonneg int> classVars;
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (!tok->isName())
            continue;

        if (Token::simpleMatch(tok, ""this ) ("") && Token::simpleMatch(tok->tokAt(-2), ""( *"")) {
            tok = tok->next();
            tok->insertToken(""operator()"");
            tok->insertToken(""."");
            continue;
        }

        // Get classes that have operator() member
        if (Token::Match(tok, ""class|struct %name% [:{]"")) {
            int indent = 0;
            for (const Token *tok2 = tok->next(); tok2; tok2 = tok2->next()) {
                if (tok2->str() == ""}"")
                    break;
                if (indent == 0 && tok2->str() == "";"")
                    break;
                if (tok2->str() == ""{"") {
                    if (indent == 0)
                        ++indent;
           ...",1,13,lib/tokenize.cpp,Tokenizer.simplifyOverloadedOperators:void(),<empty>,,false,10395,10468,simplifyOverloadedOperators,,,1,void()
111669153809,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::removeUnnecessaryQualification()
{
    if (isC())
        return;

    std::vector<Space> classInfo;
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""class|struct|namespace %type% :|{"") &&
            (!tok->previous() || tok->strAt(-1) != ""enum"")) {
            Space info;
            info.isNamespace = tok->str() == ""namespace"";
            tok = tok->next();
            info.className = tok->str();
            tok = tok->next();
            while (tok && tok->str() != ""{"")
                tok = tok->next();
            if (!tok)
                return;
            info.bodyEnd = tok->link();
            classInfo.push_back(std::move(info));
        } else if (!classInfo.empty()) {
            if (tok == classInfo.back().bodyEnd)
                classInfo.pop_back();
            else if (tok->str() == classInfo.back().className &&
                     !classInfo.back().isNamespace && tok->strAt(-1) != "":"" &&
             ...",1,1,lib/tokenize.cpp,Tokenizer.removeUnnecessaryQualification:void(),<empty>,,false,10471,10539,removeUnnecessaryQualification,,,1,void()
111669153810,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::printUnknownTypes() const
{
    if (!mSymbolDatabase)
        return;

    std::vector<std::pair<std::string, const Token *>> unknowns;

    for (int i = 1; i <= mVarId; ++i) {
        const Variable *var = mSymbolDatabase->getVariableFromVarId(i);
        if (!var)
            continue;
        // is unknown type?
        if (var->type() || var->typeStartToken()->isStandardType())
            continue;

        std::string name;
        const Token * nameTok;

        // single token type?
        if (var->typeStartToken() == var->typeEndToken()) {
            nameTok = var->typeStartToken();
            name = nameTok->str();
        }

        // complicated type
        else {
            const Token *tok = var->typeStartToken();
            int level = 0;

            nameTok =  tok;

            while (tok) {
                // skip pointer and reference part of type
                if (level == 0 && Token::Match(tok, ""*|&""))
                    break;

       ...",1,1,lib/tokenize.cpp,Tokenizer.printUnknownTypes<const>:void(),<empty>,,false,10541,10617,printUnknownTypes,,,1,void()
111669153811,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::prepareTernaryOpForAST()
{
    // http://en.cppreference.com/w/cpp/language/operator_precedence says about ternary operator:
    //       ""The expression in the middle of the conditional operator (between ? and :) is parsed as if parenthesized: its precedence relative to ?: is ignored.""
    // The AST parser relies on this function to add such parentheses where necessary.
    for (Token* tok = list.front(); tok; tok = tok->next()) {
        if (tok->str() == ""?"") {
            bool parenthesesNeeded = false;
            int depth = 0;
            Token* tok2 = tok->next();
            for (; tok2; tok2 = tok2->next()) {
                if (tok2->link() && Token::Match(tok2, ""[|(|<""))
                    tok2 = tok2->link();
                else if (tok2->str() == "":"") {
                    if (depth == 0)
                        break;
                    depth--;
                } else if (tok2->str() == "";"" || (tok2->link() && tok2->str() != ""{"" && tok2->str() != ""...",1,1,lib/tokenize.cpp,Tokenizer.prepareTernaryOpForAST:void(),<empty>,,false,10619,10654,prepareTernaryOpForAST,,,1,void()
111669153812,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::reportError(const Token* tok, const Severity severity, const std::string& id, const std::string& msg, bool inconclusive) const
{
    const std::list<const Token*> callstack(1, tok);
    reportError(callstack, severity, id, msg, inconclusive);
}",1,1,lib/tokenize.cpp,"Tokenizer.reportError<const>:void(Token*,Severity,std.string&,std.string&,bool)",<empty>,,false,10656,10660,reportError,,,1,"void(Token*,Severity,std.string&,std.string&,bool)"
111669153813,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::reportError(const std::list<const Token*>& callstack, Severity severity, const std::string& id, const std::string& msg, bool inconclusive) const
{
    const ErrorMessage errmsg(callstack, &list, severity, id, msg, inconclusive ? Certainty::inconclusive : Certainty::normal);
    mErrorLogger.reportErr(errmsg);
}",1,1,lib/tokenize.cpp,"Tokenizer.reportError<const>:void(std.list<constToken*>&,Severity,std.string&,std.string&,bool)",<empty>,,false,10662,10666,reportError,,,1,"void(std.list<constToken*>&,Severity,std.string&,std.string&,bool)"
111669153814,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::setPodTypes()
{
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (!tok->isName() || tok->varId())
            continue;

        // pod type
        const Library::PodType *podType = mSettings.library.podtype(tok->str());
        if (podType) {
            const Token *prev = tok->previous();
            while (prev && prev->isName())
                prev = prev->previous();
            if (prev && !Token::Match(prev, "";|{|}|,|(""))
                continue;
            tok->isStandardType(true);
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.setPodTypes:void(),<empty>,,false,10668,10685,setPodTypes,,,1,void()
111669153815,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"const Token *Tokenizer::findSQLBlockEnd(const Token *tokSQLStart)
{
    const Token *tokLastEnd = nullptr;
    for (const Token *tok = tokSQLStart->tokAt(2); tok != nullptr; tok = tok->next()) {
        if (tokLastEnd == nullptr && tok->str() == "";"")
            tokLastEnd = tok;
        else if (tok->str() == ""__CPPCHECK_EMBEDDED_SQL_EXEC__"") {
            if (Token::simpleMatch(tok->tokAt(-2), ""END - __CPPCHECK_EMBEDDED_SQL_EXEC__ ;""))
                return tok->next();
            return tokLastEnd;
        } else if (Token::Match(tok, ""{|}|==|&&|!|^|<<|>>|++|+=|-=|/=|*=|>>=|<<=|~""))
            break; // We are obviously outside the SQL block
    }

    return tokLastEnd;
}",1,1,lib/tokenize.cpp,Tokenizer.findSQLBlockEnd:Token*(Token*),<empty>,,false,10687,10702,findSQLBlockEnd,,,1,Token*(Token*)
111669153816,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyNestedNamespace()
{
    if (!isCPP())
        return;

    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (Token::Match(tok, ""namespace %name% ::"") && tok->strAt(-1) != ""using"") {
            Token * tok2 = tok->tokAt(2);

            // validate syntax
            while (Token::Match(tok2, "":: %name%""))
                tok2 = tok2->tokAt(2);

            if (!tok2 || tok2->str() != ""{"")
                return; // syntax error

            std::stack<Token *> links;
            tok2 = tok->tokAt(2);

            while (tok2->str() == ""::"") {
                links.push(tok2);
                tok2->str(""{"");
                tok2->insertToken(""namespace"");
                tok2 = tok2->tokAt(3);
            }

            tok = tok2;

            if (!links.empty() && tok2->str() == ""{"") {
                tok2 = tok2->link();
                while (!links.empty()) {
                    tok2->insertToken(""}"");
                    tok2 = tok2-...",1,1,lib/tokenize.cpp,Tokenizer.simplifyNestedNamespace:void(),<empty>,,false,10704,10743,simplifyNestedNamespace,,,1,void()
111669153817,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyCoroutines()
{
    if (!isCPP() || mSettings.standards.cpp < Standards::CPP20)
        return;
    for (Token *tok = list.front(); tok; tok = tok->next()) {
        if (!tok->isName() || !Token::Match(tok, ""co_return|co_yield|co_await""))
            continue;
        Token *end = tok->next();
        while (end && end->str() != "";"") {
            if (Token::Match(end, ""[({[]""))
                end = end->link();
            else if (Token::Match(end, ""[)]}]""))
                break;
            end = end->next();
        }
        if (Token::simpleMatch(end, "";"")) {
            tok->insertToken(""("");
            end->previous()->insertToken("")"");
            Token::createMutualLinks(tok->next(), end->previous());
        }
    }
}",1,1,lib/tokenize.cpp,Tokenizer.simplifyCoroutines:void(),<empty>,,false,10745,10766,simplifyCoroutines,,,1,void()
111669153818,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static bool sameTokens(const Token *first, const Token *last, const Token *other)
{
    while (other && first->str() == other->str()) {
        if (first == last)
            return true;
        first = first->next();
        other = other->next();
    }

    return false;
}",1,1,lib/tokenize.cpp,"sameTokens:bool(Token*,Token*,Token*)",<empty>,,false,10768,10778,sameTokens,,,1,"bool(Token*,Token*,Token*)"
111669153819,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static bool alreadyHasNamespace(const Token *first, const Token *last, const Token *end)
{
    while (end && last->str() == end->str()) {
        if (first == last)
            return true;
        last = last->previous();
        end = end->previous();
    }

    return false;
}",1,1,lib/tokenize.cpp,"alreadyHasNamespace:bool(Token*,Token*,Token*)",<empty>,,false,10780,10790,alreadyHasNamespace,,,1,"bool(Token*,Token*,Token*)"
111669153820,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"static Token * deleteAlias(Token * tok)
{
    Token::eraseTokens(tok, Token::findsimplematch(tok, "";""));

    // delete first token
    tok->deleteThis();

    // delete ';' if not last token
    tok->deleteThis();

    return tok;
}",1,1,lib/tokenize.cpp,deleteAlias:Token*(Token*),<empty>,,false,10792,10803,deleteAlias,,,1,Token*(Token*)
111669153821,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::simplifyNamespaceAliases()
{
    if (!isCPP())
        return;

    int scope = 0;

    for (Token *tok = list.front(); tok; tok = tok->next()) {
        bool isPrev{};
        if (tok->str() == ""{"")
            scope++;
        else if (tok->str() == ""}"")
            scope--;
        else if (Token::Match(tok, ""namespace %name% ="") || (isPrev = Token::Match(tok->previous(), ""namespace %name% =""))) {
            if (isPrev)
                tok = tok->previous();
            if (tok->tokAt(-1) && !Token::Match(tok->tokAt(-1), ""[;{}]""))
                syntaxError(tok->tokAt(-1));
            const std::string name(tok->strAt(1));
            Token * tokNameStart = tok->tokAt(3);
            Token * tokNameEnd = tokNameStart;

            while (tokNameEnd && tokNameEnd->next() && tokNameEnd->strAt(1) != "";"") {
                if (tokNameEnd->str() == ""("") {
                    if (tokNameEnd->previous()->isName())
                        unknownMacroError(tokNameEnd->...",1,1,lib/tokenize.cpp,Tokenizer.simplifyNamespaceAliases:void(),<empty>,,false,10805,10905,simplifyNamespaceAliases,,,1,void()
111669153822,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::setDirectives(std::list<Directive> directives)
{
    mDirectives = std::move(directives);
}",1,1,lib/tokenize.cpp,Tokenizer.setDirectives:void(std.list<Directive>),<empty>,,false,10907,10910,setDirectives,,,1,void(std.list<Directive>)
111669153823,METHOD,<empty>,<empty>,"[&](const Directive& d) {
        return startsWith(d.str, ""#if"") &&
        d.linenr >= start->linenr() &&
        d.linenr <= end->linenr() &&
        start->fileIndex() < list.getFiles().size() &&
        d.file == list.getFiles()[start->fileIndex()];
    }",64,5,lib/tokenize.cpp,lib/tokenize.cpp:<global>.Tokenizer.hasIfdef<const>.<lambda>18:bool(Directive&),<empty>,,false,10915,10921,<lambda>18,,,1,bool(Directive&)
111669153824,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"bool Tokenizer::hasIfdef(const Token *start, const Token *end) const
{
    const auto& directives = mDirectives;
    return std::any_of(directives.cbegin(), directives.cend(), [&](const Directive& d) {
        return startsWith(d.str, ""#if"") &&
        d.linenr >= start->linenr() &&
        d.linenr <= end->linenr() &&
        start->fileIndex() < list.getFiles().size() &&
        d.file == list.getFiles()[start->fileIndex()];
    });
}",1,1,lib/tokenize.cpp,"Tokenizer.hasIfdef<const>:bool(Token*,Token*)",<empty>,,false,10912,10922,hasIfdef,,,1,"bool(Token*,Token*)"
111669153825,METHOD,<empty>,<empty>,"[&](const Directive& d) {
        return d.linenr < bodyStart->linenr() && d.str == ""#pragma pack(1)"" && d.file == list.getFiles().front();
    }",64,5,lib/tokenize.cpp,lib/tokenize.cpp:<global>.Tokenizer.isPacked<const>.<lambda>19:bool(Directive&),<empty>,,false,10928,10930,<lambda>19,,,1,bool(Directive&)
111669153826,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"bool Tokenizer::isPacked(const Token * bodyStart) const
{
    const auto& directives = mDirectives;
    // TODO: should this return true if the #pragma exists in any line before the start token?
    return std::any_of(directives.cbegin(), directives.cend(), [&](const Directive& d) {
        return d.linenr < bodyStart->linenr() && d.str == ""#pragma pack(1)"" && d.file == list.getFiles().front();
    });
}",1,1,lib/tokenize.cpp,Tokenizer.isPacked<const>:bool(Token*),<empty>,,false,10924,10931,isPacked,,,1,bool(Token*)
111669153827,METHOD,lib/tokenize.cpp:<global>,TYPE_DECL,"void Tokenizer::getErrorMessages(ErrorLogger& errorLogger, const Settings& settings)
{
    Tokenizer tokenizer(settings, errorLogger);
    tokenizer.invalidConstFunctionTypeError(nullptr);
    // checkLibraryNoReturn
    tokenizer.unhandled_macro_class_x_y(nullptr, """", """", """", """");
    tokenizer.macroWithSemicolonError(nullptr, """");
    tokenizer.unhandledCharLiteral(nullptr, """");
}",1,1,lib/tokenize.cpp,"Tokenizer.getErrorMessages:void(ErrorLogger&,Settings&)",<empty>,,false,10933,10941,getErrorMessages,,,1,"void(ErrorLogger&,Settings&)"
111669153828,METHOD,lib/tokenize.h:<global>,TYPE_DECL,<global>,1,1,lib/tokenize.h,lib/tokenize.h:<global>,<empty>,,false,1,689,<global>,,,1,
111669153829,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"TokenList::TokenList(const Settings* settings)
    : mTokensFrontBack(*this)
    , mSettings(settings)
{
    if (mSettings && (mSettings->enforcedLang != Standards::Language::None)) {
        mLang = mSettings->enforcedLang;
    }
}",1,1,lib/tokenlist.cpp,TokenList.TokenList:ANY(Settings*),<empty>,,false,63,70,TokenList,,,1,TokenList.TokenList:ANY(Settings*)(Settings*)
111669153830,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,<global>,1,1,lib/tokenlist.cpp,lib/tokenlist.cpp:<global>,<empty>,,false,1,2366,<global>,,,1,
111669153831,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"TokenList::~TokenList()
{
    deallocateTokens();
}",1,1,lib/tokenlist.cpp,TokenList.~TokenList:ANY(),<empty>,,false,72,75,~TokenList,,,1,ANY()
111669153832,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"const std::string& TokenList::getSourceFilePath() const
{
    if (getFiles().empty()) {
        static const std::string s_empty_string;
        return s_empty_string;
    }
    return getFiles()[0];
}",1,1,lib/tokenlist.cpp,TokenList.getSourceFilePath<const>:ANY(),<empty>,,false,79,86,getSourceFilePath,,,1,ANY()
111669153833,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"void TokenList::deallocateTokens()
{
    deleteTokens(mTokensFrontBack.front);
    mTokensFrontBack.front = nullptr;
    mTokensFrontBack.back = nullptr;
    mFiles.clear();
}",1,1,lib/tokenlist.cpp,TokenList.deallocateTokens:void(),<empty>,,false,91,97,deallocateTokens,,,1,void()
111669153834,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"void TokenList::determineCppC()
{
    // only try to determine if it wasn't enforced
    if (mLang == Standards::Language::None) {
        ASSERT_LANG(!getSourceFilePath().empty());
        mLang = Path::identify(getSourceFilePath(), mSettings ? mSettings->cppHeaderProbe : false);
        // TODO: cannot enable assert as this might occur for unknown extensions
        //ASSERT_LANG(mLang != Standards::Language::None);
        if (mLang == Standards::Language::None) {
            // TODO: should default to C instead like we do for headers
            // default to C++
            mLang = Standards::Language::CPP;
        }
    }
}",1,8,lib/tokenlist.cpp,TokenList.determineCppC:void(),<empty>,,false,99,113,determineCppC,,,1,void()
111669153835,METHOD,<empty>,<empty>,"[&](const std::string& f) {
        return Path::sameFileName(f, fileName);
    }",60,5,lib/tokenlist.cpp,lib/tokenlist.cpp:<global>.TokenList.appendFileIfNew.<lambda>0:bool(std.string&),<empty>,,false,118,120,<lambda>0,,,1,bool(std.string&)
111669153836,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"int TokenList::appendFileIfNew(std::string fileName)
{
    // Has this file been tokenized already?
    auto it = std::find_if(mFiles.cbegin(), mFiles.cend(), [&](const std::string& f) {
        return Path::sameFileName(f, fileName);
    });
    if (it != mFiles.cend())
        return static_cast<int>(std::distance(mFiles.cbegin(), it));

    // The ""mFiles"" vector remembers what files have been tokenized..
    mFiles.push_back(std::move(fileName));

    // Update mIsC and mIsCpp properties
    if (mFiles.size() == 1) { // Update only useful if first file added to _files
        determineCppC();
    }
    return mFiles.size() - 1;
}",1,1,lib/tokenlist.cpp,TokenList.appendFileIfNew:int(std.string),<empty>,,false,115,132,appendFileIfNew,,,1,int(std.string)
111669153837,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"void TokenList::clangSetOrigFiles()
{
    mOrigFiles = mFiles;
}",1,1,lib/tokenlist.cpp,TokenList.clangSetOrigFiles:void(),<empty>,,false,134,137,clangSetOrigFiles,,,1,void()
111669153838,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"void TokenList::deleteTokens(Token *tok)
{
    while (tok) {
        Token *next = tok->next();
        delete tok;
        tok = next;
    }
}",1,1,lib/tokenlist.cpp,TokenList.deleteTokens:void(Token*),<empty>,,false,139,146,deleteTokens,,,1,void(Token*)
111669153839,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"void TokenList::addtoken(const std::string& str, const nonneg int lineno, const nonneg int column, const nonneg int fileno, bool split)
{
    if (str.empty())
        return;

    // If token contains # characters, split it up
    if (split) {
        size_t begin = 0;
        size_t end = 0;
        while ((end = str.find(""##"", begin)) != std::string::npos) {
            addtoken(str.substr(begin, end - begin), lineno, fileno, false);
            addtoken(""##"", lineno, column, fileno, false);
            begin = end+2;
        }
        if (begin != 0) {
            addtoken(str.substr(begin), lineno, column, fileno, false);
            return;
        }
    }

    if (mTokensFrontBack.back) {
        mTokensFrontBack.back->insertToken(str);
    } else {
        mTokensFrontBack.front = new Token(mTokensFrontBack);
        mTokensFrontBack.back = mTokensFrontBack.front;
        mTokensFrontBack.back->str(str);
    }

    mTokensFrontBack.back->linenr(lineno);
    mTokensFrontBack.b...",1,55,lib/tokenlist.cpp,"TokenList.addtoken:void(std.string&,int,int,int,bool)",<empty>,,false,152,183,addtoken,,,1,"void(std.string&,int,int,int,bool)"
111669153840,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"void TokenList::addtoken(const std::string& str, const Token *locationTok)
{
    if (str.empty())
        return;

    if (mTokensFrontBack.back) {
        mTokensFrontBack.back->insertToken(str);
    } else {
        mTokensFrontBack.front = new Token(mTokensFrontBack);
        mTokensFrontBack.back = mTokensFrontBack.front;
        mTokensFrontBack.back->str(str);
    }

    mTokensFrontBack.back->linenr(locationTok->linenr());
    mTokensFrontBack.back->column(locationTok->column());
    mTokensFrontBack.back->fileIndex(locationTok->fileIndex());
}",1,1,lib/tokenlist.cpp,"TokenList.addtoken:void(std.string&,Token*)",<empty>,,false,185,201,addtoken,,,1,"void(std.string&,Token*)"
111669153841,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"void TokenList::addtoken(const Token * tok, const nonneg int lineno, const nonneg int column, const nonneg int fileno)
{
    if (tok == nullptr)
        return;

    if (mTokensFrontBack.back) {
        mTokensFrontBack.back->insertToken(tok->str(), tok->originalName());
    } else {
        mTokensFrontBack.front = new Token(mTokensFrontBack);
        mTokensFrontBack.back = mTokensFrontBack.front;
        mTokensFrontBack.back->str(tok->str());
        if (!tok->originalName().empty())
            mTokensFrontBack.back->originalName(tok->originalName());
    }

    mTokensFrontBack.back->linenr(lineno);
    mTokensFrontBack.back->column(column);
    mTokensFrontBack.back->fileIndex(fileno);
    mTokensFrontBack.back->flags(tok->flags());
}",1,50,lib/tokenlist.cpp,"TokenList.addtoken:void(Token*,int,int,int)",<empty>,,false,203,222,addtoken,,,1,"void(Token*,int,int,int)"
111669153842,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"void TokenList::addtoken(const Token *tok, const Token *locationTok)
{
    if (tok == nullptr || locationTok == nullptr)
        return;

    if (mTokensFrontBack.back) {
        mTokensFrontBack.back->insertToken(tok->str(), tok->originalName());
    } else {
        mTokensFrontBack.front = new Token(mTokensFrontBack);
        mTokensFrontBack.back = mTokensFrontBack.front;
        mTokensFrontBack.back->str(tok->str());
        if (!tok->originalName().empty())
            mTokensFrontBack.back->originalName(tok->originalName());
    }

    mTokensFrontBack.back->flags(tok->flags());
    mTokensFrontBack.back->linenr(locationTok->linenr());
    mTokensFrontBack.back->column(locationTok->column());
    mTokensFrontBack.back->fileIndex(locationTok->fileIndex());
}",1,1,lib/tokenlist.cpp,"TokenList.addtoken:void(Token*,Token*)",<empty>,,false,224,243,addtoken,,,1,"void(Token*,Token*)"
111669153843,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"void TokenList::addtoken(const Token *tok)
{
    if (tok == nullptr)
        return;

    if (mTokensFrontBack.back) {
        mTokensFrontBack.back->insertToken(tok->str(), tok->originalName(), tok->getMacroName());
    } else {
        mTokensFrontBack.front = new Token(mTokensFrontBack);
        mTokensFrontBack.back = mTokensFrontBack.front;
        mTokensFrontBack.back->str(tok->str());
        if (!tok->originalName().empty())
            mTokensFrontBack.back->originalName(tok->originalName());
        if (!tok->getMacroName().empty())
            mTokensFrontBack.back->setMacroName(tok->getMacroName());
    }

    mTokensFrontBack.back->flags(tok->flags());
    mTokensFrontBack.back->linenr(tok->linenr());
    mTokensFrontBack.back->column(tok->column());
    mTokensFrontBack.back->fileIndex(tok->fileIndex());
}",1,1,lib/tokenlist.cpp,TokenList.addtoken:void(Token*),<empty>,,false,245,266,addtoken,,,1,void(Token*)
111669153844,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"Token *TokenList::copyTokens(Token *dest, const Token *first, const Token *last, bool one_line)
{
    std::stack<Token *> links;
    Token *tok2 = dest;
    int linenr = dest->linenr();
    const int commonFileIndex = dest->fileIndex();
    for (const Token *tok = first; tok != last->next(); tok = tok->next()) {
        tok2->insertToken(tok->str());
        tok2 = tok2->next();
        tok2->fileIndex(commonFileIndex);
        tok2->linenr(linenr);
        tok2->tokType(tok->tokType());
        tok2->flags(tok->flags());
        tok2->varId(tok->varId());
        tok2->setTokenDebug(tok->getTokenDebug());

        // Check for links and fix them up
        if (Token::Match(tok2, ""(|[|{""))
            links.push(tok2);
        else if (Token::Match(tok2, "")|]|}"")) {
            if (links.empty())
                return tok2;

            Token * link = links.top();

            tok2->link(link);
            link->link(tok2);

            links.pop();
        }
        if (!one_line ...",1,1,lib/tokenlist.cpp,"TokenList.copyTokens:Token*(Token*,Token*,Token*,bool)",<empty>,,false,273,307,copyTokens,,,1,"Token*(Token*,Token*,Token*,bool)"
111669153845,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"void TokenList::insertTokens(Token *dest, const Token *src, nonneg int n)
{
    // TODO: put the linking in a helper?
    std::stack<Token *> link;

    while (n > 0) {
        dest->insertToken(src->str(), src->originalName());
        dest = dest->next();

        // Set links
        if (Token::Match(dest, ""(|[|{""))
            link.push(dest);
        else if (!link.empty() && Token::Match(dest, "")|]|}"")) {
            Token::createMutualLinks(dest, link.top());
            link.pop();
        }

        dest->fileIndex(src->fileIndex());
        dest->linenr(src->linenr());
        dest->column(src->column());
        dest->varId(src->varId());
        dest->tokType(src->tokType());
        dest->flags(src->flags());
        if (!src->getMacroName().empty())
            dest->setMacroName(src->getMacroName());
        src  = src->next();
        --n;
    }
}",1,60,lib/tokenlist.cpp,"TokenList.insertTokens:void(Token*,Token*,int)",<empty>,,false,313,341,insertTokens,,,1,"void(Token*,Token*,int)"
111669153846,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"bool TokenList::createTokens(std::istream &code, const std::string& file0)
{
    ASSERT_LANG(!file0.empty());

    appendFileIfNew(file0);

    return createTokensInternal(code, file0);
}",1,4,lib/tokenlist.cpp,"TokenList.createTokens:bool(std.istream&,std.string&)",<empty>,,false,347,354,createTokens,,,1,"bool(std.istream&,std.string&)"
111669153847,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"bool TokenList::createTokens(std::istream &code, Standards::Language lang)
{
    ASSERT_LANG(lang != Standards::Language::None);
    if (mLang == Standards::Language::None) {
        mLang = lang;
    } else {
        ASSERT_LANG(lang == mLang);
    }

    return createTokensInternal(code, """");
}",1,4,lib/tokenlist.cpp,"TokenList.createTokens:bool(std.istream&,Standards.Language)",<empty>,,false,358,368,createTokens,,,1,"bool(std.istream&,Standards.Language)"
111669153848,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"bool TokenList::createTokensInternal(std::istream &code, const std::string& file0)
{
    simplecpp::OutputList outputList;
    simplecpp::TokenList tokens(code, mFiles, file0, &outputList);

    createTokens(std::move(tokens));

    return outputList.empty();
}",1,1,lib/tokenlist.cpp,"TokenList.createTokensInternal:bool(std.istream&,std.string&)",<empty>,,false,372,380,createTokensInternal,,,1,"bool(std.istream&,std.string&)"
111669153849,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"void TokenList::createTokens(simplecpp::TokenList&& tokenList)
{
    // TODO: what to do if the list has been filled already? clear mTokensFrontBack?

    // tokenList.cfront() might be NULL if the file contained nothing to tokenize so we need to check the files instead
    if (!tokenList.getFiles().empty()) {
        // this is a copy
        // TODO: this points to mFiles when called from createTokens(std::istream &, const std::string&)
        mOrigFiles = mFiles = tokenList.getFiles();
    }
    else
        mFiles.clear();

    determineCppC();

    for (const simplecpp::Token *tok = tokenList.cfront(); tok;) {

        // TODO: move from TokenList
        std::string str = tok->str();

        // Float literal
        if (str.size() > 1 && str[0] == '.' && std::isdigit(str[1]))
            str = '0' + str;

        if (mTokensFrontBack.back) {
            mTokensFrontBack.back->insertToken(str);
        } else {
            mTokensFrontBack.front = new Token(mTokensFrontBack);...",1,1,lib/tokenlist.cpp,TokenList.createTokens:void(simplecpp.TokenList&&),<empty>,,false,385,434,createTokens,,,1,void(simplecpp.TokenList&&)
111669153850,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"std::size_t TokenList::calculateHash() const
{
    std::string hashData;
    for (const Token* tok = front(); tok; tok = tok->next()) {
        hashData += std::to_string(tok->flags());
        hashData += std::to_string(tok->varId());
        hashData += std::to_string(tok->tokType());
        hashData += tok->str();
        hashData += tok->originalName();
    }
    return (std::hash<std::string>{})(hashData);
}",1,1,lib/tokenlist.cpp,TokenList.calculateHash<const>:size_t(),<empty>,,false,438,449,calculateHash,,,1,size_t()
111669153851,METHOD,AST_state,TYPE_DECL,explicit AST_state(bool cpp) : cpp(cpp) {},9,50,lib/tokenlist.cpp,AST_state.AST_state:ANY(bool),<empty>,,false,465,465,AST_state,,,10,AST_state.AST_state:ANY(bool)(bool)
111669153852,METHOD,<empty>,<empty>,<empty>,5,,lib/tokenlist.cpp,AST_state.<clinit>,<empty>,,false,455,,<clinit>,,,11,
111669153853,METHOD,<empty>,<empty>,"[](const Token* tok) -> bool {
        if (!Token::simpleMatch(tok, "")""))
            return false;
        tok = tok->next();
        while (Token::Match(tok, ""*|&|&&|const""))
            tok = tok->next();
        if (Token::simpleMatch(tok, ""(""))
            tok = tok->link()->next();
        return Token::Match(tok, ""%name%| ,|)"");
    }",32,5,lib/tokenlist.cpp,lib/tokenlist.cpp:<global>.skipDecl.<lambda>1:bool(Token*),<empty>,,false,471,480,<lambda>1,,,1,bool(Token*)
111669153854,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static Token* skipDecl(Token* tok, std::vector<Token*>* inner = nullptr)
{
    auto isDecltypeFuncParam = [](const Token* tok) -> bool {
        if (!Token::simpleMatch(tok, "")""))
            return false;
        tok = tok->next();
        while (Token::Match(tok, ""*|&|&&|const""))
            tok = tok->next();
        if (Token::simpleMatch(tok, ""(""))
            tok = tok->link()->next();
        return Token::Match(tok, ""%name%| ,|)"");
    };

    if (!Token::Match(tok->previous(), ""( %name%""))
        return tok;
    Token *vartok = tok;
    while (Token::Match(vartok, ""%name%|*|&|::|<"")) {
        if (vartok->str() == ""<"") {
            if (vartok->link())
                vartok = vartok->link();
            else
                return tok;
        } else if (Token::Match(vartok, ""%var% [:=({]"")) {
            return vartok;
        } else if (Token::Match(vartok, ""decltype|typeof ("") && !isDecltypeFuncParam(tok->linkAt(1))) {
            if (inner)
                inner->push...",1,1,lib/tokenlist.cpp,"skipDecl:Token*(Token*,std.vector<Token*>*)",<empty>,,false,469,501,skipDecl,,,1,"Token*(Token*,std.vector<Token*>*)"
111669153855,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static bool iscast(const Token *tok, bool cpp)
{
    if (!Token::Match(tok, ""( ::| %name%""))
        return false;

    if (Token::simpleMatch(tok->link(), "") ( )""))
        return false;

    if (Token::Match(tok->link(), "") %assign%|,|...""))
        return false;

    if (tok->previous() && tok->previous()->isName() && tok->strAt(-1) != ""return"" &&
        (!cpp || !Token::Match(tok->previous(), ""delete|throw"")))
        return false;

    if (Token::simpleMatch(tok->previous(), "">"") && tok->linkAt(-1))
        return false;

    if (Token::Match(tok, ""( (| typeof ("") && Token::Match(tok->link(), "") %num%""))
        return true;

    if (Token::Match(tok->link(), "") }|)|]|;""))
        return false;

    if (Token::Match(tok->link(), "") ++|-- [;)]""))
        return false;

    if (Token::Match(tok->link(), "") %cop%"") && !Token::Match(tok->link(), "") [&*+-~!]""))
        return false;

    if (Token::Match(tok->previous(), ""= ( %name% ) {"") && tok->next()->varId() == 0)
        retur...",1,1,lib/tokenlist.cpp,"iscast:bool(Token*,bool)",<empty>,,false,503,573,iscast,,,1,"bool(Token*,bool)"
111669153856,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static Token * findCppTypeInitPar(Token *tok)
{
    if (!tok || !Token::Match(tok->previous(), ""[,()] %name%""))
        return nullptr;
    bool istype = false;
    while (Token::Match(tok, ""%name%|::|<"")) {
        if (tok->str() == ""<"") {
            tok = tok->link();
            if (!tok)
                return nullptr;
        }
        istype |= tok->isStandardType();
        tok = tok->next();
    }
    if (!istype)
        return nullptr;
    if (!Token::Match(tok, ""[*&]""))
        return nullptr;
    while (Token::Match(tok, ""[*&]""))
        tok = tok->next();
    return (tok && tok->str() == ""("") ? tok : nullptr;
}",1,1,lib/tokenlist.cpp,findCppTypeInitPar:Token*(Token*),<empty>,,false,576,597,findCppTypeInitPar,,,1,Token*(Token*)
111669153857,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static bool iscpp11init(const Token * const tok)
{
    if (tok->isCpp11init() == TokenImpl::Cpp11init::UNKNOWN)
        tok->setCpp11init(iscpp11init_impl(tok));
    return tok->isCpp11init() == TokenImpl::Cpp11init::CPP11INIT;
}",1,1,lib/tokenlist.cpp,iscpp11init:bool(Token*),<empty>,,false,601,606,iscpp11init,,,1,bool(Token*)
111669153858,METHOD,<empty>,<empty>,"[](const Token* colonTok) {
        if (!Token::Match(colonTok->tokAt(-1), ""%name%|%num%|%char%|) :""))
            return false;
        if (const Token* castTok = colonTok->linkAt(-1)) {
            if (Token::simpleMatch(castTok->astParent(), ""case""))
                return true;
        }
        const Token* caseTok = colonTok->tokAt(-2);
        while (caseTok && Token::Match(caseTok->tokAt(-1), ""::|%name%""))
            caseTok = caseTok->tokAt(-1);
        return Token::simpleMatch(caseTok, ""case"");
    }",23,5,lib/tokenlist.cpp,lib/tokenlist.cpp:<global>.iscpp11init_impl.<lambda>2:bool(Token*),<empty>,,false,637,648,<lambda>2,,,1,bool(Token*)
111669153859,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static bool iscpp11init_impl(const Token * const tok)
{
    if (Token::simpleMatch(tok, ""{"") && Token::simpleMatch(tok->link()->previous(), ""; }""))
        return false;
    const Token *nameToken = tok;
    while (nameToken && nameToken->str() == ""{"") {
        if (nameToken->isCpp11init() != TokenImpl::Cpp11init::UNKNOWN)
            return nameToken->isCpp11init() == TokenImpl::Cpp11init::CPP11INIT;
        nameToken = nameToken->previous();
        if (nameToken && nameToken->str() == "","" && Token::simpleMatch(nameToken->previous(), ""} ,""))
            nameToken = nameToken->linkAt(-1);
    }
    if (!nameToken)
        return false;
    if (nameToken->str() == "")"" && Token::simpleMatch(nameToken->link()->previous(), ""decltype ("") &&
        !Token::simpleMatch(nameToken->link()->tokAt(-2), "".""))
        nameToken = nameToken->link()->previous();
    if (Token::simpleMatch(nameToken, "", {""))
        return true;
    if (nameToken->str() == "">"" && nameToken->link())
        nameT...",1,1,lib/tokenlist.cpp,iscpp11init_impl:bool(Token*),<empty>,,false,608,689,iscpp11init_impl,,,1,bool(Token*)
111669153860,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static bool isQualifier(const Token* tok)
{
    while (Token::Match(tok, ""&|&&|*""))
        tok = tok->next();
    return Token::Match(tok, ""{|;"");
}",1,1,lib/tokenlist.cpp,isQualifier:bool(Token*),<empty>,,false,691,696,isQualifier,,,1,bool(Token*)
111669153861,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compileUnaryOp(Token *&tok, AST_state& state, void (*f)(Token *&tok, AST_state& state))
{
    Token *unaryop = tok;
    if (f) {
        tok = tok->next();
        state.depth++;
        if (state.depth > AST_MAX_DEPTH)
            throw InternalError(tok, ""maximum AST depth exceeded"", InternalError::AST);
        if (tok)
            f(tok, state);
        state.depth--;
    }

    if (!state.op.empty() && (!precedes(state.op.top(), unaryop) || unaryop->isIncDecOp() || Token::Match(unaryop, ""[({[]""))) { // nullary functions, empty lists/arrays
        unaryop->astOperand1(state.op.top());
        state.op.pop();
    }
    state.op.push(unaryop);
}",1,1,lib/tokenlist.cpp,"compileUnaryOp:void(Token*&,AST_state&,void)",<empty>,,false,698,716,compileUnaryOp,,,1,"void(Token*&,AST_state&,void)"
111669153862,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void skipGenericType(Token *&tok)
{
    Token *skip = tok;
    while (Token::Match(skip, ""%name%|*|:|("")) {
        if (skip->link()) {
            skip = skip->link()->next();
            continue;
        }
        if (Token::simpleMatch(skip, "":"")) {
            tok = skip->next();
            return;
        }
        skip = skip->next();
    }
}",1,1,lib/tokenlist.cpp,skipGenericType:void(Token*&),<empty>,,false,718,732,skipGenericType,,,1,void(Token*&)
111669153863,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compileBinOp(Token *&tok, AST_state& state, void (*f)(Token *&tok, AST_state& state))
{
    Token *binop = tok;
    if (f) {
        tok = tok->next();
        if (Token::simpleMatch(binop, "","") && state.inGeneric)
            skipGenericType(tok);
        const bool inGenericSaved = state.inGeneric;
        state.inGeneric = false;
        if (Token::Match(binop, ""::|. ~""))
            tok = tok->next();
        state.depth++;
        if (tok && state.depth <= AST_MAX_DEPTH)
            f(tok, state);
        if (state.depth > AST_MAX_DEPTH)
            throw InternalError(tok, ""maximum AST depth exceeded"", InternalError::AST);
        state.depth--;
        state.inGeneric = inGenericSaved;
    }

    // TODO: Should we check if op is empty.
    // * Is it better to add assertion that it isn't?
    // * Write debug warning if it's empty?
    if (!state.op.empty()) {
        binop->astOperand2(state.op.top());
        state.op.pop();
    }
    if (!state.op.empty()) {
 ...",1,1,lib/tokenlist.cpp,"compileBinOp:void(Token*&,AST_state&,void)",<empty>,,false,734,766,compileBinOp,,,1,"void(Token*&,AST_state&,void)"
111669153864,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compileTerm(Token *&tok, AST_state& state)
{
    if (!tok)
        return;
    if (Token::Match(tok, ""L %str%|%char%""))
        tok = tok->next();
    if (state.inArrayAssignment && Token::Match(tok->previous(), ""[{,] . %name%"")) { // Jump over . in C style struct initialization
        state.op.push(tok);
        tok->astOperand1(tok->next());
        tok = tok->tokAt(2);
    }
    if (state.inArrayAssignment && Token::Match(tok->previous(), ""[{,] [ %num%|%name% ]"")) {
        state.op.push(tok);
        tok->astOperand1(tok->next());
        tok = tok->tokAt(3);
    }
    if (tok->isLiteral()) {
        state.op.push(tok);
        do {
            tok = tok->next();
        } while (Token::Match(tok, ""%name%|%str%""));
    } else if (tok->isName()) {
        if (Token::Match(tok, ""return|case"") || (state.cpp && (tok->str() == ""throw""))) {
            if (tok->str() == ""case"")
                state.inCase = true;
            const bool tokIsReturn = tok->str() == ""return...",1,1,lib/tokenlist.cpp,"compileTerm:void(Token*&,AST_state&)",<empty>,,false,770,917,compileTerm,,,1,"void(Token*&,AST_state&)"
111669153865,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compileScope(Token *&tok, AST_state& state)
{
    compileTerm(tok, state);
    while (tok) {
        if (tok->str() == ""::"") {
            const Token *lastOp = state.op.empty() ? nullptr : state.op.top();
            if (Token::Match(lastOp, "":: %name%""))
                lastOp = lastOp->next();
            if (Token::Match(lastOp, ""%name%"") &&
                (lastOp->next() == tok || (Token::Match(lastOp, ""%name% <"") && lastOp->linkAt(1) && tok == lastOp->linkAt(1)->next())))
                compileBinOp(tok, state, compileTerm);
            else
                compileUnaryOp(tok, state, compileTerm);
        } else break;
    }
}",1,1,lib/tokenlist.cpp,"compileScope:void(Token*&,AST_state&)",<empty>,,false,919,934,compileScope,,,1,"void(Token*&,AST_state&)"
111669153866,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static bool isPrefixUnary(const Token* tok, bool cpp)
{
    if (cpp && Token::simpleMatch(tok->previous(), ""* ["") && Token::simpleMatch(tok->link(), ""] {"")) {
        for (const Token* prev = tok->previous(); Token::Match(prev, ""%name%|::|*|&|>|>>""); prev = prev->previous()) {
            if (Token::Match(prev, "">|>>"")) {
                if (!prev->link())
                    break;
                prev = prev->link();
            }
            if (prev->str() == ""new"")
                return false;
        }
    }
    if (!tok->previous()
        || ((Token::Match(tok->previous(), ""(|[|{|%op%|;|?|:|,|.|case|return|::"") || (cpp && tok->strAt(-1) == ""throw""))
            && (tok->previous()->tokType() != Token::eIncDecOp || tok->tokType() == Token::eIncDecOp)))
        return true;

    if (tok->strAt(-1) == ""}"") {
        const Token* parent = tok->linkAt(-1)->tokAt(-1);
        return !Token::Match(parent, ""%type%"") || parent->isKeyword();
    }

    if (tok->str() == ""*"" && tok->p...",1,1,lib/tokenlist.cpp,"isPrefixUnary:bool(Token*,bool)",<empty>,,false,936,963,isPrefixUnary,,,1,"bool(Token*,bool)"
111669153867,METHOD,<empty>,<empty>,"[&](const Token* tok) -> bool {
        const bool isStartOfCpp11Init = state.cpp && tok && tok->str() == ""{"" && iscpp11init(tok);
        if (isStartOfCpp11Init || Token::simpleMatch(tok, ""("")) {
            tok = tok->previous();
            while (Token::simpleMatch(tok, ""*""))
                tok = tok->previous();
            while (tok && Token::Match(tok->previous(), "":: %type%""))
                tok = tok->tokAt(-2);
            if (tok && !tok->isKeyword())
                tok = tok->previous();
            return !Token::Match(tok, ""new ::| %type%"");
        }
        return !findLambdaEndTokenWithoutAST(tok);
    }",27,5,lib/tokenlist.cpp,lib/tokenlist.cpp:<global>.compilePrecedence2.<lambda>3:bool(Token*),<empty>,,false,967,980,<lambda>3,,,1,bool(Token*)
111669153868,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compilePrecedence2(Token *&tok, AST_state& state)
{
    auto doCompileScope = [&](const Token* tok) -> bool {
        const bool isStartOfCpp11Init = state.cpp && tok && tok->str() == ""{"" && iscpp11init(tok);
        if (isStartOfCpp11Init || Token::simpleMatch(tok, ""("")) {
            tok = tok->previous();
            while (Token::simpleMatch(tok, ""*""))
                tok = tok->previous();
            while (tok && Token::Match(tok->previous(), "":: %type%""))
                tok = tok->tokAt(-2);
            if (tok && !tok->isKeyword())
                tok = tok->previous();
            return !Token::Match(tok, ""new ::| %type%"");
        }
        return !findLambdaEndTokenWithoutAST(tok);
    };

    bool isNew = true;
    if (doCompileScope(tok)) {
        compileScope(tok, state);
        isNew = false;
    }
    while (tok) {
        if (tok->tokType() == Token::eIncDecOp && !isPrefixUnary(tok, state.cpp)) {
            compileUnaryOp(tok, state, compileScope);...",1,1,lib/tokenlist.cpp,"compilePrecedence2:void(Token*&,AST_state&)",<empty>,,false,965,1141,compilePrecedence2,,,1,"void(Token*&,AST_state&)"
111669153869,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compilePrecedence3(Token *&tok, AST_state& state)
{
    compilePrecedence2(tok, state);
    while (tok) {
        if ((Token::Match(tok, ""[+-!~*&]"") || tok->tokType() == Token::eIncDecOp) &&
            isPrefixUnary(tok, state.cpp)) {
            if (Token::Match(tok, ""* [*,)]"")) {
                Token* tok2 = tok->next();
                while (tok2->next() && tok2->str() == ""*"")
                    tok2 = tok2->next();
                if (Token::Match(tok2, ""[>),]"")) {
                    tok = tok2;
                    continue;
                }
            }
            compileUnaryOp(tok, state, compilePrecedence3);
        } else if (tok->str() == ""("" && iscast(tok, state.cpp)) {
            Token* castTok = tok;
            castTok->isCast(true);
            tok = tok->link()->next();
            const int inArrayAssignment = state.inArrayAssignment;
            if (tok && tok->str() == ""{"")
                state.inArrayAssignment = 1;
            compilePreced...",1,1,lib/tokenlist.cpp,"compilePrecedence3:void(Token*&,AST_state&)",<empty>,,false,1143,1248,compilePrecedence3,,,1,"void(Token*&,AST_state&)"
111669153870,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compilePointerToElem(Token *&tok, AST_state& state)
{
    compilePrecedence3(tok, state);
    while (tok) {
        if (Token::simpleMatch(tok, "". *"")) {
            compileBinOp(tok, state, compilePrecedence3);
        } else break;
    }
}",1,1,lib/tokenlist.cpp,"compilePointerToElem:void(Token*&,AST_state&)",<empty>,,false,1250,1258,compilePointerToElem,,,1,"void(Token*&,AST_state&)"
111669153871,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compileMulDiv(Token *&tok, AST_state& state)
{
    compilePointerToElem(tok, state);
    while (tok) {
        if (Token::Match(tok, ""[/%]"") || (tok->str() == ""*"" && !tok->astOperand1() && !isQualifier(tok))) {
            if (Token::Match(tok, ""* [*,)]"")) {
                Token* tok2 = tok->next();
                while (tok2->next() && tok2->str() == ""*"")
                    tok2 = tok2->next();
                if (Token::Match(tok2, ""[>),]"")) {
                    tok = tok2;
                    break;
                }
            }
            compileBinOp(tok, state, compilePointerToElem);
        } else break;
    }
}",1,1,lib/tokenlist.cpp,"compileMulDiv:void(Token*&,AST_state&)",<empty>,,false,1260,1277,compileMulDiv,,,1,"void(Token*&,AST_state&)"
111669153872,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compileAddSub(Token *&tok, AST_state& state)
{
    compileMulDiv(tok, state);
    while (tok) {
        if (Token::Match(tok, ""+|-"") && !tok->astOperand1()) {
            compileBinOp(tok, state, compileMulDiv);
        } else break;
    }
}",1,1,lib/tokenlist.cpp,"compileAddSub:void(Token*&,AST_state&)",<empty>,,false,1279,1287,compileAddSub,,,1,"void(Token*&,AST_state&)"
111669153873,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compileShift(Token *&tok, AST_state& state)
{
    compileAddSub(tok, state);
    while (tok) {
        if (Token::Match(tok, ""<<|>>"")) {
            compileBinOp(tok, state, compileAddSub);
        } else break;
    }
}",1,1,lib/tokenlist.cpp,"compileShift:void(Token*&,AST_state&)",<empty>,,false,1289,1297,compileShift,,,1,"void(Token*&,AST_state&)"
111669153874,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compileThreewayComp(Token *&tok, AST_state& state)
{
    compileShift(tok, state);
    while (tok) {
        if (tok->str() == ""<=>"") {
            compileBinOp(tok, state, compileShift);
        } else break;
    }
}",1,1,lib/tokenlist.cpp,"compileThreewayComp:void(Token*&,AST_state&)",<empty>,,false,1299,1307,compileThreewayComp,,,1,"void(Token*&,AST_state&)"
111669153875,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compileRelComp(Token *&tok, AST_state& state)
{
    compileThreewayComp(tok, state);
    while (tok) {
        if (Token::Match(tok, ""<|<=|>=|>"") && !tok->link()) {
            compileBinOp(tok, state, compileThreewayComp);
        } else break;
    }
}",1,1,lib/tokenlist.cpp,"compileRelComp:void(Token*&,AST_state&)",<empty>,,false,1309,1317,compileRelComp,,,1,"void(Token*&,AST_state&)"
111669153876,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compileEqComp(Token *&tok, AST_state& state)
{
    compileRelComp(tok, state);
    while (tok) {
        if (Token::Match(tok, ""==|!="")) {
            compileBinOp(tok, state, compileRelComp);
        } else break;
    }
}",1,1,lib/tokenlist.cpp,"compileEqComp:void(Token*&,AST_state&)",<empty>,,false,1319,1327,compileEqComp,,,1,"void(Token*&,AST_state&)"
111669153877,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compileAnd(Token *&tok, AST_state& state)
{
    compileEqComp(tok, state);
    while (tok) {
        if (tok->str() == ""&"" && !tok->astOperand1() && !isQualifier(tok)) {
            Token* tok2 = tok->next();
            if (!tok2)
                break;
            if (tok2->str() == ""&"")
                tok2 = tok2->next();
            if (state.cpp && Token::Match(tok2, "",|)"")) {
                tok = tok2;
                break; // rValue reference
            }
            compileBinOp(tok, state, compileEqComp);
        } else break;
    }
}",1,1,lib/tokenlist.cpp,"compileAnd:void(Token*&,AST_state&)",<empty>,,false,1329,1346,compileAnd,,,1,"void(Token*&,AST_state&)"
111669153878,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compileXor(Token *&tok, AST_state& state)
{
    compileAnd(tok, state);
    while (tok) {
        if (tok->str() == ""^"") {
            compileBinOp(tok, state, compileAnd);
        } else break;
    }
}",1,1,lib/tokenlist.cpp,"compileXor:void(Token*&,AST_state&)",<empty>,,false,1348,1356,compileXor,,,1,"void(Token*&,AST_state&)"
111669153879,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compileOr(Token *&tok, AST_state& state)
{
    compileXor(tok, state);
    while (tok) {
        if (tok->str() == ""|"") {
            compileBinOp(tok, state, compileXor);
        } else break;
    }
}",1,1,lib/tokenlist.cpp,"compileOr:void(Token*&,AST_state&)",<empty>,,false,1358,1366,compileOr,,,1,"void(Token*&,AST_state&)"
111669153880,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compileLogicAnd(Token *&tok, AST_state& state)
{
    compileOr(tok, state);
    while (tok) {
        if (tok->str() == ""&&"" && !isQualifier(tok)) {
            if (!tok->astOperand1()) {
                Token* tok2 = tok->next();
                if (!tok2)
                    break;
                if (state.cpp && Token::Match(tok2, "",|)"")) {
                    tok = tok2;
                    break; // rValue reference
                }
            }
            compileBinOp(tok, state, compileOr);
        } else break;
    }
}",1,1,lib/tokenlist.cpp,"compileLogicAnd:void(Token*&,AST_state&)",<empty>,,false,1368,1385,compileLogicAnd,,,1,"void(Token*&,AST_state&)"
111669153881,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compileLogicOr(Token *&tok, AST_state& state)
{
    compileLogicAnd(tok, state);
    while (tok) {
        if (tok->str() == ""||"") {
            compileBinOp(tok, state, compileLogicAnd);
        } else break;
    }
}",1,1,lib/tokenlist.cpp,"compileLogicOr:void(Token*&,AST_state&)",<empty>,,false,1387,1395,compileLogicOr,,,1,"void(Token*&,AST_state&)"
111669153882,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compileAssignTernary(Token *&tok, AST_state& state)
{
    compileLogicOr(tok, state);
    while (tok) {
        if (tok->isAssignmentOp()) {
            state.assign++;
            const Token *tok1 = tok->next();
            compileBinOp(tok, state, compileAssignTernary);
            if (Token::simpleMatch(tok1, ""{"") && tok == tok1->link() && tok->next())
                tok = tok->next();
            if (state.assign > 0)
                state.assign--;
        } else if (tok->str() == ""?"") {
            // http://en.cppreference.com/w/cpp/language/operator_precedence says about ternary operator:
            //       ""The expression in the middle of the conditional operator (between ? and :) is parsed as if parenthesized: its precedence relative to ?: is ignored.""
            // Hence, we rely on Tokenizer::prepareTernaryOpForAST() to add such parentheses where necessary.
            const bool stopAtColon = state.stopAtColon;
            state.stopAtColon = false;
   ...",1,1,lib/tokenlist.cpp,"compileAssignTernary:void(Token*&,AST_state&)",<empty>,,false,1397,1436,compileAssignTernary,,,1,"void(Token*&,AST_state&)"
111669153883,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compileComma(Token *&tok, AST_state& state)
{
    compileAssignTernary(tok, state);
    while (tok) {
        if (tok->str() == "","") {
            if (Token::simpleMatch(tok, "", }""))
                tok = tok->next();
            else
                compileBinOp(tok, state, compileAssignTernary);
        } else if (tok->str() == "";"" && state.functionCallEndPar && tok->index() < state.functionCallEndPar->index()) {
            compileBinOp(tok, state, compileAssignTernary);
        } else break;
    }
}",1,1,lib/tokenlist.cpp,"compileComma:void(Token*&,AST_state&)",<empty>,,false,1438,1451,compileComma,,,1,"void(Token*&,AST_state&)"
111669153884,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void compileExpression(Token *&tok, AST_state& state)
{
    if (state.depth > AST_MAX_DEPTH)
        throw InternalError(tok, ""maximum AST depth exceeded"", InternalError::AST); // ticket #5592
    if (tok)
        compileComma(tok, state);
}",1,1,lib/tokenlist.cpp,"compileExpression:void(Token*&,AST_state&)",<empty>,,false,1453,1459,compileExpression,,,1,"void(Token*&,AST_state&)"
111669153885,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"const Token* isLambdaCaptureList(const Token * tok)
{
    // a lambda expression '[x](y){}' is compiled as:
    // [
    // `-(  <<-- optional
    //   `-{
    // see compilePrecedence2
    if (!Token::simpleMatch(tok, ""[""))
        return nullptr;
    if (!Token::Match(tok->link(), ""] (|{""))
        return nullptr;
    if (Token::simpleMatch(tok->astOperand1(), ""{"") && tok->astOperand1() == tok->link()->next())
        return tok->astOperand1();
    if (!tok->astOperand1() || tok->astOperand1()->str() != ""("")
        return nullptr;
    const Token * params = tok->astOperand1();
    if (!Token::simpleMatch(params->astOperand1(), ""{""))
        return nullptr;
    return params->astOperand1();
}",1,1,lib/tokenlist.cpp,isLambdaCaptureList:Token*(Token*),<empty>,,false,1461,1480,isLambdaCaptureList,,,1,Token*(Token*)
111669153886,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"const Token* findLambdaEndTokenWithoutAST(const Token* tok) {
    if (!(Token::simpleMatch(tok, ""["") && tok->link()))
        return nullptr;
    tok = tok->link()->next();
    if (Token::simpleMatch(tok, ""("") && tok->link())
        tok = tok->link()->next();
    if (Token::simpleMatch(tok, ""mutable""))
        tok = tok->next();
    if (Token::Match(tok, "".|->"")) { // trailing return type
        tok = tok->next();
        while (Token::Match(tok, ""%type%|%name%|::|&|&&|*|<|("")) {
            if (tok->link())
                tok = tok->link()->next();
            else
                tok = tok->next();
        }
    }
    if (!(Token::simpleMatch(tok, ""{"") && tok->link()))
        return nullptr;
    return tok->link()->next();
}",1,1,lib/tokenlist.cpp,findLambdaEndTokenWithoutAST:Token*(Token*),<empty>,,false,1482,1502,findLambdaEndTokenWithoutAST,,,1,Token*(Token*)
111669153887,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static void createAstAtTokenInner(Token * const tok1, const Token *endToken, bool cpp)
{
    for (Token* tok = tok1; precedes(tok, endToken); tok = tok ? tok->next() : nullptr) {
        if (tok->str() == ""{"" && !iscpp11init(tok)) {
            const Token * const endToken2 = tok->link();
            bool hasAst = false;
            for (const Token *inner = tok->next(); inner != endToken2; inner = inner->next()) {
                if (inner->astOperand1()) {
                    hasAst = true;
                    break;
                }
                if (tok->isConstOp())
                    break;
                if (inner->str() == ""{"")
                    inner = inner->link();
            }
            if (!hasAst) {
                for (; tok && tok != endToken && tok != endToken2; tok = tok ? tok->next() : nullptr)
                    tok = createAstAtToken(tok);
            }
        } else if (cpp && tok->str() == ""["") {
            if (isLambdaCaptureList(tok)) {
        ...",1,1,lib/tokenlist.cpp,"createAstAtTokenInner:void(Token*,Token*,bool)",<empty>,,false,1507,1555,createAstAtTokenInner,,,1,"void(Token*,Token*,bool)"
111669153888,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static Token * findAstTop(Token *tok1, const Token *tok2)
{
    for (Token *tok = tok1; tok && (tok != tok2); tok = tok->next()) {
        if (tok->astParent() || tok->astOperand1() || tok->astOperand2()) {
            while (tok->astParent() && tok->astParent()->index() >= tok1->index() && tok->astParent()->index() <= tok2->index())
                tok = tok->astParent();
            return tok;
        }
        if (Token::simpleMatch(tok, ""( {""))
            tok = tok->link();
    }
    for (Token *tok = tok1; tok && (tok != tok2); tok = tok->next()) {
        if (tok->isName() || tok->isNumber())
            return tok;
        if (Token::simpleMatch(tok, ""( {""))
            tok = tok->link();
    }
    return nullptr;
}",1,1,lib/tokenlist.cpp,"findAstTop:Token*(Token*,Token*)",<empty>,,false,1557,1575,findAstTop,,,1,"Token*(Token*,Token*)"
111669153889,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static Token *skipMethodDeclEnding(Token *tok)
{
    if (tok->str() != "")"")
        tok = tok->previous();
    if (!tok || tok->str() != "")"")
        return nullptr;
    Token *const tok2 = const_cast<Token*>(TokenList::isFunctionHead(tok, "";{""));
    if (tok2 && tok->next() != tok2)
        return tok2;
    return nullptr;
}",1,1,lib/tokenlist.cpp,skipMethodDeclEnding:Token*(Token*),<empty>,,false,1577,1587,skipMethodDeclEnding,,,1,Token*(Token*)
111669153890,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"static Token * createAstAtToken(Token *tok)
{
    const bool cpp = tok->isCpp();
    // skip function pointer declaration
    if (Token::Match(tok, ""%type% %type%"") && !Token::Match(tok, ""return|throw|new|delete"")) {
        Token* tok2 = tok->tokAt(2);
        // skip type tokens and qualifiers etc
        while (Token::Match(tok2, ""%type%|*|&""))
            tok2 = tok2->next();
        if (Token::Match(tok2, ""%var% [;,)]""))
            return tok2;
    }
    if (Token *const endTok = skipMethodDeclEnding(tok)) {
        Token *tok2 = tok;
        do {
            tok2 = tok2->next();
            tok2->setCpp11init(false);
            if (Token::Match(tok2, ""decltype|noexcept ("")) {
                AST_state state(cpp);
                Token *tok3 = tok2->tokAt(2);
                compileExpression(tok3, state);
                tok2 = tok2->linkAt(1);
            }
        } while (tok2 != endTok && !precedes(endTok, tok2));
        return endTok;
    }
    if (Token::Match(tok, ""%...",1,1,lib/tokenlist.cpp,createAstAtToken:Token*(Token*),<empty>,,false,1589,1859,createAstAtToken,,,1,Token*(Token*)
111669153891,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"void TokenList::createAst() const
{
    for (Token *tok = mTokensFrontBack.front; tok; tok = tok ? tok->next() : nullptr) {
        Token* const nextTok = createAstAtToken(tok);
        if (precedes(nextTok, tok))
            throw InternalError(tok, ""Syntax Error: Infinite loop when creating AST."", InternalError::AST);
        tok = nextTok;
    }
}",1,1,lib/tokenlist.cpp,TokenList.createAst<const>:void(),<empty>,,false,1861,1869,createAst,,,1,void()
111669153892,METHOD,OnException,TYPE_DECL,"~OnException() {
#ifndef _MSC_VER
            if (std::uncaught_exception())
                f();
#endif
        }",9,9,lib/tokenlist.cpp,OnException.~OnException:ANY(),<empty>,,false,1875,1880,~OnException,,,2,ANY()
111669153893,METHOD,<empty>,<empty>,"[&] {
            if (print)
                mTokensFrontBack.front->printOut(std::cout);
        }",20,9,lib/tokenlist.cpp,lib/tokenlist.cpp:<global>.TokenList.validateAst<const>.<lambda>4:void(),<empty>,,false,1886,1889,<lambda>4,,,1,void()
111669153894,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"void TokenList::validateAst(bool print) const
{
    OnException oe{[&] {
            if (print)
                mTokensFrontBack.front->printOut(std::cout);
        }};
    // Check for some known issues in AST to avoid crash/hang later on
    std::set<const Token*> safeAstTokens;    // list of ""safe"" AST tokens without endless recursion
    for (const Token *tok = mTokensFrontBack.front; tok; tok = tok->next()) {
        // Syntax error if binary operator only has 1 operand
        if ((tok->isAssignmentOp() || tok->isComparisonOp() || Token::Match(tok,""[|^/%]"")) && tok->astOperand1() && !tok->astOperand2())
            throw InternalError(tok, ""Syntax Error: AST broken, binary operator has only one operand."", InternalError::AST);

        // Syntax error if we encounter ""?"" with operand2 that is not "":""
        if (tok->str() == ""?"") {
            if (!tok->astOperand1() || !tok->astOperand2())
                throw InternalError(tok, ""AST broken, ternary operator missing operand(...",1,1,lib/tokenlist.cpp,TokenList.validateAst<const>:void(bool),<empty>,,false,1884,1996,validateAst,,,1,void(bool)
111669153895,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"std::string TokenList::getOrigFile(const Token *tok) const
{
    return mOrigFiles.at(tok->fileIndex());
}",1,1,lib/tokenlist.cpp,TokenList.getOrigFile<const>:string(Token*),<empty>,,false,1998,2001,getOrigFile,,,1,string(Token*)
111669153896,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"const std::string& TokenList::file(const Token *tok) const
{
    return mFiles.at(tok->fileIndex());
}",1,1,lib/tokenlist.cpp,TokenList.file<const>:ANY(Token*),<empty>,,false,2003,2006,file,,,1,ANY(Token*)
111669153897,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"std::string TokenList::fileLine(const Token *tok) const
{
    return ErrorMessage::FileLocation(tok, this).stringify();
}",1,1,lib/tokenlist.cpp,TokenList.fileLine<const>:string(Token*),<empty>,,false,2008,2011,fileLine,,,1,string(Token*)
111669153898,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"bool TokenList::validateToken(const Token* tok) const
{
    if (!tok)
        return true;
    for (const Token *t = mTokensFrontBack.front; t; t = t->next()) {
        if (tok==t)
            return true;
    }
    return false;
}",1,1,lib/tokenlist.cpp,TokenList.validateToken<const>:bool(Token*),<empty>,,false,2013,2022,validateToken,,,1,bool(Token*)
111669153899,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"void TokenList::simplifyPlatformTypes()
{
    if (!mSettings)
        return;

    const bool isCPP11 = isCPP() && (mSettings->standards.cpp >= Standards::CPP11);

    enum : std::uint8_t { isLongLong, isLong, isInt } type;

    /** @todo This assumes a flat address space. Not true for segmented address space (FAR *). */

    if (mSettings->platform.sizeof_size_t == mSettings->platform.sizeof_long)
        type = isLong;
    else if (mSettings->platform.sizeof_size_t == mSettings->platform.sizeof_long_long)
        type = isLongLong;
    else if (mSettings->platform.sizeof_size_t == mSettings->platform.sizeof_int)
        type = isInt;
    else
        return;

    for (Token *tok = front(); tok; tok = tok->next()) {
        // pre-check to reduce unneeded match calls
        if (!Token::Match(tok, ""std| ::| %type%""))
            continue;
        bool isUnsigned;
        if (Token::Match(tok, ""std| ::| size_t|uintptr_t|uintmax_t"")) {
            if (isCPP11 && tok->strAt(-1) == ""us...",1,1,lib/tokenlist.cpp,TokenList.simplifyPlatformTypes:void(),<empty>,,false,2024,2157,simplifyPlatformTypes,,,1,void()
111669153900,METHOD,<empty>,<empty>,"[](const Token* tok) -> bool {
        if (!Token::simpleMatch(tok, ""}""))
            return false;
        tok = tok->link()->previous();
        while (Token::Match(tok, ""%name%"")) {
            if (Token::Match(tok, ""struct|union|enum""))
                return true;
            tok = tok->previous();
        }
        return false;
    }",23,5,lib/tokenlist.cpp,lib/tokenlist.cpp:<global>.TokenList.simplifyStdType.<lambda>5:bool(Token*),<empty>,,false,2161,2171,<lambda>5,,,1,bool(Token*)
111669153901,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"void TokenList::simplifyStdType()
{
    auto isVarDeclC = [](const Token* tok) -> bool {
        if (!Token::simpleMatch(tok, ""}""))
            return false;
        tok = tok->link()->previous();
        while (Token::Match(tok, ""%name%"")) {
            if (Token::Match(tok, ""struct|union|enum""))
                return true;
            tok = tok->previous();
        }
        return false;
    };

    for (Token *tok = front(); tok; tok = tok->next()) {

        if (isC() && Token::Match(tok, ""const|extern *|&|%name%"") && (!tok->previous() || Token::Match(tok->previous(), ""[;{}]""))) {
            if (Token::Match(tok->next(), ""%name% !!;""))
                continue;
            if (isVarDeclC(tok->previous()))
                continue;

            tok->insertToken(""int"");
            tok->next()->isImplicitInt(true);
            continue;
        }

        if (Token::Match(tok, ""char|short|int|long|unsigned|signed|double|float"") || (isC() && (!mSettings || (mSettings->standards....",1,1,lib/tokenlist.cpp,TokenList.simplifyStdType:void(),<empty>,,false,2159,2243,simplifyStdType,,,1,void()
111669153902,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"bool TokenList::isKeyword(const std::string &str) const
{
    if (isCPP()) {
        // TODO: integrate into keywords?
        // types and literals are not handled as keywords
        static const std::unordered_set<std::string> cpp_types = {""bool"", ""false"", ""true""};
        if (cpp_types.find(str) != cpp_types.end())
            return false;

        if (mSettings) {
            const auto &cpp_keywords = Keywords::getAll(mSettings->standards.cpp);
            return cpp_keywords.find(str) != cpp_keywords.end();
        }

        static const auto& latest_cpp_keywords = Keywords::getAll(Standards::cppstd_t::CPPLatest);
        return latest_cpp_keywords.find(str) != latest_cpp_keywords.end();
    }

    // TODO: integrate into Keywords?
    // types are not handled as keywords
    static const std::unordered_set<std::string> c_types = {""char"", ""double"", ""float"", ""int"", ""long"", ""short""};
    if (c_types.find(str) != c_types.end())
        return false;

    if (mSettings) {
     ...",1,1,lib/tokenlist.cpp,TokenList.isKeyword<const>:bool(std.string&),<empty>,,false,2245,2276,isKeyword,,,1,bool(std.string&)
111669153903,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"bool TokenList::isC() const
{
    ASSERT_LANG(mLang != Standards::Language::None);

    // TODO: remove the fallback
    if (mLang == Standards::Language::None)
        return false; // treat as C++ by default

    return mLang == Standards::Language::C;
}",1,4,lib/tokenlist.cpp,TokenList.isC<const>:bool(),<empty>,,false,2278,2287,isC,,,1,bool()
111669153904,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"bool TokenList::isCPP() const
{
    ASSERT_LANG(mLang != Standards::Language::None);

    // TODO: remove the fallback
    if (mLang == Standards::Language::None)
        return true; // treat as C++ by default

    return mLang == Standards::Language::CPP;
}",1,4,lib/tokenlist.cpp,TokenList.isCPP<const>:bool(),<empty>,,false,2289,2298,isCPP,,,1,bool()
111669153905,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"void TokenList::setLang(Standards::Language lang, bool force)
{
    ASSERT_LANG(lang != Standards::Language::None);
    if (!force)
    {
        ASSERT_LANG(mLang == Standards::Language::None);
    }

    mLang = lang;
}",1,4,lib/tokenlist.cpp,"TokenList.setLang:void(Standards.Language,bool)",<empty>,,false,2300,2309,setLang,,,1,"void(Standards.Language,bool)"
111669153906,METHOD,lib/tokenlist.cpp:<global>,TYPE_DECL,"const Token * TokenList::isFunctionHead(const Token *tok, const std::string &endsWith)
{
    if (!tok)
        return nullptr;
    if (tok->str() == ""("")
        tok = tok->link();
    if (tok->str() != "")"")
        return nullptr;
    if (!tok->isCpp() && !Token::Match(tok->link()->previous(), ""%name%|(|)""))
        return nullptr;
    if (Token::Match(tok, "") ;|{|["")) {
        tok = tok->next();
        while (tok && tok->str() == ""["" && tok->link()) {
            if (endsWith.find(tok->str()) != std::string::npos)
                return tok;
            tok = tok->link()->next();
        }
        return (tok && endsWith.find(tok->str()) != std::string::npos) ? tok : nullptr;
    }
    if (tok->isCpp() && tok->str() == "")"") {
        tok = tok->next();
        while (Token::Match(tok, ""const|noexcept|override|final|volatile|mutable|&|&& !!("") ||
               (Token::Match(tok, ""%name% !!("") && tok->isUpperCaseName()))
            tok = tok->next();
        if (tok && tok->str(...",1,1,lib/tokenlist.cpp,"TokenList.isFunctionHead:Token*(Token*,std.string&)",<empty>,,false,2311,2366,isFunctionHead,,,1,"Token*(Token*,std.string&)"
111669153907,METHOD,lib/tokenlist.h:<global>,TYPE_DECL,<global>,1,1,lib/tokenlist.h,lib/tokenlist.h:<global>,<empty>,,false,1,239,<global>,,,1,
111669153908,METHOD,lib/tokenrange.h:<global>,TYPE_DECL,<global>,1,1,lib/tokenrange.h,lib/tokenrange.h:<global>,<empty>,,false,1,83,<global>,,,1,
111669153909,METHOD,lib/utils.cpp:<global>,TYPE_DECL,"int caseInsensitiveStringCompare(const std::string &lhs, const std::string &rhs)
{
    if (lhs.size() != rhs.size())
        return (lhs.size() < rhs.size()) ? -1 : 1;
    for (unsigned int i = 0; i < lhs.size(); ++i) {
        const int c1 = std::toupper(lhs[i]);
        const int c2 = std::toupper(rhs[i]);
        if (c1 != c2)
            return (c1 < c2) ? -1 : 1;
    }
    return 0;
}",1,1,lib/utils.cpp,"caseInsensitiveStringCompare:int(std.string&,std.string&)",<empty>,,false,28,39,caseInsensitiveStringCompare,,,1,"int(std.string&,std.string&)"
111669153910,METHOD,lib/utils.cpp:<global>,TYPE_DECL,<global>,1,1,lib/utils.cpp,lib/utils.cpp:<global>,<empty>,,false,1,202,<global>,,,1,
111669153911,METHOD,lib/utils.cpp:<global>,TYPE_DECL,"bool isValidGlobPattern(const std::string& pattern)
{
    for (auto i = pattern.cbegin(); i != pattern.cend(); ++i) {
        if (*i == '*' || *i == '?') {
            const auto j = i + 1;
            if (j != pattern.cend() && (*j == '*' || *j == '?')) {
                return false;
            }
        }
    }
    return true;
}",1,1,lib/utils.cpp,isValidGlobPattern:bool(std.string&),<empty>,,false,41,52,isValidGlobPattern,,,1,bool(std.string&)
111669153912,METHOD,lib/utils.cpp:<global>,TYPE_DECL,"bool matchglob(const std::string& pattern, const std::string& name)
{
    const char* p = pattern.c_str();
    const char* n = name.c_str();
    std::stack<std::pair<const char*, const char*>, std::vector<std::pair<const char*, const char*>>> backtrack;

    for (;;) {
        bool matching = true;
        while (*p != '\\0' && matching) {
            switch (*p) {
            case '*':
                // Step forward until we match the next character after *
                while (*n != '\\0' && *n != p[1]) {
                    n++;
                }
                if (*n != '\\0') {
                    // If this isn't the last possibility, save it for later
                    backtrack.emplace(p, n);
                }
                break;
            case '?':
                // Any character matches unless we're at the end of the name
                if (*n != '\\0') {
                    n++;
                } else {
                    matching = false;
                }
    ...",1,1,lib/utils.cpp,"matchglob:bool(std.string&,std.string&)",<empty>,,false,54,116,matchglob,,,1,"bool(std.string&,std.string&)"
111669153913,METHOD,<empty>,<empty>,"[&name](const std::string &pattern) {
        return matchglob(pattern, name);
    }",56,5,lib/utils.cpp,lib/utils.cpp:<global>.matchglobs.<lambda>0:bool(std.string&),<empty>,,false,119,121,<lambda>0,,,1,bool(std.string&)
111669153914,METHOD,lib/utils.cpp:<global>,TYPE_DECL,"bool matchglobs(const std::vector<std::string> &patterns, const std::string &name) {
    return std::any_of(begin(patterns), end(patterns), [&name](const std::string &pattern) {
        return matchglob(pattern, name);
    });
}",1,1,lib/utils.cpp,"matchglobs:bool(std.vector<std.string>&,std.string&)",<empty>,,false,118,122,matchglobs,,,1,"bool(std.vector<std.string>&,std.string&)"
111669153915,METHOD,<empty>,<empty>,"[](int c) {
        return std::tolower(c);
    }",59,5,lib/utils.cpp,lib/utils.cpp:<global>.strTolower.<lambda>1:ANY(int),<empty>,,false,128,130,<lambda>1,,,1,ANY(int)
111669153916,METHOD,lib/utils.cpp:<global>,TYPE_DECL,"void strTolower(std::string& str)
{
    // This wrapper exists because Sun's CC does not allow a static_cast
    // from extern ""C"" int(*)(int) to int(*)(int).
    std::transform(str.cbegin(), str.cend(), str.begin(), [](int c) {
        return std::tolower(c);
    });
}",1,1,lib/utils.cpp,strTolower:void(std.string&),<empty>,,false,124,131,strTolower,,,1,void(std.string&)
111669153917,METHOD,lib/utils.cpp:<global>,TYPE_DECL,"std::string trim(const std::string& s, const std::string& t)
{
    const std::string::size_type beg = s.find_first_not_of(t);
    if (beg == std::string::npos)
        return """";
    const std::string::size_type end = s.find_last_not_of(t);
    return s.substr(beg, end - beg + 1);
}",1,1,lib/utils.cpp,"trim:string(std.string&,std.string&)",<empty>,,false,133,140,trim,,,1,"string(std.string&,std.string&)"
111669153918,METHOD,lib/utils.cpp:<global>,TYPE_DECL,"void findAndReplace(std::string &source, const std::string &searchFor, const std::string &replaceWith)
{
    std::string::size_type index = 0;
    while ((index = source.find(searchFor, index)) != std::string::npos) {
        source.replace(index, searchFor.length(), replaceWith);
        index += replaceWith.length();
    }
}",1,1,lib/utils.cpp,"findAndReplace:void(std.string&,std.string&,std.string&)",<empty>,,false,142,149,findAndReplace,,,1,"void(std.string&,std.string&,std.string&)"
111669153919,METHOD,lib/utils.cpp:<global>,TYPE_DECL,"std::string replaceEscapeSequences(const std::string &source) {
    std::string result;
    result.reserve(source.size());
    for (std::size_t i = 0; i < source.size(); ++i) {
        if (source[i] != '\\\\' || i + 1 >= source.size())
            result += source[i];
        else {
            ++i;
            if (source[i] == 'n') {
                result += '\\n';
            } else if (source[i] == 'r') {
                result += '\\r';
            } else if (source[i] == 't') {
                result += '\\t';
            } else if (source[i] == 'x') {
                std::string value = ""0"";
                if (i + 1 < source.size() && std::isxdigit(source[i+1]))
                    value += source[i++ + 1];
                if (i + 1 < source.size() && std::isxdigit(source[i+1]))
                    value += source[i++ + 1];
                result += static_cast<char>(std::stoi(value, nullptr, 16));
            } else if (source[i] == '0') {
                std::string value = ""0""...",1,1,lib/utils.cpp,replaceEscapeSequences:string(std.string&),<empty>,,false,151,185,replaceEscapeSequences,,,1,string(std.string&)
111669153920,METHOD,lib/utils.cpp:<global>,TYPE_DECL,"std::vector<std::string> splitString(const std::string& str, char sep)
{
    std::vector<std::string> l;

    std::string::size_type pos1 = 0;
    std::string::size_type pos2;
    while (true) {
        pos2 = str.find(sep, pos1);
        l.push_back(str.substr(pos1, pos2 - pos1));
        if (pos2 == std::string::npos)
            break;
        pos1 = pos2 + 1;
    }
    return l;
}",1,1,lib/utils.cpp,"splitString:vector<std.string>(std.string&,char)",<empty>,,false,188,202,splitString,,,1,"vector<std::string>(std.string&,char)"
111669153921,METHOD,lib/utils.h:<global>,TYPE_DECL,<global>,1,1,lib/utils.h,lib/utils.h:<global>,<empty>,,false,1,432,<global>,,,1,
111669153922,METHOD,lib/utils.h:<global>,TYPE_DECL,"inline static const char *getOrdinalText(int i)
{
    if (i == 1)
        return ""st"";
    if (i == 2)
        return ""nd"";
    if (i == 3)
        return ""rd"";
    return ""th"";
}",1,1,lib/utils.h,getOrdinalText,<empty>,,false,190,199,getOrdinalText,,,1,const char*(int)
111669153923,METHOD,lib/utils.h:<global>,TYPE_DECL,"static inline const char* bool_to_string(bool b)
{
    return b ? ""true"" : ""false"";
}",1,1,lib/utils.h,bool_to_string,<empty>,,false,346,349,bool_to_string,,,1,const char*(bool)
111669153924,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void bailoutInternal(const std::string& type,
                            const TokenList& tokenlist,
                            ErrorLogger& errorLogger,
                            const Token* tok,
                            const std::string& what,
                            const std::string& file,
                            int line,
                            std::string function)
{
    if (function.find(""operator"") != std::string::npos)
        function = ""(valueFlow)"";
    ErrorMessage::FileLocation loc(tok, &tokenlist);
    const std::string location = Path::stripDirectoryPart(file) + "":"" + std::to_string(line) + "":"";
    ErrorMessage errmsg({std::move(loc)},
                        tokenlist.getSourceFilePath(),
                        Severity::debug,
                        (file.empty() ? """" : location) + function + "" bailout: "" + what,
                        type,
                        Certainty::normal);
    errorLogger.reportErr(errmsg);
}",1,1,lib/valueflow.cpp,"bailoutInternal:void(std.string&,TokenList&,ErrorLogger&,Token*,std.string&,std.string&,int,std.string)",<empty>,,false,133,153,bailoutInternal,,,1,"void(std.string&,TokenList&,ErrorLogger&,Token*,std.string&,std.string&,int,std.string)"
111669153925,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,<global>,1,1,lib/valueflow.cpp,lib/valueflow.cpp:<global>,<empty>,,false,1,7395,<global>,,,1,
111669153926,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void changeKnownToPossible(std::list<ValueFlow::Value>& values, int indirect = -1)
{
    for (ValueFlow::Value& v : values) {
        if (indirect >= 0 && v.indirect != indirect)
            continue;
        v.changeKnownToPossible();
    }
}",1,1,lib/valueflow.cpp,"changeKnownToPossible:void(std.list<ValueFlow.Value>&,int)",<empty>,,false,164,171,changeKnownToPossible,,,1,"void(std.list<ValueFlow.Value>&,int)"
111669153927,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
        if (indirect >= 0 && v.indirect != indirect)
            return false;
        return v.isImpossible();
    }",22,5,lib/valueflow.cpp,lib/valueflow.cpp:<global>.removeImpossible.<lambda>0:bool(ValueFlow.Value&),<empty>,,false,175,179,<lambda>0,,,1,bool(ValueFlow.Value&)
111669153928,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void removeImpossible(std::list<ValueFlow::Value>& values, int indirect = -1)
{
    values.remove_if([&](const ValueFlow::Value& v) {
        if (indirect >= 0 && v.indirect != indirect)
            return false;
        return v.isImpossible();
    });
}",1,1,lib/valueflow.cpp,"removeImpossible:void(std.list<ValueFlow.Value>&,int)",<empty>,,false,173,180,removeImpossible,,,1,"void(std.list<ValueFlow.Value>&,int)"
111669153929,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void lowerToPossible(std::list<ValueFlow::Value>& values, int indirect = -1)
{
    changeKnownToPossible(values, indirect);
    removeImpossible(values, indirect);
}",1,1,lib/valueflow.cpp,"lowerToPossible:void(std.list<ValueFlow.Value>&,int)",<empty>,,false,182,186,lowerToPossible,,,1,"void(std.list<ValueFlow.Value>&,int)"
111669153930,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void changePossibleToKnown(std::list<ValueFlow::Value>& values, int indirect = -1)
{
    for (ValueFlow::Value& v : values) {
        if (indirect >= 0 && v.indirect != indirect)
            continue;
        if (!v.isPossible())
            continue;
        if (v.bound != ValueFlow::Value::Bound::Point)
            continue;
        v.setKnown();
    }
}",1,1,lib/valueflow.cpp,"changePossibleToKnown:void(std.list<ValueFlow.Value>&,int)",<empty>,,false,188,199,changePossibleToKnown,,,1,"void(std.list<ValueFlow.Value>&,int)"
111669153931,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isNonConditionalPossibleIntValue(const ValueFlow::Value& v)
{
    if (v.conditional)
        return false;
    if (v.condition)
        return false;
    if (!v.isPossible())
        return false;
    if (!v.isIntValue())
        return false;
    return true;
}",1,1,lib/valueflow.cpp,isNonConditionalPossibleIntValue:bool(ValueFlow.Value&),<empty>,,false,201,212,isNonConditionalPossibleIntValue,,,1,bool(ValueFlow.Value&)
111669153932,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void setValueUpperBound(ValueFlow::Value& value, bool upper)
{
    if (upper)
        value.bound = ValueFlow::Value::Bound::Upper;
    else
        value.bound = ValueFlow::Value::Bound::Lower;
}",1,1,lib/valueflow.cpp,"setValueUpperBound:void(ValueFlow.Value&,bool)",<empty>,,false,214,220,setValueUpperBound,,,1,"void(ValueFlow.Value&,bool)"
111669153933,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void setValueBound(ValueFlow::Value& value, const Token* tok, bool invert)
{
    if (Token::Match(tok, ""<|<="")) {
        setValueUpperBound(value, !invert);
    } else if (Token::Match(tok, "">|>="")) {
        setValueUpperBound(value, invert);
    }
}",1,1,lib/valueflow.cpp,"setValueBound:void(ValueFlow.Value&,Token*,bool)",<empty>,,false,222,229,setValueBound,,,1,"void(ValueFlow.Value&,Token*,bool)"
111669153934,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void setConditionalValue(ValueFlow::Value& value, const Token* tok, MathLib::bigint i)
{
    assert(value.isIntValue());
    value.intvalue = i;
    value.assumeCondition(tok);
    value.setPossible();
}",1,1,lib/valueflow.cpp,"setConditionalValue:void(ValueFlow.Value&,Token*,MathLib.bigint)",<empty>,,false,231,237,setConditionalValue,,,1,"void(ValueFlow.Value&,Token*,MathLib.bigint)"
111669153935,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void setConditionalValues(const Token* tok,
                                 bool lhs,
                                 MathLib::bigint value,
                                 ValueFlow::Value& true_value,
                                 ValueFlow::Value& false_value)
{
    if (Token::Match(tok, ""==|!=|>=|<="")) {
        setConditionalValue(true_value, tok, value);
        const char* greaterThan = "">="";
        const char* lessThan = ""<="";
        if (lhs)
            std::swap(greaterThan, lessThan);
        if (Token::simpleMatch(tok, greaterThan, strlen(greaterThan))) {
            setConditionalValue(false_value, tok, value - 1);
        } else if (Token::simpleMatch(tok, lessThan, strlen(lessThan))) {
            setConditionalValue(false_value, tok, value + 1);
        } else {
            setConditionalValue(false_value, tok, value);
        }
    } else {
        const char* greaterThan = "">"";
        const char* lessThan = ""<"";
        if (lhs)
            std::swa...",1,1,lib/valueflow.cpp,"setConditionalValues:void(Token*,bool,MathLib.bigint,ValueFlow.Value&,ValueFlow.Value&)",<empty>,,false,239,273,setConditionalValues,,,1,"void(Token*,bool,MathLib.bigint,ValueFlow.Value&,ValueFlow.Value&)"
111669153936,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isSaturated(MathLib::bigint value)
{
    return value == std::numeric_limits<MathLib::bigint>::max() || value == std::numeric_limits<MathLib::bigint>::min();
}",1,1,lib/valueflow.cpp,isSaturated:bool(MathLib.bigint),<empty>,,false,275,278,isSaturated,,,1,bool(MathLib.bigint)
111669153937,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void parseCompareEachInt(
    const Token* tok,
    const std::function<void(const Token* varTok, ValueFlow::Value true_value, ValueFlow::Value false_value)>& each,
    const std::function<std::vector<ValueFlow::Value>(const Token*)>& evaluate)
{
    if (!tok->astOperand1() || !tok->astOperand2())
        return;
    if (tok->isComparisonOp()) {
        std::vector<ValueFlow::Value> value1 = evaluate(tok->astOperand1());
        std::vector<ValueFlow::Value> value2 = evaluate(tok->astOperand2());
        if (!value1.empty() && !value2.empty()) {
            if (tok->astOperand1()->hasKnownIntValue())
                value2.clear();
            if (tok->astOperand2()->hasKnownIntValue())
                value1.clear();
        }
        for (const ValueFlow::Value& v1 : value1) {
            if (isSaturated(v1.intvalue) || astIsFloat(tok->astOperand2(), /*unknown*/ false))
                continue;
            ValueFlow::Value true_value = v1;
            ValueFlow::Value fals...",1,1,lib/valueflow.cpp,"parseCompareEachInt:void(Token*,std.function<void(constToken*,ValueFlow.Value,ValueFlow.Value)>&,std.function<std.vector<ValueFlow.Value>(constToken*)>&)",<empty>,,false,280,313,parseCompareEachInt,,,1,"void(Token*,std.function<void(constToken*,ValueFlow.Value,ValueFlow.Value)>&,std.function<std.vector<ValueFlow.Value>(constToken*)>&)"
111669153938,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
            if (v.path < 1)
                return false;
            if (!isNonConditionalPossibleIntValue(v))
                return false;
            return true;
        }",92,9,lib/valueflow.cpp,lib/valueflow.cpp:<global>.parseCompareEachInt.<lambda>1.<lambda>2:bool(ValueFlow.Value&),<empty>,,false,323,329,<lambda>2,,,1,bool(ValueFlow.Value&)
111669153939,METHOD,<empty>,<empty>,"[](const Token* t) -> std::vector<ValueFlow::Value> {
        if (const ValueFlow::Value* v = t->getKnownValue(ValueFlow::Value::ValueType::INT))
            return {*v};
        std::vector<ValueFlow::Value> result;
        std::copy_if(t->values().cbegin(), t->values().cend(), std::back_inserter(result), [&](const ValueFlow::Value& v) {
            if (v.path < 1)
                return false;
            if (!isNonConditionalPossibleIntValue(v))
                return false;
            return true;
        });
        return result;
    }",36,5,lib/valueflow.cpp,lib/valueflow.cpp:<global>.parseCompareEachInt.<lambda>1:vector<ValueFlow::Value>(Token*),<empty>,,false,319,331,<lambda>1,,,1,vector<ValueFlow::Value>(Token*)
111669153940,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void parseCompareEachInt(
    const Token* tok,
    const std::function<void(const Token* varTok, ValueFlow::Value true_value, ValueFlow::Value false_value)>& each)
{
    parseCompareEachInt(tok, each, [](const Token* t) -> std::vector<ValueFlow::Value> {
        if (const ValueFlow::Value* v = t->getKnownValue(ValueFlow::Value::ValueType::INT))
            return {*v};
        std::vector<ValueFlow::Value> result;
        std::copy_if(t->values().cbegin(), t->values().cend(), std::back_inserter(result), [&](const ValueFlow::Value& v) {
            if (v.path < 1)
                return false;
            if (!isNonConditionalPossibleIntValue(v))
                return false;
            return true;
        });
        return result;
    });
}",1,1,lib/valueflow.cpp,"parseCompareEachInt:void(Token*,std.function<void(constToken*,ValueFlow.Value,ValueFlow.Value)>&)",<empty>,,false,315,332,parseCompareEachInt,,,1,"void(Token*,std.function<void(constToken*,ValueFlow.Value,ValueFlow.Value)>&)"
111669153941,METHOD,<empty>,<empty>,"[&](const Token* vartok, ValueFlow::Value true_value2, ValueFlow::Value false_value2) {
        if (result)
            return;
        result = vartok;
        true_value = std::move(true_value2);
        false_value = std::move(false_value2);
    }",9,5,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.parseCompareInt.<lambda>3:void(Token*,ValueFlow.Value,ValueFlow.Value)",<empty>,,false,342,348,<lambda>3,,,1,"void(Token*,ValueFlow.Value,ValueFlow.Value)"
111669153942,METHOD,<empty>,<empty>,"[&](MathLib::bigint i) {
            return ValueFlow::Value{i};
        }",69,9,lib/valueflow.cpp,lib/valueflow.cpp:<global>.ValueFlow.parseCompareInt.<lambda>4.<lambda>5:ValueFlow.Value(MathLib.bigint),<empty>,,false,353,355,<lambda>5,,,1,ValueFlow.Value(MathLib.bigint)
111669153943,METHOD,<empty>,<empty>,"[&](const Token* t) -> std::vector<ValueFlow::Value> {
        std::vector<ValueFlow::Value> r;
        std::vector<MathLib::bigint> v = evaluate(t);

        std::transform(v.cbegin(), v.cend(), std::back_inserter(r), [&](MathLib::bigint i) {
            return ValueFlow::Value{i};
        });
        return r;
    }",9,5,lib/valueflow.cpp,lib/valueflow.cpp:<global>.ValueFlow.parseCompareInt.<lambda>4:vector<ValueFlow::Value>(Token*),<empty>,,false,349,357,<lambda>4,,,1,vector<ValueFlow::Value>(Token*)
111669153944,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"const Token* ValueFlow::parseCompareInt(const Token* tok,
                                        ValueFlow::Value& true_value,
                                        ValueFlow::Value& false_value,
                                        const std::function<std::vector<MathLib::bigint>(const Token*)>& evaluate)
{
    const Token* result = nullptr;
    parseCompareEachInt(
        tok,
        [&](const Token* vartok, ValueFlow::Value true_value2, ValueFlow::Value false_value2) {
        if (result)
            return;
        result = vartok;
        true_value = std::move(true_value2);
        false_value = std::move(false_value2);
    },
        [&](const Token* t) -> std::vector<ValueFlow::Value> {
        std::vector<ValueFlow::Value> r;
        std::vector<MathLib::bigint> v = evaluate(t);

        std::transform(v.cbegin(), v.cend(), std::back_inserter(r), [&](MathLib::bigint i) {
            return ValueFlow::Value{i};
        });
        return r;
    });
    return result;
}",1,1,lib/valueflow.cpp,"ValueFlow.parseCompareInt:Token*(Token*,ValueFlow.Value&,ValueFlow.Value&,std.function<std.vector<MathLib.bigint>(constToken*)>&)",<empty>,,false,334,359,parseCompareInt,,,1,"Token*(Token*,ValueFlow.Value&,ValueFlow.Value&,std.function<std.vector<MathLib.bigint>(constToken*)>&)"
111669153945,METHOD,<empty>,<empty>,"[](const Token* t) -> std::vector<MathLib::bigint> {
        if (const ValueFlow::Value* v = t->getKnownValue(Value::ValueType::INT))
            return {v->intvalue};
        return std::vector<MathLib::bigint>{};
    }",58,5,lib/valueflow.cpp,lib/valueflow.cpp:<global>.ValueFlow.parseCompareInt.<lambda>6:vector<MathLib::bigint>(Token*),<empty>,,false,363,367,<lambda>6,,,1,vector<MathLib::bigint>(Token*)
111669153946,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"const Token *ValueFlow::parseCompareInt(const Token *tok, ValueFlow::Value &true_value, ValueFlow::Value &false_value)
{
    return parseCompareInt(tok, true_value, false_value, [](const Token* t) -> std::vector<MathLib::bigint> {
        if (const ValueFlow::Value* v = t->getKnownValue(Value::ValueType::INT))
            return {v->intvalue};
        return std::vector<MathLib::bigint>{};
    });
}",1,1,lib/valueflow.cpp,"ValueFlow.parseCompareInt:Token*(Token*,ValueFlow.Value&,ValueFlow.Value&)",<empty>,,false,361,368,parseCompareInt,,,1,"Token*(Token*,ValueFlow.Value&,ValueFlow.Value&)"
111669153947,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isEscapeScope(const Token* tok, const Settings& settings, bool unknown = false)
{
    if (!Token::simpleMatch(tok, ""{""))
        return false;
    // TODO this search for termTok in all subscopes. It should check the end of the scope.
    const Token* termTok = Token::findmatch(tok, ""return|continue|break|throw|goto"", tok->link());
    if (termTok && termTok->scope() == tok->scope())
        return true;
    std::string unknownFunction;
    if (settings.library.isScopeNoReturn(tok->link(), &unknownFunction))
        return unknownFunction.empty() || unknown;
    return false;
}",1,1,lib/valueflow.cpp,"isEscapeScope:bool(Token*,Settings&,bool)",<empty>,,false,370,382,isEscapeScope,,,1,"bool(Token*,Settings&,bool)"
111669153948,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"void ValueFlow::combineValueProperties(const ValueFlow::Value &value1, const ValueFlow::Value &value2, ValueFlow::Value &result)
{
    if (value1.isKnown() && value2.isKnown())
        result.setKnown();
    else if (value1.isImpossible() || value2.isImpossible())
        result.setImpossible();
    else if (value1.isInconclusive() || value2.isInconclusive())
        result.setInconclusive();
    else
        result.setPossible();
    if (value1.tokvalue)
        result.tokvalue = value1.tokvalue;
    else if (value2.tokvalue)
        result.tokvalue = value2.tokvalue;
    if (value1.isSymbolicValue()) {
        result.valueType = value1.valueType;
        result.tokvalue = value1.tokvalue;
    }
    if (value2.isSymbolicValue()) {
        result.valueType = value2.valueType;
        result.tokvalue = value2.tokvalue;
    }
    if (value1.isIteratorValue())
        result.valueType = value1.valueType;
    if (value2.isIteratorValue())
        result.valueType = value2.valueType;
   ...",1,1,lib/valueflow.cpp,"ValueFlow.combineValueProperties:void(ValueFlow.Value&,ValueFlow.Value&,ValueFlow.Value&)",<empty>,,false,384,425,combineValueProperties,,,1,"void(ValueFlow.Value&,ValueFlow.Value&,ValueFlow.Value&)"
111669153949,METHOD,<empty>,<empty>,"[](MathLib::bigint i1, const Dimension& dim) {
                return i1 * dim.num;
            }",114,13,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.accumulateStructMembers.<lambda>7:longlongint(MathLib.bigint,Dimension&)",<empty>,,false,439,441,<lambda>7,,,1,"longlongint(MathLib.bigint,Dimension&)"
111669153950,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static size_t accumulateStructMembers(const Scope* scope, F f)
{
    size_t total = 0;
    std::set<const Scope*> anonScopes;
    for (const Variable& var : scope->varlist) {
        if (var.isStatic())
            continue;
        if (const ValueType* vt = var.valueType()) {
            if (vt->type == ValueType::Type::RECORD && vt->typeScope == scope)
                return 0;
            const MathLib::bigint dim = std::accumulate(var.dimensions().cbegin(), var.dimensions().cend(), 1LL, [](MathLib::bigint i1, const Dimension& dim) {
                return i1 * dim.num;
            });
            if (var.nameToken()->scope() != scope && var.nameToken()->scope()->definedType) { // anonymous union
                const auto ret = anonScopes.insert(var.nameToken()->scope());
                if (ret.second)
                    total = f(total, *vt, dim);
            }
            else
                total = f(total, *vt, dim);
        }
        if (total == 0)
            return 0;...",1,1,lib/valueflow.cpp,"accumulateStructMembers:size_t(Scope*,F)",<empty>,,false,429,454,accumulateStructMembers,,,1,"size_t(Scope*,F)"
111669153951,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static size_t bitCeil(size_t x)
{
    if (x <= 1)
        return 1;
    --x;
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x |= x >> 32;
    return x + 1;
}",1,1,lib/valueflow.cpp,bitCeil:size_t(size_t),<empty>,,false,456,468,bitCeil,,,1,size_t(size_t)
111669153952,METHOD,<empty>,<empty>,"[&](size_t max, const ValueType& vt2, size_t /*dim*/) {
            size_t a = getAlignOf(vt2, settings, ++maxRecursion);
            return std::max(max, a);
        }",26,9,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.getAlignOf.<lambda>8:ANY(size_t,ValueType&,size_t)",<empty>,,false,481,484,<lambda>8,,,1,"ANY(size_t,ValueType&,size_t)"
111669153953,METHOD,<empty>,<empty>,"[&](size_t v, const Type::BaseInfo& bi) {
                if (bi.type && bi.type->classScope)
                    v += accumulateStructMembers(bi.type->classScope, accHelper);
                return v;
            }",92,13,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.getAlignOf.<lambda>9:ANY(size_t,Type.BaseInfo&)",<empty>,,false,487,491,<lambda>9,,,1,"ANY(size_t,Type.BaseInfo&)"
111669153954,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static size_t getAlignOf(const ValueType& vt, const Settings& settings, int maxRecursion = 0)
{
    if (maxRecursion == settings.vfOptions.maxAlignOfRecursion) {
        // TODO: add bailout message
        return 0;
    }
    if (vt.pointer || vt.reference != Reference::None || vt.isPrimitive()) {
        auto align = ValueFlow::getSizeOf(vt, settings);
        return align == 0 ? 0 : bitCeil(align);
    }
    if (vt.type == ValueType::Type::RECORD && vt.typeScope) {
        auto accHelper = [&](size_t max, const ValueType& vt2, size_t /*dim*/) {
            size_t a = getAlignOf(vt2, settings, ++maxRecursion);
            return std::max(max, a);
        };
        size_t total = 0;
        if (const Type* dt = vt.typeScope->definedType) {
            total = std::accumulate(dt->derivedFrom.begin(), dt->derivedFrom.end(), total, [&](size_t v, const Type::BaseInfo& bi) {
                if (bi.type && bi.type->classScope)
                    v += accumulateStructMembers(bi.type->cl...",1,1,lib/valueflow.cpp,"getAlignOf:size_t(ValueType&,Settings&,int)",<empty>,,false,470,498,getAlignOf,,,1,"size_t(ValueType&,Settings&,int)"
111669153955,METHOD,<empty>,<empty>,"[&](size_t total, const ValueType& vt2, size_t dim) -> size_t {
            size_t n = ValueFlow::getSizeOf(vt2, settings, ++maxRecursion);
            size_t a = getAlignOf(vt2, settings);
            if (n == 0 || a == 0)
                return 0;
            n *= dim;
            size_t padding = (a - (total % a)) % a;
            return vt.typeScope->type == ScopeType::eUnion ? std::max(total, n) : total + padding + n;
        }",26,9,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.getSizeOf.<lambda>10:size_t(size_t,ValueType&,size_t)",<empty>,,false,529,537,<lambda>10,,,1,"size_t(size_t,ValueType&,size_t)"
111669153956,METHOD,<empty>,<empty>,"[&](size_t v, const Type::BaseInfo& bi) {
                if (bi.type && bi.type->classScope)
                    v += accumulateStructMembers(bi.type->classScope, accHelper);
                return v;
            }",92,13,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.getSizeOf.<lambda>11:ANY(size_t,Type.BaseInfo&)",<empty>,,false,540,544,<lambda>11,,,1,"ANY(size_t,Type.BaseInfo&)"
111669153957,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"size_t ValueFlow::getSizeOf(const ValueType &vt, const Settings &settings, int maxRecursion)
{
    if (maxRecursion == settings.vfOptions.maxSizeOfRecursion) {
        // TODO: add bailout message
        return 0;
    }
    if (vt.pointer || vt.reference != Reference::None)
        return settings.platform.sizeof_pointer;
    if (vt.type == ValueType::Type::BOOL || vt.type == ValueType::Type::CHAR)
        return 1;
    if (vt.type == ValueType::Type::SHORT)
        return settings.platform.sizeof_short;
    if (vt.type == ValueType::Type::WCHAR_T)
        return settings.platform.sizeof_wchar_t;
    if (vt.type == ValueType::Type::INT)
        return settings.platform.sizeof_int;
    if (vt.type == ValueType::Type::LONG)
        return settings.platform.sizeof_long;
    if (vt.type == ValueType::Type::LONGLONG)
        return settings.platform.sizeof_long_long;
    if (vt.type == ValueType::Type::FLOAT)
        return settings.platform.sizeof_float;
    if (vt.type == ValueType::T...",1,1,lib/valueflow.cpp,"ValueFlow.getSizeOf:size_t(ValueType&,Settings&,int)",<empty>,,false,500,555,getSizeOf,,,1,"size_t(ValueType&,Settings&,int)"
111669153958,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowNumber(TokenList &tokenlist, const Settings& settings)
{
    for (Token *tok = tokenlist.front(); tok;) {
        tok = ValueFlow::valueFlowSetConstantValue(tok, settings);
    }

    if (tokenlist.isCPP() || settings.standards.c >= Standards::C23) {
        for (Token *tok = tokenlist.front(); tok; tok = tok->next()) {
            if (tok->isName() && !tok->varId() && Token::Match(tok, ""false|true"")) {
                ValueFlow::Value value(tok->str() == ""true"");
                if (!tok->isTemplateArg())
                    value.setKnown();
                setTokenValue(tok, std::move(value), settings);
            } else if (Token::Match(tok, ""[(,] NULL [,)]"")) {
                // NULL function parameters are not simplified in the
                // normal tokenlist
                ValueFlow::Value value(0);
                if (!tok->isTemplateArg())
                    value.setKnown();
                setTokenValue(tok->next(), std::move(value), settings)...",1,1,lib/valueflow.cpp,"valueFlowNumber:void(TokenList&,Settings&)",<empty>,,false,557,580,valueFlowNumber,,,1,"void(TokenList&,Settings&)"
111669153959,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowString(TokenList& tokenlist, const Settings& settings)
{
    for (Token* tok = tokenlist.front(); tok; tok = tok->next()) {
        if (tok->tokType() == Token::eString) {
            ValueFlow::Value strvalue;
            strvalue.valueType = ValueFlow::Value::ValueType::TOK;
            strvalue.tokvalue = tok;
            strvalue.setKnown();
            setTokenValue(tok, std::move(strvalue), settings);
        }
    }
}",1,1,lib/valueflow.cpp,"valueFlowString:void(TokenList&,Settings&)",<empty>,,false,582,593,valueFlowString,,,1,"void(TokenList&,Settings&)"
111669153960,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowArray(TokenList& tokenlist, const Settings& settings)
{
    std::map<nonneg int, const Token*> constantArrays;

    for (Token* tok = tokenlist.front(); tok; tok = tok->next()) {
        if (tok->varId() > 0) {
            // array
            const auto it = utils::as_const(constantArrays).find(tok->varId());
            if (it != constantArrays.end()) {
                ValueFlow::Value value;
                value.valueType = ValueFlow::Value::ValueType::TOK;
                value.tokvalue = it->second;
                value.setKnown();
                setTokenValue(tok, std::move(value), settings);
            }

            // const array decl
            else if (tok->variable() && tok->variable()->isArray() && tok->variable()->isConst() &&
                     tok->variable()->nameToken() == tok && Token::Match(tok, ""%var% [ %num%| ] = {"")) {
                Token* rhstok = tok->linkAt(1)->tokAt(2);
                constantArrays[tok->varId()] = rhstok;
  ...",1,13,lib/valueflow.cpp,"valueFlowArray:void(TokenList&,Settings&)",<empty>,,false,595,648,valueFlowArray,,,1,"void(TokenList&,Settings&)"
111669153961,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isNonZero(const Token* tok)
{
    return tok && (!tok->hasKnownIntValue() || tok->getKnownIntValue() != 0);
}",1,1,lib/valueflow.cpp,isNonZero:bool(Token*),<empty>,,false,650,653,isNonZero,,,1,bool(Token*)
111669153962,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static const Token* getOtherOperand(const Token* tok)
{
    if (!tok)
        return nullptr;
    if (!tok->astParent())
        return nullptr;
    if (tok->astParent()->astOperand1() != tok)
        return tok->astParent()->astOperand1();
    if (tok->astParent()->astOperand2() != tok)
        return tok->astParent()->astOperand2();
    return nullptr;
}",1,1,lib/valueflow.cpp,getOtherOperand:Token*(Token*),<empty>,,false,655,666,getOtherOperand,,,1,Token*(Token*)
111669153963,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowArrayBool(TokenList& tokenlist, const Settings& settings)
{
    for (Token* tok = tokenlist.front(); tok; tok = tok->next()) {
        if (tok->hasKnownIntValue())
            continue;
        const Variable* var = nullptr;
        bool known = false;
        const auto val =
            std::find_if(tok->values().cbegin(), tok->values().cend(), std::mem_fn(&ValueFlow::Value::isTokValue));
        if (val == tok->values().end()) {
            var = tok->variable();
            known = true;
        } else {
            var = val->tokvalue->variable();
            known = val->isKnown();
        }
        if (!var)
            continue;
        if (!var->isArray() || var->isArgument() || var->isStlType())
            continue;
        if (isNonZero(getOtherOperand(tok)) && Token::Match(tok->astParent(), ""%comp%""))
            continue;
        // TODO: Check for function argument
        if ((astIsBool(tok->astParent()) && !Token::Match(tok->astParent(), ""(|%nam...",1,1,lib/valueflow.cpp,"valueFlowArrayBool:void(TokenList&,Settings&)",<empty>,,false,668,699,valueFlowArrayBool,,,1,"void(TokenList&,Settings&)"
111669153964,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowArrayElement(TokenList& tokenlist, const Settings& settings)
{
    for (Token* tok = tokenlist.front(); tok; tok = tok->next()) {
        if (tok->hasKnownIntValue())
            continue;
        const Token* indexTok = nullptr;
        const Token* arrayTok = nullptr;
        if (Token::simpleMatch(tok, ""["") && tok->isBinaryOp()) {
            indexTok = tok->astOperand2();
            arrayTok = tok->astOperand1();
        } else if (Token::Match(tok->tokAt(-2), "". %name% ("") && astIsContainer(tok->tokAt(-2)->astOperand1())) {
            arrayTok = tok->tokAt(-2)->astOperand1();
            const Library::Container* container = getLibraryContainer(arrayTok);
            if (!container || container->stdAssociativeLike)
                continue;
            const Library::Container::Yield yield = container->getYield(tok->strAt(-1));
            if (yield != Library::Container::Yield::AT_INDEX)
                continue;
            indexTok = tok->astOperand2()...",1,1,lib/valueflow.cpp,"valueFlowArrayElement:void(TokenList&,Settings&)",<empty>,,false,701,780,valueFlowArrayElement,,,1,"void(TokenList&,Settings&)"
111669153965,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowPointerAlias(TokenList& tokenlist, const Settings& settings)
{
    for (Token* tok = tokenlist.front(); tok; tok = tok->next()) {
        // not address of
        if (!tok->isUnaryOp(""&""))
            continue;

        // parent should be a '='
        if (!Token::simpleMatch(tok->astParent(), ""=""))
            continue;

        // child should be some buffer or variable
        const Token* vartok = tok->astOperand1();
        while (vartok) {
            if (vartok->str() == ""["")
                vartok = vartok->astOperand1();
            else if (vartok->str() == ""."" || vartok->str() == ""::"")
                vartok = vartok->astOperand2();
            else
                break;
        }
        if (!(vartok && vartok->variable() && !vartok->variable()->isPointer()))
            continue;

        ValueFlow::Value value;
        value.valueType = ValueFlow::Value::ValueType::TOK;
        value.tokvalue = tok;
        setTokenValue(tok, std::move(value), s...",1,1,lib/valueflow.cpp,"valueFlowPointerAlias:void(TokenList&,Settings&)",<empty>,,false,782,811,valueFlowPointerAlias,,,1,"void(TokenList&,Settings&)"
111669153966,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowBitAnd(TokenList& tokenlist, const Settings& settings)
{
    for (Token* tok = tokenlist.front(); tok; tok = tok->next()) {
        if (tok->str() != ""&"")
            continue;

        if (tok->hasKnownValue())
            continue;

        if (!tok->astOperand1() || !tok->astOperand2())
            continue;

        MathLib::bigint number;
        if (MathLib::isInt(tok->astOperand1()->str()))
            number = MathLib::toBigNumber(tok->astOperand1());
        else if (MathLib::isInt(tok->astOperand2()->str()))
            number = MathLib::toBigNumber(tok->astOperand2());
        else
            continue;

        int bit = 0;
        while (bit <= (MathLib::bigint_bits - 2) && ((((MathLib::bigint)1) << bit) < number))
            ++bit;

        if ((((MathLib::bigint)1) << bit) == number) {
            setTokenValue(tok, ValueFlow::Value(0), settings);
            setTokenValue(tok, ValueFlow::Value(number), settings);
        }
    }
}",1,1,lib/valueflow.cpp,"valueFlowBitAnd:void(TokenList&,Settings&)",<empty>,,false,813,842,valueFlowBitAnd,,,1,"void(TokenList&,Settings&)"
111669153967,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowSameExpressions(TokenList& tokenlist, const Settings& settings)
{
    for (Token* tok = tokenlist.front(); tok; tok = tok->next()) {
        if (tok->hasKnownIntValue())
            continue;

        if (!tok->astOperand1() || !tok->astOperand2())
            continue;

        if (tok->astOperand1()->isLiteral() || tok->astOperand2()->isLiteral())
            continue;

        if (!astIsIntegral(tok->astOperand1(), false) && !astIsIntegral(tok->astOperand2(), false))
            continue;

        long long val;

        if (Token::Match(tok, ""==|>=|<=|/"")) {
            val = 1;
        }
        else if (Token::Match(tok, ""!=|>|<|%|-"")) {
            val = 0;
        }
        else
            continue;

        ValueFlow::Value value(val);
        value.setKnown();

        if (isSameExpression(false, tok->astOperand1(), tok->astOperand2(), settings, true, true, &value.errorPath)) {
            setTokenValue(tok, std::move(value), settings);
        }
    }
}",1,1,lib/valueflow.cpp,"valueFlowSameExpressions:void(TokenList&,Settings&)",<empty>,,false,844,877,valueFlowSameExpressions,,,1,"void(TokenList&,Settings&)"
111669153968,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool getExpressionRange(const Token* expr, MathLib::bigint* minvalue, MathLib::bigint* maxvalue)
{
    if (const ValueFlow::Value* v = expr->getKnownValue(ValueFlow::Value::ValueType::INT)) {
        if (minvalue)
            *minvalue = v->intvalue;
        if (maxvalue)
            *maxvalue = v->intvalue;
        return true;
    }

    if (expr->str() == ""&"" && expr->astOperand1() && expr->astOperand2()) {
        MathLib::bigint vals[4];
        const bool lhsHasKnownRange = getExpressionRange(expr->astOperand1(), &vals[0], &vals[1]);
        const bool rhsHasKnownRange = getExpressionRange(expr->astOperand2(), &vals[2], &vals[3]);
        if (!lhsHasKnownRange && !rhsHasKnownRange)
            return false;
        if (!lhsHasKnownRange || !rhsHasKnownRange) {
            if (minvalue)
                *minvalue = lhsHasKnownRange ? vals[0] : vals[2];
            if (maxvalue)
                *maxvalue = lhsHasKnownRange ? vals[1] : vals[3];
        } else {
            ...",1,1,lib/valueflow.cpp,"getExpressionRange:bool(Token*,MathLib.bigint*,MathLib.bigint*)",<empty>,,false,879,930,getExpressionRange,,,1,"bool(Token*,MathLib.bigint*,MathLib.bigint*)"
111669153969,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowRightShift(TokenList& tokenList, const Settings& settings)
{
    for (Token* tok = tokenList.front(); tok; tok = tok->next()) {
        if (tok->str() != "">>"")
            continue;

        if (tok->hasKnownIntValue())
            continue;

        if (!tok->astOperand1() || !tok->astOperand2())
            continue;

        if (!tok->astOperand2()->hasKnownIntValue())
            continue;

        const MathLib::bigint rhsvalue = tok->astOperand2()->getKnownIntValue();
        if (rhsvalue < 0)
            continue;

        if (!tok->astOperand1()->valueType() || !tok->astOperand1()->valueType()->isIntegral())
            continue;

        if (!tok->astOperand2()->valueType() || !tok->astOperand2()->valueType()->isIntegral())
            continue;

        MathLib::bigint lhsmax = 0;
        if (!getExpressionRange(tok->astOperand1(), nullptr, &lhsmax))
            continue;
        if (lhsmax < 0)
            continue;
        std::uint8_t lhsbits;
     ...",1,1,lib/valueflow.cpp,"valueFlowRightShift:void(TokenList&,Settings&)",<empty>,,false,932,982,valueFlowRightShift,,,1,"void(TokenList&,Settings&)"
111669153970,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static std::vector<MathLib::bigint> minUnsignedValue(const Token* tok, int depth = 8)
{
    std::vector<MathLib::bigint> result;
    if (!tok)
        return result;
    if (depth < 0)
        return result;
    if (const ValueFlow::Value* v = tok->getKnownValue(ValueFlow::Value::ValueType::INT)) {
        result = {v->intvalue};
    } else if (!Token::Match(tok, ""-|%|&|^"") && tok->isConstOp() && tok->astOperand1() && tok->astOperand2()) {
        std::vector<MathLib::bigint> op1 = minUnsignedValue(tok->astOperand1(), depth - 1);
        if (!op1.empty()) {
            std::vector<MathLib::bigint> op2 = minUnsignedValue(tok->astOperand2(), depth - 1);
            if (!op2.empty()) {
                result = calculate<std::vector<MathLib::bigint>>(tok->str(), op1.front(), op2.front());
            }
        }
    }
    if (result.empty() && astIsUnsigned(tok))
        result = {0};
    return result;
}",1,1,lib/valueflow.cpp,"minUnsignedValue:vector<MathLib.bigint>(Token*,int)",<empty>,,false,984,1005,minUnsignedValue,,,1,"vector<MathLib::bigint>(Token*,int)"
111669153971,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isConvertedToIntegral(const Token* tok, const Settings& settings)
{
    if (!tok)
        return false;
    std::vector<ValueType> parentTypes = getParentValueTypes(tok, settings);
    if (parentTypes.empty())
        return false;
    const ValueType& vt = parentTypes.front();
    return vt.type != ValueType::UNKNOWN_INT && vt.isIntegral();
}",1,1,lib/valueflow.cpp,"isConvertedToIntegral:bool(Token*,Settings&)",<empty>,,false,1007,1016,isConvertedToIntegral,,,1,"bool(Token*,Settings&)"
111669153972,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isSameToken(const Token* tok1, const Token* tok2)
{
    if (!tok1 || !tok2)
        return false;
    if (tok1->exprId() != 0 && tok1->exprId() == tok2->exprId())
        return true;
    if (tok1->hasKnownIntValue() && tok2->hasKnownIntValue())
        return tok1->getKnownIntValue() == tok2->getKnownIntValue();
    return false;
}",1,1,lib/valueflow.cpp,"isSameToken:bool(Token*,Token*)",<empty>,,false,1018,1027,isSameToken,,,1,"bool(Token*,Token*)"
111669153973,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
                        if (!v.isKnown())
                            return false;
                        return v.isSymbolicValue();
                    }",34,21,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowImpossibleValues.<lambda>12:bool(ValueFlow.Value&),<empty>,,false,1078,1082,<lambda>12,,,1,bool(ValueFlow.Value&)
111669153974,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowImpossibleValues(TokenList& tokenList, const Settings& settings)
{
    for (Token* tok = tokenList.front(); tok; tok = tok->next()) {
        if (tok->hasKnownIntValue())
            continue;
        if (Token::Match(tok, ""true|false""))
            continue;
        if (astIsBool(tok) || Token::Match(tok, ""%comp%"")) {
            ValueFlow::Value lower{-1};
            lower.bound = ValueFlow::Value::Bound::Upper;
            lower.setImpossible();
            setTokenValue(tok, std::move(lower), settings);

            ValueFlow::Value upper{2};
            upper.bound = ValueFlow::Value::Bound::Lower;
            upper.setImpossible();
            setTokenValue(tok, std::move(upper), settings);
        } else if (astIsUnsigned(tok) && !astIsPointer(tok)) {
            std::vector<MathLib::bigint> minvalue = minUnsignedValue(tok);
            if (minvalue.empty())
                continue;
            ValueFlow::Value value{std::max<MathLib::bigint>(0, minvalu...",1,1,lib/valueflow.cpp,"valueFlowImpossibleValues:void(TokenList&,Settings&)",<empty>,,false,1029,1139,valueFlowImpossibleValues,,,1,"void(TokenList&,Settings&)"
111669153975,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowEnumValue(SymbolDatabase & symboldatabase, const Settings & settings)
{
    for (Scope & scope : symboldatabase.scopeList) {
        if (scope.type != ScopeType::eEnum)
            continue;
        MathLib::bigint value = 0;
        bool prev_enum_is_known = true;

        for (Enumerator & enumerator : scope.enumeratorList) {
            if (enumerator.start) {
                auto* rhs = const_cast<Token*>(enumerator.start->previous()->astOperand2());
                ValueFlow::valueFlowConstantFoldAST(rhs, settings);
                if (rhs && rhs->hasKnownIntValue()) {
                    enumerator.value = rhs->getKnownIntValue();
                    enumerator.value_known = true;
                    value = enumerator.value + 1;
                    prev_enum_is_known = true;
                } else
                    prev_enum_is_known = false;
            } else if (prev_enum_is_known) {
                enumerator.value = value++;
                enumera...",1,1,lib/valueflow.cpp,"valueFlowEnumValue:void(SymbolDatabase&,Settings&)",<empty>,,false,1141,1166,valueFlowEnumValue,,,1,"void(SymbolDatabase&,Settings&)"
111669153976,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowGlobalConstVar(TokenList& tokenList, const Settings& settings)
{
    // Get variable values...
    std::map<const Variable*, ValueFlow::Value> vars;
    for (const Token* tok = tokenList.front(); tok; tok = tok->next()) {
        if (!tok->variable())
            continue;
        // Initialization...
        if (tok == tok->variable()->nameToken() && !tok->variable()->isVolatile() && !tok->variable()->isArgument() &&
            tok->variable()->isConst() && tok->valueType() && tok->valueType()->isIntegral() &&
            tok->valueType()->pointer == 0 && tok->valueType()->constness == 1 && Token::Match(tok, ""%name% ="") &&
            tok->next()->astOperand2() && tok->next()->astOperand2()->hasKnownIntValue()) {
            vars[tok->variable()] = *tok->next()->astOperand2()->getKnownValue(ValueFlow::Value::ValueType::INT);
        }
    }

    // Set values..
    for (Token* tok = tokenList.front(); tok; tok = tok->next()) {
        if (!tok->variable())
   ...",1,1,lib/valueflow.cpp,"valueFlowGlobalConstVar:void(TokenList&,Settings&)",<empty>,,false,1168,1193,valueFlowGlobalConstVar,,,1,"void(TokenList&,Settings&)"
111669153977,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowGlobalStaticVar(TokenList& tokenList, const Settings& settings)
{
    // Get variable values...
    std::map<const Variable*, ValueFlow::Value> vars;
    for (const Token* tok = tokenList.front(); tok; tok = tok->next()) {
        if (!tok->variable())
            continue;
        // Initialization...
        if (tok == tok->variable()->nameToken() && tok->variable()->isStatic() && !tok->variable()->isConst() &&
            tok->valueType() && tok->valueType()->isIntegral() && tok->valueType()->pointer == 0 &&
            tok->valueType()->constness == 0 && Token::Match(tok, ""%name% ="") && tok->next()->astOperand2() &&
            tok->next()->astOperand2()->hasKnownIntValue()) {
            vars[tok->variable()] = *tok->next()->astOperand2()->getKnownValue(ValueFlow::Value::ValueType::INT);
        } else {
            // If variable is written anywhere in TU then remove it from vars
            if (!tok->astParent())
                continue;
            if (...",1,1,lib/valueflow.cpp,"valueFlowGlobalStaticVar:void(TokenList&,Settings&)",<empty>,,false,1195,1235,valueFlowGlobalStaticVar,,,1,"void(TokenList&,Settings&)"
111669153978,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static Analyzer::Result valueFlowForward(Token* startToken,
                                         const Token* endToken,
                                         const Token* exprTok,
                                         ValueFlow::Value value,
                                         const TokenList& tokenlist,
                                         ErrorLogger& errorLogger,
                                         const Settings& settings,
                                         SourceLocation loc = SourceLocation::current())
{
    if (settings.debugnormal)
        setSourceLocation(value, loc, startToken);
    return valueFlowGenericForward(startToken,
                                   endToken,
                                   makeAnalyzer(exprTok, std::move(value), settings),
                                   tokenlist,
                                   errorLogger,
                                   settings);
}",1,1,lib/valueflow.cpp,"valueFlowForward:Analyzer.Result(Token*,Token*,Token*,ValueFlow.Value,TokenList&,ErrorLogger&,Settings&,SourceLocation)",<empty>,,false,1237,1254,valueFlowForward,,,1,"Analyzer.Result(Token*,Token*,Token*,ValueFlow.Value,TokenList&,ErrorLogger&,Settings&,SourceLocation)"
111669153979,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static Analyzer::Result valueFlowForward(Token* startToken,
                                         const Token* endToken,
                                         const Token* exprTok,
                                         std::list<ValueFlow::Value> values,
                                         const TokenList& tokenlist,
                                         ErrorLogger& errorLogger,
                                         const Settings& settings,
                                         SourceLocation loc = SourceLocation::current())
{
    Analyzer::Result result{};
    for (ValueFlow::Value& v : values) {
        result.update(valueFlowForward(startToken, endToken, exprTok, std::move(v), tokenlist, errorLogger, settings, loc));
    }
    return result;
}",1,1,lib/valueflow.cpp,"valueFlowForward:Analyzer.Result(Token*,Token*,Token*,std.list<ValueFlow.Value>,TokenList&,ErrorLogger&,Settings&,SourceLocation)",<empty>,,false,1256,1270,valueFlowForward,,,1,"Analyzer.Result(Token*,Token*,Token*,std.list<ValueFlow.Value>,TokenList&,ErrorLogger&,Settings&,SourceLocation)"
111669153980,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static Analyzer::Result valueFlowForward(Token* startToken,
                                         const Token* exprTok,
                                         ValueOrValues v,
                                         const TokenList& tokenlist,
                                         ErrorLogger& errorLogger,
                                         const Settings& settings,
                                         SourceLocation loc = SourceLocation::current())
{
    const Token* endToken = nullptr;
    const Function* f = Scope::nestedInFunction(startToken->scope());
    if (f && f->functionScope)
        endToken = f->functionScope->bodyEnd;
    if (!endToken && exprTok && exprTok->variable() && !exprTok->variable()->isLocal())
        endToken = startToken->scope()->bodyEnd;
    return valueFlowForward(startToken, endToken, exprTok, std::move(v), tokenlist, errorLogger, settings, loc);
}",1,1,lib/valueflow.cpp,"valueFlowForward:Result(Token*,Token*,ValueOrValues,TokenList&,ErrorLogger&,Settings&,SourceLocation)",<empty>,,false,1273,1288,valueFlowForward,,,1,"Result(Token*,Token*,ValueOrValues,TokenList&,ErrorLogger&,Settings&,SourceLocation)"
111669153981,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static Analyzer::Result valueFlowForwardRecursive(Token* top,
                                                  const Token* exprTok,
                                                  std::list<ValueFlow::Value> values,
                                                  const TokenList& tokenlist,
                                                  ErrorLogger& errorLogger,
                                                  const Settings& settings,
                                                  SourceLocation loc = SourceLocation::current())
{
    Analyzer::Result result{};
    for (ValueFlow::Value& v : values) {
        if (settings.debugnormal)
            setSourceLocation(v, loc, top);
        result.update(
            valueFlowGenericForward(top, makeAnalyzer(exprTok, std::move(v), settings), tokenlist, errorLogger, settings));
    }
    return result;
}",1,1,lib/valueflow.cpp,"valueFlowForwardRecursive:Analyzer.Result(Token*,Token*,std.list<ValueFlow.Value>,TokenList&,ErrorLogger&,Settings&,SourceLocation)",<empty>,,false,1290,1306,valueFlowForwardRecursive,,,1,"Analyzer.Result(Token*,Token*,std.list<ValueFlow.Value>,TokenList&,ErrorLogger&,Settings&,SourceLocation)"
111669153982,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowReverse(Token* tok,
                             const Token* const endToken,
                             const Token* const varToken,
                             std::list<ValueFlow::Value> values,
                             const TokenList& tokenlist,
                             ErrorLogger& errorLogger,
                             const Settings& settings,
                             SourceLocation loc = SourceLocation::current())
{
    for (ValueFlow::Value& v : values) {
        if (settings.debugnormal)
            setSourceLocation(v, loc, tok);
        valueFlowGenericReverse(tok,
                                endToken,
                                makeReverseAnalyzer(varToken, std::move(v), settings),
                                tokenlist,
                                errorLogger,
                                settings);
    }
}",1,1,lib/valueflow.cpp,"valueFlowReverse:void(Token*,Token*,Token*,std.list<ValueFlow.Value>,TokenList&,ErrorLogger&,Settings&,SourceLocation)",<empty>,,false,1308,1327,valueFlowReverse,,,1,"void(Token*,Token*,Token*,std.list<ValueFlow.Value>,TokenList&,ErrorLogger&,Settings&,SourceLocation)"
111669153983,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowReverse(const TokenList& tokenlist,
                             Token* tok,
                             const Token* const varToken,
                             ValueFlow::Value val,
                             ErrorLogger& errorLogger,
                             const Settings& settings,
                             SourceLocation loc = SourceLocation::current())
{
    valueFlowReverse(tok, nullptr, varToken, {std::move(val)}, tokenlist, errorLogger, settings, loc);
}",1,1,lib/valueflow.cpp,"valueFlowReverse:void(TokenList&,Token*,Token*,ValueFlow.Value,ErrorLogger&,Settings&,SourceLocation)",<empty>,,false,1330,1339,valueFlowReverse,,,1,"void(TokenList&,Token*,Token*,ValueFlow.Value,ErrorLogger&,Settings&,SourceLocation)"
111669153984,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isConditionKnown(const Token* tok, bool then)
{
    const char* op = ""||"";
    if (then)
        op = ""&&"";
    const Token* parent = tok->astParent();
    while (parent && (parent->str() == op || parent->str() == ""!"" || parent->isCast()))
        parent = parent->astParent();
    const Token* top = tok->astTop();
    if (Token::Match(top->previous(), ""if|while|for (""))
        return parent == top || Token::simpleMatch(parent, "";"");
    return parent && parent->str() != op;
}",1,1,lib/valueflow.cpp,"isConditionKnown:bool(Token*,bool)",<empty>,,false,1341,1353,isConditionKnown,,,1,"bool(Token*,bool)"
111669153985,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static std::string lifetimeType(const Token *tok, const ValueFlow::Value *val)
{
    std::string result;
    if (!val)
        return ""object"";
    switch (val->lifetimeKind) {
    case ValueFlow::Value::LifetimeKind::Lambda:
        result = ""lambda"";
        break;
    case ValueFlow::Value::LifetimeKind::Iterator:
        result = ""iterator"";
        break;
    case ValueFlow::Value::LifetimeKind::Object:
    case ValueFlow::Value::LifetimeKind::SubObject:
    case ValueFlow::Value::LifetimeKind::Address:
        if (astIsPointer(tok))
            result = ""pointer"";
        else if (Token::simpleMatch(tok, ""="") && astIsPointer(tok->astOperand2()))
            result = ""pointer"";
        else
            result = ""object"";
        break;
    }
    return result;
}",1,1,lib/valueflow.cpp,"lifetimeType:string(Token*,ValueFlow.Value*)",<empty>,,false,1357,1381,lifetimeType,,,1,"string(Token*,ValueFlow.Value*)"
111669153986,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"std::string ValueFlow::lifetimeMessage(const Token *tok, const ValueFlow::Value *val, ErrorPath &errorPath)
{
    const Token *tokvalue = val ? val->tokvalue : nullptr;
    const Variable *tokvar = tokvalue ? tokvalue->variable() : nullptr;
    const Token *vartok = tokvar ? tokvar->nameToken() : nullptr;
    const bool classVar = tokvar ? (!tokvar->isLocal() && !tokvar->isArgument() && !tokvar->isGlobal()) : false;
    std::string type = lifetimeType(tok, val);
    std::string msg = type;
    if (vartok) {
        if (!classVar)
            errorPath.emplace_back(vartok, ""Variable created here."");
        const Variable * var = vartok->variable();
        if (var) {
            std::string submessage;
            switch (val->lifetimeKind) {
            case ValueFlow::Value::LifetimeKind::SubObject:
            case ValueFlow::Value::LifetimeKind::Object:
            case ValueFlow::Value::LifetimeKind::Address:
                if (type == ""pointer"")
                    submessage...",1,1,lib/valueflow.cpp,"ValueFlow.lifetimeMessage:string(Token*,ValueFlow.Value*,ErrorPath&)",<empty>,,false,1383,1419,lifetimeMessage,,,1,"string(Token*,ValueFlow.Value*,ErrorPath&)"
111669153987,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
        if (!v.isLocalLifetimeValue() && !(path != 0 && v.isSubFunctionLifetimeValue()))
            return false;
        if (!inconclusive && v.isInconclusive())
            return false;
        if (!v.tokvalue)
            return false;
        if (path >= 0 && v.path != 0 && v.path != path)
            return false;
        return true;
    }",17,5,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.getLifetimeObjValues:vector<ValueFlow.Value>(Token*,bool,MathLib.bigint).<lambda>13:bool(ValueFlow.Value&)",<empty>,,false,1424,1434,<lambda>13,,,1,bool(ValueFlow.Value&)
111669153988,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"std::vector<ValueFlow::Value> ValueFlow::getLifetimeObjValues(const Token* tok, bool inconclusive, MathLib::bigint path)
{
    std::vector<ValueFlow::Value> result;
    auto pred = [&](const ValueFlow::Value& v) {
        if (!v.isLocalLifetimeValue() && !(path != 0 && v.isSubFunctionLifetimeValue()))
            return false;
        if (!inconclusive && v.isInconclusive())
            return false;
        if (!v.tokvalue)
            return false;
        if (path >= 0 && v.path != 0 && v.path != path)
            return false;
        return true;
    };
    std::copy_if(tok->values().cbegin(), tok->values().cend(), std::back_inserter(result), pred);
    return result;
}",1,1,lib/valueflow.cpp,"ValueFlow.getLifetimeObjValues:vector<ValueFlow.Value>(Token*,bool,MathLib.bigint)",<empty>,,false,1421,1437,getLifetimeObjValues,,,1,"vector<ValueFlow::Value>(Token*,bool,MathLib.bigint)"
111669153989,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool hasUniqueOwnership(const Token* tok)
{
    if (!tok)
        return false;
    const Variable* var = tok->variable();
    if (var && var->isArray() && !var->isArgument())
        return true;
    if (astIsPointer(tok))
        return false;
    if (astIsUniqueSmartPointer(tok))
        return true;
    if (astIsContainerOwned(tok))
        return true;
    return false;
}",1,1,lib/valueflow.cpp,hasUniqueOwnership:bool(Token*),<empty>,,false,1439,1453,hasUniqueOwnership,,,1,bool(Token*)
111669153990,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool derefShared(const Token* tok)
{
    if (!tok)
        return false;
    if (!tok->isUnaryOp(""*"") && tok->str() != ""["" && tok->str() != ""."")
        return false;
    if (tok->str() == ""."" && tok->originalName() != ""->"")
        return false;
    const Token* ptrTok = tok->astOperand1();
    return !hasUniqueOwnership(ptrTok);
}",1,1,lib/valueflow.cpp,derefShared:bool(Token*),<empty>,,false,1456,1466,derefShared,,,1,bool(Token*)
111669153991,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"ValueFlow::Value ValueFlow::getLifetimeObjValue(const Token *tok, bool inconclusive)
{
    std::vector<ValueFlow::Value> values = ValueFlow::getLifetimeObjValues(tok, inconclusive);
    // There should only be one lifetime
    if (values.size() != 1)
        return ValueFlow::Value{};
    return values.front();
}",1,1,lib/valueflow.cpp,"ValueFlow.getLifetimeObjValue:ValueFlow.Value(Token*,bool)",<empty>,,false,1468,1475,getLifetimeObjValue,,,1,"ValueFlow.Value(Token*,bool)"
111669153992,METHOD,<empty>,<empty>,"[&](const ValueType& vt) {
            return vt.isTypeEqual(vartok->valueType());
        }",58,9,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.getLifetimeTokens:vector<ValueFlow.LifetimeToken>(Token*,bool,ErrorPath,Predicate,Settings&,int).<lambda>14:bool(ValueType&)",<empty>,,false,1624,1626,<lambda>14,,,1,bool(ValueType&)
111669153993,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static std::vector<ValueFlow::LifetimeToken> getLifetimeTokens(const Token* tok,
                                                               bool escape,
                                                               ErrorPath errorPath,
                                                               Predicate pred,
                                                               const Settings& settings,
                                                               int depth = 20)
{
    if (!tok)
        return std::vector<ValueFlow::LifetimeToken> {};
    if (Token::simpleMatch(tok, ""...""))
        return std::vector<ValueFlow::LifetimeToken>{};
    const Variable *var = tok->variable();
    if (pred(tok))
        return {{tok, std::move(errorPath)}};
    if (depth < 0)
        return {{tok, std::move(errorPath)}};
    if (var && var->declarationId() == tok->varId()) {
        if (var->isReference() || var->isRValueReference()) {
            const Token * const varDeclEndToken = ...",1,1,lib/valueflow.cpp,"getLifetimeTokens:vector<ValueFlow.LifetimeToken>(Token*,bool,ErrorPath,Predicate,Settings&,int)",<empty>,,false,1478,1631,getLifetimeTokens,,,1,"vector<ValueFlow::LifetimeToken>(Token*,bool,ErrorPath,Predicate,Settings&,int)"
111669153994,METHOD,<empty>,<empty>,"[](const Token*) {
        return false;
    }",65,5,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.getLifetimeTokens:vector<ValueFlow.LifetimeToken>(Token*,Settings&,bool,ErrorPath).<lambda>15:bool(Token*)",<empty>,,false,1635,1637,<lambda>15,,,1,bool(Token*)
111669153995,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"std::vector<ValueFlow::LifetimeToken> ValueFlow::getLifetimeTokens(const Token* tok, const Settings& settings, bool escape, ErrorPath errorPath)
{
    return getLifetimeTokens(tok, escape, std::move(errorPath), [](const Token*) {
        return false;
    }, settings);
}",1,1,lib/valueflow.cpp,"ValueFlow.getLifetimeTokens:vector<ValueFlow.LifetimeToken>(Token*,Settings&,bool,ErrorPath)",<empty>,,false,1633,1638,getLifetimeTokens,,,1,"vector<ValueFlow::LifetimeToken>(Token*,Settings&,bool,ErrorPath)"
111669153996,METHOD,<empty>,<empty>,"[&](const Token* tok2) {
        result = tok2->exprId() == lifetime->exprId();
        return result;
    }",48,5,lib/valueflow.cpp,lib/valueflow.cpp:<global>.ValueFlow.hasLifetimeToken.<lambda>16:bool(Token*),<empty>,,false,1643,1646,<lambda>16,,,1,bool(Token*)
111669153997,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"bool ValueFlow::hasLifetimeToken(const Token* tok, const Token* lifetime, const Settings& settings)
{
    bool result = false;
    getLifetimeTokens(tok, false, ErrorPath{}, [&](const Token* tok2) {
        result = tok2->exprId() == lifetime->exprId();
        return result;
    }, settings);
    return result;
}",1,1,lib/valueflow.cpp,"ValueFlow.hasLifetimeToken:bool(Token*,Token*,Settings&)",<empty>,,false,1640,1648,hasLifetimeToken,,,1,"bool(Token*,Token*,Settings&)"
111669153998,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static const Token* getLifetimeToken(const Token* tok, ErrorPath& errorPath, const Settings& settings, bool* addressOf = nullptr)
{
    std::vector<ValueFlow::LifetimeToken> lts = ValueFlow::getLifetimeTokens(tok, settings);
    if (lts.size() != 1)
        return nullptr;
    if (lts.front().inconclusive)
        return nullptr;
    if (addressOf)
        *addressOf = lts.front().addressOf;
    errorPath.insert(errorPath.end(), lts.front().errorPath.cbegin(), lts.front().errorPath.cend());
    return lts.front().token;
}",1,1,lib/valueflow.cpp,"getLifetimeToken:Token*(Token*,ErrorPath&,Settings&,bool*)",<empty>,,false,1650,1661,getLifetimeToken,,,1,"Token*(Token*,ErrorPath&,Settings&,bool*)"
111669153999,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"const Variable* ValueFlow::getLifetimeVariable(const Token* tok, ErrorPath& errorPath, const Settings& settings, bool* addressOf)
{
    const Token* tok2 = getLifetimeToken(tok, errorPath, settings, addressOf);
    if (tok2 && tok2->variable())
        return tok2->variable();
    return nullptr;
}",1,1,lib/valueflow.cpp,"ValueFlow.getLifetimeVariable:Variable*(Token*,ErrorPath&,Settings&,bool*)",<empty>,,false,1663,1669,getLifetimeVariable,,,1,"Variable*(Token*,ErrorPath&,Settings&,bool*)"
111669154000,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"const Variable* ValueFlow::getLifetimeVariable(const Token* tok, const Settings& settings)
{
    ErrorPath errorPath;
    return getLifetimeVariable(tok, errorPath, settings, nullptr);
}",1,1,lib/valueflow.cpp,"ValueFlow.getLifetimeVariable:Variable*(Token*,Settings&)",<empty>,,false,1671,1675,getLifetimeVariable,,,1,"Variable*(Token*,Settings&)"
111669154001,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isNotLifetimeValue(const ValueFlow::Value& val)
{
    return !val.isLifetimeValue();
}",1,1,lib/valueflow.cpp,isNotLifetimeValue:bool(ValueFlow.Value&),<empty>,,false,1677,1680,isNotLifetimeValue,,,1,bool(ValueFlow.Value&)
111669154002,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isLifetimeOwned(const ValueType* vtParent)
{
    if (vtParent->container)
        return !vtParent->container->view;
    return vtParent->type == ValueType::CONTAINER;
}",1,1,lib/valueflow.cpp,isLifetimeOwned:bool(ValueType*),<empty>,,false,1682,1687,isLifetimeOwned,,,1,bool(ValueType*)
111669154003,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isLifetimeOwned(const ValueType *vt, const ValueType *vtParent)
{
    if (!vtParent)
        return false;
    if (isLifetimeOwned(vtParent))
        return true;
    if (!vt)
        return false;
    // If converted from iterator to pointer then the iterator is most likely a pointer
    if (vtParent->pointer == 1 && vt->pointer == 0 && vt->type == ValueType::ITERATOR)
        return false;
    if (vt->type != ValueType::UNKNOWN_TYPE && vtParent->type != ValueType::UNKNOWN_TYPE) {
        if (vt->pointer != vtParent->pointer)
            return true;
        if (vt->type != vtParent->type) {
            if (vtParent->type == ValueType::RECORD)
                return true;
            if (isLifetimeOwned(vtParent))
                return true;
        }
    }

    return false;
}",1,1,lib/valueflow.cpp,"isLifetimeOwned:bool(ValueType*,ValueType*)",<empty>,,false,1689,1712,isLifetimeOwned,,,1,"bool(ValueType*,ValueType*)"
111669154004,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isLifetimeBorrowed(const ValueType *vt, const ValueType *vtParent)
{
    if (!vtParent)
        return false;
    if (!vt)
        return false;
    if (vt->pointer > 0 && vt->pointer == vtParent->pointer)
        return true;
    if (vtParent->container && vtParent->container->view)
        return true;
    if (vt->type != ValueType::UNKNOWN_TYPE && vtParent->type != ValueType::UNKNOWN_TYPE && vtParent->container == vt->container) {
        if (vtParent->pointer > vt->pointer)
            return true;
        if (vtParent->pointer < vt->pointer && vtParent->isIntegral())
            return true;
        if (vtParent->str() == vt->str())
            return true;
    }

    return false;
}",1,1,lib/valueflow.cpp,"isLifetimeBorrowed:bool(ValueType*,ValueType*)",<empty>,,false,1714,1734,isLifetimeBorrowed,,,1,"bool(ValueType*,ValueType*)"
111669154005,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static const Token* skipCVRefs(const Token* tok, const Token* endTok)
{
    while (tok != endTok && Token::Match(tok, ""const|volatile|auto|&|&&""))
        tok = tok->next();
    return tok;
}",1,1,lib/valueflow.cpp,"skipCVRefs:Token*(Token*,Token*)",<empty>,,false,1736,1741,skipCVRefs,,,1,"Token*(Token*,Token*)"
111669154006,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isNotEqual(std::pair<const Token*, const Token*> x, std::pair<const Token*, const Token*> y)
{
    const Token* start1 = x.first;
    const Token* start2 = y.first;
    if (start1 == nullptr || start2 == nullptr)
        return false;
    while (start1 != x.second && start2 != y.second) {
        const Token* tok1 = skipCVRefs(start1, x.second);
        if (tok1 != start1) {
            start1 = tok1;
            continue;
        }
        const Token* tok2 = skipCVRefs(start2, y.second);
        if (tok2 != start2) {
            start2 = tok2;
            continue;
        }
        if (start1->str() != start2->str())
            return true;
        start1 = start1->next();
        start2 = start2->next();
    }
    start1 = skipCVRefs(start1, x.second);
    start2 = skipCVRefs(start2, y.second);
    return !(start1 == x.second && start2 == y.second);
}",1,1,lib/valueflow.cpp,"isNotEqual:bool(std.pair<constToken*,constToken*>,std.pair<constToken*,constToken*>)",<empty>,,false,1743,1768,isNotEqual,,,1,"bool(std.pair<constToken*,constToken*>,std.pair<constToken*,constToken*>)"
111669154007,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isNotEqual(std::pair<const Token*, const Token*> x, const std::string& y, bool cpp)
{
    TokenList tokenList(nullptr);
    std::istringstream istr(y);
    tokenList.createTokens(istr, cpp ? Standards::Language::CPP : Standards::Language::C); // TODO: check result?
    return isNotEqual(x, std::make_pair(tokenList.front(), tokenList.back()));
}",1,1,lib/valueflow.cpp,"isNotEqual:bool(std.pair<constToken*,constToken*>,std.string&,bool)",<empty>,,false,1769,1775,isNotEqual,,,1,"bool(std.pair<constToken*,constToken*>,std.string&,bool)"
111669154008,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isNotEqual(std::pair<const Token*, const Token*> x, const ValueType* y, bool cpp)
{
    if (y == nullptr)
        return false;
    if (y->originalTypeName.empty())
        return false;
    return isNotEqual(x, y->originalTypeName, cpp);
}",1,1,lib/valueflow.cpp,"isNotEqual:bool(std.pair<constToken*,constToken*>,ValueType*,bool)",<empty>,,false,1776,1783,isNotEqual,,,1,"bool(std.pair<constToken*,constToken*>,ValueType*,bool)"
111669154009,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isDifferentType(const Token* src, const Token* dst)
{
    const Type* t = Token::typeOf(src);
    const Type* parentT = Token::typeOf(dst);
    if (t && parentT) {
        if (t->classDef && parentT->classDef && t->classDef != parentT->classDef)
            return true;
    } else {
        std::pair<const Token*, const Token*> decl = Token::typeDecl(src);
        std::pair<const Token*, const Token*> parentdecl = Token::typeDecl(dst);
        const bool isCpp = (src && src->isCpp()) || (dst && dst->isCpp());
        if (isNotEqual(decl, parentdecl) && !(isCpp && (Token::simpleMatch(decl.first, ""auto"") || Token::simpleMatch(parentdecl.first, ""auto""))))
            return true;
        if (isNotEqual(decl, dst->valueType(), isCpp))
            return true;
        if (isNotEqual(parentdecl, src->valueType(), isCpp))
            return true;
    }
    return false;
}",1,1,lib/valueflow.cpp,"isDifferentType:bool(Token*,Token*)",<empty>,,false,1785,1804,isDifferentType,,,1,"bool(Token*,Token*)"
111669154010,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"bool ValueFlow::isLifetimeBorrowed(const Token *tok, const Settings &settings)
{
    if (!tok)
        return true;
    if (tok->str() == "","")
        return true;
    if (!tok->astParent())
        return true;
    const Token* parent = nullptr;
    const ValueType* vt = tok->valueType();
    std::vector<ValueType> vtParents = getParentValueTypes(tok, settings, &parent);
    for (const ValueType& vtParent : vtParents) {
        if (isLifetimeBorrowed(vt, &vtParent))
            return true;
        if (isLifetimeOwned(vt, &vtParent))
            return false;
    }
    if (parent) {
        if (isDifferentType(tok, parent))
            return false;
    }
    return true;
}",1,1,lib/valueflow.cpp,"ValueFlow.isLifetimeBorrowed:bool(Token*,Settings&)",<empty>,,false,1806,1828,isLifetimeBorrowed,,,1,"bool(Token*,Settings&)"
111669154011,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isRangeForScope(const Scope* scope)
{
    if (!scope)
        return false;
    if (scope->type != ScopeType::eFor)
        return false;
    if (!scope->bodyStart)
        return false;
    if (!Token::simpleMatch(scope->bodyStart->previous(), "") {""))
        return false;
    return Token::simpleMatch(scope->bodyStart->linkAt(-1)->astOperand2(), "":"");
}",1,1,lib/valueflow.cpp,isRangeForScope:bool(Scope*),<empty>,,false,1837,1848,isRangeForScope,,,1,bool(Scope*)
111669154012,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static const Token* getEndOfVarScope(const Variable* var)
{
    if (!var)
        return nullptr;
    const Scope* innerScope = var->scope();
    const Scope* outerScope = innerScope;
    if (var->typeStartToken() && var->typeStartToken()->scope())
        outerScope = var->typeStartToken()->scope();
    if (!innerScope && outerScope)
        innerScope = outerScope;
    if (!innerScope || !outerScope)
        return nullptr;
    if (!innerScope->isExecutable())
        return nullptr;
    // If the variable is defined in a for/while initializer then we want to
    // pick one token after the end so forward analysis can analyze the exit
    // conditions
    if (innerScope != outerScope && outerScope->isExecutable() && innerScope->isLoopScope() &&
        !isRangeForScope(innerScope))
        return innerScope->bodyEnd->next();
    return innerScope->bodyEnd;
}",1,1,lib/valueflow.cpp,getEndOfVarScope:Token*(Variable*),<empty>,,false,1850,1871,getEndOfVarScope,,,1,Token*(Variable*)
111669154013,METHOD,<empty>,<empty>,"[&](const Token* child) {
        if (const Variable* var = child->variable()) {
            local |= var->isLocal();
            if (var->isLocal() || var->isArgument()) {
                const Token* varEnd = getEndOfVarScope(var);
                if (!end || (smallest ? precedes(varEnd, end) : succeeds(varEnd, end)))
                    end = varEnd;

                const Token* top = var->nameToken()->astTop();
                if (Token::simpleMatch(top->tokAt(-1), ""if ("")) { // variable declared in if (...)
                    const Token* elseTok = top->link()->linkAt(1);
                    if (Token::simpleMatch(elseTok, ""} else {"") && tok->scope()->isNestedIn(elseTok->tokAt(2)->scope()))
                        end = tok->scope()->bodyEnd;
                }
            }
        }
        return ChildrenToVisit::op1_and_op2;
    }",24,5,lib/valueflow.cpp,lib/valueflow.cpp:<global>.ValueFlow.getEndOfExprScope.<lambda>17:ChildrenToVisit(Token*),<empty>,,false,1877,1894,<lambda>17,,,1,ChildrenToVisit(Token*)
111669154014,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"const Token* ValueFlow::getEndOfExprScope(const Token* tok, const Scope* defaultScope, bool smallest)
{
    const Token* end = nullptr;
    bool local = false;
    visitAstNodes(tok, [&](const Token* child) {
        if (const Variable* var = child->variable()) {
            local |= var->isLocal();
            if (var->isLocal() || var->isArgument()) {
                const Token* varEnd = getEndOfVarScope(var);
                if (!end || (smallest ? precedes(varEnd, end) : succeeds(varEnd, end)))
                    end = varEnd;

                const Token* top = var->nameToken()->astTop();
                if (Token::simpleMatch(top->tokAt(-1), ""if ("")) { // variable declared in if (...)
                    const Token* elseTok = top->link()->linkAt(1);
                    if (Token::simpleMatch(elseTok, ""} else {"") && tok->scope()->isNestedIn(elseTok->tokAt(2)->scope()))
                        end = tok->scope()->bodyEnd;
                }
            }
        }
        retu...",1,1,lib/valueflow.cpp,"ValueFlow.getEndOfExprScope:Token*(Token*,Scope*,bool)",<empty>,,false,1873,1910,getEndOfExprScope,,,1,"Token*(Token*,Scope*,bool)"
111669154015,METHOD,<empty>,<empty>,"[&](const Token* child) {
                return child->exprId() == expr->exprId();
            }",48,13,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowForwardLifetime.<lambda>18.<lambda>19:bool(Token*),<empty>,,false,1949,1951,<lambda>19,,,1,bool(Token*)
111669154016,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& value) {
            return findAstNode(value.tokvalue, [&](const Token* child) {
                return child->exprId() == expr->exprId();
            });
        }",26,9,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowForwardLifetime.<lambda>18:Token*(ValueFlow.Value&),<empty>,,false,1948,1952,<lambda>18,,,1,Token*(ValueFlow.Value&)
111669154017,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowForwardLifetime(Token * tok, const TokenList &tokenlist, ErrorLogger &errorLogger, const Settings &settings)
{
    // Forward lifetimes to constructed variable
    if (Token::Match(tok->previous(), ""%var% {|("") && isVariableDecl(tok->previous())) {
        std::list<ValueFlow::Value> values = tok->values();
        values.remove_if(&isNotLifetimeValue);
        valueFlowForward(nextAfterAstRightmostLeaf(tok), ValueFlow::getEndOfExprScope(tok), tok->previous(), std::move(values), tokenlist, errorLogger, settings);
        return;
    }
    Token *parent = tok->astParent();
    while (parent && parent->str() == "","")
        parent = parent->astParent();
    if (!parent)
        return;
    // Assignment
    if (parent->str() == ""="" && (!parent->astParent() || Token::simpleMatch(parent->astParent(), "";""))) {
        // Rhs values..
        if (!parent->astOperand2() || parent->astOperand2()->values().empty())
            return;

        if (!ValueFlow::isLifetimeB...",1,1,lib/valueflow.cpp,"valueFlowForwardLifetime:void(Token*,TokenList&,ErrorLogger&,Settings&)",<empty>,,false,1912,2000,valueFlowForwardLifetime,,,1,"void(Token*,TokenList&,ErrorLogger&,Settings&)"
111669154018,METHOD,<empty>,<empty>,"[](const Token*) {
            return true;
        }",13,9,lib/valueflow.cpp,lib/valueflow.cpp:<global>.LifetimeStore.byRef.<lambda>20:bool(Token*),<empty>,,false,2119,2121,<lambda>20,,,1,bool(Token*)
111669154019,METHOD,<empty>,<empty>,"[](const Token*) {
            return true;
        }",13,9,lib/valueflow.cpp,lib/valueflow.cpp:<global>.LifetimeStore.byVal.<lambda>21:bool(Token*),<empty>,,false,2214,2216,<lambda>21,,,1,bool(Token*)
111669154020,METHOD,<empty>,<empty>,"[](const Token*) {
            return true;
        }",13,9,lib/valueflow.cpp,lib/valueflow.cpp:<global>.LifetimeStore.byDerefCopy<const>.<lambda>22:bool(Token*),<empty>,,false,2270,2272,<lambda>22,,,1,bool(Token*)
111669154021,METHOD,LifetimeStore,TYPE_DECL,LifetimeStore() = default;,5,30,lib/valueflow.cpp,LifetimeStore.LifetimeStore:ANY(),<empty>,,false,2010,2010,LifetimeStore,,,7,ANY()
111669154022,METHOD,LifetimeStore,TYPE_DECL,"LifetimeStore(const Token* argtok,
                  std::string message,
                  ValueFlow::Value::LifetimeKind type = ValueFlow::Value::LifetimeKind::Object,
                  bool inconclusive = false)
        : argtok(argtok),
        message(std::move(message)),
        type(type),
        inconclusive(inconclusive)
    {}",5,6,lib/valueflow.cpp,"LifetimeStore.LifetimeStore:ANY(Token*,std.string,ValueFlow.Value.LifetimeKind,bool)",<empty>,,false,2012,2020,LifetimeStore,,,8,"LifetimeStore.LifetimeStore:ANY(Token*,std.string,ValueFlow.Value.LifetimeKind,bool)(Token*,std.string,ValueFlow.Value.LifetimeKind,bool)"
111669154023,METHOD,LifetimeStore,TYPE_DECL,"static void forEach(const TokenList& tokenlist,
                        ErrorLogger& errorLogger,
                        const Settings& settings,
                        const std::vector<const Token*>& argtoks,
                        const std::string& message,
                        ValueFlow::Value::LifetimeKind type,
                        F f) {
        std::set<Token*> forwardToks;
        for (const Token* arg : argtoks) {
            LifetimeStore ls{arg, message, type};
            ls.forward = false;
            f(ls);
            if (ls.forwardTok)
                forwardToks.emplace(ls.forwardTok);
        }
        for (auto* tok : forwardToks) {
            valueFlowForwardLifetime(tok, tokenlist, errorLogger, settings);
        }
    }",5,5,lib/valueflow.cpp,"LifetimeStore.forEach:void(TokenList&,ErrorLogger&,Settings&,std.vector<constToken*>&,std.string&,ValueFlow.Value.LifetimeKind,F)",<empty>,,false,2023,2041,forEach,,,9,"void(TokenList&,ErrorLogger&,Settings&,std.vector<constToken*>&,std.string&,ValueFlow.Value.LifetimeKind,F)"
111669154024,METHOD,LifetimeStore,TYPE_DECL,"static LifetimeStore fromFunctionArg(const Function * f, const Token *tok, const Variable *var, const TokenList &tokenlist, const Settings& settings, ErrorLogger &errorLogger) {
        if (!var)
            return LifetimeStore{};
        if (!var->isArgument())
            return LifetimeStore{};
        const int n = getArgumentPos(var, f);
        if (n < 0)
            return LifetimeStore{};
        std::vector<const Token *> args = getArguments(tok);
        if (n >= args.size()) {
            if (settings.debugwarnings)
                bailout(tokenlist,
                        errorLogger,
                        tok,
                        ""Argument mismatch: Function '"" + tok->str() + ""' returning lifetime from argument index "" +
                        std::to_string(n) + "" but only "" + std::to_string(args.size()) +
                        "" arguments are available."");
            return LifetimeStore{};
        }
        const Token *argtok2 = args[n];
        return L...",5,16,lib/valueflow.cpp,"LifetimeStore.fromFunctionArg:LifetimeStore(Function*,Token*,Variable*,TokenList&,Settings&,ErrorLogger&)",<empty>,,false,2043,2064,fromFunctionArg,,,10,"LifetimeStore(Function*,Token*,Variable*,TokenList&,Settings&,ErrorLogger&)"
111669154025,METHOD,LifetimeStore,TYPE_DECL,"bool byRef(Token* tok,
               const TokenList& tokenlist,
               ErrorLogger& errorLogger,
               const Settings& settings,
               const Predicate& pred,
               SourceLocation loc = SourceLocation::current())
    {
        if (!argtok)
            return false;
        bool update = false;
        for (const ValueFlow::LifetimeToken& lt : ValueFlow::getLifetimeTokens(argtok, settings)) {
            if (!settings.certainty.isEnabled(Certainty::inconclusive) && lt.inconclusive)
                continue;
            if (!lt.token)
                return false;
            if (!pred(lt.token))
                return false;
            ErrorPath er = errorPath;
            er.insert(er.end(), lt.errorPath.cbegin(), lt.errorPath.cend());
            er.emplace_back(argtok, message);

            ValueFlow::Value value;
            value.valueType = ValueFlow::Value::ValueType::LIFETIME;
            value.lifetimeScope = ValueFlow::Value::LifetimeSc...",5,5,lib/valueflow.cpp,"LifetimeStore.byRef:bool(Token*,TokenList&,ErrorLogger&,Settings&,Predicate&,SourceLocation)",<empty>,,false,2067,2106,byRef,,,11,"bool(Token*,TokenList&,ErrorLogger&,Settings&,Predicate&,SourceLocation)"
111669154026,METHOD,LifetimeStore,TYPE_DECL,"bool byRef(Token* tok,
               const TokenList& tokenlist,
               ErrorLogger& errorLogger,
               const Settings& settings,
               SourceLocation loc = SourceLocation::current())
    {
        return byRef(
            tok,
            tokenlist,
            errorLogger,
            settings,
            [](const Token*) {
            return true;
        },
            loc);
    }",5,5,lib/valueflow.cpp,"LifetimeStore.byRef:bool(Token*,TokenList&,ErrorLogger&,Settings&,SourceLocation)",<empty>,,false,2108,2123,byRef,,,12,"bool(Token*,TokenList&,ErrorLogger&,Settings&,SourceLocation)"
111669154027,METHOD,LifetimeStore,TYPE_DECL,"bool byVal(Token* tok,
               const TokenList& tokenlist,
               ErrorLogger& errorLogger,
               const Settings& settings,
               const Predicate& pred,
               SourceLocation loc = SourceLocation::current())
    {
        if (!argtok)
            return false;
        bool update = false;
        if (argtok->values().empty()) {
            ErrorPath er;
            er.emplace_back(argtok, message);
            for (const ValueFlow::LifetimeToken& lt : ValueFlow::getLifetimeTokens(argtok, settings)) {
                if (!settings.certainty.isEnabled(Certainty::inconclusive) && lt.inconclusive)
                    continue;
                ValueFlow::Value value;
                value.valueType = ValueFlow::Value::ValueType::LIFETIME;
                value.tokvalue = lt.token;
                value.capturetok = argtok;
                value.errorPath = er;
                value.lifetimeKind = type;
                value.setInconclusive(inconcl...",5,5,lib/valueflow.cpp,"LifetimeStore.byVal:bool(Token*,TokenList&,ErrorLogger&,Settings&,Predicate&,SourceLocation)",<empty>,,false,2126,2201,byVal,,,13,"bool(Token*,TokenList&,ErrorLogger&,Settings&,Predicate&,SourceLocation)"
111669154028,METHOD,LifetimeStore,TYPE_DECL,"bool byVal(Token* tok,
               const TokenList& tokenlist,
               ErrorLogger& errorLogger,
               const Settings& settings,
               SourceLocation loc = SourceLocation::current())
    {
        return byVal(
            tok,
            tokenlist,
            errorLogger,
            settings,
            [](const Token*) {
            return true;
        },
            loc);
    }",5,5,lib/valueflow.cpp,"LifetimeStore.byVal:bool(Token*,TokenList&,ErrorLogger&,Settings&,SourceLocation)",<empty>,,false,2203,2218,byVal,,,14,"bool(Token*,TokenList&,ErrorLogger&,Settings&,SourceLocation)"
111669154029,METHOD,LifetimeStore,TYPE_DECL,"bool byDerefCopy(Token* tok,
                     const TokenList& tokenlist,
                     ErrorLogger& errorLogger,
                     const Settings& settings,
                     Predicate pred,
                     SourceLocation loc = SourceLocation::current()) const
    {
        bool update = false;
        if (!settings.certainty.isEnabled(Certainty::inconclusive) && inconclusive)
            return update;
        if (!argtok)
            return update;
        if (!tok)
            return update;
        for (const ValueFlow::Value &v : argtok->values()) {
            if (!v.isLifetimeValue())
                continue;
            const Token *tok2 = v.tokvalue;
            ErrorPath er = v.errorPath;
            const Variable *var = ValueFlow::getLifetimeVariable(tok2, er, settings);
            // TODO: the inserted data is never used
            er.insert(er.end(), errorPath.cbegin(), errorPath.cend());
            if (!var)
                continue;
       ...",5,5,lib/valueflow.cpp,"LifetimeStore.byDerefCopy<const>:bool(Token*,TokenList&,ErrorLogger&,Settings&,Predicate,SourceLocation)",<empty>,,false,2221,2257,byDerefCopy,,,15,"bool(Token*,TokenList&,ErrorLogger&,Settings&,Predicate,SourceLocation)"
111669154030,METHOD,LifetimeStore,TYPE_DECL,"bool byDerefCopy(Token* tok,
                     const TokenList& tokenlist,
                     ErrorLogger& errorLogger,
                     const Settings& settings,
                     SourceLocation loc = SourceLocation::current()) const
    {
        return byDerefCopy(
            tok,
            tokenlist,
            errorLogger,
            settings,
            [](const Token*) {
            return true;
        },
            loc);
    }",5,5,lib/valueflow.cpp,"LifetimeStore.byDerefCopy<const>:bool(Token*,TokenList&,ErrorLogger&,Settings&,SourceLocation)",<empty>,,false,2259,2274,byDerefCopy,,,16,"bool(Token*,TokenList&,ErrorLogger&,Settings&,SourceLocation)"
111669154031,METHOD,LifetimeStore,TYPE_DECL,"void forwardLifetime(Token* tok, const TokenList& tokenlist, ErrorLogger& errorLogger, const Settings& settings) {
        forwardTok = tok;
        valueFlowForwardLifetime(tok, tokenlist, errorLogger, settings);
    }",5,5,lib/valueflow.cpp,"LifetimeStore.forwardLifetime:void(Token*,TokenList&,ErrorLogger&,Settings&)",<empty>,,false,2279,2282,forwardLifetime,,,18,"void(Token*,TokenList&,ErrorLogger&,Settings&)"
111669154032,METHOD,<empty>,<empty>,<empty>,1,,lib/valueflow.cpp,LifetimeStore.<clinit>,<empty>,,false,2002,,<clinit>,,,19,
111669154033,METHOD,<empty>,<empty>,"[vt](const Token* arg) {
                return arg->valueType() && arg->valueType()->type == vt->type;
            }",56,13,lib/valueflow.cpp,lib/valueflow.cpp:<global>.hasBorrowingVariables.<lambda>23.<lambda>24:bool(Token*),<empty>,,false,2292,2294,<lambda>24,,,1,bool(Token*)
111669154034,METHOD,<empty>,<empty>,"[&](const Variable& var) {
        if (const ValueType* vt = var.valueType()) {
            if (vt->pointer > 0 &&
                std::none_of(args.begin(), args.end(), [vt](const Token* arg) {
                return arg->valueType() && arg->valueType()->type == vt->type;
            }))
                return false;
            if (vt->pointer > 0)
                return true;
            if (vt->reference != Reference::None)
                return true;
            if (vt->isPrimitive())
                return false;
            if (vt->isEnum())
                return false;
            // TODO: Check container inner type
            if (vt->type == ValueType::CONTAINER && vt->container)
                return vt->container->view;
            if (vt->typeScope)
                return hasBorrowingVariables(vt->typeScope->varlist, args, depth - 1);
        }
        return true;
    }",52,5,lib/valueflow.cpp,lib/valueflow.cpp:<global>.hasBorrowingVariables.<lambda>23:bool(Variable&),<empty>,,false,2289,2311,<lambda>23,,,1,bool(Variable&)
111669154035,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool hasBorrowingVariables(const std::list<Variable>& vars, const std::vector<const Token*>& args, int depth = 10)
{
    if (depth < 0)
        return true;
    return std::any_of(vars.cbegin(), vars.cend(), [&](const Variable& var) {
        if (const ValueType* vt = var.valueType()) {
            if (vt->pointer > 0 &&
                std::none_of(args.begin(), args.end(), [vt](const Token* arg) {
                return arg->valueType() && arg->valueType()->type == vt->type;
            }))
                return false;
            if (vt->pointer > 0)
                return true;
            if (vt->reference != Reference::None)
                return true;
            if (vt->isPrimitive())
                return false;
            if (vt->isEnum())
                return false;
            // TODO: Check container inner type
            if (vt->type == ValueType::CONTAINER && vt->container)
                return vt->container->view;
            if (vt->typeScope)
      ...",1,1,lib/valueflow.cpp,"hasBorrowingVariables:bool(std.list<Variable>&,std.vector<constToken*>&,int)",<empty>,,false,2285,2312,hasBorrowingVariables,,,1,"bool(std.list<Variable>&,std.vector<constToken*>&,int)"
111669154036,METHOD,<empty>,<empty>,"[&](LifetimeStore& ls) {
            const Variable* paramVar = argToParam.at(ls.argtok);
            if (paramCapture.count(paramVar) == 0)
                return;
            const LifetimeCapture c = paramCapture.at(paramVar);
            if (c == LifetimeCapture::ByReference)
                ls.byRef(tok, tokenlist, errorLogger, settings);
            else
                ls.byVal(tok, tokenlist, errorLogger, settings);
        }",32,9,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowLifetimeUserConstructor.<lambda>25:void(LifetimeStore&),<empty>,,false,2380,2389,<lambda>25,,,1,void(LifetimeStore&)
111669154037,METHOD,<empty>,<empty>,"[&](LifetimeStore& ls) {
            ls.inconclusive = true;
            const Variable* var = argToParam.at(ls.argtok);
            if (var && !var->isConst() && var->isReference())
                ls.byRef(tok, tokenlist, errorLogger, settings);
            else
                ls.byVal(tok, tokenlist, errorLogger, settings);
        }",32,9,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowLifetimeUserConstructor.<lambda>26:void(LifetimeStore&),<empty>,,false,2397,2404,<lambda>26,,,1,void(LifetimeStore&)
111669154038,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowLifetimeUserConstructor(Token* tok,
                                             const Function* constructor,
                                             const std::string& name,
                                             const std::vector<const Token*>& args,
                                             const TokenList& tokenlist,
                                             ErrorLogger& errorLogger,
                                             const Settings& settings)
{
    if (!constructor)
        return;
    std::unordered_map<const Token*, const Variable*> argToParam;
    for (std::size_t i = 0; i < args.size(); i++)
        argToParam[args[i]] = constructor->getArgumentVar(i);
    if (const Token* initList = constructor->constructorMemberInitialization()) {
        std::unordered_map<const Variable*, LifetimeCapture> paramCapture;
        for (const Token* tok2 : astFlatten(initList->astOperand2(), "","")) {
            if (!Token::simpleMatch(tok2, ""(""...",1,1,lib/valueflow.cpp,"valueFlowLifetimeUserConstructor:void(Token*,Function*,std.string&,std.vector<constToken*>&,TokenList&,ErrorLogger&,Settings&)",<empty>,,false,2314,2406,valueFlowLifetimeUserConstructor,,,1,"void(Token*,Function*,std.string&,std.vector<constToken*>&,TokenList&,ErrorLogger&,Settings&)"
111669154039,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowLifetimeFunction(Token *tok, const TokenList &tokenlist, ErrorLogger &errorLogger, const Settings &settings)
{
    if (!Token::Match(tok, ""%name% (""))
        return;
    Token* memtok = nullptr;
    if (Token::Match(tok->astParent(), "". %name% ("") && astIsRHS(tok))
        memtok = tok->astParent()->astOperand1();
    const int returnContainer = settings.library.returnValueContainer(tok);
    if (returnContainer >= 0) {
        std::vector<const Token *> args = getArguments(tok);
        for (int argnr = 1; argnr <= args.size(); ++argnr) {
            const Library::ArgumentChecks::IteratorInfo *i = settings.library.getArgIteratorInfo(tok, argnr);
            if (!i)
                continue;
            if (i->container != returnContainer)
                continue;
            const Token * const argTok = args[argnr - 1];
            bool forward = false;
            for (ValueFlow::Value val : argTok->values()) {
                if (!val.isLifetimeValue())
  ...",1,1,lib/valueflow.cpp,"valueFlowLifetimeFunction:void(Token*,TokenList&,ErrorLogger&,Settings&)",<empty>,,false,2408,2556,valueFlowLifetimeFunction,,,1,"void(Token*,TokenList&,ErrorLogger&,Settings&)"
111669154040,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isScope(const Token* tok)
{
    if (!tok)
        return false;
    if (!Token::simpleMatch(tok, ""{""))
        return false;
    const Scope* scope = tok->scope();
    if (!scope)
        return false;
    if (!scope->bodyStart)
        return false;
    return scope->bodyStart == tok;
}",1,1,lib/valueflow.cpp,isScope:bool(Token*),<empty>,,false,2558,2570,isScope,,,1,bool(Token*)
111669154041,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static const Function* findConstructor(const Scope* scope, const Token* tok, const std::vector<const Token*>& args)
{
    if (!tok)
        return nullptr;
    const Function* f = tok->function();
    if (!f && tok->astOperand1())
        f = tok->astOperand1()->function();
    // Search for a constructor
    if (!f || !f->isConstructor()) {
        f = nullptr;
        std::vector<const Function*> candidates;
        for (const Function& function : scope->functionList) {
            if (function.minArgCount() > args.size())
                continue;
            if (!function.isConstructor())
                continue;
            candidates.push_back(&function);
        }
        // TODO: Narrow the candidates
        if (candidates.size() == 1)
            f = candidates.front();
    }
    if (!f)
        return nullptr;
    return f;
}",1,1,lib/valueflow.cpp,"findConstructor:Function*(Scope*,Token*,std.vector<constToken*>&)",<empty>,,false,2572,2597,findConstructor,,,1,"Function*(Scope*,Token*,std.vector<constToken*>&)"
111669154042,METHOD,<empty>,<empty>,"[&](LifetimeStore& ls) {
            ls.inconclusive = true;
            ls.byVal(tok, tokenlist, errorLogger, settings);
        }",32,9,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowLifetimeClassConstructor.<lambda>27:void(LifetimeStore&),<empty>,,false,2623,2626,<lambda>27,,,1,void(LifetimeStore&)
111669154043,METHOD,<empty>,<empty>,"[](const Variable& var) {
                    return !var.isStatic();
                }",62,17,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowLifetimeClassConstructor.<lambda>28.<lambda>29:bool(Variable&),<empty>,,false,2646,2648,<lambda>29,,,1,bool(Variable&)
111669154044,METHOD,<empty>,<empty>,"[&](LifetimeStore& ls) {
                // Skip static variable
                it = std::find_if(it, scope->varlist.cend(), [](const Variable& var) {
                    return !var.isStatic();
                });
                if (it == scope->varlist.cend())
                    return;
                const Variable& var = *it;
                if (var.valueType() && var.valueType()->container && var.valueType()->container->stdStringLike && !var.valueType()->container->view)
                    return; // TODO: check in isLifetimeBorrowed()?
                if (var.isReference() || var.isRValueReference()) {
                    ls.byRef(tok, tokenlist, errorLogger, settings);
                } else if (ValueFlow::isLifetimeBorrowed(ls.argtok, settings)) {
                    ls.byVal(tok, tokenlist, errorLogger, settings);
                }
                it++;
            }",17,13,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowLifetimeClassConstructor.<lambda>28:void(LifetimeStore&),<empty>,,false,2644,2660,<lambda>28,,,1,void(LifetimeStore&)
111669154045,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowLifetimeClassConstructor(Token* tok,
                                              const Type* t,
                                              const TokenList& tokenlist,
                                              ErrorLogger& errorLogger,
                                              const Settings& settings)
{
    if (!Token::Match(tok, ""(|{""))
        return;
    if (isScope(tok))
        return;
    if (!t) {
        if (tok->valueType() && tok->valueType()->type != ValueType::RECORD)
            return;
        if (tok->str() != ""{"" && !Token::Match(tok->previous(), ""%var% ("") && !isVariableDecl(tok->previous()))
            return;
        // If the type is unknown then assume it captures by value in the
        // constructor, but make each lifetime inconclusive
        std::vector<const Token*> args = getArguments(tok);
        LifetimeStore::forEach(tokenlist,
                               errorLogger,
                               settings,
     ...",1,1,lib/valueflow.cpp,"valueFlowLifetimeClassConstructor:void(Token*,Type*,TokenList&,ErrorLogger&,Settings&)",<empty>,,false,2599,2666,valueFlowLifetimeClassConstructor,,,1,"void(Token*,Type*,TokenList&,ErrorLogger&,Settings&)"
111669154046,METHOD,<empty>,<empty>,"[&](LifetimeStore& ls) {
                ls.byVal(tok, tokenlist, errorLogger, settings);
            }",36,13,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowLifetimeConstructor.<lambda>30:void(LifetimeStore&),<empty>,,false,2693,2695,<lambda>30,,,1,void(LifetimeStore&)
111669154047,METHOD,<empty>,<empty>,"[&](const LifetimeStore& ls) {
                    ls.byDerefCopy(tok, tokenlist, errorLogger, settings);
                }",21,17,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowLifetimeConstructor.<lambda>31:void(LifetimeStore&),<empty>,,false,2709,2711,<lambda>31,,,1,void(LifetimeStore&)
111669154048,METHOD,<empty>,<empty>,"[&](LifetimeStore& ls) {
                    ls.byVal(tok, tokenlist, errorLogger, settings);
                }",40,17,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowLifetimeConstructor.<lambda>32:void(LifetimeStore&),<empty>,,false,2719,2721,<lambda>32,,,1,void(LifetimeStore&)
111669154049,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowLifetimeConstructor(Token* tok, const TokenList& tokenlist, ErrorLogger& errorLogger, const Settings& settings)
{
    if (!Token::Match(tok, ""(|{""))
        return;
    if (isScope(tok))
        return;
    std::vector<ValueType> vts;
    if (tok->valueType()) {
        vts = {*tok->valueType()};
    } else if (Token::Match(tok->previous(), ""%var% {|("") && isVariableDecl(tok->previous()) &&
               tok->previous()->valueType()) {
        vts = {*tok->previous()->valueType()};
    } else if (Token::simpleMatch(tok, ""{"") && !Token::Match(tok->previous(), ""%name%"")) {
        vts = getParentValueTypes(tok, settings);
    }

    for (const ValueType& vt : vts) {
        if (vt.pointer > 0) {
            std::vector<const Token*> args = getArguments(tok);
            LifetimeStore::forEach(tokenlist,
                                   errorLogger,
                                   settings,
                                   args,
                            ...",1,1,lib/valueflow.cpp,"valueFlowLifetimeConstructor:void(Token*,TokenList&,ErrorLogger&,Settings&)",<empty>,,false,2668,2732,valueFlowLifetimeConstructor,,,1,"void(Token*,TokenList&,ErrorLogger&,Settings&)"
111669154050,METHOD,Lambda,TYPE_DECL,"explicit Lambda(const Token* tok)
    {
        if (!Token::simpleMatch(tok, ""["") || !tok->link())
            return;
        capture = tok;

        if (Token::simpleMatch(capture->link(), ""] ("")) {
            arguments = capture->link()->next();
        }
        const Token * afterArguments = arguments ? arguments->link()->next() : capture->link()->next();
        if (afterArguments && afterArguments->originalName() == ""->"") {
            returnTok = afterArguments->next();
            bodyTok = Token::findsimplematch(returnTok, ""{"");
        } else if (Token::simpleMatch(afterArguments, ""{"")) {
            bodyTok = afterArguments;
        }
        for (const Token* c:getCaptures()) {
            if (Token::Match(c, ""this !!."")) {
                explicitCaptures[c->variable()] = std::make_pair(c, LifetimeCapture::ByReference);
            } else if (Token::simpleMatch(c, ""* this"")) {
                explicitCaptures[c->next()->variable()] = std::make_pair(c->next(), Lifetime...",5,5,lib/valueflow.cpp,Lambda.Lambda:ANY(Token*),<empty>,,false,2735,2769,Lambda,,,1,ANY(Token*)
111669154051,METHOD,Lambda,TYPE_DECL,"std::vector<const Token*> getCaptures() const {
        return getArguments(capture);
    }",5,5,lib/valueflow.cpp,Lambda.getCaptures<const>:vector<constToken*>(),<empty>,,false,2778,2780,getCaptures,,,8,vector<const Token*>()
111669154052,METHOD,Lambda,TYPE_DECL,"bool isLambda() const {
        return capture && bodyTok;
    }",5,5,lib/valueflow.cpp,Lambda.isLambda<const>:bool(),<empty>,,false,2782,2784,isLambda,,,9,bool()
111669154053,METHOD,<empty>,<empty>,<empty>,1,,lib/valueflow.cpp,Lambda.<clinit>,<empty>,,false,2734,,<clinit>,,,10,
111669154054,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isDecayedPointer(const Token *tok)
{
    if (!tok)
        return false;
    if (!tok->astParent())
        return false;
    if (Token::simpleMatch(tok->astParent(), ""="") && astIsRHS(tok))
        return true;
    if (astIsPointer(tok->astParent()) && !Token::simpleMatch(tok->astParent(), ""return""))
        return true;
    if (tok->astParent()->isConstOp())
        return true;
    if (!Token::simpleMatch(tok->astParent(), ""return""))
        return false;
    return astIsPointer(tok->astParent()) || astIsContainerView(tok->astParent());
}",1,1,lib/valueflow.cpp,isDecayedPointer:bool(Token*),<empty>,,false,2787,2802,isDecayedPointer,,,1,bool(Token*)
111669154055,METHOD,<empty>,<empty>,"[&](const ValueType& vt) {
        if (!vt.container)
            return false;
        return vt.container->view;
    }",62,5,lib/valueflow.cpp,lib/valueflow.cpp:<global>.isConvertedToView.<lambda>33:bool(ValueType&),<empty>,,false,2807,2811,<lambda>33,,,1,bool(ValueType&)
111669154056,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isConvertedToView(const Token* tok, const Settings& settings)
{
    std::vector<ValueType> vtParents = getParentValueTypes(tok, settings);
    return std::any_of(vtParents.cbegin(), vtParents.cend(), [&](const ValueType& vt) {
        if (!vt.container)
            return false;
        return vt.container->view;
    });
}",1,1,lib/valueflow.cpp,"isConvertedToView:bool(Token*,Settings&)",<empty>,,false,2804,2812,isConvertedToView,,,1,"bool(Token*,Settings&)"
111669154057,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isContainerOfPointers(const Token* tok, const Settings& settings)
{
    if (!tok)
    {
        return true;
    }

    ValueType vt = ValueType::parseDecl(tok, settings);
    return vt.pointer > 0;
}",1,1,lib/valueflow.cpp,"isContainerOfPointers:bool(Token*,Settings&)",<empty>,,false,2814,2823,isContainerOfPointers,,,1,"bool(Token*,Settings&)"
111669154058,METHOD,<empty>,<empty>,"[&](const Token *varTok) {
                const Variable *var = varTok->variable();
                if (!var)
                    return false;
                if (varids.count(var->declarationId()) > 0)
                    return false;
                if (!var->isLocal() && !var->isArgument())
                    return false;
                const Scope *scope = var->scope();
                if (!scope)
                    return false;
                if (scopes.count(scope) > 0)
                    return false;
                if (scope->isNestedIn(bodyScope))
                    return false;
                scopes.insert(scope);
                varids.insert(var->declarationId());
                return true;
            }",48,13,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowLifetime.<lambda>34:bool(Token*),<empty>,,false,2842,2860,<lambda>34,,,1,bool(Token*)
111669154059,METHOD,<empty>,<empty>,"[&](const Token* tok2, LifetimeCapture c, const std::function<bool(const Token*)> &pred) {
                if (varids.count(tok->varId()) > 0)
                    return;
                if (c == LifetimeCapture::ByReference) {
                    LifetimeStore ls{
                        tok2, ""Lambda captures variable by reference here."", ValueFlow::Value::LifetimeKind::Lambda};
                    ls.forward = false;
                    update |= ls.byRef(tok, tokenlist, errorLogger, settings, pred);
                } else if (c == LifetimeCapture::ByValue) {
                    LifetimeStore ls{
                        tok2, ""Lambda captures variable by value here."", ValueFlow::Value::LifetimeKind::Lambda};
                    ls.forward = false;
                    update |= ls.byVal(tok, tokenlist, errorLogger, settings, pred);
                    pred(tok2);
                }
            }",36,13,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.valueFlowLifetime.<lambda>35:void(Token*,LifetimeCapture,std.function<bool(constToken*)>&)",<empty>,,false,2863,2878,<lambda>35,,,1,"void(Token*,LifetimeCapture,std.function<bool(constToken*)>&)"
111669154060,METHOD,<empty>,<empty>,"[&](const Token* tok2, LifetimeCapture c) {
                ValueFlow::Value value;
                value.valueType = ValueFlow::Value::ValueType::LIFETIME;
                if (c == LifetimeCapture::ByReference)
                    value.lifetimeScope = ValueFlow::Value::LifetimeScope::ThisPointer;
                else if (c == LifetimeCapture::ByValue)
                    value.lifetimeScope = ValueFlow::Value::LifetimeScope::ThisValue;
                value.tokvalue = tok2;
                value.errorPath.emplace_back(tok2, ""Lambda captures the 'this' variable here."");
                value.lifetimeKind = ValueFlow::Value::LifetimeKind::Lambda;
                capturedThis = true;
                // Don't add the value a second time
                if (std::find(tok->values().cbegin(), tok->values().cend(), value) != tok->values().cend())
                    return;
                setTokenValue(tok, std::move(value), settings);
                update |= true;
            }",40,13,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.valueFlowLifetime.<lambda>36:void(Token*,LifetimeCapture)",<empty>,,false,2880,2896,<lambda>36,,,1,"void(Token*,LifetimeCapture)"
111669154061,METHOD,<empty>,<empty>,"[](const Token*) {
                        return true;
                    }",46,21,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowLifetime.<lambda>37:bool(Token*),<empty>,,false,2906,2908,<lambda>37,,,1,bool(Token*)
111669154062,METHOD,<empty>,<empty>,"[&](const Token* tok2) {
                if (capturedThis)
                    return false;
                if (Token::simpleMatch(tok2, ""this""))
                    return true;
                if (tok2->variable()) {
                    if (Token::simpleMatch(tok2->previous(), "".""))
                        return false;
                    const Variable* var = tok2->variable();
                    if (var->isLocal())
                        return false;
                    if (var->isArgument())
                        return false;
                    return exprDependsOnThis(tok2);
                }
                if (Token::simpleMatch(tok2, ""(""))
                    return exprDependsOnThis(tok2);
                return false;
            }",44,13,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowLifetime.<lambda>38:bool(Token*),<empty>,,false,2913,2931,<lambda>38,,,1,bool(Token*)
111669154063,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowLifetime(TokenList &tokenlist, ErrorLogger &errorLogger, const Settings &settings)
{
    for (Token *tok = tokenlist.front(); tok; tok = tok->next()) {
        if (!tok->scope())
            continue;
        if (tok->scope()->type == ScopeType::eGlobal)
            continue;
        Lambda lam(tok);
        // Lambdas
        if (lam.isLambda()) {
            const Scope * bodyScope = lam.bodyTok->scope();

            std::set<const Scope *> scopes;
            // Avoid capturing a variable twice
            std::set<nonneg int> varids;
            bool capturedThis = false;

            auto isImplicitCapturingVariable = [&](const Token *varTok) {
                const Variable *var = varTok->variable();
                if (!var)
                    return false;
                if (varids.count(var->declarationId()) > 0)
                    return false;
                if (!var->isLocal() && !var->isArgument())
                    return false;
            ...",1,21,lib/valueflow.cpp,"valueFlowLifetime:void(TokenList&,ErrorLogger&,Settings&)",<empty>,,false,2825,3099,valueFlowLifetime,,,1,"void(TokenList&,ErrorLogger&,Settings&)"
111669154064,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isStdMoveOrStdForwarded(Token * tok, ValueFlow::Value::MoveKind * moveKind, Token ** varTok = nullptr)
{
    if (tok->str() != ""std"")
        return false;
    ValueFlow::Value::MoveKind kind = ValueFlow::Value::MoveKind::NonMovedVariable;
    Token * variableToken = nullptr;
    if (Token::Match(tok, ""std :: move ( %var% )"")) {
        variableToken = tok->tokAt(4);
        kind = ValueFlow::Value::MoveKind::MovedVariable;
    } else if (Token::simpleMatch(tok, ""std :: forward <"")) {
        Token * const leftAngle = tok->tokAt(3);
        Token * rightAngle = leftAngle->link();
        if (Token::Match(rightAngle, ""> ( %var% )"")) {
            variableToken = rightAngle->tokAt(2);
            kind = ValueFlow::Value::MoveKind::ForwardedVariable;
        }
    }
    if (!variableToken)
        return false;
    if (variableToken->strAt(2) == ""."") // Only partially moved
        return false;
    if (variableToken->valueType() && variableToken->valueType()->type >= Value...",1,1,lib/valueflow.cpp,"isStdMoveOrStdForwarded:bool(Token*,ValueFlow.Value.MoveKind*,Token**)",<empty>,,false,3101,3129,isStdMoveOrStdForwarded,,,1,"bool(Token*,ValueFlow.Value.MoveKind*,Token**)"
111669154065,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isOpenParenthesisMemberFunctionCallOfVarId(const Token * openParenthesisToken, nonneg int varId)
{
    const Token * varTok = openParenthesisToken->tokAt(-3);
    return Token::Match(varTok, ""%varid% . %name% ("", varId) &&
           varTok->next()->originalName().empty();
}",1,91,lib/valueflow.cpp,"isOpenParenthesisMemberFunctionCallOfVarId:bool(Token*,int)",<empty>,,false,3131,3136,isOpenParenthesisMemberFunctionCallOfVarId,,,1,"bool(Token*,int)"
111669154066,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static Token* findOpenParentesisOfMove(Token* moveVarTok)
{
    Token* tok = moveVarTok;
    while (tok && tok->str() != ""("")
        tok = tok->previous();
    return tok;
}",1,1,lib/valueflow.cpp,findOpenParentesisOfMove:Token*(Token*),<empty>,,false,3138,3144,findOpenParentesisOfMove,,,1,Token*(Token*)
111669154067,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static Token* findEndOfFunctionCallForParameter(Token* parameterToken)
{
    if (!parameterToken)
        return nullptr;
    Token* parent = parameterToken->astParent();
    while (parent && !parent->isOp() && !Token::Match(parent, ""[({]""))
        parent = parent->astParent();
    if (!parent)
        return nullptr;
    return nextAfterAstRightmostLeaf(parent);
}",1,1,lib/valueflow.cpp,findEndOfFunctionCallForParameter:Token*(Token*),<empty>,,false,3146,3156,findEndOfFunctionCallForParameter,,,1,Token*(Token*)
111669154068,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowAfterMove(const TokenList& tokenlist, const SymbolDatabase& symboldatabase, ErrorLogger& errorLogger, const Settings& settings)
{
    if (!tokenlist.isCPP() || settings.standards.cpp < Standards::CPP11)
        return;
    for (const Scope * scope : symboldatabase.functionScopes) {
        if (!scope)
            continue;
        const Token * start = scope->bodyStart;
        if (scope->function) {
            const Token * memberInitializationTok = scope->function->constructorMemberInitialization();
            if (memberInitializationTok)
                start = memberInitializationTok;
        }

        for (auto* tok = const_cast<Token*>(start); tok != scope->bodyEnd; tok = tok->next()) {
            Token * varTok;
            if (Token::Match(tok, ""%var% . reset|clear ("") && tok->next()->originalName().empty()) {
                varTok = tok;

                const Variable *var = tok->variable();
                if (!var || (!var->isLocal() && !var->is...",1,18,lib/valueflow.cpp,"valueFlowAfterMove:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)",<empty>,,false,3158,3237,valueFlowAfterMove,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)"
111669154069,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static const Token* findIncompleteVar(const Token* start, const Token* end)
{
    for (const Token* tok = start; tok != end; tok = tok->next()) {
        if (tok->isIncompleteVar())
            return tok;
    }
    return nullptr;
}",1,1,lib/valueflow.cpp,"findIncompleteVar:Token*(Token*,Token*)",<empty>,,false,3239,3246,findIncompleteVar,,,1,"Token*(Token*,Token*)"
111669154070,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static ValueFlow::Value makeConditionValue(long long val,
                                           const Token* condTok,
                                           bool assume,
                                           bool impossible,
                                           const Settings& settings,
                                           SourceLocation loc = SourceLocation::current())
{
    ValueFlow::Value v(val);
    v.setKnown();
    if (impossible) {
        v.intvalue = !v.intvalue;
        v.setImpossible();
    }
    v.condition = condTok;
    if (assume)
        v.errorPath.emplace_back(condTok, ""Assuming condition '"" + condTok->expressionString() + ""' is true"");
    else
        v.errorPath.emplace_back(condTok, ""Assuming condition '"" + condTok->expressionString() + ""' is false"");
    if (settings.debugnormal)
        setSourceLocation(v, loc, condTok);
    return v;
}",1,1,lib/valueflow.cpp,"makeConditionValue:ValueFlow.Value(longlong,Token*,bool,bool,Settings&,SourceLocation)",<empty>,,false,3248,3269,makeConditionValue,,,1,"ValueFlow.Value(longlong,Token*,bool,bool,Settings&,SourceLocation)"
111669154071,METHOD,<empty>,<empty>,"[&](const Token* tok2) {
            if (tok2->exprId() == 0)
                return false;
            if (tok2->hasKnownIntValue())
                return false;
            if (Token::Match(tok2, ""%var%|."") && !astIsBool(tok2))
                return false;
            return true;
        }",77,9,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.getConditions:vector<constToken*>(Token*,char*).<lambda>39:bool(Token*)",<empty>,,false,3276,3284,<lambda>39,,,1,bool(Token*)
111669154072,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static std::vector<const Token*> getConditions(const Token* tok, const char* op)
{
    std::vector<const Token*> conds = {tok};
    if (tok->str() == op) {
        std::vector<const Token*> args = astFlatten(tok, op);
        std::copy_if(args.cbegin(), args.cend(), std::back_inserter(conds), [&](const Token* tok2) {
            if (tok2->exprId() == 0)
                return false;
            if (tok2->hasKnownIntValue())
                return false;
            if (Token::Match(tok2, ""%var%|."") && !astIsBool(tok2))
                return false;
            return true;
        });
    }
    return conds;
}",1,1,lib/valueflow.cpp,"getConditions:vector<constToken*>(Token*,char*)",<empty>,,false,3271,3287,getConditions,,,1,"vector<const Token*>(Token*,char*)"
111669154073,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isBreakOrContinueScope(const Token* endToken)
{
    if (!Token::simpleMatch(endToken, ""}""))
        return false;
    return Token::Match(endToken->tokAt(-2), ""break|continue ;"");
}",1,1,lib/valueflow.cpp,isBreakOrContinueScope:bool(Token*),<empty>,,false,3289,3294,isBreakOrContinueScope,,,1,bool(Token*)
111669154074,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static const Scope* getLoopScope(const Token* tok)
{
    if (!tok)
        return nullptr;
    const Scope* scope = tok->scope();
    while (scope && scope->type != ScopeType::eWhile && scope->type != ScopeType::eFor && scope->type != ScopeType::eDo)
        scope = scope->nestedIn;
    return scope;
}",1,1,lib/valueflow.cpp,getLoopScope:Scope*(Token*),<empty>,,false,3296,3304,getLoopScope,,,1,Scope*(Token*)
111669154075,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowConditionExpressions(const TokenList& tokenlist,
                                          const SymbolDatabase& symboldatabase,
                                          ErrorLogger& errorLogger,
                                          const Settings& settings)
{
    if (!settings.daca && !settings.vfOptions.doConditionExpressionAnalysis) {
        if (settings.debugwarnings) {
            ErrorMessage::FileLocation loc(tokenlist.getSourceFilePath(), 0, 0);
            const ErrorMessage errmsg(
                {std::move(loc)},
                tokenlist.getSourceFilePath(),
                Severity::debug,
                ""Analysis of condition expressions is disabled. Use --check-level=exhaustive to enable it."",
                ""normalCheckLevelConditionExpressions"",
                Certainty::normal);
            errorLogger.reportErr(errmsg);
        }
        return;
    }

    for (const Scope* scope : symboldatabase.functionScopes) {
        if (const ...",1,16,lib/valueflow.cpp,"valueFlowConditionExpressions:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)",<empty>,,false,3307,3433,valueFlowConditionExpressions,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)"
111669154076,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isTruncated(const ValueType* src, const ValueType* dst, const Settings& settings)
{
    if (src->pointer > 0 || dst->pointer > 0)
        return src->pointer != dst->pointer;
    if (src->smartPointer && dst->smartPointer)
        return false;
    if ((src->isIntegral() && dst->isIntegral()) || (src->isFloat() && dst->isFloat())) {
        const size_t srcSize = ValueFlow::getSizeOf(*src, settings);
        const size_t dstSize = ValueFlow::getSizeOf(*dst, settings);
        if (srcSize > dstSize)
            return true;
        if (srcSize == dstSize && src->sign != dst->sign)
            return true;
    } else if (src->type == dst->type) {
        if (src->type == ValueType::Type::RECORD)
            return src->typeScope != dst->typeScope;
    } else {
        return true;
    }
    return false;
}",1,1,lib/valueflow.cpp,"isTruncated:bool(ValueType*,ValueType*,Settings&)",<empty>,,false,3435,3455,isTruncated,,,1,"bool(ValueType*,ValueType*,Settings&)"
111669154077,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void setSymbolic(ValueFlow::Value& value, const Token* tok)
{
    assert(tok && tok->exprId() > 0 && ""Missing expr id for symbolic value"");
    value.valueType = ValueFlow::Value::ValueType::SYMBOLIC;
    value.tokvalue = tok;
}",1,1,lib/valueflow.cpp,"setSymbolic:void(ValueFlow.Value&,Token*)",<empty>,,false,3457,3462,setSymbolic,,,1,"void(ValueFlow.Value&,Token*)"
111669154078,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static ValueFlow::Value makeSymbolic(const Token* tok, MathLib::bigint delta = 0)
{
    ValueFlow::Value value;
    value.setKnown();
    setSymbolic(value, tok);
    value.intvalue = delta;
    return value;
}",1,1,lib/valueflow.cpp,"makeSymbolic:ValueFlow.Value(Token*,MathLib.bigint)",<empty>,,false,3464,3471,makeSymbolic,,,1,"ValueFlow.Value(Token*,MathLib.bigint)"
111669154079,METHOD,<empty>,<empty>,"[&](const Token* child) {
        if (child->varId() > 0)
            result.insert(child->varId());
        return ChildrenToVisit::op1_and_op2;
    }",24,5,lib/valueflow.cpp,lib/valueflow.cpp:<global>.getVarIds.<lambda>40:ChildrenToVisit(Token*),<empty>,,false,3476,3480,<lambda>40,,,1,ChildrenToVisit(Token*)
111669154080,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static std::set<nonneg int> getVarIds(const Token* tok)
{
    std::set<nonneg int> result;
    visitAstNodes(tok, [&](const Token* child) {
        if (child->varId() > 0)
            result.insert(child->varId());
        return ChildrenToVisit::op1_and_op2;
    });
    return result;
}",1,16,lib/valueflow.cpp,getVarIds:set<int>(Token*),<empty>,,false,3473,3482,getVarIds,,,1,set<int>(Token*)
111669154081,METHOD,<empty>,<empty>,"[&](const Variable* var) {
                if (rhsVarIds.count(var->declarationId()) > 0)
                    return true;
                if (var->isLocal())
                    return var->isStatic();
                return !var->isArgument();
            }",57,13,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowSymbolic.<lambda>41:bool(Variable*),<empty>,,false,3515,3521,<lambda>41,,,1,bool(Variable*)
111669154082,METHOD,<empty>,<empty>,"[](const Token* child) {
                return child->isIncompleteVar();
            }",34,13,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowSymbolic.<lambda>42:bool(Token*),<empty>,,false,3524,3526,<lambda>42,,,1,bool(Token*)
111669154083,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowSymbolic(const TokenList& tokenlist, const SymbolDatabase& symboldatabase, ErrorLogger& errorLogger, const Settings& settings)
{
    for (const Scope* scope : symboldatabase.functionScopes) {
        for (auto* tok = const_cast<Token*>(scope->bodyStart); tok != scope->bodyEnd; tok = tok->next()) {
            if (!Token::simpleMatch(tok, ""=""))
                continue;
            if (tok->astParent())
                continue;
            if (!tok->astOperand1())
                continue;
            if (!tok->astOperand2())
                continue;
            if (tok->astOperand1()->hasKnownIntValue())
                continue;
            if (tok->astOperand2()->hasKnownIntValue())
                continue;
            if (tok->astOperand1()->exprId() == 0)
                continue;
            if (tok->astOperand2()->exprId() == 0)
                continue;
            if (!isConstExpression(tok->astOperand2(), settings.library))
                continue;
...",1,27,lib/valueflow.cpp,"valueFlowSymbolic:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)",<empty>,,false,3484,3545,valueFlowSymbolic,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)"
111669154084,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static const Token* isStrlenOf(const Token* tok, const Token* expr, int depth = 10)
{
    if (depth < 0)
        return nullptr;
    if (!tok)
        return nullptr;
    if (!expr)
        return nullptr;
    if (expr->exprId() == 0)
        return nullptr;
    if (Token::simpleMatch(tok->previous(), ""strlen ("")) {
        if (tok->astOperand2()->exprId() == expr->exprId())
            return tok;
    } else {
        for (const ValueFlow::Value& v : tok->values()) {
            if (!v.isSymbolicValue())
                continue;
            if (!v.isKnown())
                continue;
            if (v.intvalue != 0)
                continue;
            if (const Token* next = isStrlenOf(v.tokvalue, expr, depth - 1))
                return next;
        }
    }
    return nullptr;
}",1,1,lib/valueflow.cpp,"isStrlenOf:Token*(Token*,Token*,int)",<empty>,,false,3547,3573,isStrlenOf,,,1,"Token*(Token*,Token*,int)"
111669154085,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
                    if (!v.isSymbolicValue())
                        return false;
                    if (!v.tokvalue)
                        return false;
                    return ids.insert(v.tokvalue->exprId()).second;
                }",30,17,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowSymbolicOperators.<lambda>43:bool(ValueFlow.Value&),<empty>,,false,3634,3640,<lambda>43,,,1,bool(ValueFlow.Value&)
111669154086,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowSymbolicOperators(const SymbolDatabase& symboldatabase, const Settings& settings)
{
    for (const Scope* scope : symboldatabase.functionScopes) {
        for (auto* tok = const_cast<Token*>(scope->bodyStart); tok != scope->bodyEnd; tok = tok->next()) {
            if (tok->hasKnownIntValue())
                continue;

            if (Token::Match(tok, ""abs|labs|llabs|fabs|fabsf|fabsl ("")) {
                const Token* arg = tok->next()->astOperand2();
                if (!arg)
                    continue;
                if (arg->exprId() == 0)
                    continue;
                ValueFlow::Value c = inferCondition("">="", arg, 0);
                if (!c.isKnown())
                    continue;

                ValueFlow::Value v = makeSymbolic(arg);
                v.errorPath = c.errorPath;
                v.errorPath.emplace_back(tok, ""Passed to "" + tok->str());
                if (c.intvalue == 0)
                    v.setImpossible();
          ...",1,35,lib/valueflow.cpp,"valueFlowSymbolicOperators:void(SymbolDatabase&,Settings&)",<empty>,,false,3575,3667,valueFlowSymbolicOperators,,,1,"void(SymbolDatabase&,Settings&)"
111669154087,METHOD,SymbolicInferModel,TYPE_DECL,"explicit SymbolicInferModel(const Token* tok) : expr(tok) {
        assert(expr->exprId() != 0);
    }",5,5,lib/valueflow.cpp,SymbolicInferModel.SymbolicInferModel:ANY(Token*),<empty>,,false,3671,3673,SymbolicInferModel,,,2,SymbolicInferModel.SymbolicInferModel:ANY(Token*)(Token*)
111669154088,METHOD,SymbolicInferModel,TYPE_DECL,"bool match(const ValueFlow::Value& value) const override
    {
        return value.isSymbolicValue() && value.tokvalue && value.tokvalue->exprId() == expr->exprId();
    }",5,5,lib/valueflow.cpp,SymbolicInferModel.match<const>:bool(ValueFlow.Value&),<empty>,,false,3674,3677,match,,,3,bool(ValueFlow.Value&)
111669154089,METHOD,SymbolicInferModel,TYPE_DECL,"ValueFlow::Value yield(MathLib::bigint value) const override
    {
        ValueFlow::Value result(value);
        result.valueType = ValueFlow::Value::ValueType::SYMBOLIC;
        result.tokvalue = expr;
        result.setKnown();
        return result;
    }",5,5,lib/valueflow.cpp,SymbolicInferModel.yield<const>:ValueFlow.Value(MathLib.bigint),<empty>,,false,3678,3685,yield,,,4,ValueFlow.Value(MathLib.bigint)
111669154090,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowSymbolicInfer(const SymbolDatabase& symboldatabase, const Settings& settings)
{
    for (const Scope* scope : symboldatabase.functionScopes) {
        for (auto* tok = const_cast<Token*>(scope->bodyStart); tok != scope->bodyEnd; tok = tok->next()) {
            if (!Token::Match(tok, ""-|%comp%""))
                continue;
            if (tok->hasKnownIntValue())
                continue;
            if (!tok->astOperand1())
                continue;
            if (!tok->astOperand2())
                continue;
            if (tok->astOperand1()->exprId() == 0)
                continue;
            if (tok->astOperand2()->exprId() == 0)
                continue;
            if (tok->astOperand1()->hasKnownIntValue())
                continue;
            if (tok->astOperand2()->hasKnownIntValue())
                continue;
            if (astIsFloat(tok->astOperand1(), false))
                continue;
            if (astIsFloat(tok->astOperand2(), false))
     ...",1,1,lib/valueflow.cpp,"valueFlowSymbolicInfer:void(SymbolDatabase&,Settings&)",<empty>,,false,3688,3727,valueFlowSymbolicInfer,,,1,"void(SymbolDatabase&,Settings&)"
111669154091,METHOD,<empty>,<empty>,"[&](const ReferenceToken& ref) {
                    return ref.token->varId() == var->declarationId();
                }",68,17,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowForwardConst.<lambda>44.<lambda>45:bool(ReferenceToken&),<empty>,,false,3747,3749,<lambda>45,,,1,bool(ReferenceToken&)
111669154092,METHOD,<empty>,<empty>,"[&] {
                // Follow references
                auto refs = followAllReferences(tok);
                auto it = std::find_if(refs.cbegin(), refs.cend(), [&](const ReferenceToken& ref) {
                    return ref.token->varId() == var->declarationId();
                });
                if (it != refs.end()) {
                    for (ValueFlow::Value value : values) {
                        if (refs.size() > 1)
                            value.setInconclusive();
                        value.errorPath.insert(value.errorPath.end(), it->errors.cbegin(), it->errors.cend());
                        setTokenValue(tok, std::move(value), settings);
                    }
                    return;
                }
                // Follow symbolic values
                for (const ValueFlow::Value& v : tok->values()) {
                    if (!v.isSymbolicValue())
                        continue;
                    if (!v.tokvalue)
                        continue;
 ...",13,13,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowForwardConst.<lambda>44:void(),<empty>,,false,3744,3782,<lambda>44,,,1,void()
111669154093,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowForwardConst(Token* start,
                                  const Token* end,
                                  const Variable* var,
                                  const ContainerOfValue& values,
                                  const Settings& settings,
                                  int /*unused*/ = 0)
{
    if (!precedes(start, end))
        throw InternalError(var->nameToken(), ""valueFlowForwardConst: start token does not precede the end token."");
    for (Token* tok = start; tok != end; tok = tok->next()) {
        if (tok->varId() == var->declarationId()) {
            for (const ValueFlow::Value& value : values)
                setTokenValue(tok, value, settings);
        } else {
            [&] {
                // Follow references
                auto refs = followAllReferences(tok);
                auto it = std::find_if(refs.cbegin(), refs.cend(), [&](const ReferenceToken& ref) {
                    return ref.token->varId() == var->declarat...",1,1,lib/valueflow.cpp,"valueFlowForwardConst:void(Token*,Token*,Variable*,ContainerOfValue&,Settings&,int)",<empty>,,false,3730,3785,valueFlowForwardConst,,,1,"void(Token*,Token*,Variable*,ContainerOfValue&,Settings&,int)"
111669154094,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowForwardConst(Token* start,
                                  const Token* end,
                                  const Variable* var,
                                  const std::initializer_list<ValueFlow::Value>& values,
                                  const Settings& settings)
{
    valueFlowForwardConst(start, end, var, values, settings, 0);
}",1,1,lib/valueflow.cpp,"valueFlowForwardConst:void(Token*,Token*,Variable*,std.initializer_list<ValueFlow.Value>&,Settings&)",<empty>,,false,3787,3794,valueFlowForwardConst,,,1,"void(Token*,Token*,Variable*,std.initializer_list<ValueFlow.Value>&,Settings&)"
111669154095,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static ValueFlow::Value::Bound findVarBound(const Variable* var,
                                            const Token* start,
                                            const Token* end,
                                            const Settings& settings)
{
    ValueFlow::Value::Bound result = ValueFlow::Value::Bound::Point;
    const Token* next = start;
    while ((next = findExpressionChangedSkipDeadCode(
                var->nameToken(), next->next(), end, settings, &evaluateKnownValues))) {
        ValueFlow::Value::Bound b = ValueFlow::Value::Bound::Point;
        if (next->varId() != var->declarationId())
            return ValueFlow::Value::Bound::Point;
        if (Token::simpleMatch(next->astParent(), ""++""))
            b = ValueFlow::Value::Bound::Lower;
        else if (Token::simpleMatch(next->astParent(), ""--""))
            b = ValueFlow::Value::Bound::Upper;
        else
            return ValueFlow::Value::Bound::Point;
        if (result == ValueFlow::Value::Bo...",1,1,lib/valueflow.cpp,"findVarBound:ValueFlow.Value.Bound(Variable*,Token*,Token*,Settings&)",<empty>,,false,3796,3820,findVarBound,,,1,"ValueFlow.Value.Bound(Variable*,Token*,Token*,Settings&)"
111669154096,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isInitialVarAssign(const Token* tok)
{
    if (!tok)
        return false;
    if (!tok->variable())
        return false;
    if (tok->variable()->nameToken() == tok)
        return true;
    const Token* prev = tok->tokAt(2);
    if (!Token::Match(prev, ""%var% ; %var%""))
        return false;
    return tok->varId() == prev->varId() && tok->variable()->nameToken() == prev;
}",1,1,lib/valueflow.cpp,isInitialVarAssign:bool(Token*),<empty>,,false,3822,3834,isInitialVarAssign,,,1,bool(Token*)
111669154097,METHOD,<empty>,<empty>,"[&](const Variable* var) {
        return !var->isPointer() && !var->isSmartPointer();
    }",41,5,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowForwardAssign.<lambda>46:bool(Variable*),<empty>,,false,3853,3855,<lambda>46,,,1,bool(Variable*)
111669154098,METHOD,<empty>,<empty>,"[&](const Variable* var) {
        return var->isVolatile();
    }",49,5,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowForwardAssign.<lambda>47:bool(Variable*),<empty>,,false,3889,3891,<lambda>47,,,1,bool(Variable*)
111669154099,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& value) {
            if (!value.isKnown())
                return false;
            if (value.isIntValue())
                return true;
            if (value.isFloatValue())
                return true;
            if (value.isContainerSizeValue())
                return true;
            if (value.isIteratorValue())
                return true;
            return false;
        }",64,9,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowForwardAssign.<lambda>48:bool(ValueFlow.Value&),<empty>,,false,3908,3920,<lambda>48,,,1,bool(ValueFlow.Value&)
111669154100,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& value) {
                if (!value.isKnown())
                    return false;
                return value.isIntValue();
            }",76,13,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowForwardAssign.<lambda>49:bool(ValueFlow.Value&),<empty>,,false,3929,3933,<lambda>49,,,1,bool(ValueFlow.Value&)
111669154101,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowForwardAssign(Token* const tok,
                                   const Token* expr,
                                   std::vector<const Variable*> vars,
                                   std::list<ValueFlow::Value> values,
                                   const bool init,
                                   const TokenList& tokenlist,
                                   ErrorLogger& errorLogger,
                                   const Settings& settings)
{
    if (Token::simpleMatch(tok->astParent(), ""return""))
        return;
    const Token* endOfVarScope = ValueFlow::getEndOfExprScope(expr);
    if (std::any_of(values.cbegin(), values.cend(), std::mem_fn(&ValueFlow::Value::isLifetimeValue))) {
        valueFlowForwardLifetime(tok, tokenlist, errorLogger, settings);
        values.remove_if(std::mem_fn(&ValueFlow::Value::isLifetimeValue));
    }
    if (std::all_of(
            vars.cbegin(), vars.cend(), [&](const Variable* var) {
        return !var->is...",1,1,lib/valueflow.cpp,"valueFlowForwardAssign:void(Token*,Token*,std.vector<constVariable*>,std.list<ValueFlow.Value>,bool,TokenList&,ErrorLogger&,Settings&)",<empty>,,false,3836,3944,valueFlowForwardAssign,,,1,"void(Token*,Token*,std.vector<constVariable*>,std.list<ValueFlow.Value>,bool,TokenList&,ErrorLogger&,Settings&)"
111669154102,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowForwardAssign(Token* const tok,
                                   const Variable* const var,
                                   const std::list<ValueFlow::Value>& values,
                                   const bool /*unused*/,
                                   const bool init,
                                   const TokenList& tokenlist,
                                   ErrorLogger& errorLogger,
                                   const Settings& settings)
{
    valueFlowForwardAssign(tok, var->nameToken(), {var}, values, init, tokenlist, errorLogger, settings);
}",1,1,lib/valueflow.cpp,"valueFlowForwardAssign:void(Token*,Variable*,std.list<ValueFlow.Value>&,bool,bool,TokenList&,ErrorLogger&,Settings&)",<empty>,,false,3946,3956,valueFlowForwardAssign,,,1,"void(Token*,Variable*,std.list<ValueFlow.Value>&,bool,bool,TokenList&,ErrorLogger&,Settings&)"
111669154103,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& value) {
                if (!value.isIntValue())
                    return false;
                if (!value.isImpossible())
                    return false;
                if (value.bound != ValueFlow::Value::Bound::Upper)
                    return false;
                if (osz == sz && value.intvalue < 0)
                    return true;
                if (osz > sz)
                    return true;
                return false;
            }",30,13,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.truncateValues:list<ValueFlow.Value>(std.list<ValueFlow.Value>,ValueType*,ValueType*,Settings&).<lambda>50:bool(ValueFlow.Value&)",<empty>,,false,3971,3983,<lambda>50,,,1,bool(ValueFlow.Value&)
111669154104,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static std::list<ValueFlow::Value> truncateValues(std::list<ValueFlow::Value> values,
                                                  const ValueType* dst,
                                                  const ValueType* src,
                                                  const Settings& settings)
{
    if (!dst || !dst->isIntegral())
        return values;

    const size_t sz = ValueFlow::getSizeOf(*dst, settings);

    if (src) {
        const size_t osz = ValueFlow::getSizeOf(*src, settings);
        if (osz >= sz && dst->sign == ValueType::Sign::SIGNED && src->sign == ValueType::Sign::UNSIGNED) {
            values.remove_if([&](const ValueFlow::Value& value) {
                if (!value.isIntValue())
                    return false;
                if (!value.isImpossible())
                    return false;
                if (value.bound != ValueFlow::Value::Bound::Upper)
                    return false;
                if (osz == sz && value.intvalue < 0)
         ...",1,1,lib/valueflow.cpp,"truncateValues:list<ValueFlow.Value>(std.list<ValueFlow.Value>,ValueType*,ValueType*,Settings&)",<empty>,,false,3958,4000,truncateValues,,,1,"list<ValueFlow::Value>(std.list<ValueFlow.Value>,ValueType*,ValueType*,Settings&)"
111669154105,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isVariableInit(const Token *tok)
{
    if (!tok)
        return false;
    if (!Token::Match(tok->previous(), ""%var% (|{""))
        return false;
    if (!tok->isBinaryOp() && !(tok->astOperand1() && tok->link() == tok->next()))
        return false;
    if (Token::simpleMatch(tok->astOperand2(), "",""))
        return false;
    const Variable* var = tok->astOperand1()->variable();
    if (!var)
        return false;
    if (var->nameToken() != tok->astOperand1())
        return false;
    const ValueType* vt = var->valueType();
    if (!vt)
        return false;
    if (vt->type < ValueType::Type::VOID)
        return false;
    return true;
}",1,1,lib/valueflow.cpp,isVariableInit:bool(Token*),<empty>,,false,4002,4023,isVariableInit,,,1,bool(Token*)
111669154106,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool intersects(const C1& c1, const C2& c2)
{
    if (c1.size() > c2.size())
        return intersects(c2, c1);
    // NOLINTNEXTLINE(readability-use-anyofallof) - TODO: fix if possible / also Cppcheck false negative
    for (auto&& x : c1) {
        if (c2.find(x) != c2.end())
            return true;
    }
    return false;
}",1,1,lib/valueflow.cpp,"intersects:bool(C1&,C2&)",<empty>,,false,4027,4037,intersects,,,1,"bool(C1&,C2&)"
111669154107,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& value) {
                return types.count(value.valueType) > 0;
            }",30,13,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowAfterAssign.<lambda>51:bool(ValueFlow.Value&),<empty>,,false,4085,4087,<lambda>51,,,1,bool(ValueFlow.Value&)
111669154108,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& value) {
                    return value.valueType == ValueFlow::Value::ValueType::CONTAINER_SIZE;
                }",34,17,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowAfterAssign.<lambda>52:bool(ValueFlow.Value&),<empty>,,false,4090,4092,<lambda>52,,,1,bool(ValueFlow.Value&)
111669154109,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& value) {
                if (value.isSymbolicValue() && value.tokvalue)
                    return value.tokvalue->exprId() == tok->astOperand1()->exprId();
                return false;
            }",30,13,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowAfterAssign.<lambda>53:bool(ValueFlow.Value&),<empty>,,false,4094,4098,<lambda>53,,,1,bool(ValueFlow.Value&)
111669154110,METHOD,<empty>,<empty>,"[&](const Token* child) {
                    return child->exprId() == tok->astOperand1()->exprId();
                }",36,17,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowAfterAssign.<lambda>54.<lambda>55:bool(Token*),<empty>,,false,4102,4104,<lambda>55,,,1,bool(Token*)
111669154111,METHOD,<empty>,<empty>,"[&](const Token* tok2) -> bool {
                return findAstNode(tok2,
                                   [&](const Token* child) {
                    return child->exprId() == tok->astOperand1()->exprId();
                });
            }",34,13,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowAfterAssign.<lambda>54:bool(Token*),<empty>,,false,4100,4105,<lambda>54,,,1,bool(Token*)
111669154112,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& value) {
                if (!value.isSymbolicValue())
                    return false;
                return isIncremental(value.tokvalue);
            }",82,13,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowAfterAssign.<lambda>56:bool(ValueFlow.Value&),<empty>,,false,4108,4112,<lambda>56,,,1,bool(ValueFlow.Value&)
111669154113,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& value) {
                    if (value.tokvalue)
                        return value.tokvalue == tok->astOperand2();
                    return false;
                }",34,17,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowAfterAssign.<lambda>57:bool(ValueFlow.Value&),<empty>,,false,4115,4119,<lambda>57,,,1,bool(ValueFlow.Value&)
111669154114,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& value) {
                    return value.isUninitValue();
                }",34,17,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowAfterAssign.<lambda>58:bool(ValueFlow.Value&),<empty>,,false,4124,4126,<lambda>58,,,1,bool(ValueFlow.Value&)
111669154115,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowAfterAssign(TokenList &tokenlist,
                                 const SymbolDatabase& symboldatabase,
                                 ErrorLogger &errorLogger,
                                 const Settings &settings,
                                 const std::set<const Scope*>& skippedFunctions)
{
    for (const Scope * scope : symboldatabase.functionScopes) {
        if (skippedFunctions.count(scope))
            continue;
        std::unordered_map<nonneg int, std::unordered_set<nonneg int>> backAssigns;
        for (auto* tok = const_cast<Token*>(scope->bodyStart); tok != scope->bodyEnd; tok = tok->next()) {
            if (!tok->scope()->isExecutable()) {
                tok = const_cast<Token*>(tok->scope()->bodyEnd); // skip local type definition
                continue;
            }

            // Assignment
            bool isInit = false;
            if (tok->str() != ""="" && !(isInit = isVariableInit(tok)))
                continue;

         ...",1,27,lib/valueflow.cpp,"valueFlowAfterAssign:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,4039,4168,valueFlowAfterAssign,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154116,METHOD,<empty>,<empty>,"[&](const Token* child) {
        if (child->variable())
            result.push_back(child->variable());
        return ChildrenToVisit::op1_and_op2;
    }",24,5,lib/valueflow.cpp,lib/valueflow.cpp:<global>.getVariables:vector<constVariable*>(Token*).<lambda>59:ChildrenToVisit(Token*),<empty>,,false,4173,4177,<lambda>59,,,1,ChildrenToVisit(Token*)
111669154117,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static std::vector<const Variable*> getVariables(const Token* tok)
{
    std::vector<const Variable*> result;
    visitAstNodes(tok, [&](const Token* child) {
        if (child->variable())
            result.push_back(child->variable());
        return ChildrenToVisit::op1_and_op2;
    });
    return result;
}",1,1,lib/valueflow.cpp,getVariables:vector<constVariable*>(Token*),<empty>,,false,4170,4179,getVariables,,,1,vector<const Variable*>(Token*)
111669154118,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowAfterSwap(const TokenList& tokenlist,
                               const SymbolDatabase& symboldatabase,
                               ErrorLogger& errorLogger,
                               const Settings& settings)
{
    for (const Scope* scope : symboldatabase.functionScopes) {
        for (auto* tok = const_cast<Token*>(scope->bodyStart); tok != scope->bodyEnd; tok = tok->next()) {
            if (!Token::simpleMatch(tok, ""swap (""))
                continue;
            if (!Token::simpleMatch(tok->next()->astOperand2(), "",""))
                continue;
            std::vector<Token*> args = astFlatten(tok->next()->astOperand2(), "","");
            if (args.size() != 2)
                continue;
            if (args[0]->exprId() == 0)
                continue;
            if (args[1]->exprId() == 0)
                continue;
            for (int i = 0; i < 2; i++) {
                std::vector<const Variable*> vars = getVariables(args[0]);
                ...",1,1,lib/valueflow.cpp,"valueFlowAfterSwap:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)",<empty>,,false,4181,4207,valueFlowAfterSwap,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)"
111669154119,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowSetConditionToKnown(const Token* tok, std::list<ValueFlow::Value>& values, bool then)
{
    if (values.empty())
        return;
    if (then && !Token::Match(tok, ""==|!|(""))
        return;
    if (!then && !Token::Match(tok, ""!=|%var%|(""))
        return;
    if (isConditionKnown(tok, then))
        changePossibleToKnown(values);
}",1,1,lib/valueflow.cpp,"valueFlowSetConditionToKnown:void(Token*,std.list<ValueFlow.Value>&,bool)",<empty>,,false,4209,4219,valueFlowSetConditionToKnown,,,1,"void(Token*,std.list<ValueFlow.Value>&,bool)"
111669154120,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isBreakScope(const Token* const endToken)
{
    if (!Token::simpleMatch(endToken, ""}""))
        return false;
    if (!Token::simpleMatch(endToken->link(), ""{""))
        return false;
    return Token::findmatch(endToken->link(), ""break|goto"", endToken);
}",1,1,lib/valueflow.cpp,isBreakScope:bool(Token*),<empty>,,false,4221,4228,isBreakScope,,,1,bool(Token*)
111669154121,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"ValueFlow::Value ValueFlow::asImpossible(ValueFlow::Value v)
{
    v.invertRange();
    v.setImpossible();
    return v;
}",1,1,lib/valueflow.cpp,ValueFlow.asImpossible:ValueFlow.Value(ValueFlow.Value),<empty>,,false,4230,4235,asImpossible,,,1,ValueFlow.Value(ValueFlow.Value)
111669154122,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void insertImpossible(std::list<ValueFlow::Value>& values, const std::list<ValueFlow::Value>& input)
{
    std::transform(input.cbegin(), input.cend(), std::back_inserter(values), &ValueFlow::asImpossible);
}",1,1,lib/valueflow.cpp,"insertImpossible:void(std.list<ValueFlow.Value>&,std.list<ValueFlow.Value>&)",<empty>,,false,4237,4240,insertImpossible,,,1,"void(std.list<ValueFlow.Value>&,std.list<ValueFlow.Value>&)"
111669154123,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void insertNegateKnown(std::list<ValueFlow::Value>& values, const std::list<ValueFlow::Value>& input)
{
    for (ValueFlow::Value value:input) {
        if (!value.isIntValue() && !value.isContainerSizeValue())
            continue;
        value.intvalue = !value.intvalue;
        value.setKnown();
        values.push_back(std::move(value));
    }
}",1,1,lib/valueflow.cpp,"insertNegateKnown:void(std.list<ValueFlow.Value>&,std.list<ValueFlow.Value>&)",<empty>,,false,4242,4251,insertNegateKnown,,,1,"void(std.list<ValueFlow.Value>&,std.list<ValueFlow.Value>&)"
111669154124,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
                return v.path > 0;
            }",68,13,lib/valueflow.cpp,lib/valueflow.cpp:<global>.ConditionHandler.Condition.findPath.<lambda>60:bool(ValueFlow.Value&),<empty>,,false,4268,4270,<lambda>60,,,1,bool(ValueFlow.Value&)
111669154125,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
                return v.path == 0 || v.path == it->path;
            }",50,13,lib/valueflow.cpp,lib/valueflow.cpp:<global>.ConditionHandler.Condition.findPath.<lambda>61:bool(ValueFlow.Value&),<empty>,,false,4273,4275,<lambda>61,,,1,bool(ValueFlow.Value&)
111669154126,METHOD,ConditionHandler.Condition,TYPE_DECL,"bool isBool() const {
            return astIsBool(vartok);
        }",9,9,lib/valueflow.cpp,ConditionHandler.Condition.isBool<const>:bool(),<empty>,,false,4262,4264,isBool,,,6,bool()
111669154127,METHOD,ConditionHandler.Condition,TYPE_DECL,"static MathLib::bigint findPath(const std::list<ValueFlow::Value>& values)
        {
            auto it = std::find_if(values.cbegin(), values.cend(), [](const ValueFlow::Value& v) {
                return v.path > 0;
            });
            if (it == values.end())
                return 0;
            assert(std::all_of(it, values.end(), [&](const ValueFlow::Value& v) {
                return v.path == 0 || v.path == it->path;
            }));
            return it->path;
        }",9,9,lib/valueflow.cpp,ConditionHandler.Condition.findPath:longlongint(std.list<ValueFlow.Value>&),<empty>,,false,4266,4277,findPath,,,7,longlongint(std.list<ValueFlow.Value>&)
111669154128,METHOD,ConditionHandler.Condition,TYPE_DECL,"MathLib::bigint getPath() const
        {
            assert(std::abs(findPath(true_values) - findPath(false_values)) == 0);
            return findPath(true_values) | findPath(false_values);
        }",9,9,lib/valueflow.cpp,ConditionHandler.Condition.getPath<const>:longlongint(),<empty>,,false,4279,4283,getPath,,,8,longlongint()
111669154129,METHOD,ConditionHandler.Condition,TYPE_DECL,"Token* getContextAndValues(Token* condTok,
                                   std::list<ValueFlow::Value>& thenValues,
                                   std::list<ValueFlow::Value>& elseValues,
                                   bool known = false) const
        {
            const MathLib::bigint path = getPath();
            const bool allowKnown = path == 0;
            const bool allowImpossible = impossible && allowKnown;

            bool inverted2 = inverted;
            Token* ctx = skipNotAndCasts(condTok, &inverted2);
            bool then = !inverted || !inverted2;

            if (!Token::Match(condTok, ""!=|=|(|."") && condTok != vartok) {
                thenValues.insert(thenValues.end(), true_values.cbegin(), true_values.cend());
                if (allowImpossible && (known || isConditionKnown(ctx, !then)))
                    insertImpossible(elseValues, false_values);
            }
            if (!Token::Match(condTok, ""==|!"")) {
                elseValues.insert(...",9,9,lib/valueflow.cpp,"ConditionHandler.Condition.getContextAndValues<const>:Token*(Token*,std.list<ValueFlow.Value>&,std.list<ValueFlow.Value>&,bool)",<empty>,,false,4285,4316,getContextAndValues,,,9,"Token*(Token*,std.list<ValueFlow.Value>&,std.list<ValueFlow.Value>&,bool)"
111669154130,METHOD,<empty>,<empty>,<empty>,5,,lib/valueflow.cpp,ConditionHandler.Condition.<clinit>,<empty>,,false,4254,,<clinit>,,,10,
111669154131,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
                    if (v.isIntValue())
                        return v.intvalue != 0;
                    return false;
                }",34,17,lib/valueflow.cpp,lib/valueflow.cpp:<global>.ConditionHandler.beforeCondition<const>.<lambda>62.<lambda>63:bool(ValueFlow.Value&),<empty>,,false,4442,4446,<lambda>63,,,1,bool(ValueFlow.Value&)
111669154132,METHOD,<empty>,<empty>,"[&](const Token* tok2) {
                        return Token::Match(tok2->astParent(), ""%assign%"") && astIsLHS(tok2);
                    }",75,21,lib/valueflow.cpp,lib/valueflow.cpp:<global>.ConditionHandler.beforeCondition<const>.<lambda>62.<lambda>64:bool(Token*),<empty>,,false,4476,4478,<lambda>64,,,1,bool(Token*)
111669154133,METHOD,<empty>,<empty>,"[&](const Condition& cond, Token* tok, const Scope*) {
            if (cond.vartok->exprId() == 0)
                return;

            // If condition is known then don't propagate value
            if (tok->hasKnownIntValue())
                return;

            Token* top = tok->astTop();

            if (Token::Match(top, ""%assign%""))
                return;
            if (Token::Match(cond.vartok->astParent(), ""%assign%|++|--""))
                return;

            if (Token::simpleMatch(tok->astParent(), ""?"") && tok->astParent()->isExpandedMacro()) {
                if (settings.debugwarnings)
                    bailout(tokenlist,
                            errorLogger,
                            tok,
                            ""variable '"" + cond.vartok->expressionString() + ""', condition is defined in macro"");
                return;
            }

            // if,macro => bailout
            if (Token::simpleMatch(top->previous(), ""if ("") && top->previous()->isExpan...",71,20,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ConditionHandler.beforeCondition<const>.<lambda>62:void(ConditionHandler.Condition&,Token*,Scope*)",<empty>,,false,4396,4501,<lambda>62,,,1,"void(ConditionHandler.Condition&,Token*,Scope*)"
111669154134,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
                return v.path == path && isNonConditionalPossibleIntValue(v);
            }",87,13,lib/valueflow.cpp,lib/valueflow.cpp:<global>.ConditionHandler.fillFromPath.<lambda>65.<lambda>66:bool(ValueFlow.Value&),<empty>,,false,4533,4535,<lambda>66,,,1,bool(ValueFlow.Value&)
111669154135,METHOD,<empty>,<empty>,"[&](const Token* tok) {
            const ValueFlow::Value* v = ValueFlow::findValue(tok->values(), settings, [&](const ValueFlow::Value& v) {
                return v.path == path && isNonConditionalPossibleIntValue(v);
            });
            if (v == nullptr)
                return ChildrenToVisit::op1_and_op2;
            pm.setValue(tok, *v);
            return ChildrenToVisit::op1_and_op2;
        }",28,9,lib/valueflow.cpp,lib/valueflow.cpp:<global>.ConditionHandler.fillFromPath.<lambda>65:ChildrenToVisit(Token*),<empty>,,false,4532,4540,<lambda>65,,,1,ChildrenToVisit(Token*)
111669154136,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
                        return v.isIntValue() || v.isFloatValue();
                    }",70,21,lib/valueflow.cpp,lib/valueflow.cpp:<global>.ConditionHandler.afterCondition<const>.<lambda>67.<lambda>68:bool(ValueFlow.Value&),<empty>,,false,4584,4586,<lambda>68,,,1,bool(ValueFlow.Value&)
111669154137,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
                            return v.isImpossible();
                        }",42,25,lib/valueflow.cpp,lib/valueflow.cpp:<global>.ConditionHandler.afterCondition<const>.<lambda>67.<lambda>69:bool(ValueFlow.Value&),<empty>,,false,4587,4589,<lambda>69,,,1,bool(ValueFlow.Value&)
111669154138,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
                    return v.isKnown() || v.isImpossible();
                }",82,17,lib/valueflow.cpp,lib/valueflow.cpp:<global>.ConditionHandler.afterCondition<const>.<lambda>67.<lambda>70:bool(ValueFlow.Value&),<empty>,,false,4840,4842,<lambda>70,,,1,bool(ValueFlow.Value&)
111669154139,METHOD,<empty>,<empty>,"[&](const Condition& cond, Token* condTok, const Scope* scope) {
            const MathLib::bigint path = cond.getPath();
            const bool allowKnown = path == 0;

            std::list<ValueFlow::Value> thenValues;
            std::list<ValueFlow::Value> elseValues;

            Token* ctx = cond.getContextAndValues(condTok, thenValues, elseValues);

            if (Token::Match(ctx->astParent(), ""%oror%|&&"")) {
                Token* parent = ctx->astParent();
                if (astIsRHS(ctx) && astIsLHS(parent) && parent->astParent() &&
                    parent->str() == parent->astParent()->str())
                    parent = parent->astParent();
                else if (!astIsLHS(ctx)) {
                    parent = nullptr;
                }
                if (parent) {
                    std::vector<Token*> nextExprs = {parent->astOperand2()};
                    if (astIsLHS(parent) && parent->astParent() && parent->astParent()->str() == parent->str()) {
         ...",71,20,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ConditionHandler.afterCondition<const>.<lambda>67:void(ConditionHandler.Condition&,Token*,Scope*)",<empty>,,false,4548,4863,<lambda>67,,,1,"void(ConditionHandler.Condition&,Token*,Scope*)"
111669154140,METHOD,ConditionHandler,TYPE_DECL,"virtual Analyzer::Result forward(Token* start,
                                     const Token* stop,
                                     const Token* exprTok,
                                     const std::list<ValueFlow::Value>& values,
                                     TokenList& tokenlist,
                                     ErrorLogger& errorLogger,
                                     const Settings& settings,
                                     SourceLocation loc = SourceLocation::current()) const
    {
        return valueFlowForward(start->next(), stop, exprTok, values, tokenlist, errorLogger, settings, loc);
    }",5,5,lib/valueflow.cpp,"ConditionHandler.forward<const>:Analyzer.Result(Token*,Token*,Token*,std.list<ValueFlow.Value>&,TokenList&,ErrorLogger&,Settings&,SourceLocation)",<empty>,,false,4321,4331,forward,,,2,"Analyzer.Result(Token*,Token*,Token*,std.list<ValueFlow.Value>&,TokenList&,ErrorLogger&,Settings&,SourceLocation)"
111669154141,METHOD,ConditionHandler,TYPE_DECL,"virtual Analyzer::Result forward(Token* top,
                                     const Token* exprTok,
                                     const std::list<ValueFlow::Value>& values,
                                     TokenList& tokenlist,
                                     ErrorLogger& errorLogger,
                                     const Settings& settings,
                                     SourceLocation loc = SourceLocation::current()) const
    {
        return valueFlowForwardRecursive(top, exprTok, values, tokenlist, errorLogger, settings, loc);
    }",5,5,lib/valueflow.cpp,"ConditionHandler.forward<const>:Analyzer.Result(Token*,Token*,std.list<ValueFlow.Value>&,TokenList&,ErrorLogger&,Settings&,SourceLocation)",<empty>,,false,4333,4342,forward,,,3,"Analyzer.Result(Token*,Token*,std.list<ValueFlow.Value>&,TokenList&,ErrorLogger&,Settings&,SourceLocation)"
111669154142,METHOD,ConditionHandler,TYPE_DECL,"virtual void reverse(Token* start,
                         const Token* endToken,
                         const Token* exprTok,
                         const std::list<ValueFlow::Value>& values,
                         TokenList& tokenlist,
                         ErrorLogger& errorLogger,
                         const Settings& settings,
                         SourceLocation loc = SourceLocation::current()) const
    {
        valueFlowReverse(start, endToken, exprTok, values, tokenlist, errorLogger, settings, loc);
    }",5,5,lib/valueflow.cpp,"ConditionHandler.reverse<const>:void(Token*,Token*,Token*,std.list<ValueFlow.Value>&,TokenList&,ErrorLogger&,Settings&,SourceLocation)",<empty>,,false,4344,4354,reverse,,,4,"void(Token*,Token*,Token*,std.list<ValueFlow.Value>&,TokenList&,ErrorLogger&,Settings&,SourceLocation)"
111669154143,METHOD,ConditionHandler,TYPE_DECL,"void traverseCondition(const SymbolDatabase& symboldatabase,
                           const Settings& settings,
                           const std::set<const Scope*>& skippedFunctions,
                           const std::function<void(const Condition& cond, Token* tok, const Scope* scope)>& f) const
    {
        for (const Scope *scope : symboldatabase.functionScopes) {
            if (skippedFunctions.count(scope))
                continue;
            for (auto *tok = const_cast<Token *>(scope->bodyStart); tok != scope->bodyEnd; tok = tok->next()) {
                if (Token::Match(tok, ""if|while|for (""))
                    continue;
                if (Token::Match(tok, "":|;|,""))
                    continue;

                const Token* top = tok->astTop();

                if (!Token::Match(top->previous(), ""if|while|for ("") && !Token::Match(tok->astParent(), ""&&|%oror%|?|!""))
                    continue;
                for (const Condition& cond : parse(tok, setting...",5,5,lib/valueflow.cpp,"ConditionHandler.traverseCondition<const>:void(SymbolDatabase&,Settings&,std.set<constScope*>&,std.function<void(constCondition&,Token*,Scope*)>&)",<empty>,,false,4356,4389,traverseCondition,,,5,"void(SymbolDatabase&,Settings&,std.set<constScope*>&,std.function<void(constCondition&,Token*,Scope*)>&)"
111669154144,METHOD,ConditionHandler,TYPE_DECL,"void beforeCondition(TokenList& tokenlist,
                         const SymbolDatabase& symboldatabase,
                         ErrorLogger& errorLogger,
                         const Settings& settings,
                         const std::set<const Scope*>& skippedFunctions) const {
        traverseCondition(symboldatabase, settings, skippedFunctions, [&](const Condition& cond, Token* tok, const Scope*) {
            if (cond.vartok->exprId() == 0)
                return;

            // If condition is known then don't propagate value
            if (tok->hasKnownIntValue())
                return;

            Token* top = tok->astTop();

            if (Token::Match(top, ""%assign%""))
                return;
            if (Token::Match(cond.vartok->astParent(), ""%assign%|++|--""))
                return;

            if (Token::simpleMatch(tok->astParent(), ""?"") && tok->astParent()->isExpandedMacro()) {
                if (settings.debugwarnings)
                    bailout(t...",5,20,lib/valueflow.cpp,"ConditionHandler.beforeCondition<const>:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,4391,4502,beforeCondition,,,6,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154145,METHOD,ConditionHandler,TYPE_DECL,"static Token* skipNotAndCasts(Token* tok, bool* inverted = nullptr)
    {
        for (; tok->astParent(); tok = tok->astParent()) {
            if (Token::simpleMatch(tok->astParent(), ""!"")) {
                if (inverted)
                    *inverted ^= true;
                continue;
            }
            if (Token::Match(tok->astParent(), ""==|!="")) {
                const Token* sibling = tok->astSibling();
                if (sibling->hasKnownIntValue() && (astIsBool(tok) || astIsBool(sibling))) {
                    const bool value = !!sibling->getKnownIntValue();
                    if (inverted)
                        *inverted ^= value == Token::simpleMatch(tok->astParent(), ""!="");
                    continue;
                }
            }
            if (tok->astParent()->isCast() && astIsBool(tok->astParent()))
                continue;
            return tok;
        }
        return tok;
    }",5,5,lib/valueflow.cpp,"ConditionHandler.skipNotAndCasts:Token*(Token*,bool*)",<empty>,,false,4504,4526,skipNotAndCasts,,,7,"Token*(Token*,bool*)"
111669154146,METHOD,ConditionHandler,TYPE_DECL,"static void fillFromPath(ProgramMemory& pm, const Token* top, MathLib::bigint path, const Settings& settings)
    {
        if (path < 1)
            return;
        visitAstNodes(top, [&](const Token* tok) {
            const ValueFlow::Value* v = ValueFlow::findValue(tok->values(), settings, [&](const ValueFlow::Value& v) {
                return v.path == path && isNonConditionalPossibleIntValue(v);
            });
            if (v == nullptr)
                return ChildrenToVisit::op1_and_op2;
            pm.setValue(tok, *v);
            return ChildrenToVisit::op1_and_op2;
        });
    }",5,5,lib/valueflow.cpp,"ConditionHandler.fillFromPath:void(ProgramMemory&,Token*,MathLib.bigint,Settings&)",<empty>,,false,4528,4541,fillFromPath,,,8,"void(ProgramMemory&,Token*,MathLib.bigint,Settings&)"
111669154147,METHOD,ConditionHandler,TYPE_DECL,"void afterCondition(TokenList& tokenlist,
                        const SymbolDatabase& symboldatabase,
                        ErrorLogger& errorLogger,
                        const Settings& settings,
                        const std::set<const Scope*>& skippedFunctions) const {
        traverseCondition(symboldatabase, settings, skippedFunctions, [&](const Condition& cond, Token* condTok, const Scope* scope) {
            const MathLib::bigint path = cond.getPath();
            const bool allowKnown = path == 0;

            std::list<ValueFlow::Value> thenValues;
            std::list<ValueFlow::Value> elseValues;

            Token* ctx = cond.getContextAndValues(condTok, thenValues, elseValues);

            if (Token::Match(ctx->astParent(), ""%oror%|&&"")) {
                Token* parent = ctx->astParent();
                if (astIsRHS(ctx) && astIsLHS(parent) && parent->astParent() &&
                    parent->str() == parent->astParent()->str())
                    paren...",5,20,lib/valueflow.cpp,"ConditionHandler.afterCondition<const>:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,4543,4864,afterCondition,,,9,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154148,METHOD,ConditionHandler,TYPE_DECL,virtual ~ConditionHandler() = default;,5,42,lib/valueflow.cpp,ConditionHandler.~ConditionHandler:ANY(),<empty>,,false,4865,4865,~ConditionHandler,,,10,ANY()
111669154149,METHOD,ConditionHandler,TYPE_DECL,ConditionHandler(const ConditionHandler&) = default;,5,56,lib/valueflow.cpp,ConditionHandler.ConditionHandler:ANY(ConditionHandler&),<empty>,,false,4866,4866,ConditionHandler,,,11,ANY(ConditionHandler&)
111669154150,METHOD,ConditionHandler,TYPE_DECL,ConditionHandler() = default;,5,33,lib/valueflow.cpp,ConditionHandler.ConditionHandler:ANY(),<empty>,,false,4868,4868,ConditionHandler,,,12,ANY()
111669154151,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowCondition(const ValuePtr<ConditionHandler>& handler,
                               TokenList& tokenlist,
                               SymbolDatabase& symboldatabase,
                               ErrorLogger& errorLogger,
                               const Settings& settings,
                               const std::set<const Scope*>& skippedFunctions)
{
    handler->beforeCondition(tokenlist, symboldatabase, errorLogger, settings, skippedFunctions);
    handler->afterCondition(tokenlist, symboldatabase, errorLogger, settings, skippedFunctions);
}",1,1,lib/valueflow.cpp,"valueFlowCondition:void(ValuePtr<ConditionHandler>&,TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,4871,4880,valueFlowCondition,,,1,"void(ValuePtr<ConditionHandler>&,TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154152,METHOD,<empty>,<empty>,"[&](const Token* vartok, ValueFlow::Value true_value, ValueFlow::Value false_value) {
            if (vartok->hasKnownIntValue())
                return;
            if (vartok->str() == ""="" && vartok->astOperand1() && vartok->astOperand2())
                vartok = vartok->astOperand1();
            Condition cond;
            cond.true_values.push_back(std::move(true_value));
            cond.false_values.push_back(std::move(false_value));
            cond.vartok = vartok;
            conds.push_back(std::move(cond));
        }",34,9,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.SimpleConditionHandler.parse<const>.<lambda>71:void(Token*,ValueFlow.Value,ValueFlow.Value)",<empty>,,false,4886,4896,<lambda>71,,,1,"void(Token*,ValueFlow.Value,ValueFlow.Value)"
111669154153,METHOD,SimpleConditionHandler,TYPE_DECL,"std::vector<Condition> parse(const Token* tok, const Settings& /*settings*/) const override {

        std::vector<Condition> conds;
        parseCompareEachInt(tok, [&](const Token* vartok, ValueFlow::Value true_value, ValueFlow::Value false_value) {
            if (vartok->hasKnownIntValue())
                return;
            if (vartok->str() == ""="" && vartok->astOperand1() && vartok->astOperand2())
                vartok = vartok->astOperand1();
            Condition cond;
            cond.true_values.push_back(std::move(true_value));
            cond.false_values.push_back(std::move(false_value));
            cond.vartok = vartok;
            conds.push_back(std::move(cond));
        });
        if (!conds.empty())
            return conds;

        const Token* vartok = nullptr;

        if (tok->str() == ""!"") {
            vartok = tok->astOperand1();

        } else if (tok->astParent() && (Token::Match(tok->astParent(), ""%oror%|&&|?"") ||
                                  ...",5,5,lib/valueflow.cpp,"SimpleConditionHandler.parse<const>:vector<Condition>(Token*,Settings&)",<empty>,,false,4883,4921,parse,,,1,"vector<Condition>(Token*,Settings&)"
111669154154,METHOD,IteratorInferModel,TYPE_DECL,"bool match(const ValueFlow::Value& value) const override {
        return value.valueType == getType();
    }",5,5,lib/valueflow.cpp,IteratorInferModel.match<const>:bool(ValueFlow.Value&),<empty>,,false,4926,4928,match,,,1,bool(ValueFlow.Value&)
111669154155,METHOD,IteratorInferModel,TYPE_DECL,"ValueFlow::Value yield(MathLib::bigint value) const override
    {
        ValueFlow::Value result(value);
        result.valueType = getType();
        result.setKnown();
        return result;
    }",5,5,lib/valueflow.cpp,IteratorInferModel.yield<const>:ValueFlow.Value(MathLib.bigint),<empty>,,false,4929,4935,yield,,,2,ValueFlow.Value(MathLib.bigint)
111669154156,METHOD,EndIteratorInferModel,TYPE_DECL,"ValueFlow::Value::ValueType getType() const override {
        return ValueFlow::Value::ValueType::ITERATOR_END;
    }",5,5,lib/valueflow.cpp,EndIteratorInferModel.getType<const>:ValueFlow.Value.ValueType(),<empty>,,false,4939,4941,getType,,,1,ValueFlow.Value.ValueType()
111669154157,METHOD,StartIteratorInferModel,TYPE_DECL,"ValueFlow::Value::ValueType getType() const override {
        return ValueFlow::Value::ValueType::ITERATOR_END;
    }",5,5,lib/valueflow.cpp,StartIteratorInferModel.getType<const>:ValueFlow.Value.ValueType(),<empty>,,false,4945,4947,getType,,,1,ValueFlow.Value.ValueType()
111669154158,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isIntegralOnlyOperator(const Token* tok) {
    return Token::Match(tok, ""%|<<|>>|&|^|~|%or%"");
}",1,1,lib/valueflow.cpp,isIntegralOnlyOperator:bool(Token*),<empty>,,false,4950,4952,isIntegralOnlyOperator,,,1,bool(Token*)
111669154159,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isIntegralOrPointer(const Token* tok)
{
    if (!tok)
        return false;
    if (astIsIntegral(tok, false))
        return true;
    if (astIsPointer(tok))
        return true;
    if (Token::Match(tok, ""NULL|nullptr""))
        return true;
    if (tok->valueType())
        return false;
    // These operators only work on integers
    if (isIntegralOnlyOperator(tok))
        return true;
    if (isIntegralOnlyOperator(tok->astParent()))
        return true;
    if (Token::Match(tok, ""+|-|*|/"") && tok->isBinaryOp())
        return isIntegralOrPointer(tok->astOperand1()) && isIntegralOrPointer(tok->astOperand2());
    return false;
}",1,1,lib/valueflow.cpp,isIntegralOrPointer:bool(Token*),<empty>,,false,4954,4974,isIntegralOrPointer,,,1,bool(Token*)
111669154160,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowInferCondition(TokenList& tokenlist, const Settings& settings)
{
    for (Token* tok = tokenlist.front(); tok; tok = tok->next()) {
        if (!tok->astParent())
            continue;
        if (tok->hasKnownIntValue())
            continue;
        if (Token::Match(tok, ""%comp%|-"") && tok->astOperand1() && tok->astOperand2()) {
            if (astIsIterator(tok->astOperand1()) || astIsIterator(tok->astOperand2())) {
                static const std::array<ValuePtr<InferModel>, 2> iteratorModels = {EndIteratorInferModel{},
                                                                                   StartIteratorInferModel{}};
                for (const ValuePtr<InferModel>& model : iteratorModels) {
                    std::vector<ValueFlow::Value> result =
                        infer(model, tok->str(), tok->astOperand1()->values(), tok->astOperand2()->values());
                    for (ValueFlow::Value value : result) {
                        value....",1,1,lib/valueflow.cpp,"valueFlowInferCondition:void(TokenList&,Settings&)",<empty>,,false,4976,5012,valueFlowInferCondition,,,1,"void(TokenList&,Settings&)"
111669154161,METHOD,<empty>,<empty>,"[&](const Token* lhsTok, const Token* rhsTok, bool inverted) {
            for (int i = 0; i < 2; i++) {
                const bool lhs = i == 0;
                const Token* vartok = lhs ? lhsTok : rhsTok;
                const Token* valuetok = lhs ? rhsTok : lhsTok;
                if (valuetok->exprId() == 0)
                    continue;
                if (valuetok->hasKnownSymbolicValue(vartok))
                    continue;
                if (vartok->hasKnownSymbolicValue(valuetok))
                    continue;
                ValueFlow::Value true_value;
                ValueFlow::Value false_value;
                setConditionalValues(tok, !lhs, 0, true_value, false_value);
                setSymbolic(true_value, valuetok);
                setSymbolic(false_value, valuetok);

                Condition cond;
                cond.true_values = {std::move(true_value)};
                cond.false_values = {std::move(false_value)};
                cond.vartok = vartok;
      ...",24,9,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.SymbolicConditionHandler.parse<const>.<lambda>72:void(Token*,Token*,bool)",<empty>,,false,5044,5068,<lambda>72,,,1,"void(Token*,Token*,bool)"
111669154162,METHOD,SymbolicConditionHandler,TYPE_DECL,"static bool isNegatedBool(const Token* tok)
    {
        if (!Token::simpleMatch(tok, ""!""))
            return false;
        return (astIsBool(tok->astOperand1()));
    }",5,5,lib/valueflow.cpp,SymbolicConditionHandler.isNegatedBool:bool(Token*),<empty>,,false,5016,5021,isNegatedBool,,,1,bool(Token*)
111669154163,METHOD,SymbolicConditionHandler,TYPE_DECL,"static const Token* skipNot(const Token* tok)
    {
        if (!Token::simpleMatch(tok, ""!""))
            return tok;
        return tok->astOperand1();
    }",5,5,lib/valueflow.cpp,SymbolicConditionHandler.skipNot:Token*(Token*),<empty>,,false,5023,5028,skipNot,,,2,Token*(Token*)
111669154164,METHOD,SymbolicConditionHandler,TYPE_DECL,"std::vector<Condition> parse(const Token* tok, const Settings& settings) const override
    {
        if (!Token::Match(tok, ""%comp%""))
            return {};
        if (tok->hasKnownIntValue())
            return {};
        if (!tok->astOperand1() || tok->astOperand1()->hasKnownIntValue() || tok->astOperand1()->isLiteral())
            return {};
        if (!tok->astOperand2() || tok->astOperand2()->hasKnownIntValue() || tok->astOperand2()->isLiteral())
            return {};
        if (!isConstExpression(tok, settings.library))
            return {};

        std::vector<Condition> result;
        auto addCond = [&](const Token* lhsTok, const Token* rhsTok, bool inverted) {
            for (int i = 0; i < 2; i++) {
                const bool lhs = i == 0;
                const Token* vartok = lhs ? lhsTok : rhsTok;
                const Token* valuetok = lhs ? rhsTok : lhsTok;
                if (valuetok->exprId() == 0)
                    continue;
                if (valuet...",5,5,lib/valueflow.cpp,"SymbolicConditionHandler.parse<const>:vector<Condition>(Token*,Settings&)",<empty>,,false,5030,5076,parse,,,3,"vector<Condition>(Token*,Settings&)"
111669154165,METHOD,<empty>,<empty>,"[&](const Token *t) {
            if (t->str() == ""="" && t->astOperand1() && programMemory.hasValue(t->astOperand1()->varId()))
                // TODO: investigate what variable is assigned.
                reassign = true;
            return reassign ? ChildrenToVisit::done : ChildrenToVisit::op1_and_op2;
        }",23,9,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowForLoop2.<lambda>73:ChildrenToVisit(Token*),<empty>,,false,5103,5108,<lambda>73,,,1,ChildrenToVisit(Token*)
111669154166,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool valueFlowForLoop2(const Token *tok,
                              ProgramMemory *memory1,
                              ProgramMemory *memory2,
                              ProgramMemory *memoryAfter,
                              const Settings& settings)
{
    // for ( firstExpression ; secondExpression ; thirdExpression )
    const Token *firstExpression  = tok->next()->astOperand2()->astOperand1();
    const Token *secondExpression = tok->next()->astOperand2()->astOperand2()->astOperand1();
    const Token *thirdExpression = tok->next()->astOperand2()->astOperand2()->astOperand2();

    ProgramMemory programMemory;
    MathLib::bigint result(0);
    bool error = false;
    execute(firstExpression, programMemory, &result, &error, settings);
    if (error)
        return false;
    execute(secondExpression, programMemory, &result, &error, settings);
    if (result == 0) // 2nd expression is false => no looping
        return false;
    if (error) {
        // If a var...",1,1,lib/valueflow.cpp,"valueFlowForLoop2:bool(Token*,ProgramMemory*,ProgramMemory*,ProgramMemory*,Settings&)",<empty>,,false,5079,5135,valueFlowForLoop2,,,1,"bool(Token*,ProgramMemory*,ProgramMemory*,ProgramMemory*,Settings&)"
111669154167,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowForLoopSimplify(Token* const bodyStart,
                                     const Token* expr,
                                     bool globalvar,
                                     const MathLib::bigint value,
                                     const TokenList& tokenlist,
                                     ErrorLogger& errorLogger,
                                     const Settings& settings)
{
    // TODO: Refactor this to use arbitrary expressions
    assert(expr->varId() > 0);
    const Token * const bodyEnd = bodyStart->link();

    // Is variable modified inside for loop
    if (isVariableChanged(bodyStart, bodyEnd, expr->varId(), globalvar, settings))
        return;

    if (const Token* escape = findEscapeStatement(bodyStart->scope(), &settings.library)) {
        if (settings.debugwarnings)
            bailout(tokenlist, errorLogger, escape, ""For loop variable bailout on escape statement"");
        return;
    }

    for (Token *tok2 = bodySta...",1,12,lib/valueflow.cpp,"valueFlowForLoopSimplify:void(Token*,Token*,bool,MathLib.bigint,TokenList&,ErrorLogger&,Settings&)",<empty>,,false,5137,5236,valueFlowForLoopSimplify,,,1,"void(Token*,Token*,bool,MathLib.bigint,TokenList&,ErrorLogger&,Settings&)"
111669154168,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowForLoopSimplifyAfter(Token* fortok, nonneg int varid, const MathLib::bigint num, const TokenList& tokenlist, ErrorLogger & errorLogger, const Settings& settings)
{
    const Token *vartok = nullptr;
    for (const Token *tok = fortok; tok; tok = tok->next()) {
        if (tok->varId() == varid) {
            vartok = tok;
            break;
        }
    }
    if (!vartok || !vartok->variable())
        return;

    const Variable *var = vartok->variable();
    const Token *endToken = nullptr;
    if (var->isLocal())
        endToken = var->scope()->bodyEnd;
    else
        endToken = fortok->scope()->bodyEnd;

    Token* blockTok = fortok->linkAt(1)->linkAt(1);
    if (blockTok != endToken) {
        ValueFlow::Value v{num};
        v.errorPath.emplace_back(fortok,""After for loop, "" + var->name() + "" has value "" + v.infoString());

        valueFlowForward(blockTok->next(), endToken, vartok, std::move(v), tokenlist, errorLogger, settings);
    }
}",1,57,lib/valueflow.cpp,"valueFlowForLoopSimplifyAfter:void(Token*,int,MathLib.bigint,TokenList&,ErrorLogger&,Settings&)",<empty>,,false,5238,5264,valueFlowForLoopSimplifyAfter,,,1,"void(Token*,int,MathLib.bigint,TokenList&,ErrorLogger&,Settings&)"
111669154169,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowForLoop(TokenList &tokenlist, const SymbolDatabase& symboldatabase, ErrorLogger &errorLogger, const Settings &settings)
{
    for (const Scope &scope : symboldatabase.scopeList) {
        if (scope.type != ScopeType::eFor)
            continue;

        auto* tok = const_cast<Token*>(scope.classDef);
        auto* const bodyStart = const_cast<Token*>(scope.bodyStart);

        if (!Token::simpleMatch(tok->next()->astOperand2(), "";"") ||
            !Token::simpleMatch(tok->next()->astOperand2()->astOperand2(), "";""))
            continue;

        nonneg int varid;
        bool knownInitValue, partialCond;
        MathLib::bigint initValue, stepValue, lastValue;

        if (extractForLoopValues(tok, varid, knownInitValue, initValue, partialCond, stepValue, lastValue)) {
            const bool executeBody = !knownInitValue || initValue <= lastValue;
            const Token* vartok = Token::findmatch(tok, ""%varid%"", bodyStart, varid);
            if (executeBody &&...",1,8,lib/valueflow.cpp,"valueFlowForLoop:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)",<empty>,,false,5266,5337,valueFlowForLoop,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)"
111669154170,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& value) {
            Args new_args;
            for (auto arg : args) {
                if (value.path != 0) {
                    for (const auto& q : arg) {
                        if (q.first == p.first)
                            continue;
                        if (q.second.path == 0)
                            continue;
                        if (q.second.path != value.path)
                            return;
                    }
                }
                arg[p.first] = value;
                new_args.push_back(std::move(arg));
            }
            std::copy(new_args.cbegin(), new_args.cend(), std::back_inserter(args));
        }",68,9,lib/valueflow.cpp,lib/valueflow.cpp:<global>.productParams.<lambda>74:void(ValueFlow.Value&),<empty>,,false,5359,5376,<lambda>74,,,1,void(ValueFlow.Value&)
111669154171,METHOD,<empty>,<empty>,"[&](const std::pair<Key, ValueFlow::Value>& p) {
            return p.second.path != path;
        }",51,9,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.productParams.<lambda>75:bool(std.pair<Key,ValueFlow.Value>&)",<empty>,,false,5390,5392,<lambda>75,,,1,"bool(std.pair<Key,ValueFlow.Value>&)"
111669154172,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool productParams(const Settings& settings, const std::unordered_map<Key, std::list<ValueFlow::Value>>& vars, F f)
{
    using Args = std::vector<std::unordered_map<Key, ValueFlow::Value>>;
    Args args(1);
    // Compute cartesian product of all arguments
    for (const auto& p : vars) {
        if (p.second.empty())
            continue;
        args.back()[p.first] = p.second.front();
    }
    bool bail = false;
    int max = settings.vfOptions.maxSubFunctionArgs;
    for (const auto& p : vars) {
        if (args.size() > max) {
            bail = true;
            break;
        }
        if (p.second.empty())
            continue;
        std::for_each(std::next(p.second.begin()), p.second.end(), [&](const ValueFlow::Value& value) {
            Args new_args;
            for (auto arg : args) {
                if (value.path != 0) {
                    for (const auto& q : arg) {
                        if (q.first == p.first)
                            continue;
   ...",1,1,lib/valueflow.cpp,"productParams:bool(Settings&,std.unordered_map<Key,std.list<ValueFlow.Value>>&,F)",<empty>,,false,5340,5397,productParams,,,1,"bool(Settings&,std.unordered_map<Key,std.list<ValueFlow.Value>>&,F)"
111669154173,METHOD,<empty>,<empty>,"[&](const std::unordered_map<const Variable*, ValueFlow::Value>& arg) {
        auto a = makeMultiValueFlowAnalyzer(arg, settings);
        valueFlowGenericForward(const_cast<Token*>(functionScope->bodyStart),
                                functionScope->bodyEnd,
                                a,
                                tokenlist,
                                errorLogger,
                                settings);
    }",50,5,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.valueFlowInjectParameter.<lambda>76:void(std.unordered_map<constVariable*,ValueFlow.Value>&)",<empty>,,false,5405,5413,<lambda>76,,,1,"void(std.unordered_map<constVariable*,ValueFlow.Value>&)"
111669154174,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowInjectParameter(const TokenList& tokenlist,
                                     ErrorLogger& errorLogger,
                                     const Settings& settings,
                                     const Scope* functionScope,
                                     const std::unordered_map<const Variable*, std::list<ValueFlow::Value>>& vars)
{
    const bool r = productParams(settings, vars, [&](const std::unordered_map<const Variable*, ValueFlow::Value>& arg) {
        auto a = makeMultiValueFlowAnalyzer(arg, settings);
        valueFlowGenericForward(const_cast<Token*>(functionScope->bodyStart),
                                functionScope->bodyEnd,
                                a,
                                tokenlist,
                                errorLogger,
                                settings);
    });
    if (!r) {
        std::string fname = ""<unknown>"";
        if (const Function* f = functionScope->function)
            fname = f->...",1,12,lib/valueflow.cpp,"valueFlowInjectParameter:void(TokenList&,ErrorLogger&,Settings&,Scope*,std.unordered_map<constVariable*,std.list<ValueFlow.Value>>&)",<empty>,,false,5399,5421,valueFlowInjectParameter,,,1,"void(TokenList&,ErrorLogger&,Settings&,Scope*,std.unordered_map<constVariable*,std.list<ValueFlow.Value>>&)"
111669154175,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowInjectParameter(const TokenList& tokenlist,
                                     ErrorLogger& errorLogger,
                                     const Settings& settings,
                                     const Variable* arg,
                                     const Scope* functionScope,
                                     const std::list<ValueFlow::Value>& argvalues)
{
    // Is argument passed by value or const reference, and is it a known non-class type?
    if (arg->isReference() && !arg->isConst() && !arg->isClass())
        return;

    // Set value in function scope..
    const nonneg int varid2 = arg->declarationId();
    if (!varid2)
        return;

    valueFlowForward(const_cast<Token*>(functionScope->bodyStart->next()),
                     functionScope->bodyEnd,
                     arg->nameToken(),
                     argvalues,
                     tokenlist,
                     errorLogger,
                     settings);
}",1,10,lib/valueflow.cpp,"valueFlowInjectParameter:void(TokenList&,ErrorLogger&,Settings&,Variable*,Scope*,std.list<ValueFlow.Value>&)",<empty>,,false,5423,5446,valueFlowInjectParameter,,,1,"void(TokenList&,ErrorLogger&,Settings&,Variable*,Scope*,std.list<ValueFlow.Value>&)"
111669154176,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowSwitchVariable(const TokenList& tokenlist,
                                    const SymbolDatabase& symboldatabase,
                                    ErrorLogger& errorLogger,
                                    const Settings& settings)
{
    for (const Scope& scope : symboldatabase.scopeList) {
        if (scope.type != ScopeType::eSwitch)
            continue;
        if (!Token::Match(scope.classDef, ""switch ( %var% ) {""))
            continue;
        const Token* vartok = scope.classDef->tokAt(2);
        const Variable* var = vartok->variable();
        if (!var)
            continue;

        // bailout: global non-const variables
        if (!(var->isLocal() || var->isArgument()) && !var->isConst()) {
            if (settings.debugwarnings)
                bailout(tokenlist, errorLogger, vartok, ""switch variable "" + var->name() + "" is global"");
            continue;
        }

        for (const Token* tok = scope.bodyStart->next(); tok != scope.body...",1,16,lib/valueflow.cpp,"valueFlowSwitchVariable:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)",<empty>,,false,5448,5521,valueFlowSwitchVariable,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)"
111669154177,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static std::list<ValueFlow::Value> getFunctionArgumentValues(const Token* argtok)
{
    std::list<ValueFlow::Value> argvalues(argtok->values());
    removeImpossible(argvalues);
    if (argvalues.empty() && Token::Match(argtok, ""%comp%|%oror%|&&|!"")) {
        argvalues.emplace_back(0);
        argvalues.emplace_back(1);
    }
    return argvalues;
}",1,1,lib/valueflow.cpp,getFunctionArgumentValues:list<ValueFlow.Value>(Token*),<empty>,,false,5523,5532,getFunctionArgumentValues,,,1,list<ValueFlow::Value>(Token*)
111669154178,METHOD,<empty>,<empty>,"[&](const std::unordered_map<nonneg int, ValueFlow::Value>& arg) {
        ValueFlow::Value value = evaluateLibraryFunction(arg, returnValue, settings, tok->isCpp());
        if (value.isUninitValue())
            return;
        ValueFlow::Value::ValueKind kind = ValueFlow::Value::ValueKind::Known;
        for (auto&& p : arg) {
            if (p.second.isPossible())
                kind = p.second.valueKind;
            if (p.second.isInconclusive()) {
                kind = p.second.valueKind;
                break;
            }
        }
        if (value.isImpossible() && kind != ValueFlow::Value::ValueKind::Known)
            return;
        if (!value.isImpossible())
            value.valueKind = kind;
        setTokenValue(tok, std::move(value), settings);
    }",40,68,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.valueFlowLibraryFunction.<lambda>77:void(std.unordered_map<int,ValueFlow.Value>&)",<empty>,,false,5544,5562,<lambda>77,,,1,"void(std.unordered_map<int,ValueFlow.Value>&)"
111669154179,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowLibraryFunction(Token* tok, const std::string& returnValue, const Settings& settings)
{
    std::unordered_map<nonneg int, std::list<ValueFlow::Value>> argValues;
    int argn = 1;
    for (const Token* argtok : getArguments(tok->previous())) {
        argValues[argn] = getFunctionArgumentValues(argtok);
        argn++;
    }
    if (returnValue.find(""arg"") != std::string::npos && argValues.empty())
        return;
    productParams(settings, argValues, [&](const std::unordered_map<nonneg int, ValueFlow::Value>& arg) {
        ValueFlow::Value value = evaluateLibraryFunction(arg, returnValue, settings, tok->isCpp());
        if (value.isUninitValue())
            return;
        ValueFlow::Value::ValueKind kind = ValueFlow::Value::ValueKind::Known;
        for (auto&& p : arg) {
            if (p.second.isPossible())
                kind = p.second.valueKind;
            if (p.second.isInconclusive()) {
                kind = p.second.valueKind;
                ...",1,23,lib/valueflow.cpp,"valueFlowLibraryFunction:void(Token*,std.string&,Settings&)",<empty>,,false,5534,5563,valueFlowLibraryFunction,,,1,"void(Token*,std.string&,Settings&)"
111669154180,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
                    if (v.isLifetimeValue())
                        return !v.isLocalLifetimeValue() && !v.isSubFunctionLifetimeValue();
                    return false;
                }",37,17,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowSubFunction.<lambda>78:bool(ValueFlow.Value&),<empty>,,false,5608,5612,<lambda>78,,,1,bool(ValueFlow.Value&)
111669154181,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowSubFunction(const TokenList& tokenlist,
                                 const SymbolDatabase& symboldatabase,
                                 ErrorLogger& errorLogger,
                                 const Settings& settings)
{
    int id = 0;
    for (auto it = symboldatabase.functionScopes.crbegin(); it != symboldatabase.functionScopes.crend(); ++it) {
        const Scope* scope = *it;
        const Function* function = scope->function;
        if (!function)
            continue;
        for (auto* tok = const_cast<Token*>(scope->bodyStart); tok != scope->bodyEnd; tok = tok->next()) {
            if (tok->isKeyword() || !Token::Match(tok, ""%name% (""))
                continue;

            const Function* const calledFunction = tok->function();
            if (!calledFunction) {
                // library function?
                const std::string& returnValue(settings.library.returnValue(tok));
                if (!returnValue.empty())
                  ...",1,1,lib/valueflow.cpp,"valueFlowSubFunction:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)",<empty>,,false,5565,5644,valueFlowSubFunction,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)"
111669154182,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowFunctionDefaultParameter(const TokenList& tokenlist, const SymbolDatabase& symboldatabase, ErrorLogger& errorLogger, const Settings& settings)
{
    if (!tokenlist.isCPP())
        return;

    for (const Scope* scope : symboldatabase.functionScopes) {
        const Function* function = scope->function;
        if (!function)
            continue;
        for (nonneg int arg = function->minArgCount(); arg < function->argCount(); arg++) {
            const Variable* var = function->getArgumentVar(arg);
            if (var && var->hasDefault() && Token::Match(var->nameToken(), ""%var% = %num%|%str%|%char%|%name% [,)]"")) {
                const std::list<ValueFlow::Value> &values = var->nameToken()->tokAt(2)->values();
                std::list<ValueFlow::Value> argvalues;
                for (const ValueFlow::Value &value : values) {
                    ValueFlow::Value v(value);
                    v.defaultArg = true;
                    v.changeKnownToPossible()...",1,13,lib/valueflow.cpp,"valueFlowFunctionDefaultParameter:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)",<empty>,,false,5646,5672,valueFlowFunctionDefaultParameter,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)"
111669154183,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
        return (v.isIntValue() || v.isContainerSizeValue() || v.isFloatValue()) && v.isKnown();
    }",72,5,lib/valueflow.cpp,lib/valueflow.cpp:<global>.getKnownValueFromToken.<lambda>79:bool(ValueFlow.Value&),<empty>,,false,5678,5680,<lambda>79,,,1,bool(ValueFlow.Value&)
111669154184,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static const ValueFlow::Value* getKnownValueFromToken(const Token* tok)
{
    if (!tok)
        return nullptr;
    auto it = std::find_if(tok->values().begin(), tok->values().end(), [&](const ValueFlow::Value& v) {
        return (v.isIntValue() || v.isContainerSizeValue() || v.isFloatValue()) && v.isKnown();
    });
    if (it == tok->values().end())
        return nullptr;
    return std::addressof(*it);
}",1,1,lib/valueflow.cpp,getKnownValueFromToken:ValueFlow.Value*(Token*),<empty>,,false,5674,5684,getKnownValueFromToken,,,1,ValueFlow.Value*(Token*)
111669154185,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
            return v.equalValue(*result) && v.valueKind == result->valueKind;
        }",72,9,lib/valueflow.cpp,lib/valueflow.cpp:<global>.getKnownValueFromTokens.<lambda>80.<lambda>81:bool(ValueFlow.Value&),<empty>,,false,5694,5696,<lambda>81,,,1,bool(ValueFlow.Value&)
111669154186,METHOD,<empty>,<empty>,"[&](const Token* tok) {
        return std::any_of(tok->values().begin(), tok->values().end(), [&](const ValueFlow::Value& v) {
            return v.equalValue(*result) && v.valueKind == result->valueKind;
        });
    }",59,5,lib/valueflow.cpp,lib/valueflow.cpp:<global>.getKnownValueFromTokens.<lambda>80:ANY(Token*),<empty>,,false,5693,5697,<lambda>80,,,1,ANY(Token*)
111669154187,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static const ValueFlow::Value* getKnownValueFromTokens(const std::vector<const Token*>& toks)
{
    if (toks.empty())
        return nullptr;
    const ValueFlow::Value* result = getKnownValueFromToken(toks.front());
    if (!result)
        return nullptr;
    if (!std::all_of(std::next(toks.begin()), toks.end(), [&](const Token* tok) {
        return std::any_of(tok->values().begin(), tok->values().end(), [&](const ValueFlow::Value& v) {
            return v.equalValue(*result) && v.valueKind == result->valueKind;
        });
    }))
        return nullptr;
    return result;
}",1,1,lib/valueflow.cpp,getKnownValueFromTokens:ValueFlow.Value*(std.vector<constToken*>&),<empty>,,false,5686,5700,getKnownValueFromTokens,,,1,ValueFlow.Value*(std.vector<constToken*>&)
111669154188,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void setFunctionReturnValue(const Function* f, Token* tok, ValueFlow::Value v, const Settings& settings)
{
    if (f->hasVirtualSpecifier()) {
        if (v.isImpossible())
            return;
        v.setPossible();
    } else if (!v.isImpossible()) {
        v.setKnown();
    }
    v.errorPath.emplace_back(tok, ""Calling function '"" + f->name() + ""' returns "" + v.toString());
    setTokenValue(tok, std::move(v), settings);
}",1,1,lib/valueflow.cpp,"setFunctionReturnValue:void(Function*,Token*,ValueFlow.Value,Settings&)",<empty>,,false,5702,5713,setFunctionReturnValue,,,1,"void(Function*,Token*,ValueFlow.Value,Settings&)"
111669154189,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowFunctionReturn(TokenList& tokenlist, ErrorLogger& errorLogger, const Settings& settings)
{
    for (Token* tok = tokenlist.back(); tok; tok = tok->previous()) {
        if (tok->str() != ""("" || !tok->astOperand1() || tok->isCast())
            continue;

        const Function* function = nullptr;
        if (Token::Match(tok->previous(), ""%name% (""))
            function = tok->previous()->function();
        else
            function = tok->astOperand1()->function();
        if (!function)
            continue;
        // TODO: Check if member variable is a pointer or reference
        if (function->isImplicitlyVirtual() && !function->hasFinalSpecifier())
            continue;

        if (tok->hasKnownValue())
            continue;

        std::vector<const Token*> returns = Function::findReturns(function);
        if (returns.empty())
            continue;

        if (const ValueFlow::Value* v = getKnownValueFromTokens(returns)) {
            setFunctionRe...",1,20,lib/valueflow.cpp,"valueFlowFunctionReturn:void(TokenList&,ErrorLogger&,Settings&)",<empty>,,false,5715,5770,valueFlowFunctionReturn,,,1,"void(TokenList&,ErrorLogger&,Settings&)"
111669154190,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool needsInitialization(const Variable* var)
{
    if (!var)
        return false;
    if (var->hasDefault())
        return false;
    if (var->isPointer())
        return true;
    if (var->type() && var->type()->isUnionType())
        return false;
    if (!var->nameToken()->isCpp())
        return true;
    if (var->type() && var->type()->needInitialization == Type::NeedInitialization::True)
        return true;
    if (var->valueType()) {
        if (var->valueType()->isPrimitive())
            return true;
        if (var->valueType()->type == ValueType::Type::POD)
            return true;
        if (var->valueType()->type == ValueType::Type::ITERATOR)
            return true;
        if (var->isStlType() && var->isArray()) {
            if (const Token* ctt = var->valueType()->containerTypeToken) {
                if (ctt->isStandardType())
                    return true;
                const Type* ct = ctt->type();
                if (ct && ct->needInitialization ...",1,1,lib/valueflow.cpp,needsInitialization:bool(Variable*),<empty>,,false,5772,5804,needsInitialization,,,1,bool(Variable*)
111669154191,METHOD,<empty>,<empty>,"[](const ErrorPathItem& e) {
        return e.first;
    }",20,5,lib/valueflow.cpp,lib/valueflow.cpp:<global>.addToErrorPath.<lambda>82:ANY(ErrorPathItem&),<empty>,,false,5812,5814,<lambda>82,,,1,ANY(ErrorPathItem&)
111669154192,METHOD,<empty>,<empty>,"[&](const ErrorPathItem& e) {
        return locations.insert(e.first).second;
    }",18,5,lib/valueflow.cpp,lib/valueflow.cpp:<global>.addToErrorPath.<lambda>83:ANY(ErrorPathItem&),<empty>,,false,5820,5822,<lambda>83,,,1,ANY(ErrorPathItem&)
111669154193,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void addToErrorPath(ValueFlow::Value& value, const ValueFlow::Value& from)
{
    std::unordered_set<const Token*> locations;
    std::transform(value.errorPath.cbegin(),
                   value.errorPath.cend(),
                   std::inserter(locations, locations.begin()),
                   [](const ErrorPathItem& e) {
        return e.first;
    });
    if (from.condition && !value.condition)
        value.condition = from.condition;
    std::copy_if(from.errorPath.cbegin(),
                 from.errorPath.cend(),
                 std::back_inserter(value.errorPath),
                 [&](const ErrorPathItem& e) {
        return locations.insert(e.first).second;
    });
}",1,1,lib/valueflow.cpp,"addToErrorPath:void(ValueFlow.Value&,ValueFlow.Value&)",<empty>,,false,5806,5823,addToErrorPath,,,1,"void(ValueFlow.Value&,ValueFlow.Value&)"
111669154194,METHOD,<empty>,<empty>,"[&](const Token* tok) {
        return tok->varId() == var->declarationId();
    }",67,5,lib/valueflow.cpp,lib/valueflow.cpp:<global>.findAllUsages.<lambda>84:bool(Token*),<empty>,,false,5833,5835,<lambda>84,,,1,bool(Token*)
111669154195,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static std::vector<Token*> findAllUsages(const Variable* var,
                                         Token* start, // cppcheck-suppress constParameterPointer // FP
                                         const Library& library)
{
    // std::vector<Token*> result;
    const Scope* scope = var->scope();
    if (!scope)
        return {};
    return findTokensSkipDeadCode(library, start, scope->bodyEnd, [&](const Token* tok) {
        return tok->varId() == var->declarationId();
    });
}",1,1,lib/valueflow.cpp,"findAllUsages:vector<Token*>(Variable*,Token*,Library&)",<empty>,,false,5825,5836,findAllUsages,,,1,"vector<Token*>(Variable*,Token*,Library&)"
111669154196,METHOD,<empty>,<empty>,"[&](const Token* tok) {
        return tok->scope() == scope;
    }",51,5,lib/valueflow.cpp,lib/valueflow.cpp:<global>.findStartToken.<lambda>85:bool(Token*),<empty>,,false,5873,5875,<lambda>85,,,1,bool(Token*)
111669154197,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static Token* findStartToken(const Variable* var, Token* start, const Library& library)
{
    std::vector<Token*> uses = findAllUsages(var, start, library);
    if (uses.empty())
        return start;
    Token* first = uses.front();
    if (Token::findmatch(start, ""goto|asm|setjmp|longjmp"", first))
        return start;
    if (first != var->nameToken()) {
        // if this is lhs in assignment then set first to the first token in LHS expression
        Token* temp = first;
        while (Token::Match(temp->astParent(), ""[&*(]"") && precedes(temp->astParent(), temp))
            temp = temp->astParent();
        if (Token::simpleMatch(temp->astParent(), ""="") && precedes(temp, temp->astParent()))
            first = temp;
    }
    // If there is only one usage
    if (uses.size() == 1)
        return first->previous();
    const Scope* scope = first->scope();
    // If first usage is in variable scope
    if (scope == var->scope()) {
        bool isLoopExpression = false;
        f...",1,1,lib/valueflow.cpp,"findStartToken:Token*(Variable*,Token*,Library&)",<empty>,,false,5838,5890,findStartToken,,,1,"Token*(Variable*,Token*,Library&)"
111669154198,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowUninit(TokenList& tokenlist, ErrorLogger& errorLogger, const Settings& settings)
{
    for (Token *tok = tokenlist.front(); tok; tok = tok->next()) {
        if (!tok->scope()->isExecutable())
            continue;
        if (!Token::Match(tok, ""%var% ;|[""))
            continue;
        const Variable* var = tok->variable();
        if (!var)
            continue;
        if (var->nameToken() != tok || var->isInit())
            continue;
        if (!needsInitialization(var))
            continue;
        if (!var->isLocal() || var->isStatic() || var->isExtern() || var->isReference() || var->isThrow())
            continue;

        ValueFlow::Value uninitValue;
        uninitValue.setKnown();
        uninitValue.valueType = ValueFlow::Value::ValueType::UNINIT;
        uninitValue.tokvalue = tok;
        if (var->isArray())
            uninitValue.indirect = var->dimensions().size();

        bool partial = false;

        Token* start = findStartToken(var, t...",1,1,lib/valueflow.cpp,"valueFlowUninit:void(TokenList&,ErrorLogger&,Settings&)",<empty>,,false,5892,5969,valueFlowUninit,,,1,"void(TokenList&,ErrorLogger&,Settings&)"
111669154199,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isContainerSizeChangedByFunction(const Token* tok,
                                             int indirect,
                                             const Settings& settings,
                                             int depth = 20)
{
    if (!tok->valueType())
        return false;
    if (!astIsContainer(tok))
        return false;
    // If we are accessing an element then we are not changing the container size
    if (Token::Match(tok, ""%name% . %name% ("")) {
        const Library::Container::Yield yield = getLibraryContainer(tok)->getYield(tok->strAt(2));
        if (yield != Library::Container::Yield::NO_YIELD)
            return false;
    }
    if (Token::simpleMatch(tok->astParent(), ""[""))
        return false;

    // address of variable
    const bool addressOf = tok->valueType()->pointer || (tok->astParent() && tok->astParent()->isUnaryOp(""&""));

    int narg;
    const Token * ftok = getTokenArgumentFunction(tok, narg);
    if (!ftok)
        return...",1,1,lib/valueflow.cpp,"isContainerSizeChangedByFunction:bool(Token*,int,Settings&,int)",<empty>,,false,5978,6035,isContainerSizeChangedByFunction,,,1,"bool(Token*,int,Settings&,int)"
111669154200,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static const Token* parseBinaryIntOp(const Token* expr,
                                     const std::function<std::vector<MathLib::bigint>(const Token*)>& eval,
                                     MathLib::bigint& known)
{
    if (!expr)
        return nullptr;
    if (!expr->astOperand1() || !expr->astOperand2())
        return nullptr;
    if (expr->astOperand1()->exprId() == 0 && expr->astOperand2()->exprId() == 0)
        return nullptr;
    std::vector<MathLib::bigint> x1 = eval(expr->astOperand1());
    if (expr->astOperand1()->exprId() == 0 && x1.empty())
        return nullptr;
    std::vector<MathLib::bigint> x2 = eval(expr->astOperand2());
    if (expr->astOperand2()->exprId() == 0 && x2.empty())
        return nullptr;
    const Token* varTok = nullptr;
    if (!x1.empty() && x2.empty()) {
        varTok = expr->astOperand2();
        known = x1.front();
    } else if (x1.empty() && !x2.empty()) {
        varTok = expr->astOperand1();
        known = x2.front();
    }...",1,1,lib/valueflow.cpp,"parseBinaryIntOp:Token*(Token*,std.function<std.vector<MathLib.bigint>(constToken*)>&,MathLib.bigint&)",<empty>,,false,6037,6062,parseBinaryIntOp,,,1,"Token*(Token*,std.function<std.vector<MathLib.bigint>(constToken*)>&,MathLib.bigint&)"
111669154201,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"const Token* ValueFlow::solveExprValue(const Token* expr,
                                       const std::function<std::vector<MathLib::bigint>(const Token*)>& eval,
                                       ValueFlow::Value& value)
{
    if (!value.isIntValue() && !value.isIteratorValue() && !value.isSymbolicValue())
        return expr;
    if (value.isSymbolicValue() && !Token::Match(expr, ""+|-""))
        return expr;
    MathLib::bigint intval = 0;
    const Token* binaryTok = parseBinaryIntOp(expr, eval, intval);
    const bool rhs = astIsRHS(binaryTok);
    // If its on the rhs, then -1 multiplication is needed, which is not possible with simple delta analysis used currently for symbolic values
    if (value.isSymbolicValue() && rhs && Token::simpleMatch(expr, ""-""))
        return expr;
    if (binaryTok && expr->str().size() == 1) {
        switch (expr->str()[0]) {
        case '+': {
            value.intvalue -= intval;
            return ValueFlow::solveExprValue(binaryTok...",1,1,lib/valueflow.cpp,"ValueFlow.solveExprValue:Token*(Token*,std.function<std.vector<MathLib.bigint>(constToken*)>&,ValueFlow.Value&)",<empty>,,false,6064,6104,solveExprValue,,,1,"Token*(Token*,std.function<std.vector<MathLib.bigint>(constToken*)>&,ValueFlow.Value&)"
111669154202,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"bool ValueFlow::isContainerSizeChanged(const Token* tok, int indirect, const Settings& settings, int depth)
{
    if (!tok)
        return false;
    if (!tok->valueType() || !tok->valueType()->container)
        return true;
    if (astIsLHS(tok) && Token::Match(tok->astParent(), ""%assign%|<<""))
        return true;
    if (astIsLHS(tok) && Token::simpleMatch(tok->astParent(), ""[""))
        return tok->valueType()->container->stdAssociativeLike;
    const Library::Container::Action action = astContainerAction(tok);
    switch (action) {
    case Library::Container::Action::RESIZE:
    case Library::Container::Action::CLEAR:
    case Library::Container::Action::PUSH:
    case Library::Container::Action::POP:
    case Library::Container::Action::CHANGE:
    case Library::Container::Action::INSERT:
    case Library::Container::Action::ERASE:
    case Library::Container::Action::APPEND:
        return true;
    case Library::Container::Action::NO_ACTION:
        // Is this an unknown m...",1,1,lib/valueflow.cpp,"ValueFlow.isContainerSizeChanged:bool(Token*,int,Settings&,int)",<empty>,,false,6106,6141,isContainerSizeChanged,,,1,"bool(Token*,int,Settings&,int)"
111669154203,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool isContainerSizeChanged(const Token* expr,
                                   const Token* start,
                                   const Token* end,
                                   int indirect,
                                   const Settings& settings,
                                   int depth)
{
    for (const Token *tok = start; tok != end; tok = tok->next()) {
        if (tok->exprId() != expr->exprId() && !isAliasOf(tok, expr))
            continue;
        if (ValueFlow::isContainerSizeChanged(tok, indirect, settings, depth))
            return true;
    }
    return false;
}",1,1,lib/valueflow.cpp,"isContainerSizeChanged:bool(Token*,Token*,Token*,int,Settings&,int)",<empty>,,false,6143,6157,isContainerSizeChanged,,,1,"bool(Token*,Token*,Token*,int,Settings&,int)"
111669154204,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowSmartPointer(TokenList &tokenlist, ErrorLogger & errorLogger, const Settings &settings)
{
    for (Token *tok = tokenlist.front(); tok; tok = tok->next()) {
        if (!tok->scope())
            continue;
        if (!tok->scope()->isExecutable())
            continue;
        if (!astIsSmartPointer(tok))
            continue;
        if (tok->variable() && Token::Match(tok, ""%var% (|{|;"")) {
            const Variable* var = tok->variable();
            if (!var->isSmartPointer())
                continue;
            if (var->nameToken() == tok) {
                if (Token::Match(tok, ""%var% (|{"") && tok->next()->astOperand2() &&
                    tok->next()->astOperand2()->str() != "","") {
                    Token* inTok = tok->next()->astOperand2();
                    const std::list<ValueFlow::Value>& values = inTok->values();
                    const bool constValue = inTok->isNumber();
                    valueFlowForwardAssign(inTok, var, values, c...",1,1,lib/valueflow.cpp,"valueFlowSmartPointer:void(TokenList&,ErrorLogger&,Settings&)",<empty>,,false,6159,6232,valueFlowSmartPointer,,,1,"void(TokenList&,ErrorLogger&,Settings&)"
111669154205,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static Library::Container::Yield findIteratorYield(Token* tok, const Token*& ftok, const Settings& settings)
{
    auto yield = astContainerYield(tok, &ftok);
    if (ftok)
        return yield;

    if (!tok->astParent())
        return yield;

    // begin/end free functions
    return astFunctionYield(tok->astParent()->previous(), settings, &ftok);
}",1,1,lib/valueflow.cpp,"findIteratorYield:Library.Container.Yield(Token*,Token*&,Settings&)",<empty>,,false,6234,6245,findIteratorYield,,,1,"Library.Container.Yield(Token*,Token*&,Settings&)"
111669154206,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowIterators(TokenList& tokenlist, const Settings& settings)
{
    for (Token* tok = tokenlist.front(); tok; tok = tok->next()) {
        if (!tok->scope())
            continue;
        if (!tok->scope()->isExecutable())
            continue;
        if (!astIsContainer(tok))
            continue;
        const Token* ftok = nullptr;
        const Library::Container::Yield yield = findIteratorYield(tok, ftok, settings);
        if (!ftok)
            continue;
        if (yield == Library::Container::Yield::START_ITERATOR) {
            ValueFlow::Value v(0);
            v.setKnown();
            v.valueType = ValueFlow::Value::ValueType::ITERATOR_START;
            setTokenValue(const_cast<Token*>(ftok)->next(), std::move(v), settings);
        } else if (yield == Library::Container::Yield::END_ITERATOR) {
            ValueFlow::Value v(0);
            v.setKnown();
            v.valueType = ValueFlow::Value::ValueType::ITERATOR_END;
            setTokenValue(con...",1,1,lib/valueflow.cpp,"valueFlowIterators:void(TokenList&,Settings&)",<empty>,,false,6247,6272,valueFlowIterators,,,1,"void(TokenList&,Settings&)"
111669154207,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
        if (kind && v.valueKind != *kind)
            return true;
        return !v.isIteratorValue();
    }",22,5,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.getIteratorValues:list<ValueFlow.Value>(std.list<ValueFlow.Value>,ValueFlow.Value.ValueKind*).<lambda>86:bool(ValueFlow.Value&)",<empty>,,false,6277,6281,<lambda>86,,,1,bool(ValueFlow.Value&)
111669154208,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static std::list<ValueFlow::Value> getIteratorValues(std::list<ValueFlow::Value> values,
                                                     const ValueFlow::Value::ValueKind* kind = nullptr)
{
    values.remove_if([&](const ValueFlow::Value& v) {
        if (kind && v.valueKind != *kind)
            return true;
        return !v.isIteratorValue();
    });
    return values;
}",1,1,lib/valueflow.cpp,"getIteratorValues:list<ValueFlow.Value>(std.list<ValueFlow.Value>,ValueFlow.Value.ValueKind*)",<empty>,,false,6274,6283,getIteratorValues,,,1,"list<ValueFlow::Value>(std.list<ValueFlow.Value>,ValueFlow.Value.ValueKind*)"
111669154209,METHOD,IteratorConditionHandler,TYPE_DECL,"std::vector<Condition> parse(const Token* tok, const Settings& /*settings*/) const override {
        Condition cond;

        if (Token::Match(tok, ""==|!="")) {
            if (!tok->astOperand1() || !tok->astOperand2())
                return {};

            constexpr ValueFlow::Value::ValueKind kind = ValueFlow::Value::ValueKind::Known;
            std::list<ValueFlow::Value> values = getIteratorValues(tok->astOperand1()->values(), &kind);
            if (!values.empty()) {
                cond.vartok = tok->astOperand2();
            } else {
                values = getIteratorValues(tok->astOperand2()->values(), &kind);
                if (!values.empty())
                    cond.vartok = tok->astOperand1();
            }
            for (ValueFlow::Value& v:values) {
                v.setPossible();
                v.assumeCondition(tok);
            }
            cond.true_values = values;
            cond.false_values = std::move(values);
        }

        return {std::mo...",5,5,lib/valueflow.cpp,"IteratorConditionHandler.parse<const>:vector<Condition>(Token*,Settings&)",<empty>,,false,6286,6311,parse,,,1,"vector<Condition>(Token*,Settings&)"
111669154210,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
            if (!v.isImpossible())
                return true;
            if (!v.condition)
                return true;
            if (v.bound != ValueFlow::Value::Bound::Point)
                return true;
            if (v.isIteratorEndValue() && v.intvalue <= 0)
                return true;
            if (v.isIteratorStartValue() && v.intvalue >= 0)
                return true;
            return false;
        }",26,9,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowIteratorInfer.<lambda>87:bool(ValueFlow.Value&),<empty>,,false,6322,6334,<lambda>87,,,1,bool(ValueFlow.Value&)
111669154211,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowIteratorInfer(TokenList& tokenlist, const Settings& settings)
{
    for (Token* tok = tokenlist.front(); tok; tok = tok->next()) {
        if (!tok->scope())
            continue;
        if (!tok->scope()->isExecutable())
            continue;
        std::list<ValueFlow::Value> values = getIteratorValues(tok->values());
        values.remove_if([&](const ValueFlow::Value& v) {
            if (!v.isImpossible())
                return true;
            if (!v.condition)
                return true;
            if (v.bound != ValueFlow::Value::Bound::Point)
                return true;
            if (v.isIteratorEndValue() && v.intvalue <= 0)
                return true;
            if (v.isIteratorStartValue() && v.intvalue >= 0)
                return true;
            return false;
        });
        for (ValueFlow::Value& v : values) {
            v.setPossible();
            if (v.isIteratorStartValue())
                v.intvalue++;
            if (v.isI...",1,1,lib/valueflow.cpp,"valueFlowIteratorInfer:void(TokenList&,Settings&)",<empty>,,false,6314,6344,valueFlowIteratorInfer,,,1,"void(TokenList&,Settings&)"
111669154212,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static std::vector<ValueFlow::Value> getContainerValues(const Token* tok)
{
    std::vector<ValueFlow::Value> values;
    if (tok) {
        std::copy_if(tok->values().cbegin(),
                     tok->values().cend(),
                     std::back_inserter(values),
                     std::mem_fn(&ValueFlow::Value::isContainerSizeValue));
    }
    return values;
}",1,1,lib/valueflow.cpp,getContainerValues:vector<ValueFlow.Value>(Token*),<empty>,,false,6346,6356,getContainerValues,,,1,vector<ValueFlow::Value>(Token*)
111669154213,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static ValueFlow::Value makeContainerSizeValue(MathLib::bigint s, bool known = true)
{
    ValueFlow::Value value(s);
    value.valueType = ValueFlow::Value::ValueType::CONTAINER_SIZE;
    if (known)
        value.setKnown();
    return value;
}",1,1,lib/valueflow.cpp,"makeContainerSizeValue:ValueFlow.Value(MathLib.bigint,bool)",<empty>,,false,6358,6365,makeContainerSizeValue,,,1,"ValueFlow.Value(MathLib.bigint,bool)"
111669154214,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static std::vector<ValueFlow::Value> makeContainerSizeValue(const Token* tok, bool known = true)
{
    if (const ValueFlow::Value* v = tok->getKnownValue(ValueFlow::Value::ValueType::INT))
        return {makeContainerSizeValue(v->intvalue, known)};
    return {};
}",1,1,lib/valueflow.cpp,"makeContainerSizeValue:vector<ValueFlow.Value>(Token*,bool)",<empty>,,false,6367,6372,makeContainerSizeValue,,,1,"vector<ValueFlow::Value>(Token*,bool)"
111669154215,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static std::vector<ValueFlow::Value> getContainerSizeFromConstructorArgs(const std::vector<const Token*>& args,
                                                                         const Library::Container* container,
                                                                         bool known)
{
    if (astIsIntegral(args[0], false)) { // { count, i } or { count }
        if (args.size() == 1 || (args.size() > 1 && !astIsIntegral(args[1], false)))
            return {makeContainerSizeValue(args[0], known)};
    } else if (astIsContainer(args[0]) && args.size() == 1) { // copy constructor
        return getContainerValues(args[0]);
    } else if (isIteratorPair(args)) {
        std::vector<ValueFlow::Value> result = getContainerValues(args[0]);
        if (!result.empty())
            return result;
        // (ptr, ptr + size)
        if (astIsPointer(args[0]) && args[0]->exprId() != 0) {
            // (ptr, ptr) is empty
            // TODO: Use lifetime values to chec...",1,16,lib/valueflow.cpp,"getContainerSizeFromConstructorArgs:vector<ValueFlow.Value>(std.vector<constToken*>&,Library.Container*,bool)",<empty>,,false,6374,6419,getContainerSizeFromConstructorArgs,,,1,"vector<ValueFlow::Value>(std.vector<constToken*>&,Library.Container*,bool)"
111669154216,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool valueFlowIsSameContainerType(const ValueType& contType, const Token* tok, const Settings& settings)
{
    if (!tok || !tok->valueType() || !tok->valueType()->containerTypeToken)
        return true;

    const ValueType tokType = ValueType::parseDecl(tok->valueType()->containerTypeToken, settings);
    return contType.isTypeEqual(&tokType) || tokType.type == ValueType::Type::UNKNOWN_TYPE;
}",1,1,lib/valueflow.cpp,"valueFlowIsSameContainerType:bool(ValueType&,Token*,Settings&)",<empty>,,false,6421,6428,valueFlowIsSameContainerType,,,1,"bool(ValueType&,Token*,Settings&)"
111669154217,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static std::vector<ValueFlow::Value> getInitListSize(const Token* tok,
                                                     const ValueType* valueType,
                                                     const Settings& settings,
                                                     bool known = true)
{
    std::vector<const Token*> args = getArguments(tok);
    if (args.empty())
        return {makeContainerSizeValue(MathLib::bigint{0}, known)};
    bool initList = tok->str() == ""{"";
    // Try to disambiguate init list from constructor
    if (initList && args.size() < 4) {
        initList = !isIteratorPair(args);
        const Token* containerTypeToken = valueType->containerTypeToken;
        if (valueType->container->stdStringLike) {
            initList = astIsGenericChar(args[0]) && !astIsPointer(args[0]);
        } else if (containerTypeToken) {
            ValueType vt = ValueType::parseDecl(containerTypeToken, settings);
            if (vt.pointer > 0 && astIsPointer(args[...",1,1,lib/valueflow.cpp,"getInitListSize:vector<ValueFlow.Value>(Token*,ValueType*,Settings&,bool)",<empty>,,false,6430,6462,getInitListSize,,,1,"vector<ValueFlow::Value>(Token*,ValueType*,Settings&,bool)"
111669154218,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static std::vector<ValueFlow::Value> getContainerSizeFromConstructor(const Token* tok,
                                                                     const ValueType* valueType,
                                                                     const Settings& settings,
                                                                     bool known = true)
{
    std::vector<const Token*> args = getArguments(tok);
    if (args.empty())
        return {makeContainerSizeValue(MathLib::bigint{0}, known)};
    // Init list in constructor
    if (args.size() == 1 && Token::simpleMatch(args[0], ""{""))
        return getInitListSize(args[0], valueType, settings, known);
    return getContainerSizeFromConstructorArgs(args, valueType->container, known);
}",1,1,lib/valueflow.cpp,"getContainerSizeFromConstructor:vector<ValueFlow.Value>(Token*,ValueType*,Settings&,bool)",<empty>,,false,6464,6476,getContainerSizeFromConstructor,,,1,"vector<ValueFlow::Value>(Token*,ValueType*,Settings&,bool)"
111669154219,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowContainerSetTokValue(const TokenList& tokenlist, ErrorLogger& errorLogger, const Settings& settings, const Token* tok, Token* initList)
{
    ValueFlow::Value value;
    value.valueType = ValueFlow::Value::ValueType::TOK;
    value.tokvalue = initList;
    if (astIsContainerString(tok) && Token::simpleMatch(initList, ""{"") && Token::Match(initList->astOperand2(), ""%str%"")) {
        value.tokvalue = initList->astOperand2();
    }
    value.setKnown();
    Token* start = initList->link() ? initList->link() : initList->next();
    if (tok->variable() && tok->variable()->isConst()) {
        valueFlowForwardConst(start, tok->variable()->scope()->bodyEnd, tok->variable(), {std::move(value)}, settings);
    } else {
        valueFlowForward(start, tok, std::move(value), tokenlist, errorLogger, settings);
    }
}",1,1,lib/valueflow.cpp,"valueFlowContainerSetTokValue:void(TokenList&,ErrorLogger&,Settings&,Token*,Token*)",<empty>,,false,6478,6493,valueFlowContainerSetTokValue,,,1,"void(TokenList&,ErrorLogger&,Settings&,Token*,Token*)"
111669154220,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static const Scope* getFunctionScope(const Scope* scope) {
    while (scope && scope->type != ScopeType::eFunction)
        scope = scope->nestedIn;
    return scope;
}",1,1,lib/valueflow.cpp,getFunctionScope:Scope*(Scope*),<empty>,,false,6495,6499,getFunctionScope,,,1,Scope*(Scope*)
111669154221,METHOD,<empty>,<empty>,"[&](MathLib::bigint size, Token* opTok, const Token* exprTok) -> void {
        if (size == 0)
            return;

        ValueFlow::Value value(size - 1);
        value.valueType = ValueFlow::Value::ValueType::CONTAINER_SIZE;
        value.bound = ValueFlow::Value::Bound::Upper;
        value.setImpossible();
        Token* next = nextAfterAstRightmostLeaf(opTok);
        if (!next)
            next = opTok->next();
        valueFlowForward(next, exprTok, std::move(value), tokenlist, errorLogger, settings);
    }",40,5,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.valueFlowContainerSize.<lambda>88:void(MathLib.bigint,Token*,Token*)",<empty>,,false,6578,6590,<lambda>88,,,1,"void(MathLib.bigint,Token*,Token*)"
111669154222,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowContainerSize(const TokenList& tokenlist,
                                   const SymbolDatabase& symboldatabase,
                                   ErrorLogger& errorLogger,
                                   const Settings& settings,
                                   const std::set<const Scope*>& skippedFunctions)
{
    // declaration
    for (const Variable *var : symboldatabase.variableList()) {
        if (!var)
            continue;
        if (!var->scope() || !var->scope()->bodyEnd || !var->scope()->bodyStart)
            continue;
        if (!var->valueType() || !var->valueType()->container)
            continue;
        if (!astIsContainer(var->nameToken()))
            continue;
        if (skippedFunctions.count(getFunctionScope(var->scope())))
            continue;

        bool known = true;
        MathLib::bigint size = 0;
        const bool nonLocal = !var->isLocal() || var->isPointer() || var->isReference() || var->isStatic();
        bool c...",1,1,lib/valueflow.cpp,"valueFlowContainerSize:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,6501,6682,valueFlowContainerSize,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154223,METHOD,<empty>,<empty>,"[&](const Token* vartok, ValueFlow::Value true_value, ValueFlow::Value false_value) {
            vartok = settings.library.getContainerFromYield(vartok, Library::Container::Yield::SIZE);
            if (!vartok)
                return;
            true_value.valueType = ValueFlow::Value::ValueType::CONTAINER_SIZE;
            false_value.valueType = ValueFlow::Value::ValueType::CONTAINER_SIZE;
            Condition cond;
            cond.true_values.push_back(std::move(true_value));
            cond.false_values.push_back(std::move(false_value));
            cond.vartok = vartok;
            conds.push_back(std::move(cond));
        }",34,9,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ContainerConditionHandler.parse<const>.<lambda>89:void(Token*,ValueFlow.Value,ValueFlow.Value)",<empty>,,false,6688,6699,<lambda>89,,,1,"void(Token*,ValueFlow.Value,ValueFlow.Value)"
111669154224,METHOD,ContainerConditionHandler,TYPE_DECL,"std::vector<Condition> parse(const Token* tok, const Settings& settings) const override
    {
        std::vector<Condition> conds;
        parseCompareEachInt(tok, [&](const Token* vartok, ValueFlow::Value true_value, ValueFlow::Value false_value) {
            vartok = settings.library.getContainerFromYield(vartok, Library::Container::Yield::SIZE);
            if (!vartok)
                return;
            true_value.valueType = ValueFlow::Value::ValueType::CONTAINER_SIZE;
            false_value.valueType = ValueFlow::Value::ValueType::CONTAINER_SIZE;
            Condition cond;
            cond.true_values.push_back(std::move(true_value));
            cond.false_values.push_back(std::move(false_value));
            cond.vartok = vartok;
            conds.push_back(std::move(cond));
        });
        if (!conds.empty())
            return conds;

        const Token* vartok = nullptr;

        // Empty check
        if (tok->str() == ""("") {
            vartok = settings.libra...",5,5,lib/valueflow.cpp,"ContainerConditionHandler.parse<const>:vector<Condition>(Token*,Settings&)",<empty>,,false,6685,6750,parse,,,1,"vector<Condition>(Token*,Settings&)"
111669154225,METHOD,<empty>,<empty>,"[&](const Token* funcTok) -> MathLib::bigint {
        MathLib::bigint sizeValue = -1;
        const Library::AllocFunc* allocFunc = settings.library.getAllocFuncInfo(funcTok);
        if (!allocFunc)
            allocFunc = settings.library.getReallocFuncInfo(funcTok);
        if (!allocFunc || allocFunc->bufferSize == Library::AllocFunc::BufferSize::none)
            return sizeValue;

        const std::vector<const Token*> args = getArguments(funcTok);

        const Token* const arg1 = (args.size() >= allocFunc->bufferSizeArg1) ? args[allocFunc->bufferSizeArg1 - 1] : nullptr;
        const Token* const arg2 = (args.size() >= allocFunc->bufferSizeArg2) ? args[allocFunc->bufferSizeArg2 - 1] : nullptr;

        switch (allocFunc->bufferSize) {
        case Library::AllocFunc::BufferSize::none:
            break;
        case Library::AllocFunc::BufferSize::malloc:
            if (arg1 && arg1->hasKnownIntValue())
                sizeValue = arg1->getKnownIntValue();
            br...",39,5,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowDynamicBufferSize.<lambda>90:bigint(Token*),<empty>,,false,6755,6788,<lambda>90,,,1,bigint(Token*)
111669154226,METHOD,<empty>,<empty>,"[&](const Token* newTok) -> MathLib::bigint {
        MathLib::bigint sizeValue = -1, numElem = -1;

        if (newTok && newTok->astOperand1()) { // number of elements
            const Token* bracTok = nullptr, *typeTok = nullptr;
            if (newTok->astOperand1()->str() == ""["")
                bracTok = newTok->astOperand1();
            else if (Token::Match(newTok->astOperand1(), ""(|{"")) {
                if (newTok->astOperand1()->astOperand1() && newTok->astOperand1()->astOperand1()->str() == ""["")
                    bracTok = newTok->astOperand1()->astOperand1();
                else
                    typeTok = newTok->astOperand1()->astOperand1();
            }
            else
                typeTok = newTok->astOperand1();
            if (bracTok && bracTok->astOperand2() && bracTok->astOperand2()->hasKnownIntValue())
                numElem = bracTok->astOperand2()->getKnownIntValue();
            else if (Token::Match(typeTok, ""%type%""))
                numElem ...",33,5,lib/valueflow.cpp,lib/valueflow.cpp:<global>.valueFlowDynamicBufferSize.<lambda>91:bigint(Token*),<empty>,,false,6790,6822,<lambda>91,,,1,bigint(Token*)
111669154227,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowDynamicBufferSize(const TokenList& tokenlist, const SymbolDatabase& symboldatabase, ErrorLogger& errorLogger, const Settings& settings)
{
    auto getBufferSizeFromAllocFunc = [&](const Token* funcTok) -> MathLib::bigint {
        MathLib::bigint sizeValue = -1;
        const Library::AllocFunc* allocFunc = settings.library.getAllocFuncInfo(funcTok);
        if (!allocFunc)
            allocFunc = settings.library.getReallocFuncInfo(funcTok);
        if (!allocFunc || allocFunc->bufferSize == Library::AllocFunc::BufferSize::none)
            return sizeValue;

        const std::vector<const Token*> args = getArguments(funcTok);

        const Token* const arg1 = (args.size() >= allocFunc->bufferSizeArg1) ? args[allocFunc->bufferSizeArg1 - 1] : nullptr;
        const Token* const arg2 = (args.size() >= allocFunc->bufferSizeArg2) ? args[allocFunc->bufferSizeArg2 - 1] : nullptr;

        switch (allocFunc->bufferSize) {
        case Library::AllocFunc::BufferSize:...",1,1,lib/valueflow.cpp,"valueFlowDynamicBufferSize:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)",<empty>,,false,6753,6853,valueFlowDynamicBufferSize,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)"
111669154228,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static bool getMinMaxValues(const std::string& typestr,
                            const Settings& settings,
                            bool cpp,
                            MathLib::bigint& minvalue,
                            MathLib::bigint& maxvalue)
{
    TokenList typeTokens(&settings);
    std::istringstream istr(typestr + "";"");
    if (!typeTokens.createTokens(istr, cpp ? Standards::Language::CPP : Standards::Language::C))
        return false;
    typeTokens.simplifyPlatformTypes();
    typeTokens.simplifyStdType();
    const ValueType& vt = ValueType::parseDecl(typeTokens.front(), settings);
    return ValueFlow::getMinMaxValues(&vt, settings.platform, minvalue, maxvalue);
}",1,1,lib/valueflow.cpp,"getMinMaxValues:bool(std.string&,Settings&,bool,MathLib.bigint&,MathLib.bigint&)",<empty>,,false,6855,6869,getMinMaxValues,,,1,"bool(std.string&,Settings&,bool,MathLib.bigint&,MathLib.bigint&)"
111669154229,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowSafeFunctions(const TokenList& tokenlist, const SymbolDatabase& symboldatabase, ErrorLogger& errorLogger, const Settings& settings)
{
    for (const Scope *functionScope : symboldatabase.functionScopes) {
        if (!functionScope->bodyStart)
            continue;
        const Function *function = functionScope->function;
        if (!function)
            continue;

        const bool safe = function->isSafe(settings);
        const bool all = safe && settings.platform.type != Platform::Type::Unspecified;

        for (const Variable &arg : function->argumentList) {
            if (!arg.nameToken() || !arg.valueType())
                continue;

            if (arg.valueType()->type == ValueType::Type::CONTAINER) {
                if (!safe)
                    continue;
                std::list<ValueFlow::Value> argValues;
                argValues.emplace_back(0);
                argValues.back().valueType = ValueFlow::Value::ValueType::CONTAINER_SIZE;
   ...",1,1,lib/valueflow.cpp,"valueFlowSafeFunctions:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)",<empty>,,false,6871,6967,valueFlowSafeFunctions,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)"
111669154230,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowUnknownFunctionReturn(TokenList& tokenlist, const Settings& settings)
{
    if (!tokenlist.front())
        return;
    for (Token* tok = tokenlist.front()->next(); tok; tok = tok->next()) {
        if (!tok->astParent() || tok->str() != ""("" || !tok->previous()->isName())
            continue;

        if (const auto* f = settings.library.getAllocFuncInfo(tok->astOperand1())) {
            if (settings.library.returnValueType(tok->astOperand1()).find('*') != std::string::npos) {
                // Allocation function that returns a pointer
                ValueFlow::Value value(0);
                value.setPossible();
                value.errorPath.emplace_back(tok, ""Assuming allocation function fails"");
                if (Library::ismemory(f->groupId))
                    value.unknownFunctionReturn = ValueFlow::Value::UnknownFunctionReturn::outOfMemory;
                else
                    value.unknownFunctionReturn = ValueFlow::Value::UnknownFunctionRe...",1,1,lib/valueflow.cpp,"valueFlowUnknownFunctionReturn:void(TokenList&,Settings&)",<empty>,,false,6969,7012,valueFlowUnknownFunctionReturn,,,1,"void(TokenList&,Settings&)"
111669154231,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static void valueFlowDebug(TokenList& tokenlist, ErrorLogger& errorLogger, const Settings& settings)
{
    if (!settings.debugnormal && !settings.debugwarnings)
        return;
    for (Token* tok = tokenlist.front(); tok; tok = tok->next()) {
        if (tok->getTokenDebug() != TokenDebug::ValueFlow)
            continue;
        if (tok->astParent() && tok->astParent()->getTokenDebug() == TokenDebug::ValueFlow)
            continue;
        for (const ValueFlow::Value& v : tok->values()) {
            std::string msg = ""The value is "" + debugString(v);
            ErrorPath errorPath = v.errorPath;
            errorPath.insert(errorPath.end(), v.debugPath.cbegin(), v.debugPath.cend());
            errorPath.emplace_back(tok, """");
            errorLogger.reportErr({errorPath, &tokenlist, Severity::debug, ""valueFlow"", msg, CWE{0}, Certainty::normal});
        }
    }
}",1,1,lib/valueflow.cpp,"valueFlowDebug:void(TokenList&,ErrorLogger&,Settings&)",<empty>,,false,7014,7031,valueFlowDebug,,,1,"void(TokenList&,ErrorLogger&,Settings&)"
111669154232,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"const ValueFlow::Value *ValueFlow::valueFlowConstantFoldAST(Token *expr, const Settings &settings)
{
    if (expr && expr->values().empty()) {
        valueFlowConstantFoldAST(expr->astOperand1(), settings);
        valueFlowConstantFoldAST(expr->astOperand2(), settings);
        valueFlowSetConstantValue(expr, settings);
    }
    return expr && expr->hasKnownValue() ? &expr->values().front() : nullptr;
}",1,1,lib/valueflow.cpp,"ValueFlow.valueFlowConstantFoldAST:ValueFlow.Value*(Token*,Settings&)",<empty>,,false,7033,7041,valueFlowConstantFoldAST,,,1,"ValueFlow.Value*(Token*,Settings&)"
111669154233,METHOD,ValueFlowState,TYPE_DECL,"explicit ValueFlowState(TokenList& tokenlist,
                            SymbolDatabase& symboldatabase,
                            ErrorLogger& errorLogger,
                            const Settings& settings)
        : tokenlist(tokenlist), symboldatabase(symboldatabase), errorLogger(errorLogger), settings(settings)
    {}",5,6,lib/valueflow.cpp,"ValueFlowState.ValueFlowState:ANY(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)",<empty>,,false,7044,7049,ValueFlowState,,,1,"ValueFlowState.ValueFlowState:ANY(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&)"
111669154234,METHOD,ValueFlowPass,TYPE_DECL,ValueFlowPass() = default;,5,30,lib/valueflow.cpp,ValueFlowPass.ValueFlowPass:ANY(),<empty>,,false,7059,7059,ValueFlowPass,,,1,ANY()
111669154235,METHOD,ValueFlowPass,TYPE_DECL,ValueFlowPass(const ValueFlowPass&) = default;,5,50,lib/valueflow.cpp,ValueFlowPass.ValueFlowPass:ANY(ValueFlowPass&),<empty>,,false,7060,7060,ValueFlowPass,,,2,ANY(ValueFlowPass&)
111669154236,METHOD,ValueFlowPass,TYPE_DECL,virtual ~ValueFlowPass() noexcept = default;,5,48,lib/valueflow.cpp,ValueFlowPass.~ValueFlowPass:ANY(),<empty>,,false,7067,7067,~ValueFlowPass,,,3,ANY()
111669154237,METHOD,<empty>,<empty>,"[&](const ValuePtr<ValueFlowPass>& pass) {
            return run(pass);
        }",58,9,lib/valueflow.cpp,lib/valueflow.cpp:<global>.ValueFlowPassRunner.run_once<const>.<lambda>92:bool(ValuePtr<ValueFlowPass>&),<empty>,,false,7082,7084,<lambda>92,,,1,bool(ValuePtr<ValueFlowPass>&)
111669154238,METHOD,<empty>,<empty>,"[&](const ValuePtr<ValueFlowPass>& pass) {
                return run(pass);
            }",59,13,lib/valueflow.cpp,lib/valueflow.cpp:<global>.ValueFlowPassRunner.run<const>.<lambda>93:bool(ValuePtr<ValueFlowPass>&),<empty>,,false,7093,7095,<lambda>93,,,1,bool(ValuePtr<ValueFlowPass>&)
111669154239,METHOD,ValueFlowPassRunner,TYPE_DECL,"explicit ValueFlowPassRunner(ValueFlowState state, TimerResultsIntf* timerResults = nullptr)
        : state(std::move(state)), stop(TimePoint::max()), timerResults(timerResults)
    {
        setSkippedFunctions();
        setStopTime();
    }",5,5,lib/valueflow.cpp,"ValueFlowPassRunner.ValueFlowPassRunner:ANY(ValueFlowState,TimerResultsIntf*)",<empty>,,false,7073,7078,ValueFlowPassRunner,,,3,"ValueFlowPassRunner.ValueFlowPassRunner:ANY(ValueFlowState,TimerResultsIntf*)(ValueFlowState,TimerResultsIntf*)"
111669154240,METHOD,ValueFlowPassRunner,TYPE_DECL,"bool run_once(std::initializer_list<ValuePtr<ValueFlowPass>> passes) const
    {
        return std::any_of(passes.begin(), passes.end(), [&](const ValuePtr<ValueFlowPass>& pass) {
            return run(pass);
        });
    }",5,5,lib/valueflow.cpp,ValueFlowPassRunner.run_once<const>:bool(std.initializer_list<ValuePtr<ValueFlowPass>>),<empty>,,false,7080,7085,run_once,,,4,bool(std.initializer_list<ValuePtr<ValueFlowPass>>)
111669154241,METHOD,ValueFlowPassRunner,TYPE_DECL,"bool run(std::initializer_list<ValuePtr<ValueFlowPass>> passes) const
    {
        std::size_t values = 0;
        std::size_t n = state.settings.vfOptions.maxIterations;
        while (n > 0 && values != getTotalValues()) {
            values = getTotalValues();
            if (std::any_of(passes.begin(), passes.end(), [&](const ValuePtr<ValueFlowPass>& pass) {
                return run(pass);
            }))
                return true;
            --n;
        }
        if (state.settings.debugwarnings) {
            if (n == 0 && values != getTotalValues()) {
                ErrorMessage::FileLocation loc(state.tokenlist.getFiles()[0], 0, 0);
                ErrorMessage errmsg({std::move(loc)},
                                    """",
                                    Severity::debug,
                                    ""ValueFlow maximum iterations exceeded"",
                                    ""valueFlowMaxIterations"",
                                    Certainty::normal)...",5,5,lib/valueflow.cpp,ValueFlowPassRunner.run<const>:bool(std.initializer_list<ValuePtr<ValueFlowPass>>),<empty>,,false,7087,7112,run,,,5,bool(std.initializer_list<ValuePtr<ValueFlowPass>>)
111669154242,METHOD,ValueFlowPassRunner,TYPE_DECL,"bool run(const ValuePtr<ValueFlowPass>& pass) const
    {
        auto start = Clock::now();
        if (start > stop) {
            // TODO: add bailout message
            return true;
        }
        if (!state.tokenlist.isCPP() && pass->cpp())
            return false;
        if (timerResults) {
            Timer t(pass->name(), state.settings.showtime, timerResults);
            pass->run(state);
        } else {
            pass->run(state);
        }
        return false;
    }",5,5,lib/valueflow.cpp,ValueFlowPassRunner.run<const>:bool(ValuePtr<ValueFlowPass>&),<empty>,,false,7114,7130,run,,,6,bool(ValuePtr<ValueFlowPass>&)
111669154243,METHOD,ValueFlowPassRunner,TYPE_DECL,"std::size_t getTotalValues() const
    {
        std::size_t n = 1;
        for (Token* tok = state.tokenlist.front(); tok; tok = tok->next())
            n += tok->values().size();
        return n;
    }",5,5,lib/valueflow.cpp,ValueFlowPassRunner.getTotalValues<const>:size_t(),<empty>,,false,7132,7138,getTotalValues,,,7,size_t()
111669154244,METHOD,ValueFlowPassRunner,TYPE_DECL,"void setSkippedFunctions()
    {
        if (state.settings.vfOptions.maxIfCount > 0) {
            for (const Scope* functionScope : state.symboldatabase.functionScopes) {
                int countIfScopes = 0;
                std::vector<const Scope*> scopes{functionScope};
                while (!scopes.empty()) {
                    const Scope* s = scopes.back();
                    scopes.pop_back();
                    for (const Scope* s2 : s->nestedList) {
                        scopes.emplace_back(s2);
                        if (s2->type == ScopeType::eIf)
                            ++countIfScopes;
                    }
                }
                if (countIfScopes > state.settings.vfOptions.maxIfCount) {
                    state.skippedFunctions.emplace(functionScope);

                    if (state.settings.severity.isEnabled(Severity::information)) {
                        const std::string& functionName = functionScope->className;
                        st...",5,5,lib/valueflow.cpp,ValueFlowPassRunner.setSkippedFunctions:void(),<empty>,,false,7140,7175,setSkippedFunctions,,,8,void()
111669154245,METHOD,ValueFlowPassRunner,TYPE_DECL,"void setStopTime()
    {
        if (state.settings.vfOptions.maxTime >= 0)
            stop = Clock::now() + std::chrono::seconds{state.settings.vfOptions.maxTime};
    }",5,5,lib/valueflow.cpp,ValueFlowPassRunner.setStopTime:void(),<empty>,,false,7177,7181,setStopTime,,,9,void()
111669154246,METHOD,ValueFlowPassAdaptor,TYPE_DECL,"ValueFlowPassAdaptor(const char* pname, bool pcpp, F prun) : ValueFlowPass(), mName(pname), mCPP(pcpp), mRun(prun) {}",5,121,lib/valueflow.cpp,"ValueFlowPassAdaptor.ValueFlowPassAdaptor:ANY(char*,bool,F)",<empty>,,false,7193,7193,ValueFlowPassAdaptor,,,4,"ValueFlowPassAdaptor.ValueFlowPassAdaptor:ANY(char*,bool,F)(char*,bool,F)"
111669154247,METHOD,ValueFlowPassAdaptor,TYPE_DECL,"const char* name() const override {
        return mName;
    }",5,5,lib/valueflow.cpp,ValueFlowPassAdaptor.name<const>:char*(),<empty>,,false,7194,7196,name,,,5,char*()
111669154248,METHOD,ValueFlowPassAdaptor,TYPE_DECL,"void run(const ValueFlowState& state) const override
    {
        mRun(state.tokenlist, state.symboldatabase, state.errorLogger, state.settings, state.skippedFunctions);
    }",5,5,lib/valueflow.cpp,ValueFlowPassAdaptor.run<const>:void(ValueFlowState&),<empty>,,false,7197,7200,run,,,6,void(ValueFlowState&)
111669154249,METHOD,ValueFlowPassAdaptor,TYPE_DECL,"bool cpp() const override {
        return mCPP;
    }",5,5,lib/valueflow.cpp,ValueFlowPassAdaptor.cpp<const>:bool(),<empty>,,false,7201,7203,cpp,,,7,bool()
111669154250,METHOD,<empty>,<empty>,<empty>,1,,lib/valueflow.cpp,ValueFlowPassAdaptor.<clinit>,<empty>,,false,7189,,<clinit>,,,8,
111669154251,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static ValueFlowPassAdaptor<F> makeValueFlowPassAdaptor(const char* name, bool cpp, F run)
{
    return {name, cpp, run};
}",1,1,lib/valueflow.cpp,"makeValueFlowPassAdaptor:ValueFlowPassAdaptor<F>(char*,bool,F)",<empty>,,false,7207,7210,makeValueFlowPassAdaptor,,,1,"ValueFlowPassAdaptor<F>(char*,bool,F)"
111669154252,METHOD,<empty>,<empty>,"VFA(valueFlowEnumValue(symboldatabase, settings))",9,57,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>94:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7254,7254,<lambda>94,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154253,METHOD,<empty>,<empty>,"VFA(valueFlowNumber(tokenlist, settings))",9,49,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>95:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7255,7255,<lambda>95,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154254,METHOD,<empty>,<empty>,"VFA(valueFlowString(tokenlist, settings))",9,49,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>96:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7256,7256,<lambda>96,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154255,METHOD,<empty>,<empty>,"VFA(valueFlowArray(tokenlist, settings))",9,48,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>97:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7257,7257,<lambda>97,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154256,METHOD,<empty>,<empty>,"VFA(valueFlowUnknownFunctionReturn(tokenlist, settings))",9,64,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>98:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7258,7258,<lambda>98,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154257,METHOD,<empty>,<empty>,"VFA(valueFlowGlobalConstVar(tokenlist, settings))",9,57,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>99:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7259,7259,<lambda>99,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154258,METHOD,<empty>,<empty>,"VFA(valueFlowEnumValue(symboldatabase, settings))",9,57,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>100:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7260,7260,<lambda>100,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154259,METHOD,<empty>,<empty>,"VFA(valueFlowGlobalStaticVar(tokenlist, settings))",9,58,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>101:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7261,7261,<lambda>101,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154260,METHOD,<empty>,<empty>,"VFA(valueFlowPointerAlias(tokenlist, settings))",9,55,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>102:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7262,7262,<lambda>102,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154261,METHOD,<empty>,<empty>,"VFA(valueFlowLifetime(tokenlist, errorLogger, settings))",9,64,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>103:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7263,7263,<lambda>103,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154262,METHOD,<empty>,<empty>,"VFA(valueFlowSymbolic(tokenlist, symboldatabase, errorLogger, settings))",9,80,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>104:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7264,7264,<lambda>104,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154263,METHOD,<empty>,<empty>,"VFA(valueFlowBitAnd(tokenlist, settings))",9,49,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>105:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7265,7265,<lambda>105,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154264,METHOD,<empty>,<empty>,"VFA(valueFlowSameExpressions(tokenlist, settings))",9,58,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>106:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7266,7266,<lambda>106,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154265,METHOD,<empty>,<empty>,"VFA(valueFlowConditionExpressions(tokenlist, symboldatabase, errorLogger, settings))",9,92,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>107:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7267,7267,<lambda>107,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154266,METHOD,<empty>,<empty>,"VFA(valueFlowImpossibleValues(tokenlist, settings))",9,59,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>108:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7271,7271,<lambda>108,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154267,METHOD,<empty>,<empty>,"VFA(valueFlowSymbolicOperators(symboldatabase, settings))",9,65,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>109:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7272,7272,<lambda>109,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154268,METHOD,<empty>,<empty>,"VFA(valueFlowCondition(SymbolicConditionHandler{}, tokenlist, symboldatabase, errorLogger, settings, skippedFunctions))",9,127,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>110:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7273,7273,<lambda>110,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154269,METHOD,<empty>,<empty>,"VFA(valueFlowSymbolicInfer(symboldatabase, settings))",9,61,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>111:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7274,7274,<lambda>111,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154270,METHOD,<empty>,<empty>,"VFA(valueFlowArrayBool(tokenlist, settings))",9,52,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>112:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7275,7275,<lambda>112,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154271,METHOD,<empty>,<empty>,"VFA(valueFlowArrayElement(tokenlist, settings))",9,55,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>113:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7276,7276,<lambda>113,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154272,METHOD,<empty>,<empty>,"VFA(valueFlowRightShift(tokenlist, settings))",9,53,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>114:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7277,7277,<lambda>114,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154273,METHOD,<empty>,<empty>,"VFA_CPP(
            valueFlowCondition(ContainerConditionHandler{}, tokenlist, symboldatabase, errorLogger, settings, skippedFunctions))",9,128,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>115:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7278,7279,<lambda>115,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154274,METHOD,<empty>,<empty>,"VFA(valueFlowAfterAssign(tokenlist, symboldatabase, errorLogger, settings, skippedFunctions))",9,101,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>116:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7280,7280,<lambda>116,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154275,METHOD,<empty>,<empty>,"VFA_CPP(valueFlowAfterSwap(tokenlist, symboldatabase, errorLogger, settings))",9,85,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>117:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7281,7281,<lambda>117,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154276,METHOD,<empty>,<empty>,"VFA(valueFlowCondition(SimpleConditionHandler{}, tokenlist, symboldatabase, errorLogger, settings, skippedFunctions))",9,125,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>118:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7282,7282,<lambda>118,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154277,METHOD,<empty>,<empty>,"VFA(valueFlowInferCondition(tokenlist, settings))",9,57,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>119:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7283,7283,<lambda>119,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154278,METHOD,<empty>,<empty>,"VFA(valueFlowSwitchVariable(tokenlist, symboldatabase, errorLogger, settings))",9,86,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>120:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7284,7284,<lambda>120,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154279,METHOD,<empty>,<empty>,"VFA(valueFlowForLoop(tokenlist, symboldatabase, errorLogger, settings))",9,79,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>121:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7285,7285,<lambda>121,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154280,METHOD,<empty>,<empty>,"VFA(valueFlowSubFunction(tokenlist, symboldatabase, errorLogger, settings))",9,83,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>122:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7286,7286,<lambda>122,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154281,METHOD,<empty>,<empty>,"VFA(valueFlowFunctionReturn(tokenlist, errorLogger, settings))",9,70,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>123:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7287,7287,<lambda>123,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154282,METHOD,<empty>,<empty>,"VFA(valueFlowLifetime(tokenlist, errorLogger, settings))",9,64,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>124:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7288,7288,<lambda>124,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154283,METHOD,<empty>,<empty>,"VFA(valueFlowFunctionDefaultParameter(tokenlist, symboldatabase, errorLogger, settings))",9,96,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>125:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7289,7289,<lambda>125,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154284,METHOD,<empty>,<empty>,"VFA(valueFlowUninit(tokenlist, errorLogger, settings))",9,62,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>126:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7290,7290,<lambda>126,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154285,METHOD,<empty>,<empty>,"VFA_CPP(valueFlowAfterMove(tokenlist, symboldatabase, errorLogger, settings))",9,85,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>127:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7291,7291,<lambda>127,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154286,METHOD,<empty>,<empty>,"VFA_CPP(valueFlowSmartPointer(tokenlist, errorLogger, settings))",9,72,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>128:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7292,7292,<lambda>128,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154287,METHOD,<empty>,<empty>,"VFA_CPP(valueFlowIterators(tokenlist, settings))",9,56,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>129:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7293,7293,<lambda>129,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154288,METHOD,<empty>,<empty>,"VFA_CPP(
            valueFlowCondition(IteratorConditionHandler{}, tokenlist, symboldatabase, errorLogger, settings, skippedFunctions))",9,127,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>130:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7294,7295,<lambda>130,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154289,METHOD,<empty>,<empty>,"VFA_CPP(valueFlowIteratorInfer(tokenlist, settings))",9,60,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>131:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7296,7296,<lambda>131,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154290,METHOD,<empty>,<empty>,"VFA_CPP(valueFlowContainerSize(tokenlist, symboldatabase, errorLogger, settings, skippedFunctions))",9,107,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>132:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7297,7297,<lambda>132,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154291,METHOD,<empty>,<empty>,"VFA(valueFlowSafeFunctions(tokenlist, symboldatabase, errorLogger, settings))",9,85,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>133:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7298,7298,<lambda>133,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154292,METHOD,<empty>,<empty>,"VFA(valueFlowDynamicBufferSize(tokenlist, symboldatabase, errorLogger, settings))",9,89,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>134:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7302,7302,<lambda>134,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154293,METHOD,<empty>,<empty>,"VFA(valueFlowDebug(tokenlist, errorLogger, settings))",9,61,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.ValueFlow.setValues.<lambda>135:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)",<empty>,,false,7303,7303,<lambda>135,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,std.set<constScope*>&)"
111669154294,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"void ValueFlow::setValues(TokenList& tokenlist,
                          SymbolDatabase& symboldatabase,
                          ErrorLogger& errorLogger,
                          const Settings& settings,
                          TimerResultsIntf* timerResults)
{
    for (Token* tok = tokenlist.front(); tok; tok = tok->next())
        tok->clearValueFlow();

    // commas in init..
    for (Token* tok = tokenlist.front(); tok; tok = tok->next()) {
        if (tok->str() != ""{"" || !tok->astOperand1())
            continue;
        for (Token* tok2 = tok->next(); tok2 != tok->link(); tok2 = tok2->next()) {
            if (tok2->link() && Token::Match(tok2, ""[{[(<]""))
                tok2 = tok2->link();
            else if (tok2->str() == "","")
                tok2->isInitComma(true);
        }
    }

    ValueFlowPassRunner runner{ValueFlowState{tokenlist, symboldatabase, errorLogger, settings}, timerResults};
    runner.run_once({
        VFA(valueFlowEnumValue(symboldatabase, ...",1,8,lib/valueflow.cpp,"ValueFlow.setValues:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,TimerResultsIntf*)",<empty>,,false,7231,7305,setValues,,,1,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,TimerResultsIntf*)"
111669154295,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"std::string ValueFlow::eitherTheConditionIsRedundant(const Token *condition)
{
    if (!condition)
        return ""Either the condition is redundant"";
    if (condition->str() == ""case"") {
        std::string expr;
        for (const Token *tok = condition; tok && tok->str() != "":""; tok = tok->next()) {
            expr += tok->str();
            if (Token::Match(tok, ""%name%|%num% %name%|%num%""))
                expr += ' ';
        }
        return ""Either the switch case '"" + expr + ""' is redundant"";
    }
    return ""Either the condition '"" + condition->expressionString() + ""' is redundant"";
}",1,1,lib/valueflow.cpp,ValueFlow.eitherTheConditionIsRedundant:string(Token*),<empty>,,false,7307,7321,eitherTheConditionIsRedundant,,,1,string(Token*)
111669154296,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"const ValueFlow::Value* ValueFlow::findValue(const std::list<ValueFlow::Value>& values,
                                             const Settings& settings,
                                             const std::function<bool(const ValueFlow::Value&)> &pred)
{
    const ValueFlow::Value* ret = nullptr;
    for (const ValueFlow::Value& v : values) {
        if (pred(v)) {
            if (!ret || ret->isInconclusive() || (ret->condition && !v.isInconclusive()))
                ret = &v;
            if (!ret->isInconclusive() && !ret->condition)
                break;
        }
    }
    if (ret) {
        if (ret->isInconclusive() && !settings.certainty.isEnabled(Certainty::inconclusive))
            return nullptr;
        if (ret->condition && !settings.severity.isEnabled(Severity::warning))
            return nullptr;
    }
    return ret;
}",1,1,lib/valueflow.cpp,"ValueFlow.findValue:ValueFlow.Value*(std.list<ValueFlow.Value>&,Settings&,std.function<bool(constValueFlow.Value&)>&)",<empty>,,false,7323,7343,findValue,,,1,"ValueFlow.Value*(std.list<ValueFlow.Value>&,Settings&,std.function<bool(constValueFlow.Value&)>&)"
111669154297,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
        return v.isSymbolicValue() && v.isPossible() && v.bound == ValueFlow::Value::Bound::Upper;
    }",77,5,lib/valueflow.cpp,"lib/valueflow.cpp:<global>.isOutOfBoundsImpl:vector<ValueFlow.Value>(ValueFlow.Value&,Token*,bool).<lambda>136:bool(ValueFlow.Value&)",<empty>,,false,7362,7364,<lambda>136,,,1,bool(ValueFlow.Value&)
111669154298,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"static std::vector<ValueFlow::Value> isOutOfBoundsImpl(const ValueFlow::Value& size,
                                                       const Token* indexTok,
                                                       bool condition)
{
    if (!indexTok)
        return {};
    const ValueFlow::Value* indexValue = indexTok->getMaxValue(condition, size.path);
    if (!indexValue)
        return {};
    if (indexValue->intvalue >= size.intvalue)
        return {*indexValue};
    if (!condition)
        return {};
    // TODO: Use a better way to decide if the variable in unconstrained
    if (!indexTok->variable() || !indexTok->variable()->isArgument())
        return {};
    if (std::any_of(indexTok->values().cbegin(), indexTok->values().cend(), [&](const ValueFlow::Value& v) {
        return v.isSymbolicValue() && v.isPossible() && v.bound == ValueFlow::Value::Bound::Upper;
    }))
        return {};
    if (indexValue->bound != ValueFlow::Value::Bound::Lower)
        return {};
    ...",1,1,lib/valueflow.cpp,"isOutOfBoundsImpl:vector<ValueFlow.Value>(ValueFlow.Value&,Token*,bool)",<empty>,,false,7346,7381,isOutOfBoundsImpl,,,1,"vector<ValueFlow::Value>(ValueFlow.Value&,Token*,bool)"
111669154299,METHOD,lib/valueflow.cpp:<global>,TYPE_DECL,"std::vector<ValueFlow::Value> ValueFlow::isOutOfBounds(const Value& size, const Token* indexTok, bool possible)
{
    ValueFlow::Value inBoundsValue = inferCondition(""<"", indexTok, size.intvalue);
    if (inBoundsValue.isKnown() && inBoundsValue.intvalue != 0)
        return {};
    std::vector<ValueFlow::Value> result = isOutOfBoundsImpl(size, indexTok, false);
    if (!result.empty())
        return result;
    if (!possible)
        return result;
    return isOutOfBoundsImpl(size, indexTok, true);
}",1,1,lib/valueflow.cpp,"ValueFlow.isOutOfBounds:vector<ValueFlow.Value>(ValueFlow.Value&,Token*,bool)",<empty>,,false,7384,7395,isOutOfBounds,,,1,"vector<ValueFlow::Value>(ValueFlow.Value&,Token*,bool)"
111669154300,METHOD,lib/valueflow.h:<global>,TYPE_DECL,<global>,1,1,lib/valueflow.h,lib/valueflow.h:<global>,<empty>,,false,1,137,<global>,,,1,
111669154301,METHOD,lib/valueptr.h:<global>,TYPE_DECL,<global>,1,1,lib/valueptr.h,lib/valueptr.h:<global>,<empty>,,false,1,99,<global>,,,1,
111669154302,METHOD,lib/version.h:<global>,TYPE_DECL,<global>,1,4,lib/version.h,lib/version.h:<global>,<empty>,,false,1,41,<global>,,,1,
111669154303,METHOD,ValueFlowAnalyzer.ConditionState,TYPE_DECL,"bool isUnknownDependent() const {
            return unknown && dependent;
        }",9,9,lib/vf_analyzers.cpp,ValueFlowAnalyzer.ConditionState.isUnknownDependent<const>:bool(),<empty>,,false,100,102,isUnknownDependent,,,3,bool()
111669154304,METHOD,<empty>,<empty>,<empty>,5,,lib/vf_analyzers.cpp,ValueFlowAnalyzer.ConditionState.<clinit>,<empty>,,false,96,,<clinit>,,,4,
111669154305,METHOD,<empty>,<empty>,"[&](const Token* arg) {
                ConditionState cs = analyzeCondition(arg, depth - 1);
                return cs.dependent;
            }",72,13,lib/vf_analyzers.cpp,lib/vf_analyzers.cpp:<global>.ValueFlowAnalyzer.analyzeCondition<const>.<lambda>0:bool(Token*),<empty>,,false,146,149,<lambda>0,,,1,bool(Token*)
111669154306,METHOD,<empty>,<empty>,"[&](const Token* child) {
                        return tok->exprId() == child->exprId();
                    }",42,21,lib/vf_analyzers.cpp,lib/vf_analyzers.cpp:<global>.ValueFlowAnalyzer.isWritable<const>.<lambda>1:bool(Token*),<empty>,,false,293,295,<lambda>1,,,1,bool(Token*)
111669154307,METHOD,<empty>,<empty>,"[&](const Token* child) {
            return match(child);
        }",33,9,lib/vf_analyzers.cpp,lib/vf_analyzers.cpp:<global>.ValueFlowAnalyzer.findMatch<const>.<lambda>2:bool(Token*),<empty>,,false,499,501,<lambda>2,,,1,bool(Token*)
111669154308,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& v) {
            return v.isSymbolicValue() && currValue->equalValue(v);
        }",71,9,lib/vf_analyzers.cpp,lib/vf_analyzers.cpp:<global>.ValueFlowAnalyzer.isSameSymbolicValue<const>.<lambda>3:bool(ValueFlow.Value&),<empty>,,false,515,517,<lambda>3,,,1,bool(ValueFlow.Value&)
111669154309,METHOD,<empty>,<empty>,"[&](const ReferenceToken& ref) {
            return tok == ref.token;
        }",54,9,lib/vf_analyzers.cpp,lib/vf_analyzers.cpp:<global>.ValueFlowAnalyzer.analyze<const>.<lambda>4:bool(ReferenceToken&),<empty>,,false,635,637,<lambda>4,,,1,bool(ReferenceToken&)
111669154310,METHOD,<empty>,<empty>,"[&] {
            return ProgramMemory{getProgramState()};
        }",33,9,lib/vf_analyzers.cpp,lib/vf_analyzers.cpp:<global>.ValueFlowAnalyzer.evaluateInt<const>:vector<MathLib.bigint>(Token*).<lambda>5:ProgramMemory(),<empty>,,false,681,683,<lambda>5,,,1,ProgramMemory()
111669154311,METHOD,<empty>,<empty>,"[&] {
                return pms.get(tok, ctx, getProgramState());
            }",37,13,lib/vf_analyzers.cpp,"lib/vf_analyzers.cpp:<global>.ValueFlowAnalyzer.evaluate<const>:vector<MathLib.bigint>(Analyzer.Evaluate,Token*,Token*).<lambda>6:ProgramMemory()",<empty>,,false,689,691,<lambda>6,,,1,ProgramMemory()
111669154312,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
                return v.isKnown() && v.isContainerSizeValue();
            }",91,13,lib/vf_analyzers.cpp,"lib/vf_analyzers.cpp:<global>.ValueFlowAnalyzer.evaluate<const>:vector<MathLib.bigint>(Analyzer.Evaluate,Token*,Token*).<lambda>7:bool(ValueFlow.Value&)",<empty>,,false,694,696,<lambda>7,,,1,bool(ValueFlow.Value&)
111669154313,METHOD,ValueFlowAnalyzer,TYPE_DECL,"explicit ValueFlowAnalyzer(const Settings& s) : settings(s), pms(settings) {}",5,81,lib/vf_analyzers.cpp,ValueFlowAnalyzer.ValueFlowAnalyzer:ANY(Settings&),<empty>,,false,54,54,ValueFlowAnalyzer,,,3,ValueFlowAnalyzer.ValueFlowAnalyzer:ANY(Settings&)(Settings&)
111669154314,METHOD,ValueFlowAnalyzer,TYPE_DECL,"virtual bool internalMatch(const Token* /*tok*/) const {
        return false;
    }",5,5,lib/vf_analyzers.cpp,ValueFlowAnalyzer.internalMatch<const>:bool(Token*),<empty>,,false,65,67,internalMatch,,,4,bool(Token*)
111669154315,METHOD,ValueFlowAnalyzer,TYPE_DECL,"virtual int getIndirect(const Token* tok) const {
        const ValueFlow::Value* value = getValue(tok);
        if (value)
            return value->indirect;
        return 0;
    }",5,5,lib/vf_analyzers.cpp,ValueFlowAnalyzer.getIndirect<const>:int(Token*),<empty>,,false,75,80,getIndirect,,,6,int(Token*)
111669154316,METHOD,ValueFlowAnalyzer,TYPE_DECL,"virtual bool isGlobal() const {
        return false;
    }",5,5,lib/vf_analyzers.cpp,ValueFlowAnalyzer.isGlobal<const>:bool(),<empty>,,false,82,84,isGlobal,,,7,bool()
111669154317,METHOD,ValueFlowAnalyzer,TYPE_DECL,"virtual bool dependsOnThis() const {
        return false;
    }",5,5,lib/vf_analyzers.cpp,ValueFlowAnalyzer.dependsOnThis<const>:bool(),<empty>,,false,85,87,dependsOnThis,,,8,bool()
111669154318,METHOD,ValueFlowAnalyzer,TYPE_DECL,"virtual bool isVariable() const {
        return false;
    }",5,5,lib/vf_analyzers.cpp,ValueFlowAnalyzer.isVariable<const>:bool(),<empty>,,false,88,90,isVariable,,,9,bool()
111669154319,METHOD,ValueFlowAnalyzer,TYPE_DECL,"const Settings& getSettings() const {
        return settings;
    }",5,5,lib/vf_analyzers.cpp,ValueFlowAnalyzer.getSettings<const>:Settings&(),<empty>,,false,92,94,getSettings,,,10,Settings&()
111669154320,METHOD,ValueFlowAnalyzer,TYPE_DECL,"ConditionState analyzeCondition(const Token* tok, int depth = 20) const
    {
        ConditionState result;
        if (!tok)
            return result;
        if (depth < 0)
            return result;
        depth--;
        if (analyze(tok, Direction::Forward).isRead()) {
            result.dependent = true;
            result.unknown = false;
            return result;
        }
        if (tok->hasKnownIntValue() || tok->isLiteral()) {
            result.dependent = false;
            result.unknown = false;
            return result;
        }
        if (Token::Match(tok, ""%cop%"")) {
            if (isLikelyStream(tok->astOperand1())) {
                result.dependent = false;
                return result;
            }
            ConditionState lhs = analyzeCondition(tok->astOperand1(), depth - 1);
            if (lhs.isUnknownDependent())
                return lhs;
            ConditionState rhs = analyzeCondition(tok->astOperand2(), depth - 1);
            if (rhs.is...",5,27,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.analyzeCondition<const>:ValueFlowAnalyzer.ConditionState(Token*,int)",<empty>,,false,105,173,analyzeCondition,,,12,"ValueFlowAnalyzer.ConditionState(Token*,int)"
111669154321,METHOD,ValueFlowAnalyzer,TYPE_DECL,"static ValueFlow::Value::MoveKind isMoveOrForward(const Token* tok)
    {
        if (!tok)
            return ValueFlow::Value::MoveKind::NonMovedVariable;
        const Token* parent = tok->astParent();
        if (!Token::simpleMatch(parent, ""(""))
            return ValueFlow::Value::MoveKind::NonMovedVariable;
        const Token* ftok = parent->astOperand1();
        if (!ftok)
            return ValueFlow::Value::MoveKind::NonMovedVariable;
        if (Token::simpleMatch(ftok->astOperand1(), ""std :: move""))
            return ValueFlow::Value::MoveKind::MovedVariable;
        if (Token::simpleMatch(ftok->astOperand1(), ""std :: forward""))
            return ValueFlow::Value::MoveKind::ForwardedVariable;
        // TODO: Check for cast
        return ValueFlow::Value::MoveKind::NonMovedVariable;
    }",5,5,lib/vf_analyzers.cpp,ValueFlowAnalyzer.isMoveOrForward:ValueFlow.Value.MoveKind(Token*),<empty>,,false,175,191,isMoveOrForward,,,13,ValueFlow.Value.MoveKind(Token*)
111669154322,METHOD,ValueFlowAnalyzer,TYPE_DECL,"virtual Action isModified(const Token* tok) const {
        const Action read = Action::Read;
        const ValueFlow::Value* value = getValue(tok);
        if (value) {
            // Moving a moved value won't change the moved value
            if (value->isMovedValue() && isMoveOrForward(tok) != ValueFlow::Value::MoveKind::NonMovedVariable)
                return read;
            // Inserting elements to container won't change the lifetime
            if (astIsContainer(tok) && value->isLifetimeValue() &&
                contains({Library::Container::Action::PUSH,
                          Library::Container::Action::INSERT,
                          Library::Container::Action::APPEND,
                          Library::Container::Action::CHANGE_INTERNAL},
                         astContainerAction(tok)))
                return read;
        }
        bool inconclusive = false;
        if (isVariableChangedByFunctionCall(tok, getIndirect(tok), getSettings(), &inconclusive))
   ...",5,5,lib/vf_analyzers.cpp,ValueFlowAnalyzer.isModified<const>:Analyzer.Action(Token*),<empty>,,false,193,227,isModified,,,14,Analyzer.Action(Token*)
111669154323,METHOD,ValueFlowAnalyzer,TYPE_DECL,"virtual Action isAliasModified(const Token* tok, int indirect = -1) const {
        // Lambda function call
        if (Token::Match(tok, ""%var% (""))
            // TODO: Check if modified in the lambda function
            return Action::Invalid;
        if (indirect == -1) {
            indirect = 0;
            if (const ValueType* vt = tok->valueType()) {
                indirect = vt->pointer;
                if (vt->type == ValueType::ITERATOR)
                    ++indirect;
                const Token* tok2 = tok;
                while (Token::simpleMatch(tok2->astParent(), ""["")) {
                    tok2 = tok2->astParent();
                    --indirect;
                }
                indirect = std::max(indirect, 0);
            }
        }
        for (int i = 0; i <= indirect; ++i)
            if (isVariableChanged(tok, i, getSettings()))
                return Action::Invalid;
        return Action::None;
    }",5,5,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.isAliasModified<const>:Analyzer.Action(Token*,int)",<empty>,,false,229,252,isAliasModified,,,15,"Analyzer.Action(Token*,int)"
111669154324,METHOD,ValueFlowAnalyzer,TYPE_DECL,"virtual Action isThisModified(const Token* tok) const {
        if (isThisChanged(tok, 0, getSettings()))
            return Action::Invalid;
        return Action::None;
    }",5,5,lib/vf_analyzers.cpp,ValueFlowAnalyzer.isThisModified<const>:Analyzer.Action(Token*),<empty>,,false,254,258,isThisModified,,,16,Analyzer.Action(Token*)
111669154325,METHOD,ValueFlowAnalyzer,TYPE_DECL,"virtual Action isWritable(const Token* tok, Direction d) const {
        const ValueFlow::Value* value = getValue(tok);
        if (!value)
            return Action::None;
        if (!(value->isIntValue() || value->isFloatValue() || value->isSymbolicValue() || value->isLifetimeValue()))
            return Action::None;
        const Token* parent = tok->astParent();
        // Only if its invertible
        if (value->isImpossible() && !Token::Match(parent, ""+=|-=|*=|++|--""))
            return Action::None;
        if (value->isLifetimeValue()) {
            if (value->lifetimeKind != ValueFlow::Value::LifetimeKind::Iterator)
                return Action::None;
            if (!Token::Match(parent, ""++|--|+=""))
                return Action::None;
            return Action::Read | Action::Write;
        }
        if (parent && parent->isAssignmentOp() && astIsLHS(tok)) {
            const Token* rhs = parent->astOperand2();
            std::vector<MathLib::bigint> result = evalu...",5,5,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.isWritable<const>:Analyzer.Action(Token*,Analyzer.Direction)",<empty>,,false,260,307,isWritable,,,17,"Analyzer.Action(Token*,Analyzer.Direction)"
111669154326,METHOD,ValueFlowAnalyzer,TYPE_DECL,"virtual void writeValue(ValueFlow::Value* value, const Token* tok, Direction d) const {
        if (!value)
            return;
        if (!tok->astParent())
            return;
        // Lifetime value doesn't change
        if (value->isLifetimeValue())
            return;
        if (tok->astParent()->isAssignmentOp()) {
            const Token* rhs = tok->astParent()->astOperand2();
            std::vector<MathLib::bigint> result = evaluateInt(rhs);
            assert(!result.empty());
            ValueFlow::Value rhsValue{result.front()};
            if (evalAssignment(*value, getAssign(tok->astParent(), d), rhsValue)) {
                std::string info(""Compound assignment '"" + tok->astParent()->str() + ""', assigned value is "" +
                                 value->infoString());
                if (tok->astParent()->str() == ""="")
                    value->errorPath.clear();
                value->errorPath.emplace_back(tok, std::move(info));
            } else {
       ...",5,5,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.writeValue<const>:void(ValueFlow.Value*,Token*,Analyzer.Direction)",<empty>,,false,309,359,writeValue,,,18,"void(ValueFlow.Value*,Token*,Analyzer.Direction)"
111669154327,METHOD,ValueFlowAnalyzer,TYPE_DECL,"virtual bool useSymbolicValues() const {
        return true;
    }",5,5,lib/vf_analyzers.cpp,ValueFlowAnalyzer.useSymbolicValues<const>:bool(),<empty>,,false,361,363,useSymbolicValues,,,19,bool()
111669154328,METHOD,ValueFlowAnalyzer,TYPE_DECL,"virtual void internalUpdate(Token* /*tok*/, const ValueFlow::Value& /*v*/, Direction /*d*/)
    {
        assert(false && ""Internal update unimplemented."");
    }",5,5,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.internalUpdate:void(Token*,ValueFlow.Value&,Analyzer.Direction)",<empty>,,false,365,368,internalUpdate,,,20,"void(Token*,ValueFlow.Value&,Analyzer.Direction)"
111669154329,METHOD,ValueFlowAnalyzer,TYPE_DECL,"Action analyzeLifetime(const Token* tok) const
    {
        if (!tok)
            return Action::None;
        if (match(tok))
            return Action::Match;
        if (Token::simpleMatch(tok, ""."") && analyzeLifetime(tok->astOperand1()) != Action::None)
            return Action::Read;
        if (astIsRHS(tok) && Token::simpleMatch(tok->astParent(), "".""))
            return analyzeLifetime(tok->astParent());
        return Action::None;
    }",5,5,lib/vf_analyzers.cpp,ValueFlowAnalyzer.analyzeLifetime<const>:Analyzer.Action(Token*),<empty>,,false,372,383,analyzeLifetime,,,21,Analyzer.Action(Token*)
111669154330,METHOD,ValueFlowAnalyzer,TYPE_DECL,"std::unordered_map<nonneg int, const Token*> getSymbols(const Token* tok) const
    {
        std::unordered_map<nonneg int, const Token*> result;
        if (!tok)
            return result;
        for (const ValueFlow::Value& v : tok->values()) {
            if (!v.isSymbolicValue())
                continue;
            if (v.isImpossible())
                continue;
            if (!v.tokvalue)
                continue;
            if (v.tokvalue->exprId() == 0)
                continue;
            if (match(v.tokvalue))
                continue;
            result[v.tokvalue->exprId()] = v.tokvalue;
        }
        return result;
    }",5,23,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.getSymbols<const>:unordered_map<int,constToken*>(Token*)",<empty>,,false,385,404,getSymbols,,,22,"unordered_map<int,const Token*>(Token*)"
111669154331,METHOD,ValueFlowAnalyzer,TYPE_DECL,"Action isGlobalModified(const Token* tok) const
    {
        if (tok->function()) {
            if (!tok->function()->isConstexpr() && !isConstFunctionCall(tok, getSettings().library))
                return Action::Invalid;
        } else if (getSettings().library.getFunction(tok)) {
            // Assume library function doesn't modify user-global variables
            return Action::None;
        } else if (Token::simpleMatch(tok->astParent(), ""."") && astIsContainer(tok->astParent()->astOperand1())) {
            // Assume container member function doesn't modify user-global variables
            return Action::None;
        } else if (tok->tokType() == Token::eType && astIsPrimitive(tok->next())) {
            // Function cast does not modify global variables
            return Action::None;
        } else if (!tok->isKeyword() && Token::Match(tok, ""%name% ("")) {
            return Action::Invalid;
        }
        return Action::None;
    }",5,5,lib/vf_analyzers.cpp,ValueFlowAnalyzer.isGlobalModified<const>:Analyzer.Action(Token*),<empty>,,false,406,424,isGlobalModified,,,23,Analyzer.Action(Token*)
111669154332,METHOD,ValueFlowAnalyzer,TYPE_DECL,"static const std::string& invertAssign(const std::string& assign)
    {
        static std::unordered_map<std::string, std::string> lookup = {{""="", ""=""},
            {""+="", ""-=""},
            {""-="", ""+=""},
            {""*="", ""/=""},
            {""/="", ""*=""},
            {""<<="", "">>=""},
            {"">>="", ""<<=""},
            {""^="", ""^=""}};
        auto it = lookup.find(assign);
        if (it == lookup.end()) {
            static const std::string s_empty_string;
            return s_empty_string;
        }
        return it->second;
    }",5,5,lib/vf_analyzers.cpp,ValueFlowAnalyzer.invertAssign:ANY(std.string&),<empty>,,false,426,442,invertAssign,,,24,ANY(std.string&)
111669154333,METHOD,ValueFlowAnalyzer,TYPE_DECL,"static const std::string& getAssign(const Token* tok, Direction d)
    {
        if (d == Direction::Forward)
            return tok->str();
        return invertAssign(tok->str());
    }",5,5,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.getAssign:ANY(Token*,Analyzer.Direction)",<empty>,,false,444,449,getAssign,,,25,"ANY(Token*,Analyzer.Direction)"
111669154334,METHOD,ValueFlowAnalyzer,TYPE_DECL,"static void assignValueIfMutable(T& x, const U& y)
    {
        x = y;
    }",5,5,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.assignValueIfMutable:void(T&,U&)",<empty>,,false,452,455,assignValueIfMutable,,,26,"void(T&,U&)"
111669154335,METHOD,ValueFlowAnalyzer,TYPE_DECL,"static void assignValueIfMutable(const T& /*unused*/, const U& /*unused*/)
    {}",5,6,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.assignValueIfMutable<duplicate>0:void(T&,U&)",<empty>,,false,458,459,assignValueIfMutable,,,27,"void(T&,U&)"
111669154336,METHOD,ValueFlowAnalyzer,TYPE_DECL,"static std::string removeAssign(const std::string& assign) {
        return std::string{assign.cbegin(), assign.cend() - 1};
    }",5,5,lib/vf_analyzers.cpp,ValueFlowAnalyzer.removeAssign:string(std.string&),<empty>,,false,461,463,removeAssign,,,28,string(std.string&)
111669154337,METHOD,ValueFlowAnalyzer,TYPE_DECL,"static T calculateAssign(const std::string& assign, const T& x, const U& y, bool* error = nullptr)
    {
        if (assign.empty() || assign.back() != '=') {
            if (error)
                *error = true;
            return T{};
        }
        if (assign == ""="")
            return static_cast<T>(y);
        return calculate<T, T>(removeAssign(assign), x, y, error);
    }",5,5,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.calculateAssign:T(std.string&,T&,U&,bool*)",<empty>,,false,466,476,calculateAssign,,,29,"T(std.string&,T&,U&,bool*)"
111669154338,METHOD,ValueFlowAnalyzer,TYPE_DECL,"static bool evalAssignment(Value& lhsValue, const std::string& assign, const ValueFlow::Value& rhsValue)
    {
        bool error = false;
        if (lhsValue.isSymbolicValue() && rhsValue.isIntValue()) {
            if (assign != ""+="" && assign != ""-="")
                return false;
            assignValueIfMutable(lhsValue.intvalue, calculateAssign(assign, lhsValue.intvalue, rhsValue.intvalue, &error));
        } else if (lhsValue.isIntValue() && rhsValue.isIntValue()) {
            assignValueIfMutable(lhsValue.intvalue, calculateAssign(assign, lhsValue.intvalue, rhsValue.intvalue, &error));
        } else if (lhsValue.isFloatValue() && rhsValue.isIntValue()) {
            assignValueIfMutable(lhsValue.floatValue,
                                 calculateAssign(assign, lhsValue.floatValue, rhsValue.intvalue, &error));
        } else {
            return false;
        }
        return !error;
    }",5,5,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.evalAssignment:bool(Value&,std.string&,ValueFlow.Value&)",<empty>,,false,479,495,evalAssignment,,,30,"bool(Value&,std.string&,ValueFlow.Value&)"
111669154339,METHOD,ValueFlowAnalyzer,TYPE_DECL,"const Token* findMatch(const Token* tok) const
    {
        return findAstNode(tok, [&](const Token* child) {
            return match(child);
        });
    }",5,5,lib/vf_analyzers.cpp,ValueFlowAnalyzer.findMatch<const>:Token*(Token*),<empty>,,false,497,502,findMatch,,,31,Token*(Token*)
111669154340,METHOD,ValueFlowAnalyzer,TYPE_DECL,"bool isSameSymbolicValue(const Token* tok, ValueFlow::Value* value = nullptr) const
    {
        if (!useSymbolicValues())
            return false;
        if (Token::Match(tok, ""%assign%""))
            return false;
        const ValueFlow::Value* currValue = getValue(tok);
        if (!currValue)
            return false;
        // If the same symbolic value is already there then skip
        if (currValue->isSymbolicValue() &&
            std::any_of(tok->values().cbegin(), tok->values().cend(), [&](const ValueFlow::Value& v) {
            return v.isSymbolicValue() && currValue->equalValue(v);
        }))
            return false;
        const bool isPoint = currValue->bound == ValueFlow::Value::Bound::Point && currValue->isIntValue();
        const bool exact = !currValue->isIntValue() || currValue->isImpossible();
        for (const ValueFlow::Value& v : tok->values()) {
            if (!v.isSymbolicValue())
                continue;
            if (currValue->equalValue(v...",5,5,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.isSameSymbolicValue<const>:bool(Token*,ValueFlow.Value*)",<empty>,,false,504,554,isSameSymbolicValue,,,32,"bool(Token*,ValueFlow.Value*)"
111669154341,METHOD,ValueFlowAnalyzer,TYPE_DECL,"Action analyzeMatch(const Token* tok, Direction d) const {
        const Token* parent = tok->astParent();
        if (d == Direction::Reverse && isGlobal() && !dependsOnThis() && Token::Match(parent, "". %name% ("")) {
            Action a = isGlobalModified(parent->next());
            if (a != Action::None)
                return a;
        }
        if ((astIsPointer(tok) || astIsSmartPointer(tok)) &&
            (Token::Match(parent, ""*|["") || (parent && parent->originalName() == ""->"")) && getIndirect(tok) <= 0)
            return Action::Read;

        Action w = isWritable(tok, d);
        if (w != Action::None)
            return w;

        // Check for modifications by function calls
        return isModified(tok);
    }",5,5,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.analyzeMatch<const>:Analyzer.Action(Token*,Analyzer.Direction)",<empty>,,false,556,573,analyzeMatch,,,33,"Analyzer.Action(Token*,Analyzer.Direction)"
111669154342,METHOD,ValueFlowAnalyzer,TYPE_DECL,"Action analyzeToken(const Token* ref, const Token* tok, Direction d, bool inconclusiveRef) const {
        if (!ref)
            return Action::None;
        // If its an inconclusiveRef then ref != tok
        assert(!inconclusiveRef || ref != tok);
        bool inconclusive = false;
        if (match(ref)) {
            if (inconclusiveRef) {
                Action a = isModified(tok);
                if (a.isModified() || a.isInconclusive())
                    return Action::Inconclusive;
            } else {
                return analyzeMatch(tok, d) | Action::Match;
            }
        } else if (ref->isUnaryOp(""*"") && !match(ref->astOperand1())) {
            const Token* lifeTok = nullptr;
            for (const ValueFlow::Value& v:ref->astOperand1()->values()) {
                if (!v.isLocalLifetimeValue())
                    continue;
                if (lifeTok)
                    return Action::None;
                lifeTok = v.tokvalue;
            }
            i...",5,5,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.analyzeToken<const>:Analyzer.Action(Token*,Token*,Analyzer.Direction,bool)",<empty>,,false,575,627,analyzeToken,,,34,"Analyzer.Action(Token*,Token*,Analyzer.Direction,bool)"
111669154343,METHOD,ValueFlowAnalyzer,TYPE_DECL,"Action analyze(const Token* tok, Direction d) const override {
        if (invalid())
            return Action::Invalid;
        // Follow references
        auto refs = followAllReferences(tok);
        const bool inconclusiveRefs = refs.size() != 1;
        if (std::none_of(refs.cbegin(), refs.cend(), [&](const ReferenceToken& ref) {
            return tok == ref.token;
        }))
            refs.emplace_back(ReferenceToken{tok, {}});
        for (const ReferenceToken& ref:refs) {
            Action a = analyzeToken(ref.token, tok, d, inconclusiveRefs && ref.token != tok);
            if (internalMatch(ref.token))
                a |= Action::Internal;
            if (a != Action::None)
                return a;
        }
        if (dependsOnThis() && exprDependsOnThis(tok, !isVariable()))
            return isThisModified(tok);

        // bailout: global non-const variables
        if (isGlobal() && !dependsOnThis() && Token::Match(tok, ""%name% ("") && !tok->variable() &&
   ...",5,5,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.analyze<const>:Analyzer.Action(Token*,Analyzer.Direction)",<empty>,,false,629,655,analyze,,,35,"Analyzer.Action(Token*,Analyzer.Direction)"
111669154344,METHOD,ValueFlowAnalyzer,TYPE_DECL,"std::vector<MathLib::bigint> evaluateInt(const Token* tok, F getProgramMemory) const
    {
        if (const ValueFlow::Value* v = tok->getKnownValue(ValueFlow::Value::ValueType::INT))
            return {static_cast<int>(v->intvalue)};
        std::vector<MathLib::bigint> result;
        ProgramMemory pm = getProgramMemory();
        if (Token::Match(tok, ""&&|%oror%"")) {
            if (conditionIsTrue(tok, pm, getSettings()))
                result.push_back(1);
            if (conditionIsFalse(tok, std::move(pm), getSettings()))
                result.push_back(0);
        } else {
            MathLib::bigint out = 0;
            bool error = false;
            execute(tok, pm, &out, &error, getSettings());
            if (!error)
                result.push_back(out);
        }
        return result;
    }",5,5,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.evaluateInt<const>:vector<MathLib.bigint>(Token*,F)",<empty>,,false,658,677,evaluateInt,,,36,"vector<MathLib::bigint>(Token*,F)"
111669154345,METHOD,ValueFlowAnalyzer,TYPE_DECL,"std::vector<MathLib::bigint> evaluateInt(const Token* tok) const
    {
        return evaluateInt(tok, [&] {
            return ProgramMemory{getProgramState()};
        });
    }",5,5,lib/vf_analyzers.cpp,ValueFlowAnalyzer.evaluateInt<const>:vector<MathLib.bigint>(Token*),<empty>,,false,679,684,evaluateInt,,,37,vector<MathLib::bigint>(Token*)
111669154346,METHOD,ValueFlowAnalyzer,TYPE_DECL,"std::vector<MathLib::bigint> evaluate(Evaluate e, const Token* tok, const Token* ctx = nullptr) const override
    {
        if (e == Evaluate::Integral) {
            return evaluateInt(tok, [&] {
                return pms.get(tok, ctx, getProgramState());
            });
        }
        if (e == Evaluate::ContainerEmpty) {
            const ValueFlow::Value* value = ValueFlow::findValue(tok->values(), settings, [](const ValueFlow::Value& v) {
                return v.isKnown() && v.isContainerSizeValue();
            });
            if (value)
                return {value->intvalue == 0};
            ProgramMemory pm = pms.get(tok, ctx, getProgramState());
            MathLib::bigint out = 0;
            if (pm.getContainerEmptyValue(tok->exprId(), out))
                return {static_cast<int>(out)};
            return {};
        }
        return {};
    }",5,5,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.evaluate<const>:vector<MathLib.bigint>(Analyzer.Evaluate,Token*,Token*)",<empty>,,false,686,706,evaluate,,,38,"vector<MathLib::bigint>(Analyzer.Evaluate,Token*,Token*)"
111669154347,METHOD,ValueFlowAnalyzer,TYPE_DECL,"void assume(const Token* tok, bool state, unsigned int flags) override {
        // Update program state
        pms.removeModifiedVars(tok);
        pms.addState(tok, getProgramState());
        pms.assume(tok, state, flags & Assume::ContainerEmpty);

        bool isCondBlock = false;
        const Token* parent = tok->astParent();
        if (parent) {
            isCondBlock = Token::Match(parent->previous(), ""if|while ("");
        }

        if (isCondBlock) {
            const Token* startBlock = parent->link()->next();
            if (Token::simpleMatch(startBlock, "";"") && Token::simpleMatch(parent->tokAt(-2), ""} while (""))
                startBlock = parent->linkAt(-2);
            const Token* endBlock = startBlock->link();
            if (state) {
                pms.removeModifiedVars(endBlock);
                pms.addState(endBlock->previous(), getProgramState());
            } else {
                if (Token::simpleMatch(endBlock, ""} else {""))
                    pms.a...",5,5,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.assume:void(Token*,bool,unsigned int)",<empty>,,false,708,745,assume,,,39,"void(Token*,bool,unsigned int)"
111669154348,METHOD,ValueFlowAnalyzer,TYPE_DECL,"void updateState(const Token* tok) override
    {
        // Update program state
        pms.removeModifiedVars(tok);
        pms.addState(tok, getProgramState());
    }",5,5,lib/vf_analyzers.cpp,ValueFlowAnalyzer.updateState:void(Token*),<empty>,,false,747,752,updateState,,,40,void(Token*)
111669154349,METHOD,ValueFlowAnalyzer,TYPE_DECL,"void update(Token* tok, Action a, Direction d) override {
        ValueFlow::Value* value = getValue(tok);
        if (!value)
            return;
        ValueFlow::Value localValue;
        if (a.isSymbolicMatch()) {
            // Make a copy of the value to modify it
            localValue = *value;
            value = &localValue;
            isSameSymbolicValue(tok, &localValue);
        }
        if (a.isInternal())
            internalUpdate(tok, *value, d);
        // Read first when moving forward
        if (d == Direction::Forward && a.isRead())
            setTokenValue(tok, *value, getSettings());
        if (a.isInconclusive())
            (void)lowerToInconclusive();
        if (a.isWrite() && tok->astParent()) {
            writeValue(value, tok, d);
        }
        // Read last when moving in reverse
        if (d == Direction::Reverse && a.isRead())
            setTokenValue(tok, *value, getSettings());
    }",5,5,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.update:void(Token*,Analyzer.Action,Analyzer.Direction)",<empty>,,false,754,778,update,,,41,"void(Token*,Analyzer.Action,Analyzer.Direction)"
111669154350,METHOD,ValueFlowAnalyzer,TYPE_DECL,"ValuePtr<Analyzer> reanalyze(Token* /*tok*/, const std::string& /*msg*/) const override {
        return {};
    }",5,5,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.reanalyze<const>:ValuePtr<Analyzer>(Token*,std.string&)",<empty>,,false,780,782,reanalyze,,,42,"ValuePtr<Analyzer>(Token*,std.string&)"
111669154351,METHOD,lib/vf_analyzers.cpp:<global>,TYPE_DECL,<global>,1,1,lib/vf_analyzers.cpp,lib/vf_analyzers.cpp:<global>,<empty>,,false,1,1577,<global>,,,1,
111669154352,METHOD,lib/vf_analyzers.cpp:<global>,TYPE_DECL,"static bool bifurcateVariableChanged(const Variable* var,
                                     const std::set<nonneg int>& varids,
                                     const Token* start,
                                     const Token* end,
                                     const Settings& settings,
                                     int depth = 20)
{
    bool result = false;
    const Token* tok = start;
    while ((tok = findVariableChanged(
                tok->next(), end, var->isPointer(), var->declarationId(), var->isGlobal(), settings))) {
        if (Token::Match(tok->astParent(), ""%assign%"")) {
            if (!bifurcate(tok->astParent()->astOperand2(), varids, settings, depth - 1))
                return true;
        } else {
            result = true;
        }
    }
    return result;
}",1,52,lib/vf_analyzers.cpp,"bifurcateVariableChanged:bool(Variable*,std.set<int>&,Token*,Token*,Settings&,int)",<empty>,,false,787,806,bifurcateVariableChanged,,,1,"bool(Variable*,std.set<int>&,Token*,Token*,Settings&,int)"
111669154353,METHOD,lib/vf_analyzers.cpp:<global>,TYPE_DECL,"static bool bifurcate(const Token* tok, const std::set<nonneg int>& varids, const Settings& settings, int depth)
{
    if (depth < 0)
        return false;
    if (!tok)
        return true;
    if (tok->hasKnownIntValue())
        return true;
    if (tok->isConstOp())
        return bifurcate(tok->astOperand1(), varids, settings, depth) && bifurcate(tok->astOperand2(), varids, settings, depth);
    if (tok->varId() != 0) {
        if (varids.count(tok->varId()) > 0)
            return true;
        const Variable* var = tok->variable();
        if (!var)
            return false;
        const Token* start = var->declEndToken();
        if (!start)
            return false;
        if (start->strAt(-1) == "")"" || start->strAt(-1) == ""}"")
            return false;
        if (Token::Match(start, ""; %varid% ="", var->declarationId()))
            start = start->tokAt(2);
        if (var->isConst() || !bifurcateVariableChanged(var, varids, start, tok, settings, depth))
            retu...",1,55,lib/vf_analyzers.cpp,"bifurcate:bool(Token*,std.set<int>&,Settings&,int)",<empty>,,false,808,836,bifurcate,,,1,"bool(Token*,std.set<int>&,Settings&,int)"
111669154354,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& val) {
        if (!val.isNonValue())
            return false;
        if (val.isInconclusive())
            return false;
        if (val.isLifetimeValue() && !val.isLocalLifetimeValue())
            return false;
        if (val.isLifetimeValue() && val.lifetimeKind != ValueFlow::Value::LifetimeKind::Address)
            return false;
        if (!Token::Match(val.tokvalue, "".|&|*|%var%""))
            return false;
        return astHasVar(val.tokvalue, tok->varId());
    }",54,5,lib/vf_analyzers.cpp,lib/vf_analyzers.cpp:<global>.isAliasOf.<lambda>8:bool(ValueFlow.Value&),<empty>,,false,851,863,<lambda>8,,,1,bool(ValueFlow.Value&)
111669154355,METHOD,lib/vf_analyzers.cpp:<global>,TYPE_DECL,"static bool isAliasOf(const Variable * var, const Token *tok, nonneg int varid, const V& values, bool* inconclusive = nullptr)
{
    if (tok->varId() == varid)
        return false;
    if (tok->varId() == 0)
        return false;
    if (isAliasOf(tok, varid, inconclusive))
        return true;
    if (var && !var->isPointer())
        return false;
    // Search through non value aliases
    return std::any_of(values.begin(), values.end(), [&](const ValueFlow::Value& val) {
        if (!val.isNonValue())
            return false;
        if (val.isInconclusive())
            return false;
        if (val.isLifetimeValue() && !val.isLocalLifetimeValue())
            return false;
        if (val.isLifetimeValue() && val.lifetimeKind != ValueFlow::Value::LifetimeKind::Address)
            return false;
        if (!Token::Match(val.tokvalue, "".|&|*|%var%""))
            return false;
        return astHasVar(val.tokvalue, tok->varId());
    });
}",1,62,lib/vf_analyzers.cpp,"isAliasOf:bool(Variable*,Token*,int,V&,bool*)",<empty>,,false,840,864,isAliasOf,,,1,"bool(Variable*,Token*,int,V&,bool*)"
111669154356,METHOD,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator,TYPE_DECL,"explicit Iterator(const M::const_iterator & it)
                : mIt(it) {}",13,28,lib/vf_analyzers.cpp,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator.Iterator:ANY(M.const_iterator&),<empty>,,false,877,878,Iterator,,,6,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator.Iterator:ANY(M.const_iterator&)(M.const_iterator&)
111669154357,METHOD,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator,TYPE_DECL,"reference operator*() const {
                return mIt->second;
            }",13,13,lib/vf_analyzers.cpp,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator.*<const>:ValueFlow.Value&(),<empty>,,false,880,882,*,,,7,ValueFlow.Value&()
111669154358,METHOD,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator,TYPE_DECL,"pointer operator->() const {
                return &mIt->second;
            }",13,13,lib/vf_analyzers.cpp,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator.-><const>:ValueFlow.Value*(),<empty>,,false,884,886,->,,,8,ValueFlow.Value*()
111669154359,METHOD,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator,TYPE_DECL,"Iterator &operator++() {
                // cppcheck-suppress postfixOperator - forward iterator needs to perform post-increment
                mIt++;
                return *this;
            }",13,13,lib/vf_analyzers.cpp,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator.++:MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator&(),<empty>,,false,888,892,++,,,9,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator&()
111669154360,METHOD,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator,TYPE_DECL,"friend bool operator==(const Iterator &a, const Iterator &b) {
                return a.mIt == b.mIt;
            }",13,13,lib/vf_analyzers.cpp,"==:bool(MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator&,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator&)",<empty>,,false,894,896,==,,,10,"bool(MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator&,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator&)"
111669154361,METHOD,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator,TYPE_DECL,"friend bool operator!=(const Iterator &a, const Iterator &b) {
                return a.mIt != b.mIt;
            }",13,13,lib/vf_analyzers.cpp,"!=:bool(MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator&,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator&)",<empty>,,false,898,900,!=,,,11,"bool(MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator&,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator&)"
111669154362,METHOD,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange,TYPE_DECL,"explicit SelectValueFromVarIdMapRange(const M *m)
            : mMap(m) {}",9,24,lib/vf_analyzers.cpp,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.SelectValueFromVarIdMapRange:ANY(MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.M*),<empty>,,false,907,908,SelectValueFromVarIdMapRange,,,3,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.SelectValueFromVarIdMapRange:ANY(MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.M*)(MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.M*)
111669154363,METHOD,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange,TYPE_DECL,"Iterator begin() const {
            return Iterator(mMap->begin());
        }",9,9,lib/vf_analyzers.cpp,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.begin<const>:MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator(),<empty>,,false,910,912,begin,,,4,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator()
111669154364,METHOD,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange,TYPE_DECL,"Iterator end() const {
            return Iterator(mMap->end());
        }",9,9,lib/vf_analyzers.cpp,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.end<const>:MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator(),<empty>,,false,913,915,end,,,5,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange.Iterator()
111669154365,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& v) {
                return v.isSymbolicValue() && Token::Match(v.tokvalue, ""%oror%|&&"");
            }",66,13,lib/vf_analyzers.cpp,lib/vf_analyzers.cpp:<global>.MultiValueFlowAnalyzer.stopOnCondition<const>.<lambda>9:bool(ValueFlow.Value&),<empty>,,false,1011,1013,<lambda>9,,,1,bool(ValueFlow.Value&)
111669154366,METHOD,<empty>,<empty>,"[](const std::pair<nonneg int, ValueFlow::Value>& p) {
                return p.second.isLifetimeValue();
            }",64,82,lib/vf_analyzers.cpp,"lib/vf_analyzers.cpp:<global>.MultiValueFlowAnalyzer.updateScope<const>.<lambda>10:ANY(std.pair<int,ValueFlow.Value>&)",<empty>,,false,1023,1025,<lambda>10,,,1,"ANY(std.pair<int,ValueFlow.Value>&)"
111669154367,METHOD,<empty>,<empty>,"[](const ValueFlow::Value& value) {
                if (value.isKnown())
                    return true;
                if (value.isImpossible())
                    return true;
                if (value.isLifetimeValue())
                    return true;
                return false;
            }",25,13,lib/vf_analyzers.cpp,lib/vf_analyzers.cpp:<global>.MultiValueFlowAnalyzer.updateScope<const>.<lambda>11:bool(ValueFlow.Value&),<empty>,,false,1029,1037,<lambda>11,,,1,bool(ValueFlow.Value&)
111669154368,METHOD,MultiValueFlowAnalyzer,TYPE_DECL,"MultiValueFlowAnalyzer(const std::unordered_map<const Variable*, ValueFlow::Value>& args, const Settings& set)
        : ValueFlowAnalyzer(set) {
        for (const auto& p:args) {
            values[p.first->declarationId()] = p.second;
            vars[p.first->declarationId()] = p.first;
        }
    }",5,5,lib/vf_analyzers.cpp,"MultiValueFlowAnalyzer.MultiValueFlowAnalyzer:ANY(std.unordered_map<constVariable*,ValueFlow.Value>&,Settings&)",<empty>,,false,924,930,MultiValueFlowAnalyzer,,,4,"MultiValueFlowAnalyzer.MultiValueFlowAnalyzer:ANY(std.unordered_map<constVariable*,ValueFlow.Value>&,Settings&)(std.unordered_map<constVariable*,ValueFlow.Value>&,Settings&)"
111669154369,METHOD,MultiValueFlowAnalyzer,TYPE_DECL,"virtual const std::unordered_map<nonneg int, const Variable*>& getVars() const {
        return vars;
    }",5,37,lib/vf_analyzers.cpp,MultiValueFlowAnalyzer.getVars<const>:ANY(),<empty>,,false,932,934,getVars,,,5,ANY()
111669154370,METHOD,MultiValueFlowAnalyzer,TYPE_DECL,"const ValueFlow::Value* getValue(const Token* tok) const override {
        if (tok->varId() == 0)
            return nullptr;
        auto it = values.find(tok->varId());
        if (it == values.end())
            return nullptr;
        return &it->second;
    }",5,5,lib/vf_analyzers.cpp,MultiValueFlowAnalyzer.getValue<const>:ValueFlow.Value*(Token*),<empty>,,false,936,943,getValue,,,6,ValueFlow.Value*(Token*)
111669154371,METHOD,MultiValueFlowAnalyzer,TYPE_DECL,"ValueFlow::Value* getValue(const Token* tok) override {
        if (tok->varId() == 0)
            return nullptr;
        auto it = values.find(tok->varId());
        if (it == values.end())
            return nullptr;
        return &it->second;
    }",5,5,lib/vf_analyzers.cpp,MultiValueFlowAnalyzer.getValue:ValueFlow.Value*(Token*),<empty>,,false,944,951,getValue,,,7,ValueFlow.Value*(Token*)
111669154372,METHOD,MultiValueFlowAnalyzer,TYPE_DECL,"void makeConditional() override {
        for (auto&& p:values) {
            p.second.conditional = true;
        }
    }",5,5,lib/vf_analyzers.cpp,MultiValueFlowAnalyzer.makeConditional:void(),<empty>,,false,953,957,makeConditional,,,8,void()
111669154373,METHOD,MultiValueFlowAnalyzer,TYPE_DECL,"void addErrorPath(const Token* tok, const std::string& s) override {
        for (auto&& p:values) {
            p.second.errorPath.emplace_back(tok, s);
        }
    }",5,5,lib/vf_analyzers.cpp,"MultiValueFlowAnalyzer.addErrorPath:void(Token*,std.string&)",<empty>,,false,959,963,addErrorPath,,,9,"void(Token*,std.string&)"
111669154374,METHOD,MultiValueFlowAnalyzer,TYPE_DECL,"bool isAlias(const Token* tok, bool& inconclusive) const override {
        const auto range = SelectValueFromVarIdMapRange(&values);

        for (const auto& p:getVars()) {
            nonneg int const varid = p.first;
            const Variable* var = p.second;
            if (tok->varId() == varid)
                return true;
            if (isAliasOf(var, tok, varid, range, &inconclusive))
                return true;
        }
        return false;
    }",5,12,lib/vf_analyzers.cpp,"MultiValueFlowAnalyzer.isAlias<const>:bool(Token*,bool&)",<empty>,,false,965,977,isAlias,,,10,"bool(Token*,bool&)"
111669154375,METHOD,MultiValueFlowAnalyzer,TYPE_DECL,"bool lowerToPossible() override {
        for (auto&& p:values) {
            if (p.second.isImpossible())
                return false;
            p.second.changeKnownToPossible();
        }
        return true;
    }",5,5,lib/vf_analyzers.cpp,MultiValueFlowAnalyzer.lowerToPossible:bool(),<empty>,,false,979,986,lowerToPossible,,,11,bool()
111669154376,METHOD,MultiValueFlowAnalyzer,TYPE_DECL,"bool lowerToInconclusive() override {
        for (auto&& p:values) {
            if (p.second.isImpossible())
                return false;
            p.second.setInconclusive();
        }
        return true;
    }",5,5,lib/vf_analyzers.cpp,MultiValueFlowAnalyzer.lowerToInconclusive:bool(),<empty>,,false,987,994,lowerToInconclusive,,,12,bool()
111669154377,METHOD,MultiValueFlowAnalyzer,TYPE_DECL,"bool isConditional() const override {
        for (auto&& p:values) {
            if (p.second.conditional)
                return true;
            if (p.second.condition)
                return !p.second.isImpossible();
        }
        return false;
    }",5,5,lib/vf_analyzers.cpp,MultiValueFlowAnalyzer.isConditional<const>:bool(),<empty>,,false,996,1004,isConditional,,,13,bool()
111669154378,METHOD,MultiValueFlowAnalyzer,TYPE_DECL,"bool stopOnCondition(const Token* condTok) const override {
        if (isConditional())
            return true;
        if (!condTok->hasKnownIntValue() && values.count(condTok->varId()) == 0) {
            const auto& values_ = condTok->values();
            return std::any_of(values_.cbegin(), values_.cend(), [](const ValueFlow::Value& v) {
                return v.isSymbolicValue() && Token::Match(v.tokvalue, ""%oror%|&&"");
            });
        }
        return false;
    }",5,5,lib/vf_analyzers.cpp,MultiValueFlowAnalyzer.stopOnCondition<const>:bool(Token*),<empty>,,false,1006,1016,stopOnCondition,,,14,bool(Token*)
111669154379,METHOD,MultiValueFlowAnalyzer,TYPE_DECL,"bool updateScope(const Token* endBlock, bool /*modified*/) const override {
        const Scope* scope = endBlock->scope();
        if (!scope)
            return false;
        if (scope->type == ScopeType::eLambda) {
            return std::all_of(values.cbegin(), values.cend(), [](const std::pair<nonneg int, ValueFlow::Value>& p) {
                return p.second.isLifetimeValue();
            });
        }
        if (scope->type == ScopeType::eIf || scope->type == ScopeType::eElse || scope->type == ScopeType::eWhile ||
            scope->type == ScopeType::eFor) {
            auto pred = [](const ValueFlow::Value& value) {
                if (value.isKnown())
                    return true;
                if (value.isImpossible())
                    return true;
                if (value.isLifetimeValue())
                    return true;
                return false;
            };
            if (std::all_of(values.cbegin(), values.cend(), std::bind(pred, std::bind(SelectM...",5,82,lib/vf_analyzers.cpp,"MultiValueFlowAnalyzer.updateScope<const>:bool(Token*,bool)",<empty>,,false,1018,1049,updateScope,,,15,"bool(Token*,bool)"
111669154380,METHOD,MultiValueFlowAnalyzer,TYPE_DECL,"bool match(const Token* tok) const override {
        return values.count(tok->varId()) > 0;
    }",5,5,lib/vf_analyzers.cpp,MultiValueFlowAnalyzer.match<const>:bool(Token*),<empty>,,false,1051,1053,match,,,16,bool(Token*)
111669154381,METHOD,MultiValueFlowAnalyzer,TYPE_DECL,"ProgramState getProgramState() const override {
        ProgramState ps;
        for (const auto& p : values) {
            const Variable* var = vars.at(p.first);
            if (!var)
                continue;
            ps[var->nameToken()] = p.second;
        }
        return ps;
    }",5,5,lib/vf_analyzers.cpp,MultiValueFlowAnalyzer.getProgramState<const>:ProgramState(),<empty>,,false,1055,1064,getProgramState,,,17,ProgramState()
111669154382,METHOD,lib/vf_analyzers.cpp:<global>,TYPE_DECL,"ValuePtr<Analyzer> makeMultiValueFlowAnalyzer(const std::unordered_map<const Variable*, ValueFlow::Value>& args, const Settings& settings)
{
    return MultiValueFlowAnalyzer{args, settings};
}",1,1,lib/vf_analyzers.cpp,"makeMultiValueFlowAnalyzer:ValuePtr<Analyzer>(std.unordered_map<constVariable*,ValueFlow.Value>&,Settings&)",<empty>,,false,1067,1070,makeMultiValueFlowAnalyzer,,,1,"ValuePtr<Analyzer>(std.unordered_map<constVariable*,ValueFlow.Value>&,Settings&)"
111669154383,METHOD,SingleValueFlowAnalyzer.SingleRange,TYPE_DECL,"T* begin() const {
            return x;
        }",9,9,lib/vf_analyzers.cpp,SingleValueFlowAnalyzer.SingleRange.begin<const>:ANY(),<empty>,,false,1114,1116,begin,,,2,ANY()
111669154384,METHOD,SingleValueFlowAnalyzer.SingleRange,TYPE_DECL,"T* end() const {
            return x+1;
        }",9,9,lib/vf_analyzers.cpp,SingleValueFlowAnalyzer.SingleRange.end<const>:ANY(),<empty>,,false,1117,1119,end,,,3,ANY()
111669154385,METHOD,<empty>,<empty>,"[] (const std::pair<nonneg int, const Variable*>& p) {
            const Variable* var = p.second;
            return !var->isLocal() && !var->isArgument() && !var->isConst();
        }",56,75,lib/vf_analyzers.cpp,"lib/vf_analyzers.cpp:<global>.SingleValueFlowAnalyzer.isGlobal<const>.<lambda>12:bool(std.pair<int,constVariable*>&)",<empty>,,false,1148,1151,<lambda>12,,,1,"bool(std.pair<int,constVariable*>&)"
111669154386,METHOD,SingleValueFlowAnalyzer,TYPE_DECL,"SingleValueFlowAnalyzer(ValueFlow::Value v, const Settings& s) : ValueFlowAnalyzer(s), value(std::move(v)) {}",5,113,lib/vf_analyzers.cpp,"SingleValueFlowAnalyzer.SingleValueFlowAnalyzer:ANY(ValueFlow.Value,Settings&)",<empty>,,false,1077,1077,SingleValueFlowAnalyzer,,,4,"SingleValueFlowAnalyzer.SingleValueFlowAnalyzer:ANY(ValueFlow.Value,Settings&)(ValueFlow.Value,Settings&)"
111669154387,METHOD,SingleValueFlowAnalyzer,TYPE_DECL,"const std::unordered_map<nonneg int, const Variable*>& getVars() const {
        return varids;
    }",5,29,lib/vf_analyzers.cpp,SingleValueFlowAnalyzer.getVars<const>:ANY(),<empty>,,false,1079,1081,getVars,,,5,ANY()
111669154388,METHOD,SingleValueFlowAnalyzer,TYPE_DECL,"const std::unordered_map<nonneg int, const Variable*>& getAliasedVars() const {
        return aliases;
    }",5,29,lib/vf_analyzers.cpp,SingleValueFlowAnalyzer.getAliasedVars<const>:ANY(),<empty>,,false,1083,1085,getAliasedVars,,,6,ANY()
111669154389,METHOD,SingleValueFlowAnalyzer,TYPE_DECL,"const ValueFlow::Value* getValue(const Token* /*tok*/) const override {
        return &value;
    }",5,5,lib/vf_analyzers.cpp,SingleValueFlowAnalyzer.getValue<const>:ValueFlow.Value*(Token*),<empty>,,false,1087,1089,getValue,,,7,ValueFlow.Value*(Token*)
111669154390,METHOD,SingleValueFlowAnalyzer,TYPE_DECL,"ValueFlow::Value* getValue(const Token* /*tok*/) override {
        return &value;
    }",5,5,lib/vf_analyzers.cpp,SingleValueFlowAnalyzer.getValue:ValueFlow.Value*(Token*),<empty>,,false,1090,1092,getValue,,,8,ValueFlow.Value*(Token*)
111669154391,METHOD,SingleValueFlowAnalyzer,TYPE_DECL,"void makeConditional() override {
        value.conditional = true;
    }",5,5,lib/vf_analyzers.cpp,SingleValueFlowAnalyzer.makeConditional:void(),<empty>,,false,1094,1096,makeConditional,,,9,void()
111669154392,METHOD,SingleValueFlowAnalyzer,TYPE_DECL,"bool useSymbolicValues() const override
    {
        if (value.isUninitValue())
            return false;
        if (value.isLifetimeValue())
            return false;
        return true;
    }",5,5,lib/vf_analyzers.cpp,SingleValueFlowAnalyzer.useSymbolicValues<const>:bool(),<empty>,,false,1098,1105,useSymbolicValues,,,10,bool()
111669154393,METHOD,SingleValueFlowAnalyzer,TYPE_DECL,"void addErrorPath(const Token* tok, const std::string& s) override {
        value.errorPath.emplace_back(tok, s);
    }",5,5,lib/vf_analyzers.cpp,"SingleValueFlowAnalyzer.addErrorPath:void(Token*,std.string&)",<empty>,,false,1107,1109,addErrorPath,,,11,"void(Token*,std.string&)"
111669154394,METHOD,SingleValueFlowAnalyzer,TYPE_DECL,"static SingleRange<T> MakeSingleRange(T& x)
    {
        return {&x};
    }",5,5,lib/vf_analyzers.cpp,SingleValueFlowAnalyzer.MakeSingleRange:SingleRange<T>(T&),<empty>,,false,1123,1126,MakeSingleRange,,,13,SingleRange<T>(T&)
111669154395,METHOD,SingleValueFlowAnalyzer,TYPE_DECL,"bool isAlias(const Token* tok, bool& inconclusive) const override {
        if (value.isLifetimeValue())
            return false;
        for (const auto& m: {
            std::ref(getVars()), std::ref(getAliasedVars())
        }) {
            for (const auto& p:m.get()) {
                nonneg int const varid = p.first;
                const Variable* var = p.second;
                if (tok->varId() == varid)
                    return true;
                if (isAliasOf(var, tok, varid, MakeSingleRange(value), &inconclusive))
                    return true;
            }
        }
        return false;
    }",5,16,lib/vf_analyzers.cpp,"SingleValueFlowAnalyzer.isAlias<const>:bool(Token*,bool&)",<empty>,,false,1128,1144,isAlias,,,14,"bool(Token*,bool&)"
111669154396,METHOD,SingleValueFlowAnalyzer,TYPE_DECL,"bool isGlobal() const override {
        const auto& vars = getVars();
        return std::any_of(vars.cbegin(), vars.cend(), [] (const std::pair<nonneg int, const Variable*>& p) {
            const Variable* var = p.second;
            return !var->isLocal() && !var->isArgument() && !var->isConst();
        });
    }",5,75,lib/vf_analyzers.cpp,SingleValueFlowAnalyzer.isGlobal<const>:bool(),<empty>,,false,1146,1152,isGlobal,,,15,bool()
111669154397,METHOD,SingleValueFlowAnalyzer,TYPE_DECL,"bool lowerToPossible() override {
        if (value.isImpossible())
            return false;
        value.changeKnownToPossible();
        return true;
    }",5,5,lib/vf_analyzers.cpp,SingleValueFlowAnalyzer.lowerToPossible:bool(),<empty>,,false,1154,1159,lowerToPossible,,,16,bool()
111669154398,METHOD,SingleValueFlowAnalyzer,TYPE_DECL,"bool lowerToInconclusive() override {
        if (value.isImpossible())
            return false;
        value.setInconclusive();
        return true;
    }",5,5,lib/vf_analyzers.cpp,SingleValueFlowAnalyzer.lowerToInconclusive:bool(),<empty>,,false,1160,1165,lowerToInconclusive,,,17,bool()
111669154399,METHOD,SingleValueFlowAnalyzer,TYPE_DECL,"bool isConditional() const override {
        if (value.conditional)
            return true;
        if (value.condition)
            return !value.isKnown() && !value.isImpossible();
        return false;
    }",5,5,lib/vf_analyzers.cpp,SingleValueFlowAnalyzer.isConditional<const>:bool(),<empty>,,false,1167,1173,isConditional,,,18,bool()
111669154400,METHOD,SingleValueFlowAnalyzer,TYPE_DECL,"bool stopOnCondition(const Token* condTok) const override
    {
        if (value.isNonValue())
            return false;
        if (value.isImpossible())
            return false;
        if (isConditional() && !value.isKnown() && !value.isImpossible())
            return true;
        if (value.isSymbolicValue())
            return false;
        ConditionState cs = analyzeCondition(condTok);
        return cs.isUnknownDependent();
    }",5,5,lib/vf_analyzers.cpp,SingleValueFlowAnalyzer.stopOnCondition<const>:bool(Token*),<empty>,,false,1175,1187,stopOnCondition,,,19,bool(Token*)
111669154401,METHOD,SingleValueFlowAnalyzer,TYPE_DECL,"bool updateScope(const Token* endBlock, bool /*modified*/) const override {
        const Scope* scope = endBlock->scope();
        if (!scope)
            return false;
        if (scope->type == ScopeType::eLambda)
            return value.isLifetimeValue();
        if (scope->type == ScopeType::eIf || scope->type == ScopeType::eElse || scope->type == ScopeType::eWhile ||
            scope->type == ScopeType::eFor) {
            if (value.isKnown() || value.isImpossible())
                return true;
            if (value.isLifetimeValue())
                return true;
            if (isConditional())
                return false;
            const Token* condTok = getCondTokFromEnd(endBlock);
            std::set<nonneg int> varids2;
            std::transform(getVars().cbegin(), getVars().cend(), std::inserter(varids2, varids2.begin()), SelectMapKeys{});
            return bifurcate(condTok, varids2, getSettings());
        }

        return false;
    }",5,21,lib/vf_analyzers.cpp,"SingleValueFlowAnalyzer.updateScope<const>:bool(Token*,bool)",<empty>,,false,1189,1210,updateScope,,,20,"bool(Token*,bool)"
111669154402,METHOD,SingleValueFlowAnalyzer,TYPE_DECL,"ValuePtr<Analyzer> reanalyze(Token* tok, const std::string& msg) const override {
        ValueFlow::Value newValue = value;
        newValue.errorPath.emplace_back(tok, msg);
        return makeAnalyzer(tok, std::move(newValue), settings);
    }",5,5,lib/vf_analyzers.cpp,"SingleValueFlowAnalyzer.reanalyze<const>:ValuePtr<Analyzer>(Token*,std.string&)",<empty>,,false,1212,1216,reanalyze,,,21,"ValuePtr<Analyzer>(Token*,std.string&)"
111669154403,METHOD,<empty>,<empty>,"[&](const Token* tok) {
            const bool top = depth == 0 && tok == start;
            const bool ispointer = astIsPointer(tok) || astIsSmartPointer(tok) || astIsIterator(tok);
            if (!top || !ispointer || value.indirect != 0) {
                for (const ValueFlow::Value& v : tok->values()) {
                    if (!(v.isLocalLifetimeValue() || (ispointer && v.isSymbolicValue() && v.isKnown())))
                        continue;
                    if (!v.tokvalue)
                        continue;
                    if (v.tokvalue == tok)
                        continue;
                    setupExprVarIds(v.tokvalue, depth + 1);
                }
            }
            if (depth == 0 && tok->isIncompleteVar()) {
                // TODO: Treat incomplete var as global, but we need to update
                // the alias variables to just expr ids instead of requiring
                // Variable
                unknown = true;
                return ChildrenToVi...",30,9,lib/vf_analyzers.cpp,lib/vf_analyzers.cpp:<global>.ExpressionAnalyzer.setupExprVarIds.<lambda>13:ChildrenToVisit(Token*),<empty>,,false,1252,1287,<lambda>13,,,1,ChildrenToVisit(Token*)
111669154404,METHOD,ExpressionAnalyzer,TYPE_DECL,"ExpressionAnalyzer(const Token* e, ValueFlow::Value val, const Settings& s)
        : SingleValueFlowAnalyzer(std::move(val), s),
        expr(e)
    {

        assert(e && e->exprId() != 0 && ""Not a valid expression"");
        dependOnThis = exprDependsOnThis(expr);
        setupExprVarIds(expr);
        if (value.isSymbolicValue()) {
            dependOnThis |= exprDependsOnThis(value.tokvalue);
            setupExprVarIds(value.tokvalue);
        }
        uniqueExprId =
            expr->isUniqueExprId() && (Token::Match(expr, ""%cop%"") || !isVariableChanged(expr, 0, s));
    }",5,5,lib/vf_analyzers.cpp,"ExpressionAnalyzer.ExpressionAnalyzer:ANY(Token*,ValueFlow.Value,Settings&)",<empty>,,false,1226,1240,ExpressionAnalyzer,,,6,"ExpressionAnalyzer.ExpressionAnalyzer:ANY(Token*,ValueFlow.Value,Settings&)(Token*,ValueFlow.Value,Settings&)"
111669154405,METHOD,ExpressionAnalyzer,TYPE_DECL,"static bool nonLocal(const Variable* var, bool deref) {
        return !var || (!var->isLocal() && !var->isArgument()) || (deref && var->isArgument() && var->isPointer()) ||
               var->isStatic() || var->isReference() || var->isExtern();
    }",5,5,lib/vf_analyzers.cpp,"ExpressionAnalyzer.nonLocal:bool(Variable*,bool)",<empty>,,false,1242,1245,nonLocal,,,7,"bool(Variable*,bool)"
111669154406,METHOD,ExpressionAnalyzer,TYPE_DECL,"void setupExprVarIds(const Token* start, int depth = 0) {
        if (depth > settings.vfOptions.maxExprVarIdDepth) {
            // TODO: add bailout message
            return;
        }
        visitAstNodes(start, [&](const Token* tok) {
            const bool top = depth == 0 && tok == start;
            const bool ispointer = astIsPointer(tok) || astIsSmartPointer(tok) || astIsIterator(tok);
            if (!top || !ispointer || value.indirect != 0) {
                for (const ValueFlow::Value& v : tok->values()) {
                    if (!(v.isLocalLifetimeValue() || (ispointer && v.isSymbolicValue() && v.isKnown())))
                        continue;
                    if (!v.tokvalue)
                        continue;
                    if (v.tokvalue == tok)
                        continue;
                    setupExprVarIds(v.tokvalue, depth + 1);
                }
            }
            if (depth == 0 && tok->isIncompleteVar()) {
                // TODO: Treat in...",5,5,lib/vf_analyzers.cpp,"ExpressionAnalyzer.setupExprVarIds:void(Token*,int)",<empty>,,false,1247,1288,setupExprVarIds,,,8,"void(Token*,int)"
111669154407,METHOD,ExpressionAnalyzer,TYPE_DECL,"virtual bool skipUniqueExprIds() const {
        return true;
    }",5,5,lib/vf_analyzers.cpp,ExpressionAnalyzer.skipUniqueExprIds<const>:bool(),<empty>,,false,1290,1292,skipUniqueExprIds,,,9,bool()
111669154408,METHOD,ExpressionAnalyzer,TYPE_DECL,"bool invalid() const override {
        if (skipUniqueExprIds() && uniqueExprId)
            return true;
        return unknown;
    }",5,5,lib/vf_analyzers.cpp,ExpressionAnalyzer.invalid<const>:bool(),<empty>,,false,1294,1298,invalid,,,10,bool()
111669154409,METHOD,ExpressionAnalyzer,TYPE_DECL,"ProgramState getProgramState() const override {
        ProgramState ps;
        ps[expr] = value;
        return ps;
    }",5,5,lib/vf_analyzers.cpp,ExpressionAnalyzer.getProgramState<const>:ProgramState(),<empty>,,false,1300,1304,getProgramState,,,11,ProgramState()
111669154410,METHOD,ExpressionAnalyzer,TYPE_DECL,"bool match(const Token* tok) const override {
        return tok->exprId() == expr->exprId();
    }",5,5,lib/vf_analyzers.cpp,ExpressionAnalyzer.match<const>:bool(Token*),<empty>,,false,1306,1308,match,,,12,bool(Token*)
111669154411,METHOD,ExpressionAnalyzer,TYPE_DECL,"bool dependsOnThis() const override {
        return dependOnThis;
    }",5,5,lib/vf_analyzers.cpp,ExpressionAnalyzer.dependsOnThis<const>:bool(),<empty>,,false,1310,1312,dependsOnThis,,,13,bool()
111669154412,METHOD,ExpressionAnalyzer,TYPE_DECL,"bool isGlobal() const override {
        return !local;
    }",5,5,lib/vf_analyzers.cpp,ExpressionAnalyzer.isGlobal<const>:bool(),<empty>,,false,1314,1316,isGlobal,,,14,bool()
111669154413,METHOD,ExpressionAnalyzer,TYPE_DECL,"bool isVariable() const override {
        return expr->varId() > 0;
    }",5,5,lib/vf_analyzers.cpp,ExpressionAnalyzer.isVariable<const>:bool(),<empty>,,false,1318,1320,isVariable,,,15,bool()
111669154414,METHOD,ExpressionAnalyzer,TYPE_DECL,"Action isAliasModified(const Token* tok, int indirect) const override {
        if (value.isSymbolicValue() && tok->exprId() == value.tokvalue->exprId())
            indirect = 0;
        return SingleValueFlowAnalyzer::isAliasModified(tok, indirect);
    }",5,5,lib/vf_analyzers.cpp,"ExpressionAnalyzer.isAliasModified<const>:Analyzer.Action(Token*,int)",<empty>,,false,1322,1326,isAliasModified,,,16,"Analyzer.Action(Token*,int)"
111669154415,METHOD,<empty>,<empty>,<empty>,1,,lib/vf_analyzers.cpp,ExpressionAnalyzer.<clinit>,<empty>,,false,1219,,<clinit>,,,17,
111669154416,METHOD,SameExpressionAnalyzer,TYPE_DECL,"SameExpressionAnalyzer(const Token* e, ValueFlow::Value val, const Settings& s)
        : ExpressionAnalyzer(e, std::move(val), s)
    {}",5,6,lib/vf_analyzers.cpp,"SameExpressionAnalyzer.SameExpressionAnalyzer:ANY(Token*,ValueFlow.Value,Settings&)",<empty>,,false,1330,1332,SameExpressionAnalyzer,,,1,"SameExpressionAnalyzer.SameExpressionAnalyzer:ANY(Token*,ValueFlow.Value,Settings&)(Token*,ValueFlow.Value,Settings&)"
111669154417,METHOD,SameExpressionAnalyzer,TYPE_DECL,"bool skipUniqueExprIds() const override {
        return false;
    }",5,5,lib/vf_analyzers.cpp,SameExpressionAnalyzer.skipUniqueExprIds<const>:bool(),<empty>,,false,1334,1336,skipUniqueExprIds,,,2,bool()
111669154418,METHOD,SameExpressionAnalyzer,TYPE_DECL,"bool match(const Token* tok) const override
    {
        return isSameExpression(true, expr, tok, getSettings(), true, true);
    }",5,5,lib/vf_analyzers.cpp,SameExpressionAnalyzer.match<const>:bool(Token*),<empty>,,false,1338,1341,match,,,3,bool(Token*)
111669154419,METHOD,lib/vf_analyzers.cpp:<global>,TYPE_DECL,"ValuePtr<Analyzer> makeSameExpressionAnalyzer(const Token* e, ValueFlow::Value val, const Settings& s)
{
    return SameExpressionAnalyzer{e, std::move(val), s};
}",1,1,lib/vf_analyzers.cpp,"makeSameExpressionAnalyzer:ValuePtr<Analyzer>(Token*,ValueFlow.Value,Settings&)",<empty>,,false,1344,1347,makeSameExpressionAnalyzer,,,1,"ValuePtr<Analyzer>(Token*,ValueFlow.Value,Settings&)"
111669154420,METHOD,OppositeExpressionAnalyzer,TYPE_DECL,"OppositeExpressionAnalyzer(bool pIsNot, const Token* e, ValueFlow::Value val, const Settings& s)
        : ExpressionAnalyzer(e, std::move(val), s), isNot(pIsNot)
    {}",5,6,lib/vf_analyzers.cpp,"OppositeExpressionAnalyzer.OppositeExpressionAnalyzer:ANY(bool,Token*,ValueFlow.Value,Settings&)",<empty>,,false,1352,1354,OppositeExpressionAnalyzer,,,2,"OppositeExpressionAnalyzer.OppositeExpressionAnalyzer:ANY(bool,Token*,ValueFlow.Value,Settings&)(bool,Token*,ValueFlow.Value,Settings&)"
111669154421,METHOD,OppositeExpressionAnalyzer,TYPE_DECL,"bool skipUniqueExprIds() const override {
        return false;
    }",5,5,lib/vf_analyzers.cpp,OppositeExpressionAnalyzer.skipUniqueExprIds<const>:bool(),<empty>,,false,1356,1358,skipUniqueExprIds,,,3,bool()
111669154422,METHOD,OppositeExpressionAnalyzer,TYPE_DECL,"bool match(const Token* tok) const override {
        return isOppositeCond(isNot, expr, tok, getSettings(), true, true);
    }",5,5,lib/vf_analyzers.cpp,OppositeExpressionAnalyzer.match<const>:bool(Token*),<empty>,,false,1360,1362,match,,,4,bool(Token*)
111669154423,METHOD,<empty>,<empty>,<empty>,1,,lib/vf_analyzers.cpp,OppositeExpressionAnalyzer.<clinit>,<empty>,,false,1349,,<clinit>,,,5,
111669154424,METHOD,lib/vf_analyzers.cpp:<global>,TYPE_DECL,"ValuePtr<Analyzer> makeOppositeExpressionAnalyzer(bool pIsNot, const Token* e, ValueFlow::Value val, const Settings& s)
{
    return OppositeExpressionAnalyzer{pIsNot, e, std::move(val), s};
}",1,1,lib/vf_analyzers.cpp,"makeOppositeExpressionAnalyzer:ValuePtr<Analyzer>(bool,Token*,ValueFlow.Value,Settings&)",<empty>,,false,1365,1368,makeOppositeExpressionAnalyzer,,,1,"ValuePtr<Analyzer>(bool,Token*,ValueFlow.Value,Settings&)"
111669154425,METHOD,SubExpressionAnalyzer,TYPE_DECL,"SubExpressionAnalyzer(const Token* e, ValueFlow::Value val, const Settings& s)
        : ExpressionAnalyzer(e, std::move(val), s), partialReads(std::make_shared<PartialReadContainer>())
    {}",5,6,lib/vf_analyzers.cpp,"SubExpressionAnalyzer.SubExpressionAnalyzer:ANY(Token*,ValueFlow.Value,Settings&)",<empty>,,false,1375,1377,SubExpressionAnalyzer,,,3,"SubExpressionAnalyzer.SubExpressionAnalyzer:ANY(Token*,ValueFlow.Value,Settings&)(Token*,ValueFlow.Value,Settings&)"
111669154426,METHOD,SubExpressionAnalyzer,TYPE_DECL,"SubExpressionAnalyzer(const Token* e, ValueFlow::Value val, const std::shared_ptr<PartialReadContainer>& p, const Settings& s)
        : ExpressionAnalyzer(e, std::move(val), s), partialReads(p)
    {}",5,6,lib/vf_analyzers.cpp,"SubExpressionAnalyzer.SubExpressionAnalyzer:ANY(Token*,ValueFlow.Value,std.shared_ptr<PartialReadContainer>&,Settings&)",<empty>,,false,1379,1381,SubExpressionAnalyzer,,,4,"SubExpressionAnalyzer.SubExpressionAnalyzer:ANY(Token*,ValueFlow.Value,std.shared_ptr<PartialReadContainer>&,Settings&)(Token*,ValueFlow.Value,std.shared_ptr<PartialReadContainer>&,Settings&)"
111669154427,METHOD,SubExpressionAnalyzer,TYPE_DECL,"bool isAlias(const Token* tok, bool& inconclusive) const override
    {
        if (tok->exprId() == expr->exprId() && tok->astParent() && submatch(tok->astParent(), false))
            return false;
        return ExpressionAnalyzer::isAlias(tok, inconclusive);
    }",5,5,lib/vf_analyzers.cpp,"SubExpressionAnalyzer.isAlias<const>:bool(Token*,bool&)",<empty>,,false,1385,1390,isAlias,,,5,"bool(Token*,bool&)"
111669154428,METHOD,SubExpressionAnalyzer,TYPE_DECL,"bool match(const Token* tok) const override
    {
        return tok->astOperand1() && tok->astOperand1()->exprId() == expr->exprId() && submatch(tok);
    }",5,5,lib/vf_analyzers.cpp,SubExpressionAnalyzer.match<const>:bool(Token*),<empty>,,false,1392,1395,match,,,6,bool(Token*)
111669154429,METHOD,SubExpressionAnalyzer,TYPE_DECL,"bool internalMatch(const Token* tok) const override
    {
        return tok->exprId() == expr->exprId() && !(astIsLHS(tok) && submatch(tok->astParent(), false));
    }",5,5,lib/vf_analyzers.cpp,SubExpressionAnalyzer.internalMatch<const>:bool(Token*),<empty>,,false,1396,1399,internalMatch,,,7,bool(Token*)
111669154430,METHOD,SubExpressionAnalyzer,TYPE_DECL,"void internalUpdate(Token* tok, const ValueFlow::Value& v, Direction /*d*/) override
    {
        partialReads->emplace_back(tok, v);
    }",5,5,lib/vf_analyzers.cpp,"SubExpressionAnalyzer.internalUpdate:void(Token*,ValueFlow.Value&,Analyzer.Direction)",<empty>,,false,1400,1403,internalUpdate,,,8,"void(Token*,ValueFlow.Value&,Analyzer.Direction)"
111669154431,METHOD,SubExpressionAnalyzer,TYPE_DECL,"ValuePtr<Analyzer> reanalyze(Token* /*tok*/, const std::string& /*msg*/) const override {
        return {};
    }",5,5,lib/vf_analyzers.cpp,"SubExpressionAnalyzer.reanalyze<const>:ValuePtr<Analyzer>(Token*,std.string&)",<empty>,,false,1406,1408,reanalyze,,,9,"ValuePtr<Analyzer>(Token*,std.string&)"
111669154432,METHOD,MemberExpressionAnalyzer,TYPE_DECL,"MemberExpressionAnalyzer(std::string varname, const Token* e, ValueFlow::Value val, const std::shared_ptr<PartialReadContainer>& p, const Settings& s)
        : SubExpressionAnalyzer(e, std::move(val), p, s), varname(std::move(varname))
    {}",5,6,lib/vf_analyzers.cpp,"MemberExpressionAnalyzer.MemberExpressionAnalyzer:ANY(std.string,Token*,ValueFlow.Value,std.shared_ptr<PartialReadContainer>&,Settings&)",<empty>,,false,1414,1416,MemberExpressionAnalyzer,,,2,"MemberExpressionAnalyzer.MemberExpressionAnalyzer:ANY(std.string,Token*,ValueFlow.Value,std.shared_ptr<PartialReadContainer>&,Settings&)(std.string,Token*,ValueFlow.Value,std.shared_ptr<PartialReadContainer>&,Settings&)"
111669154433,METHOD,MemberExpressionAnalyzer,TYPE_DECL,"bool submatch(const Token* tok, bool exact) const override
    {
        if (!Token::Match(tok, "". %var%""))
            return false;
        if (!exact)
            return true;
        return tok->strAt(1) == varname;
    }",5,5,lib/vf_analyzers.cpp,"MemberExpressionAnalyzer.submatch<const>:bool(Token*,bool)",<empty>,,false,1418,1425,submatch,,,3,"bool(Token*,bool)"
111669154434,METHOD,lib/vf_analyzers.cpp:<global>,TYPE_DECL,"ValuePtr<Analyzer> makeMemberExpressionAnalyzer(std::string varname, const Token* e, ValueFlow::Value val, const std::shared_ptr<PartialReadContainer>& p, const Settings& s)
{
    return MemberExpressionAnalyzer{std::move(varname), e, std::move(val), p, s};
}",1,1,lib/vf_analyzers.cpp,"makeMemberExpressionAnalyzer:ValuePtr<Analyzer>(std.string,Token*,ValueFlow.Value,std.shared_ptr<PartialReadContainer>&,Settings&)",<empty>,,false,1428,1431,makeMemberExpressionAnalyzer,,,1,"ValuePtr<Analyzer>(std.string,Token*,ValueFlow.Value,std.shared_ptr<PartialReadContainer>&,Settings&)"
111669154435,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value &rhsval) {
                    return rhsval.isKnown() && rhsval.isContainerSizeValue();
                }",79,17,lib/vf_analyzers.cpp,lib/vf_analyzers.cpp:<global>.ContainerExpressionAnalyzer.isWritable<const>.<lambda>14:bool(ValueFlow.Value&),<empty>,,false,1461,1463,<lambda>14,,,1,bool(ValueFlow.Value&)
111669154436,METHOD,<empty>,<empty>,"[&](const ValueFlow::Value& rhsval) {
                    return rhsval.isKnown() && rhsval.isContainerSizeValue();
                }",84,17,lib/vf_analyzers.cpp,lib/vf_analyzers.cpp:<global>.ContainerExpressionAnalyzer.writeValue<const>.<lambda>15:bool(ValueFlow.Value&),<empty>,,false,1496,1498,<lambda>15,,,1,bool(ValueFlow.Value&)
111669154437,METHOD,ContainerExpressionAnalyzer,TYPE_DECL,"ContainerExpressionAnalyzer(const Token* expr, ValueFlow::Value val, const Settings& s)
        : ExpressionAnalyzer(expr, std::move(val), s)
    {}",5,6,lib/vf_analyzers.cpp,"ContainerExpressionAnalyzer.ContainerExpressionAnalyzer:ANY(Token*,ValueFlow.Value,Settings&)",<empty>,,false,1434,1436,ContainerExpressionAnalyzer,,,1,"ContainerExpressionAnalyzer.ContainerExpressionAnalyzer:ANY(Token*,ValueFlow.Value,Settings&)(Token*,ValueFlow.Value,Settings&)"
111669154438,METHOD,ContainerExpressionAnalyzer,TYPE_DECL,"bool match(const Token* tok) const override {
        return tok->exprId() == expr->exprId() || (astIsIterator(tok) && isAliasOf(tok, expr->exprId()));
    }",5,5,lib/vf_analyzers.cpp,ContainerExpressionAnalyzer.match<const>:bool(Token*),<empty>,,false,1438,1440,match,,,2,bool(Token*)
111669154439,METHOD,ContainerExpressionAnalyzer,TYPE_DECL,"Action isWritable(const Token* tok, Direction /*d*/) const override
    {
        if (astIsIterator(tok))
            return Action::None;
        if (!getValue(tok))
            return Action::None;
        if (!tok->valueType())
            return Action::None;
        if (!astIsContainer(tok))
            return Action::None;
        const Token* parent = tok->astParent();
        const Library::Container* container = getLibraryContainer(tok);

        if (container->stdStringLike && Token::simpleMatch(parent, ""+="") && astIsLHS(tok) && parent->astOperand2()) {
            const Token* rhs = parent->astOperand2();
            if (rhs->tokType() == Token::eString)
                return Action::Read | Action::Write | Action::Incremental;
            const Library::Container* rhsContainer = getLibraryContainer(rhs);
            if (rhsContainer && rhsContainer->stdStringLike) {
                if (std::any_of(rhs->values().cbegin(), rhs->values().cend(), [&](const ValueFlow::Value &...",5,5,lib/vf_analyzers.cpp,"ContainerExpressionAnalyzer.isWritable<const>:Analyzer.Action(Token*,Analyzer.Direction)",<empty>,,false,1442,1475,isWritable,,,3,"Analyzer.Action(Token*,Analyzer.Direction)"
111669154440,METHOD,ContainerExpressionAnalyzer,TYPE_DECL,"void writeValue(ValueFlow::Value* val, const Token* tok, Direction d) const override {
        if (!val)
            return;
        if (!tok->astParent())
            return;
        if (!tok->valueType())
            return;
        if (!astIsContainer(tok))
            return;
        const Token* parent = tok->astParent();
        const Library::Container* container = getLibraryContainer(tok);
        MathLib::bigint n = 0;

        if (container->stdStringLike && Token::simpleMatch(parent, ""+="") && parent->astOperand2()) {
            const Token* rhs = parent->astOperand2();
            const Library::Container* rhsContainer = getLibraryContainer(rhs);
            if (rhs->tokType() == Token::eString)
                n = Token::getStrLength(rhs);
            else if (rhsContainer && rhsContainer->stdStringLike) {
                auto it = std::find_if(rhs->values().begin(), rhs->values().end(), [&](const ValueFlow::Value& rhsval) {
                    return rhsval.isKnown() &...",5,5,lib/vf_analyzers.cpp,"ContainerExpressionAnalyzer.writeValue<const>:void(ValueFlow.Value*,Token*,Analyzer.Direction)",<empty>,,false,1477,1527,writeValue,,,4,"void(ValueFlow.Value*,Token*,Analyzer.Direction)"
111669154441,METHOD,ContainerExpressionAnalyzer,TYPE_DECL,"int getIndirect(const Token* tok) const override
    {
        if (tok->valueType()) {
            return tok->valueType()->pointer;
        }
        return ValueFlowAnalyzer::getIndirect(tok);
    }",5,5,lib/vf_analyzers.cpp,ContainerExpressionAnalyzer.getIndirect<const>:int(Token*),<empty>,,false,1529,1535,getIndirect,,,5,int(Token*)
111669154442,METHOD,ContainerExpressionAnalyzer,TYPE_DECL,"Action isModified(const Token* tok) const override {
        Action read = Action::Read;
        // An iterator won't change the container size
        if (astIsIterator(tok))
            return read;
        if (Token::Match(tok->astParent(), ""%assign%"") && astIsLHS(tok))
            return Action::Invalid;
        if (isLikelyStreamRead(tok->astParent()))
            return Action::Invalid;
        if (astIsContainer(tok) && ValueFlow::isContainerSizeChanged(tok, getIndirect(tok), getSettings()))
            return read | Action::Invalid;
        return read;
    }",5,5,lib/vf_analyzers.cpp,ContainerExpressionAnalyzer.isModified<const>:Analyzer.Action(Token*),<empty>,,false,1537,1549,isModified,,,6,Analyzer.Action(Token*)
111669154443,METHOD,<empty>,<empty>,"[](const Token* tok) -> std::vector<MathLib::bigint> {
        if (const ValueFlow::Value* v = tok->getKnownValue(ValueFlow::Value::ValueType::INT))
            return {v->intvalue};
        return {};
    }",9,5,lib/vf_analyzers.cpp,lib/vf_analyzers.cpp:<global>.solveExprValue.<lambda>16:vector<MathLib::bigint>(Token*),<empty>,,false,1556,1560,<lambda>16,,,1,vector<MathLib::bigint>(Token*)
111669154444,METHOD,lib/vf_analyzers.cpp:<global>,TYPE_DECL,"static const Token* solveExprValue(const Token* expr, ValueFlow::Value& value)
{
    return ValueFlow::solveExprValue(
        expr,
        [](const Token* tok) -> std::vector<MathLib::bigint> {
        if (const ValueFlow::Value* v = tok->getKnownValue(ValueFlow::Value::ValueType::INT))
            return {v->intvalue};
        return {};
    },
        value);
}",1,1,lib/vf_analyzers.cpp,"solveExprValue:Token*(Token*,ValueFlow.Value&)",<empty>,,false,1552,1562,solveExprValue,,,1,"Token*(Token*,ValueFlow.Value&)"
111669154445,METHOD,lib/vf_analyzers.cpp:<global>,TYPE_DECL,"ValuePtr<Analyzer> makeAnalyzer(const Token* exprTok, ValueFlow::Value value, const Settings& settings)
{
    if (value.isContainerSizeValue())
        return ContainerExpressionAnalyzer(exprTok, std::move(value), settings);
    const Token* expr = solveExprValue(exprTok, value);
    return ExpressionAnalyzer(expr, std::move(value), settings);
}",1,1,lib/vf_analyzers.cpp,"makeAnalyzer:ValuePtr<Analyzer>(Token*,ValueFlow.Value,Settings&)",<empty>,,false,1564,1570,makeAnalyzer,,,1,"ValuePtr<Analyzer>(Token*,ValueFlow.Value,Settings&)"
111669154446,METHOD,lib/vf_analyzers.cpp:<global>,TYPE_DECL,"ValuePtr<Analyzer> makeReverseAnalyzer(const Token* exprTok, ValueFlow::Value value, const Settings& settings)
{
    if (value.isContainerSizeValue())
        return ContainerExpressionAnalyzer(exprTok, std::move(value), settings);
    return ExpressionAnalyzer(exprTok, std::move(value), settings);
}",1,1,lib/vf_analyzers.cpp,"makeReverseAnalyzer:ValuePtr<Analyzer>(Token*,ValueFlow.Value,Settings&)",<empty>,,false,1572,1577,makeReverseAnalyzer,,,1,"ValuePtr<Analyzer>(Token*,ValueFlow.Value,Settings&)"
111669154447,METHOD,lib/vf_analyzers.h:<global>,TYPE_DECL,<global>,1,1,lib/vf_analyzers.h,lib/vf_analyzers.h:<global>,<empty>,,false,1,51,<global>,,,1,
111669154448,METHOD,lib/vf_common.cpp:<global>,TYPE_DECL,"bool getMinMaxValues(const ValueType *vt, const Platform &platform, MathLib::bigint &minValue, MathLib::bigint &maxValue)
    {
        if (!vt || !vt->isIntegral() || vt->pointer)
            return false;

        std::uint8_t bits;
        switch (vt->type) {
        case ValueType::Type::BOOL:
            bits = 1;
            break;
        case ValueType::Type::CHAR:
            bits = platform.char_bit;
            break;
        case ValueType::Type::SHORT:
            bits = platform.short_bit;
            break;
        case ValueType::Type::INT:
            bits = platform.int_bit;
            break;
        case ValueType::Type::LONG:
            bits = platform.long_bit;
            break;
        case ValueType::Type::LONGLONG:
            bits = platform.long_long_bit;
            break;
        default:
            return false;
        }

        if (bits == 1) {
            minValue = 0;
            maxValue = 1;
        } else if (bits < 62) {
            if (vt->...",5,5,lib/vf_common.cpp,"ValueFlow.getMinMaxValues:bool(ValueType*,Platform&,MathLib.bigint&,MathLib.bigint&)",<empty>,,false,44,97,getMinMaxValues,,,1,"bool(ValueType*,Platform&,MathLib.bigint&,MathLib.bigint&)"
111669154449,METHOD,lib/vf_common.cpp:<global>,TYPE_DECL,"MathLib::bigint truncateIntValue(MathLib::bigint value, size_t value_size, const ValueType::Sign dst_sign)
    {
        if (value_size == 0)
            return value;

        const MathLib::biguint unsignedMaxValue = std::numeric_limits<MathLib::biguint>::max() >> ((sizeof(unsignedMaxValue) - value_size) * 8);
        const MathLib::biguint signBit = 1ULL << (value_size * 8 - 1);
        value &= unsignedMaxValue;
        if (dst_sign == ValueType::Sign::SIGNED && (value & signBit))
            value |= ~unsignedMaxValue;

        return value;
    }",5,5,lib/vf_common.cpp,"ValueFlow.truncateIntValue:longlongint(MathLib.bigint,size_t,ValueType.Sign)",<empty>,,false,99,111,truncateIntValue,,,1,"longlongint(MathLib.bigint,size_t,ValueType.Sign)"
111669154450,METHOD,lib/vf_common.cpp:<global>,TYPE_DECL,"static nonneg int getSizeOfType(const Token *typeTok, const Settings &settings)
    {
        const ValueType &valueType = ValueType::parseDecl(typeTok, settings);

        return getSizeOf(valueType, settings);
    }",5,11,lib/vf_common.cpp,"ValueFlow.getSizeOfType:int(Token*,Settings&)",<empty>,,false,113,118,getSizeOfType,,,1,"int(Token*,Settings&)"
111669154451,METHOD,lib/vf_common.cpp:<global>,TYPE_DECL,"Token * valueFlowSetConstantValue(Token *tok, const Settings &settings)
    {
        if ((tok->isNumber() && MathLib::isInt(tok->str())) || (tok->tokType() == Token::eChar)) {
            try {
                MathLib::bigint signedValue = MathLib::toBigNumber(tok);
                const ValueType* vt = tok->valueType();
                if (vt && vt->sign == ValueType::UNSIGNED && signedValue < 0 && getSizeOf(*vt, settings) < sizeof(MathLib::bigint)) {
                    MathLib::bigint minValue{}, maxValue{};
                    if (getMinMaxValues(tok->valueType(), settings.platform, minValue, maxValue))
                        signedValue += maxValue + 1;
                }
                Value value(signedValue);
                if (!tok->isTemplateArg())
                    value.setKnown();
                setTokenValue(tok, std::move(value), settings);
            } catch (const std::exception & /*e*/) {
                // Bad character literal
            }
        } else ...",5,22,lib/vf_common.cpp,"ValueFlow.valueFlowSetConstantValue:Token*(Token*,Settings&)",<empty>,,false,121,333,valueFlowSetConstantValue,,,1,"Token*(Token*,Settings&)"
111669154452,METHOD,lib/vf_common.cpp:<global>,TYPE_DECL,"Value castValue(Value value, const ValueType::Sign sign, nonneg int bit)
    {
        if (value.isFloatValue()) {
            value.valueType = Value::ValueType::INT;
            if (value.floatValue >= std::numeric_limits<int>::min() && value.floatValue <= std::numeric_limits<int>::max()) {
                value.intvalue = static_cast<MathLib::bigint>(value.floatValue);
            } else { // don't perform UB
                value.intvalue = 0;
            }
        }
        if (bit < MathLib::bigint_bits) {
            constexpr MathLib::biguint one = 1;
            value.intvalue &= (one << bit) - 1;
            if (sign == ValueType::Sign::SIGNED && value.intvalue & (one << (bit - 1))) {
                value.intvalue |= ~((one << bit) - 1ULL);
            }
        }
        return value;
    }",5,61,lib/vf_common.cpp,"ValueFlow.castValue:ValueFlow.Value(ValueFlow.Value,ValueType.Sign,int)",<empty>,,false,335,353,castValue,,,1,"ValueFlow.Value(ValueFlow.Value,ValueType.Sign,int)"
111669154453,METHOD,lib/vf_common.cpp:<global>,TYPE_DECL,"std::string debugString(const Value& v)
    {
        std::string kind;
        switch (v.valueKind) {

        case Value::ValueKind::Impossible:
        case Value::ValueKind::Known:
            kind = ""always"";
            break;
        case Value::ValueKind::Inconclusive:
            kind = ""inconclusive"";
            break;
        case Value::ValueKind::Possible:
            kind = ""possible"";
            break;
        }
        return kind + "" "" + v.toString();
    }",5,5,lib/vf_common.cpp,ValueFlow.debugString:string(ValueFlow.Value&),<empty>,,false,355,372,debugString,,,1,string(ValueFlow.Value&)
111669154454,METHOD,lib/vf_common.cpp:<global>,TYPE_DECL,"void setSourceLocation(Value& v,
                           SourceLocation ctx,
                           const Token* tok,
                           SourceLocation local)
    {
        std::string file = ctx.file_name();
        if (file.empty())
            return;
        std::string s = Path::stripDirectoryPart(file) + "":"" + std::to_string(ctx.line()) + "": "" + ctx.function_name() +
                        "" => "" + local.function_name() + "": "" + debugString(v);
        v.debugPath.emplace_back(tok, std::move(s));
    }",5,5,lib/vf_common.cpp,"ValueFlow.setSourceLocation:void(ValueFlow.Value&,SourceLocation,Token*,SourceLocation)",<empty>,,false,374,385,setSourceLocation,,,1,"void(ValueFlow.Value&,SourceLocation,Token*,SourceLocation)"
111669154455,METHOD,lib/vf_common.cpp:<global>,TYPE_DECL,"MathLib::bigint valueFlowGetStrLength(const Token* tok)
    {
        if (tok->tokType() == Token::eString)
            return Token::getStrLength(tok);
        if (astIsGenericChar(tok) || tok->tokType() == Token::eChar)
            return 1;
        if (const Value* v = tok->getKnownValue(Value::ValueType::CONTAINER_SIZE))
            return v->intvalue;
        if (const Value* v = tok->getKnownValue(Value::ValueType::TOK)) {
            if (v->tokvalue != tok)
                return valueFlowGetStrLength(v->tokvalue);
        }
        return 0;
    }",5,5,lib/vf_common.cpp,ValueFlow.valueFlowGetStrLength:longlongint(Token*),<empty>,,false,387,400,valueFlowGetStrLength,,,1,longlongint(Token*)
111669154456,METHOD,lib/vf_common.cpp:<global>,TYPE_DECL,<global>,1,1,lib/vf_common.cpp,lib/vf_common.cpp:<global>,<empty>,,false,1,401,<global>,,,1,
111669154457,METHOD,lib/vf_common.h:<global>,TYPE_DECL,<global>,1,1,lib/vf_common.h,lib/vf_common.h:<global>,<empty>,,false,1,59,<global>,,,1,
111669154458,METHOD,lib/vf_settokenvalue.cpp:<global>,TYPE_DECL,"static Library::Container::Yield getContainerYield(Token* tok, const Settings& settings, Token*& parent)
    {
        if (Token::Match(tok, "". %name% ("") && tok->astParent() == tok->tokAt(2) && tok->astOperand1() &&
            tok->astOperand1()->valueType()) {
            const Library::Container* c = getLibraryContainer(tok->astOperand1());
            parent = tok->astParent();
            return c ? c->getYield(tok->strAt(1)) : Library::Container::Yield::NO_YIELD;
        }
        if (Token::Match(tok->previous(), ""%name% ("")) {
            parent = tok;
            if (const Library::Function* f = settings.library.getFunction(tok->previous())) {
                return f->containerYield;
            }
        }
        return Library::Container::Yield::NO_YIELD;
    }",5,5,lib/vf_settokenvalue.cpp,"ValueFlow.getContainerYield:Library.Container.Yield(Token*,Settings&,Token*&)",<empty>,,false,50,65,getContainerYield,,,1,"Library.Container.Yield(Token*,Settings&,Token*&)"
111669154459,METHOD,lib/vf_settokenvalue.cpp:<global>,TYPE_DECL,"static Value truncateImplicitConversion(Token* parent, const Value& value, const Settings& settings)
    {
        if (!value.isIntValue() && !value.isFloatValue())
            return value;
        if (!parent)
            return value;
        if (!parent->isBinaryOp())
            return value;
        if (!parent->isConstOp())
            return value;
        if (!astIsIntegral(parent->astOperand1(), false))
            return value;
        if (!astIsIntegral(parent->astOperand2(), false))
            return value;
        const ValueType* vt1 = parent->astOperand1()->valueType();
        const ValueType* vt2 = parent->astOperand2()->valueType();
        // If the sign is the same there is no truncation
        if (vt1->sign == vt2->sign)
            return value;
        const size_t n1 = getSizeOf(*vt1, settings);
        const size_t n2 = getSizeOf(*vt2, settings);
        ValueType::Sign sign = ValueType::Sign::UNSIGNED;
        if (n1 < n2)
            sign = vt2->sign;
 ...",5,5,lib/vf_settokenvalue.cpp,"ValueFlow.truncateImplicitConversion:ValueFlow.Value(Token*,ValueFlow.Value&,Settings&)",<empty>,,false,67,96,truncateImplicitConversion,,,1,"ValueFlow.Value(Token*,ValueFlow.Value&,Settings&)"
111669154460,METHOD,lib/vf_settokenvalue.cpp:<global>,TYPE_DECL,"static const Token *getCastTypeStartToken(const Token *parent, const Settings& settings)
    {
        // TODO: This might be a generic utility function?
        if (!Token::Match(parent, ""{|(""))
            return nullptr;
        // Functional cast
        if (parent->isBinaryOp() && Token::Match(parent->astOperand1(), ""%type% (|{"") &&
            parent->astOperand1()->tokType() == Token::eType && astIsPrimitive(parent))
            return parent->astOperand1();
        if (parent->str() != ""("")
            return nullptr;
        if (!parent->astOperand2() && Token::Match(parent, ""( %name%|::"")) {
            const Token* ftok = parent->next();
            if (ftok->isStandardType())
                return ftok;
            if (Token::simpleMatch(ftok, ""::""))
                ftok = ftok->next();
            while (Token::Match(ftok, ""%name% ::""))
                ftok = ftok->tokAt(2);
            if (settings.library.isNotLibraryFunction(ftok))
                return parent->nex...",5,5,lib/vf_settokenvalue.cpp,"ValueFlow.getCastTypeStartToken:Token*(Token*,Settings&)",<empty>,,false,98,123,getCastTypeStartToken,,,1,"Token*(Token*,Settings&)"
111669154461,METHOD,lib/vf_settokenvalue.cpp:<global>,TYPE_DECL,"static bool isNumeric(const Value& value) {
        return value.isIntValue() || value.isFloatValue();
    }",5,5,lib/vf_settokenvalue.cpp,ValueFlow.isNumeric:bool(ValueFlow.Value&),<empty>,,false,125,127,isNumeric,,,1,bool(ValueFlow.Value&)
111669154462,METHOD,lib/vf_settokenvalue.cpp:<global>,TYPE_DECL,"static void setTokenValueCast(Token *parent, const ValueType &valueType, const Value &value, const Settings &settings)
    {
        if (valueType.pointer || value.isImpossible())
            setTokenValue(parent,value,settings);
        else if (valueType.type == ValueType::Type::CHAR)
            setTokenValue(parent, castValue(value, valueType.sign, settings.platform.char_bit), settings);
        else if (valueType.type == ValueType::Type::SHORT)
            setTokenValue(parent, castValue(value, valueType.sign, settings.platform.short_bit), settings);
        else if (valueType.type == ValueType::Type::INT)
            setTokenValue(parent, castValue(value, valueType.sign, settings.platform.int_bit), settings);
        else if (valueType.type == ValueType::Type::LONG)
            setTokenValue(parent, castValue(value, valueType.sign, settings.platform.long_bit), settings);
        else if (valueType.type == ValueType::Type::LONGLONG)
            setTokenValue(parent, castValue(v...",5,5,lib/vf_settokenvalue.cpp,"ValueFlow.setTokenValueCast:void(Token*,ValueType&,ValueFlow.Value&,Settings&)",<empty>,,false,129,157,setTokenValueCast,,,1,"void(Token*,ValueType&,ValueFlow.Value&,Settings&)"
111669154463,METHOD,lib/vf_settokenvalue.cpp:<global>,TYPE_DECL,"static bool isNonInvertibleOperation(const Token* tok)
    {
        return !Token::Match(tok, ""+|-"");
    }",5,5,lib/vf_settokenvalue.cpp,ValueFlow.isNonInvertibleOperation:bool(Token*),<empty>,,false,160,163,isNonInvertibleOperation,,,1,bool(Token*)
111669154464,METHOD,lib/vf_settokenvalue.cpp:<global>,TYPE_DECL,"static bool isComputableValue(const Token* parent, const Value& value)
    {
        const bool noninvertible = isNonInvertibleOperation(parent);
        if (noninvertible && value.isImpossible())
            return false;
        if (!value.isIntValue() && !value.isFloatValue() && !value.isTokValue() && !value.isIteratorValue())
            return false;
        if (value.isIteratorValue() && !Token::Match(parent, ""+|-""))
            return false;
        if (value.isTokValue() && (!parent->isComparisonOp() || !Token::Match(value.tokvalue, ""{|%str%"")))
            return false;
        return true;
    }",5,5,lib/vf_settokenvalue.cpp,"ValueFlow.isComputableValue:bool(Token*,ValueFlow.Value&)",<empty>,,false,165,177,isComputableValue,,,1,"bool(Token*,ValueFlow.Value&)"
111669154465,METHOD,lib/vf_settokenvalue.cpp:<global>,TYPE_DECL,"static bool isCompatibleValueTypes(Value::ValueType x, Value::ValueType y)
    {
        static const std::unordered_map<Value::ValueType,
                                        std::unordered_set<Value::ValueType, EnumClassHash>,
                                        EnumClassHash>
        compatibleTypes = {
            {Value::ValueType::INT,
             {Value::ValueType::FLOAT,
              Value::ValueType::SYMBOLIC,
              Value::ValueType::TOK}},
            {Value::ValueType::FLOAT, {Value::ValueType::INT}},
            {Value::ValueType::TOK, {Value::ValueType::INT}},
            {Value::ValueType::ITERATOR_START, {Value::ValueType::INT}},
            {Value::ValueType::ITERATOR_END, {Value::ValueType::INT}},
        };
        if (x == y)
            return true;
        auto it = compatibleTypes.find(x);
        if (it == compatibleTypes.end())
            return false;
        return it->second.count(y) > 0;
    }",5,5,lib/vf_settokenvalue.cpp,"ValueFlow.isCompatibleValueTypes:bool(ValueFlow.Value.ValueType,ValueFlow.Value.ValueType)",<empty>,,false,180,201,isCompatibleValueTypes,,,1,"bool(ValueFlow.Value.ValueType,ValueFlow.Value.ValueType)"
111669154466,METHOD,lib/vf_settokenvalue.cpp:<global>,TYPE_DECL,"static bool isCompatibleValues(const Value& value1, const Value& value2)
    {
        if (value1.isSymbolicValue() && value2.isSymbolicValue() && value1.tokvalue->exprId() != value2.tokvalue->exprId())
            return false;
        if (!isCompatibleValueTypes(value1.valueType, value2.valueType))
            return false;
        if (value1.isKnown() || value2.isKnown())
            return true;
        if (value1.isImpossible() || value2.isImpossible())
            return false;
        if (value1.varId == 0 || value2.varId == 0)
            return true;
        if (value1.varId == value2.varId && value1.varvalue == value2.varvalue && value1.isIntValue() && value2.isIntValue())
            return true;
        return false;
    }",5,5,lib/vf_settokenvalue.cpp,"ValueFlow.isCompatibleValues:bool(ValueFlow.Value&,ValueFlow.Value&)",<empty>,,false,203,218,isCompatibleValues,,,1,"bool(ValueFlow.Value&,ValueFlow.Value&)"
111669154467,METHOD,<empty>,<empty>,"[](const Token* p) {
                return !Token::simpleMatch(p, "","");
            }",58,13,lib/vf_settokenvalue.cpp,lib/vf_settokenvalue.cpp:<global>.ValueFlow.setTokenValue.<lambda>0:bool(Token*),<empty>,,false,248,250,<lambda>0,,,1,bool(Token*)
111669154468,METHOD,<empty>,<empty>,"[&](const Token *t) {
                    if (t->varId()) {
                        if (varId > 0 || value.varId != 0)
                            ret = true;
                        varId = t->varId();
                    } else if (t->str() == ""("" && Token::Match(t->previous(), ""%name%""))
                        ret = true; // function call
                    return ret ? ChildrenToVisit::done : ChildrenToVisit::op1_and_op2;
                }",31,17,lib/vf_settokenvalue.cpp,lib/vf_settokenvalue.cpp:<global>.ValueFlow.setTokenValue.<lambda>1:ChildrenToVisit(Token*),<empty>,,false,412,420,<lambda>1,,,1,ChildrenToVisit(Token*)
111669154469,METHOD,<empty>,<empty>,"[&]() -> MathLib::bigint {
                        return value1.isFloatValue() ? static_cast<MathLib::bigint>(value1.floatValue) : value1.intvalue;
                    }",44,21,lib/vf_settokenvalue.cpp,lib/vf_settokenvalue.cpp:<global>.ValueFlow.setTokenValue.<lambda>2:bigint(),<empty>,,false,501,503,<lambda>2,,,1,bigint()
111669154470,METHOD,<empty>,<empty>,"[&]() -> MathLib::bigint {
                        return value2.isFloatValue() ? static_cast<MathLib::bigint>(value2.floatValue) : value2.intvalue;
                    }",44,21,lib/vf_settokenvalue.cpp,lib/vf_settokenvalue.cpp:<global>.ValueFlow.setTokenValue.<lambda>3:bigint(),<empty>,,false,504,506,<lambda>3,,,1,bigint()
111669154471,METHOD,<empty>,<empty>,"[&](const Token* atok, const Token* btok) {
                                        return atok->getKnownIntValue() ==
                                        btok->getKnownIntValue();
                                    }",56,37,lib/vf_settokenvalue.cpp,"lib/vf_settokenvalue.cpp:<global>.ValueFlow.setTokenValue.<lambda>4:bool(Token*,Token*)",<empty>,,false,538,541,<lambda>4,,,1,"bool(Token*,Token*)"
111669154472,METHOD,lib/vf_settokenvalue.cpp:<global>,TYPE_DECL,"void setTokenValue(Token* tok,
                       Value value,
                       const Settings& settings,
                       SourceLocation loc)
    {
        // Skip setting values that are too big since its ambiguous
        if (!value.isImpossible() && value.isIntValue() && value.intvalue < 0 && astIsUnsigned(tok) &&
            getSizeOf(*tok->valueType(), settings) >= sizeof(MathLib::bigint))
            return;

        if (!value.isImpossible() && value.isIntValue())
            value = truncateImplicitConversion(tok->astParent(), value, settings);

        if (settings.debugnormal)
            setSourceLocation(value, loc, tok);

        if (!tok->addValue(value))
            return;

        if (value.path < 0)
            return;

        Token *parent = tok->astParent();
        if (!parent)
            return;

        if (Token::simpleMatch(parent, "","") && !parent->isInitComma() && astIsRHS(tok)) {
            const Token* callParent = findParent(parent, [...",5,16,lib/vf_settokenvalue.cpp,"ValueFlow.setTokenValue:void(Token*,ValueFlow.Value,Settings&,SourceLocation)",<empty>,,false,221,737,setTokenValue,,,1,"void(Token*,ValueFlow.Value,Settings&,SourceLocation)"
111669154473,METHOD,lib/vf_settokenvalue.cpp:<global>,TYPE_DECL,<global>,1,1,lib/vf_settokenvalue.cpp,lib/vf_settokenvalue.cpp:<global>,<empty>,,false,1,738,<global>,,,1,
111669154474,METHOD,lib/vf_settokenvalue.h:<global>,TYPE_DECL,<global>,1,1,lib/vf_settokenvalue.h,lib/vf_settokenvalue.h:<global>,<empty>,,false,1,36,<global>,,,1,
111669154475,METHOD,lib/vfvalue.cpp:<global>,TYPE_DECL,"Value::Value(const Token *c, MathLib::bigint val, Bound b)
        : bound(b),
        safe(false),
        conditional(false),
        macro(false),
        defaultArg(false),
        intvalue(val),
        varvalue(val),
        condition(c) {
        errorPath.emplace_back(c, ""Assuming that condition '"" + c->expressionString() + ""' is not redundant"");
    }",5,5,lib/vfvalue.cpp,"ValueFlow.Value.Value:ANY(Token*,MathLib.bigint,ValueFlow.Value.Bound)",<empty>,,false,29,39,Value,,,1,"ValueFlow.Value.Value:ANY(Token*,MathLib.bigint,ValueFlow.Value.Bound)(Token*,MathLib.bigint,ValueFlow.Value.Bound)"
111669154476,METHOD,lib/vfvalue.cpp:<global>,TYPE_DECL,"void Value::assumeCondition(const Token *tok) {
        condition = tok;
        errorPath.emplace_back(tok, ""Assuming that condition '"" + tok->expressionString() + ""' is not redundant"");
    }",5,5,lib/vfvalue.cpp,ValueFlow.Value.assumeCondition:void(Token*),<empty>,,false,41,44,assumeCondition,,,1,void(Token*)
111669154477,METHOD,lib/vfvalue.cpp:<global>,TYPE_DECL,"std::string Value::toString() const {
        std::stringstream ss;
        if (this->isImpossible())
            ss << ""!"";
        if (this->bound == Bound::Lower)
            ss << "">="";
        if (this->bound == Bound::Upper)
            ss << ""<="";
        switch (this->valueType) {
        case ValueType::INT:
            ss << this->intvalue;
            break;
        case ValueType::TOK:
            ss << this->tokvalue->str();
            break;
        case ValueType::FLOAT:
            ss << MathLib::toString(this->floatValue);
            break;
        case ValueType::MOVED:
            ss << toString(this->moveKind);
            break;
        case ValueType::UNINIT:
            ss << ""Uninit"";
            break;
        case ValueType::BUFFER_SIZE:
        case ValueType::CONTAINER_SIZE:
            ss << ""size="" << this->intvalue;
            break;
        case ValueType::ITERATOR_START:
            ss << ""start="" << this->intvalue;
            break;
        case...",5,5,lib/vfvalue.cpp,ValueFlow.Value.toString<const>:string(),<empty>,,false,46,99,toString,,,1,string()
111669154478,METHOD,lib/vfvalue.cpp:<global>,TYPE_DECL,"std::string Value::infoString() const {
        switch (valueType) {
        case ValueType::INT:
            return MathLib::toString(intvalue);
        case ValueType::TOK:
            return tokvalue->str();
        case ValueType::FLOAT:
            return MathLib::toString(floatValue);
        case ValueType::MOVED:
            return ""<Moved>"";
        case ValueType::UNINIT:
            return ""<Uninit>"";
        case ValueType::BUFFER_SIZE:
        case ValueType::CONTAINER_SIZE:
            return ""size="" + MathLib::toString(intvalue);
        case ValueType::ITERATOR_START:
            return ""start="" + MathLib::toString(intvalue);
        case ValueType::ITERATOR_END:
            return ""end="" + MathLib::toString(intvalue);
        case ValueType::LIFETIME:
            return ""lifetime="" + tokvalue->str();
        case ValueType::SYMBOLIC:
        {
            std::string result = ""symbolic="" + tokvalue->expressionString();
            if (intvalue > 0)
                r...",5,5,lib/vfvalue.cpp,ValueFlow.Value.infoString<const>:string(),<empty>,,false,101,133,infoString,,,1,string()
111669154479,METHOD,lib/vfvalue.cpp:<global>,TYPE_DECL,"const char *Value::toString(MoveKind moveKind) {
        switch (moveKind) {
        case MoveKind::NonMovedVariable:
            return ""NonMovedVariable"";
        case MoveKind::MovedVariable:
            return ""MovedVariable"";
        case MoveKind::ForwardedVariable:
            return ""ForwardedVariable"";
        }
        return """";
    }",5,5,lib/vfvalue.cpp,ValueFlow.Value.toString:char*(ValueFlow.Value.MoveKind),<empty>,,false,135,145,toString,,,1,char*(ValueFlow.Value.MoveKind)
111669154480,METHOD,lib/vfvalue.cpp:<global>,TYPE_DECL,"const char *Value::toString(LifetimeKind lifetimeKind) {
        switch (lifetimeKind) {
        case LifetimeKind::Object:
            return ""Object"";
        case LifetimeKind::SubObject:
            return ""SubObject"";
        case LifetimeKind::Lambda:
            return ""Lambda"";
        case LifetimeKind::Iterator:
            return ""Iterator"";
        case LifetimeKind::Address:
            return ""Address"";
        }
        return """";
    }",5,5,lib/vfvalue.cpp,ValueFlow.Value.toString:char*(ValueFlow.Value.LifetimeKind),<empty>,,false,147,161,toString,,,1,char*(ValueFlow.Value.LifetimeKind)
111669154481,METHOD,lib/vfvalue.cpp:<global>,TYPE_DECL,"bool Value::sameToken(const Token *tok1, const Token *tok2) {
        if (tok1 == tok2)
            return true;
        if (!tok1)
            return false;
        if (tok1->exprId() == 0 || tok2->exprId() == 0)
            return false;
        return tok1->exprId() == tok2->exprId();
    }",5,5,lib/vfvalue.cpp,"ValueFlow.Value.sameToken:bool(Token*,Token*)",<empty>,,false,163,171,sameToken,,,1,"bool(Token*,Token*)"
111669154482,METHOD,lib/vfvalue.cpp:<global>,TYPE_DECL,"const char *Value::toString(LifetimeScope lifetimeScope) {
        switch (lifetimeScope) {
        case LifetimeScope::Local:
            return ""Local"";
        case LifetimeScope::Argument:
            return ""Argument"";
        case LifetimeScope::SubFunction:
            return ""SubFunction"";
        case LifetimeScope::ThisPointer:
            return ""ThisPointer"";
        case LifetimeScope::ThisValue:
            return ""ThisValue"";
        }
        return """";
    }",5,5,lib/vfvalue.cpp,ValueFlow.Value.toString:char*(ValueFlow.Value.LifetimeScope),<empty>,,false,173,187,toString,,,1,char*(ValueFlow.Value.LifetimeScope)
111669154483,METHOD,lib/vfvalue.cpp:<global>,TYPE_DECL,"const char *Value::toString(Bound bound) {
        switch (bound) {
        case Bound::Point:
            return ""Point"";
        case Bound::Upper:
            return ""Upper"";
        case Bound::Lower:
            return ""Lower"";
        }
        return """";
    }",5,5,lib/vfvalue.cpp,ValueFlow.Value.toString:char*(ValueFlow.Value.Bound),<empty>,,false,189,199,toString,,,1,char*(ValueFlow.Value.Bound)
111669154484,METHOD,lib/vfvalue.cpp:<global>,TYPE_DECL,<global>,1,1,lib/vfvalue.cpp,lib/vfvalue.cpp:<global>,<empty>,,false,1,200,<global>,,,1,
111669154485,METHOD,lib/vfvalue.h:<global>,TYPE_DECL,<global>,1,1,lib/vfvalue.h,lib/vfvalue.h:<global>,<empty>,,false,1,436,<global>,,,1,
111669154486,METHOD,lib/xml.h:<global>,TYPE_DECL,<global>,1,1,lib/xml.h,lib/xml.h:<global>,<empty>,,false,1,51,<global>,,,1,
111669154487,METHOD,DummyErrorLogger,TYPE_DECL,"void reportOut(const std::string& /*outmsg*/, Color /*c*/) override {}",5,74,oss-fuzz/main.cpp,"DummyErrorLogger.reportOut:void(std.string&,Color)",<empty>,,false,41,41,reportOut,,,1,"void(std.string&,Color)"
111669154488,METHOD,DummyErrorLogger,TYPE_DECL,void reportErr(const ErrorMessage& /*msg*/) override {},5,59,oss-fuzz/main.cpp,DummyErrorLogger.reportErr:void(ErrorMessage&),<empty>,,false,42,42,reportErr,,,2,void(ErrorMessage&)
111669154489,METHOD,DummyErrorLogger,TYPE_DECL,"void reportProgress(const std::string& /*filename*/,
                        const char /*stage*/[],
                        const std::size_t /*value*/) override {}",5,64,oss-fuzz/main.cpp,"DummyErrorLogger.reportProgress:void(std.string&,char[],std.size_t)",<empty>,,false,43,45,reportProgress,,,3,"void(std.string&,char[],std.size_t)"
111669154490,METHOD,oss-fuzz/main.cpp:<global>,TYPE_DECL,<global>,1,1,oss-fuzz/main.cpp,oss-fuzz/main.cpp:<global>,<empty>,,false,1,103,<global>,,,1,
111669154491,METHOD,oss-fuzz/main.cpp:<global>,TYPE_DECL,"static Settings create_settings()
{
    // TODO: load std.cfg
    Settings s;
    s.addEnabled(""all"");
    s.certainty.setEnabled(Certainty::inconclusive, true);
    return s;
}",1,1,oss-fuzz/main.cpp,create_settings:Settings(),<empty>,,false,48,55,create_settings,,,1,Settings()
111669154492,METHOD,oss-fuzz/main.cpp:<global>,TYPE_DECL,"static void doCheck(const std::string& code)
{
    Suppressions supprs;
    CppCheck cppcheck(s_settings, supprs, s_errorLogger, false, nullptr);
    cppcheck.check(s_file, code);
}",1,1,oss-fuzz/main.cpp,doCheck:void(std.string&),<empty>,,false,60,65,doCheck,,,1,void(std.string&)
111669154493,METHOD,oss-fuzz/main.cpp:<global>,TYPE_DECL,"int LLVMFuzzerTestOneInput(const uint8_t *data, size_t dataSize)
{
    if (dataSize < 10000) {
        const std::string code = generateCode2(data, dataSize);
        doCheck(code);
    }
    return 0;
}",1,1,oss-fuzz/main.cpp,LLVMFuzzerTestOneInput,<empty>,,false,70,77,LLVMFuzzerTestOneInput,,,1,"int(uint8_t*,size_t)"
111669154494,METHOD,oss-fuzz/main.cpp:<global>,TYPE_DECL,"int main(int argc, char * argv[])
{
    if (argc < 2 || argc > 3)
        return EXIT_FAILURE;

    std::ifstream f(argv[1]);
    if (!f.is_open())
        return EXIT_FAILURE;

    std::ostringstream oss;
    oss << f.rdbuf();

    if (!f.good())
        return EXIT_FAILURE;

    const int cnt = (argc == 3) ? std::stoi(argv[2]) : 1;

    const std::string code = oss.str();
    for (int i = 0; i < cnt; ++i)
        doCheck(code);

    return EXIT_SUCCESS;
}",1,1,oss-fuzz/main.cpp,"main<duplicate>1:int(int,char[]*)",<empty>,,false,79,101,main,,,1,"int(int,char[]*)"
111669154495,METHOD,oss-fuzz/translate.cpp:<global>,TYPE_DECL,"int main(int argc, char **argv)
{
    const char *filename = argc==2 ? argv[1] : nullptr;

    if (!filename) {
        std::cout << ""Invalid args, no filename\\n"";
        return 1;
    }

    std::ifstream f(filename);
    if (!f.is_open()) {
        std::cout << ""failed to open file:"" << filename << ""\\n"";
        return 1;
    }

    std::string str((std::istreambuf_iterator<char>(f)),
                    std::istreambuf_iterator<char>());

    std::cout << generateCode2(reinterpret_cast<const uint8_t *>(str.data()), str.size()) << std::endl;

    return 0;
}",1,1,oss-fuzz/translate.cpp,"main:int(int,char**)",<empty>,,false,24,45,main,,,1,"int(int,char**)"
111669154496,METHOD,oss-fuzz/translate.cpp:<global>,TYPE_DECL,<global>,1,1,oss-fuzz/translate.cpp,oss-fuzz/translate.cpp:<global>,<empty>,,false,1,45,<global>,,,1,
111669154497,METHOD,oss-fuzz/type2.cpp:<global>,TYPE_DECL,"static int getValue(const uint8_t *data, size_t dataSize, uint8_t maxValue, bool *done = nullptr)
{
    static size_t pos;    // current ""data"" position
    static int dataValue; // value extracted from data
    static int ones;      // ones. This variable tracks if we need to add more stuff in ""dataValue"".

    // Shift more bits from ""data"" into ""dataValue"" if needed
    while (pos < dataSize && ones < 0xFFFF) {
        ones = (ones << 8) | 0xff;
        dataValue = (dataValue << 8) | data[pos];
        pos++;
    }

    if (done)
        *done = (ones == 0);

    if (maxValue == 0)
        return 0;

    // Shift out info from ""dataValue"" using % . Using & and >> would work but then we are limited to ""power of 2"" max value.
    const int ret = dataValue % maxValue;
    ones /= maxValue;
    dataValue /= maxValue;
    return ret;
}",1,1,oss-fuzz/type2.cpp,"getValue:int(uint8_t*,size_t,uint8_t,bool*)",<empty>,,false,23,47,getValue,,,1,"int(uint8_t*,size_t,uint8_t,bool*)"
111669154498,METHOD,oss-fuzz/type2.cpp:<global>,TYPE_DECL,<global>,1,1,oss-fuzz/type2.cpp,oss-fuzz/type2.cpp:<global>,<empty>,,false,1,230,<global>,,,1,
111669154499,METHOD,oss-fuzz/type2.cpp:<global>,TYPE_DECL,"static std::string generateExpression2_lvalue(const uint8_t *data, size_t dataSize)
{
    return ""var"" + std::to_string(1 + getValue(data, dataSize, 5));
}",1,1,oss-fuzz/type2.cpp,"generateExpression2_lvalue:string(uint8_t*,size_t)",<empty>,,false,49,52,generateExpression2_lvalue,,,1,"string(uint8_t*,size_t)"
111669154500,METHOD,oss-fuzz/type2.cpp:<global>,TYPE_DECL,"static std::string generateExpression2_Op(const uint8_t *data, size_t dataSize, uint8_t numberOfGlobalConstants)
{
    std::string code;
    switch (getValue(data, dataSize, 3)) {
    case 0:
        code += generateExpression2_lvalue(data, dataSize);
        break;
    case 1:
        code += ""globalconstant"";
        code += (1 + getValue(data, dataSize, numberOfGlobalConstants));
        break;
    case 2:
        code += (getValue(data, dataSize, 0x80) * 0x80 + getValue(data, dataSize, 0x80));
        break;
    }
    return code;
}",1,1,oss-fuzz/type2.cpp,"generateExpression2_Op:string(uint8_t*,size_t,uint8_t)",<empty>,,false,54,70,generateExpression2_Op,,,1,"string(uint8_t*,size_t,uint8_t)"
111669154501,METHOD,oss-fuzz/type2.cpp:<global>,TYPE_DECL,"static std::string generateExpression2_Expr(const uint8_t *data, size_t dataSize, uint8_t numberOfGlobalConstants, int depth=0)
{
    ++depth;
    const int type = (depth > 3) ? 0 : getValue(data, dataSize, 3);
    const char binop[] = ""=<>+-*/%&|^"";
    const char *unop[] = {""++"",""--"",""()"",""~""};

    switch (type) {
    case 0:
        return generateExpression2_Op(data, dataSize, numberOfGlobalConstants);
    case 1: {
        const char op = binop[getValue(data,dataSize,sizeof(binop)-1)];
        const std::string lhs = (op == '=') ?
                                generateExpression2_lvalue(data, dataSize) :
                                generateExpression2_Expr(data, dataSize, numberOfGlobalConstants, depth);
        const std::string rhs = generateExpression2_Expr(data, dataSize, numberOfGlobalConstants, depth);

        std::string ret = lhs + op + rhs;
        if (depth > 1 && op == '=')
            ret = ""("" + ret + "")"";

        return ret;
    }
    case 2: {
        co...",1,1,oss-fuzz/type2.cpp,"generateExpression2_Expr:string(uint8_t*,size_t,uint8_t,int)",<empty>,,false,72,108,generateExpression2_Expr,,,1,"string(uint8_t*,size_t,uint8_t,int)"
111669154502,METHOD,oss-fuzz/type2.cpp:<global>,TYPE_DECL,"static std::string generateExpression2_Cond(const uint8_t *data, size_t dataSize, uint8_t numberOfGlobalConstants)
{
    const char *comp[] = {""=="", ""!="", ""<"", ""<="", "">"", "">=""};
    const int i = getValue(data, dataSize, 6);
    const std::string lhs = generateExpression2_Expr(data, dataSize, numberOfGlobalConstants);
    const std::string rhs = generateExpression2_Expr(data, dataSize, numberOfGlobalConstants);
    return lhs + comp[i] + rhs;
}",1,1,oss-fuzz/type2.cpp,"generateExpression2_Cond:string(uint8_t*,size_t,uint8_t)",<empty>,,false,111,118,generateExpression2_Cond,,,1,"string(uint8_t*,size_t,uint8_t)"
111669154503,METHOD,oss-fuzz/type2.cpp:<global>,TYPE_DECL,"static std::string functionStart()
{
    static int functionNumber;
    return ""int f"" + std::to_string(++functionNumber) + ""()\\n""
           ""{\\n"";
}",1,1,oss-fuzz/type2.cpp,functionStart:string(),<empty>,,false,121,126,functionStart,,,1,string()
111669154504,METHOD,oss-fuzz/type2.cpp:<global>,TYPE_DECL,"static std::string generateExpression2_conditionalCode(const std::string &indent,
                                                       const uint8_t *data,
                                                       size_t dataSize,
                                                       uint8_t numberOfGlobalConstants)
{
    std::string code;

    if (indent.empty())
        code += functionStart();
    else {
        code += indent;
        code += ""{\\n"";
    }

    for (int line = 0; line < 4 || indent.empty(); ++line) {
        bool done = false;
        const int type1 = getValue(data, dataSize, 8, &done);
        if (done)
            break;

        const int mostLikelyType = (line >= 2) ? 4 : 0;  // should var assignment or return be more likely?

        const int type2 = (indent.size() >= 12) ?
                          mostLikelyType :  // max indentation, no inner conditions
                          ((type1 >= 5) ? mostLikelyType : type1);

        if (type2 == 0) {
       ...",1,1,oss-fuzz/type2.cpp,"generateExpression2_conditionalCode:string(std.string&,uint8_t*,size_t,uint8_t)",<empty>,,false,128,204,generateExpression2_conditionalCode,,,1,"string(std.string&,uint8_t*,size_t,uint8_t)"
111669154505,METHOD,oss-fuzz/type2.cpp:<global>,TYPE_DECL,"std::string generateCode2(const uint8_t *data, size_t dataSize)
{
    std::string code;

    // create global constants
    constexpr uint8_t numberOfGlobalConstants = 0;
    /*
       const int numberOfGlobalConstants = getValue(data, dataSize, 5);
       for (int nr = 1; nr <= numberOfGlobalConstants; nr++) {
        const char *types[4] = {""char"", ""int"", ""long long"", ""float""};
        code << ""const "" << types[getValue(data, dataSize, 4)] << "" globalconstant"" << nr << "" = "" << generateExpression2_Expr(data, dataSize, nr - 1) << "";\\n"";
       }
     */

    code += ""int var1 = 1;\\n""
            ""int var2 = 0;\\n""
            ""int var3 = 1;\\n""
            ""int var4 = 0;\\n""
            ""int var5 = -1;\\n\\n"";

    code += generateExpression2_conditionalCode("""", data, dataSize, numberOfGlobalConstants);

    return code;
}",1,1,oss-fuzz/type2.cpp,"generateCode2:string(uint8_t*,size_t)",<empty>,,false,206,229,generateCode2,,,1,"string(uint8_t*,size_t)"
111669154506,METHOD,oss-fuzz/type2.h:<global>,TYPE_DECL,<global>,1,65,oss-fuzz/type2.h,oss-fuzz/type2.h:<global>,<empty>,,false,1,24,<global>,,,1,
111669154507,METHOD,samples/AssignmentAddressToInteger/bad.c:<global>,TYPE_DECL,"static int foo(int *p)
{
    int a = p;
    return a + 4;
}",1,1,samples/AssignmentAddressToInteger/bad.c,foo,<empty>,,false,1,5,foo,,,1,int(int*)
111669154508,METHOD,samples/AssignmentAddressToInteger/bad.c:<global>,TYPE_DECL,<global>,1,1,samples/AssignmentAddressToInteger/bad.c,samples/AssignmentAddressToInteger/bad.c:<global>,<empty>,,false,1,12,<global>,,,1,
111669154509,METHOD,samples/AssignmentAddressToInteger/bad.c:<global>,TYPE_DECL,"int main()
{
    int i[10];
    foo(i);
    return 0;
}",1,1,samples/AssignmentAddressToInteger/bad.c,main,<empty>,,false,7,12,main,,,1,int()
111669154510,METHOD,samples/AssignmentAddressToInteger/good.c:<global>,TYPE_DECL,"static int* foo(int *p)
{
    return p + 4;
}",1,1,samples/AssignmentAddressToInteger/good.c,foo<duplicate>0,<empty>,,false,1,4,foo,,,1,int*(int*)
111669154511,METHOD,samples/AssignmentAddressToInteger/good.c:<global>,TYPE_DECL,<global>,1,1,samples/AssignmentAddressToInteger/good.c,samples/AssignmentAddressToInteger/good.c:<global>,<empty>,,false,1,11,<global>,,,1,
111669154512,METHOD,samples/AssignmentAddressToInteger/good.c:<global>,TYPE_DECL,"int main()
{
    int i[10];
    foo(i);
    return 0;
}",1,1,samples/AssignmentAddressToInteger/good.c,main<duplicate>0,<empty>,,false,6,11,main,,,1,int()
111669154513,METHOD,samples/accessMoved/bad.cpp:<global>,TYPE_DECL,"int main()
{
    std::string s = ""test"";
    foo(std::move(s));

    std::cout << s << std::endl;
}",1,1,samples/accessMoved/bad.cpp,main<duplicate>0:int(),<empty>,,false,3,9,main,,,1,int()
111669154514,METHOD,samples/accessMoved/bad.cpp:<global>,TYPE_DECL,<global>,1,1,samples/accessMoved/bad.cpp,samples/accessMoved/bad.cpp:<global>,<empty>,,false,1,9,<global>,,,1,
111669154515,METHOD,samples/accessMoved/good.cpp:<global>,TYPE_DECL,"int main()
{
    std::string s = ""test"";
    foo(s);

    std::cout << s << std::endl;
}",1,1,samples/accessMoved/good.cpp,main<duplicate>1:int(),<empty>,,false,3,9,main,,,1,int()
111669154516,METHOD,samples/accessMoved/good.cpp:<global>,TYPE_DECL,<global>,1,1,samples/accessMoved/good.cpp,samples/accessMoved/good.cpp:<global>,<empty>,,false,1,9,<global>,,,1,
111669154517,METHOD,samples/arrayIndexOutOfBounds_1/bad.c:<global>,TYPE_DECL,"int main()
{
    a[0] = 0;
    a[1] = 0;
    a[2] = 0;
    return a[0];
}",1,1,samples/arrayIndexOutOfBounds_1/bad.c,main<duplicate>1,<empty>,,false,3,9,main,,,1,int()
111669154518,METHOD,samples/arrayIndexOutOfBounds_1/bad.c:<global>,TYPE_DECL,<global>,1,1,samples/arrayIndexOutOfBounds_1/bad.c,samples/arrayIndexOutOfBounds_1/bad.c:<global>,<empty>,,false,1,9,<global>,,,1,
111669154519,METHOD,samples/arrayIndexOutOfBounds_1/good.c:<global>,TYPE_DECL,"int main()
{
    a[0] = 0;
    a[1] = 0;
    a[2] = 0;
    return 0;
}",1,1,samples/arrayIndexOutOfBounds_1/good.c,main<duplicate>2,<empty>,,false,3,9,main,,,1,int()
111669154520,METHOD,samples/arrayIndexOutOfBounds_1/good.c:<global>,TYPE_DECL,<global>,1,1,samples/arrayIndexOutOfBounds_1/good.c,samples/arrayIndexOutOfBounds_1/good.c:<global>,<empty>,,false,1,9,<global>,,,1,
111669154521,METHOD,samples/arrayIndexOutOfBounds_2/bad.c:<global>,TYPE_DECL,"int main()
{
    int a[2];
    int i;
    for (i = 0; i < 3; i++)
        a[i] = 0;
    return a[0];
}",1,1,samples/arrayIndexOutOfBounds_2/bad.c,main<duplicate>3,<empty>,,false,1,8,main,,,1,int()
111669154522,METHOD,samples/arrayIndexOutOfBounds_2/bad.c:<global>,TYPE_DECL,<global>,1,1,samples/arrayIndexOutOfBounds_2/bad.c,samples/arrayIndexOutOfBounds_2/bad.c:<global>,<empty>,,false,1,8,<global>,,,1,
111669154523,METHOD,samples/arrayIndexOutOfBounds_2/good.c:<global>,TYPE_DECL,"int main()
{
    int a[3];
    int i;
    for (i = 0; i < 3; i++)
        a[i] = 0;
    return a[0];
}",1,1,samples/arrayIndexOutOfBounds_2/good.c,main<duplicate>4,<empty>,,false,1,8,main,,,1,int()
111669154524,METHOD,samples/arrayIndexOutOfBounds_2/good.c:<global>,TYPE_DECL,<global>,1,1,samples/arrayIndexOutOfBounds_2/good.c,samples/arrayIndexOutOfBounds_2/good.c:<global>,<empty>,,false,1,8,<global>,,,1,
111669154525,METHOD,samples/autoVariables/bad.c:<global>,TYPE_DECL,"static void foo(int **a)
{
    int b = 1;
    *a = &b;
}",1,1,samples/autoVariables/bad.c,foo<duplicate>1,<empty>,,false,1,5,foo,,,1,void(int**)
111669154526,METHOD,samples/autoVariables/bad.c:<global>,TYPE_DECL,<global>,1,1,samples/autoVariables/bad.c,samples/autoVariables/bad.c:<global>,<empty>,,false,1,12,<global>,,,1,
111669154527,METHOD,samples/autoVariables/bad.c:<global>,TYPE_DECL,"int main()
{
    int *c;
    foo(&c);
    return 0;
}",1,1,samples/autoVariables/bad.c,main<duplicate>5,<empty>,,false,7,12,main,,,1,int()
111669154528,METHOD,samples/autoVariables/good.c:<global>,TYPE_DECL,"static void foo(int **a)
{
    int b = 1;
    **a = b;
}",1,1,samples/autoVariables/good.c,foo<duplicate>2,<empty>,,false,1,5,foo,,,1,void(int**)
111669154529,METHOD,samples/autoVariables/good.c:<global>,TYPE_DECL,<global>,1,1,samples/autoVariables/good.c,samples/autoVariables/good.c:<global>,<empty>,,false,1,13,<global>,,,1,
111669154530,METHOD,samples/autoVariables/good.c:<global>,TYPE_DECL,"int main()
{
    int b;
    int *c = &b;
    foo(&c);
    return 0;
}",1,1,samples/autoVariables/good.c,main<duplicate>6,<empty>,,false,7,13,main,,,1,int()
111669154531,METHOD,samples/bufferAccessOutOfBounds/bad.c:<global>,TYPE_DECL,"int main()
{
    char str[5];
    strcpy(str, ""0123456789abcdef"");
    return 0;
}",1,1,samples/bufferAccessOutOfBounds/bad.c,main<duplicate>7,<empty>,,false,2,7,main,,,1,int()
111669154532,METHOD,samples/bufferAccessOutOfBounds/bad.c:<global>,TYPE_DECL,<global>,1,1,samples/bufferAccessOutOfBounds/bad.c,samples/bufferAccessOutOfBounds/bad.c:<global>,<empty>,,false,1,7,<global>,,,1,
111669154533,METHOD,samples/bufferAccessOutOfBounds/good.c:<global>,TYPE_DECL,"int main()
{
    char str[10];
    snprintf(str, 10, ""%s"", ""abc"");
    return 0;
}",1,1,samples/bufferAccessOutOfBounds/good.c,main<duplicate>8,<empty>,,false,2,7,main,,,1,int()
111669154534,METHOD,samples/bufferAccessOutOfBounds/good.c:<global>,TYPE_DECL,<global>,1,1,samples/bufferAccessOutOfBounds/good.c,samples/bufferAccessOutOfBounds/good.c:<global>,<empty>,,false,1,7,<global>,,,1,
111669154535,METHOD,samples/incorrectLogicOperator/bad.c:<global>,TYPE_DECL,"static void foo(int x) {
    if (x >= 0 || x <= 10) {}
}",1,1,samples/incorrectLogicOperator/bad.c,foo<duplicate>3,<empty>,,false,2,4,foo,,,1,void(int)
111669154536,METHOD,samples/incorrectLogicOperator/bad.c:<global>,TYPE_DECL,<global>,1,12,samples/incorrectLogicOperator/bad.c,samples/incorrectLogicOperator/bad.c:<global>,<empty>,,false,1,6,<global>,,,1,
111669154537,METHOD,samples/incorrectLogicOperator/good.c:<global>,TYPE_DECL,"static void foo(int x) {
    if (x >= 0 && x <= 10) {}
}",1,1,samples/incorrectLogicOperator/good.c,foo<duplicate>4,<empty>,,false,2,4,foo,,,1,void(int)
111669154538,METHOD,samples/incorrectLogicOperator/good.c:<global>,TYPE_DECL,<global>,1,12,samples/incorrectLogicOperator/good.c,samples/incorrectLogicOperator/good.c:<global>,<empty>,,false,1,6,<global>,,,1,
111669154539,METHOD,samples/invalidContainer/bad.cpp:<global>,TYPE_DECL,"int main()
{
    std::vector<int> items;
    items.push_back(1);
    items.push_back(2);
    items.push_back(3);
    std::vector<int>::iterator iter;
    for (iter = items.begin(); iter != items.end(); ++iter) {
        if (*iter == 2) {
            items.erase(iter);
        }
    }
}",1,1,samples/invalidContainer/bad.cpp,main<duplicate>2:int(),<empty>,,false,2,14,main,,,1,int()
111669154540,METHOD,samples/invalidContainer/bad.cpp:<global>,TYPE_DECL,<global>,1,1,samples/invalidContainer/bad.cpp,samples/invalidContainer/bad.cpp:<global>,<empty>,,false,1,14,<global>,,,1,
111669154541,METHOD,samples/invalidContainer/good.cpp:<global>,TYPE_DECL,"int main()
{
    std::vector<int> items;
    items.push_back(1);
    items.push_back(2);
    items.push_back(3);
    std::vector<int>::iterator iter;
    for (iter = items.begin(); iter != items.end();) {
        if (*iter == 2) {
            iter = items.erase(iter);
        } else {
            ++iter;
        }
    }
}",1,1,samples/invalidContainer/good.cpp,main<duplicate>3:int(),<empty>,,false,2,16,main,,,1,int()
111669154542,METHOD,samples/invalidContainer/good.cpp:<global>,TYPE_DECL,<global>,1,1,samples/invalidContainer/good.cpp,samples/invalidContainer/good.cpp:<global>,<empty>,,false,1,16,<global>,,,1,
111669154543,METHOD,samples/memleak/bad.c:<global>,TYPE_DECL,"int main()
{
    int result = 0;
    char *a = malloc(10);
    if (a) {
        a[0] = 0;
        result = a[0];
    }
    return result;
}",1,1,samples/memleak/bad.c,main<duplicate>9,<empty>,,false,2,11,main,,,1,int()
111669154544,METHOD,samples/memleak/bad.c:<global>,TYPE_DECL,<global>,1,1,samples/memleak/bad.c,samples/memleak/bad.c:<global>,<empty>,,false,1,11,<global>,,,1,
111669154545,METHOD,samples/memleak/good.c:<global>,TYPE_DECL,"int main()
{
    int result = 0;
    char *a = malloc(10);
    if (a) {
        a[0] = 0;
        result = a[0];
        free(a);
    }
    return result;
}",1,1,samples/memleak/good.c,main<duplicate>10,<empty>,,false,2,12,main,,,1,int()
111669154546,METHOD,samples/memleak/good.c:<global>,TYPE_DECL,<global>,1,1,samples/memleak/good.c,samples/memleak/good.c:<global>,<empty>,,false,1,12,<global>,,,1,
111669154547,METHOD,samples/multiCondition/bad.c:<global>,TYPE_DECL,"static void f(bool b)
{
    if (b) {}
    else if (!b) {}
}",1,1,samples/multiCondition/bad.c,f,<empty>,,false,1,5,f,,,1,void(bool)
111669154548,METHOD,samples/multiCondition/bad.c:<global>,TYPE_DECL,<global>,1,1,samples/multiCondition/bad.c,samples/multiCondition/bad.c:<global>,<empty>,,false,1,11,<global>,,,1,
111669154549,METHOD,samples/multiCondition/bad.c:<global>,TYPE_DECL,"int main()
{
    f(true);
    return 0;
}",1,1,samples/multiCondition/bad.c,main<duplicate>11,<empty>,,false,7,11,main,,,1,int()
111669154550,METHOD,samples/multiCondition/good.c:<global>,TYPE_DECL,"static void f(bool b)
{
    if (b) {}
    else {}
}",1,1,samples/multiCondition/good.c,f<duplicate>0,<empty>,,false,1,5,f,,,1,void(bool)
111669154551,METHOD,samples/multiCondition/good.c:<global>,TYPE_DECL,<global>,1,1,samples/multiCondition/good.c,samples/multiCondition/good.c:<global>,<empty>,,false,1,11,<global>,,,1,
111669154552,METHOD,samples/multiCondition/good.c:<global>,TYPE_DECL,"int main()
{
    f(true);
    return 0;
}",1,1,samples/multiCondition/good.c,main<duplicate>12,<empty>,,false,7,11,main,,,1,int()
111669154553,METHOD,C,TYPE_DECL,"explicit C(std::string s)
    : _s(s)
    {
    }",5,5,samples/passedByValue_1/bad.cpp,C.C:ANY(std.string),<empty>,,false,4,7,C,,,1,C.C:ANY(std.string)(std.string)
111669154554,METHOD,samples/passedByValue_1/bad.cpp:<global>,TYPE_DECL,<global>,1,2,samples/passedByValue_1/bad.cpp,samples/passedByValue_1/bad.cpp:<global>,<empty>,,false,1,11,<global>,,,1,
111669154555,METHOD,C,TYPE_DECL,"explicit C(std::string s)
    : _s(std::move(s))
    {
    }",5,5,samples/passedByValue_1/good.cpp,C.C:ANY(std.string)<duplicate>0,<empty>,,false,4,7,C,,,1,C.C:ANY(std.string)(std.string)
111669154556,METHOD,samples/passedByValue_1/good.cpp:<global>,TYPE_DECL,<global>,1,2,samples/passedByValue_1/good.cpp,samples/passedByValue_1/good.cpp:<global>,<empty>,,false,1,11,<global>,,,1,
111669154557,METHOD,samples/passedByValue_2/bad.cpp:<global>,TYPE_DECL,"bool foo(std::string s)
{
    return s.empty();
}",1,1,samples/passedByValue_2/bad.cpp,foo:bool(std.string),<empty>,,false,1,4,foo,,,1,bool(std.string)
111669154558,METHOD,samples/passedByValue_2/bad.cpp:<global>,TYPE_DECL,<global>,1,1,samples/passedByValue_2/bad.cpp,samples/passedByValue_2/bad.cpp:<global>,<empty>,,false,1,10,<global>,,,1,
111669154559,METHOD,samples/passedByValue_2/bad.cpp:<global>,TYPE_DECL,"int main()
{
    std::string s;
    foo(s);
}",1,1,samples/passedByValue_2/bad.cpp,main<duplicate>4:int(),<empty>,,false,6,10,main,,,1,int()
111669154560,METHOD,samples/passedByValue_2/good.cpp:<global>,TYPE_DECL,"bool foo(const std::string& s)
{
    return s.empty();
}",1,1,samples/passedByValue_2/good.cpp,foo:bool(std.string&),<empty>,,false,1,4,foo,,,1,bool(std.string&)
111669154561,METHOD,samples/passedByValue_2/good.cpp:<global>,TYPE_DECL,<global>,1,1,samples/passedByValue_2/good.cpp,samples/passedByValue_2/good.cpp:<global>,<empty>,,false,1,10,<global>,,,1,
111669154562,METHOD,samples/passedByValue_2/good.cpp:<global>,TYPE_DECL,"int main()
{
    std::string s;
    foo(s);
}",1,1,samples/passedByValue_2/good.cpp,main<duplicate>5:int(),<empty>,,false,6,10,main,,,1,int()
111669154563,METHOD,samples/resourceLeak/bad.c:<global>,TYPE_DECL,"int main()
{
    const FILE *a = fopen(""good.c"", ""r"");
    if (!a)
        return 0;

    return 0;
}",1,1,samples/resourceLeak/bad.c,main<duplicate>13,<empty>,,false,2,9,main,,,1,int()
111669154564,METHOD,samples/resourceLeak/bad.c:<global>,TYPE_DECL,<global>,1,1,samples/resourceLeak/bad.c,samples/resourceLeak/bad.c:<global>,<empty>,,false,1,9,<global>,,,1,
111669154565,METHOD,samples/resourceLeak/good.c:<global>,TYPE_DECL,"int main()
{
    FILE *a = fopen(""good.c"", ""r"");
    if (!a)
        return 0;
    fclose(a);
    return 0;
}",1,1,samples/resourceLeak/good.c,main<duplicate>14,<empty>,,false,2,9,main,,,1,int()
111669154566,METHOD,samples/resourceLeak/good.c:<global>,TYPE_DECL,<global>,1,1,samples/resourceLeak/good.c,samples/resourceLeak/good.c:<global>,<empty>,,false,1,9,<global>,,,1,
111669154567,METHOD,samples/syntaxError/bad.c:<global>,TYPE_DECL,"int main()
{
    return 0;",1,13,samples/syntaxError/bad.c,main<duplicate>15,<empty>,,false,1,3,main,,,1,int()
111669154568,METHOD,samples/syntaxError/bad.c:<global>,TYPE_DECL,<global>,1,6,samples/syntaxError/bad.c,samples/syntaxError/bad.c:<global>,<empty>,,false,1,6,<global>,,,1,
111669154569,METHOD,samples/syntaxError/good.c:<global>,TYPE_DECL,"int main()
{
#ifndef A
#endif
    return 0;
}",1,1,samples/syntaxError/good.c,main<duplicate>16,<empty>,,false,1,6,main,,,1,int()
111669154570,METHOD,samples/syntaxError/good.c:<global>,TYPE_DECL,<global>,1,1,samples/syntaxError/good.c,samples/syntaxError/good.c:<global>,<empty>,,false,1,6,<global>,,,1,
111669154571,METHOD,samples/unreadVariable/bad.cpp:<global>,TYPE_DECL,"int main()
{
    std::string s1 = ""test1"", s2 = ""test2"";
    foo(s1, s1);
}",1,1,samples/unreadVariable/bad.cpp,main<duplicate>6:int(),<empty>,,false,3,7,main,,,1,int()
111669154572,METHOD,samples/unreadVariable/bad.cpp:<global>,TYPE_DECL,<global>,1,1,samples/unreadVariable/bad.cpp,samples/unreadVariable/bad.cpp:<global>,<empty>,,false,1,7,<global>,,,1,
111669154573,METHOD,samples/unreadVariable/good.cpp:<global>,TYPE_DECL,"int main()
{
    std::string s1 = ""test1"", s2 = ""test2"";
    foo(s1, s2);
}",1,1,samples/unreadVariable/good.cpp,main<duplicate>7:int(),<empty>,,false,3,7,main,,,1,int()
111669154574,METHOD,samples/unreadVariable/good.cpp:<global>,TYPE_DECL,<global>,1,1,samples/unreadVariable/good.cpp,samples/unreadVariable/good.cpp:<global>,<empty>,,false,1,7,<global>,,,1,
111669154575,METHOD,tools/defines/float.c:<global>,TYPE_DECL,"int main(void)
{
    PRINT_DEF(FLT_RADIX, d);
    PRINT_DEF(FLT_MANT_DIG, d);
    PRINT_DEF(DBL_MANT_DIG, d);
    PRINT_DEF(LDBL_MANT_DIG, d);
    PRINT_DEF(FLT_DIG, d);
    PRINT_DEF(DBL_DIG, d);
    PRINT_DEF(LDBL_DIG, d);
    PRINT_DEF(FLT_MIN_EXP, d);
    PRINT_DEF(DBL_MIN_EXP, d);
    PRINT_DEF(LDBL_MIN_EXP, d);
    PRINT_DEF(FLT_MIN_10_EXP, d);
    PRINT_DEF(DBL_MIN_10_EXP, d);
    PRINT_DEF(LDBL_MIN_10_EXP, d);
    PRINT_DEF(FLT_MAX_EXP, d);
    PRINT_DEF(DBL_MAX_EXP, d);
    PRINT_DEF(LDBL_MAX_EXP, d);
    PRINT_DEF(FLT_MAX_10_EXP, d);
    PRINT_DEF(DBL_MAX_10_EXP, d);
    PRINT_DEF(LDBL_MAX_10_EXP, d);
    PRINT_DEF(FLT_MAX, f); // TODO: float-to-double
    PRINT_DEF(DBL_MAX, f);
    PRINT_DEF(LDBL_MAX, Lf);
    PRINT_DEF(FLT_EPSILON, f); // TODO: float-to-double
    PRINT_DEF(DBL_EPSILON, f);
    PRINT_DEF(LDBL_EPSILON, Lf);
    PRINT_DEF(FLT_MIN, f); // TODO: float-to-double
    PRINT_DEF(DBL_MIN, f);
    PRINT_DEF(LDBL_MIN, Lf);
#if (__STDC_VERSION__ >= 199901L) || (__cp...",1,4,tools/defines/float.c,main<duplicate>17,<empty>,,false,7,43,main,,,1,int(void)
111669154576,METHOD,tools/defines/float.c:<global>,TYPE_DECL,<global>,1,4,tools/defines/float.c,tools/defines/float.c:<global>,<empty>,,false,1,43,<global>,,,1,
111669154577,METHOD,tools/defines/limits.c:<global>,TYPE_DECL,"int main(void)
{
    PRINT_DEF(CHAR_BIT, d);
    PRINT_DEF(SCHAR_MIN, d);
    PRINT_DEF(SCHAR_MAX, d);
    PRINT_DEF(UCHAR_MAX, d);
    PRINT_DEF(CHAR_MIN, d);
    PRINT_DEF(CHAR_MAX, d);
    PRINT_DEF(MB_LEN_MAX, d);
    PRINT_DEF(SHRT_MIN, d);
    PRINT_DEF(SHRT_MAX, d);
    PRINT_DEF(USHRT_MAX, d);
    PRINT_DEF(INT_MIN, d);
    PRINT_DEF(INT_MAX, d);
    PRINT_DEF(UINT_MAX, u);
    PRINT_DEF(LONG_MIN, ld);
    PRINT_DEF(LONG_MAX, ld);
    PRINT_DEF(ULONG_MAX, ld);
#if (__STDC_VERSION__ >= 199901L) || (__cplusplus >= 201103L)
    PRINT_DEF(LLONG_MIN, lld);
    PRINT_DEF(LLONG_MAX, lld);
    PRINT_DEF(ULLONG_MAX, llu);
#endif

    return 0;
}",1,4,tools/defines/limits.c,main<duplicate>18,<empty>,,false,7,32,main,,,1,int(void)
111669154578,METHOD,tools/defines/limits.c:<global>,TYPE_DECL,<global>,1,4,tools/defines/limits.c,tools/defines/limits.c:<global>,<empty>,,false,1,32,<global>,,,1,
111669154579,METHOD,tools/defines/stdint.c:<global>,TYPE_DECL,"int main(void)
{
    PRINT_DEF(INTMAX_MIN, ld);
    PRINT_DEF(INTMAX_MAX, ld);
    PRINT_DEF(UINTMAX_MAX, lu);
    PRINT_DEF_N(INT, _MIN, d);
    PRINT_DEF_N(INT, _MAX, d);
    PRINT_DEF_N(UINT, _MAX, u);
    PRINT_DEF_N(INT_LEAST, _MIN, d);
    PRINT_DEF_N(INT_LEAST, _MAX, d);
    PRINT_DEF_N(UINT_LEAST, _MAX, u);
    PRINT_DEF_N(INT_FAST, _MIN, d);
    PRINT_DEF_N(INT_FAST, _MAX, d);
    PRINT_DEF_N(UINT_FAST, _MAX, u);
    PRINT_DEF(INTPTR_MIN, ld);
    PRINT_DEF(INTPTR_MAX, ld);
    PRINT_DEF(UINTPTR_MAX, lu);
    PRINT_DEF(SIZE_MAX, lu);
    PRINT_DEF(PTRDIFF_MIN, ld);
    PRINT_DEF(PTRDIFF_MAX, ld);
    PRINT_DEF(SIG_ATOMIC_MIN, d);
    PRINT_DEF(SIG_ATOMIC_MAX, d);
    PRINT_DEF(WCHAR_MIN, d);
    PRINT_DEF(WCHAR_MAX, d);
    PRINT_DEF(WINT_MIN, d);
    PRINT_DEF(WINT_MAX, d);

    return 0;
}",1,4,tools/defines/stdint.c,main<duplicate>19,<empty>,,false,16,44,main,,,1,int(void)
111669154580,METHOD,tools/defines/stdint.c:<global>,TYPE_DECL,<global>,1,4,tools/defines/stdint.c,tools/defines/stdint.c:<global>,<empty>,,false,1,44,<global>,,,1,
111669154581,METHOD,tools/dmake/dmake.cpp:<global>,TYPE_DECL,"static std::string builddir(std::string filename)
{
    if (startsWith(filename,""lib/""))
        filename = ""$(libcppdir)"" + filename.substr(3);
    else if (startsWith(filename, ""../lib/"")) // oss-fuzz
        filename = ""$(libcppdir)"" + filename.substr(6);

    return filename;
}",1,1,tools/dmake/dmake.cpp,builddir:string(std.string),<empty>,,false,39,47,builddir,,,1,string(std.string)
111669154582,METHOD,tools/dmake/dmake.cpp:<global>,TYPE_DECL,<global>,1,1,tools/dmake/dmake.cpp,tools/dmake/dmake.cpp:<global>,<empty>,,false,1,846,<global>,,,1,
111669154583,METHOD,tools/dmake/dmake.cpp:<global>,TYPE_DECL,"static std::string objfile(std::string cppfile)
{
    cppfile.erase(cppfile.rfind('.'));
    if (startsWith(cppfile, ""../externals/simplecpp/"")) // oss-fuzz
        cppfile = cppfile.substr(23);
    else if (startsWith(cppfile, ""../externals/tinyxml2/"")) // oss-fuzz
        cppfile = cppfile.substr(22);
    return builddir(cppfile + "".o"");
}",1,1,tools/dmake/dmake.cpp,objfile:string(std.string),<empty>,,false,49,57,objfile,,,1,string(std.string)
111669154584,METHOD,tools/dmake/dmake.cpp:<global>,TYPE_DECL,"static std::string objfiles(const std::vector<std::string> &files)
{
    std::string allObjfiles;
    for (const std::string &file : files) {
        if (file != files.front())
            allObjfiles += std::string(14, ' ');
        allObjfiles += objfile(file);
        if (file != files.back())
            allObjfiles += "" \\\\\\n"";
    }
    return allObjfiles;
}",1,1,tools/dmake/dmake.cpp,objfiles:string(std.vector<std.string>&),<empty>,,false,59,70,objfiles,,,1,string(std.vector<std.string>&)
111669154585,METHOD,tools/dmake/dmake.cpp:<global>,TYPE_DECL,"static void getDeps(std::string filename, std::vector<std::string> &depfiles)
{
    static const std::array<std::string, 3> externalfolders{""externals/picojson"", ""externals/simplecpp"", ""externals/tinyxml2""};
    static const std::array<std::string, 3> externalfolders_rel{""../externals/picojson"", ""../externals/simplecpp"", ""../externals/tinyxml2""};

    // Is the dependency already included?
    if (std::find(depfiles.cbegin(), depfiles.cend(), filename) != depfiles.cend())
        return;

    const bool relative = startsWith(filename, ""../""); // oss-fuzz
    if (relative)
        filename = filename.substr(3);

    std::ifstream f(filename.c_str());
    if (!f.is_open()) {
        /*
         * Recursively search for includes in other directories.
         * Files are searched according to the following priority:
         * [test, tools] -> cli -> lib -> externals
         */
        if (startsWith(filename, ""cli/""))
            getDeps(""lib"" + filename.substr(filename.find('/')), d...",1,1,tools/dmake/dmake.cpp,"getDeps:void(std.string,std.vector<std.string>&)",<empty>,,false,72,144,getDeps,,,1,"void(std.string,std.vector<std.string>&)"
111669154586,METHOD,tools/dmake/dmake.cpp:<global>,TYPE_DECL,"static void compilefiles(std::ostream &fout, const std::vector<std::string> &files, const std::string &args)
{
    for (const std::string &file : files) {
        const bool external(startsWith(file,""externals/"") || startsWith(file,""../externals/""));
        const bool tinyxml2(startsWith(file,""externals/tinyxml2/"") || startsWith(file,""../externals/tinyxml2/""));
        fout << objfile(file) << "": "" << file;
        std::vector<std::string> depfiles;
        getDeps(file, depfiles);
        std::sort(depfiles.begin(), depfiles.end());
        for (const std::string &depfile : depfiles)
            fout << "" "" << depfile;
        std::string additional;
        if (external)
            additional += "" -w""; // do not show any warnings for external
        if (tinyxml2)
            additional += "" -D_LARGEFILE_SOURCE""; // required for fseeko() and ftello() (on Cygwin)
        fout << ""\\n\\t$(CXX) "" << args << "" $(CPPFLAGS) $(CXXFLAGS)"" << additional << "" -c -o $@ "" << builddir(file) <<...",1,1,tools/dmake/dmake.cpp,"compilefiles:void(std.ostream&,std.vector<std.string>&,std.string&)",<empty>,,false,146,164,compilefiles,,,1,"void(std.ostream&,std.vector<std.string>&,std.string&)"
111669154587,METHOD,tools/dmake/dmake.cpp:<global>,TYPE_DECL,"static std::string getCppFiles(std::vector<std::string> &files, const std::string &path, bool recursive)
{
    std::list<FileWithDetails> filelist;
    const std::set<std::string> extra;
    const std::vector<std::string> masks;
    const PathMatch matcher(masks);
    std::string err = FileLister::addFiles(filelist, path, extra, recursive, matcher);
    if (!err.empty())
        return err;

    // add *.cpp files to the ""files"" vector..
    for (const auto& file : filelist) {
        if (endsWith(file.path(), "".cpp""))
            files.push_back(file.path());
    }
    return """";
}",1,1,tools/dmake/dmake.cpp,"getCppFiles:string(std.vector<std.string>&,std.string&,bool)",<empty>,,false,166,182,getCppFiles,,,1,"string(std.vector<std.string>&,std.string&,bool)"
111669154588,METHOD,tools/dmake/dmake.cpp:<global>,TYPE_DECL,"static void makeConditionalVariable(std::ostream &os, const std::string &variable, const std::string &defaultValue)
{
    os << ""ifndef "" << variable << '\\n'
       << ""    "" << variable << '=' << defaultValue << '\\n'
       << ""endif\\n""
       << ""\\n"";
}",1,1,tools/dmake/dmake.cpp,"makeConditionalVariable:void(std.ostream&,std.string&,std.string&)",<empty>,,false,185,191,makeConditionalVariable,,,1,"void(std.ostream&,std.string&,std.string&)"
111669154589,METHOD,tools/dmake/dmake.cpp:<global>,TYPE_DECL,"static int write_vcxproj(const std::string &proj_name, const std::function<void(std::string&)> &source_f, const std::function<void(std::string&)> &header_f)
{
    std::string outstr;

    {
        // treat as binary to prevent implicit line ending conversions
        std::ifstream in(proj_name, std::ios::binary);
        if (!in.is_open()) {
            std::cerr << ""Could not open "" << proj_name << std::endl;
            return EXIT_FAILURE;
        }

        std::string line;
        bool in_itemgroup = false;
        while (std::getline(in, line)) {
            if (in_itemgroup) {
                if (line.find(""</ItemGroup>"") == std::string::npos)
                    continue;
                in_itemgroup = false;
            }

            // strip all remaining line endings
            const std::string::size_type pos = line.find_last_not_of(""\\r\\n"");
            if (pos != std::string::npos)
                line.resize(pos+1, '\\0');

            outstr += line;
            ou...",1,1,tools/dmake/dmake.cpp,"write_vcxproj:int(std.string&,std.function<void(std.string&)>&,std.function<void(std.string&)>&)",<empty>,,false,193,248,write_vcxproj,,,1,"int(std.string&,std.function<void(std.string&)>&,std.function<void(std.string&)>&)"
111669154590,METHOD,tools/dmake/dmake.cpp:<global>,TYPE_DECL,"static std::string make_vcxproj_cl_entry(const std::string& file, ClType type)
{
    std::string outstr;
    if (type == Precompile) {
        outstr += R""(    <ClCompile Include="")"";
        outstr += file;
        outstr += R""("">)"";
        outstr += ""\\r\\n"";
        outstr += R""(      <PrecompiledHeader Condition=""'$(Configuration)|$(Platform)'=='Release|x64'"">Create</PrecompiledHeader>)"";
        outstr += ""\\r\\n"";
        outstr += R""(      <PrecompiledHeader Condition=""'$(Configuration)|$(Platform)'=='Debug|x64'"">Create</PrecompiledHeader>)"";
        outstr += ""\\r\\n"";
        outstr += R""(      <PrecompiledHeader Condition=""'$(Configuration)|$(Platform)'=='Release-PCRE|x64'"">Create</PrecompiledHeader>)"";
        outstr += ""\\r\\n"";
        outstr += R""(      <PrecompiledHeader Condition=""'$(Configuration)|$(Platform)'=='Debug-PCRE|x64'"">Create</PrecompiledHeader>)"";
        outstr += ""\\r\\n"";
        outstr += ""    </ClCompile>\\r\\n"";
        return outstr;
    }
    outstr += ""    ...",1,1,tools/dmake/dmake.cpp,"make_vcxproj_cl_entry:string(std.string&,ClType)",<empty>,,false,252,278,make_vcxproj_cl_entry,,,1,"string(std.string&,ClType)"
111669154591,METHOD,<empty>,<empty>,"[&](const std::string &l1, const std::string &l2) {
        const auto p1 = priorities.find(l1);
        const auto p2 = priorities.find(l2);
        return (p1 != priorities.end() ? p1->second : 0) > (p2 != priorities.end() ? p2->second : 0);
    }",59,5,tools/dmake/dmake.cpp,"tools/dmake/dmake.cpp:<global>.prioritizelib:vector<std.string>(std.vector<std.string>&).<lambda>0:bool(std.string&,std.string&)",<empty>,,false,291,295,<lambda>0,,,1,"bool(std.string&,std.string&)"
111669154592,METHOD,tools/dmake/dmake.cpp:<global>,TYPE_DECL,"static std::vector<std::string> prioritizelib(const std::vector<std::string>& libfiles)
{
    std::map<std::string, std::size_t> priorities;
    std::size_t prio = libfiles.size();
    for (const auto &l : libfiles) {
        priorities.emplace(l, prio--);
    }
    priorities[""lib/valueflow.cpp""] = 1000;
    priorities[""lib/tokenize.cpp""] = 900;
    priorities[""lib/symboldatabase.cpp""] = 800;
    std::vector<std::string> libfiles_prio = libfiles;
    std::sort(libfiles_prio.begin(), libfiles_prio.end(), [&](const std::string &l1, const std::string &l2) {
        const auto p1 = priorities.find(l1);
        const auto p2 = priorities.find(l2);
        return (p1 != priorities.end() ? p1->second : 0) > (p2 != priorities.end() ? p2->second : 0);
    });
    return libfiles_prio;
}",1,1,tools/dmake/dmake.cpp,prioritizelib:vector<std.string>(std.vector<std.string>&),<empty>,,false,280,297,prioritizelib,,,1,vector<std::string>(std.vector<std.string>&)
111669154593,METHOD,tools/dmake/dmake.cpp:<global>,TYPE_DECL,"static void makeMatchcompiler(std::ostream& fout, const std::string& toolsPrefix, std::string args)
{
    if (!args.empty())
        args = "" "" + args;

    // avoid undefined variable
    fout << ""ifndef MATCHCOMPILER\\n""
         << ""    MATCHCOMPILER=\\n""
         << ""endif\\n"";
    // TODO: bail out when matchcompiler.py fails (i.e. invalid PYTHON_INTERPRETER specified)
    // TODO: handle ""PYTHON_INTERPRETER=""
    // use match compiler..
    fout << ""# use match compiler\\n"";
    fout << ""ifeq ($(MATCHCOMPILER),yes)\\n""
         << ""    # Find available Python interpreter\\n""
         << ""    ifeq ($(PYTHON_INTERPRETER),)\\n""
         << ""        PYTHON_INTERPRETER := $(shell which python3)\\n""
         << ""    endif\\n""
         << ""    ifeq ($(PYTHON_INTERPRETER),)\\n""
         << ""        PYTHON_INTERPRETER := $(shell which python)\\n""
         << ""    endif\\n""
         << ""    ifeq ($(PYTHON_INTERPRETER),)\\n""
         << ""        $(error Did not find a Python interpreter)\\n""
         ...",1,1,tools/dmake/dmake.cpp,"makeMatchcompiler:void(std.ostream&,std.string&,std.string)",<empty>,,false,299,334,makeMatchcompiler,,,1,"void(std.ostream&,std.string&,std.string)"
111669154594,METHOD,tools/dmake/dmake.cpp:<global>,TYPE_DECL,"static void write_ossfuzz_makefile(std::vector<std::string> libfiles_prio, std::vector<std::string> extfiles)
{
    for (auto& l : libfiles_prio)
    {
        l = ""../"" + l;
    }

    for (auto& e : extfiles)
    {
        e = ""../"" + e;
    }

    std::ofstream fout(""oss-fuzz/Makefile"");

    fout << ""# This file is generated by dmake, do not edit.\\n"";
    fout << '\\n';
    fout << ""# make CXX=clang++ MATCHCOMPILER=yes CXXFLAGS=\\""-O1 -fno-omit-frame-pointer -gline-tables-only -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION -fsanitize=address -fsanitize-address-use-after-scope -DHAVE_BOOST\\"" LIB_FUZZING_ENGINE=\\""-fsanitize=fuzzer\\"" oss-fuzz-client\\n"";
    fout << '\\n';
    fout << ""MATCHCOMPILER=yes\\n""; // always need to enable the matchcompiler so the library files are being copied
    makeMatchcompiler(fout, ""../"", ""--read-dir ../lib"");

    fout << ""INCS=-I../lib -isystem../externals/simplecpp -isystem../externals/tinyxml2 -isystem../externals/picojson\\n"";
    fout << ""CPPFLAGS=-std...",1,1,tools/dmake/dmake.cpp,"write_ossfuzz_makefile:void(std.vector<std.string>,std.vector<std.string>)",<empty>,,false,336,413,write_ossfuzz_makefile,,,1,"void(std.vector<std.string>,std.vector<std.string>)"
111669154595,METHOD,<empty>,<empty>,"[&](std::string &outstr){
        for (const std::string &clifile: clifiles) {
            const std::string c = clifile.substr(4);
            outstr += make_vcxproj_cl_entry(c, c == ""executor.cpp"" ? Precompile : Compile);
        }
    }",38,5,tools/dmake/dmake.cpp,tools/dmake/dmake.cpp:<global>.main.<lambda>1:void(std.string&),<empty>,,false,502,507,<lambda>1,,,1,void(std.string&)
111669154596,METHOD,<empty>,<empty>,"[&](std::string &outstr){
        for (const std::string &clifile_h: clifiles_h) {
            outstr += make_vcxproj_cl_entry(clifile_h, Include);
        }
    }",8,5,tools/dmake/dmake.cpp,tools/dmake/dmake.cpp:<global>.main.<lambda>2:void(std.string&),<empty>,,false,507,511,<lambda>2,,,1,void(std.string&)
111669154597,METHOD,<empty>,<empty>,"[&](std::string &outstr){
        outstr += make_vcxproj_cl_entry(R""(..\\externals\\simplecpp\\simplecpp.cpp)"", Compile);
        outstr += make_vcxproj_cl_entry(R""(..\\externals\\tinyxml2\\tinyxml2.cpp)"", Compile);

        for (const std::string &libfile: libfiles_prio) {
            const std::string l = libfile.substr(4);
            outstr += make_vcxproj_cl_entry(l, l == ""check.cpp"" ? Precompile : Compile);
        }
    }",43,5,tools/dmake/dmake.cpp,tools/dmake/dmake.cpp:<global>.main.<lambda>3:void(std.string&),<empty>,,false,513,521,<lambda>3,,,1,void(std.string&)
111669154598,METHOD,<empty>,<empty>,"[&](std::string &outstr){
        outstr += make_vcxproj_cl_entry(R""(..\\externals\\simplecpp\\simplecpp.h)"", Include);
        outstr += make_vcxproj_cl_entry(R""(..\\externals\\tinyxml2\\tinyxml2.h)"", Include);

        for (const std::string &libfile_h: libfiles_h) {
            outstr += make_vcxproj_cl_entry(libfile_h, Include);
        }
    }",8,5,tools/dmake/dmake.cpp,tools/dmake/dmake.cpp:<global>.main.<lambda>4:void(std.string&),<empty>,,false,521,528,<lambda>4,,,1,void(std.string&)
111669154599,METHOD,<empty>,<empty>,"[&](std::string &outstr){
        for (const std::string &clifile: clifiles) {
            if (clifile == ""cli/main.cpp"")
                continue;
            const std::string c = R""(..\\cli\\)"" + clifile.substr(4);
            outstr += make_vcxproj_cl_entry(c, Compile);
        }

        for (const std::string &testfile: testfiles) {
            const std::string t = testfile.substr(5);
            outstr += make_vcxproj_cl_entry(t, t == ""fixture.cpp"" ? Precompile : Compile);
        }
    }",46,5,tools/dmake/dmake.cpp,tools/dmake/dmake.cpp:<global>.main.<lambda>5:void(std.string&),<empty>,,false,530,542,<lambda>5,,,1,void(std.string&)
111669154600,METHOD,<empty>,<empty>,"[&](std::string &outstr){
        for (const std::string &clifile_h: clifiles_h) {
            const std::string c = R""(..\\cli\\)"" + clifile_h;
            outstr += make_vcxproj_cl_entry(c, Include);
        }

        for (const std::string &testfile_h: testfiles_h) {
            outstr += make_vcxproj_cl_entry(testfile_h, Include);
        }
    }",8,5,tools/dmake/dmake.cpp,tools/dmake/dmake.cpp:<global>.main.<lambda>6:void(std.string&),<empty>,,false,542,551,<lambda>6,,,1,void(std.string&)
111669154601,METHOD,tools/dmake/dmake.cpp:<global>,TYPE_DECL,"int main(int argc, char **argv)
{
    const bool release(argc >= 2 && std::string(argv[1]) == ""--release"");

    // Get files..
    std::vector<std::string> libfiles;
    std::string err = getCppFiles(libfiles, ""lib/"", false);
    if (!err.empty()) {
        std::cerr << err << std::endl;
        return EXIT_FAILURE;
    }
    const std::vector<std::string> libfiles_prio = prioritizelib(libfiles);

    std::vector<std::string> extfiles;
    err = getCppFiles(extfiles, ""externals/"", true);
    if (!err.empty()) {
        std::cerr << err << std::endl;
        return EXIT_FAILURE;
    }

    std::vector<std::string> clifiles;
    err = getCppFiles(clifiles, ""cli/"", false);
    if (!err.empty()) {
        std::cerr << err << std::endl;
        return EXIT_FAILURE;
    }

    std::vector<std::string> testfiles;
    err = getCppFiles(testfiles, ""test/"", false);
    if (!err.empty()) {
        std::cerr << err << std::endl;
        return EXIT_FAILURE;
    }

    std::vector<std::string> ...",1,1,tools/dmake/dmake.cpp,"main<duplicate>0:int(int,char**)",<empty>,,false,415,846,main,,,1,"int(int,char**)"
111669154602,METHOD,tools/triage/main.cpp:<global>,TYPE_DECL,"int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.show();

    return QApplication::exec();
}",1,1,tools/triage/main.cpp,"main<duplicate>2:int(int,char[]*)",<empty>,,false,23,30,main,,,1,"int(int,char[]*)"
111669154603,METHOD,tools/triage/main.cpp:<global>,TYPE_DECL,<global>,1,1,tools/triage/main.cpp,tools/triage/main.cpp:<global>,<empty>,,false,1,30,<global>,,,1,
111669154604,METHOD,tools/triage/mainwindow.cpp:<global>,TYPE_DECL,"MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow),
    mVersionRe(""^(master|main|your|head|[12].[0-9][0-9]?) (.*)$""),
    hFiles{""*.hpp"", ""*.h"", ""*.hxx"", ""*.hh"", ""*.tpp"", ""*.txx"", ""*.ipp"", ""*.ixx""},
    srcFiles{""*.cpp"", ""*.cxx"", ""*.cc"", ""*.c++"", ""*.C"", ""*.c"", ""*.cl""}
{
    ui->setupUi(this);
    std::srand(static_cast<unsigned int>(std::time(nullptr)));
    QDir workFolder(WORK_FOLDER);
    if (!workFolder.exists()) {
        workFolder.mkdir(WORK_FOLDER);
    }

    ui->results->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(ui->results, &QListWidget::customContextMenuRequested,
            this, &MainWindow::resultsContextMenu);

    mFSmodel.setRootPath(WORK_FOLDER);
    mFSmodel.setReadOnly(true);
    mFSmodel.setFilter(QDir::Dirs | QDir::Files | QDir::NoDotAndDotDot);
    ui->directoryTree->setModel(&mFSmodel);
    QHeaderView * header =  ui->directoryTree->header();
    for (int i = 1; i < header->length(); ++i)  // hide a...",1,1,tools/triage/mainwindow.cpp,MainWindow.MainWindow:ANY(QWidget*),<empty>,,false,69,98,MainWindow,,,1,MainWindow.MainWindow:ANY(QWidget*)(QWidget*)
111669154605,METHOD,tools/triage/mainwindow.cpp:<global>,TYPE_DECL,<global>,1,1,tools/triage/mainwindow.cpp,tools/triage/mainwindow.cpp:<global>,<empty>,,false,1,424,<global>,,,1,
111669154606,METHOD,tools/triage/mainwindow.cpp:<global>,TYPE_DECL,"MainWindow::~MainWindow()
{
    delete ui;
}",1,1,tools/triage/mainwindow.cpp,MainWindow.~MainWindow<duplicate>0:ANY(),<empty>,,false,100,103,~MainWindow,,,1,ANY()
111669154607,METHOD,tools/triage/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::loadFile()
{
    ui->statusBar->clearMessage();
    const QString fileName = QFileDialog::getOpenFileName(this, tr(""daca results file""), WORK_FOLDER, tr(""Text files (*.txt *.log);;All (*.*)""));
    if (fileName.isEmpty())
        return;
    QFile file(fileName);
    file.open(QIODevice::ReadOnly | QIODevice::Text);
    QTextStream textStream(&file);
    load(textStream);
}",1,1,tools/triage/mainwindow.cpp,MainWindow.loadFile:void(),<empty>,,false,105,115,loadFile,,,1,void()
111669154608,METHOD,tools/triage/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::loadFromClipboard()
{
    ui->statusBar->clearMessage();
    QString clipboardContent = QApplication::clipboard()->text();
    QTextStream textStream(&clipboardContent);
    load(textStream);
}",1,1,tools/triage/mainwindow.cpp,MainWindow.loadFromClipboard:void(),<empty>,,false,117,123,loadFromClipboard,,,1,void()
111669154609,METHOD,tools/triage/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::load(QTextStream &textStream)
{
    bool local = false;
    QString url;
    QString errorMessage;
    QStringList versions;
    mAllErrors.clear();
    while (true) {
        QString line = textStream.readLine();
        if (line.isNull())
            break;
        if (line.startsWith(""ftp://"") || (line.startsWith(DACA2_PACKAGES) && line.endsWith("".tar.xz""))) {
            local = line.startsWith(DACA2_PACKAGES) && line.endsWith("".tar.xz"");
            url = line;
            if (!errorMessage.isEmpty())
                mAllErrors << errorMessage;
            errorMessage.clear();
        } else if (!url.isEmpty()) {
            static const QRegularExpression severityRe(""^.*: (error|warning|style|note):.*$"");
            if (!severityRe.match(line).hasMatch())
                continue;
            if (!local) {
                const QRegularExpressionMatch matchRes = mVersionRe.match(line);
                if (matchRes.hasMatch()) {
                    const QStr...",1,1,tools/triage/mainwindow.cpp,MainWindow.load:void(QTextStream&),<empty>,,false,125,173,load,,,1,void(QTextStream&)
111669154610,METHOD,tools/triage/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::refreshResults()
{
    filter(ui->version->currentText());
}",1,1,tools/triage/mainwindow.cpp,MainWindow.refreshResults:void(),<empty>,,false,175,178,refreshResults,,,1,void()
111669154611,METHOD,tools/triage/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::filter(const QString& filter)
{
    QStringList allErrors;

    for (const QString &errorItem : mAllErrors) {
        if (filter.isEmpty()) {
            allErrors << errorItem;
            continue;
        }

        const QStringList lines = errorItem.split(""\\n"");
        if (lines.size() < 2)
            continue;

        if (lines[1].startsWith(filter))
            allErrors << errorItem;
    }

    ui->results->clear();

    if (ui->random100->isChecked() && allErrors.size() > MAX_ERRORS) {
        // remove items in /test/
        for (int i = allErrors.size() - 1; i >= 0 && allErrors.size() > MAX_ERRORS; --i) {
            if (allErrors[i].indexOf(""test"") > 0)
                allErrors.removeAt(i);
        }
        std::shuffle(allErrors.begin(), allErrors.end(), std::mt19937(std::random_device()()));
        ui->results->addItems(allErrors.mid(0, MAX_ERRORS));
        ui->results->sortItems();
    } else {
        ui->results->addItems(allErrors);
    }
}",1,1,tools/triage/mainwindow.cpp,MainWindow.filter:void(QString&),<empty>,,false,180,212,filter,,,1,void(QString&)
111669154612,METHOD,tools/triage/mainwindow.cpp:<global>,TYPE_DECL,"bool MainWindow::runProcess(const QString &programName, const QStringList &arguments)
{
    QProgressDialog dialog(""Running external process: "" + programName, ""Kill"", 0 /*min*/, 1 /*max*/, this);
    dialog.setWindowModality(Qt::WindowModal);
    dialog.setMinimumDuration(0 /*msec*/);
    dialog.setValue(0);

    QProcess process;
    process.setWorkingDirectory(WORK_FOLDER);
    process.start(programName, arguments);  // async action

    bool success = false;
    bool state = (QProcess::Running == process.state() || QProcess::Starting == process.state());
    while (!success && state) {
        success = process.waitForFinished(50 /*msec*/);
        // Not the best way to keep UI unfreeze, keep work async in other thread much more a Qt style
        QCoreApplication::processEvents();
        if (dialog.wasCanceled()) {
            process.kill();
            success = false;
            break;
        }
        state = (QProcess::Running == process.state() || QProcess::Starting ==...",1,1,tools/triage/mainwindow.cpp,"MainWindow.runProcess:bool(QString&,QStringList&)",<empty>,,false,214,256,runProcess,,,1,"bool(QString&,QStringList&)"
111669154613,METHOD,tools/triage/mainwindow.cpp:<global>,TYPE_DECL,"bool MainWindow::wget(const QString &url)
{
    return runProcess(""wget"", QStringList{url});
}",1,1,tools/triage/mainwindow.cpp,MainWindow.wget:bool(QString&),<empty>,,false,258,261,wget,,,1,bool(QString&)
111669154614,METHOD,tools/triage/mainwindow.cpp:<global>,TYPE_DECL,"bool MainWindow::unpackArchive(const QString &archiveName)
{
    // Unpack archive
    QStringList args;
#ifdef Q_OS_WIN
    /* On Windows --force-local is necessary because tar wants to connect to a remote system
     * when a colon is found in the archiveName. So ""C:/Users/blah/triage/package"" would not work
     * without it. */
    args << ""--force-local"";
#endif
    if (archiveName.endsWith("".tar.gz""))
        args << ""-xzvf"";
    else if (archiveName.endsWith("".tar.bz2""))
        args << ""-xjvf"";
    else if (archiveName.endsWith("".tar.xz""))
        args << ""-xJvf"";
    else {
        // Try to automatically find an (un)compressor for this archive
        args << ""-xavf"";
    }
    args << archiveName;

    return runProcess(""tar"", args);
}",1,1,tools/triage/mainwindow.cpp,MainWindow.unpackArchive:bool(QString&),<empty>,,false,263,286,unpackArchive,,,1,bool(QString&)
111669154615,METHOD,tools/triage/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::showResult(QListWidgetItem *item)
{
    ui->statusBar->clearMessage();
    const bool local = item->text().startsWith(DACA2_PACKAGES);
    if (!item->text().startsWith(""ftp://"") && !local)
        return;
    const QStringList lines = item->text().split(""\\n"");
    if (lines.size() < 2)
        return;
    const QString &url = lines[0];
    QString msg = lines[1];
    if (!local) {
        const QRegularExpressionMatch matchRes = mVersionRe.match(msg);
        if (matchRes.hasMatch())
            msg = matchRes.captured(2);
    }
    const QString archiveName = url.mid(url.lastIndexOf(""/"") + 1);
    const int pos1 = msg.indexOf("":"");
    const int pos2 = msg.indexOf("":"", pos1+1);
    const QString fileName = WORK_FOLDER + '/' + msg.left(msg.indexOf("":""));
    const int lineNumber = msg.mid(pos1+1, pos2-pos1-1).toInt();

    if (!QFileInfo::exists(fileName)) {
        const QString daca2archiveFile {DACA2_PACKAGES + '/' + archiveName.mid(0,archiveName.indexOf("".tar."")...",1,1,tools/triage/mainwindow.cpp,MainWindow.showResult:void(QListWidgetItem*),<empty>,,false,288,327,showResult,,,1,void(QListWidgetItem*)
111669154616,METHOD,tools/triage/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::showSrcFile(const QString &fileName, const QString &url, const int lineNumber)
{
    // Open file
    ui->code->setFocus();
    QFile f(fileName);
    if (!f.open(QIODevice::ReadOnly | QIODevice::Text)) {
        const QString errorMsg =
            QString(""Opening file %1 failed: %2"").arg(f.fileName(), f.errorString());
        ui->statusBar->showMessage(errorMsg);
    } else {
        QTextStream textStream(&f);
        const QString fileData = textStream.readAll();
        ui->code->setError(fileData, lineNumber, QStringList());
        f.close();

        ui->urlEdit->setText(url);
        ui->fileEdit->setText(fileName);
        ui->directoryTree->setCurrentIndex(mFSmodel.index(fileName));
    }
}",1,1,tools/triage/mainwindow.cpp,"MainWindow.showSrcFile:void(QString&,QString&,int)",<empty>,,false,329,348,showSrcFile,,,1,"void(QString&,QString&,int)"
111669154617,METHOD,tools/triage/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::fileTreeFilter(const QString &str)
{
    mFSmodel.setNameFilters(QStringList{""*"" + str + ""*""});
    mFSmodel.setNameFilterDisables(false);
}",1,1,tools/triage/mainwindow.cpp,MainWindow.fileTreeFilter:void(QString&),<empty>,,false,350,354,fileTreeFilter,,,1,void(QString&)
111669154618,METHOD,tools/triage/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::findInFilesClicked()
{
    ui->tabWidget->setCurrentIndex(1);
    ui->inFilesResult->clear();
    const QString text = ui->filterEdit->text();

    // cppcheck-suppress shadowFunction - TODO: fix this
    QStringList filter;
    if (ui->hFilesFilter->isChecked())
        filter.append(hFiles);
    if (ui->srcFilesFilter->isChecked())
        filter.append(srcFiles);

    QMimeDatabase mimeDatabase;
    QDirIterator it(WORK_FOLDER, filter, QDir::AllEntries | QDir::NoSymLinks | QDir::NoDotAndDotDot, QDirIterator::Subdirectories);

    const auto common_path_len = WORK_FOLDER.length() + 1;  // let's remove common part of path improve UI

    while (it.hasNext()) {
        const QString fileName = it.next();
        const QMimeType mimeType = mimeDatabase.mimeTypeForFile(fileName);

        if (mimeType.isValid() && !mimeType.inherits(QStringLiteral(""text/plain""))) {
            continue;
        }

        QFile file(fileName);
        if (file.open(QIODevice::ReadOnly...",1,1,tools/triage/mainwindow.cpp,MainWindow.findInFilesClicked:void(),<empty>,,false,356,395,findInFilesClicked,,,1,void()
111669154619,METHOD,tools/triage/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::directorytreeDoubleClick()
{
    showSrcFile(mFSmodel.filePath(ui->directoryTree->currentIndex()), """", 1);
}",1,1,tools/triage/mainwindow.cpp,MainWindow.directorytreeDoubleClick:void(),<empty>,,false,397,400,directorytreeDoubleClick,,,1,void()
111669154620,METHOD,tools/triage/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::searchResultsDoubleClick()
{
    QString filename = ui->inFilesResult->currentItem()->text();
    const auto idx = filename.lastIndexOf(':');
    const int line = filename.mid(idx + 1).toInt();
    showSrcFile(WORK_FOLDER + QString{""/""} + filename.left(idx), """", line);
}",1,1,tools/triage/mainwindow.cpp,MainWindow.searchResultsDoubleClick:void(),<empty>,,false,402,408,searchResultsDoubleClick,,,1,void()
111669154621,METHOD,tools/triage/mainwindow.cpp:<global>,TYPE_DECL,"void MainWindow::resultsContextMenu(const QPoint& pos)
{
    if (ui->results->selectedItems().isEmpty())
        return;
    QMenu submenu;
    submenu.addAction(""Copy"");
    const QAction* menuItem = submenu.exec(ui->results->mapToGlobal(pos));
    if (menuItem && menuItem->text().contains(""Copy""))
    {
        QString text;
        for (const auto *res: ui->results->selectedItems())
            text += res->text() + ""\\n"";
        QApplication::clipboard()->setText(text);
    }
}",1,1,tools/triage/mainwindow.cpp,MainWindow.resultsContextMenu:void(QPoint&),<empty>,,false,410,424,resultsContextMenu,,,1,void(QPoint&)
111669154622,METHOD,tools/triage/mainwindow.h:<global>,TYPE_DECL,<global>,1,22,tools/triage/mainwindow.h,tools/triage/mainwindow.h:<global>,<empty>,,false,1,75,<global>,,,1,
111669154623,METHOD,lib/astutils.h:<global>,TYPE_DECL,"bool astIsIntegral(const Token *tok, bool unknown);",6,50,lib/astutils.h,astIsIntegral,<empty>,,false,146,146,astIsIntegral,,,1,"bool(Token*,bool)"
111669154624,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool astIsContainerString(const Token* tok);,6,43,lib/astutils.h,astIsContainerString,<empty>,,false,165,165,astIsContainerString,,,1,bool(Token*)
111669154625,METHOD,FileStream,TYPE_DECL,FileStream(const FileStream&);,5,33,externals/simplecpp/simplecpp.cpp,FileStream.FileStream:ANY(FileStream&),<empty>,,false,463,463,FileStream,,,1,ANY(FileStream&)
111669154626,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool astIsContainer(const Token *tok);,6,37,lib/astutils.h,astIsContainer,<empty>,,false,160,160,astIsContainer,,,1,bool(Token*)
111669154627,METHOD,lib/astutils.h:<global>,TYPE_DECL,"int getArgumentPos(const Variable* var, const Function* f);",5,58,lib/astutils.h,getArgumentPos,<empty>,,false,401,401,getArgumentPos,,,1,"int(Variable*,Function*)"
111669154628,METHOD,ValueFlowAnalyzer,TYPE_DECL,"virtual void addErrorPath(const Token* tok, const std::string& s) = 0;",18,73,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.addErrorPath:void(Token*,std.string&)",<empty>,,false,61,61,addErrorPath,,,1,"void(Token*,std.string&)"
111669154629,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool isStlStringType(const Token* tok);,6,38,lib/astutils.h,isStlStringType,<empty>,,false,190,190,isStlStringType,,,1,bool(Token*)
111669154630,METHOD,clangimport.AstNode,TYPE_DECL,std::string getType(int index = 0) const;,21,48,lib/clangimport.cpp,clangimport.AstNode.getType<const>:ANY(int),<empty>,,false,370,370,getType,,,1,std.string(int)
111669154631,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool astIsContainerOwned(const Token* tok);,6,42,lib/astutils.h,astIsContainerOwned,<empty>,,false,164,164,astIsContainerOwned,,,1,bool(Token*)
111669154632,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool isStructuredBindingVariable(const Variable* var);,6,53,lib/astutils.h,isStructuredBindingVariable,<empty>,,false,267,267,isStructuredBindingVariable,,,1,bool(Variable*)
111669154633,METHOD,Analyzer,TYPE_DECL,bool lowerToInconclusive() = 0;,18,42,lib/analyzer.h,lowerToInconclusive,<empty>,,false,177,177,lowerToInconclusive,,,1,bool()
111669154634,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool isLikelyStream(const Token *stream);,6,40,lib/astutils.h,isLikelyStream,<empty>,,false,420,420,isLikelyStream,,,1,bool(Token*)
111669154635,METHOD,lib/astutils.h:<global>,TYPE_DECL,const Token* getParentMember(const Token * tok);,12,47,lib/astutils.h,getParentMember,<empty>,,false,203,203,getParentMember,,,1,Token*(Token*)
111669154636,METHOD,Analyzer.Action,TYPE_DECL,bool isInternal(),14,25,lib/analyzer.h,isInternal,<empty>,,false,105,105,isInternal,,,1,bool()
111669154637,METHOD,ProgramMemory,TYPE_DECL,bool hasValue(nonneg int exprid);,10,18,lib/programmemory.h,hasValue,<empty>,,false,120,120,hasValue,,,1,bool(int)
111669154638,METHOD,gui/statsdialog.cpp:<global>,TYPE_DECL,"static QLineSeries *numberOfReports(const QString &fileName, const QString &severity);",20,85,gui/statsdialog.cpp,"numberOfReports:ANY(QString&,QString&)",<empty>,,false,70,70,numberOfReports,,,1,"QLineSeries*(QString&,QString&)"
111669154639,METHOD,SourceLocation,TYPE_DECL,const char* function_name(),15,31,lib/sourcelocation.h,function_name,<empty>,,false,92,92,function_name,,,1,char*()
111669154640,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool astIsBool(const Token *tok);,6,32,lib/astutils.h,astIsBool,<empty>,,false,151,151,astIsBool,,,1,bool(Token*)
111669154641,METHOD,lib/astutils.h:<global>,TYPE_DECL,"const Token* followReferences(const Token* tok, ErrorPath* errors = nullptr);",12,76,lib/astutils.h,followReferences,<empty>,,false,261,261,followReferences,,,1,"Token*(Token*,ErrorPath*)"
111669154642,METHOD,lib/errorlogger.cpp:<global>,TYPE_DECL,"ErrorMessage::FileLocation loc(substrings[3], std::move(info), strToInt<int>(substrings[0]), strToInt<unsigned int>(substrings[1]));",36,139,lib/errorlogger.cpp,"loc:ErrorMessage.FileLocation(substrings[3],std.move,strToInt<int>,strToInt<unsignedint>)",<empty>,,false,422,422,loc,,,1,"ErrorMessage.FileLocation(substrings[3],std.move,strToInt<int>,strToInt<unsignedint>)"
111669154643,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool astIsRangeBasedForDecl(const Token* tok);,6,45,lib/astutils.h,astIsRangeBasedForDecl,<empty>,,false,173,173,astIsRangeBasedForDecl,,,1,bool(Token*)
111669154644,METHOD,lib/astutils.h:<global>,TYPE_DECL,"bool astIsFloat(const Token *tok, bool unknown);",6,47,lib/astutils.h,astIsFloat,<empty>,,false,149,149,astIsFloat,,,1,"bool(Token*,bool)"
111669154645,METHOD,CWE,TYPE_DECL,explicit CWE(unsigned short cweId),14,38,lib/errortypes.h,CWE,<empty>,,false,126,126,CWE,,,1,explicit(shortunsigned)
111669154646,METHOD,ProgramMemory,TYPE_DECL,bool empty(),10,16,lib/programmemory.h,empty,<empty>,,false,131,131,empty,,,1,bool()
111669154647,METHOD,lib/astutils.h:<global>,TYPE_DECL,"bool precedes(const Token * tok1, const Token * tok2);",6,53,lib/astutils.h,precedes,<empty>,,false,242,242,precedes,,,1,"bool(Token*,Token*)"
111669154648,METHOD,Analyzer,TYPE_DECL,bool lowerToPossible() = 0;,18,38,lib/analyzer.h,lowerToPossible,<empty>,,false,175,175,lowerToPossible,,,1,bool()
111669154649,METHOD,lib/astutils.h:<global>,TYPE_DECL,int numberOfArguments(const Token* ftok);,5,40,lib/astutils.h,numberOfArguments,<empty>,,false,391,391,numberOfArguments,,,1,int(Token*)
111669154650,METHOD,ProgramMemory,TYPE_DECL,void replace(ProgramMemory pm);,10,34,lib/programmemory.h,replace,<empty>,,false,133,133,replace,,,1,void(ProgramMemory)
111669154651,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool isUniqueExpression(const Token* tok);,6,41,lib/astutils.h,isUniqueExpression,<empty>,,false,299,299,isUniqueExpression,,,1,bool(Token*)
111669154652,METHOD,Analyzer.Action,TYPE_DECL,bool isSymbolicMatch(),14,30,lib/analyzer.h,isSymbolicMatch,<empty>,,false,101,101,isSymbolicMatch,,,1,bool()
111669154653,METHOD,lib/astutils.h:<global>,TYPE_DECL,"int astCount(const Token* tok, const char* op, int depth = 100);",12,70,lib/astutils.h,astCount,<empty>,,false,131,131,astCount,,,1,"int(Token*,char*,int)"
111669154654,METHOD,lib/astutils.h:<global>,TYPE_DECL,const Token *findLambdaStartToken(const Token *last);,25,64,lib/astutils.h,findLambdaStartToken,<empty>,,false,410,410,findLambdaStartToken,,,1,Token*(Token*)
111669154655,METHOD,lib/astutils.h:<global>,TYPE_DECL,"const Token* findEscapeStatement(const Scope* scope, const Library* library);",12,76,lib/astutils.h,findEscapeStatement,<empty>,,false,126,126,findEscapeStatement,,,1,"Token*(Scope*,Library*)"
111669154656,METHOD,Analyzer.Action,TYPE_DECL,bool isModified(),14,25,lib/analyzer.h,isModified,<empty>,,false,89,89,isModified,,,1,bool()
111669154657,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool astIsUniqueSmartPointer(const Token* tok);,6,46,lib/astutils.h,astIsUniqueSmartPointer,<empty>,,false,156,156,astIsUniqueSmartPointer,,,1,bool(Token*)
111669154658,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool astIsPrimitive(const Token* tok);,6,37,lib/astutils.h,astIsPrimitive,<empty>,,false,138,138,astIsPrimitive,,,1,bool(Token*)
111669154659,METHOD,Analyzer,TYPE_DECL,"Action analyze(const Token* tok, Direction d)",20,57,lib/analyzer.h,analyze,<empty>,,false,165,165,analyze,,,1,"Action(Token*,Direction)"
111669154660,METHOD,Analyzer.Action,TYPE_DECL,bool isWrite(),14,22,lib/analyzer.h,isWrite,<empty>,,false,73,73,isWrite,,,1,bool()
111669154661,METHOD,SourceLocation,TYPE_DECL,const char* file_name(),15,27,lib/sourcelocation.h,file_name,<empty>,,false,89,89,file_name,,,1,char*()
111669154662,METHOD,ValueFlowAnalyzer,TYPE_DECL,virtual void makeConditional() = 0;,18,38,lib/vf_analyzers.cpp,ValueFlowAnalyzer.makeConditional:void(),<empty>,,false,59,59,makeConditional,,,1,void()
111669154663,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool astIsIterator(const Token *tok);,6,36,lib/astutils.h,astIsIterator,<empty>,,false,158,158,astIsIterator,,,1,bool(Token*)
111669154664,METHOD,gui/erroritem.h:<global>,TYPE_DECL,Q_DECLARE_METATYPE(ErrorItem),1,29,gui/erroritem.h,Q_DECLARE_METATYPE,<empty>,,false,109,109,Q_DECLARE_METATYPE,,,1,ANY(ANY)
111669154665,METHOD,ValueFlowAnalyzer,TYPE_DECL,virtual ValueFlow::Value* getValue(const Token* tok) = 0;,29,60,lib/vf_analyzers.cpp,ValueFlowAnalyzer.getValue:ValueFlow.Value*(Token*),<empty>,,false,57,57,getValue,,,1,ValueFlow.Value*(Token*)
111669154666,METHOD,ProgramMemory,TYPE_DECL,void clear();,10,16,lib/programmemory.h,clear,<empty>,,false,129,129,clear,,,1,void()
111669154667,METHOD,clangimport.AstNode,TYPE_DECL,std::string getSpelling() const;,21,39,lib/clangimport.cpp,clangimport.AstNode.getSpelling<const>:ANY(),<empty>,,false,369,369,getSpelling,,,1,std.string()
111669154668,METHOD,ValueFlowPass,TYPE_DECL,virtual const char* name() const = 0;,23,40,lib/valueflow.cpp,ValueFlowPass.name<const>:char*(),<empty>,,false,7062,7062,name,,,1,char*()
111669154669,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool isLikelyStreamRead(const Token *op);,6,40,lib/astutils.h,isLikelyStreamRead,<empty>,,false,427,427,isLikelyStreamRead,,,1,bool(Token*)
111669154670,METHOD,Analyzer.Action,TYPE_DECL,bool isInconclusive(),14,29,lib/analyzer.h,isInconclusive,<empty>,,false,81,81,isInconclusive,,,1,bool()
111669154671,METHOD,simplecpp.TokenList.Stream,TYPE_DECL,virtual int get() = 0;,17,25,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.Stream.get:int(),<empty>,,false,249,249,get,,,1,int()
111669154672,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool astIsRHS(const Token* tok);,6,31,lib/astutils.h,astIsRHS,<empty>,,false,213,213,astIsRHS,,,1,bool(Token*)
111669154673,METHOD,lib/astutils.h:<global>,TYPE_DECL,const Token* getArgumentStart(const Token* ftok);,12,48,lib/astutils.h,getArgumentStart,<empty>,,false,385,385,getArgumentStart,,,1,Token*(Token*)
111669154674,METHOD,samples/unreadVariable/bad.cpp:<global>,TYPE_DECL,"void foo(const std::string&, const std::string&);",6,48,samples/unreadVariable/bad.cpp,"foo:void(std.string&,std.string&)",<empty>,,false,1,1,foo,,,1,"void(std.string&,std.string&)"
111669154675,METHOD,cli/sehwrapper.h:<global>,TYPE_DECL,void set_seh_output(FILE* f);,6,28,cli/sehwrapper.h,set_seh_output,<empty>,,false,31,31,set_seh_output,,,1,void(FILE*)
111669154676,METHOD,lib/astutils.h:<global>,TYPE_DECL,const Token * nextAfterAstRightmostLeaf(const Token * tok);,25,70,lib/astutils.h,nextAfterAstRightmostLeaf,<empty>,,false,197,197,nextAfterAstRightmostLeaf,,,1,Token*(Token*)
111669154677,METHOD,TimerResultsData,TYPE_DECL,double seconds(),12,20,lib/timer.h,seconds,<empty>,,false,53,53,seconds,,,1,double()
111669154678,METHOD,Enumerator,TYPE_DECL,explicit Enumerator(const Scope * scope_),14,45,lib/symboldatabase.h,Enumerator,<empty>,,false,163,163,Enumerator,,,1,explicit(Scope*)
111669154679,METHOD,SubExpressionAnalyzer,TYPE_DECL,"virtual bool submatch(const Token* tok, bool exact = true) const = 0;",18,72,lib/vf_analyzers.cpp,"SubExpressionAnalyzer.submatch<const>:bool(Token*,bool)",<empty>,,false,1383,1383,submatch,,,1,"bool(Token*,bool)"
111669154680,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool isUnevaluated(const Token *tok);,6,36,lib/astutils.h,isUnevaluated,<empty>,,false,454,454,isUnevaluated,,,1,bool(Token*)
111669154681,METHOD,simplecpp.TokenList.Stream,TYPE_DECL,virtual int peek() = 0;,17,26,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.Stream.peek:int(),<empty>,,false,250,250,peek,,,1,int()
111669154682,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool astIsPointer(const Token *tok);,6,35,lib/astutils.h,astIsPointer,<empty>,,false,153,153,astIsPointer,,,1,bool(Token*)
111669154683,METHOD,lib/astutils.h:<global>,TYPE_DECL,"bool isAliasOf(const Token *tok, nonneg int varid, bool* inconclusive = nullptr);",6,33,lib/astutils.h,isAliasOf,<empty>,,false,381,381,isAliasOf,,,1,"bool(Token*,int,bool*)"
111669154684,METHOD,Analyzer.Action,TYPE_DECL,bool isNone(),14,21,lib/analyzer.h,isNone,<empty>,,false,85,85,isNone,,,1,bool()
111669154685,METHOD,lib/astutils.h:<global>,TYPE_DECL,Token* getCondTok(Token* tok);,6,29,lib/astutils.h,getCondTok,<empty>,,false,215,215,getCondTok,,,1,Token*(Token*)
111669154686,METHOD,MyLock,TYPE_DECL,MyLock(const MyLock&);,5,25,externals/simplecpp/simplecpp.cpp,MyLock.MyLock:ANY(MyLock<ANY>&),<empty>,,false,2412,2412,MyLock,,,1,ANY(MyLock<ANY>&)
111669154687,METHOD,FileStream,TYPE_DECL,FileStream &operator=(const FileStream&);,16,44,externals/simplecpp/simplecpp.cpp,FileStream.=:FileStream&(FileStream&),<empty>,,false,464,464,operator =,,,1,FileStream&(FileStream&)
111669154688,METHOD,clangimport.AstNode,TYPE_DECL,std::string getTemplateParameters() const;,21,49,lib/clangimport.cpp,clangimport.AstNode.getTemplateParameters<const>:ANY(),<empty>,,false,373,373,getTemplateParameters,,,1,std.string()
111669154689,METHOD,lib/astutils.h:<global>,TYPE_DECL,"const Token* findExpression(const Token* start, nonneg int exprid);",12,48,lib/astutils.h,findExpression,<empty>,,false,123,123,findExpression,,,1,"Token*(Token*,int)"
111669154690,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool astIsUnknownSignChar(const Token *tok);,6,43,lib/astutils.h,astIsUnknownSignChar,<empty>,,false,142,142,astIsUnknownSignChar,,,1,bool(Token*)
111669154691,METHOD,simplecpp.TokenList.Stream,TYPE_DECL,virtual bool good() = 0;,18,27,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.Stream.good:bool(),<empty>,,false,252,252,good,,,1,bool()
111669154692,METHOD,gui/threadhandler.cpp:<global>,TYPE_DECL,emit done();,14,19,gui/threadhandler.cpp,done:ANY(),<empty>,,false,90,90,done,,,1,emit()
111669154693,METHOD,lib/token.h:<global>,TYPE_DECL,Token* findLambdaEndScope(Token* tok);,6,37,lib/token.h,findLambdaEndScope,<empty>,,false,1593,1593,findLambdaEndScope,,,1,Token*(Token*)
111669154694,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool astIsSignedChar(const Token *tok);,6,38,lib/astutils.h,astIsSignedChar,<empty>,,false,140,140,astIsSignedChar,,,1,bool(Token*)
111669154695,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool astIsNonStringContainer(const Token *tok);,6,46,lib/astutils.h,astIsNonStringContainer,<empty>,,false,161,161,astIsNonStringContainer,,,1,bool(Token*)
111669154696,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool isGlobalData(const Token *expr);,6,36,lib/astutils.h,isGlobalData,<empty>,,false,452,452,isGlobalData,,,1,bool(Token*)
111669154697,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool astIsSmartPointer(const Token* tok);,6,40,lib/astutils.h,astIsSmartPointer,<empty>,,false,155,155,astIsSmartPointer,,,1,bool(Token*)
111669154698,METHOD,lib/astutils.h:<global>,TYPE_DECL,const Token* getIteratorExpression(const Token* tok);,12,52,lib/astutils.h,getIteratorExpression,<empty>,,false,403,403,getIteratorExpression,,,1,Token*(Token*)
111669154699,METHOD,samples/accessMoved/good.cpp:<global>,TYPE_DECL,void foo(std::string);,6,21,samples/accessMoved/good.cpp,foo:void(std.string),<empty>,,false,1,1,foo,,,1,void(std.string)
111669154700,METHOD,Analyzer.Action,TYPE_DECL,bool isIncremental(),14,28,lib/analyzer.h,isIncremental,<empty>,,false,97,97,isIncremental,,,1,bool()
111669154701,METHOD,lib/astutils.h:<global>,TYPE_DECL,const Token* getParentLifetime(const Token* tok);,12,48,lib/astutils.h,getParentLifetime,<empty>,,false,205,205,getParentLifetime,,,1,Token*(Token*)
111669154702,METHOD,lib/astutils.h:<global>,TYPE_DECL,Token* getCondTokFromEnd(Token* endBlock);,6,41,lib/astutils.h,getCondTokFromEnd,<empty>,,false,224,224,getCondTokFromEnd,,,1,Token*(Token*)
111669154703,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool isCPPCast(const Token* tok);,6,32,lib/astutils.h,isCPPCast,<empty>,,false,429,429,isCPPCast,,,1,bool(Token*)
111669154704,METHOD,ValueFlowAnalyzer,TYPE_DECL,"virtual bool isAlias(const Token* tok, bool& inconclusive) const = 0;",18,72,lib/vf_analyzers.cpp,"ValueFlowAnalyzer.isAlias<const>:bool(Token*,bool&)",<empty>,,false,69,69,isAlias,,,1,"bool(Token*,bool&)"
111669154705,METHOD,lib/astutils.h:<global>,TYPE_DECL,const Token* isInLoopCondition(const Token* tok);,12,48,lib/astutils.h,isInLoopCondition,<empty>,,false,269,269,isInLoopCondition,,,1,Token*(Token*)
111669154706,METHOD,lib/astutils.h:<global>,TYPE_DECL,Token* astParentSkipParens(Token* tok);,6,38,lib/astutils.h,astParentSkipParens,<empty>,,false,200,200,astParentSkipParens,,,1,Token*(Token*)
111669154707,METHOD,ProgramMemoryState,TYPE_DECL,void removeModifiedVars(const Token* tok);,10,45,lib/programmemory.h,removeModifiedVars,<empty>,,false,170,170,removeModifiedVars,,,1,void(Token*)
111669154708,METHOD,ValueFlowAnalyzer,TYPE_DECL,virtual bool match(const Token* tok) const = 0;,18,50,lib/vf_analyzers.cpp,ValueFlowAnalyzer.match<const>:bool(Token*),<empty>,,false,63,63,match,,,1,bool(Token*)
111669154709,METHOD,clangimport.AstNode,TYPE_DECL,std::string getFullType(int index = 0) const;,21,52,lib/clangimport.cpp,clangimport.AstNode.getFullType<const>:ANY(int),<empty>,,false,371,371,getFullType,,,1,std.string(int)
111669154710,METHOD,lib/astutils.h:<global>,TYPE_DECL,"bool succeeds(const Token* tok1, const Token* tok2);",6,51,lib/astutils.h,succeeds,<empty>,,false,243,243,succeeds,,,1,"bool(Token*,Token*)"
111669154711,METHOD,ValueFlowAnalyzer,TYPE_DECL,virtual const ValueFlow::Value* getValue(const Token* tok) const = 0;,35,72,lib/vf_analyzers.cpp,ValueFlowAnalyzer.getValue<const>:ValueFlow.Value*(Token*),<empty>,,false,56,56,getValue,,,1,ValueFlow.Value*(Token*)
111669154712,METHOD,TokenImpl,TYPE_DECL,TokenImpl(),14,15,lib/token.h,<unresolvedNamespace>.,<empty>,,false,146,146,,,,1,TokenImpl()
111669154713,METHOD,Analyzer,TYPE_DECL,void updateState(const Token* tok) = 0;,18,50,lib/analyzer.h,updateState,<empty>,,false,187,187,updateState,,,1,void(Token*)
111669154714,METHOD,lib/astutils.h:<global>,TYPE_DECL,"bool compareTokenFlags(const Token* tok1, const Token* tok2, bool macro);",6,72,lib/astutils.h,compareTokenFlags,<empty>,,false,279,279,compareTokenFlags,,,1,"bool(Token*,Token*,bool)"
111669154715,METHOD,Analyzer,TYPE_DECL,bool invalid(),18,26,lib/analyzer.h,invalid,<empty>,,false,190,190,invalid,,,1,bool()
111669154716,METHOD,IteratorInferModel,TYPE_DECL,virtual ValueFlow::Value::ValueType getType() const = 0;,41,59,lib/valueflow.cpp,IteratorInferModel.getType<const>:ValueFlow.Value.ValueType(),<empty>,,false,4925,4925,getType,,,1,ValueFlow.Value.ValueType()
111669154717,METHOD,externals/simplecpp/simplecpp.cpp:<global>,TYPE_DECL,"static std::string openHeader(std::ifstream &f, const simplecpp::DUI &dui, const std::string &sourcefile, const std::string &header, bool systemheader);",20,151,externals/simplecpp/simplecpp.cpp,"openHeader:ANY(std.ifstream&,simplecpp.DUI&,std.string&,std.string&,bool)",<empty>,,false,2684,2684,openHeader,,,1,"std.string(std.ifstream&,simplecpp.DUI&,std.string&,std.string&,bool)"
111669154718,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool astIsGenericChar(const Token* tok);,6,39,lib/astutils.h,astIsGenericChar,<empty>,,false,144,144,astIsGenericChar,,,1,bool(Token*)
111669154719,METHOD,lib/astutils.h:<global>,TYPE_DECL,"bool isEqualKnownValue(const Token * tok1, const Token * tok2);",6,62,lib/astutils.h,isEqualKnownValue,<empty>,,false,265,265,isEqualKnownValue,,,1,"bool(Token*,Token*)"
111669154720,METHOD,lib/astutils.h:<global>,TYPE_DECL,const Variable *getLHSVariable(const Token *tok);,16,48,lib/astutils.h,getLHSVariable,<empty>,,false,439,439,getLHSVariable,,,1,Variable*(Token*)
111669154721,METHOD,lib/astutils.h:<global>,TYPE_DECL,"bool isTemporary(const Token* tok, const Library* library, bool unknown = false);",6,80,lib/astutils.h,isTemporary,<empty>,,false,192,192,isTemporary,,,1,"bool(Token*,Library*,bool)"
111669154722,METHOD,lib/astutils.h:<global>,TYPE_DECL,"bool exprDependsOnThis(const Token* expr, bool onVar = true, nonneg int depth = 0);",6,61,lib/astutils.h,exprDependsOnThis,<empty>,,false,245,245,exprDependsOnThis,,,1,"bool(Token*,bool,int)"
111669154723,METHOD,lib/astutils.h:<global>,TYPE_DECL,"bool isWithoutSideEffects(const Token* tok, bool checkArrayAccess = false, bool checkReference = true);",6,102,lib/astutils.h,isWithoutSideEffects,<empty>,,false,297,297,isWithoutSideEffects,,,1,"bool(Token*,bool,bool)"
111669154724,METHOD,lib/astutils.h:<global>,TYPE_DECL,"bool isEscapeFunction(const Token* ftok, const Library* library);",6,64,lib/astutils.h,isEscapeFunction,<empty>,,false,301,301,isEscapeFunction,,,1,"bool(Token*,Library*)"
111669154725,METHOD,ProgramMemoryState,TYPE_DECL,"void assume(const Token* tok, bool b, bool isEmpty = false);",10,63,lib/programmemory.h,assume,<empty>,,false,168,168,assume,,,1,"void(Token*,bool,bool)"
111669154726,METHOD,ValueFlowPass,TYPE_DECL,virtual bool cpp() const = 0;,18,32,lib/valueflow.cpp,ValueFlowPass.cpp<const>:bool(),<empty>,,false,7066,7066,cpp,,,1,bool()
111669154727,METHOD,Analyzer.Action,TYPE_DECL,bool isIdempotent(),14,27,lib/analyzer.h,isIdempotent,<empty>,,false,93,93,isIdempotent,,,1,bool()
111669154728,METHOD,lib/astutils.h:<global>,TYPE_DECL,"bool astHasVar(const Token * tok, nonneg int varid);",6,34,lib/astutils.h,astHasVar,<empty>,,false,136,136,astHasVar,,,1,"bool(Token*,int)"
111669154729,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool isNullOperand(const Token *expr);,18,49,lib/astutils.h,isNullOperand,<empty>,,false,450,450,isNullOperand,,,1,bool(Token*)
111669154730,METHOD,Analyzer,TYPE_DECL,bool isConditional(),18,32,lib/analyzer.h,isConditional,<empty>,,false,181,181,isConditional,,,1,bool()
111669154731,METHOD,Analyzer.Action,TYPE_DECL,bool isRead(),14,21,lib/analyzer.h,isRead,<empty>,,false,69,69,isRead,,,1,bool()
111669154732,METHOD,lib/astutils.h:<global>,TYPE_DECL,"bool astHasExpr(const Token* tok, nonneg int exprid);",6,34,lib/astutils.h,astHasExpr,<empty>,,false,135,135,astHasExpr,,,1,"bool(Token*,int)"
111669154733,METHOD,lib/astutils.h:<global>,TYPE_DECL,const Token *skipUnreachableBranch(const Token *tok);,13,52,lib/astutils.h,skipUnreachableBranch,<empty>,,false,460,460,skipUnreachableBranch,,,1,Token*(Token*)
111669154734,METHOD,gui/resultsview.cpp:<global>,TYPE_DECL,emit gotResults();,14,25,gui/resultsview.cpp,gotResults:ANY(),<empty>,,false,181,181,gotResults,,,1,emit()
111669154735,METHOD,gui/common.h:<global>,TYPE_DECL,QString getDataDir();,9,20,gui/common.h,getDataDir,<empty>,,false,155,155,getDataDir,,,1,QString()
111669154736,METHOD,ConditionHandler,TYPE_DECL,"virtual std::vector<Condition> parse(const Token* tok, const Settings& settings) const = 0;",36,94,lib/valueflow.cpp,"ConditionHandler.parse<const>:ANY(Token*,Settings&)",<empty>,,false,4319,4319,parse,,,1,"std.vector<Condition>(Token*,Settings&)"
111669154737,METHOD,gui/statsdialog.cpp:<global>,TYPE_DECL,"static QChartView *createChart(const QString &statsFile, const QString &tool);",19,77,gui/statsdialog.cpp,"createChart:ANY(QString&,QString&)",<empty>,,false,71,71,createChart,,,1,"QChartView*(QString&,QString&)"
111669154738,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool astIsUnsigned(const Token* tok);,6,36,lib/astutils.h,astIsUnsigned,<empty>,,false,147,147,astIsUnsigned,,,1,bool(Token*)
111669154739,METHOD,ProgramMemory,TYPE_DECL,void setUnknown(const Token* expr);,10,38,lib/programmemory.h,setUnknown,<empty>,,false,117,117,setUnknown,,,1,void(Token*)
111669154740,METHOD,Analyzer.Action,TYPE_DECL,bool get(unsigned int f),14,32,lib/analyzer.h,get,<empty>,,false,65,65,get,,,1,bool(unsigned int)
111669154741,METHOD,cli/signalhandler.h:<global>,TYPE_DECL,void register_signal_handler(FILE* output);,6,42,cli/signalhandler.h,register_signal_handler,<empty>,,false,28,28,register_signal_handler,,,1,void(FILE*)
111669154742,METHOD,lib/astutils.h:<global>,TYPE_DECL,const Token *findNextTokenFromBreak(const Token *breakToken);,13,60,lib/astutils.h,findNextTokenFromBreak,<empty>,,false,229,229,findNextTokenFromBreak,,,1,Token*(Token*)
111669154743,METHOD,PathAnalysis,TYPE_DECL,static const Scope* findOuterScope(const Scope * scope);,23,59,lib/pathanalysis.h,findOuterScope,<empty>,,false,68,68,findOuterScope,,,1,Scope*(Scope*)
111669154744,METHOD,MyLock,TYPE_DECL,MyLock& operator=(const MyLock&);,11,36,externals/simplecpp/simplecpp.cpp,MyLock.=:MyLock<#0>&(MyLock<ANY>&),<empty>,,false,2411,2411,operator =,,,1,MyLock<#0>&(MyLock<ANY>&)
111669154745,METHOD,ValueFlowAnalyzer,TYPE_DECL,virtual ProgramState getProgramState() const = 0;,26,52,lib/vf_analyzers.cpp,ValueFlowAnalyzer.getProgramState<const>:ANY(),<empty>,,false,73,73,getProgramState,,,1,ValueFlowAnalyzer.ProgramState()
111669154746,METHOD,Analyzer,TYPE_DECL,bool stopOnCondition(const Token* condTok),18,54,lib/analyzer.h,stopOnCondition,<empty>,,false,183,183,stopOnCondition,,,1,bool(Token*)
111669154747,METHOD,simplecpp.TokenList.Stream,TYPE_DECL,virtual void unget() = 0;,18,28,externals/simplecpp/simplecpp.cpp,simplecpp.TokenList.Stream.unget:void(),<empty>,,false,251,251,unget,,,1,void()
111669154748,METHOD,lib/astutils.h:<global>,TYPE_DECL,Token* getStepTok(Token* tok);,6,29,lib/astutils.h,getStepTok,<empty>,,false,221,221,getStepTok,,,1,Token*(Token*)
111669154749,METHOD,lib/astutils.h:<global>,TYPE_DECL,Token* getInitTok(Token* tok);,6,29,lib/astutils.h,getInitTok,<empty>,,false,218,218,getInitTok,,,1,Token*(Token*)
111669154750,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool isUnreachableOperand(const Token *tok);,6,43,lib/astutils.h,isUnreachableOperand,<empty>,,false,458,458,isUnreachableOperand,,,1,bool(Token*)
111669154751,METHOD,cli/stacktrace.h:<global>,TYPE_DECL,"void print_stacktrace(FILE* output, int start_idx, bool demangling, int maxdepth, bool omit_above_own);",6,102,cli/stacktrace.h,print_stacktrace,<empty>,,false,40,40,print_stacktrace,,,1,"void(FILE*,int,bool,int,bool)"
111669154752,METHOD,lib/astutils.h:<global>,TYPE_DECL,const Token *findLambdaEndToken(const Token *first);,25,63,lib/astutils.h,findLambdaEndToken,<empty>,,false,417,417,findLambdaEndToken,,,1,Token*(Token*)
111669154753,METHOD,lib/astutils.h:<global>,TYPE_DECL,const Token* getLHSVariableToken(const Token* tok);,12,50,lib/astutils.h,getLHSVariableToken,<empty>,,false,441,441,getLHSVariableToken,,,1,Token*(Token*)
111669154754,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool isLeafDot(const Token* tok);,6,32,lib/astutils.h,isLeafDot,<empty>,,false,433,433,isLeafDot,,,1,bool(Token*)
111669154755,METHOD,Analyzer.Action,TYPE_DECL,bool matches(),14,22,lib/analyzer.h,matches,<empty>,,false,109,109,matches,,,1,bool()
111669154756,METHOD,ValueFlowPass,TYPE_DECL,virtual void run(const ValueFlowState& state) const = 0;,18,59,lib/valueflow.cpp,ValueFlowPass.run<const>:void(ValueFlowState&),<empty>,,false,7064,7064,run,,,1,void(ValueFlowState&)
111669154757,METHOD,ProgramMemory,TYPE_DECL,explicit ProgramMemory(Map values),14,38,lib/programmemory.h,ProgramMemory,<empty>,,false,105,105,ProgramMemory,,,1,explicit(Map)
111669154758,METHOD,C,TYPE_DECL,void foo();,10,14,samples/passedByValue_1/bad.cpp,C.foo:void(),<empty>,,false,8,8,foo,,,1,void()
111669154759,METHOD,lib/astutils.h:<global>,TYPE_DECL,"bool astHasToken(const Token* root, const Token * tok);",6,54,lib/astutils.h,astHasToken,<empty>,,false,133,133,astHasToken,,,1,"bool(Token*,Token*)"
111669154760,METHOD,Analyzer.Action,TYPE_DECL,bool isInvalid(),14,24,lib/analyzer.h,isInvalid,<empty>,,false,77,77,isInvalid,,,1,bool()
111669154761,METHOD,ExprIdToken,TYPE_DECL,int getExpressionId(),16,32,lib/programmemory.h,getExpressionId,<empty>,,false,53,53,getExpressionId,,,1,int()
111669154762,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool astIsContainerView(const Token* tok);,6,41,lib/astutils.h,astIsContainerView,<empty>,,false,163,163,astIsContainerView,,,1,bool(Token*)
111669154763,METHOD,lib/astutils.h:<global>,TYPE_DECL,"bool isWithinScope(const Token* tok,
                   const Variable* var,
                   ScopeType type);",6,34,lib/astutils.h,isWithinScope,<empty>,,false,310,312,isWithinScope,,,1,"bool(Token*,Variable*,ScopeType)"
111669154764,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool astIsLHS(const Token* tok);,6,31,lib/astutils.h,astIsLHS,<empty>,,false,212,212,astIsLHS,,,1,bool(Token*)
111669154765,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool isExhaustiveSwitch(const Token *startbrace);,6,48,lib/astutils.h,isExhaustiveSwitch,<empty>,,false,456,456,isExhaustiveSwitch,,,1,bool(Token*)
111669154766,METHOD,lib/astutils.h:<global>,TYPE_DECL,const Token* previousBeforeAstLeftmostLeaf(const Token* tok);,12,60,lib/astutils.h,previousBeforeAstLeftmostLeaf,<empty>,,false,194,194,previousBeforeAstLeftmostLeaf,,,1,Token*(Token*)
111669154767,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool isVariableDecl(const Token* tok);,6,37,lib/astutils.h,isVariableDecl,<empty>,,false,189,189,isVariableDecl,,,1,bool(Token*)
111669154768,METHOD,lib/token.h:<global>,TYPE_DECL,Token* findTypeEnd(Token* tok);,6,30,lib/token.h,findTypeEnd,<empty>,,false,1592,1592,findTypeEnd,,,1,Token*(Token*)
111669154769,METHOD,Analyzer,TYPE_DECL,"bool updateScope(const Token* endBlock, bool modified)",18,66,lib/analyzer.h,updateScope,<empty>,,false,179,179,updateScope,,,1,"bool(Token*,bool)"
111669154770,METHOD,lib/astutils.h:<global>,TYPE_DECL,bool isScopeBracket(const Token* tok);,6,37,lib/astutils.h,isScopeBracket,<empty>,,false,448,448,isScopeBracket,,,1,bool(Token*)
111669154771,METHOD,lib/tokenlist.h:<global>,TYPE_DECL,const Token* findLambdaEndTokenWithoutAST(const Token* tok);,12,59,lib/tokenlist.h,findLambdaEndTokenWithoutAST,<empty>,,false,236,236,findLambdaEndTokenWithoutAST,,,1,Token*(Token*)
111669154772,METHOD,lib/astutils.h:<global>,TYPE_DECL,int numberOfArgumentsWithoutAst(const Token* start);,5,51,lib/astutils.h,numberOfArgumentsWithoutAst,<empty>,,false,394,394,numberOfArgumentsWithoutAst,,,1,int(Token*)
111669154773,METHOD,lib/tokenlist.h:<global>,TYPE_DECL,const Token* isLambdaCaptureList(const Token* tok);,12,50,lib/tokenlist.h,isLambdaCaptureList,<empty>,,false,235,235,isLambdaCaptureList,,,1,Token*(Token*)
111669154774,METHOD,<includes>:<global>,NAMESPACE_BLOCK,<global>,,,<includes>,<includes>:<global>,<empty>,,false,1,,<global>,,,1,
111669154775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.equals,<empty>,,true,,,<operator>.equals,,,0,
111669154776,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignment,<empty>,,true,,,<operator>.assignment,,,0,
111669154777,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.addressOf,<empty>,,true,,,<operator>.addressOf,,,0,
111669154778,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.fieldAccess,<empty>,,true,,,<operator>.fieldAccess,,,0,
111669154779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.open:<unresolvedSignature>(1),<empty>,,true,,,open,,,0,<unresolvedSignature>
111669154780,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalNot,<empty>,,true,,,<operator>.logicalNot,,,0,
111669154781,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.is_open:<unresolvedSignature>(0),<empty>,,true,,,is_open,,,0,<unresolvedSignature>
111669154782,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getline:<unresolvedSignature>(2),<empty>,,true,,,getline,,,0,<unresolvedSignature>
111669154783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirection,<empty>,,true,,,<operator>.indirection,,,0,
111669154784,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.empty:<unresolvedSignature>(0),<empty>,,true,,,empty,,,0,<unresolvedSignature>
111669154785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.emplace_back:<unresolvedSignature>(1),<empty>,,true,,,emplace_back,,,0,<unresolvedSignature>
111669154786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.move:<unresolvedSignature>(1),<empty>,,true,,,move,,,0,<unresolvedSignature>
111669154787,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.constructorInitializer,<empty>,,true,,,<operator>.constructorInitializer,,,0,
111669154788,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.removeQuotationMarks:<unresolvedSignature>(1),<empty>,,true,,,removeQuotationMarks,,,0,<unresolvedSignature>
111669154789,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fromNativeSeparators:<unresolvedSignature>(1),<empty>,,true,,,fromNativeSeparators,,,0,<unresolvedSignature>
111669154790,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"endsWith:bool(ANY,char)",<empty>,,true,,,endsWith,,,0,"bool(ANY,char)"
111669154791,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentPlus,<empty>,,true,,,<operator>.assignmentPlus,,,0,
111669154792,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.greaterThan,<empty>,,true,,,<operator>.greaterThan,,,0,
111669154793,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.lessThan,<empty>,,true,,,<operator>.lessThan,,,0,
111669154794,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addIncludePathsToList:<unresolvedSignature>(2),<empty>,,true,,,addIncludePathsToList,,,0,<unresolvedSignature>
111669154795,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.insert:<unresolvedSignature>(2),<empty>,,true,,,insert,,,0,<unresolvedSignature>
111669154796,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.cbegin:<unresolvedSignature>(0),<empty>,,true,,,cbegin,,,0,<unresolvedSignature>
111669154797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.cend:<unresolvedSignature>(0),<empty>,,true,,,cend,,,0,<unresolvedSignature>
111669154798,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.shiftLeft,<empty>,,true,,,<operator>.shiftLeft,,,0,
111669154799,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"XMLErrorMessagesLogger.reportOut:void(ANY,Color)",<empty>,,true,,,reportOut,,,0,"void(ANY,Color)"
111669154800,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorMessage.toXML<const>:ANY(),<empty>,,true,,,toXML,,,0,ANY()
111669154801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Path.isHeader:bool(ANY),<empty>,,true,,,isHeader,,,0,bool(ANY)
111669154802,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"matchglobs:bool(ANY,ANY)",<empty>,,true,,,matchglobs,,,0,"bool(ANY,ANY)"
111669154803,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirectFieldAccess,<empty>,,true,,,<operator>.indirectFieldAccess,,,0,
111669154804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FileSettings.filename<const>:ANY(),<empty>,,true,,,filename,,,0,ANY()
111669154805,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalOr,<empty>,,true,,,<operator>.logicalOr,,,0,
111669154806,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.markupFile<const>:bool(ANY),<empty>,,true,,,markupFile,,,0,bool(ANY)
111669154807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.processMarkupAfterCode<const>:bool(ANY),<empty>,,true,,,processMarkupAfterCode,,,0,bool(ANY)
111669154808,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalAnd,<empty>,,true,,,<operator>.logicalAnd,,,0,
111669154809,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FileWithDetails.path<const>:ANY(),<empty>,,true,,,path,,,0,ANY()
111669154810,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CmdLineParser.parseFromArgs:CmdLineParser.Result(int,char**)",<empty>,,true,,,parseFromArgs,,,0,"CmdLineParser.Result(int,char**)"
111669154811,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Settings.terminate:void(bool),<empty>,,true,,,terminate,,,0,void(bool)
111669154812,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.notEquals,<empty>,,true,,,<operator>.notEquals,,,0,
111669154813,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.toNativeSeparators:<unresolvedSignature>(1),<empty>,,true,,,toNativeSeparators,,,0,<unresolvedSignature>
111669154814,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Path.isDirectory:bool(ANY),<empty>,,true,,,isDirectory,,,0,bool(ANY)
111669154815,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.preIncrement,<empty>,,true,,,<operator>.preIncrement,,,0,
111669154816,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SimpleEnableGroup<enumSeverity>.isEnabled<const>:bool(Severity),<empty>,,true,,,isEnabled,,,0,bool(Severity)
111669154817,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.erase:<unresolvedSignature>(1),<empty>,,true,,,erase,,,0,<unresolvedSignature>
111669154818,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CmdLineParser.getIgnoredPaths:ANY(),<empty>,,true,,,getIgnoredPaths,,,0,ANY()
111669154819,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.any_of:<unresolvedSignature>(3),<empty>,,true,,,any_of,,,0,<unresolvedSignature>
111669154820,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.printMessage:<unresolvedSignature>(1),<empty>,,true,,,printMessage,,,0,<unresolvedSignature>
111669154821,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CmdLineParser.getPathNames:ANY(),<empty>,,true,,,getPathNames,,,0,ANY()
111669154822,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CmdLineParser.getFileSettings:ANY(),<empty>,,true,,,getFileSettings,,,0,ANY()
111669154823,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.assert:<unresolvedSignature>(1),<empty>,,true,,,assert,,,0,<unresolvedSignature>
111669154824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.copy_if:<unresolvedSignature>(4),<empty>,,true,,,copy_if,,,0,<unresolvedSignature>
111669154825,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.back_inserter:<unresolvedSignature>(1),<empty>,,true,,,back_inserter,,,0,<unresolvedSignature>
111669154826,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.printError:<unresolvedSignature>(1),<empty>,,true,,,printError,,,0,<unresolvedSignature>
111669154827,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.clear:<unresolvedSignature>(0),<empty>,,true,,,clear,,,0,<unresolvedSignature>
111669154828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.iterator:std.iterator(),<empty>,,true,,,iterator,,,0,std.iterator()
111669154829,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.iterator.hasNext:bool(),<empty>,,true,,,hasNext,,,0,bool()
111669154830,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.iterator.next:ANY(),<empty>,,true,,,next,,,0,ANY()
111669154831,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.markupFile:<unresolvedSignature>(1),<empty>,,true,,,markupFile,,,0,<unresolvedSignature>
111669154832,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.filename:<unresolvedSignature>(0),<empty>,,true,,,filename,,,0,<unresolvedSignature>
111669154833,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setLang:<unresolvedSignature>(1),<empty>,,true,,,setLang,,,0,<unresolvedSignature>
111669154834,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.identify:<unresolvedSignature>(3),<empty>,,true,,,identify,,,0,<unresolvedSignature>
111669154835,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.lang:<unresolvedSignature>(0),<empty>,,true,,,lang,,,0,<unresolvedSignature>
111669154836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FileLister.recursiveAddFiles:ANY(ANY,ANY,ANY,PathMatch&,bool)",<empty>,,true,,,recursiveAddFiles,,,0,"ANY(ANY,ANY,ANY,PathMatch&,bool)"
111669154837,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Path.toNativeSeparators:ANY(ANY),<empty>,,true,,,toNativeSeparators,,,0,ANY(ANY)
111669154838,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CmdLineLogger.printMessage:void(ANY),<empty>,,true,,,printMessage,,,0,void(ANY)
111669154839,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.begin:<unresolvedSignature>(0),<empty>,,true,,,begin,,,0,<unresolvedSignature>
111669154840,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.end:<unresolvedSignature>(0),<empty>,,true,,,end,,,0,<unresolvedSignature>
111669154841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.path:<unresolvedSignature>(0),<empty>,,true,,,path,,,0,<unresolvedSignature>
111669154842,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.erase:<unresolvedSignature>(2),<empty>,,true,,,erase,,,0,<unresolvedSignature>
111669154843,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.remove_if:<unresolvedSignature>(3),<empty>,,true,,,remove_if,,,0,<unresolvedSignature>
111669154844,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.next:<unresolvedSignature>(1),<empty>,,true,,,next,,,0,<unresolvedSignature>
111669154845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.inserter:<unresolvedSignature>(2),<empty>,,true,,,inserter,,,0,<unresolvedSignature>
111669154846,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Path.getCurrentExecutablePath:ANY(char*),<empty>,,true,,,getCurrentExecutablePath,,,0,ANY(char*)
111669154847,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirectIndexAccess,<empty>,,true,,,<operator>.indirectIndexAccess,,,0,
111669154848,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.lessEqualsThan,<empty>,,true,,,<operator>.lessEqualsThan,,,0,
111669154849,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CmdLineParser.printHelp:void(),<empty>,,true,,,printHelp,,,0,void()
111669154850,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.postIncrement,<empty>,,true,,,<operator>.postIncrement,,,0,
111669154851,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.strcmp:<unresolvedSignature>(2),<empty>,,true,,,strcmp,,,0,<unresolvedSignature>
111669154852,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Check.instances:ANY(),<empty>,,true,,,instances,,,0,ANY()
111669154853,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Check.name<const>:ANY(),<empty>,,true,,,name,,,0,ANY()
111669154854,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Check.classInfo<const>:ANY(),<empty>,,true,,,classInfo,,,0,ANY()
111669154855,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.printRaw:<unresolvedSignature>(1),<empty>,,true,,,printRaw,,,0,<unresolvedSignature>
111669154856,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.str:<unresolvedSignature>(0),<empty>,,true,,,str,,,0,<unresolvedSignature>
111669154857,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ErrorMessage.getXMLHeader:ANY(ANY,int)",<empty>,,true,,,getXMLHeader,,,0,"ANY(ANY,int)"
111669154858,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorMessage.getXMLFooter:ANY(int),<empty>,,true,,,getXMLFooter,,,0,ANY(int)
111669154859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CmdLineParser.getVersion:ANY(),<empty>,,true,,,getVersion,,,0,ANY()
111669154860,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CmdLineLogger.printRaw:void(ANY),<empty>,,true,,,printRaw,,,0,void(ANY)
111669154861,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.strncmp:<unresolvedSignature>(3),<empty>,,true,,,strncmp,,,0,<unresolvedSignature>
111669154862,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.greaterEqualsThan,<empty>,,true,,,<operator>.greaterEqualsThan,,,0,
111669154863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.addition,<empty>,,true,,,<operator>.addition,,,0,
111669154864,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.find:<unresolvedSignature>(1),<empty>,,true,,,find,,,0,<unresolvedSignature>
111669154865,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.insert:<unresolvedSignature>(1),<empty>,,true,,,insert,,,0,<unresolvedSignature>
111669154866,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.emplace:<unresolvedSignature>(1),<empty>,,true,,,emplace,,,0,<unresolvedSignature>
111669154867,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.assign:<unresolvedSignature>(1),<empty>,,true,,,assign,,,0,<unresolvedSignature>
111669154868,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CmdLineLogger.printError:void(ANY),<empty>,,true,,,printError,,,0,void(ANY)
111669154869,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.parseNumberArg:<unresolvedSignature>(4),<empty>,,true,,,parseNumberArg,,,0,<unresolvedSignature>
111669154870,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"addPathsToSet:bool(ANY,ANY)",<empty>,,true,,,addPathsToSet,,,0,"bool(ANY,ANY)"
111669154871,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.pop_back:<unresolvedSignature>(0),<empty>,,true,,,pop_back,,,0,<unresolvedSignature>
111669154872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.removeEnabled:<unresolvedSignature>(1),<empty>,,true,,,removeEnabled,,,0,<unresolvedSignature>
111669154873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Settings.addEnabled:ANY(ANY),<empty>,,true,,,addEnabled,,,0,ANY(ANY)
111669154874,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addEnabled:<unresolvedSignature>(1),<empty>,,true,,,addEnabled,,,0,<unresolvedSignature>
111669154875,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.parseNumberArg:<unresolvedSignature>(3),<empty>,,true,,,parseNumberArg,,,0,<unresolvedSignature>
111669154876,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SuppressionList.parseFile:ANY(ANY),<empty>,,true,,,parseFile,,,0,ANY(ANY)
111669154877,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addFilesToList:<unresolvedSignature>(2),<empty>,,true,,,addFilesToList,,,0,<unresolvedSignature>
111669154878,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"addFilesToList:bool(ANY,ANY)",<empty>,,true,,,addFilesToList,,,0,"bool(ANY,ANY)"
111669154879,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"addIncludePathsToList:bool(ANY,ANY)",<empty>,,true,,,addIncludePathsToList,,,0,"bool(ANY,ANY)"
111669154880,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SimpleEnableGroup<enumCertainty>.enable:void(Certainty),<empty>,,true,,,enable,,,0,void(Certainty)
111669154881,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.strToInt:<unresolvedSignature>(3),<empty>,,true,,,strToInt,,,0,<unresolvedSignature>
111669154882,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.splitString:<unresolvedSignature>(2),<empty>,,true,,,splitString,,,0,<unresolvedSignature>
111669154883,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.simplifyPath:<unresolvedSignature>(1),<empty>,,true,,,simplifyPath,,,0,<unresolvedSignature>
111669154884,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.arrayInitializer,<empty>,,true,,,<operator>.arrayInitializer,,,0,
111669154885,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Platform.set:bool(ANY,ANY,ANY,bool)",<empty>,,true,,,set,,,0,"bool(ANY,ANY,ANY,bool)"
111669154886,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CmdLineParser.isCppcheckPremium:bool(),<empty>,,true,,,isCppcheckPremium,,,0,bool()
111669154887,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.conditional,<empty>,,true,,,<operator>.conditional,,,0,
111669154888,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.substr:<unresolvedSignature>(2),<empty>,,true,,,substr,,,0,<unresolvedSignature>
111669154889,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.count:<unresolvedSignature>(1),<empty>,,true,,,count,,,0,<unresolvedSignature>
111669154890,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.startsWith:<unresolvedSignature>(2),<empty>,,true,,,startsWith,,,0,<unresolvedSignature>
111669154891,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ImportProject.import:ImportProject.Type(ANY,Settings*,Suppressions*)",<empty>,,true,,,import,,,0,"ImportProject.Type(ANY,Settings*,Suppressions*)"
111669154892,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.copy:<unresolvedSignature>(3),<empty>,,true,,,copy,,,0,<unresolvedSignature>
111669154893,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.import:<unresolvedSignature>(3),<empty>,,true,,,import,,,0,<unresolvedSignature>
111669154894,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ImportProject.ignoreOtherConfigs:void(ANY),<empty>,,true,,,ignoreOtherConfigs,,,0,void(ANY)
111669154895,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.string:<unresolvedSignature>(1),<empty>,,true,,,string,,,0,<unresolvedSignature>
111669154896,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Standards.setStd:bool(ANY),<empty>,,true,,,setStd,,,0,bool(ANY)
111669154897,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SuppressionList.addSuppressionLine:ANY(ANY),<empty>,,true,,,addSuppressionLine,,,0,ANY(ANY)
111669154898,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.count:<unresolvedSignature>(3),<empty>,,true,,,count,,,0,<unresolvedSignature>
111669154899,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SuppressionList.parseXmlFile:ANY(char*),<empty>,,true,,,parseXmlFile,,,0,ANY(char*)
111669154900,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Settings.useSingleJob<const>:bool(),<empty>,,true,,,useSingleJob,,,0,bool()
111669154901,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,substituteTemplateFormatStatic:void(ANY),<empty>,,true,,,substituteTemplateFormatStatic,,,0,void(ANY)
111669154902,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,substituteTemplateLocationStatic:void(ANY),<empty>,,true,,,substituteTemplateLocationStatic,,,0,void(ANY)
111669154903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SimpleEnableGroup<enumChecks>.isEnabled<const>:bool(Checks),<empty>,,true,,,isEnabled,,,0,bool(Checks)
111669154904,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.exists:<unresolvedSignature>(2),<empty>,,true,,,exists,,,0,<unresolvedSignature>
111669154905,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.endsWith:<unresolvedSignature>(2),<empty>,,true,,,endsWith,,,0,<unresolvedSignature>
111669154906,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ImportProject.ignorePaths:void(ANY,bool)",<empty>,,true,,,ignorePaths,,,0,"void(ANY,bool)"
111669154907,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.size:<unresolvedSignature>(0),<empty>,,true,,,size,,,0,<unresolvedSignature>
111669154908,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Settings.loadCppcheckCfg:ANY(Settings&,Suppressions&,bool)",<empty>,,true,,,loadCppcheckCfg,,,0,"ANY(Settings&,Suppressions&,bool)"
111669154909,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.load:<unresolvedSignature>(3),<empty>,,true,,,load,,,0,<unresolvedSignature>
111669154910,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.c_str:<unresolvedSignature>(0),<empty>,,true,,,c_str,,,0,<unresolvedSignature>
111669154911,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CmdLineParser.tryLoadLibrary:bool(Library&,ANY,char*,bool)",<empty>,,true,,,tryLoadLibrary,,,0,"bool(Library&,ANY,char*,bool)"
111669154912,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Path.fromNativeSeparators:ANY(ANY),<empty>,,true,,,fromNativeSeparators,,,0,ANY(ANY)
111669154913,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Path.getPathFromFilename:ANY(ANY),<empty>,,true,,,getPathFromFilename,,,0,ANY(ANY)
111669154914,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.tryLoadLibrary:<unresolvedSignature>(4),<empty>,,true,,,tryLoadLibrary,,,0,<unresolvedSignature>
111669154915,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"AddonInfo.getAddonInfo:ANY(ANY,ANY,bool)",<empty>,,true,,,getAddonInfo,,,0,"ANY(ANY,ANY,bool)"
111669154916,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.push_back:<unresolvedSignature>(1),<empty>,,true,,,push_back,,,0,<unresolvedSignature>
111669154917,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.value:<unresolvedSignature>(1),<empty>,,true,,,value,,,0,<unresolvedSignature>
111669154918,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.shortMessage:<unresolvedSignature>(0),<empty>,,true,,,shortMessage,,,0,<unresolvedSignature>
111669154919,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.verboseMessage:<unresolvedSignature>(0),<empty>,,true,,,verboseMessage,,,0,<unresolvedSignature>
111669154920,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sarifPrecision:<unresolvedSignature>(1),<empty>,,true,,,sarifPrecision,,,0,<unresolvedSignature>
111669154921,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isCriticalErrorId:<unresolvedSignature>(1),<empty>,,true,,,isCriticalErrorId,,,0,<unresolvedSignature>
111669154922,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getfile:<unresolvedSignature>(1),<empty>,,true,,,getfile,,,0,<unresolvedSignature>
111669154923,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.cast,<empty>,,true,,,<operator>.cast,,,0,
111669154924,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sarifSeverity:<unresolvedSignature>(1),<empty>,,true,,,sarifSeverity,,,0,<unresolvedSignature>
111669154925,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.serializeLocations:<unresolvedSignature>(1),<empty>,,true,,,serializeLocations,,,0,<unresolvedSignature>
111669154926,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SarifReport.serializeRules:ANY(),<empty>,,true,,,serializeRules,,,0,ANY()
111669154927,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SarifReport.serializeResults:ANY(),<empty>,,true,,,serializeResults,,,0,ANY()
111669154928,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Settings.getNameAndVersion:ANY(ANY),<empty>,,true,,,getNameAndVersion,,,0,ANY(ANY)
111669154929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SarifReport.serializeRuns:ANY(ANY,ANY)",<empty>,,true,,,serializeRuns,,,0,"ANY(ANY,ANY)"
111669154930,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.serialize:<unresolvedSignature>(1),<empty>,,true,,,serialize,,,0,<unresolvedSignature>
111669154931,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorLogger.isCriticalErrorId:bool(ANY),<empty>,,true,,,isCriticalErrorId,,,0,bool(ANY)
111669154932,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CmdLineLoggerStd.printRaw:void(ANY),<empty>,,true,,,printRaw,,,0,void(ANY)
111669154933,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CmdLineLoggerStd.printMessage:void(ANY),<empty>,,true,,,printMessage,,,0,void(ANY)
111669154934,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.new,<empty>,,true,,,<operator>.new,,,0,
111669154935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StdLogger.reportErr:void(ANY),<empty>,,true,,,reportErr,,,0,void(ANY)
111669154936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SarifReport.serialize<const>:ANY(ANY),<empty>,,true,,,serialize,,,0,ANY(ANY)
111669154937,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.delete,<empty>,,true,,,<operator>.delete,,,0,
111669154938,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.time:<unresolvedSignature>(1),<empty>,,true,,,time,,,0,<unresolvedSignature>
111669154939,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CmdLineParser.fillSettingsFromArgs:bool(int,char**)",<empty>,,true,,,fillSettingsFromArgs,,,0,"bool(int,char**)"
111669154940,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Settings.terminated:bool(),<empty>,,true,,,terminated,,,0,bool()
111669154941,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CmdLineParser.getFiles<const>:ANY(),<empty>,,true,,,getFiles,,,0,ANY()
111669154942,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CmdLineParser.getFileSettings<const>:ANY(),<empty>,,true,,,getFileSettings,,,0,ANY()
111669154943,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setMisraRuleTexts:<unresolvedSignature>(1),<empty>,,true,,,setMisraRuleTexts,,,0,<unresolvedSignature>
111669154944,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CppCheckExecutor.check_internal:int(Settings&,Suppressions&)",<empty>,,true,,,check_internal,,,0,"int(Settings&,Suppressions&)"
111669154945,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SuppressionList.getSuppressions<const>:ANY(),<empty>,,true,,,getSuppressions,,,0,ANY()
111669154946,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentOr,<empty>,,true,,,<operators>.assignmentOr,,,0,
111669154947,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.reportUnmatchedSuppressions:<unresolvedSignature>(2),<empty>,,true,,,reportUnmatchedSuppressions,,,0,<unresolvedSignature>
111669154948,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getUnmatchedLocalSuppressions:<unresolvedSignature>(2),<empty>,,true,,,getUnmatchedLocalSuppressions,,,0,<unresolvedSignature>
111669154949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SuppressionList.reportUnmatchedSuppressions:bool(ANY,ErrorLogger&)",<empty>,,true,,,reportUnmatchedSuppressions,,,0,"bool(ANY,ErrorLogger&)"
111669154950,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SuppressionList.getUnmatchedInlineSuppressions<const>:ANY(bool),<empty>,,true,,,getUnmatchedInlineSuppressions,,,0,ANY(bool)
111669154951,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SuppressionList.getUnmatchedGlobalSuppressions<const>:ANY(bool),<empty>,,true,,,getUnmatchedGlobalSuppressions,,,0,ANY(bool)
111669154952,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.writeFilesTxt:<unresolvedSignature>(4),<empty>,,true,,,writeFilesTxt,,,0,<unresolvedSignature>
111669154953,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.remove:<unresolvedSignature>(1),<empty>,,true,,,remove,,,0,<unresolvedSignature>
111669154954,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CppCheck.analyseWholeProgram:unsigned int(ANY,ANY,ANY,ANY)",<empty>,,true,,,analyseWholeProgram,,,0,"unsigned int(ANY,ANY,ANY,ANY)"
111669154955,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CppCheckExecutor.reportSuppressions:bool(Settings&,SuppressionList&,bool,ANY,ANY,ErrorLogger&)",<empty>,,true,,,reportSuppressions,,,0,"bool(Settings&,SuppressionList&,bool,ANY,ANY,ErrorLogger&)"
111669154956,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.tooManyConfigsError:<unresolvedSignature>(2),<empty>,,true,,,tooManyConfigsError,,,0,<unresolvedSignature>
111669154957,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.to_string:<unresolvedSignature>(1),<empty>,,true,,,to_string,,,0,<unresolvedSignature>
111669154958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorMessage.setmsg:void(ANY),<empty>,,true,,,setmsg,,,0,void(ANY)
111669154959,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckersReport.getReport<const>:ANY(ANY),<empty>,,true,,,getReport,,,0,ANY(ANY)
111669154960,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.reportErr:<unresolvedSignature>(1),<empty>,,true,,,reportErr,,,0,<unresolvedSignature>
111669154961,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SuppressionList.dump<const>:void(ANY),<empty>,,true,,,dump,,,0,void(ANY)
111669154962,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckersReport.getXmlReport<const>:ANY(ANY),<empty>,,true,,,getXmlReport,,,0,ANY(ANY)
111669154963,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cli/cppcheckexecutor.cpp,cli/cppcheckexecutor.cpp:575:575:ansiToOEM:2,<empty>,,true,575,575,ansiToOEM,,,0,
111669154964,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.reportOut:<unresolvedSignature>(1),<empty>,,true,,,reportOut,,,0,<unresolvedSignature>
111669154965,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorMessage.shortMessage<const>:ANY(),<empty>,,true,,,shortMessage,,,0,ANY()
111669154966,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getGuideline:ANY(ANY,ReportType,ANY,Severity)",<empty>,,true,,,getGuideline,,,0,"ANY(ANY,ReportType,ANY,Severity)"
111669154967,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getClassification:ANY(ANY,ReportType)",<empty>,,true,,,getClassification,,,0,"ANY(ANY,ReportType)"
111669154968,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ErrorMessage.toString<const>:ANY(bool,ANY,ANY)",<empty>,,true,,,toString,,,0,"ANY(bool,ANY,ANY)"
111669154969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addFinding:<unresolvedSignature>(1),<empty>,,true,,,addFinding,,,0,<unresolvedSignature>
111669154970,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.popen:<unresolvedSignature>(2),<empty>,,true,,,popen,,,0,<unresolvedSignature>
111669154971,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.minus,<empty>,,true,,,<operator>.minus,,,0,
111669154972,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.alloc,<empty>,,true,,,<operator>.alloc,,,0,
111669154973,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fgets:<unresolvedSignature>(3),<empty>,,true,,,fgets,,,0,<unresolvedSignature>
111669154974,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.sizeOf,<empty>,,true,,,<operator>.sizeOf,,,0,
111669154975,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.pclose:<unresolvedSignature>(1),<empty>,,true,,,pclose,,,0,<unresolvedSignature>
111669154976,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.WIFEXITED:<unresolvedSignature>(1),<empty>,,true,,,WIFEXITED,,,0,<unresolvedSignature>
111669154977,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.WEXITSTATUS:<unresolvedSignature>(1),<empty>,,true,,,WEXITSTATUS,,,0,<unresolvedSignature>
111669154978,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.WIFSIGNALED:<unresolvedSignature>(1),<empty>,,true,,,WIFSIGNALED,,,0,<unresolvedSignature>
111669154979,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.WTERMSIG:<unresolvedSignature>(1),<empty>,,true,,,WTERMSIG,,,0,<unresolvedSignature>
111669154980,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SuppressionList.isSuppressed:bool(ErrorMessage&,ANY)",<empty>,,true,,,isSuppressed,,,0,"bool(ErrorMessage&,ANY)"
111669154981,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.lg:<unresolvedSignature>(1),<empty>,,true,,,lg,,,0,<unresolvedSignature>
111669154982,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.division,<empty>,,true,,,<operator>.division,,,0,
111669154983,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.multiplication,<empty>,,true,,,<operator>.multiplication,,,0,
111669154984,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.reportOut:<unresolvedSignature>(2),<empty>,,true,,,reportOut,,,0,<unresolvedSignature>
111669154985,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PathMatch.match<const>:bool(ANY),<empty>,,true,,,match,,,0,bool(ANY)
111669154986,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.stat:<unresolvedSignature>(2),<empty>,,true,,,stat,,,0,<unresolvedSignature>
111669154987,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.and,<empty>,,true,,,<operator>.and,,,0,
111669154988,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.emplace_back:<unresolvedSignature>(3),<empty>,,true,,,emplace_back,,,0,<unresolvedSignature>
111669154989,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.opendir:<unresolvedSignature>(1),<empty>,,true,,,opendir,,,0,<unresolvedSignature>
111669154990,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.length:<unresolvedSignature>(0),<empty>,,true,,,length,,,0,<unresolvedSignature>
111669154991,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"addFiles2:ANY(ANY,ANY,ANY,bool,PathMatch&,bool)",<empty>,,true,,,addFiles2,,,0,"ANY(ANY,ANY,ANY,bool,PathMatch&,bool)"
111669154992,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Path.acceptFile:bool(ANY,ANY,Standards.Language*)",<empty>,,true,,,acceptFile,,,0,"bool(ANY,ANY,Standards.Language*)"
111669154993,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.subtraction,<empty>,,true,,,<operator>.subtraction,,,0,
111669154994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sort:<unresolvedSignature>(1),<empty>,,true,,,sort,,,0,<unresolvedSignature>
111669154995,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.insert:<unresolvedSignature>(3),<empty>,,true,,,insert,,,0,<unresolvedSignature>
111669154996,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.make_move_iterator:<unresolvedSignature>(1),<empty>,,true,,,make_move_iterator,,,0,<unresolvedSignature>
111669154997,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FileLister.addFiles:ANY(ANY,ANY,ANY,bool,PathMatch&,bool)",<empty>,,true,,,addFiles,,,0,"ANY(ANY,ANY,ANY,bool,PathMatch&,bool)"
111669154998,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CppCheckExecutor.check:int(int,char**)",<empty>,,true,,,check,,,0,"int(int,char**)"
111669154999,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"PipeWriter.writeToPipe:void(PipeWriter.PipeSignal,ANY)",<empty>,,true,,,writeToPipe,,,0,"void(PipeWriter.PipeSignal,ANY)"
111669155000,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorMessage.serialize<const>:ANY(),<empty>,,true,,,serialize,,,0,ANY()
111669155001,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.writeToPipe:<unresolvedSignature>(2),<empty>,,true,,,writeToPipe,,,0,<unresolvedSignature>
111669155002,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.suppressionToString:<unresolvedSignature>(1),<empty>,,true,,,suppressionToString,,,0,<unresolvedSignature>
111669155003,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SuppressionList.Suppression.toString<const>:ANY(),<empty>,,true,,,toString,,,0,ANY()
111669155004,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.write:<unresolvedSignature>(3),<empty>,,true,,,write,,,0,<unresolvedSignature>
111669155005,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.strerror:<unresolvedSignature>(1),<empty>,,true,,,strerror,,,0,<unresolvedSignature>
111669155006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.writeToPipeInternal:<unresolvedSignature>(3),<empty>,,true,,,writeToPipeInternal,,,0,<unresolvedSignature>
111669155007,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"PipeWriter.writeToPipeInternal:void(PipeWriter.PipeSignal,void*,ANY)",<empty>,,true,,,writeToPipeInternal,,,0,"void(PipeWriter.PipeSignal,void*,ANY)"
111669155008,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.read:<unresolvedSignature>(3),<empty>,,true,,,read,,,0,<unresolvedSignature>
111669155009,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,int,<empty>,,true,,,int,,,0,
111669155010,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentMinus,<empty>,,true,,,<operator>.assignmentMinus,,,0,
111669155011,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.substr:<unresolvedSignature>(1),<empty>,,true,,,substr,,,0,<unresolvedSignature>
111669155012,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorMessage.deserialize:void(ANY),<empty>,,true,,,deserialize,,,0,void(ANY)
111669155013,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorLogger.reportErr:void(ErrorMessage&),<empty>,,true,,,reportErr,,,0,void(ErrorMessage&)
111669155014,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"splitString:ANY(ANY,char)",<empty>,,true,,,splitString,,,0,"ANY(ANY,char)"
111669155015,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.parseLine:<unresolvedSignature>(1),<empty>,,true,,,parseLine,,,0,<unresolvedSignature>
111669155016,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addSuppression:<unresolvedSignature>(1),<empty>,,true,,,addSuppression,,,0,<unresolvedSignature>
111669155017,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.updateSuppressionState:<unresolvedSignature>(1),<empty>,,true,,,updateSuppressionState,,,0,<unresolvedSignature>
111669155018,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.stoi:<unresolvedSignature>(1),<empty>,,true,,,stoi,,,0,<unresolvedSignature>
111669155019,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getloadavg:<unresolvedSignature>(2),<empty>,,true,,,getloadavg,,,0,<unresolvedSignature>
111669155020,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FileWithDetails.size<const>:ANY(),<empty>,,true,,,size,,,0,ANY()
111669155021,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.accumulate:<unresolvedSignature>(4),<empty>,,true,,,accumulate,,,0,<unresolvedSignature>
111669155022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.size_t:<unresolvedSignature>(1),<empty>,,true,,,size_t,,,0,<unresolvedSignature>
111669155023,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProcessExecutor.checkLoadAverage:bool(ANY),<empty>,,true,,,checkLoadAverage,,,0,bool(ANY)
111669155024,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.pipe:<unresolvedSignature>(1),<empty>,,true,,,pipe,,,0,<unresolvedSignature>
111669155025,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fcntl:<unresolvedSignature>(3),<empty>,,true,,,fcntl,,,0,<unresolvedSignature>
111669155026,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fork:<unresolvedSignature>(0),<empty>,,true,,,fork,,,0,<unresolvedSignature>
111669155027,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.close:<unresolvedSignature>(1),<empty>,,true,,,close,,,0,<unresolvedSignature>
111669155028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.check:<unresolvedSignature>(1),<empty>,,true,,,check,,,0,<unresolvedSignature>
111669155029,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.analyseClangTidy:<unresolvedSignature>(1),<empty>,,true,,,analyseClangTidy,,,0,<unresolvedSignature>
111669155030,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.writeEnd:<unresolvedSignature>(1),<empty>,,true,,,writeEnd,,,0,<unresolvedSignature>
111669155031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.FD_ZERO:<unresolvedSignature>(1),<empty>,,true,,,FD_ZERO,,,0,<unresolvedSignature>
111669155032,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.FD_SET:<unresolvedSignature>(2),<empty>,,true,,,FD_SET,,,0,<unresolvedSignature>
111669155033,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.select:<unresolvedSignature>(5),<empty>,,true,,,select,,,0,<unresolvedSignature>
111669155034,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.max_element:<unresolvedSignature>(2),<empty>,,true,,,max_element,,,0,<unresolvedSignature>
111669155035,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.FD_ISSET:<unresolvedSignature>(2),<empty>,,true,,,FD_ISSET,,,0,<unresolvedSignature>
111669155036,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.as_const:<unresolvedSignature>(1),<empty>,,true,,,as_const,,,0,<unresolvedSignature>
111669155037,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.handleRead:<unresolvedSignature>(3),<empty>,,true,,,handleRead,,,0,<unresolvedSignature>
111669155038,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.find_if:<unresolvedSignature>(3),<empty>,,true,,,find_if,,,0,<unresolvedSignature>
111669155039,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.reportStatus:<unresolvedSignature>(4),<empty>,,true,,,reportStatus,,,0,<unresolvedSignature>
111669155040,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.waitpid:<unresolvedSignature>(3),<empty>,,true,,,waitpid,,,0,<unresolvedSignature>
111669155041,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.reportInternalChildErr:<unresolvedSignature>(2),<empty>,,true,,,reportInternalChildErr,,,0,<unresolvedSignature>
111669155042,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.DECLARE_SIGNAL:<unresolvedSignature>(1),<empty>,,true,,,DECLARE_SIGNAL,,,0,<unresolvedSignature>
111669155043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ErrorLogger.reportOut:void(ANY,Color)",<empty>,,true,,,reportOut,,,0,"void(ANY,Color)"
111669155044,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThreadExecutor.hasToLog:bool(ErrorMessage&),<empty>,,true,,,hasToLog,,,0,bool(ErrorMessage&)
111669155045,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ThreadExecutor.reportStatus:void(ANY,ANY,ANY,ANY)",<empty>,,true,,,reportStatus,,,0,"void(ANY,ANY,ANY,ANY)"
111669155046,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.l:<unresolvedSignature>(1),<empty>,,true,,,l,,,0,<unresolvedSignature>
111669155047,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isLocal:<unresolvedSignature>(0),<empty>,,true,,,isLocal,,,0,<unresolvedSignature>
111669155048,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SyncLogForwarder.reportStatus:void(ANY,ANY,ANY,ANY)",<empty>,,true,,,reportStatus,,,0,"void(ANY,ANY,ANY,ANY)"
111669155049,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.get:<unresolvedSignature>(0),<empty>,,true,,,get,,,0,<unresolvedSignature>
111669155050,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.reserve:<unresolvedSignature>(1),<empty>,,true,,,reserve,,,0,<unresolvedSignature>
111669155051,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.async:<unresolvedSignature>(3),<empty>,,true,,,async,,,0,<unresolvedSignature>
111669155052,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.what:<unresolvedSignature>(0),<empty>,,true,,,what,,,0,<unresolvedSignature>
111669155053,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sscanf:<unresolvedSignature>(3),<empty>,,true,,,sscanf,,,0,<unresolvedSignature>
111669155054,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.check:<unresolvedSignature>(2),<empty>,,true,,,check,,,0,<unresolvedSignature>
111669155055,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.FileWithDetails:<unresolvedSignature>(1),<empty>,,true,,,FileWithDetails,,,0,<unresolvedSignature>
111669155056,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fprintf:<unresolvedSignature>(3),<empty>,,true,,,fprintf,,,0,<unresolvedSignature>
111669155057,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getenv:<unresolvedSignature>(1),<empty>,,true,,,getenv,,,0,<unresolvedSignature>
111669155058,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.strncpy:<unresolvedSignature>(3),<empty>,,true,,,strncpy,,,0,<unresolvedSignature>
111669155059,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.min:<unresolvedSignature>(2),<empty>,,true,,,min,,,0,<unresolvedSignature>
111669155060,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.atoi:<unresolvedSignature>(1),<empty>,,true,,,atoi,,,0,<unresolvedSignature>
111669155061,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fopen:<unresolvedSignature>(2),<empty>,,true,,,fopen,,,0,<unresolvedSignature>
111669155062,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CppcheckExecutor.run:void(char*),<empty>,,true,,,run,,,0,void(char*)
111669155063,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fclose:<unresolvedSignature>(1),<empty>,,true,,,fclose,,,0,<unresolvedSignature>
111669155064,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.compare:<unresolvedSignature>(3),<empty>,,true,,,compare,,,0,<unresolvedSignature>
111669155065,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.rbegin:<unresolvedSignature>(0),<empty>,,true,,,rbegin,,,0,<unresolvedSignature>
111669155066,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isHex:bool(ANY),<empty>,,true,,,isHex,,,0,bool(ANY)
111669155067,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isOct:bool(ANY),<empty>,,true,,,isOct,,,0,bool(ANY)
111669155068,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.arithmeticShiftRight,<empty>,,true,,,<operator>.arithmeticShiftRight,,,0,
111669155069,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.equal:<unresolvedSignature>(3),<empty>,,true,,,equal,,,0,<unresolvedSignature>
111669155070,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.rend:<unresolvedSignature>(0),<empty>,,true,,,rend,,,0,<unresolvedSignature>
111669155071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.Location.sameline<const>:bool(simplecpp.Location&),<empty>,,true,,,sameline,,,0,bool(simplecpp.Location&)
111669155072,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.Token.str<const>:ANY(),<empty>,,true,,,str,,,0,ANY()
111669155073,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.find:<unresolvedSignature>(2),<empty>,,true,,,find,,,0,<unresolvedSignature>
111669155074,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.replace:<unresolvedSignature>(3),<empty>,,true,,,replace,,,0,<unresolvedSignature>
111669155075,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.strpbrk:<unresolvedSignature>(2),<empty>,,true,,,strpbrk,,,0,<unresolvedSignature>
111669155076,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.strchr:<unresolvedSignature>(2),<empty>,,true,,,strchr,,,0,<unresolvedSignature>
111669155077,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplecpp.TokenList.Stream.makeUtf16Char:int(unsigned char,unsigned char)",<empty>,,true,,,makeUtf16Char,,,0,"int(unsigned char,unsigned char)"
111669155078,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.or,<empty>,,true,,,<operator>.or,,,0,
111669155079,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.good:<unresolvedSignature>(0),<empty>,,true,,,good,,,0,<unresolvedSignature>
111669155080,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.peek:<unresolvedSignature>(0),<empty>,,true,,,peek,,,0,<unresolvedSignature>
111669155081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.unget:<unresolvedSignature>(0),<empty>,,true,,,unget,,,0,<unresolvedSignature>
111669155082,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.preDecrement,<empty>,,true,,,<operator>.preDecrement,,,0,
111669155083,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Output:<unresolvedSignature>(3),<empty>,,true,,,Output,,,0,<unresolvedSignature>
111669155084,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fgetc:<unresolvedSignature>(1),<empty>,,true,,,fgetc,,,0,<unresolvedSignature>
111669155085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fseek:<unresolvedSignature>(3),<empty>,,true,,,fseek,,,0,<unresolvedSignature>
111669155086,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ungetc:<unresolvedSignature>(2),<empty>,,true,,,ungetc,,,0,<unresolvedSignature>
111669155087,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplecpp.TokenList.readfile:void(simplecpp.TokenList.Stream&,ANY,ANY)",<empty>,,true,,,readfile,,,0,"void(simplecpp.TokenList.Stream&,ANY,ANY)"
111669155088,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.TokenList.cfront<const>:simplecpp.Token*(),<empty>,,true,,,cfront,,,0,simplecpp.Token*()
111669155089,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.TokenList.stringify:ANY(),<empty>,,true,,,stringify,,,0,ANY()
111669155090,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.TokenList.cfront:simplecpp.Token*(),<empty>,,true,,,cfront,,,0,simplecpp.Token*()
111669155091,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.Location.file<const>:ANY(),<empty>,,true,,,file,,,0,ANY()
111669155092,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.Location.adjust:void(ANY),<empty>,,true,,,adjust,,,0,void(ANY)
111669155093,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isalnum:<unresolvedSignature>(1),<empty>,,true,,,isalnum,,,0,<unresolvedSignature>
111669155094,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.TokenList.cback:simplecpp.Token*(),<empty>,,true,,,cback,,,0,simplecpp.Token*()
111669155095,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.TokenList.deleteToken:void(simplecpp.Token*),<empty>,,true,,,deleteToken,,,0,void(simplecpp.Token*)
111669155096,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.TokenList.back:simplecpp.Token*(),<empty>,,true,,,back,,,0,simplecpp.Token*()
111669155097,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.TokenList.fileIndex:unsigned int(ANY),<empty>,,true,,,fileIndex,,,0,unsigned int(ANY)
111669155098,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"portabilityBackslash:void(ANY,ANY,simplecpp.Location&)",<empty>,,true,,,portabilityBackslash,,,0,"void(ANY,ANY,simplecpp.Location&)"
111669155099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.TokenList.isLastLinePreprocessor:bool(int),<empty>,,true,,,isLastLinePreprocessor,,,0,bool(int)
111669155100,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.TokenList.lastLine:ANY(int),<empty>,,true,,,lastLine,,,0,ANY(int)
111669155101,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.push:<unresolvedSignature>(1),<empty>,,true,,,push,,,0,<unresolvedSignature>
111669155102,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fileIndex:<unresolvedSignature>(1),<empty>,,true,,,fileIndex,,,0,<unresolvedSignature>
111669155103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.lineDirective:<unresolvedSignature>(3),<empty>,,true,,,lineDirective,,,0,<unresolvedSignature>
111669155104,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.atol:<unresolvedSignature>(1),<empty>,,true,,,atol,,,0,<unresolvedSignature>
111669155105,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.replaceAll:<unresolvedSignature>(3),<empty>,,true,,,replaceAll,,,0,<unresolvedSignature>
111669155106,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.top:<unresolvedSignature>(0),<empty>,,true,,,top,,,0,<unresolvedSignature>
111669155107,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.pop:<unresolvedSignature>(0),<empty>,,true,,,pop,,,0,<unresolvedSignature>
111669155108,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.TokenList.lastLineTok:simplecpp.Token*(int),<empty>,,true,,,lastLineTok,,,0,simplecpp.Token*(int)
111669155109,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isdigit:<unresolvedSignature>(1),<empty>,,true,,,isdigit,,,0,<unresolvedSignature>
111669155110,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.find_last_not_of:<unresolvedSignature>(1),<empty>,,true,,,find_last_not_of,,,0,<unresolvedSignature>
111669155111,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"endsWith:bool(ANY,ANY)",<empty>,,true,,,endsWith,,,0,"bool(ANY,ANY)"
111669155112,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isStringLiteralPrefix:bool(ANY),<empty>,,true,,,isStringLiteralPrefix,,,0,bool(ANY)
111669155113,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.resize:<unresolvedSignature>(1),<empty>,,true,,,resize,,,0,<unresolvedSignature>
111669155114,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,escapeString:ANY(ANY),<empty>,,true,,,escapeString,,,0,ANY(ANY)
111669155115,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.Token.setstr:void(ANY),<empty>,,true,,,setstr,,,0,void(ANY)
111669155116,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.find_first_of:<unresolvedSignature>(1),<empty>,,true,,,find_first_of,,,0,<unresolvedSignature>
111669155117,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplecpp.TokenList.readUntil:ANY(simplecpp.TokenList.Stream&,simplecpp.Location&,char,char,ANY)",<empty>,,true,,,readUntil,,,0,"ANY(simplecpp.TokenList.Stream&,simplecpp.Location&,char,char,ANY)"
111669155118,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isspace:<unresolvedSignature>(1),<empty>,,true,,,isspace,,,0,<unresolvedSignature>
111669155119,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.TokenList.front:simplecpp.Token*(),<empty>,,true,,,front,,,0,simplecpp.Token*()
111669155120,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.tolower:<unresolvedSignature>(1),<empty>,,true,,,tolower,,,0,<unresolvedSignature>
111669155121,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.Token.isOneOf<const>:bool(char*),<empty>,,true,,,isOneOf,,,0,bool(char*)
111669155122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setstr:<unresolvedSignature>(1),<empty>,,true,,,setstr,,,0,<unresolvedSignature>
111669155123,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.Token.startsWithOneOf<const>:bool(char*),<empty>,,true,,,startsWithOneOf,,,0,bool(char*)
111669155124,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentAnd,<empty>,,true,,,<operators>.assignmentAnd,,,0,
111669155125,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"isAlternativeUnaryOp:bool(simplecpp.Token*,ANY)",<empty>,,true,,,isAlternativeUnaryOp,,,0,"bool(simplecpp.Token*,ANY)"
111669155126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.toString:<unresolvedSignature>(1),<empty>,,true,,,toString,,,0,<unresolvedSignature>
111669155127,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.not,<empty>,,true,,,<operator>.not,,,0,
111669155128,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,stringToLL:longlong(ANY),<empty>,,true,,,stringToLL,,,0,longlong(ANY)
111669155129,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.overflow_error:<unresolvedSignature>(1),<empty>,,true,,,overflow_error,,,0,<unresolvedSignature>
111669155130,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.min:<unresolvedSignature>(0),<empty>,,true,,,min,,,0,<unresolvedSignature>
111669155131,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.modulo,<empty>,,true,,,<operator>.modulo,,,0,
111669155132,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"isAlternativeBinaryOp:bool(simplecpp.Token*,ANY)",<empty>,,true,,,isAlternativeBinaryOp,,,0,"bool(simplecpp.Token*,ANY)"
111669155133,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.xor,<empty>,,true,,,<operator>.xor,,,0,
111669155134,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.runtime_error:<unresolvedSignature>(1),<empty>,,true,,,runtime_error,,,0,<unresolvedSignature>
111669155135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.reverse:<unresolvedSignature>(2),<empty>,,true,,,reverse,,,0,<unresolvedSignature>
111669155136,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.invalidHashHash:<unresolvedSignature>(3),<empty>,,true,,,invalidHashHash,,,0,<unresolvedSignature>
111669155137,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.Token.previousSkipComments<const>:simplecpp.Token*(),<empty>,,true,,,previousSkipComments,,,0,simplecpp.Token*()
111669155138,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.data:<unresolvedSignature>(0),<empty>,,true,,,data,,,0,<unresolvedSignature>
111669155139,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.TokenList.empty<const>:bool(),<empty>,,true,,,empty,,,0,bool()
111669155140,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.Macro.functionLike:bool(),<empty>,,true,,,functionLike,,,0,bool()
111669155141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Error:<unresolvedSignature>(2),<empty>,,true,,,Error,,,0,<unresolvedSignature>
111669155142,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplecpp.Macro.expand:simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,ANY,ANY)",<empty>,,true,,,expand,,,0,"simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,ANY,ANY)"
111669155143,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.TokenList.cback<const>:simplecpp.Token*(),<empty>,,true,,,cback,,,0,simplecpp.Token*()
111669155144,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.Macro.name:ANY(),<empty>,,true,,,name,,,0,ANY()
111669155145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.functionLike:<unresolvedSignature>(0),<empty>,,true,,,functionLike,,,0,<unresolvedSignature>
111669155146,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.expand:<unresolvedSignature>(5),<empty>,,true,,,expand,,,0,<unresolvedSignature>
111669155147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.TokenList.takeTokens:void(simplecpp.TokenList&),<empty>,,true,,,takeTokens,,,0,void(simplecpp.TokenList&)
111669155148,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplecpp.Token.setExpandedFrom:void(simplecpp.Token*,simplecpp.Macro*)",<empty>,,true,,,setExpandedFrom,,,0,"void(simplecpp.Token*,simplecpp.Macro*)"
111669155149,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.vector<const Token *>:<unresolvedSignature>(0),<empty>,,true,,,vector<const Token *>,,,0,<unresolvedSignature>
111669155150,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplecpp.Macro.expandHashHash:simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,ANY,ANY,ANY,bool)",<empty>,,true,,,expandHashHash,,,0,"simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,ANY,ANY,ANY,bool)"
111669155151,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplecpp.Macro.expandHash:simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,ANY,ANY)",<empty>,,true,,,expandHash,,,0,"simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,ANY,ANY)"
111669155152,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplecpp.Macro.expandArg:bool(simplecpp.TokenList*,simplecpp.Token*,simplecpp.Location&,ANY,ANY,ANY)",<empty>,,true,,,expandArg,,,0,"bool(simplecpp.TokenList*,simplecpp.Token*,simplecpp.Location&,ANY,ANY,ANY)"
111669155153,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplecpp.Macro.getMacroParameters:ANY(simplecpp.Token*,bool)",<empty>,,true,,,getMacroParameters,,,0,"ANY(simplecpp.Token*,bool)"
111669155154,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.wrongNumberOfParameters:<unresolvedSignature>(2),<empty>,,true,,,wrongNumberOfParameters,,,0,<unresolvedSignature>
111669155155,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.back:<unresolvedSignature>(0),<empty>,,true,,,back,,,0,<unresolvedSignature>
111669155156,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.swap:<unresolvedSignature>(1),<empty>,,true,,,swap,,,0,<unresolvedSignature>
111669155157,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplecpp.Macro.invalidHashHash.unexpectedNewline:simplecpp.Macro.invalidHashHash(simplecpp.Location&,ANY)",<empty>,,true,,,unexpectedNewline,,,0,"simplecpp.Macro.invalidHashHash(simplecpp.Location&,ANY)"
111669155158,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplecpp.Macro.newMacroToken:simplecpp.Token*(ANY,simplecpp.Location&,bool,simplecpp.Token*)",<empty>,,true,,,newMacroToken,,,0,"simplecpp.Token*(ANY,simplecpp.Location&,bool,simplecpp.Token*)"
111669155159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.Macro.isReplaced:bool(ANY),<empty>,,true,,,isReplaced,,,0,bool(ANY)
111669155160,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplecpp.Macro.expandToken:simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,ANY,ANY,ANY)",<empty>,,true,,,expandToken,,,0,"simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,ANY,ANY,ANY)"
111669155161,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplecpp.Macro.expandArg:bool(simplecpp.TokenList*,simplecpp.Token*,ANY)",<empty>,,true,,,expandArg,,,0,"bool(simplecpp.TokenList*,simplecpp.Token*,ANY)"
111669155162,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.newMacroToken:<unresolvedSignature>(3),<empty>,,true,,,newMacroToken,,,0,<unresolvedSignature>
111669155163,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplecpp.Macro.appendTokens:simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,ANY,ANY,ANY)",<empty>,,true,,,appendTokens,,,0,"simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,ANY,ANY,ANY)"
111669155164,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplecpp.Macro.expand<const>:simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,ANY,ANY)",<empty>,,true,,,expand,,,0,"simplecpp.Token*(simplecpp.TokenList*,simplecpp.Location&,simplecpp.Token*,ANY,ANY)"
111669155165,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.front:<unresolvedSignature>(0),<empty>,,true,,,front,,,0,<unresolvedSignature>
111669155166,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.Token.nextSkipComments<const>:simplecpp.Token*(),<empty>,,true,,,nextSkipComments,,,0,simplecpp.Token*()
111669155167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplecpp.Macro.recursiveExpandToken:simplecpp.Token*(simplecpp.TokenList*,simplecpp.TokenList&,simplecpp.Location&,simplecpp.Token*,ANY,ANY,ANY)",<empty>,,true,,,recursiveExpandToken,,,0,"simplecpp.Token*(simplecpp.TokenList*,simplecpp.TokenList&,simplecpp.Location&,simplecpp.Token*,ANY,ANY,ANY)"
111669155168,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.expandedmacros2:<unresolvedSignature>(1),<empty>,,true,,,expandedmacros2,,,0,<unresolvedSignature>
111669155169,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.recursiveExpandToken:<unresolvedSignature>(7),<empty>,,true,,,recursiveExpandToken,,,0,<unresolvedSignature>
111669155170,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.Macro.getArgNum:unsigned int(ANY),<empty>,,true,,,getArgNum,,,0,unsigned int(ANY)
111669155171,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isExpandedFrom:<unresolvedSignature>(1),<empty>,,true,,,isExpandedFrom,,,0,<unresolvedSignature>
111669155172,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.escapeString:<unresolvedSignature>(1),<empty>,,true,,,escapeString,,,0,<unresolvedSignature>
111669155173,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isStringLiteral_:bool(ANY),<empty>,,true,,,isStringLiteral_,,,0,bool(ANY)
111669155174,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isCharLiteral_:bool(ANY),<empty>,,true,,,isCharLiteral_,,,0,bool(ANY)
111669155175,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplecpp.Macro.invalidHashHash.unexpectedToken:simplecpp.Macro.invalidHashHash(simplecpp.Location&,ANY,simplecpp.Token*)",<empty>,,true,,,unexpectedToken,,,0,"simplecpp.Macro.invalidHashHash(simplecpp.Location&,ANY,simplecpp.Token*)"
111669155176,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplecpp.Macro.invalidHashHash.cannotCombine:simplecpp.Macro.invalidHashHash(simplecpp.Location&,ANY,simplecpp.Token*,simplecpp.Token*)",<empty>,,true,,,cannotCombine,,,0,"simplecpp.Macro.invalidHashHash(simplecpp.Location&,ANY,simplecpp.Token*,simplecpp.Token*)"
111669155177,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplecpp.Macro.invalidHashHash.universalCharacterUB:simplecpp.Macro.invalidHashHash(simplecpp.Location&,ANY,simplecpp.Token*,ANY)",<empty>,,true,,,universalCharacterUB,,,0,"simplecpp.Macro.invalidHashHash(simplecpp.Location&,ANY,simplecpp.Token*,ANY)"
111669155178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.replace:<unresolvedSignature>(4),<empty>,,true,,,replace,,,0,<unresolvedSignature>
111669155179,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.rfind:<unresolvedSignature>(2),<empty>,,true,,,rfind,,,0,<unresolvedSignature>
111669155180,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,externals/simplecpp/simplecpp.cpp,externals/simplecpp/simplecpp.cpp:2546:2546:realFilename:1,<empty>,,true,2546,2546,realFilename,,,0,
111669155181,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.getCppStdString:ANY(ANY),<empty>,,true,,,getCppStdString,,,0,ANY(ANY)
111669155182,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"openHeader:ANY(ANY,simplecpp.DUI&,ANY,ANY,bool)",<empty>,,true,,,openHeader,,,0,"ANY(ANY,simplecpp.DUI&,ANY,ANY,bool)"
111669155183,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.strtoull:<unresolvedSignature>(3),<empty>,,true,,,strtoull,,,0,<unresolvedSignature>
111669155184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.stringToULLbounded:<unresolvedSignature>(5),<empty>,,true,,,stringToULLbounded,,,0,<unresolvedSignature>
111669155185,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"stringToULLbounded:longlong(ANY,ANY,int,ANY,ANY)",<empty>,,true,,,stringToULLbounded,,,0,"longlong(ANY,ANY,int,ANY,ANY)"
111669155186,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.postDecrement,<empty>,,true,,,<operator>.postDecrement,,,0,
111669155187,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.max:<unresolvedSignature>(0),<empty>,,true,,,max,,,0,<unresolvedSignature>
111669155188,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentShiftLeft,<empty>,,true,,,<operators>.assignmentShiftLeft,,,0,
111669155189,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,stringToULL:longlong(ANY),<empty>,,true,,,stringToULL,,,0,longlong(ANY)
111669155190,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.characterLiteralToLL:longlong(ANY),<empty>,,true,,,characterLiteralToLL,,,0,longlong(ANY)
111669155191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplifySizeof:void(simplecpp.TokenList&,ANY)",<empty>,,true,,,simplifySizeof,,,0,"void(simplecpp.TokenList&,ANY)"
111669155192,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.simplifyPath:ANY(ANY),<empty>,,true,,,simplifyPath,,,0,ANY(ANY)
111669155193,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.find_last_of:<unresolvedSignature>(1),<empty>,,true,,,find_last_of,,,0,<unresolvedSignature>
111669155194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"openHeader:ANY(ANY,ANY)",<empty>,,true,,,openHeader,,,0,"ANY(ANY,ANY)"
111669155195,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getRelativeFileName:ANY(ANY,ANY)",<empty>,,true,,,getRelativeFileName,,,0,"ANY(ANY,ANY)"
111669155196,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getIncludePathFileName:ANY(ANY,ANY)",<empty>,,true,,,getIncludePathFileName,,,0,"ANY(ANY,ANY)"
111669155197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isAbsolutePath:bool(ANY),<empty>,,true,,,isAbsolutePath,,,0,bool(ANY)
111669155198,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"openHeaderIncludePath:ANY(ANY,simplecpp.DUI&,ANY)",<empty>,,true,,,openHeaderIncludePath,,,0,"ANY(ANY,simplecpp.DUI&,ANY)"
111669155199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"openHeaderRelative:ANY(ANY,ANY,ANY)",<empty>,,true,,,openHeaderRelative,,,0,"ANY(ANY,ANY,ANY)"
111669155200,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getFileName:ANY(ANY,ANY,ANY,simplecpp.DUI&,bool)",<empty>,,true,,,getFileName,,,0,"ANY(ANY,ANY,ANY,simplecpp.DUI&,bool)"
111669155201,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Location:<unresolvedSignature>(1),<empty>,,true,,,Location,,,0,<unresolvedSignature>
111669155202,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.close:<unresolvedSignature>(0),<empty>,,true,,,close,,,0,<unresolvedSignature>
111669155203,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"hasFile:bool(ANY,ANY,ANY,simplecpp.DUI&,bool)",<empty>,,true,,,hasFile,,,0,"bool(ANY,ANY,ANY,simplecpp.DUI&,bool)"
111669155204,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.expand:<unresolvedSignature>(4),<empty>,,true,,,expand,,,0,<unresolvedSignature>
111669155205,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.localtime_r:<unresolvedSignature>(2),<empty>,,true,,,localtime_r,,,0,<unresolvedSignature>
111669155206,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.strftime:<unresolvedSignature>(4),<empty>,,true,,,strftime,,,0,<unresolvedSignature>
111669155207,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.append:<unresolvedSignature>(1),<empty>,,true,,,append,,,0,<unresolvedSignature>
111669155208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sizeOfType:<unresolvedSignature>(1),<empty>,,true,,,sizeOfType,,,0,<unresolvedSignature>
111669155209,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.make_pair:<unresolvedSignature>(2),<empty>,,true,,,make_pair,,,0,<unresolvedSignature>
111669155210,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<unresolvedNamespace>.pair<TokenString, Macro>:<unresolvedSignature>(2)",<empty>,,true,,,"pair<TokenString, Macro>",,,0,<unresolvedSignature>
111669155211,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Macro:<unresolvedSignature>(3),<empty>,,true,,,Macro,,,0,<unresolvedSignature>
111669155212,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getDateDefine:ANY(tm*),<empty>,,true,,,getDateDefine,,,0,ANY(tm*)
111669155213,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getTimeDefine:ANY(tm*),<empty>,,true,,,getTimeDefine,,,0,ANY(tm*)
111669155214,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.getCStd:simplecpp.cstd_t(ANY),<empty>,,true,,,getCStd,,,0,simplecpp.cstd_t(ANY)
111669155215,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.getCStdString:ANY(simplecpp.cstd_t),<empty>,,true,,,getCStdString,,,0,ANY(simplecpp.cstd_t)
111669155216,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.getCppStd:simplecpp.cppstd_t(ANY),<empty>,,true,,,getCppStd,,,0,simplecpp.cppstd_t(ANY)
111669155217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.getCppStdString:ANY(simplecpp.cppstd_t),<empty>,,true,,,getCppStdString,,,0,ANY(simplecpp.cppstd_t)
111669155218,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.cfront:<unresolvedSignature>(0),<empty>,,true,,,cfront,,,0,<unresolvedSignature>
111669155219,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isNameChar:<unresolvedSignature>(1),<empty>,,true,,,isNameChar,,,0,<unresolvedSignature>
111669155220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Macro:<unresolvedSignature>(2),<empty>,,true,,,Macro,,,0,<unresolvedSignature>
111669155221,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"preprocessToken:bool(simplecpp.TokenList&,simplecpp.Token**,ANY,ANY,ANY)",<empty>,,true,,,preprocessToken,,,0,"bool(simplecpp.TokenList&,simplecpp.Token**,ANY,ANY,ANY)"
111669155222,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.evaluate:<unresolvedSignature>(3),<empty>,,true,,,evaluate,,,0,<unresolvedSignature>
111669155223,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.IfCond:<unresolvedSignature>(3),<empty>,,true,,,IfCond,,,0,<unresolvedSignature>
111669155224,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.vsnprintf:<unresolvedSignature>(4),<empty>,,true,,,vsnprintf,,,0,<unresolvedSignature>
111669155225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,externals/tinyxml2/tinyxml2.h,externals/tinyxml2/tinyxml2.h:92:92:TIXMLASSERT:1,<empty>,,true,92,92,TIXMLASSERT,,,0,
111669155226,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.strlen:<unresolvedSignature>(1),<empty>,,true,,,strlen,,,0,<unresolvedSignature>
111669155227,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.memcpy:<unresolvedSignature>(3),<empty>,,true,,,memcpy,,,0,<unresolvedSignature>
111669155228,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.StrPair.Set:void(char*,char*,int)",<empty>,,true,,,Set,,,0,"void(char*,char*,int)"
111669155229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLUtil.IsNameStartChar:bool(unsigned char),<empty>,,true,,,IsNameStartChar,,,0,bool(unsigned char)
111669155230,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLUtil.IsNameChar:bool(unsigned char),<empty>,,true,,,IsNameChar,,,0,bool(unsigned char)
111669155231,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLUtil.SkipWhiteSpace:char*(char*,int*)",<empty>,,true,,,SkipWhiteSpace,,,0,"char*(char*,int*)"
111669155232,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLUtil.IsWhiteSpace:bool(char),<empty>,,true,,,IsWhiteSpace,,,0,bool(char)
111669155233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentXor,<empty>,,true,,,<operators>.assignmentXor,,,0,
111669155234,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentArithmeticShiftRight,<empty>,,true,,,<operators>.assignmentArithmeticShiftRight,,,0,
111669155235,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentMultiplication,<empty>,,true,,,<operator>.assignmentMultiplication,,,0,
111669155236,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLUtil.ConvertUTF32ToUTF8:void(long,char*,int*)",<empty>,,true,,,ConvertUTF32ToUTF8,,,0,"void(long,char*,int*)"
111669155237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,externals/tinyxml2/tinyxml2.cpp,externals/tinyxml2/tinyxml2.cpp:92:92:TIXML_SNPRINTF:0,<empty>,,true,92,92,TIXML_SNPRINTF,,,0,
111669155238,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.snprintf:<unresolvedSignature>(4),<empty>,,true,,,snprintf,,,0,<unresolvedSignature>
111669155239,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLUtil.IsPrefixHex:bool(char*),<empty>,,true,,,IsPrefixHex,,,0,bool(char*)
111669155240,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,externals/tinyxml2/tinyxml2.cpp,externals/tinyxml2/tinyxml2.cpp:100:100:TIXML_SSCANF:0,<empty>,,true,100,100,TIXML_SSCANF,,,0,
111669155241,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLUtil.StringEqual:bool(char*,char*,int)",<empty>,,true,,,StringEqual,,,0,"bool(char*,char*,int)"
111669155242,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLDocument.CreateUnlinkedNode:tinyxml2.XMLDeclaration*(tinyxml2.MemPoolT<int<unknown>>&),<empty>,,true,,,CreateUnlinkedNode<XMLDeclaration>,,,0,tinyxml2.XMLDeclaration*(tinyxml2.MemPoolT<int<unknown>>&)
111669155243,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLDocument.CreateUnlinkedNode:tinyxml2.XMLComment*(tinyxml2.MemPoolT<int<unknown>>&),<empty>,,true,,,CreateUnlinkedNode<XMLComment>,,,0,tinyxml2.XMLComment*(tinyxml2.MemPoolT<int<unknown>>&)
111669155244,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLDocument.CreateUnlinkedNode:tinyxml2.XMLText*(tinyxml2.MemPoolT<int<unknown>>&),<empty>,,true,,,CreateUnlinkedNode<XMLText>,,,0,tinyxml2.XMLText*(tinyxml2.MemPoolT<int<unknown>>&)
111669155245,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLText.SetCData:void(bool),<empty>,,true,,,SetCData,,,0,void(bool)
111669155246,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLDocument.CreateUnlinkedNode:tinyxml2.XMLUnknown*(tinyxml2.MemPoolT<int<unknown>>&),<empty>,,true,,,CreateUnlinkedNode<XMLUnknown>,,,0,tinyxml2.XMLUnknown*(tinyxml2.MemPoolT<int<unknown>>&)
111669155247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLDocument.WhitespaceMode:tinyxml2.Whitespace(),<empty>,,true,,,WhitespaceMode,,,0,tinyxml2.Whitespace()
111669155248,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLDocument.CreateUnlinkedNode:tinyxml2.XMLElement*(tinyxml2.MemPoolT<int<unknown>>&),<empty>,,true,,,CreateUnlinkedNode<XMLElement>,,,0,tinyxml2.XMLElement*(tinyxml2.MemPoolT<int<unknown>>&)
111669155249,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLVisitor.VisitEnter:bool(tinyxml2.XMLDocument&),<empty>,,true,,,VisitEnter,,,0,bool(tinyxml2.XMLDocument&)
111669155250,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLNode.FirstChild:tinyxml2.XMLNode*(),<empty>,,true,,,FirstChild,,,0,tinyxml2.XMLNode*()
111669155251,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLNode.NextSibling<const>:tinyxml2.XMLNode*(),<empty>,,true,,,NextSibling,,,0,tinyxml2.XMLNode*()
111669155252,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLNode.Accept<const>:bool(tinyxml2.XMLVisitor*),<empty>,,true,,,Accept,,,0,bool(tinyxml2.XMLVisitor*)
111669155253,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLVisitor.VisitExit:bool(tinyxml2.XMLDocument&),<empty>,,true,,,VisitExit,,,0,bool(tinyxml2.XMLDocument&)
111669155254,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLNode.FirstChildElement:tinyxml2.XMLElement*(char*),<empty>,,true,,,FirstChildElement,,,0,tinyxml2.XMLElement*(char*)
111669155255,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLElement.NextSiblingElement<const>:tinyxml2.XMLElement*(char*),<empty>,,true,,,NextSiblingElement,,,0,tinyxml2.XMLElement*(char*)
111669155256,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLNode.ToDocument<const>:tinyxml2.XMLDocument*(),<empty>,,true,,,ToDocument,,,0,tinyxml2.XMLDocument*()
111669155257,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.StrPair.SetInternedStr:void(char*),<empty>,,true,,,SetInternedStr,,,0,void(char*)
111669155258,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLNode.ShallowClone<const>:tinyxml2.XMLNode*(tinyxml2.XMLDocument*),<empty>,,true,,,ShallowClone,,,0,tinyxml2.XMLNode*(tinyxml2.XMLDocument*)
111669155259,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLNode.FirstChild<const>:tinyxml2.XMLNode*(),<empty>,,true,,,FirstChild,,,0,tinyxml2.XMLNode*()
111669155260,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLNode.InsertChildPreamble:void(tinyxml2.XMLNode*),<empty>,,true,,,InsertChildPreamble,,,0,void(tinyxml2.XMLNode*)
111669155261,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLDocument.Error<const>:bool(),<empty>,,true,,,Error,,,0,bool()
111669155262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLDocument.SetError:void(tinyxml2.XMLError,int,char*)",<empty>,,true,,,SetError,,,0,"void(tinyxml2.XMLError,int,char*)"
111669155263,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLNode.ToDeclaration:tinyxml2.XMLDeclaration*(),<empty>,,true,,,ToDeclaration,,,0,tinyxml2.XMLDeclaration*()
111669155264,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLNode.ToDocument:tinyxml2.XMLDocument*(),<empty>,,true,,,ToDocument,,,0,tinyxml2.XMLDocument*()
111669155265,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLNode.LastChild:tinyxml2.XMLNode*(),<empty>,,true,,,LastChild,,,0,tinyxml2.XMLNode*()
111669155266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLDeclaration.Value<const>:char*(),<empty>,,true,,,Value,,,0,char*()
111669155267,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLNode.ToElement:tinyxml2.XMLElement*(),<empty>,,true,,,ToElement,,,0,tinyxml2.XMLElement*()
111669155268,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLElement.ClosingType<const>:tinyxml2.XMLElement.ElementClosingType(),<empty>,,true,,,ClosingType,,,0,tinyxml2.XMLElement.ElementClosingType()
111669155269,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.MemPool.SetTracked:void(),<empty>,,true,,,SetTracked,,,0,void()
111669155270,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.StrPair.Empty<const>:bool(),<empty>,,true,,,Empty,,,0,bool()
111669155271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLElement.Name<const>:char*(),<empty>,,true,,,Name,,,0,char*()
111669155272,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.MemPool.Free:void(void*),<empty>,,true,,,Free,,,0,void(void*)
111669155273,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLNode.ToElement<const>:tinyxml2.XMLElement*(),<empty>,,true,,,ToElement,,,0,tinyxml2.XMLElement*()
111669155274,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLText.CData<const>:bool(),<empty>,,true,,,CData,,,0,bool()
111669155275,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLDocument.ProcessEntities<const>:bool(),<empty>,,true,,,ProcessEntities,,,0,bool()
111669155276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLDocument.WhitespaceMode<const>:tinyxml2.Whitespace(),<empty>,,true,,,WhitespaceMode,,,0,tinyxml2.Whitespace()
111669155277,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLNode.Value:char*(),<empty>,,true,,,Value,,,0,char*()
111669155278,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLNode.ToText<const>:tinyxml2.XMLText*(),<empty>,,true,,,ToText,,,0,tinyxml2.XMLText*()
111669155279,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLText.Value<const>:char*(),<empty>,,true,,,Value,,,0,char*()
111669155280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLVisitor.Visit:bool(tinyxml2.XMLText&),<empty>,,true,,,Visit,,,0,bool(tinyxml2.XMLText&)
111669155281,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLNode.ToComment<const>:tinyxml2.XMLComment*(),<empty>,,true,,,ToComment,,,0,tinyxml2.XMLComment*()
111669155282,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLComment.Value<const>:char*(),<empty>,,true,,,Value,,,0,char*()
111669155283,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLVisitor.Visit:bool(tinyxml2.XMLComment&),<empty>,,true,,,Visit,,,0,bool(tinyxml2.XMLComment&)
111669155284,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLNode.ToDeclaration<const>:tinyxml2.XMLDeclaration*(),<empty>,,true,,,ToDeclaration,,,0,tinyxml2.XMLDeclaration*()
111669155285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLVisitor.Visit:bool(tinyxml2.XMLDeclaration&),<empty>,,true,,,Visit,,,0,bool(tinyxml2.XMLDeclaration&)
111669155286,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLNode.ToUnknown<const>:tinyxml2.XMLUnknown*(),<empty>,,true,,,ToUnknown,,,0,tinyxml2.XMLUnknown*()
111669155287,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLUnknown.Value<const>:char*(),<empty>,,true,,,Value,,,0,char*()
111669155288,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLVisitor.Visit:bool(tinyxml2.XMLUnknown&),<empty>,,true,,,Visit,,,0,bool(tinyxml2.XMLUnknown&)
111669155289,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLAttribute.Value:char*(),<empty>,,true,,,Value,,,0,char*()
111669155290,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLUtil.ToUnsigned:bool(char*,unsigned int*)",<empty>,,true,,,ToUnsigned,,,0,"bool(char*,unsigned int*)"
111669155291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLUtil.ToInt64:bool(char*,ANY)",<empty>,,true,,,ToInt64,,,0,"bool(char*,ANY)"
111669155292,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLUtil.ToUnsigned64:bool(char*,ANY)",<empty>,,true,,,ToUnsigned64,,,0,"bool(char*,ANY)"
111669155293,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLUtil.ToStr:void(unsigned int,char*,int)",<empty>,,true,,,ToStr,,,0,"void(unsigned int,char*,int)"
111669155294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLUtil.ToStr:void(ANY,char*,int)",<empty>,,true,,,ToStr,,,0,"void(ANY,char*,int)"
111669155295,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLElement.FindAttribute:tinyxml2.XMLAttribute*(char*),<empty>,,true,,,FindAttribute,,,0,tinyxml2.XMLAttribute*(char*)
111669155296,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLElement.QueryIntAttribute:tinyxml2.XMLError(char*,int*)",<empty>,,true,,,QueryIntAttribute,,,0,"tinyxml2.XMLError(char*,int*)"
111669155297,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLElement.QueryUnsignedAttribute:tinyxml2.XMLError(char*,unsigned int*)",<empty>,,true,,,QueryUnsignedAttribute,,,0,"tinyxml2.XMLError(char*,unsigned int*)"
111669155298,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLElement.QueryInt64Attribute:tinyxml2.XMLError(char*,ANY)",<empty>,,true,,,QueryInt64Attribute,,,0,"tinyxml2.XMLError(char*,ANY)"
111669155299,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLElement.QueryUnsigned64Attribute:tinyxml2.XMLError(char*,ANY)",<empty>,,true,,,QueryUnsigned64Attribute,,,0,"tinyxml2.XMLError(char*,ANY)"
111669155300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLElement.QueryBoolAttribute:tinyxml2.XMLError(char*,bool*)",<empty>,,true,,,QueryBoolAttribute,,,0,"tinyxml2.XMLError(char*,bool*)"
111669155301,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLElement.QueryDoubleAttribute:tinyxml2.XMLError(char*,double*)",<empty>,,true,,,QueryDoubleAttribute,,,0,"tinyxml2.XMLError(char*,double*)"
111669155302,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLElement.QueryFloatAttribute:tinyxml2.XMLError(char*,float*)",<empty>,,true,,,QueryFloatAttribute,,,0,"tinyxml2.XMLError(char*,float*)"
111669155303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLNode.ToText:tinyxml2.XMLText*(),<empty>,,true,,,ToText,,,0,tinyxml2.XMLText*()
111669155304,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLNode.GetDocument:tinyxml2.XMLDocument*(),<empty>,,true,,,GetDocument,,,0,tinyxml2.XMLDocument*()
111669155305,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLElement.QueryIntText:tinyxml2.XMLError(int*),<empty>,,true,,,QueryIntText,,,0,tinyxml2.XMLError(int*)
111669155306,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLElement.QueryUnsignedText:tinyxml2.XMLError(unsigned int*),<empty>,,true,,,QueryUnsignedText,,,0,tinyxml2.XMLError(unsigned int*)
111669155307,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLElement.QueryInt64Text:tinyxml2.XMLError(ANY),<empty>,,true,,,QueryInt64Text,,,0,tinyxml2.XMLError(ANY)
111669155308,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLElement.QueryUnsigned64Text:tinyxml2.XMLError(ANY),<empty>,,true,,,QueryUnsigned64Text,,,0,tinyxml2.XMLError(ANY)
111669155309,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLElement.QueryBoolText:tinyxml2.XMLError(bool*),<empty>,,true,,,QueryBoolText,,,0,tinyxml2.XMLError(bool*)
111669155310,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLElement.QueryDoubleText:tinyxml2.XMLError(double*),<empty>,,true,,,QueryDoubleText,,,0,tinyxml2.XMLError(double*)
111669155311,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLElement.QueryFloatText:tinyxml2.XMLError(float*),<empty>,,true,,,QueryFloatText,,,0,tinyxml2.XMLError(float*)
111669155312,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLElement.Name:char*(),<empty>,,true,,,Name,,,0,char*()
111669155313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLElement.Attribute:char*(char*,char*)",<empty>,,true,,,Attribute,,,0,"char*(char*,char*)"
111669155314,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLAttribute.~XMLAttribute:ANY(),<empty>,,true,,,~XMLAttribute,,,0,ANY()
111669155315,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.MemPoolT<int<unknown>>.Alloc:void*(),<empty>,,true,,,Alloc,,,0,void*()
111669155316,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLElement.FirstAttribute:tinyxml2.XMLAttribute*(),<empty>,,true,,,FirstAttribute,,,0,tinyxml2.XMLAttribute*()
111669155317,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLAttribute.Next<const>:tinyxml2.XMLAttribute*(),<empty>,,true,,,Next,,,0,tinyxml2.XMLAttribute*()
111669155318,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLElement.SetAttribute:void(char*,char*)",<empty>,,true,,,SetAttribute,,,0,"void(char*,char*)"
111669155319,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLElement.FirstAttribute<const>:tinyxml2.XMLAttribute*(),<empty>,,true,,,FirstAttribute,,,0,tinyxml2.XMLAttribute*()
111669155320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLVisitor.VisitEnter:bool(tinyxml2.XMLElement&,tinyxml2.XMLAttribute*)",<empty>,,true,,,VisitEnter,,,0,"bool(tinyxml2.XMLElement&,tinyxml2.XMLAttribute*)"
111669155321,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLVisitor.VisitExit:bool(tinyxml2.XMLElement&),<empty>,,true,,,VisitExit,,,0,bool(tinyxml2.XMLElement&)
111669155322,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.DynArray<tinyxml2.XMLNode*,int10>.Size<const>:int()",<empty>,,true,,,Size,,,0,int()
111669155323,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.DynArray<tinyxml2.XMLNode*,int10>.SwapRemove:void(int)",<empty>,,true,,,SwapRemove,,,0,void(int)
111669155324,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLDocument.FirstChild<const>:tinyxml2.XMLNode*(),<empty>,,true,,,FirstChild,,,0,tinyxml2.XMLNode*()
111669155325,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLDocument.InsertEndChild:tinyxml2.XMLNode*(tinyxml2.XMLNode*),<empty>,,true,,,InsertEndChild,,,0,tinyxml2.XMLNode*(tinyxml2.XMLNode*)
111669155326,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLElement.SetName:void(char*,bool)",<empty>,,true,,,SetName,,,0,"void(char*,bool)"
111669155327,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLComment.SetValue:void(char*,bool)",<empty>,,true,,,SetValue,,,0,"void(char*,bool)"
111669155328,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLText.SetValue:void(char*,bool)",<empty>,,true,,,SetValue,,,0,"void(char*,bool)"
111669155329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLDeclaration.SetValue:void(char*,bool)",<empty>,,true,,,SetValue,,,0,"void(char*,bool)"
111669155330,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLUnknown.SetValue:void(char*,bool)",<empty>,,true,,,SetValue,,,0,"void(char*,bool)"
111669155331,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.callfopen:ANY(char*,char*)",<empty>,,true,,,callfopen,,,0,"ANY(char*,char*)"
111669155332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLDocument.LoadFile:tinyxml2.XMLError(ANY),<empty>,,true,,,LoadFile,,,0,tinyxml2.XMLError(ANY)
111669155333,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,externals/tinyxml2/tinyxml2.cpp,externals/tinyxml2/tinyxml2.cpp:118:118:TIXML_FSEEK:0,<empty>,,true,118,118,TIXML_FSEEK,,,0,
111669155334,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ferror:<unresolvedSignature>(1),<empty>,,true,,,ferror,,,0,<unresolvedSignature>
111669155335,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,externals/tinyxml2/tinyxml2.cpp,externals/tinyxml2/tinyxml2.cpp:119:119:TIXML_FTELL:0,<empty>,,true,119,119,TIXML_FTELL,,,0,
111669155336,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ftell:<unresolvedSignature>(1),<empty>,,true,,,ftell,,,0,<unresolvedSignature>
111669155337,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fread:<unresolvedSignature>(4),<empty>,,true,,,fread,,,0,<unresolvedSignature>
111669155338,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.XMLDocument.SaveFile:tinyxml2.XMLError(ANY,bool)",<empty>,,true,,,SaveFile,,,0,"tinyxml2.XMLError(ANY,bool)"
111669155339,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLDocument.Print:void(tinyxml2.XMLPrinter*),<empty>,,true,,,Print,,,0,void(tinyxml2.XMLPrinter*)
111669155340,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLDocument.Error:bool(),<empty>,,true,,,Error,,,0,bool()
111669155341,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.MemPoolT<int<unknown>>.Clear:void(),<empty>,,true,,,Clear,,,0,void()
111669155342,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLDocument.Accept:bool(tinyxml2.XMLVisitor*),<empty>,,true,,,Accept,,,0,bool(tinyxml2.XMLVisitor*)
111669155343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.snprintf:<unresolvedSignature>(7),<empty>,,true,,,snprintf,,,0,<unresolvedSignature>
111669155344,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.snprintf:<unresolvedSignature>(3),<empty>,,true,,,snprintf,,,0,<unresolvedSignature>
111669155345,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.va_start:<unresolvedSignature>(2),<empty>,,true,,,va_start,,,0,<unresolvedSignature>
111669155346,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,externals/tinyxml2/tinyxml2.cpp,externals/tinyxml2/tinyxml2.cpp:93:93:TIXML_VSNPRINTF:0,<empty>,,true,93,93,TIXML_VSNPRINTF,,,0,
111669155347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.va_end:<unresolvedSignature>(1),<empty>,,true,,,va_end,,,0,<unresolvedSignature>
111669155348,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.printf:<unresolvedSignature>(2),<empty>,,true,,,printf,,,0,<unresolvedSignature>
111669155349,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLDocument.ErrorStr:char*(),<empty>,,true,,,ErrorStr,,,0,char*()
111669155350,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.DynArray<char,int20>.Push:void(char)",<empty>,,true,,,Push,,,0,void(char)
111669155351,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.vfprintf:<unresolvedSignature>(3),<empty>,,true,,,vfprintf,,,0,<unresolvedSignature>
111669155352,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TIXML_VSCPRINTF:int(char*,ANY)",<empty>,,true,,,TIXML_VSCPRINTF,,,0,"int(char*,ANY)"
111669155353,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.DynArray<char,int20>.PushArr:char*(int)",<empty>,,true,,,PushArr,,,0,char*(int)
111669155354,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fwrite:<unresolvedSignature>(4),<empty>,,true,,,fwrite,,,0,<unresolvedSignature>
111669155355,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fputc:<unresolvedSignature>(2),<empty>,,true,,,fputc,,,0,<unresolvedSignature>
111669155356,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLPrinter.Write:void(char*),<empty>,,true,,,Write,,,0,void(char*)
111669155357,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Write:<unresolvedSignature>(2),<empty>,,true,,,Write,,,0,<unresolvedSignature>
111669155358,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.DynArray<constchar*,int10>.Push:void(char*)",<empty>,,true,,,Push,,,0,void(char*)
111669155359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tinyxml2.DynArray<constchar*,int10>.Pop:char*()",<empty>,,true,,,Pop,,,0,char*()
111669155360,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLDocument.HasBOM<const>:bool(),<empty>,,true,,,HasBOM,,,0,bool()
111669155361,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLElement.Parent<const>:tinyxml2.XMLNode*(),<empty>,,true,,,Parent,,,0,tinyxml2.XMLNode*()
111669155362,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tinyxml2.XMLPrinter.CompactMode:bool(tinyxml2.XMLElement&),<empty>,,true,,,CompactMode,,,0,bool(tinyxml2.XMLElement&)
111669155363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setupUi:<unresolvedSignature>(1),<empty>,,true,,,setupUi,,,0,<unresolvedSignature>
111669155364,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isEmpty:<unresolvedSignature>(0),<empty>,,true,,,isEmpty,,,0,<unresolvedSignature>
111669155365,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setText:<unresolvedSignature>(1),<empty>,,true,,,setText,,,0,<unresolvedSignature>
111669155366,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.arg:<unresolvedSignature>(1),<empty>,,true,,,arg,,,0,<unresolvedSignature>
111669155367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.text:<unresolvedSignature>(0),<empty>,,true,,,text,,,0,<unresolvedSignature>
111669155368,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,,:-1:-1:__DATE__:0,<empty>,,true,-1,-1,__DATE__,,,0,
111669155369,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.right:<unresolvedSignature>(1),<empty>,,true,,,right,,,0,<unresolvedSignature>
111669155370,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.connect:<unresolvedSignature>(4),<empty>,,true,,,connect,,,0,<unresolvedSignature>
111669155371,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Application.getPath<const>:ANY(),<empty>,,true,,,getPath,,,0,ANY()
111669155372,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Application.getName<const>:ANY(),<empty>,,true,,,getName,,,0,ANY()
111669155373,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Application.getParameters<const>:ANY(),<empty>,,true,,,getParameters,,,0,ANY()
111669155374,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setWindowTitle:<unresolvedSignature>(1),<empty>,,true,,,setWindowTitle,,,0,<unresolvedSignature>
111669155375,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.adjustSize:<unresolvedSignature>(0),<empty>,,true,,,adjustSize,,,0,<unresolvedSignature>
111669155376,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getOpenFileName:<unresolvedSignature>(4),<empty>,,true,,,getOpenFileName,,,0,<unresolvedSignature>
111669155377,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.tr:<unresolvedSignature>(1),<empty>,,true,,,tr,,,0,<unresolvedSignature>
111669155378,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getPath:<unresolvedSignature>(1),<empty>,,true,,,getPath,,,0,<unresolvedSignature>
111669155379,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:105:105:SETTINGS_LAST_APP_PATH:0,<empty>,,true,105,105,SETTINGS_LAST_APP_PATH,,,0,
111669155380,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setPath:<unresolvedSignature>(2),<empty>,,true,,,setPath,,,0,<unresolvedSignature>
111669155381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.exec:<unresolvedSignature>(0),<empty>,,true,,,exec,,,0,<unresolvedSignature>
111669155382,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.reject:<unresolvedSignature>(0),<empty>,,true,,,reject,,,0,<unresolvedSignature>
111669155383,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setName:<unresolvedSignature>(1),<empty>,,true,,,setName,,,0,<unresolvedSignature>
111669155384,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setPath:<unresolvedSignature>(1),<empty>,,true,,,setPath,,,0,<unresolvedSignature>
111669155385,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setParameters:<unresolvedSignature>(1),<empty>,,true,,,setParameters,,,0,<unresolvedSignature>
111669155386,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.accept:<unresolvedSignature>(0),<empty>,,true,,,accept,,,0,<unresolvedSignature>
111669155387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.toStringList:<unresolvedSignature>(0),<empty>,,true,,,toStringList,,,0,<unresolvedSignature>
111669155388,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.value:<unresolvedSignature>(2),<empty>,,true,,,value,,,0,<unresolvedSignature>
111669155389,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:77:77:SETTINGS_APPLICATION_NAMES:0,<empty>,,true,77,77,SETTINGS_APPLICATION_NAMES,,,0,
111669155390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QStringList:<unresolvedSignature>(0),<empty>,,true,,,QStringList,,,0,<unresolvedSignature>
111669155391,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:78:78:SETTINGS_APPLICATION_PATHS:0,<empty>,,true,78,78,SETTINGS_APPLICATION_PATHS,,,0,
111669155392,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:79:79:SETTINGS_APPLICATION_PARAMS:0,<empty>,,true,79,79,SETTINGS_APPLICATION_PARAMS,,,0,
111669155393,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.toInt:<unresolvedSignature>(0),<empty>,,true,,,toInt,,,0,<unresolvedSignature>
111669155394,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:80:80:SETTINGS_APPLICATION_DEFAULT:0,<empty>,,true,80,80,SETTINGS_APPLICATION_DEFAULT,,,0,
111669155395,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QString:<unresolvedSignature>(0),<empty>,,true,,,QString,,,0,<unresolvedSignature>
111669155396,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isExecutable:<unresolvedSignature>(0),<empty>,,true,,,isExecutable,,,0,<unresolvedSignature>
111669155397,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QFileInfo:<unresolvedSignature>(1),<empty>,,true,,,QFileInfo,,,0,<unresolvedSignature>
111669155398,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.checkAndAddApplication:<unresolvedSignature>(3),<empty>,,true,,,checkAndAddApplication,,,0,<unresolvedSignature>
111669155399,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ApplicationList.getApplicationCount:int(),<empty>,,true,,,getApplicationCount,,,0,int()
111669155400,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setValue:<unresolvedSignature>(2),<empty>,,true,,,setValue,,,0,<unresolvedSignature>
111669155401,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.removeAt:<unresolvedSignature>(1),<empty>,,true,,,removeAt,,,0,<unresolvedSignature>
111669155402,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ApplicationList.getDefaultApplication<const>:int(),<empty>,,true,,,getDefaultApplication,,,0,int()
111669155403,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.exists:<unresolvedSignature>(1),<empty>,,true,,,exists,,,0,<unresolvedSignature>
111669155404,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Application.setName:void(ANY),<empty>,,true,,,setName,,,0,void(ANY)
111669155405,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Application.setPath:void(ANY),<empty>,,true,,,setPath,,,0,void(ANY)
111669155406,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Application.setParameters:void(ANY),<empty>,,true,,,setParameters,,,0,void(ANY)
111669155407,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.contains:<unresolvedSignature>(1),<empty>,,true,,,contains,,,0,<unresolvedSignature>
111669155408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.toLower:<unresolvedSignature>(0),<empty>,,true,,,toLower,,,0,<unresolvedSignature>
111669155409,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"addItem:void(ANY,ANY)",<empty>,,true,,,addItem,,,0,"void(ANY,ANY)"
111669155410,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.qDebug:<unresolvedSignature>(0),<empty>,,true,,,qDebug,,,0,<unresolvedSignature>
111669155411,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.toStdString:<unresolvedSignature>(0),<empty>,,true,,,toStdString,,,0,<unresolvedSignature>
111669155412,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.keys:<unresolvedSignature>(0),<empty>,,true,,,keys,,,0,<unresolvedSignature>
111669155413,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.values:<unresolvedSignature>(0),<empty>,,true,,,values,,,0,<unresolvedSignature>
111669155414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.startsWith:<unresolvedSignature>(1),<empty>,,true,,,startsWith,,,0,<unresolvedSignature>
111669155415,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.mid:<unresolvedSignature>(2),<empty>,,true,,,mid,,,0,<unresolvedSignature>
111669155416,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fromStdString:<unresolvedSignature>(1),<empty>,,true,,,fromStdString,,,0,<unresolvedSignature>
111669155417,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.unquote:<unresolvedSignature>(1),<empty>,,true,,,unquote,,,0,<unresolvedSignature>
111669155418,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.endsWith:<unresolvedSignature>(1),<empty>,,true,,,endsWith,,,0,<unresolvedSignature>
111669155419,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.replace:<unresolvedSignature>(2),<empty>,,true,,,replace,,,0,<unresolvedSignature>
111669155420,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.left:<unresolvedSignature>(1),<empty>,,true,,,left,,,0,<unresolvedSignature>
111669155421,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.systemEnvironment:<unresolvedSignature>(0),<empty>,,true,,,systemEnvironment,,,0,<unresolvedSignature>
111669155422,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setProcessEnvironment:<unresolvedSignature>(1),<empty>,,true,,,setProcessEnvironment,,,0,<unresolvedSignature>
111669155423,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,unquote:ANY(ANY),<empty>,,true,,,unquote,,,0,ANY(ANY)
111669155424,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.lastIndexOf:<unresolvedSignature>(1),<empty>,,true,,,lastIndexOf,,,0,<unresolvedSignature>
111669155425,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QString:<unresolvedSignature>(1),<empty>,,true,,,QString,,,0,<unresolvedSignature>
111669155426,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setWorkingDirectory:<unresolvedSignature>(1),<empty>,,true,,,setWorkingDirectory,,,0,<unresolvedSignature>
111669155427,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.start:<unresolvedSignature>(2),<empty>,,true,,,start,,,0,<unresolvedSignature>
111669155428,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.waitForFinished:<unresolvedSignature>(0),<empty>,,true,,,waitForFinished,,,0,<unresolvedSignature>
111669155429,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.readAllStandardOutput:<unresolvedSignature>(0),<empty>,,true,,,readAllStandardOutput,,,0,<unresolvedSignature>
111669155430,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.readAllStandardError:<unresolvedSignature>(0),<empty>,,true,,,readAllStandardError,,,0,<unresolvedSignature>
111669155431,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.exitCode:<unresolvedSignature>(0),<empty>,,true,,,exitCode,,,0,<unresolvedSignature>
111669155432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.start:<unresolvedSignature>(0),<empty>,,true,,,start,,,0,<unresolvedSignature>
111669155433,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FileWithDetails,<empty>,,true,,,FileWithDetails,,,0,
111669155434,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.identify:<unresolvedSignature>(2),<empty>,,true,,,identify,,,0,<unresolvedSignature>
111669155435,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.transform:<unresolvedSignature>(4),<empty>,,true,,,transform,,,0,<unresolvedSignature>
111669155436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThreadResult.getNextFile:ANY(),<empty>,,true,,,getNextFile,,,0,ANY()
111669155437,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckThread.runAddonsAndTools:void(Settings&,FileSettings*,ANY)",<empty>,,true,,,runAddonsAndTools,,,0,"void(Settings&,FileSettings*,ANY)"
111669155438,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.runAddonsAndTools:<unresolvedSignature>(3),<empty>,,true,,,runAddonsAndTools,,,0,<unresolvedSignature>
111669155439,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:28:28:CLANG_ANALYZER:0,<empty>,,true,28,28,CLANG_ANALYZER,,,0,
111669155440,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:29:29:CLANG_TIDY:0,<empty>,,true,29,29,CLANG_TIDY,,,0,
111669155441,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.split:<unresolvedSignature>(1),<empty>,,true,,,split,,,0,<unresolvedSignature>
111669155442,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckThread.clangTidyCmd:ANY(),<empty>,,true,,,clangTidyCmd,,,0,ANY()
111669155443,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.entryList:<unresolvedSignature>(0),<empty>,,true,,,entryList,,,0,<unresolvedSignature>
111669155444,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.absolutePath:<unresolvedSignature>(0),<empty>,,true,,,absolutePath,,,0,<unresolvedSignature>
111669155445,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.exists:<unresolvedSignature>(0),<empty>,,true,,,exists,,,0,<unresolvedSignature>
111669155446,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QDir:<unresolvedSignature>(1),<empty>,,true,,,QDir,,,0,<unresolvedSignature>
111669155447,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Standards.getCPP<const>:ANY(),<empty>,,true,,,getCPP,,,0,ANY()
111669155448,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"AnalyzerInformation.getAnalyzerInfoFile:ANY(ANY,ANY,ANY)",<empty>,,true,,,getAnalyzerInfoFile,,,0,"ANY(ANY,ANY,ANY)"
111669155449,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckThread.clangCmd:ANY(),<empty>,,true,,,clangCmd,,,0,ANY()
111669155450,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.qChecksum:<unresolvedSignature>(2),<empty>,,true,,,qChecksum,,,0,<unresolvedSignature>
111669155451,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.readAll:<unresolvedSignature>(0),<empty>,,true,,,readAll,,,0,<unresolvedSignature>
111669155452,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.parseClangErrors:<unresolvedSignature>(3),<empty>,,true,,,parseClangErrors,,,0,<unresolvedSignature>
111669155453,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.waitForFinished:<unresolvedSignature>(1),<empty>,,true,,,waitForFinished,,,0,<unresolvedSignature>
111669155454,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckThread.parseClangErrors:void(ANY,ANY,ANY)",<empty>,,true,,,parseClangErrors,,,0,"void(ANY,ANY,ANY)"
111669155455,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.FileLocation:<unresolvedSignature>(4),<empty>,,true,,,FileLocation,,,0,<unresolvedSignature>
111669155456,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.atEnd:<unresolvedSignature>(0),<empty>,,true,,,atEnd,,,0,<unresolvedSignature>
111669155457,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.readLine:<unresolvedSignature>(0),<empty>,,true,,,readLine,,,0,<unresolvedSignature>
111669155458,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QErrorPathItem:<unresolvedSignature>(0),<empty>,,true,,,QErrorPathItem,,,0,<unresolvedSignature>
111669155459,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.last:<unresolvedSignature>(0),<empty>,,true,,,last,,,0,<unresolvedSignature>
111669155460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.match:<unresolvedSignature>(1),<empty>,,true,,,match,,,0,<unresolvedSignature>
111669155461,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasMatch:<unresolvedSignature>(0),<empty>,,true,,,hasMatch,,,0,<unresolvedSignature>
111669155462,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.captured:<unresolvedSignature>(1),<empty>,,true,,,captured,,,0,<unresolvedSignature>
111669155463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ErrorItem:<unresolvedSignature>(0),<empty>,,true,,,ErrorItem,,,0,<unresolvedSignature>
111669155464,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setFileName:<unresolvedSignature>(1),<empty>,,true,,,setFileName,,,0,<unresolvedSignature>
111669155465,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckThread.isSuppressed:bool(SuppressionList.ErrorMessage&),<empty>,,true,,,isSuppressed,,,0,bool(SuppressionList.ErrorMessage&)
111669155466,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.toString:<unresolvedSignature>(0),<empty>,,true,,,toString,,,0,<unresolvedSignature>
111669155467,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QSettings:<unresolvedSignature>(0),<empty>,,true,,,QSettings,,,0,<unresolvedSignature>
111669155468,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:85:85:SETTINGS_CLANG_PATH:0,<empty>,,true,85,85,SETTINGS_CLANG_PATH,,,0,
111669155469,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setForeground:<unresolvedSignature>(1),<empty>,,true,,,setForeground,,,0,<unresolvedSignature>
111669155470,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setFontWeight:<unresolvedSignature>(1),<empty>,,true,,,setFontWeight,,,0,<unresolvedSignature>
111669155471,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QRegularExpression:<unresolvedSignature>(1),<empty>,,true,,,QRegularExpression,,,0,<unresolvedSignature>
111669155472,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setBackground:<unresolvedSignature>(1),<empty>,,true,,,setBackground,,,0,<unresolvedSignature>
111669155473,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.globalMatch:<unresolvedSignature>(1),<empty>,,true,,,globalMatch,,,0,<unresolvedSignature>
111669155474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasNext:<unresolvedSignature>(0),<empty>,,true,,,hasNext,,,0,<unresolvedSignature>
111669155475,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.next:<unresolvedSignature>(0),<empty>,,true,,,next,,,0,<unresolvedSignature>
111669155476,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setFormat:<unresolvedSignature>(3),<empty>,,true,,,setFormat,,,0,<unresolvedSignature>
111669155477,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.capturedStart:<unresolvedSignature>(0),<empty>,,true,,,capturedStart,,,0,<unresolvedSignature>
111669155478,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.capturedLength:<unresolvedSignature>(0),<empty>,,true,,,capturedLength,,,0,<unresolvedSignature>
111669155479,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setCurrentBlockState:<unresolvedSignature>(1),<empty>,,true,,,setCurrentBlockState,,,0,<unresolvedSignature>
111669155480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.previousBlockState:<unresolvedSignature>(0),<empty>,,true,,,previousBlockState,,,0,<unresolvedSignature>
111669155481,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.indexOf:<unresolvedSignature>(1),<empty>,,true,,,indexOf,,,0,<unresolvedSignature>
111669155482,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.match:<unresolvedSignature>(2),<empty>,,true,,,match,,,0,<unresolvedSignature>
111669155483,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.indexOf:<unresolvedSignature>(2),<empty>,,true,,,indexOf,,,0,<unresolvedSignature>
111669155484,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.document:<unresolvedSignature>(0),<empty>,,true,,,document,,,0,<unresolvedSignature>
111669155485,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setStyleHint:<unresolvedSignature>(1),<empty>,,true,,,setStyleHint,,,0,<unresolvedSignature>
111669155486,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setFont:<unresolvedSignature>(1),<empty>,,true,,,setFont,,,0,<unresolvedSignature>
111669155487,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setObjectName:<unresolvedSignature>(1),<empty>,,true,,,setObjectName,,,0,<unresolvedSignature>
111669155488,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setStyleSheet:<unresolvedSignature>(1),<empty>,,true,,,setStyleSheet,,,0,<unresolvedSignature>
111669155489,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CodeEditor.generateStyleString:ANY(),<empty>,,true,,,generateStyleString,,,0,ANY()
111669155490,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QKeySequence:<unresolvedSignature>(1),<empty>,,true,,,QKeySequence,,,0,<unresolvedSignature>
111669155491,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.SIGNAL:<unresolvedSignature>(1),<empty>,,true,,,SIGNAL,,,0,<unresolvedSignature>
111669155492,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.activated:<unresolvedSignature>(0),<empty>,,true,,,activated,,,0,<unresolvedSignature>
111669155493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.SLOT:<unresolvedSignature>(1),<empty>,,true,,,SLOT,,,0,<unresolvedSignature>
111669155494,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.copy:<unresolvedSignature>(0),<empty>,,true,,,copy,,,0,<unresolvedSignature>
111669155495,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.selectAll:<unresolvedSignature>(0),<empty>,,true,,,selectAll,,,0,<unresolvedSignature>
111669155496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.updateLineNumberAreaWidth:<unresolvedSignature>(1),<empty>,,true,,,updateLineNumberAreaWidth,,,0,<unresolvedSignature>
111669155497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.rehighlight:<unresolvedSignature>(0),<empty>,,true,,,rehighlight,,,0,<unresolvedSignature>
111669155498,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Highlighter.setSymbols:void(ANY),<empty>,,true,,,setSymbols,,,0,void(ANY)
111669155499,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setPlainText:<unresolvedSignature>(1),<empty>,,true,,,setPlainText,,,0,<unresolvedSignature>
111669155500,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getPos:int(ANY,int)",<empty>,,true,,,getPos,,,0,"int(ANY,int)"
111669155501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.textCursor:<unresolvedSignature>(0),<empty>,,true,,,textCursor,,,0,<unresolvedSignature>
111669155502,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setPosition:<unresolvedSignature>(1),<empty>,,true,,,setPosition,,,0,<unresolvedSignature>
111669155503,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setTextCursor:<unresolvedSignature>(1),<empty>,,true,,,setTextCursor,,,0,<unresolvedSignature>
111669155504,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.centerCursor:<unresolvedSignature>(0),<empty>,,true,,,centerCursor,,,0,<unresolvedSignature>
111669155505,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getPos:<unresolvedSignature>(2),<empty>,,true,,,getPos,,,0,<unresolvedSignature>
111669155506,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.toPlainText:<unresolvedSignature>(0),<empty>,,true,,,toPlainText,,,0,<unresolvedSignature>
111669155507,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.qMax:<unresolvedSignature>(2),<empty>,,true,,,qMax,,,0,<unresolvedSignature>
111669155508,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.blockCount:<unresolvedSignature>(0),<empty>,,true,,,blockCount,,,0,<unresolvedSignature>
111669155509,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentDivision,<empty>,,true,,,<operator>.assignmentDivision,,,0,
111669155510,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.width:<unresolvedSignature>(1),<empty>,,true,,,width,,,0,<unresolvedSignature>
111669155511,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fontMetrics:<unresolvedSignature>(0),<empty>,,true,,,fontMetrics,,,0,<unresolvedSignature>
111669155512,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QLatin1Char:<unresolvedSignature>(1),<empty>,,true,,,QLatin1Char,,,0,<unresolvedSignature>
111669155513,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setViewportMargins:<unresolvedSignature>(4),<empty>,,true,,,setViewportMargins,,,0,<unresolvedSignature>
111669155514,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.scroll:<unresolvedSignature>(2),<empty>,,true,,,scroll,,,0,<unresolvedSignature>
111669155515,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.update:<unresolvedSignature>(4),<empty>,,true,,,update,,,0,<unresolvedSignature>
111669155516,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.y:<unresolvedSignature>(0),<empty>,,true,,,y,,,0,<unresolvedSignature>
111669155517,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.width:<unresolvedSignature>(0),<empty>,,true,,,width,,,0,<unresolvedSignature>
111669155518,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.height:<unresolvedSignature>(0),<empty>,,true,,,height,,,0,<unresolvedSignature>
111669155519,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.rect:<unresolvedSignature>(0),<empty>,,true,,,rect,,,0,<unresolvedSignature>
111669155520,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.viewport:<unresolvedSignature>(0),<empty>,,true,,,viewport,,,0,<unresolvedSignature>
111669155521,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.resizeEvent:<unresolvedSignature>(1),<empty>,,true,,,resizeEvent,,,0,<unresolvedSignature>
111669155522,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.contentsRect:<unresolvedSignature>(0),<empty>,,true,,,contentsRect,,,0,<unresolvedSignature>
111669155523,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setGeometry:<unresolvedSignature>(1),<empty>,,true,,,setGeometry,,,0,<unresolvedSignature>
111669155524,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QRect:<unresolvedSignature>(4),<empty>,,true,,,QRect,,,0,<unresolvedSignature>
111669155525,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.left:<unresolvedSignature>(0),<empty>,,true,,,left,,,0,<unresolvedSignature>
111669155526,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setProperty:<unresolvedSignature>(2),<empty>,,true,,,setProperty,,,0,<unresolvedSignature>
111669155527,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QTextCursor:<unresolvedSignature>(1),<empty>,,true,,,QTextCursor,,,0,<unresolvedSignature>
111669155528,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.clearSelection:<unresolvedSignature>(0),<empty>,,true,,,clearSelection,,,0,<unresolvedSignature>
111669155529,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fillRect:<unresolvedSignature>(2),<empty>,,true,,,fillRect,,,0,<unresolvedSignature>
111669155530,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.firstVisibleBlock:<unresolvedSignature>(0),<empty>,,true,,,firstVisibleBlock,,,0,<unresolvedSignature>
111669155531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.blockNumber:<unresolvedSignature>(0),<empty>,,true,,,blockNumber,,,0,<unresolvedSignature>
111669155532,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.translated:<unresolvedSignature>(1),<empty>,,true,,,translated,,,0,<unresolvedSignature>
111669155533,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.blockBoundingGeometry:<unresolvedSignature>(1),<empty>,,true,,,blockBoundingGeometry,,,0,<unresolvedSignature>
111669155534,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.contentOffset:<unresolvedSignature>(0),<empty>,,true,,,contentOffset,,,0,<unresolvedSignature>
111669155535,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.blockBoundingRect:<unresolvedSignature>(1),<empty>,,true,,,blockBoundingRect,,,0,<unresolvedSignature>
111669155536,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isValid:<unresolvedSignature>(0),<empty>,,true,,,isValid,,,0,<unresolvedSignature>
111669155537,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.bottom:<unresolvedSignature>(0),<empty>,,true,,,bottom,,,0,<unresolvedSignature>
111669155538,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isVisible:<unresolvedSignature>(0),<empty>,,true,,,isVisible,,,0,<unresolvedSignature>
111669155539,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.number:<unresolvedSignature>(1),<empty>,,true,,,number,,,0,<unresolvedSignature>
111669155540,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setPen:<unresolvedSignature>(1),<empty>,,true,,,setPen,,,0,<unresolvedSignature>
111669155541,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.drawText:<unresolvedSignature>(6),<empty>,,true,,,drawText,,,0,<unresolvedSignature>
111669155542,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.red:<unresolvedSignature>(0),<empty>,,true,,,red,,,0,<unresolvedSignature>
111669155543,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.green:<unresolvedSignature>(0),<empty>,,true,,,green,,,0,<unresolvedSignature>
111669155544,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.blue:<unresolvedSignature>(0),<empty>,,true,,,blue,,,0,<unresolvedSignature>
111669155545,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.childGroups:<unresolvedSignature>(0),<empty>,,true,,,childGroups,,,0,<unresolvedSignature>
111669155546,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.beginGroup:<unresolvedSignature>(1),<empty>,,true,,,beginGroup,,,0,<unresolvedSignature>
111669155547,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QVariant:<unresolvedSignature>(1),<empty>,,true,,,QVariant,,,0,<unresolvedSignature>
111669155548,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.endGroup:<unresolvedSignature>(0),<empty>,,true,,,endGroup,,,0,<unresolvedSignature>
111669155549,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.value<QColor>:<unresolvedSignature>(0),<empty>,,true,,,value<QColor>,,,0,<unresolvedSignature>
111669155550,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CodeEditorStyle.isSystemTheme<const>:bool(),<empty>,,true,,,isSystemTheme,,,0,bool()
111669155551,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.updateColor:<unresolvedSignature>(0),<empty>,,true,,,updateColor,,,0,<unresolvedSignature>
111669155552,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.clicked:<unresolvedSignature>(0),<empty>,,true,,,clicked,,,0,<unresolvedSignature>
111669155553,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setModal:<unresolvedSignature>(1),<empty>,,true,,,setModal,,,0,<unresolvedSignature>
111669155554,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setColor:<unresolvedSignature>(1),<empty>,,true,,,setColor,,,0,<unresolvedSignature>
111669155555,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.selectedColor:<unresolvedSignature>(0),<empty>,,true,,,selectedColor,,,0,<unresolvedSignature>
111669155556,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addItem:<unresolvedSignature>(2),<empty>,,true,,,addItem,,,0,<unresolvedSignature>
111669155557,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.updateWeight:<unresolvedSignature>(0),<empty>,,true,,,updateWeight,,,0,<unresolvedSignature>
111669155558,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findData:<unresolvedSignature>(1),<empty>,,true,,,findData,,,0,<unresolvedSignature>
111669155559,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setCurrentIndex:<unresolvedSignature>(1),<empty>,,true,,,setCurrentIndex,,,0,<unresolvedSignature>
111669155560,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setWeight:<unresolvedSignature>(1),<empty>,,true,,,setWeight,,,0,<unresolvedSignature>
111669155561,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.itemData:<unresolvedSignature>(1),<empty>,,true,,,itemData,,,0,<unresolvedSignature>
111669155562,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addRow:<unresolvedSignature>(2),<empty>,,true,,,addRow,,,0,<unresolvedSignature>
111669155563,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addLayout:<unresolvedSignature>(1),<empty>,,true,,,addLayout,,,0,<unresolvedSignature>
111669155564,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setMinimumWidth:<unresolvedSignature>(1),<empty>,,true,,,setMinimumWidth,,,0,<unresolvedSignature>
111669155565,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QString:<unresolvedSignature>(2),<empty>,,true,,,QString,,,0,<unresolvedSignature>
111669155566,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CodeEditor.setError:void(QString&,int,ANY)",<empty>,,true,,,setError,,,0,"void(QString&,int,ANY)"
111669155567,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addWidget:<unresolvedSignature>(1),<empty>,,true,,,addWidget,,,0,<unresolvedSignature>
111669155568,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addStretch:<unresolvedSignature>(1),<empty>,,true,,,addStretch,,,0,<unresolvedSignature>
111669155569,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.accepted:<unresolvedSignature>(0),<empty>,,true,,,accepted,,,0,<unresolvedSignature>
111669155570,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.rejected:<unresolvedSignature>(0),<empty>,,true,,,rejected,,,0,<unresolvedSignature>
111669155571,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.button:<unresolvedSignature>(1),<empty>,,true,,,button,,,0,<unresolvedSignature>
111669155572,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.resetStyle:<unresolvedSignature>(0),<empty>,,true,,,resetStyle,,,0,<unresolvedSignature>
111669155573,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.colorChanged:<unresolvedSignature>(1),<empty>,,true,,,colorChanged,,,0,<unresolvedSignature>
111669155574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.colorChangedWidgetFG:<unresolvedSignature>(1),<empty>,,true,,,colorChangedWidgetFG,,,0,<unresolvedSignature>
111669155575,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.colorChangedWidgetBG:<unresolvedSignature>(1),<empty>,,true,,,colorChangedWidgetBG,,,0,<unresolvedSignature>
111669155576,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.colorChangedHighlightBG:<unresolvedSignature>(1),<empty>,,true,,,colorChangedHighlightBG,,,0,<unresolvedSignature>
111669155577,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.colorChangedLineNumFG:<unresolvedSignature>(1),<empty>,,true,,,colorChangedLineNumFG,,,0,<unresolvedSignature>
111669155578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.colorChangedLineNumBG:<unresolvedSignature>(1),<empty>,,true,,,colorChangedLineNumBG,,,0,<unresolvedSignature>
111669155579,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.colorChangedKeywordFG:<unresolvedSignature>(1),<empty>,,true,,,colorChangedKeywordFG,,,0,<unresolvedSignature>
111669155580,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.weightChanged:<unresolvedSignature>(1),<empty>,,true,,,weightChanged,,,0,<unresolvedSignature>
111669155581,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.weightChangedKeyword:<unresolvedSignature>(1),<empty>,,true,,,weightChangedKeyword,,,0,<unresolvedSignature>
111669155582,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.colorChangedClassFG:<unresolvedSignature>(1),<empty>,,true,,,colorChangedClassFG,,,0,<unresolvedSignature>
111669155583,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.weightChangedClass:<unresolvedSignature>(1),<empty>,,true,,,weightChangedClass,,,0,<unresolvedSignature>
111669155584,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.colorChangedQuoteFG:<unresolvedSignature>(1),<empty>,,true,,,colorChangedQuoteFG,,,0,<unresolvedSignature>
111669155585,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.weightChangedQuote:<unresolvedSignature>(1),<empty>,,true,,,weightChangedQuote,,,0,<unresolvedSignature>
111669155586,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.colorChangedCommentFG:<unresolvedSignature>(1),<empty>,,true,,,colorChangedCommentFG,,,0,<unresolvedSignature>
111669155587,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.weightChangedComment:<unresolvedSignature>(1),<empty>,,true,,,weightChangedComment,,,0,<unresolvedSignature>
111669155588,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.colorChangedSymbolFG:<unresolvedSignature>(1),<empty>,,true,,,colorChangedSymbolFG,,,0,<unresolvedSignature>
111669155589,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.colorChangedSymbolBG:<unresolvedSignature>(1),<empty>,,true,,,colorChangedSymbolBG,,,0,<unresolvedSignature>
111669155590,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.weightChangedSymbol:<unresolvedSignature>(1),<empty>,,true,,,weightChangedSymbol,,,0,<unresolvedSignature>
111669155591,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SelectColorButton.setColor:void(SelectColorButton.QColor&),<empty>,,true,,,setColor,,,0,void(SelectColorButton.QColor&)
111669155592,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SelectFontWeightCombo.setWeight:void(ANY),<empty>,,true,,,setWeight,,,0,void(ANY)
111669155593,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setEnabled:<unresolvedSignature>(1),<empty>,,true,,,setEnabled,,,0,<unresolvedSignature>
111669155594,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QStringList:<unresolvedSignature>(1),<empty>,,true,,,QStringList,,,0,<unresolvedSignature>
111669155595,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:101:101:SETTINGS_LAST_CHECK_PATH:0,<empty>,,true,101,101,SETTINGS_LAST_CHECK_PATH,,,0,
111669155596,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.homePath:<unresolvedSignature>(0),<empty>,,true,,,homePath,,,0,<unresolvedSignature>
111669155597,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.translate:<unresolvedSignature>(2),<empty>,,true,,,translate,,,0,<unresolvedSignature>
111669155598,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.join:<unresolvedSignature>(1),<empty>,,true,,,join,,,0,<unresolvedSignature>
111669155599,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.canonicalPath:<unresolvedSignature>(0),<empty>,,true,,,canonicalPath,,,0,<unresolvedSignature>
111669155600,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.applicationFilePath:<unresolvedSignature>(0),<empty>,,true,,,applicationFilePath,,,0,<unresolvedSignature>
111669155601,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.indexOf:<unresolvedSignature>(3),<empty>,,true,,,indexOf,,,0,<unresolvedSignature>
111669155602,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"addHeaders:void(ANY,ANY)",<empty>,,true,,,addHeaders,,,0,"void(ANY,ANY)"
111669155603,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getProjectName<const>:ANY(),<empty>,,true,,,getProjectName,,,0,ANY()
111669155604,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getCodingStandards<const>:ANY(),<empty>,,true,,,getCodingStandards,,,0,ANY()
111669155605,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getAddons<const>:ANY(),<empty>,,true,,,getAddons,,,0,ANY()
111669155606,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addItem:<unresolvedSignature>(1),<empty>,,true,,,addItem,,,0,<unresolvedSignature>
111669155607,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.toUpper:<unresolvedSignature>(0),<empty>,,true,,,toUpper,,,0,<unresolvedSignature>
111669155608,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.standardButton:<unresolvedSignature>(1),<empty>,,true,,,standardButton,,,0,<unresolvedSignature>
111669155609,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.currentText:<unresolvedSignature>(0),<empty>,,true,,,currentText,,,0,<unresolvedSignature>
111669155610,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getSaveFileName:<unresolvedSignature>(4),<empty>,,true,,,getSaveFileName,,,0,<unresolvedSignature>
111669155611,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isChecked:<unresolvedSignature>(0),<empty>,,true,,,isChecked,,,0,<unresolvedSignature>
111669155612,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.setProjectName:void(ANY),<empty>,,true,,,setProjectName,,,0,void(ANY)
111669155613,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.write:bool(ANY),<empty>,,true,,,write,,,0,bool(ANY)
111669155614,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.open:<unresolvedSignature>(0),<empty>,,true,,,open,,,0,<unresolvedSignature>
111669155615,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FileList.addPathList:void(ANY),<empty>,,true,,,addPathList,,,0,void(ANY)
111669155616,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getCheckPaths<const>:ANY(),<empty>,,true,,,getCheckPaths,,,0,ANY()
111669155617,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getImportProject<const>:ANY(),<empty>,,true,,,getImportProject,,,0,ANY()
111669155618,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getFilename<const>:ANY(),<empty>,,true,,,getFilename,,,0,ANY()
111669155619,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isAbsolute:<unresolvedSignature>(0),<empty>,,true,,,isAbsolute,,,0,<unresolvedSignature>
111669155620,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.import:<unresolvedSignature>(1),<empty>,,true,,,import,,,0,<unresolvedSignature>
111669155621,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,toStdStringList:ANY(ANY),<empty>,,true,,,toStdStringList,,,0,ANY(ANY)
111669155622,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getExcludedPaths<const>:ANY(),<empty>,,true,,,getExcludedPaths,,,0,ANY()
111669155623,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.absoluteDir:<unresolvedSignature>(0),<empty>,,true,,,absoluteDir,,,0,<unresolvedSignature>
111669155624,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addFile:<unresolvedSignature>(1),<empty>,,true,,,addFile,,,0,<unresolvedSignature>
111669155625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.relativeFilePath:<unresolvedSignature>(1),<empty>,,true,,,relativeFilePath,,,0,<unresolvedSignature>
111669155626,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FileList.getFileList<const>:ANY(),<empty>,,true,,,getFileList,,,0,ANY()
111669155627,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addHeaders:<unresolvedSignature>(2),<empty>,,true,,,addHeaders,,,0,<unresolvedSignature>
111669155628,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addData:<unresolvedSignature>(1),<empty>,,true,,,addData,,,0,<unresolvedSignature>
111669155629,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.result:<unresolvedSignature>(0),<empty>,,true,,,result,,,0,<unresolvedSignature>
111669155630,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.number:<unresolvedSignature>(2),<empty>,,true,,,number,,,0,<unresolvedSignature>
111669155631,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getSuppressions<const>:ANY(),<empty>,,true,,,getSuppressions,,,0,ANY()
111669155632,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fileName:<unresolvedSignature>(0),<empty>,,true,,,fileName,,,0,<unresolvedSignature>
111669155633,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.lineNumber:<unresolvedSignature>(0),<empty>,,true,,,lineNumber,,,0,<unresolvedSignature>
111669155634,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.name:<unresolvedSignature>(0),<empty>,,true,,,name,,,0,<unresolvedSignature>
111669155635,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.attributes:<unresolvedSignature>(0),<empty>,,true,,,attributes,,,0,<unresolvedSignature>
111669155636,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.readNext:<unresolvedSignature>(0),<empty>,,true,,,readNext,,,0,<unresolvedSignature>
111669155637,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,unhandledElement:ANY(ANY),<empty>,,true,,,unhandledElement,,,0,ANY(ANY)
111669155638,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.entry:<unresolvedSignature>(2),<empty>,,true,,,entry,,,0,<unresolvedSignature>
111669155639,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.readElementText:<unresolvedSignature>(0),<empty>,,true,,,readElementText,,,0,<unresolvedSignature>
111669155640,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.toUInt:<unresolvedSignature>(0),<empty>,,true,,,toUInt,,,0,<unresolvedSignature>
111669155641,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isNull:<unresolvedSignature>(0),<empty>,,true,,,isNull,,,0,<unresolvedSignature>
111669155642,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,loadFunctionArg:CppcheckLibraryData.Function.Arg(ANY),<empty>,,true,,,loadFunctionArg,,,0,CppcheckLibraryData.Function.Arg(ANY)
111669155643,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasAttribute:<unresolvedSignature>(1),<empty>,,true,,,hasAttribute,,,0,<unresolvedSignature>
111669155644,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.mandatoryAttibuteMissing:<unresolvedSignature>(2),<empty>,,true,,,mandatoryAttibuteMissing,,,0,<unresolvedSignature>
111669155645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CppcheckLibraryData.clear:void(),<empty>,,true,,,clear,,,0,void()
111669155646,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,loadContainer:CppcheckLibraryData.Container(ANY),<empty>,,true,,,loadContainer,,,0,CppcheckLibraryData.Container(ANY)
111669155647,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,loadDefine:CppcheckLibraryData.Define(ANY),<empty>,,true,,,loadDefine,,,0,CppcheckLibraryData.Define(ANY)
111669155648,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,loadUndefine:ANY(ANY),<empty>,,true,,,loadUndefine,,,0,ANY(ANY)
111669155649,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"loadFunction:CppcheckLibraryData.Function(ANY,ANY)",<empty>,,true,,,loadFunction,,,0,"CppcheckLibraryData.Function(ANY,ANY)"
111669155650,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,loadMemoryResource:CppcheckLibraryData.MemoryResource(ANY),<empty>,,true,,,loadMemoryResource,,,0,CppcheckLibraryData.MemoryResource(ANY)
111669155651,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,loadPodType:CppcheckLibraryData.PodType(ANY),<empty>,,true,,,loadPodType,,,0,CppcheckLibraryData.PodType(ANY)
111669155652,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,loadSmartPointer:CppcheckLibraryData.SmartPointer(ANY),<empty>,,true,,,loadSmartPointer,,,0,CppcheckLibraryData.SmartPointer(ANY)
111669155653,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,loadTypeChecks:ANY(ANY),<empty>,,true,,,loadTypeChecks,,,0,ANY(ANY)
111669155654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,loadPlatformType:CppcheckLibraryData.PlatformType(ANY),<empty>,,true,,,loadPlatformType,,,0,CppcheckLibraryData.PlatformType(ANY)
111669155655,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,loadReflection:CppcheckLibraryData.Reflection(ANY),<empty>,,true,,,loadReflection,,,0,CppcheckLibraryData.Reflection(ANY)
111669155656,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,loadMarkup:CppcheckLibraryData.Markup(ANY),<empty>,,true,,,loadMarkup,,,0,CppcheckLibraryData.Markup(ANY)
111669155657,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,loadEntrypoint:CppcheckLibraryData.Entrypoint(ANY),<empty>,,true,,,loadEntrypoint,,,0,CppcheckLibraryData.Entrypoint(ANY)
111669155658,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasError:<unresolvedSignature>(0),<empty>,,true,,,hasError,,,0,<unresolvedSignature>
111669155659,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.errorString:<unresolvedSignature>(0),<empty>,,true,,,errorString,,,0,<unresolvedSignature>
111669155660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.writeStartElement:<unresolvedSignature>(1),<empty>,,true,,,writeStartElement,,,0,<unresolvedSignature>
111669155661,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.writeAttribute:<unresolvedSignature>(2),<empty>,,true,,,writeAttribute,,,0,<unresolvedSignature>
111669155662,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.writeEndElement:<unresolvedSignature>(0),<empty>,,true,,,writeEndElement,,,0,<unresolvedSignature>
111669155663,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.writeContainerFunctions:<unresolvedSignature>(4),<empty>,,true,,,writeContainerFunctions,,,0,<unresolvedSignature>
111669155664,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"writeContainerRangeItemRecords:void(ANY,ANY)",<empty>,,true,,,writeContainerRangeItemRecords,,,0,"void(ANY,ANY)"
111669155665,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.mid:<unresolvedSignature>(1),<empty>,,true,,,mid,,,0,<unresolvedSignature>
111669155666,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.chop:<unresolvedSignature>(1),<empty>,,true,,,chop,,,0,<unresolvedSignature>
111669155667,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.writeComment:<unresolvedSignature>(1),<empty>,,true,,,writeComment,,,0,<unresolvedSignature>
111669155668,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.writeEmptyElement:<unresolvedSignature>(1),<empty>,,true,,,writeEmptyElement,,,0,<unresolvedSignature>
111669155669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CppcheckLibraryData.Function.ReturnValue.empty<const>:bool(),<empty>,,true,,,empty,,,0,bool()
111669155670,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.writeCharacters:<unresolvedSignature>(1),<empty>,,true,,,writeCharacters,,,0,<unresolvedSignature>
111669155671,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.writeTextElement:<unresolvedSignature>(2),<empty>,,true,,,writeTextElement,,,0,<unresolvedSignature>
111669155672,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,bool_to_string:char*(bool),<empty>,,true,,,bool_to_string,,,0,char*(bool)
111669155673,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ANY.isEmpty<const>:bool(),<empty>,,true,,,isEmpty,,,0,bool()
111669155674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.key:<unresolvedSignature>(1),<empty>,,true,,,key,,,0,<unresolvedSignature>
111669155675,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setAutoFormatting:<unresolvedSignature>(1),<empty>,,true,,,setAutoFormatting,,,0,<unresolvedSignature>
111669155676,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setAutoFormattingIndent:<unresolvedSignature>(1),<empty>,,true,,,setAutoFormattingIndent,,,0,<unresolvedSignature>
111669155677,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.writeStartDocument:<unresolvedSignature>(1),<empty>,,true,,,writeStartDocument,,,0,<unresolvedSignature>
111669155678,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"writeFunction:void(ANY,CppcheckLibraryData.Function&)",<empty>,,true,,,writeFunction,,,0,"void(ANY,CppcheckLibraryData.Function&)"
111669155679,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"writeMemoryResource:void(ANY,CppcheckLibraryData.MemoryResource&)",<empty>,,true,,,writeMemoryResource,,,0,"void(ANY,CppcheckLibraryData.MemoryResource&)"
111669155680,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"writeContainer:void(ANY,CppcheckLibraryData.Container&)",<empty>,,true,,,writeContainer,,,0,"void(ANY,CppcheckLibraryData.Container&)"
111669155681,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"writeTypeChecks:void(ANY,ANY)",<empty>,,true,,,writeTypeChecks,,,0,"void(ANY,ANY)"
111669155682,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"writePlatformType:void(ANY,CppcheckLibraryData.PlatformType&)",<empty>,,true,,,writePlatformType,,,0,"void(ANY,CppcheckLibraryData.PlatformType&)"
111669155683,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"writeReflection:void(ANY,CppcheckLibraryData.Reflection&)",<empty>,,true,,,writeReflection,,,0,"void(ANY,CppcheckLibraryData.Reflection&)"
111669155684,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"writeMarkup:void(ANY,CppcheckLibraryData.Markup&)",<empty>,,true,,,writeMarkup,,,0,"void(ANY,CppcheckLibraryData.Markup&)"
111669155685,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setDevice:<unresolvedSignature>(1),<empty>,,true,,,setDevice,,,0,<unresolvedSignature>
111669155686,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Report.getFile:ANY(),<empty>,,true,,,getFile,,,0,ANY()
111669155687,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QErrorPathItem:<unresolvedSignature>(1),<empty>,,true,,,QErrorPathItem,,,0,<unresolvedSignature>
111669155688,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GuiSeverity.toString:ANY(Severity),<empty>,,true,,,toString,,,0,ANY(Severity)
111669155689,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isFile:<unresolvedSignature>(0),<empty>,,true,,,isFile,,,0,<unresolvedSignature>
111669155690,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FileList.getDefaultFilters:ANY(),<empty>,,true,,,getDefaultFilters,,,0,ANY()
111669155691,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.suffix:<unresolvedSignature>(0),<empty>,,true,,,suffix,,,0,<unresolvedSignature>
111669155692,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.contains:<unresolvedSignature>(2),<empty>,,true,,,contains,,,0,<unresolvedSignature>
111669155693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FileList.filterMatches:bool(ANY),<empty>,,true,,,filterMatches,,,0,bool(ANY)
111669155694,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setSorting:<unresolvedSignature>(1),<empty>,,true,,,setSorting,,,0,<unresolvedSignature>
111669155695,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.nameFilters:<unresolvedSignature>(0),<empty>,,true,,,nameFilters,,,0,<unresolvedSignature>
111669155696,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setNameFilters:<unresolvedSignature>(1),<empty>,,true,,,setNameFilters,,,0,<unresolvedSignature>
111669155697,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setFilter:<unresolvedSignature>(1),<empty>,,true,,,setFilter,,,0,<unresolvedSignature>
111669155698,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.entryInfoList:<unresolvedSignature>(0),<empty>,,true,,,entryInfoList,,,0,<unresolvedSignature>
111669155699,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.canonicalFilePath:<unresolvedSignature>(0),<empty>,,true,,,canonicalFilePath,,,0,<unresolvedSignature>
111669155700,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FileList.addDirectory:void(ANY,bool)",<empty>,,true,,,addDirectory,,,0,"void(ANY,bool)"
111669155701,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FileList.addFile:void(ANY),<empty>,,true,,,addFile,,,0,void(ANY)
111669155702,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.filePath:<unresolvedSignature>(0),<empty>,,true,,,filePath,,,0,<unresolvedSignature>
111669155703,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FileList.applyExcludeList:ANY(),<empty>,,true,,,applyExcludeList,,,0,ANY()
111669155704,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.loadTextFile:<unresolvedSignature>(2),<empty>,,true,,,loadTextFile,,,0,<unresolvedSignature>
111669155705,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isReadable:<unresolvedSignature>(0),<empty>,,true,,,isReadable,,,0,<unresolvedSignature>
111669155706,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.scheme:<unresolvedSignature>(0),<empty>,,true,,,scheme,,,0,<unresolvedSignature>
111669155707,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.remove:<unresolvedSignature>(2),<empty>,,true,,,remove,,,0,<unresolvedSignature>
111669155708,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fileData:<unresolvedSignature>(1),<empty>,,true,,,fileData,,,0,<unresolvedSignature>
111669155709,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QUrl:<unresolvedSignature>(1),<empty>,,true,,,QUrl,,,0,<unresolvedSignature>
111669155710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.loadResource:<unresolvedSignature>(2),<empty>,,true,,,loadResource,,,0,<unresolvedSignature>
111669155711,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getDataDir:ANY(),<empty>,,true,,,getDataDir,,,0,ANY()
111669155712,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.applicationDirPath:<unresolvedSignature>(0),<empty>,,true,,,applicationDirPath,,,0,<unresolvedSignature>
111669155713,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getHelpFile:ANY(),<empty>,,true,,,getHelpFile,,,0,ANY()
111669155714,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fromValue<bool>:<unresolvedSignature>(1),<empty>,,true,,,fromValue<bool>,,,0,<unresolvedSignature>
111669155715,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setupData:<unresolvedSignature>(0),<empty>,,true,,,setupData,,,0,<unresolvedSignature>
111669155716,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.contentWidget:<unresolvedSignature>(0),<empty>,,true,,,contentWidget,,,0,<unresolvedSignature>
111669155717,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.indexWidget:<unresolvedSignature>(0),<empty>,,true,,,indexWidget,,,0,<unresolvedSignature>
111669155718,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setHelpEngine:<unresolvedSignature>(1),<empty>,,true,,,setHelpEngine,,,0,<unresolvedSignature>
111669155719,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setSource:<unresolvedSignature>(1),<empty>,,true,,,setSource,,,0,<unresolvedSignature>
111669155720,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.linkActivated:<unresolvedSignature>(1),<empty>,,true,,,linkActivated,,,0,<unresolvedSignature>
111669155721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.linkActivated:<unresolvedSignature>(2),<empty>,,true,,,linkActivated,,,0,<unresolvedSignature>
111669155722,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/libraryaddfunctiondialog.h,gui/libraryaddfunctiondialog.h:33:33:NAMES:0,<empty>,,true,33,33,NAMES,,,0,
111669155723,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setValidator:<unresolvedSignature>(1),<empty>,,true,,,setValidator,,,0,<unresolvedSignature>
111669155724,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.value:<unresolvedSignature>(0),<empty>,,true,,,value,,,0,<unresolvedSignature>
111669155725,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setFlags:ANY(),<empty>,,true,,,setFlags,,,0,ANY()
111669155726,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.flags:<unresolvedSignature>(0),<empty>,,true,,,flags,,,0,<unresolvedSignature>
111669155727,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setSelected:<unresolvedSignature>(1),<empty>,,true,,,setSelected,,,0,<unresolvedSignature>
111669155728,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.selectedItems:<unresolvedSignature>(0),<empty>,,true,,,selectedItems,,,0,<unresolvedSignature>
111669155729,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.count:<unresolvedSignature>(0),<empty>,,true,,,count,,,0,<unresolvedSignature>
111669155730,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.first:<unresolvedSignature>(0),<empty>,,true,,,first,,,0,<unresolvedSignature>
111669155731,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getOpenFileName:<unresolvedSignature>(5),<empty>,,true,,,getOpenFileName,,,0,<unresolvedSignature>
111669155732,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CppcheckLibraryData.swap:void(CppcheckLibraryData&),<empty>,,true,,,swap,,,0,void(CppcheckLibraryData&)
111669155733,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CppcheckLibraryData.toString<const>:ANY(),<empty>,,true,,,toString,,,0,ANY()
111669155734,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getPathFromFilename:<unresolvedSignature>(1),<empty>,,true,,,getPathFromFilename,,,0,<unresolvedSignature>
111669155735,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LibraryAddFunctionDialog.functionName<const>:ANY(),<empty>,,true,,,functionName,,,0,ANY()
111669155736,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setChecked:<unresolvedSignature>(1),<empty>,,true,,,setChecked,,,0,<unresolvedSignature>
111669155737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sortItems:<unresolvedSignature>(0),<empty>,,true,,,sortItems,,,0,<unresolvedSignature>
111669155738,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.filterFunctions:<unresolvedSignature>(1),<empty>,,true,,,filterFunctions,,,0,<unresolvedSignature>
111669155739,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findItems:<unresolvedSignature>(2),<empty>,,true,,,findItems,,,0,<unresolvedSignature>
111669155740,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setHidden:<unresolvedSignature>(1),<empty>,,true,,,setHidden,,,0,<unresolvedSignature>
111669155741,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.currentIndex:<unresolvedSignature>(0),<empty>,,true,,,currentIndex,,,0,<unresolvedSignature>
111669155742,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.row:<unresolvedSignature>(1),<empty>,,true,,,row,,,0,<unresolvedSignature>
111669155743,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LibraryDialog.getArgText:ANY(CppcheckLibraryData.Function.Arg&),<empty>,,true,,,getArgText,,,0,ANY(CppcheckLibraryData.Function.Arg&)
111669155744,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addItems:<unresolvedSignature>(1),<empty>,,true,,,addItems,,,0,<unresolvedSignature>
111669155745,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setValue:<unresolvedSignature>(1),<empty>,,true,,,setValue,,,0,<unresolvedSignature>
111669155746,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setOrganizationName:<unresolvedSignature>(1),<empty>,,true,,,setOrganizationName,,,0,<unresolvedSignature>
111669155747,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setApplicationName:<unresolvedSignature>(1),<empty>,,true,,,setApplicationName,,,0,<unresolvedSignature>
111669155748,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.arguments:<unresolvedSignature>(0),<empty>,,true,,,arguments,,,0,<unresolvedSignature>
111669155749,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setLanguage:<unresolvedSignature>(1),<empty>,,true,,,setLanguage,,,0,<unresolvedSignature>
111669155750,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:81:81:SETTINGS_LANGUAGE:0,<empty>,,true,81,81,SETTINGS_LANGUAGE,,,0,
111669155751,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TranslationHandler.suggestLanguage<const>:ANY(),<empty>,,true,,,suggestLanguage,,,0,ANY()
111669155752,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.CheckArgs:<unresolvedSignature>(1),<empty>,,true,,,CheckArgs,,,0,<unresolvedSignature>
111669155753,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setWindowIcon:<unresolvedSignature>(1),<empty>,,true,,,setWindowIcon,,,0,<unresolvedSignature>
111669155754,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QIcon:<unresolvedSignature>(1),<empty>,,true,,,QIcon,,,0,<unresolvedSignature>
111669155755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.show:<unresolvedSignature>(0),<empty>,,true,,,show,,,0,<unresolvedSignature>
111669155756,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.initialize:<unresolvedSignature>(3),<empty>,,true,,,initialize,,,0,<unresolvedSignature>
111669155757,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setInterval:<unresolvedSignature>(1),<empty>,,true,,,setInterval,,,0,<unresolvedSignature>
111669155758,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setSingleShot:<unresolvedSignature>(1),<empty>,,true,,,setSingleShot,,,0,<unresolvedSignature>
111669155759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setPlaceholderText:<unresolvedSignature>(1),<empty>,,true,,,setPlaceholderText,,,0,<unresolvedSignature>
111669155760,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setClearButtonEnabled:<unresolvedSignature>(1),<empty>,,true,,,setClearButtonEnabled,,,0,<unresolvedSignature>
111669155761,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.textChanged:<unresolvedSignature>(1),<empty>,,true,,,textChanged,,,0,<unresolvedSignature>
111669155762,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.triggered:<unresolvedSignature>(0),<empty>,,true,,,triggered,,,0,<unresolvedSignature>
111669155763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.print:<unresolvedSignature>(0),<empty>,,true,,,print,,,0,<unresolvedSignature>
111669155764,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.printPreview:<unresolvedSignature>(0),<empty>,,true,,,printPreview,,,0,<unresolvedSignature>
111669155765,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,connect:ANY(),<empty>,,true,,,connect,,,0,ANY()
111669155766,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.initialize:<unresolvedSignature>(1),<empty>,,true,,,initialize,,,0,<unresolvedSignature>
111669155767,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.formatAndSetTitle:<unresolvedSignature>(1),<empty>,,true,,,formatAndSetTitle,,,0,<unresolvedSignature>
111669155768,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MainWindow.formatAndSetTitle:void(ANY),<empty>,,true,,,formatAndSetTitle,,,0,void(ANY)
111669155769,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setVisible:<unresolvedSignature>(1),<empty>,,true,,,setVisible,,,0,<unresolvedSignature>
111669155770,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MainWindow.isCppcheckPremium:bool(),<empty>,,true,,,isCppcheckPremium,,,0,bool()
111669155771,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setShortcut:<unresolvedSignature>(1),<empty>,,true,,,setShortcut,,,0,<unresolvedSignature>
111669155772,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.removeFirst:<unresolvedSignature>(0),<empty>,,true,,,removeFirst,,,0,<unresolvedSignature>
111669155773,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MainWindow.handleCLIParams:void(ANY),<empty>,,true,,,handleCLIParams,,,0,void(ANY)
111669155774,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setData:<unresolvedSignature>(1),<empty>,,true,,,setData,,,0,<unresolvedSignature>
111669155775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setCheckable:<unresolvedSignature>(1),<empty>,,true,,,setCheckable,,,0,<unresolvedSignature>
111669155776,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setActionGroup:<unresolvedSignature>(1),<empty>,,true,,,setActionGroup,,,0,<unresolvedSignature>
111669155777,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.insertAction:<unresolvedSignature>(2),<empty>,,true,,,insertAction,,,0,<unresolvedSignature>
111669155778,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:99:99:SETTINGS_CHECKED_PLATFORM:0,<empty>,,true,99,99,SETTINGS_CHECKED_PLATFORM,,,0,
111669155779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.toBool:<unresolvedSignature>(0),<empty>,,true,,,toBool,,,0,<unresolvedSignature>
111669155780,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:94:94:SETTINGS_CHECK_FOR_UPDATES:0,<empty>,,true,94,94,SETTINGS_CHECK_FOR_UPDATES,,,0,
111669155781,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.get:<unresolvedSignature>(1),<empty>,,true,,,get,,,0,<unresolvedSignature>
111669155782,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QNetworkRequest:<unresolvedSignature>(1),<empty>,,true,,,QNetworkRequest,,,0,<unresolvedSignature>
111669155783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MainWindow.loadProjectFile:void(ANY),<empty>,,true,,,loadProjectFile,,,0,void(ANY)
111669155784,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"MainWindow.loadResults:void(ANY,ANY)",<empty>,,true,,,loadResults,,,0,"void(ANY,ANY)"
111669155785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MainWindow.loadResults:void(ANY),<empty>,,true,,,loadResults,,,0,void(ANY)
111669155786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QRegularExpression:<unresolvedSignature>(2),<empty>,,true,,,QRegularExpression,,,0,<unresolvedSignature>
111669155787,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QFile:<unresolvedSignature>(1),<empty>,,true,,,QFile,,,0,<unresolvedSignature>
111669155788,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.loadResults:<unresolvedSignature>(2),<empty>,,true,,,loadResults,,,0,<unresolvedSignature>
111669155789,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.currentPath:<unresolvedSignature>(0),<empty>,,true,,,currentPath,,,0,<unresolvedSignature>
111669155790,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"MainWindow.doAnalyzeFiles:void(ANY,bool,bool)",<empty>,,true,,,doAnalyzeFiles,,,0,"void(ANY,bool,bool)"
111669155791,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:36:36:SETTINGS_WINDOW_MAXIMIZED:0,<empty>,,true,36,36,SETTINGS_WINDOW_MAXIMIZED,,,0,
111669155792,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.showMaximized:<unresolvedSignature>(0),<empty>,,true,,,showMaximized,,,0,<unresolvedSignature>
111669155793,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.resize:<unresolvedSignature>(2),<empty>,,true,,,resize,,,0,<unresolvedSignature>
111669155794,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:37:37:SETTINGS_WINDOW_WIDTH:0,<empty>,,true,37,37,SETTINGS_WINDOW_WIDTH,,,0,
111669155795,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:38:38:SETTINGS_WINDOW_HEIGHT:0,<empty>,,true,38,38,SETTINGS_WINDOW_HEIGHT,,,0,
111669155796,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:52:52:SETTINGS_REPORT_TYPE:0,<empty>,,true,52,52,SETTINGS_REPORT_TYPE,,,0,
111669155797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getShowTypes:<unresolvedSignature>(0),<empty>,,true,,,getShowTypes,,,0,<unresolvedSignature>
111669155798,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setC:<unresolvedSignature>(1),<empty>,,true,,,setC,,,0,<unresolvedSignature>
111669155799,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:64:64:SETTINGS_STD_C:0,<empty>,,true,64,64,SETTINGS_STD_C,,,0,
111669155800,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setCPP:<unresolvedSignature>(1),<empty>,,true,,,setCPP,,,0,<unresolvedSignature>
111669155801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:63:63:SETTINGS_STD_CPP:0,<empty>,,true,63,63,SETTINGS_STD_CPP,,,0,
111669155802,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:47:47:SETTINGS_TOOLBARS_MAIN_SHOW:0,<empty>,,true,47,47,SETTINGS_TOOLBARS_MAIN_SHOW,,,0,
111669155803,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:48:48:SETTINGS_TOOLBARS_VIEW_SHOW:0,<empty>,,true,48,48,SETTINGS_TOOLBARS_VIEW_SHOW,,,0,
111669155804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:49:49:SETTINGS_TOOLBARS_FILTER_SHOW:0,<empty>,,true,49,49,SETTINGS_TOOLBARS_FILTER_SHOW,,,0,
111669155805,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:67:67:SETTINGS_ENFORCED_LANGUAGE:0,<empty>,,true,67,67,SETTINGS_ENFORCED_LANGUAGE,,,0,
111669155806,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:92:92:SETTINGS_OPEN_PROJECT:0,<empty>,,true,92,92,SETTINGS_OPEN_PROJECT,,,0,
111669155807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:102:102:SETTINGS_LAST_PROJECT_PATH:0,<empty>,,true,102,102,SETTINGS_LAST_PROJECT_PATH,,,0,
111669155808,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.setActiveProject:void(),<empty>,,true,,,setActiveProject,,,0,void()
111669155809,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.read:bool(ANY),<empty>,,true,,,read,,,0,bool(ANY)
111669155810,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setCurrent:<unresolvedSignature>(1),<empty>,,true,,,setCurrent,,,0,<unresolvedSignature>
111669155811,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isMaximized:<unresolvedSignature>(0),<empty>,,true,,,isMaximized,,,0,<unresolvedSignature>
111669155812,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:55:55:SETTINGS_SHOW_STYLE:0,<empty>,,true,55,55,SETTINGS_SHOW_STYLE,,,0,
111669155813,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:56:56:SETTINGS_SHOW_ERRORS:0,<empty>,,true,56,56,SETTINGS_SHOW_ERRORS,,,0,
111669155814,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:57:57:SETTINGS_SHOW_WARNINGS:0,<empty>,,true,57,57,SETTINGS_SHOW_WARNINGS,,,0,
111669155815,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:60:60:SETTINGS_SHOW_PORTABILITY:0,<empty>,,true,60,60,SETTINGS_SHOW_PORTABILITY,,,0,
111669155816,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:58:58:SETTINGS_SHOW_PERFORMANCE:0,<empty>,,true,58,58,SETTINGS_SHOW_PERFORMANCE,,,0,
111669155817,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:59:59:SETTINGS_SHOW_INFORMATION:0,<empty>,,true,59,59,SETTINGS_SHOW_INFORMATION,,,0,
111669155818,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.saveSettings:<unresolvedSignature>(1),<empty>,,true,,,saveSettings,,,0,<unresolvedSignature>
111669155819,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.make_shared<Suppressions>:<unresolvedSignature>(0),<empty>,,true,,,make_shared<Suppressions>,,,0,<unresolvedSignature>
111669155820,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getCppcheckSettings:<unresolvedSignature>(2),<empty>,,true,,,getCppcheckSettings,,,0,<unresolvedSignature>
111669155821,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ignorePaths:<unresolvedSignature>(1),<empty>,,true,,,ignorePaths,,,0,<unresolvedSignature>
111669155822,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getAnalyzeAllVsConfigs<const>:bool(),<empty>,,true,,,getAnalyzeAllVsConfigs,,,0,bool()
111669155823,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getVsConfigurations<const>:ANY(),<empty>,,true,,,getVsConfigurations,,,0,ANY()
111669155824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.selectVsConfigurations:<unresolvedSignature>(2),<empty>,,true,,,selectVsConfigurations,,,0,<unresolvedSignature>
111669155825,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.clear:<unresolvedSignature>(1),<empty>,,true,,,clear,,,0,<unresolvedSignature>
111669155826,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.checkingStarted:<unresolvedSignature>(1),<empty>,,true,,,checkingStarted,,,0,<unresolvedSignature>
111669155827,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setCheckDirectory:<unresolvedSignature>(1),<empty>,,true,,,setCheckDirectory,,,0,<unresolvedSignature>
111669155828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThreadHandler.setAddonsAndTools:void(ANY),<empty>,,true,,,setAddonsAndTools,,,0,void(ANY)
111669155829,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getAddonsAndTools<const>:ANY(),<empty>,,true,,,getAddonsAndTools,,,0,ANY()
111669155830,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:86:86:SETTINGS_VS_INCLUDE_PATHS:0,<empty>,,true,86,86,SETTINGS_VS_INCLUDE_PATHS,,,0,
111669155831,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setClangIncludePaths:<unresolvedSignature>(1),<empty>,,true,,,setClangIncludePaths,,,0,<unresolvedSignature>
111669155832,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThreadHandler.setSuppressions:void(ANY),<empty>,,true,,,setSuppressions,,,0,void(ANY)
111669155833,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setCheckSettings:<unresolvedSignature>(1),<empty>,,true,,,setCheckSettings,,,0,<unresolvedSignature>
111669155834,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FileList.addExcludeList:void(ANY),<empty>,,true,,,addExcludeList,,,0,void(ANY)
111669155835,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThreadHandler.setFiles:void(ANY),<empty>,,true,,,setFiles,,,0,void(ANY)
111669155836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getCheckingSuppressions<const>:ANY(),<empty>,,true,,,getCheckingSuppressions,,,0,ANY()
111669155837,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QList<SuppressionList::Suppression>:<unresolvedSignature>(0),<empty>,,true,,,QList<SuppressionList::Suppression>,,,0,<unresolvedSignature>
111669155838,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setFiles:<unresolvedSignature>(1),<empty>,,true,,,setFiles,,,0,<unresolvedSignature>
111669155839,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.error:<unresolvedSignature>(1),<empty>,,true,,,error,,,0,<unresolvedSignature>
111669155840,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.log:<unresolvedSignature>(1),<empty>,,true,,,log,,,0,<unresolvedSignature>
111669155841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.debugError:<unresolvedSignature>(1),<empty>,,true,,,debugError,,,0,<unresolvedSignature>
111669155842,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.analysisDone:<unresolvedSignature>(0),<empty>,,true,,,analysisDone,,,0,<unresolvedSignature>
111669155843,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasVisibleResults:<unresolvedSignature>(0),<empty>,,true,,,hasVisibleResults,,,0,<unresolvedSignature>
111669155844,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.expandAllResults:<unresolvedSignature>(0),<empty>,,true,,,expandAllResults,,,0,<unresolvedSignature>
111669155845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setIcon:<unresolvedSignature>(1),<empty>,,true,,,setIcon,,,0,<unresolvedSignature>
111669155846,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:107:107:SETTINGS_LAST_ANALYZE_FILES_FILTER:0,<empty>,,true,107,107,SETTINGS_LAST_ANALYZE_FILES_FILTER,,,0,
111669155847,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getOpenFileNames:<unresolvedSignature>(5),<empty>,,true,,,getOpenFileNames,,,0,<unresolvedSignature>
111669155848,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.toFilterString:<unresolvedSignature>(1),<empty>,,true,,,toFilterString,,,0,<unresolvedSignature>
111669155849,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getExistingDirectory:<unresolvedSignature>(3),<empty>,,true,,,getExistingDirectory,,,0,<unresolvedSignature>
111669155850,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.selectFilesToAnalyze:<unresolvedSignature>(1),<empty>,,true,,,selectFilesToAnalyze,,,0,<unresolvedSignature>
111669155851,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sort:<unresolvedSignature>(0),<empty>,,true,,,sort,,,0,<unresolvedSignature>
111669155852,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getItem:<unresolvedSignature>(7),<empty>,,true,,,getItem,,,0,<unresolvedSignature>
111669155853,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ignoreOtherConfigs:<unresolvedSignature>(1),<empty>,,true,,,ignoreOtherConfigs,,,0,<unresolvedSignature>
111669155854,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addButton:<unresolvedSignature>(1),<empty>,,true,,,addButton,,,0,<unresolvedSignature>
111669155855,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setDefaultButton:<unresolvedSignature>(1),<empty>,,true,,,setDefaultButton,,,0,<unresolvedSignature>
111669155856,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isAbsolutePath:<unresolvedSignature>(1),<empty>,,true,,,isAbsolutePath,,,0,<unresolvedSignature>
111669155857,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.cleanPath:<unresolvedSignature>(1),<empty>,,true,,,cleanPath,,,0,<unresolvedSignature>
111669155858,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.noquote:<unresolvedSignature>(0),<empty>,,true,,,noquote,,,0,<unresolvedSignature>
111669155859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.load:<unresolvedSignature>(2),<empty>,,true,,,load,,,0,<unresolvedSignature>
111669155860,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.toLatin1:<unresolvedSignature>(0),<empty>,,true,,,toLatin1,,,0,<unresolvedSignature>
111669155861,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"MainWindow.loadLibrary:Library.Error(Library&,ANY)",<empty>,,true,,,loadLibrary,,,0,"Library.Error(Library&,ANY)"
111669155862,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.information:<unresolvedSignature>(3),<empty>,,true,,,information,,,0,<unresolvedSignature>
111669155863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fromNativePath:ANY(ANY),<empty>,,true,,,fromNativePath,,,0,ANY(ANY)
111669155864,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ProjectFile.getAddonFilePath:ANY(ANY,ANY)",<empty>,,true,,,getAddonFilePath,,,0,"ANY(ANY,ANY)"
111669155865,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fromNativePath:<unresolvedSignature>(1),<empty>,,true,,,fromNativePath,,,0,<unresolvedSignature>
111669155866,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:84:84:SETTINGS_MISRA_FILE:0,<empty>,,true,84,84,SETTINGS_MISRA_FILE,,,0,
111669155867,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.serialize:<unresolvedSignature>(0),<empty>,,true,,,serialize,,,0,<unresolvedSignature>
111669155868,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.arg:<unresolvedSignature>(2),<empty>,,true,,,arg,,,0,<unresolvedSignature>
111669155869,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MainWindow.saveSettings:void(),<empty>,,true,,,saveSettings,,,0,void()
111669155870,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.tryLoadLibrary:<unresolvedSignature>(2),<empty>,,true,,,tryLoadLibrary,,,0,<unresolvedSignature>
111669155871,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.critical:<unresolvedSignature>(3),<empty>,,true,,,critical,,,0,<unresolvedSignature>
111669155872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:83:83:SETTINGS_PYTHON_PATH:0,<empty>,,true,83,83,SETTINGS_PYTHON_PATH,,,0,
111669155873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.loadAddon:<unresolvedSignature>(4),<empty>,,true,,,loadAddon,,,0,<unresolvedSignature>
111669155874,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getIncludeDirs<const>:ANY(),<empty>,,true,,,getIncludeDirs,,,0,ANY()
111669155875,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"MainWindow.addIncludeDirs:void(ANY,Settings&)",<empty>,,true,,,addIncludeDirs,,,0,"void(ANY,Settings&)"
111669155876,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getInlineSuppression<const>:bool(),<empty>,,true,,,getInlineSuppression,,,0,bool()
111669155877,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getDefines<const>:ANY(),<empty>,,true,,,getDefines,,,0,ANY()
111669155878,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getUndefines<const>:ANY(),<empty>,,true,,,getUndefines,,,0,ANY()
111669155879,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getLibraries<const>:ANY(),<empty>,,true,,,getLibraries,,,0,ANY()
111669155880,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"MainWindow.tryLoadLibrary:bool(Library&,ANY)",<empty>,,true,,,tryLoadLibrary,,,0,"bool(Library&,ANY)"
111669155881,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SuppressionList.addSuppression:ANY(SuppressionList.Suppression),<empty>,,true,,,addSuppression,,,0,ANY(SuppressionList.Suppression)
111669155882,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getBuildDir<const>:ANY(),<empty>,,true,,,getBuildDir,,,0,ANY()
111669155883,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getPlatform<const>:ANY(),<empty>,,true,,,getPlatform,,,0,ANY()
111669155884,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.loadFromFile:<unresolvedSignature>(2),<empty>,,true,,,loadFromFile,,,0,<unresolvedSignature>
111669155885,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Platform.toString:char*(Platform.Type),<empty>,,true,,,toString,,,0,char*(Platform.Type)
111669155886,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getMaxCtuDepth<const>:int(),<empty>,,true,,,getMaxCtuDepth,,,0,int()
111669155887,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getMaxTemplateRecursion<const>:int(),<empty>,,true,,,getMaxTemplateRecursion,,,0,int()
111669155888,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getCheckLevel<const>:ProjectFile.CheckLevel(),<empty>,,true,,,getCheckLevel,,,0,ProjectFile.CheckLevel()
111669155889,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getCheckHeaders<const>:bool(),<empty>,,true,,,getCheckHeaders,,,0,bool()
111669155890,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getCheckUnusedTemplates<const>:bool(),<empty>,,true,,,getCheckUnusedTemplates,,,0,bool()
111669155891,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getCheckUnknownFunctionReturn<const>:ANY(),<empty>,,true,,,getCheckUnknownFunctionReturn,,,0,ANY()
111669155892,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"MainWindow.loadAddon:ANY(Settings&,ANY,ANY,ANY)",<empty>,,true,,,loadAddon,,,0,"ANY(Settings&,ANY,ANY,ANY)"
111669155893,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getBughunting<const>:bool(),<empty>,,true,,,getBughunting,,,0,bool()
111669155894,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getCertIntPrecision<const>:int(),<empty>,,true,,,getCertIntPrecision,,,0,int()
111669155895,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:87:87:SETTINGS_INLINE_SUPPRESSIONS:0,<empty>,,true,87,87,SETTINGS_INLINE_SUPPRESSIONS,,,0,
111669155896,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:82:82:SETTINGS_GLOBAL_INCLUDE_PATHS:0,<empty>,,true,82,82,SETTINGS_GLOBAL_INCLUDE_PATHS,,,0,
111669155897,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SimpleEnableGroup<enumSeverity>.enable:void(Severity),<empty>,,true,,,enable,,,0,void(Severity)
111669155898,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SimpleEnableGroup<enumChecks>.enable:void(Checks),<empty>,,true,,,enable,,,0,void(Checks)
111669155899,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:74:74:SETTINGS_SHOW_DEBUG_WARNINGS:0,<empty>,,true,74,74,SETTINGS_SHOW_DEBUG_WARNINGS,,,0,
111669155900,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:70:70:SETTINGS_CHECK_FORCE:0,<empty>,,true,70,70,SETTINGS_CHECK_FORCE,,,0,
111669155901,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:71:71:SETTINGS_CHECK_THREADS:0,<empty>,,true,71,71,SETTINGS_CHECK_THREADS,,,0,
111669155902,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setEnabled:<unresolvedSignature>(2),<empty>,,true,,,setEnabled,,,0,<unresolvedSignature>
111669155903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:88:88:SETTINGS_INCONCLUSIVE_ERRORS:0,<empty>,,true,88,88,SETTINGS_INCONCLUSIVE_ERRORS,,,0,
111669155904,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.max:<unresolvedSignature>(2),<empty>,,true,,,max,,,0,<unresolvedSignature>
111669155905,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.checkingFinished:<unresolvedSignature>(0),<empty>,,true,,,checkingFinished,,,0,<unresolvedSignature>
111669155906,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.saveStatistics:<unresolvedSignature>(1),<empty>,,true,,,saveStatistics,,,0,<unresolvedSignature>
111669155907,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.updateFromOldReport:<unresolvedSignature>(1),<empty>,,true,,,updateFromOldReport,,,0,<unresolvedSignature>
111669155908,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.save:<unresolvedSignature>(3),<empty>,,true,,,save,,,0,<unresolvedSignature>
111669155909,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.alert:<unresolvedSignature>(2),<empty>,,true,,,alert,,,0,<unresolvedSignature>
111669155910,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:91:91:SETTINGS_SHOW_STATISTICS:0,<empty>,,true,91,91,SETTINGS_SHOW_STATISTICS,,,0,
111669155911,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sync:<unresolvedSignature>(0),<empty>,,true,,,sync,,,0,<unresolvedSignature>
111669155912,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.updateSettings:<unresolvedSignature>(6),<empty>,,true,,,updateSettings,,,0,<unresolvedSignature>
111669155913,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.updateStyleSetting:<unresolvedSignature>(1),<empty>,,true,,,updateStyleSetting,,,0,<unresolvedSignature>
111669155914,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MainWindow.setLanguage:void(ANY),<empty>,,true,,,setLanguage,,,0,void(ANY)
111669155915,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.analyzeProject:<unresolvedSignature>(2),<empty>,,true,,,analyzeProject,,,0,<unresolvedSignature>
111669155916,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.analyzeProject:<unresolvedSignature>(3),<empty>,,true,,,analyzeProject,,,0,<unresolvedSignature>
111669155917,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.analyzeProject:<unresolvedSignature>(4),<empty>,,true,,,analyzeProject,,,0,<unresolvedSignature>
111669155918,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.clearRecheckFile:<unresolvedSignature>(1),<empty>,,true,,,clearRecheckFile,,,0,<unresolvedSignature>
111669155919,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"MainWindow.analyzeProject:void(ProjectFile*,ANY,bool,bool)",<empty>,,true,,,analyzeProject,,,0,"void(ProjectFile*,ANY,bool,bool)"
111669155920,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getCheckDirectory:<unresolvedSignature>(0),<empty>,,true,,,getCheckDirectory,,,0,<unresolvedSignature>
111669155921,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThreadHandler.setCheckFiles:void(ANY),<empty>,,true,,,setCheckFiles,,,0,void(ANY)
111669155922,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThreadHandler.getCheckStartTime<const>:ANY(),<empty>,,true,,,getCheckStartTime,,,0,ANY()
111669155923,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setCheckStartTime:<unresolvedSignature>(1),<empty>,,true,,,setCheckStartTime,,,0,<unresolvedSignature>
111669155924,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThreadHandler.getReCheckFiles<const>:ANY(bool),<empty>,,true,,,getReCheckFiles,,,0,ANY(bool)
111669155925,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.entryList:<unresolvedSignature>(1),<empty>,,true,,,entryList,,,0,<unresolvedSignature>
111669155926,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Q_ASSERT:<unresolvedSignature>(1),<empty>,,true,,,Q_ASSERT,,,0,<unresolvedSignature>
111669155927,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasResults:<unresolvedSignature>(0),<empty>,,true,,,hasResults,,,0,<unresolvedSignature>
111669155928,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:103:103:SETTINGS_LAST_RESULT_PATH:0,<empty>,,true,103,103,SETTINGS_LAST_RESULT_PATH,,,0,
111669155929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.readErrorsXml:<unresolvedSignature>(1),<empty>,,true,,,readErrorsXml,,,0,<unresolvedSignature>
111669155930,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.showResults:<unresolvedSignature>(2),<empty>,,true,,,showResults,,,0,<unresolvedSignature>
111669155931,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.stop:<unresolvedSignature>(0),<empty>,,true,,,stop,,,0,<unresolvedSignature>
111669155932,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ignore:<unresolvedSignature>(0),<empty>,,true,,,ignore,,,0,<unresolvedSignature>
111669155933,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MainWindow.reAnalyzeSelected:void(ANY),<empty>,,true,,,reAnalyzeSelected,,,0,void(ANY)
111669155934,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getSaveFileName:<unresolvedSignature>(5),<empty>,,true,,,getSaveFileName,,,0,<unresolvedSignature>
111669155935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isSuccess:<unresolvedSignature>(0),<empty>,,true,,,isSuccess,,,0,<unresolvedSignature>
111669155936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getCheckersReport:<unresolvedSignature>(0),<empty>,,true,,,getCheckersReport,,,0,<unresolvedSignature>
111669155937,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getStatistics:<unresolvedSignature>(0),<empty>,,true,,,getStatistics,,,0,<unresolvedSignature>
111669155938,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TranslationHandler.setLanguage:bool(ANY),<empty>,,true,,,setLanguage,,,0,bool(ANY)
111669155939,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.retranslateUi:<unresolvedSignature>(1),<empty>,,true,,,retranslateUi,,,0,<unresolvedSignature>
111669155940,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.translate:<unresolvedSignature>(0),<empty>,,true,,,translate,,,0,<unresolvedSignature>
111669155941,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.stopAnalysis:<unresolvedSignature>(0),<empty>,,true,,,stopAnalysis,,,0,<unresolvedSignature>
111669155942,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.disableProgressbar:<unresolvedSignature>(0),<empty>,,true,,,disableProgressbar,,,0,<unresolvedSignature>
111669155943,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MainWindow.getLastResults:ANY(),<empty>,,true,,,getLastResults,,,0,ANY()
111669155944,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isActiveWindow:<unresolvedSignature>(0),<empty>,,true,,,isActiveWindow,,,0,<unresolvedSignature>
111669155945,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.activateWindow:<unresolvedSignature>(0),<empty>,,true,,,activateWindow,,,0,<unresolvedSignature>
111669155946,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MainWindow.addProjectMRU:void(ANY),<empty>,,true,,,addProjectMRU,,,0,void(ANY)
111669155947,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getRootPath<const>:ANY(),<empty>,,true,,,getRootPath,,,0,ANY()
111669155948,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getLicenseFile<const>:ANY(),<empty>,,true,,,getLicenseFile,,,0,ANY()
111669155949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.executeCommand:<unresolvedSignature>(4),<empty>,,true,,,executeCommand,,,0,<unresolvedSignature>
111669155950,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.mkpath:<unresolvedSignature>(1),<empty>,,true,,,mkpath,,,0,<unresolvedSignature>
111669155951,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QDir:<unresolvedSignature>(0),<empty>,,true,,,QDir,,,0,<unresolvedSignature>
111669155952,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.setFilename:void(ANY),<empty>,,true,,,setFilename,,,0,void(ANY)
111669155953,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setProjectName:<unresolvedSignature>(1),<empty>,,true,,,setProjectName,,,0,<unresolvedSignature>
111669155954,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setBuildDir:<unresolvedSignature>(1),<empty>,,true,,,setBuildDir,,,0,<unresolvedSignature>
111669155955,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StatsDialog.setPathSelected:void(ANY),<empty>,,true,,,setPathSelected,,,0,void(ANY)
111669155956,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setStatistics:<unresolvedSignature>(1),<empty>,,true,,,setStatistics,,,0,<unresolvedSignature>
111669155957,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.filterResults:<unresolvedSignature>(1),<empty>,,true,,,filterResults,,,0,<unresolvedSignature>
111669155958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.qobject_cast<QAction *>:<unresolvedSignature>(1),<empty>,,true,,,qobject_cast<QAction *>,,,0,<unresolvedSignature>
111669155959,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sender:<unresolvedSignature>(0),<empty>,,true,,,sender,,,0,<unresolvedSignature>
111669155960,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MainWindow.removeProjectMRU:void(ANY),<empty>,,true,,,removeProjectMRU,,,0,void(ANY)
111669155961,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.removeAction:<unresolvedSignature>(1),<empty>,,true,,,removeAction,,,0,<unresolvedSignature>
111669155962,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:89:89:SETTINGS_MRU_PROJECTS:0,<empty>,,true,89,89,SETTINGS_MRU_PROJECTS,,,0,
111669155963,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.removeDuplicates:<unresolvedSignature>(0),<empty>,,true,,,removeDuplicates,,,0,<unresolvedSignature>
111669155964,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.qMin:<unresolvedSignature>(2),<empty>,,true,,,qMin,,,0,<unresolvedSignature>
111669155965,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.insertSeparator:<unresolvedSignature>(1),<empty>,,true,,,insertSeparator,,,0,<unresolvedSignature>
111669155966,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.removeAll:<unresolvedSignature>(1),<empty>,,true,,,removeAll,,,0,<unresolvedSignature>
111669155967,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.prepend:<unresolvedSignature>(1),<empty>,,true,,,prepend,,,0,<unresolvedSignature>
111669155968,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.removeLast:<unresolvedSignature>(0),<empty>,,true,,,removeLast,,,0,<unresolvedSignature>
111669155969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.setSuppressions:void(ANY),<empty>,,true,,,setSuppressions,,,0,void(ANY)
111669155970,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.deleteLater:<unresolvedSignature>(0),<empty>,,true,,,deleteLater,,,0,<unresolvedSignature>
111669155971,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.error:<unresolvedSignature>(0),<empty>,,true,,,error,,,0,<unresolvedSignature>
111669155972,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.url:<unresolvedSignature>(0),<empty>,,true,,,url,,,0,<unresolvedSignature>
111669155973,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getVersion:int(ANY),<empty>,,true,,,getVersion,,,0,int(ANY)
111669155974,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getVersion:<unresolvedSignature>(1),<empty>,,true,,,getVersion,,,0,<unresolvedSignature>
111669155975,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.trimmed:<unresolvedSignature>(0),<empty>,,true,,,trimmed,,,0,<unresolvedSignature>
111669155976,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:93:93:SETTINGS_CHECK_VERSION:0,<empty>,,true,93,93,SETTINGS_CHECK_VERSION,,,0,
111669155977,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setToolTip:<unresolvedSignature>(1),<empty>,,true,,,setToolTip,,,0,<unresolvedSignature>
111669155978,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setReportType:<unresolvedSignature>(1),<empty>,,true,,,setReportType,,,0,<unresolvedSignature>
111669155979,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():void(QAction*,QString&)",<empty>,,true,,,<operator>(),,,0,"void(QAction*,QString&)"
111669155980,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setCurrentText:<unresolvedSignature>(1),<empty>,,true,,,setCurrentText,,,0,<unresolvedSignature>
111669155981,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.add:<unresolvedSignature>(2),<empty>,,true,,,add,,,0,<unresolvedSignature>
111669155982,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.SafeChecks.clear:void(),<empty>,,true,,,clear,,,0,void()
111669155983,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ProjectFile.readStringList:void(ANY,QXmlStreamReader&,char*)",<empty>,,true,,,readStringList,,,0,"void(ANY,QXmlStreamReader&,char*)"
111669155984,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.readTagWarnings:<unresolvedSignature>(2),<empty>,,true,,,readTagWarnings,,,0,<unresolvedSignature>
111669155985,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.readString:ANY(QXmlStreamReader&),<empty>,,true,,,readString,,,0,ANY(QXmlStreamReader&)
111669155986,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasAttribute:<unresolvedSignature>(2),<empty>,,true,,,hasAttribute,,,0,<unresolvedSignature>
111669155987,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.toULongLong:<unresolvedSignature>(0),<empty>,,true,,,toULongLong,,,0,<unresolvedSignature>
111669155988,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ProjectFile.writeStringList:void(QXmlStreamWriter&,ANY,char*,char*)",<empty>,,true,,,writeStringList,,,0,"void(QXmlStreamWriter&,ANY,char*,char*)"
111669155989,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.writeEndDocument:<unresolvedSignature>(0),<empty>,,true,,,writeEndDocument,,,0,<unresolvedSignature>
111669155990,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.item:<unresolvedSignature>(1),<empty>,,true,,,item,,,0,<unresolvedSignature>
111669155991,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ImportProject.getVSConfigs:ANY(),<empty>,,true,,,getVSConfigs,,,0,ANY()
111669155992,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hide:<unresolvedSignature>(0),<empty>,,true,,,hide,,,0,<unresolvedSignature>
111669155993,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.compare:<unresolvedSignature>(2),<empty>,,true,,,compare,,,0,<unresolvedSignature>
111669155994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setFlags:<unresolvedSignature>(1),<empty>,,true,,,setFlags,,,0,<unresolvedSignature>
111669155995,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setCheckState:<unresolvedSignature>(1),<empty>,,true,,,setCheckState,,,0,<unresolvedSignature>
111669155996,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.saveSettings:void(),<empty>,,true,,,saveSettings,,,0,void()
111669155997,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:42:42:SETTINGS_PROJECT_DIALOG_WIDTH:0,<empty>,,true,42,42,SETTINGS_PROJECT_DIALOG_WIDTH,,,0,
111669155998,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:43:43:SETTINGS_PROJECT_DIALOG_HEIGHT:0,<empty>,,true,43,43,SETTINGS_PROJECT_DIALOG_HEIGHT,,,0,
111669155999,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.setRootPath:void(ANY),<empty>,,true,,,setRootPath,,,0,void(ANY)
111669156000,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.setBuildDir:void(ANY),<empty>,,true,,,setBuildDir,,,0,void(ANY)
111669156001,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.setIncludepaths:void(ANY),<empty>,,true,,,setIncludepaths,,,0,void(ANY)
111669156002,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.setDefines:void(ANY),<empty>,,true,,,setDefines,,,0,void(ANY)
111669156003,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.setUndefines:void(ANY),<empty>,,true,,,setUndefines,,,0,void(ANY)
111669156004,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.setCheckPaths:void(ANY),<empty>,,true,,,setCheckPaths,,,0,void(ANY)
111669156005,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.setImportProject:void(ANY),<empty>,,true,,,setImportProject,,,0,void(ANY)
111669156006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setProjectConfigurations:<unresolvedSignature>(1),<empty>,,true,,,setProjectConfigurations,,,0,<unresolvedSignature>
111669156007,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getProjectConfigs:<unresolvedSignature>(1),<empty>,,true,,,getProjectConfigs,,,0,<unresolvedSignature>
111669156008,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.setExcludedPaths:void(ANY),<empty>,,true,,,setExcludedPaths,,,0,void(ANY)
111669156009,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.setLibraries:void(ANY),<empty>,,true,,,setLibraries,,,0,void(ANY)
111669156010,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.itemText:<unresolvedSignature>(1),<empty>,,true,,,itemText,,,0,<unresolvedSignature>
111669156011,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.setSuppressions:void(ANY),<empty>,,true,,,setSuppressions,,,0,void(ANY)
111669156012,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.updateAddonCheckBox:<unresolvedSignature>(4),<empty>,,true,,,updateAddonCheckBox,,,0,<unresolvedSignature>
111669156013,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isEnabled:<unresolvedSignature>(0),<empty>,,true,,,isEnabled,,,0,<unresolvedSignature>
111669156014,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getClangAnalyzer<const>:bool(),<empty>,,true,,,getClangAnalyzer,,,0,bool()
111669156015,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getClangTidy<const>:bool(),<empty>,,true,,,getClangTidy,,,0,bool()
111669156016,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getTags<const>:ANY(),<empty>,,true,,,getTags,,,0,ANY()
111669156017,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.setRootPath:void(ANY),<empty>,,true,,,setRootPath,,,0,void(ANY)
111669156018,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.getRootPath:ANY(),<empty>,,true,,,getRootPath,,,0,ANY()
111669156019,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.setBuildDir:void(ANY),<empty>,,true,,,setBuildDir,,,0,void(ANY)
111669156020,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.getBuildDir:ANY(),<empty>,,true,,,getBuildDir,,,0,ANY()
111669156021,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.setImportProject:void(ANY),<empty>,,true,,,setImportProject,,,0,void(ANY)
111669156022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.getImportProject:ANY(),<empty>,,true,,,getImportProject,,,0,ANY()
111669156023,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setAnalyzeAllVsConfigs:<unresolvedSignature>(1),<empty>,,true,,,setAnalyzeAllVsConfigs,,,0,<unresolvedSignature>
111669156024,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.setVSConfigurations:void(ANY),<empty>,,true,,,setVSConfigurations,,,0,void(ANY)
111669156025,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.getProjectConfigurations:ANY(),<empty>,,true,,,getProjectConfigurations,,,0,ANY()
111669156026,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setCheckHeaders:<unresolvedSignature>(1),<empty>,,true,,,setCheckHeaders,,,0,<unresolvedSignature>
111669156027,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setCheckUnusedTemplates:<unresolvedSignature>(1),<empty>,,true,,,setCheckUnusedTemplates,,,0,<unresolvedSignature>
111669156028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setInlineSuppression:<unresolvedSignature>(1),<empty>,,true,,,setInlineSuppression,,,0,<unresolvedSignature>
111669156029,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setMaxCtuDepth:<unresolvedSignature>(1),<empty>,,true,,,setMaxCtuDepth,,,0,<unresolvedSignature>
111669156030,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setMaxTemplateRecursion:<unresolvedSignature>(1),<empty>,,true,,,setMaxTemplateRecursion,,,0,<unresolvedSignature>
111669156031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.setIncludes:void(ANY),<empty>,,true,,,setIncludes,,,0,void(ANY)
111669156032,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.getIncludePaths:ANY(),<empty>,,true,,,getIncludePaths,,,0,ANY()
111669156033,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.setDefines:void(ANY),<empty>,,true,,,setDefines,,,0,void(ANY)
111669156034,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.getDefines:ANY(),<empty>,,true,,,getDefines,,,0,ANY()
111669156035,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.setUndefines:void(ANY),<empty>,,true,,,setUndefines,,,0,void(ANY)
111669156036,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.getUndefines:ANY(),<empty>,,true,,,getUndefines,,,0,ANY()
111669156037,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.setCheckPaths:void(ANY),<empty>,,true,,,setCheckPaths,,,0,void(ANY)
111669156038,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.getCheckPaths:ANY(),<empty>,,true,,,getCheckPaths,,,0,ANY()
111669156039,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.setExcludedPaths:void(ANY),<empty>,,true,,,setExcludedPaths,,,0,void(ANY)
111669156040,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.getExcludedPaths:ANY(),<empty>,,true,,,getExcludedPaths,,,0,ANY()
111669156041,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.setLibraries:void(ANY),<empty>,,true,,,setLibraries,,,0,void(ANY)
111669156042,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.getLibraries:ANY(),<empty>,,true,,,getLibraries,,,0,ANY()
111669156043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setPlatform:<unresolvedSignature>(1),<empty>,,true,,,setPlatform,,,0,<unresolvedSignature>
111669156044,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.getSuppressions:ANY(),<empty>,,true,,,getSuppressions,,,0,ANY()
111669156045,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.setAddons:void(ANY),<empty>,,true,,,setAddons,,,0,void(ANY)
111669156046,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setCodingStandards:<unresolvedSignature>(1),<empty>,,true,,,setCodingStandards,,,0,<unresolvedSignature>
111669156047,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setCertIntPrecision:<unresolvedSignature>(1),<empty>,,true,,,setCertIntPrecision,,,0,<unresolvedSignature>
111669156048,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setBughunting:<unresolvedSignature>(1),<empty>,,true,,,setBughunting,,,0,<unresolvedSignature>
111669156049,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setClangAnalyzer:<unresolvedSignature>(1),<empty>,,true,,,setClangAnalyzer,,,0,<unresolvedSignature>
111669156050,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setClangTidy:<unresolvedSignature>(1),<empty>,,true,,,setClangTidy,,,0,<unresolvedSignature>
111669156051,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setLicenseFile:<unresolvedSignature>(1),<empty>,,true,,,setLicenseFile,,,0,<unresolvedSignature>
111669156052,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setTags:<unresolvedSignature>(1),<empty>,,true,,,setTags,,,0,<unresolvedSignature>
111669156053,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.split:<unresolvedSignature>(2),<empty>,,true,,,split,,,0,<unresolvedSignature>
111669156054,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.saveToProjectFile:void(ProjectFile*),<empty>,,true,,,saveToProjectFile,,,0,void(ProjectFile*)
111669156055,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getExistingDirectory:<unresolvedSignature>(2),<empty>,,true,,,getExistingDirectory,,,0,<unresolvedSignature>
111669156056,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.setProjectConfigurations:void(ANY),<empty>,,true,,,setProjectConfigurations,,,0,void(ANY)
111669156057,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.getProjectConfigs:ANY(ANY),<empty>,,true,,,getProjectConfigs,,,0,ANY(ANY)
111669156058,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.checkState:<unresolvedSignature>(0),<empty>,,true,,,checkState,,,0,<unresolvedSignature>
111669156059,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getPaths:<unresolvedSignature>(1),<empty>,,true,,,getPaths,,,0,<unresolvedSignature>
111669156060,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.addIncludeDir:void(ANY),<empty>,,true,,,addIncludeDir,,,0,void(ANY)
111669156061,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.addCheckPath:void(ANY),<empty>,,true,,,addCheckPath,,,0,void(ANY)
111669156062,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFileDialog.addExcludePath:void(ANY),<empty>,,true,,,addExcludePath,,,0,void(ANY)
111669156063,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SuppressionList.Suppression.getText<const>:ANY(),<empty>,,true,,,getText,,,0,ANY()
111669156064,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.currentItem:<unresolvedSignature>(0),<empty>,,true,,,currentItem,,,0,<unresolvedSignature>
111669156065,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.editItem:<unresolvedSignature>(1),<empty>,,true,,,editItem,,,0,<unresolvedSignature>
111669156066,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.currentRow:<unresolvedSignature>(0),<empty>,,true,,,currentRow,,,0,<unresolvedSignature>
111669156067,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.takeItem:<unresolvedSignature>(1),<empty>,,true,,,takeItem,,,0,<unresolvedSignature>
111669156068,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addExcludePath:<unresolvedSignature>(1),<empty>,,true,,,addExcludePath,,,0,<unresolvedSignature>
111669156069,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.insertItem:<unresolvedSignature>(2),<empty>,,true,,,insertItem,,,0,<unresolvedSignature>
111669156070,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setCurrentItem:<unresolvedSignature>(1),<empty>,,true,,,setCurrentItem,,,0,<unresolvedSignature>
111669156071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getSuppressionIndex:<unresolvedSignature>(1),<empty>,,true,,,getSuppressionIndex,,,0,<unresolvedSignature>
111669156072,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setSuppression:<unresolvedSignature>(1),<empty>,,true,,,setSuppression,,,0,<unresolvedSignature>
111669156073,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.distance:<unresolvedSignature>(2),<empty>,,true,,,distance,,,0,<unresolvedSignature>
111669156074,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isOpen:<unresolvedSignature>(0),<empty>,,true,,,isOpen,,,0,<unresolvedSignature>
111669156075,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getGuideline:<unresolvedSignature>(4),<empty>,,true,,,getGuideline,,,0,<unresolvedSignature>
111669156076,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getClassification:<unresolvedSignature>(2),<empty>,,true,,,getClassification,,,0,<unresolvedSignature>
111669156077,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,QStringList,<empty>,,true,,,QStringList,,,0,
111669156078,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setModel:<unresolvedSignature>(1),<empty>,,true,,,setModel,,,0,<unresolvedSignature>
111669156079,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setExpandsOnDoubleClick:<unresolvedSignature>(1),<empty>,,true,,,setExpandsOnDoubleClick,,,0,<unresolvedSignature>
111669156080,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setSortingEnabled:<unresolvedSignature>(1),<empty>,,true,,,setSortingEnabled,,,0,<unresolvedSignature>
111669156081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.key:<unresolvedSignature>(0),<empty>,,true,,,key,,,0,<unresolvedSignature>
111669156082,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.quickStartApplication:<unresolvedSignature>(1),<empty>,,true,,,quickStartApplication,,,0,<unresolvedSignature>
111669156083,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.keyPressEvent:<unresolvedSignature>(1),<empty>,,true,,,keyPressEvent,,,0,<unresolvedSignature>
111669156084,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,createGuidelineMapping:ANY(ReportType),<empty>,,true,,,createGuidelineMapping,,,0,ANY(ReportType)
111669156085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.rowCount:<unresolvedSignature>(0),<empty>,,true,,,rowCount,,,0,<unresolvedSignature>
111669156086,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.item:<unresolvedSignature>(2),<empty>,,true,,,item,,,0,<unresolvedSignature>
111669156087,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.toMap:<unresolvedSignature>(0),<empty>,,true,,,toMap,,,0,<unresolvedSignature>
111669156088,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.child:<unresolvedSignature>(2),<empty>,,true,,,child,,,0,<unresolvedSignature>
111669156089,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ShowTypeToSeverity:<unresolvedSignature>(1),<empty>,,true,,,ShowTypeToSeverity,,,0,<unresolvedSignature>
111669156090,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.VariantToShowType:<unresolvedSignature>(1),<empty>,,true,,,VariantToShowType,,,0,<unresolvedSignature>
111669156091,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getGuideline:ANY(ReportType,ANY,ANY,Severity)",<empty>,,true,,,getGuideline,,,0,"ANY(ReportType,ANY,ANY,Severity)"
111669156092,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getClassification:ANY(ReportType,ANY)",<empty>,,true,,,getClassification,,,0,"ANY(ReportType,ANY)"
111669156093,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ResultsTree.isAutosarMisraReport:bool(),<empty>,,true,,,isAutosarMisraReport,,,0,bool()
111669156094,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.showColumn:<unresolvedSignature>(1),<empty>,,true,,,showColumn,,,0,<unresolvedSignature>
111669156095,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hideColumn:<unresolvedSignature>(1),<empty>,,true,,,hideColumn,,,0,<unresolvedSignature>
111669156096,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ResultsTree.isCertReport:bool(),<empty>,,true,,,isCertReport,,,0,bool()
111669156097,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setData:<unresolvedSignature>(2),<empty>,,true,,,setData,,,0,<unresolvedSignature>
111669156098,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setEditable:<unresolvedSignature>(1),<empty>,,true,,,setEditable,,,0,<unresolvedSignature>
111669156099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setTextAlignment:<unresolvedSignature>(1),<empty>,,true,,,setTextAlignment,,,0,<unresolvedSignature>
111669156100,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ResultsTree.stripPath:ANY(ANY,bool)",<empty>,,true,,,stripPath,,,0,"ANY(ANY,bool)"
111669156101,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isShown:<unresolvedSignature>(1),<empty>,,true,,,isShown,,,0,<unresolvedSignature>
111669156102,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getSeverityFromClassification:Severity(ANY),<empty>,,true,,,getSeverityFromClassification,,,0,Severity(ANY)
111669156103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ProjectFile.getActiveProject:ProjectFile*(),<empty>,,true,,,getActiveProject,,,0,ProjectFile*()
111669156104,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getWarningTags:<unresolvedSignature>(1),<empty>,,true,,,getWarningTags,,,0,<unresolvedSignature>
111669156105,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ensureFileItem:<unresolvedSignature>(3),<empty>,,true,,,ensureFileItem,,,0,<unresolvedSignature>
111669156106,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ResultsTree.addBacktraceFiles:ANY(ANY,ErrorLine&,bool,ANY,bool)",<empty>,,true,,,addBacktraceFiles,,,0,"ANY(ANY,ErrorLine&,bool,ANY,bool)"
111669156107,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ResultsTree.severityToIcon:ANY(Severity),<empty>,,true,,,severityToIcon,,,0,ANY(Severity)
111669156108,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.SeverityToShowType:<unresolvedSignature>(1),<empty>,,true,,,SeverityToShowType,,,0,<unresolvedSignature>
111669156109,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.stripPath:<unresolvedSignature>(2),<empty>,,true,,,stripPath,,,0,<unresolvedSignature>
111669156110,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addBacktraceFiles:<unresolvedSignature>(5),<empty>,,true,,,addBacktraceFiles,,,0,<unresolvedSignature>
111669156111,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ResultsTree.severityToTranslatedString:ANY(Severity),<empty>,,true,,,severityToTranslatedString,,,0,ANY(Severity)
111669156112,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ResultsTree.createNormalItem:ANY(ANY),<empty>,,true,,,createNormalItem,,,0,ANY(ANY)
111669156113,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.createNormalItem:<unresolvedSignature>(1),<empty>,,true,,,createNormalItem,,,0,<unresolvedSignature>
111669156114,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ResultsTree.createCheckboxItem:ANY(bool),<empty>,,true,,,createCheckboxItem,,,0,ANY(bool)
111669156115,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.createLineNumberItem:<unresolvedSignature>(1),<empty>,,true,,,createLineNumberItem,,,0,<unresolvedSignature>
111669156116,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getLabels:ANY(),<empty>,,true,,,getLabels,,,0,ANY()
111669156117,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.appendRow:<unresolvedSignature>(1),<empty>,,true,,,appendRow,,,0,<unresolvedSignature>
111669156118,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setRowHidden:<unresolvedSignature>(3),<empty>,,true,,,setRowHidden,,,0,<unresolvedSignature>
111669156119,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.index:<unresolvedSignature>(0),<empty>,,true,,,index,,,0,<unresolvedSignature>
111669156120,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.removeRows:<unresolvedSignature>(2),<empty>,,true,,,removeRows,,,0,<unresolvedSignature>
111669156121,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.removeRow:<unresolvedSignature>(1),<empty>,,true,,,removeRow,,,0,<unresolvedSignature>
111669156122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.columnCount:<unresolvedSignature>(0),<empty>,,true,,,columnCount,,,0,<unresolvedSignature>
111669156123,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:46:46:SETTINGS_RESULT_COLUMN_WIDTH:0,<empty>,,true,46,46,SETTINGS_RESULT_COLUMN_WIDTH,,,0,
111669156124,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setColumnWidth:<unresolvedSignature>(2),<empty>,,true,,,setColumnWidth,,,0,<unresolvedSignature>
111669156125,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:76:76:SETTINGS_SAVE_FULL_PATH:0,<empty>,,true,76,76,SETTINGS_SAVE_FULL_PATH,,,0,
111669156126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:75:75:SETTINGS_SAVE_ALL_ERRORS:0,<empty>,,true,75,75,SETTINGS_SAVE_ALL_ERRORS,,,0,
111669156127,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:72:72:SETTINGS_SHOW_FULL_PATH:0,<empty>,,true,72,72,SETTINGS_SHOW_FULL_PATH,,,0,
111669156128,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.showIdColumn:<unresolvedSignature>(1),<empty>,,true,,,showIdColumn,,,0,<unresolvedSignature>
111669156129,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:90:90:SETTINGS_SHOW_ERROR_ID:0,<empty>,,true,90,90,SETTINGS_SHOW_ERROR_ID,,,0,
111669156130,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.showInconclusiveColumn:<unresolvedSignature>(1),<empty>,,true,,,showInconclusiveColumn,,,0,<unresolvedSignature>
111669156131,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.columnWidth:<unresolvedSignature>(1),<empty>,,true,,,columnWidth,,,0,<unresolvedSignature>
111669156132,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ShowTypes.VariantToShowType:ShowTypes.ShowType(ANY),<empty>,,true,,,VariantToShowType,,,0,ShowTypes.ShowType(ANY)
111669156133,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QModelIndex:<unresolvedSignature>(0),<empty>,,true,,,QModelIndex,,,0,<unresolvedSignature>
111669156134,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findFileItem:<unresolvedSignature>(1),<empty>,,true,,,findFileItem,,,0,<unresolvedSignature>
111669156135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.row:<unresolvedSignature>(0),<empty>,,true,,,row,,,0,<unresolvedSignature>
111669156136,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ResultsTree.tagSelectedItems:void(ANY),<empty>,,true,,,tagSelectedItems,,,0,void(ANY)
111669156137,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.indexAt:<unresolvedSignature>(1),<empty>,,true,,,indexAt,,,0,<unresolvedSignature>
111669156138,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.pos:<unresolvedSignature>(0),<empty>,,true,,,pos,,,0,<unresolvedSignature>
111669156139,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.selectionModel:<unresolvedSignature>(0),<empty>,,true,,,selectionModel,,,0,<unresolvedSignature>
111669156140,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.selectedRows:<unresolvedSignature>(0),<empty>,,true,,,selectedRows,,,0,<unresolvedSignature>
111669156141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.itemFromIndex:<unresolvedSignature>(1),<empty>,,true,,,itemFromIndex,,,0,<unresolvedSignature>
111669156142,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.parent:<unresolvedSignature>(0),<empty>,,true,,,parent,,,0,<unresolvedSignature>
111669156143,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setDisabled:<unresolvedSignature>(1),<empty>,,true,,,setDisabled,,,0,<unresolvedSignature>
111669156144,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addAction:<unresolvedSignature>(1),<empty>,,true,,,addAction,,,0,<unresolvedSignature>
111669156145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.of:<unresolvedSignature>(1),<empty>,,true,,,of,,,0,<unresolvedSignature>
111669156146,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setMapping:<unresolvedSignature>(2),<empty>,,true,,,setMapping,,,0,<unresolvedSignature>
111669156147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addSeparator:<unresolvedSignature>(0),<empty>,,true,,,addSeparator,,,0,<unresolvedSignature>
111669156148,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addMenu:<unresolvedSignature>(1),<empty>,,true,,,addMenu,,,0,<unresolvedSignature>
111669156149,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.connect:<unresolvedSignature>(3),<empty>,,true,,,connect,,,0,<unresolvedSignature>
111669156150,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.exec:<unresolvedSignature>(1),<empty>,,true,,,exec,,,0,<unresolvedSignature>
111669156151,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.globalPos:<unresolvedSignature>(0),<empty>,,true,,,globalPos,,,0,<unresolvedSignature>
111669156152,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.column:<unresolvedSignature>(0),<empty>,,true,,,column,,,0,<unresolvedSignature>
111669156153,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ResultsTree.askFileDir:ANY(ANY),<empty>,,true,,,askFileDir,,,0,ANY(ANY)
111669156154,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.startDetached:<unresolvedSignature>(2),<empty>,,true,,,startDetached,,,0,<unresolvedSignature>
111669156155,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.splitCommand:<unresolvedSignature>(1),<empty>,,true,,,splitCommand,,,0,<unresolvedSignature>
111669156156,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getExistingDirectory:<unresolvedSignature>(4),<empty>,,true,,,getExistingDirectory,,,0,<unresolvedSignature>
111669156157,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:104:104:SETTINGS_LAST_SOURCE_PATH:0,<empty>,,true,104,104,SETTINGS_LAST_SOURCE_PATH,,,0,
111669156158,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,severityToString:ANY(Severity),<empty>,,true,,,severityToString,,,0,ANY(Severity)
111669156159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.clipboard:<unresolvedSignature>(0),<empty>,,true,,,clipboard,,,0,<unresolvedSignature>
111669156160,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isHeader:<unresolvedSignature>(1),<empty>,,true,,,isHeader,,,0,<unresolvedSignature>
111669156161,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ResultsTree.getFilePath:ANY(ANY,bool)",<empty>,,true,,,getFilePath,,,0,"ANY(ANY,bool)"
111669156162,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.openUrl:<unresolvedSignature>(1),<empty>,,true,,,openUrl,,,0,<unresolvedSignature>
111669156163,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fromLocalFile:<unresolvedSignature>(1),<empty>,,true,,,fromLocalFile,,,0,<unresolvedSignature>
111669156164,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setWarningTags:<unresolvedSignature>(2),<empty>,,true,,,setWarningTags,,,0,<unresolvedSignature>
111669156165,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ResultsTree.startApplication:void(ANY,int)",<empty>,,true,,,startApplication,,,0,"void(ANY,int)"
111669156166,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.startApplication:<unresolvedSignature>(1),<empty>,,true,,,startApplication,,,0,<unresolvedSignature>
111669156167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Report.writeHeader:void(),<empty>,,true,,,writeHeader,,,0,void()
111669156168,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isRowHidden:<unresolvedSignature>(2),<empty>,,true,,,isRowHidden,,,0,<unresolvedSignature>
111669156169,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.saveErrors:<unresolvedSignature>(2),<empty>,,true,,,saveErrors,,,0,<unresolvedSignature>
111669156170,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Report.writeFooter:void(),<empty>,,true,,,writeFooter,,,0,void()
111669156171,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.readErrorItem:<unresolvedSignature>(2),<empty>,,true,,,readErrorItem,,,0,<unresolvedSignature>
111669156172,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Report.writeError:void(ANY),<empty>,,true,,,writeError,,,0,void(ANY)
111669156173,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sameCID:<unresolvedSignature>(2),<empty>,,true,,,sameCID,,,0,<unresolvedSignature>
111669156174,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,XmlReportV2.read:ANY(),<empty>,,true,,,read,,,0,ANY()
111669156175,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,XmlReportV2.close:void(),<empty>,,true,,,close,,,0,void()
111669156176,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.toString:<unresolvedSignature>(2),<empty>,,true,,,toString,,,0,<unresolvedSignature>
111669156177,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.system:<unresolvedSignature>(0),<empty>,,true,,,system,,,0,<unresolvedSignature>
111669156178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.currentDate:<unresolvedSignature>(0),<empty>,,true,,,currentDate,,,0,<unresolvedSignature>
111669156179,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasChildren:<unresolvedSignature>(0),<empty>,,true,,,hasChildren,,,0,<unresolvedSignature>
111669156180,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.qDebug:<unresolvedSignature>(1),<empty>,,true,,,qDebug,,,0,<unresolvedSignature>
111669156181,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.refreshFilePaths:<unresolvedSignature>(1),<empty>,,true,,,refreshFilePaths,,,0,<unresolvedSignature>
111669156182,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setHorizontalHeaderLabels:<unresolvedSignature>(1),<empty>,,true,,,setHorizontalHeaderLabels,,,0,<unresolvedSignature>
111669156183,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.currentChanged:<unresolvedSignature>(2),<empty>,,true,,,currentChanged,,,0,<unresolvedSignature>
111669156184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setContextMenuPolicy:<unresolvedSignature>(1),<empty>,,true,,,setContextMenuPolicy,,,0,<unresolvedSignature>
111669156185,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setMinimum:<unresolvedSignature>(1),<empty>,,true,,,setMinimum,,,0,<unresolvedSignature>
111669156186,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setStyle:<unresolvedSignature>(1),<empty>,,true,,,setStyle,,,0,<unresolvedSignature>
111669156187,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.toByteArray:<unresolvedSignature>(0),<empty>,,true,,,toByteArray,,,0,<unresolvedSignature>
111669156188,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:39:39:SETTINGS_MAINWND_SPLITTER_STATE:0,<empty>,,true,39,39,SETTINGS_MAINWND_SPLITTER_STATE,,,0,
111669156189,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.restoreState:<unresolvedSignature>(1),<empty>,,true,,,restoreState,,,0,<unresolvedSignature>
111669156190,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:73:73:SETTINGS_SHOW_NO_ERRORS:0,<empty>,,true,73,73,SETTINGS_SHOW_NO_ERRORS,,,0,
111669156191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setMaximum:<unresolvedSignature>(1),<empty>,,true,,,setMaximum,,,0,<unresolvedSignature>
111669156192,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:97:97:PROGRESS_MAX:0,<empty>,,true,97,97,PROGRESS_MAX,,,0,
111669156193,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setFormat:<unresolvedSignature>(1),<empty>,,true,,,setFormat,,,0,<unresolvedSignature>
111669156194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addChecker:<unresolvedSignature>(1),<empty>,,true,,,addChecker,,,0,<unresolvedSignature>
111669156195,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.handleCriticalError:<unresolvedSignature>(1),<empty>,,true,,,handleCriticalError,,,0,<unresolvedSignature>
111669156196,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addErrorItem:<unresolvedSignature>(1),<empty>,,true,,,addErrorItem,,,0,<unresolvedSignature>
111669156197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.tool:<unresolvedSignature>(0),<empty>,,true,,,tool,,,0,<unresolvedSignature>
111669156198,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.currentMSecsSinceEpoch:<unresolvedSignature>(0),<empty>,,true,,,currentMSecsSinceEpoch,,,0,<unresolvedSignature>
111669156199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckStatistics.getTools<const>:ANY(),<empty>,,true,,,getTools,,,0,ANY()
111669156200,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckStatistics.getCount<const>:unsigned int(ANY,ShowTypes.ShowType)",<empty>,,true,,,getCount,,,0,"unsigned int(ANY,ShowTypes.ShowType)"
111669156201,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.saveResults:<unresolvedSignature>(1),<empty>,,true,,,saveResults,,,0,<unresolvedSignature>
111669156202,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ResultsView.print:void(QPrinter*),<empty>,,true,,,print,,,0,void(QPrinter*)
111669156203,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ResultsView.hasResults:bool(),<empty>,,true,,,hasResults,,,0,bool()
111669156204,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.print:<unresolvedSignature>(1),<empty>,,true,,,print,,,0,<unresolvedSignature>
111669156205,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.updateSettings:<unresolvedSignature>(5),<empty>,,true,,,updateSettings,,,0,<unresolvedSignature>
111669156206,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckStatistics.getActiveCheckers<const>:ANY(),<empty>,,true,,,getActiveCheckers,,,0,ANY()
111669156207,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setCheckersReport:<unresolvedSignature>(1),<empty>,,true,,,setCheckersReport,,,0,<unresolvedSignature>
111669156208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getReport:<unresolvedSignature>(1),<empty>,,true,,,getReport,,,0,<unresolvedSignature>
111669156209,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.refreshTree:<unresolvedSignature>(0),<empty>,,true,,,refreshTree,,,0,<unresolvedSignature>
111669156210,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.saveSettings:<unresolvedSignature>(0),<empty>,,true,,,saveSettings,,,0,<unresolvedSignature>
111669156211,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.saveState:<unresolvedSignature>(0),<empty>,,true,,,saveState,,,0,<unresolvedSignature>
111669156212,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,XmlReport.determineVersion:int(ANY),<empty>,,true,,,determineVersion,,,0,int(ANY)
111669156213,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.qobject_cast<const QStandardItemModel*>:<unresolvedSignature>(1),<empty>,,true,,,qobject_cast<const QStandardItemModel*>,,,0,<unresolvedSignature>
111669156214,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.model:<unresolvedSignature>(0),<empty>,,true,,,model,,,0,<unresolvedSignature>
111669156215,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.showIdColumn:<unresolvedSignature>(0),<empty>,,true,,,showIdColumn,,,0,<unresolvedSignature>
111669156216,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getFileName:<unresolvedSignature>(0),<empty>,,true,,,getFileName,,,0,<unresolvedSignature>
111669156217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setError:<unresolvedSignature>(2),<empty>,,true,,,setError,,,0,<unresolvedSignature>
111669156218,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setError:<unresolvedSignature>(3),<empty>,,true,,,setError,,,0,<unresolvedSignature>
111669156219,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.mapToGlobal:<unresolvedSignature>(1),<empty>,,true,,,mapToGlobal,,,0,<unresolvedSignature>
111669156220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addAction:<unresolvedSignature>(3),<empty>,,true,,,addAction,,,0,<unresolvedSignature>
111669156221,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.analyzeCode:<unresolvedSignature>(2),<empty>,,true,,,analyzeCode,,,0,<unresolvedSignature>
111669156222,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.boolToCheckState:<unresolvedSignature>(1),<empty>,,true,,,boolToCheckState,,,0,<unresolvedSignature>
111669156223,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.textEdited:<unresolvedSignature>(1),<empty>,,true,,,textEdited,,,0,<unresolvedSignature>
111669156224,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.released:<unresolvedSignature>(0),<empty>,,true,,,released,,,0,<unresolvedSignature>
111669156225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.idealThreadCount:<unresolvedSignature>(0),<empty>,,true,,,idealThreadCount,,,0,<unresolvedSignature>
111669156226,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SettingsDialog.saveSettings:void(),<empty>,,true,,,saveSettings,,,0,void()
111669156227,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TranslationHandler.getCurrentLanguage<const>:QString&(),<empty>,,true,,,getCurrentLanguage,,,0,QString&()
111669156228,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TranslationHandler.getTranslations<const>:ANY(),<empty>,,true,,,getTranslations,,,0,ANY()
111669156229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:40:40:SETTINGS_CHECK_DIALOG_WIDTH:0,<empty>,,true,40,40,SETTINGS_CHECK_DIALOG_WIDTH,,,0,
111669156230,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,gui/common.h,gui/common.h:41:41:SETTINGS_CHECK_DIALOG_HEIGHT:0,<empty>,,true,41,41,SETTINGS_CHECK_DIALOG_HEIGHT,,,0,
111669156231,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.saveCheckboxValue:<unresolvedSignature>(3),<empty>,,true,,,saveCheckboxValue,,,0,<unresolvedSignature>
111669156232,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.data:<unresolvedSignature>(1),<empty>,,true,,,data,,,0,<unresolvedSignature>
111669156233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.checkStateToBool:<unresolvedSignature>(1),<empty>,,true,,,checkStateToBool,,,0,<unresolvedSignature>
111669156234,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setCurrentRow:<unresolvedSignature>(1),<empty>,,true,,,setCurrentRow,,,0,<unresolvedSignature>
111669156235,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getOpenFileName:<unresolvedSignature>(3),<empty>,,true,,,getOpenFileName,,,0,<unresolvedSignature>
111669156236,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.rootPath:<unresolvedSignature>(0),<empty>,,true,,,rootPath,,,0,<unresolvedSignature>
111669156237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ShowTypes.save:void(),<empty>,,true,,,save,,,0,void()
111669156238,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ShowTypes.isShown:bool(ShowTypes.ShowType),<empty>,,true,,,isShown,,,0,bool(ShowTypes.ShowType)
111669156239,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setWindowFlags:<unresolvedSignature>(1),<empty>,,true,,,setWindowFlags,,,0,<unresolvedSignature>
111669156240,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setOutputFormat:<unresolvedSignature>(1),<empty>,,true,,,setOutputFormat,,,0,<unresolvedSignature>
111669156241,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setPageSize:<unresolvedSignature>(1),<empty>,,true,,,setPageSize,,,0,<unresolvedSignature>
111669156242,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QPageSize:<unresolvedSignature>(1),<empty>,,true,,,QPageSize,,,0,<unresolvedSignature>
111669156243,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setOutputFileName:<unresolvedSignature>(1),<empty>,,true,,,setOutputFileName,,,0,<unresolvedSignature>
111669156244,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setHtml:<unresolvedSignature>(1),<empty>,,true,,,setHtml,,,0,<unresolvedSignature>
111669156245,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setMimeData:<unresolvedSignature>(1),<empty>,,true,,,setMimeData,,,0,<unresolvedSignature>
111669156246,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckStatistics.getNumberOfActiveCheckers<const>:int(),<empty>,,true,,,getNumberOfActiveCheckers,,,0,int()
111669156247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckStatistics.getCheckersReport<const>:ANY(),<empty>,,true,,,getCheckersReport,,,0,ANY()
111669156248,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThreadResult.setFiles:void(ANY),<empty>,,true,,,setFiles,,,0,void(ANY)
111669156249,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ThreadHandler.getReCheckFiles:ANY(bool),<empty>,,true,,,getReCheckFiles,,,0,ANY(bool)
111669156250,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setAddonsAndTools:<unresolvedSignature>(1),<empty>,,true,,,setAddonsAndTools,,,0,<unresolvedSignature>
111669156251,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setSuppressions:<unresolvedSignature>(1),<empty>,,true,,,setSuppressions,,,0,<unresolvedSignature>
111669156252,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setSettings:<unresolvedSignature>(2),<empty>,,true,,,setSettings,,,0,<unresolvedSignature>
111669156253,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.currentDateTime:<unresolvedSignature>(0),<empty>,,true,,,currentDateTime,,,0,<unresolvedSignature>
111669156254,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isRunning:<unresolvedSignature>(0),<empty>,,true,,,isRunning,,,0,<unresolvedSignature>
111669156255,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.terminate:<unresolvedSignature>(0),<empty>,,true,,,terminate,,,0,<unresolvedSignature>
111669156256,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.wait:<unresolvedSignature>(0),<empty>,,true,,,wait,,,0,<unresolvedSignature>
111669156257,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.disconnect:<unresolvedSignature>(4),<empty>,,true,,,disconnect,,,0,<unresolvedSignature>
111669156258,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.analyseWholeProgram:<unresolvedSignature>(2),<empty>,,true,,,analyseWholeProgram,,,0,<unresolvedSignature>
111669156259,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.elapsed:<unresolvedSignature>(0),<empty>,,true,,,elapsed,,,0,<unresolvedSignature>
111669156260,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QDateTime:<unresolvedSignature>(0),<empty>,,true,,,QDateTime,,,0,<unresolvedSignature>
111669156261,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setThreadCount:<unresolvedSignature>(1),<empty>,,true,,,setThreadCount,,,0,<unresolvedSignature>
111669156262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.needsReCheck:<unresolvedSignature>(3),<empty>,,true,,,needsReCheck,,,0,<unresolvedSignature>
111669156263,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.lastModified:<unresolvedSignature>(0),<empty>,,true,,,lastModified,,,0,<unresolvedSignature>
111669156264,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ThreadHandler.needsReCheck:bool(ANY,ANY,ANY)",<empty>,,true,,,needsReCheck,,,0,"bool(ANY,ANY,ANY)"
111669156265,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.locker:<unresolvedSignature>(1),<empty>,,true,,,locker,,,0,<unresolvedSignature>
111669156266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.takeFirst:<unresolvedSignature>(0),<empty>,,true,,,takeFirst,,,0,<unresolvedSignature>
111669156267,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,quint64,<empty>,,true,,,quint64,,,0,
111669156268,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Q_UNUSED:<unresolvedSignature>(1),<empty>,,true,,,Q_UNUSED,,,0,<unresolvedSignature>
111669156269,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QT_TRANSLATE_NOOP:<unresolvedSignature>(2),<empty>,,true,,,QT_TRANSLATE_NOOP,,,0,<unresolvedSignature>
111669156270,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.removeTranslator:<unresolvedSignature>(1),<empty>,,true,,,removeTranslator,,,0,<unresolvedSignature>
111669156271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TranslationHandler.getLanguageIndexByCode:int(ANY),<empty>,,true,,,getLanguageIndexByCode,,,0,int(ANY)
111669156272,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.load:<unresolvedSignature>(1),<empty>,,true,,,load,,,0,<unresolvedSignature>
111669156273,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.installTranslator:<unresolvedSignature>(1),<empty>,,true,,,installTranslator,,,0,<unresolvedSignature>
111669156274,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getNameAndVersion:<unresolvedSignature>(1),<empty>,,true,,,getNameAndVersion,,,0,<unresolvedSignature>
111669156275,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.writeStartDocument:<unresolvedSignature>(0),<empty>,,true,,,writeStartDocument,,,0,<unresolvedSignature>
111669156276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,XmlReport.quoteMessage:ANY(ANY),<empty>,,true,,,quoteMessage,,,0,ANY(ANY)
111669156277,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.quoteMessage:<unresolvedSignature>(1),<empty>,,true,,,quoteMessage,,,0,<unresolvedSignature>
111669156278,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fromString:<unresolvedSignature>(1),<empty>,,true,,,fromString,,,0,<unresolvedSignature>
111669156279,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,XmlReport.unquoteMessage:ANY(ANY),<empty>,,true,,,unquoteMessage,,,0,ANY(ANY)
111669156280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.unquoteMessage:<unresolvedSignature>(1),<empty>,,true,,,unquoteMessage,,,0,<unresolvedSignature>
111669156281,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.push_front:<unresolvedSignature>(1),<empty>,,true,,,push_front,,,0,<unresolvedSignature>
111669156282,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Path.isFile:bool(ANY),<empty>,,true,,,isFile,,,0,bool(ANY)
111669156283,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.get_last_error:<unresolvedSignature>(0),<empty>,,true,,,get_last_error,,,0,<unresolvedSignature>
111669156284,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.is<picojson::object>:<unresolvedSignature>(0),<empty>,,true,,,is<picojson::object>,,,0,<unresolvedSignature>
111669156285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.get<picojson::object>:<unresolvedSignature>(0),<empty>,,true,,,get<picojson::object>,,,0,<unresolvedSignature>
111669156286,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.is<picojson::array>:<unresolvedSignature>(0),<empty>,,true,,,is<picojson::array>,,,0,<unresolvedSignature>
111669156287,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.get<picojson::array>:<unresolvedSignature>(0),<empty>,,true,,,get<picojson::array>,,,0,<unresolvedSignature>
111669156288,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.is<std::string>:<unresolvedSignature>(0),<empty>,,true,,,is<std::string>,,,0,<unresolvedSignature>
111669156289,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.get<std::string>:<unresolvedSignature>(0),<empty>,,true,,,get<std::string>,,,0,<unresolvedSignature>
111669156290,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.is<bool>:<unresolvedSignature>(0),<empty>,,true,,,is<bool>,,,0,<unresolvedSignature>
111669156291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.get<bool>:<unresolvedSignature>(0),<empty>,,true,,,get<bool>,,,0,<unresolvedSignature>
111669156292,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getFullPath:ANY(ANY,ANY,bool)",<empty>,,true,,,getFullPath,,,0,"ANY(ANY,ANY,bool)"
111669156293,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getAddonInfo:<unresolvedSignature>(2),<empty>,,true,,,getAddonInfo,,,0,<unresolvedSignature>
111669156294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.parse:<unresolvedSignature>(2),<empty>,,true,,,parse,,,0,<unresolvedSignature>
111669156295,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"parseAddonInfo:ANY(AddonInfo&,ANY,ANY,ANY)",<empty>,,true,,,parseAddonInfo,,,0,"ANY(AddonInfo&,ANY,ANY,ANY)"
111669156296,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.rfind:<unresolvedSignature>(1),<empty>,,true,,,rfind,,,0,<unresolvedSignature>
111669156297,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getFullPath:<unresolvedSignature>(2),<empty>,,true,,,getFullPath,,,0,<unresolvedSignature>
111669156298,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getFilename:ANY(ANY),<empty>,,true,,,getFilename,,,0,ANY(ANY)
111669156299,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Path.simplifyPath:ANY(ANY),<empty>,,true,,,simplifyPath,,,0,ANY(ANY)
111669156300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.LoadFile:<unresolvedSignature>(1),<empty>,,true,,,LoadFile,,,0,<unresolvedSignature>
111669156301,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.FirstChildElement:<unresolvedSignature>(0),<empty>,,true,,,FirstChildElement,,,0,<unresolvedSignature>
111669156302,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Attribute:<unresolvedSignature>(1),<empty>,,true,,,Attribute,,,0,<unresolvedSignature>
111669156303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.NextSiblingElement:<unresolvedSignature>(0),<empty>,,true,,,NextSiblingElement,,,0,<unresolvedSignature>
111669156304,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Name:<unresolvedSignature>(0),<empty>,,true,,,Name,,,0,<unresolvedSignature>
111669156305,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.endsWith:<unresolvedSignature>(3),<empty>,,true,,,endsWith,,,0,<unresolvedSignature>
111669156306,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.join:<unresolvedSignature>(2),<empty>,,true,,,join,,,0,<unresolvedSignature>
111669156307,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"AnalyzerInformation.getAnalyzerInfoFileFromFilesTxt:ANY(ANY,ANY,ANY)",<empty>,,true,,,getAnalyzerInfoFileFromFilesTxt,,,0,"ANY(ANY,ANY,ANY)"
111669156308,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Path.join:ANY(ANY,ANY)",<empty>,,true,,,join,,,0,"ANY(ANY,ANY)"
111669156309,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"skipAnalysis:bool(ANY,ANY,ANY)",<empty>,,true,,,skipAnalysis,,,0,"bool(ANY,ANY,ANY)"
111669156310,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.next<const>:Token*(),<empty>,,true,,,next,,,0,Token*()
111669156311,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.exprId<const>:int(),<empty>,,true,,,exprId,,,0,int()
111669156312,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.pred:<unresolvedSignature>(1),<empty>,,true,,,pred,,,0,<unresolvedSignature>
111669156313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.str<const>:ANY(),<empty>,,true,,,str,,,0,ANY()
111669156314,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.astOperand1<const>:Token*(),<empty>,,true,,,astOperand1,,,0,Token*()
111669156315,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.astOperand2<const>:Token*(),<empty>,,true,,,astOperand2,,,0,Token*()
111669156316,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.Match:bool(Token*,char*,int)",<empty>,,true,,,Match,,,0,"bool(Token*,char*,int)"
111669156317,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.link<const>:Token*(),<empty>,,true,,,link,,,0,Token*()
111669156318,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strcmp:ANY(),<empty>,,true,,,strcmp,,,0,ANY()
111669156319,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,astFlattenCopy:ANY(),<empty>,,true,,,astFlattenCopy,,,0,ANY()
111669156320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.astOperand1:<unresolvedSignature>(0),<empty>,,true,,,astOperand1,,,0,<unresolvedSignature>
111669156321,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.astOperand2:<unresolvedSignature>(0),<empty>,,true,,,astOperand2,,,0,<unresolvedSignature>
111669156322,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.astFlattenCopy:<unresolvedSignature>(3),<empty>,,true,,,astFlattenCopy,,,0,<unresolvedSignature>
111669156323,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.astParent<const>:Token*(),<empty>,,true,,,astParent,,,0,Token*()
111669156324,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.varId<const>:int(),<empty>,,true,,,varId,,,0,int()
111669156325,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.valueType<const>:ValueType*(),<empty>,,true,,,valueType,,,0,ValueType*()
111669156326,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueType.isPrimitive<const>:bool(),<empty>,,true,,,isPrimitive,,,0,bool()
111669156327,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueType.isIntegral<const>:bool(),<empty>,,true,,,isIntegral,,,0,bool()
111669156328,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isBoolean<const>:bool(),<empty>,,true,,,isBoolean,,,0,bool()
111669156329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getContainerFunction:ANY(Token*,Settings*)",<empty>,,true,,,getContainerFunction,,,0,"ANY(Token*,Settings*)"
111669156330,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getAction:<unresolvedSignature>(1),<empty>,,true,,,getAction,,,0,<unresolvedSignature>
111669156331,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getYield:<unresolvedSignature>(1),<empty>,,true,,,getYield,,,0,<unresolvedSignature>
111669156332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.simpleMatch:<unresolvedSignature>(2),<empty>,,true,,,simpleMatch,,,0,<unresolvedSignature>
111669156333,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.typeDecl:ANY(Token*,bool)",<empty>,,true,,,typeDecl,,,0,"ANY(Token*,bool)"
111669156334,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.getKnownIntValue<const>:longlongint(),<empty>,,true,,,getKnownIntValue,,,0,longlongint()
111669156335,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isComparisonOp<const>:bool(),<empty>,,true,,,isComparisonOp,,,0,bool()
111669156336,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"match:bool(Token*,ANY)",<empty>,,true,,,match,,,0,"bool(Token*,ANY)"
111669156337,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.astIsVariableComparison:<unresolvedSignature>(4),<empty>,,true,,,astIsVariableComparison,,,0,<unresolvedSignature>
111669156338,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.variable<const>:Variable*(),<empty>,,true,,,variable,,,0,Variable*()
111669156339,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.nameToken<const>:Token*(),<empty>,,true,,,nameToken,,,0,Token*()
111669156340,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.linkAt<const>:Token*(int),<empty>,,true,,,linkAt,,,0,Token*(int)
111669156341,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.originalName<const>:ANY(),<empty>,,true,,,originalName,,,0,ANY()
111669156342,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isCast<const>:bool(),<empty>,,true,,,isCast,,,0,bool()
111669156343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isCpp<const>:bool(),<empty>,,true,,,isCpp,,,0,bool()
111669156344,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isUnaryOp:<unresolvedSignature>(1),<empty>,,true,,,isUnaryOp,,,0,<unresolvedSignature>
111669156345,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.previous<const>:Token*(),<empty>,,true,,,previous,,,0,Token*()
111669156346,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.function<const>:Function*(),<empty>,,true,,,function,,,0,Function*()
111669156347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.type<const>:Type*(),<empty>,,true,,,type,,,0,Type*()
111669156348,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.tokAt<const>:Token*(int),<empty>,,true,,,tokAt,,,0,Token*(int)
111669156349,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.previous:<unresolvedSignature>(0),<empty>,,true,,,previous,,,0,<unresolvedSignature>
111669156350,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.previousBeforeAstLeftmostLeafGeneric:<unresolvedSignature>(1),<empty>,,true,,,previousBeforeAstLeftmostLeafGeneric,,,0,<unresolvedSignature>
111669156351,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,findLambdaEndToken:ANY(),<empty>,,true,,,findLambdaEndToken,,,0,ANY()
111669156352,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,precedes:ANY(),<empty>,,true,,,precedes,,,0,ANY()
111669156353,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.Match:ANY(),<empty>,,true,,,Match,,,0,ANY()
111669156354,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hasToken:ANY(),<empty>,,true,,,hasToken,,,0,ANY()
111669156355,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.linkAt:<unresolvedSignature>(1),<empty>,,true,,,linkAt,,,0,<unresolvedSignature>
111669156356,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.link:<unresolvedSignature>(0),<empty>,,true,,,link,,,0,<unresolvedSignature>
111669156357,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.nextAfterAstRightmostLeafGeneric:<unresolvedSignature>(1),<empty>,,true,,,nextAfterAstRightmostLeafGeneric,,,0,<unresolvedSignature>
111669156358,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.astParent:Token*(),<empty>,,true,,,astParent,,,0,Token*()
111669156359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.link:Token*(),<empty>,,true,,,link,,,0,Token*()
111669156360,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.previous:Token*(),<empty>,,true,,,previous,,,0,Token*()
111669156361,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.linkAt:Token*(int),<empty>,,true,,,linkAt,,,0,Token*(int)
111669156362,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isLocal<const>:bool(),<empty>,,true,,,isLocal,,,0,bool()
111669156363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isArgument<const>:bool(),<empty>,,true,,,isArgument,,,0,bool()
111669156364,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"astFlatten:ANY(Token*,char*)",<empty>,,true,,,astFlatten,,,0,"ANY(Token*,char*)"
111669156365,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getParentMembers:ANY(Token*),<empty>,,true,,,getParentMembers,,,0,ANY(Token*)
111669156366,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isArray<const>:bool(),<empty>,,true,,,isArray,,,0,bool()
111669156367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isReference<const>:bool(),<empty>,,true,,,isReference,,,0,bool()
111669156368,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.crbegin:<unresolvedSignature>(0),<empty>,,true,,,crbegin,,,0,<unresolvedSignature>
111669156369,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.crend:<unresolvedSignature>(0),<empty>,,true,,,crend,,,0,<unresolvedSignature>
111669156370,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.base:<unresolvedSignature>(0),<empty>,,true,,,base,,,0,<unresolvedSignature>
111669156371,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getParentLifetimeObject:<unresolvedSignature>(1),<empty>,,true,,,getParentLifetimeObject,,,0,<unresolvedSignature>
111669156372,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getArgumentVars:ANY(Token*,int)",<empty>,,true,,,getArgumentVars,,,0,"ANY(Token*,int)"
111669156373,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.valueType<const>:ValueType*(),<empty>,,true,,,valueType,,,0,ValueType*()
111669156374,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.dimensions<const>:ANY(),<empty>,,true,,,dimensions,,,0,ANY()
111669156375,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.next:<unresolvedSignature>(2),<empty>,,true,,,next,,,0,<unresolvedSignature>
111669156376,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.valueType:<unresolvedSignature>(0),<empty>,,true,,,valueType,,,0,<unresolvedSignature>
111669156377,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.tokType<const>:Token.Type(),<empty>,,true,,,tokType,,,0,Token.Type()
111669156378,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.simpleMatch:ANY(),<empty>,,true,,,simpleMatch,,,0,ANY()
111669156379,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getCondTok:ANY(),<empty>,,true,,,getCondTok,,,0,ANY()
111669156380,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.tokAt:<unresolvedSignature>(1),<empty>,,true,,,tokAt,,,0,<unresolvedSignature>
111669156381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isName:<unresolvedSignature>(0),<empty>,,true,,,isName,,,0,<unresolvedSignature>
111669156382,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isControlFlowKeyword:<unresolvedSignature>(0),<empty>,,true,,,isControlFlowKeyword,,,0,<unresolvedSignature>
111669156383,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getCondTokFromEnd:ANY(),<empty>,,true,,,getCondTokFromEnd,,,0,ANY()
111669156384,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getInitTokImpl:ANY(),<empty>,,true,,,getInitTokImpl,,,0,ANY()
111669156385,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getStepTokImpl:ANY(),<empty>,,true,,,getStepTokImpl,,,0,ANY()
111669156386,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getCondTokImpl:<unresolvedSignature>(1),<empty>,,true,,,getCondTokImpl,,,0,<unresolvedSignature>
111669156387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getCondTokFromEndImpl:<unresolvedSignature>(1),<empty>,,true,,,getCondTokFromEndImpl,,,0,<unresolvedSignature>
111669156388,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getInitTokImpl:<unresolvedSignature>(1),<empty>,,true,,,getInitTokImpl,,,0,<unresolvedSignature>
111669156389,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getStepTokImpl:<unresolvedSignature>(1),<empty>,,true,,,getStepTokImpl,,,0,<unresolvedSignature>
111669156390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.scope<const>:Scope*(),<empty>,,true,,,scope,,,0,Scope*()
111669156391,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Scope.isLoopScope<const>:bool(),<empty>,,true,,,isLoopScope,,,0,bool()
111669156392,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isBinaryOp<const>:bool(),<empty>,,true,,,isBinaryOp,,,0,bool()
111669156393,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getMinValue:ANY(ValuePtr<InferModel>&,ANY)",<empty>,,true,,,getMinValue,,,0,"ANY(ValuePtr<InferModel>&,ANY)"
111669156394,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.values<const>:ANY(),<empty>,,true,,,values,,,0,ANY()
111669156395,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.getMinValue<const>:ValueFlow.Value*(bool,longlongint)",<empty>,,true,,,getMinValue,,,0,"ValueFlow.Value*(bool,longlongint)"
111669156396,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.visitAstNodes:<unresolvedSignature>(2),<empty>,,true,,,visitAstNodes,,,0,<unresolvedSignature>
111669156397,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.declarationId<const>:int(),<empty>,,true,,,declarationId,,,0,int()
111669156398,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.astTop<const>:Token*(),<empty>,,true,,,astTop,,,0,Token*()
111669156399,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.index<const>:int(),<empty>,,true,,,index,,,0,int()
111669156400,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.isLocalLifetimeValue<const>:bool(),<empty>,,true,,,isLocalLifetimeValue,,,0,bool()
111669156401,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.isInconclusive<const>:bool(),<empty>,,true,,,isInconclusive,,,0,bool()
111669156402,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.isImpossible<const>:bool(),<empty>,,true,,,isImpossible,,,0,bool()
111669156403,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.isSymbolicValue<const>:bool(),<empty>,,true,,,isSymbolicValue,,,0,bool()
111669156404,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"findAstNode:Token*(Token*,ANY)",<empty>,,true,,,findAstNode,,,0,"Token*(Token*,ANY)"
111669156405,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"followAllReferences:ANY(Token*,bool,bool,ANY,int)",<empty>,,true,,,followAllReferences,,,0,"ANY(Token*,bool,bool,ANY,int)"
111669156406,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Scope.isClassOrStruct<const>:bool(),<empty>,,true,,,isClassOrStruct,,,0,bool()
111669156407,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isStatic<const>:bool(),<empty>,,true,,,isStatic,,,0,bool()
111669156408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Scope.findAssociatedScopes<const>:ANY(),<empty>,,true,,,findAssociatedScopes,,,0,ANY()
111669156409,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isOperatorKeyword<const>:bool(),<empty>,,true,,,isOperatorKeyword,,,0,bool()
111669156410,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isPrivate<const>:bool(),<empty>,,true,,,isPrivate,,,0,bool()
111669156411,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isPublic<const>:bool(),<empty>,,true,,,isPublic,,,0,bool()
111669156412,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isProtected<const>:bool(),<empty>,,true,,,isProtected,,,0,bool()
111669156413,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isStatic<const>:bool(),<empty>,,true,,,isStatic,,,0,bool()
111669156414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.fileIndex<const>:int(),<empty>,,true,,,fileIndex,,,0,int()
111669156415,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isVolatile<const>:bool(),<empty>,,true,,,isVolatile,,,0,bool()
111669156416,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isConst<const>:bool(),<empty>,,true,,,isConst,,,0,bool()
111669156417,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueType.isFloat<const>:bool(),<empty>,,true,,,isFloat,,,0,bool()
111669156418,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.scope<const>:Scope*(),<empty>,,true,,,scope,,,0,Scope*()
111669156419,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isLiteral<const>:bool(),<empty>,,true,,,isLiteral,,,0,bool()
111669156420,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.expressionString<const>:ANY(),<empty>,,true,,,expressionString,,,0,ANY()
111669156421,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.find:<unresolvedSignature>(3),<empty>,,true,,,find,,,0,<unresolvedSignature>
111669156422,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.emplace_back:<unresolvedSignature>(2),<empty>,,true,,,emplace_back,,,0,<unresolvedSignature>
111669156423,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isRValueReference<const>:bool(),<empty>,,true,,,isRValueReference,,,0,bool()
111669156424,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.followAllReferences:<unresolvedSignature>(5),<empty>,,true,,,followAllReferences,,,0,<unresolvedSignature>
111669156425,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.findReturns:ANY(Function*),<empty>,,true,,,findReturns,,,0,ANY(Function*)
111669156426,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getArguments:ANY(Token*),<empty>,,true,,,getArguments,,,0,ANY(Token*)
111669156427,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.isLifetimeValue<const>:bool(),<empty>,,true,,,isLifetimeValue,,,0,bool()
111669156428,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.mem_fn:<unresolvedSignature>(1),<empty>,,true,,,mem_fn,,,0,<unresolvedSignature>
111669156429,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isNonValue:<unresolvedSignature>(0),<empty>,,true,,,isNonValue,,,0,<unresolvedSignature>
111669156430,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isContainerSizeValue:<unresolvedSignature>(0),<empty>,,true,,,isContainerSizeValue,,,0,<unresolvedSignature>
111669156431,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isSymbolicValue:<unresolvedSignature>(0),<empty>,,true,,,isSymbolicValue,,,0,<unresolvedSignature>
111669156432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.equalValue<const>:bool(ValueFlow.Value&),<empty>,,true,,,equalValue,,,0,bool(ValueFlow.Value&)
111669156433,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.isIteratorValue<const>:bool(),<empty>,,true,,,isIteratorValue,,,0,bool()
111669156434,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.compareKnownValue:<unresolvedSignature>(3),<empty>,,true,,,compareKnownValue,,,0,<unresolvedSignature>
111669156435,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isStandardType<const>:bool(),<empty>,,true,,,isStandardType,,,0,bool()
111669156436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>():Token*(Token*),<empty>,,true,,,<operator>(),,,0,Token*(Token*)
111669156437,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isNumber<const>:bool(),<empty>,,true,,,isNumber,,,0,bool()
111669156438,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.enumerator<const>:Enumerator*(),<empty>,,true,,,enumerator,,,0,Enumerator*()
111669156439,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isExpandedMacro<const>:bool(),<empty>,,true,,,isExpandedMacro,,,0,bool()
111669156440,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isTemplateArg<const>:bool(),<empty>,,true,,,isTemplateArg,,,0,bool()
111669156441,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.astSibling<const>:Token*(),<empty>,,true,,,astSibling,,,0,Token*()
111669156442,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isKeyword<const>:bool(),<empty>,,true,,,isKeyword,,,0,bool()
111669156443,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isInitComma<const>:bool(),<empty>,,true,,,isInitComma,,,0,bool()
111669156444,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getParentValueTypes:ANY(Token*,Settings&,Token**)",<empty>,,true,,,getParentValueTypes,,,0,"ANY(Token*,Settings&,Token**)"
111669156445,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.getMacroName<const>:ANY(),<empty>,,true,,,getMacroName,,,0,ANY()
111669156446,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isComplex<const>:bool(),<empty>,,true,,,isComplex,,,0,bool()
111669156447,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isLong<const>:bool(),<empty>,,true,,,isLong,,,0,bool()
111669156448,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isUnsigned<const>:bool(),<empty>,,true,,,isUnsigned,,,0,bool()
111669156449,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isSigned<const>:bool(),<empty>,,true,,,isSigned,,,0,bool()
111669156450,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"isSameExpression:bool(bool,Token*,Token*,Settings&,bool,bool,ANY)",<empty>,,true,,,isSameExpression,,,0,"bool(bool,Token*,Token*,Settings&,bool,bool,ANY)"
111669156451,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"followVariableExpressionError:void(Token*,Token*,ANY)",<empty>,,true,,,followVariableExpressionError,,,0,"void(Token*,Token*,ANY)"
111669156452,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"followReferences:Token*(Token*,ANY)",<empty>,,true,,,followReferences,,,0,"Token*(Token*,ANY)"
111669156453,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.swap:<unresolvedSignature>(2),<empty>,,true,,,swap,,,0,<unresolvedSignature>
111669156454,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isName<const>:bool(),<empty>,,true,,,isName,,,0,bool()
111669156455,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.strAt<const>:ANY(int),<empty>,,true,,,strAt,,,0,ANY(int)
111669156456,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAttributeConst<const>:bool(),<empty>,,true,,,isAttributeConst,,,0,bool()
111669156457,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAttributePure<const>:bool(),<empty>,,true,,,isAttributePure,,,0,bool()
111669156458,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isConst<const>:bool(),<empty>,,true,,,isConst,,,0,bool()
111669156459,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isAttributeConst<const>:bool(),<empty>,,true,,,isAttributeConst,,,0,bool()
111669156460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isAttributePure<const>:bool(),<empty>,,true,,,isAttributePure,,,0,bool()
111669156461,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAssignmentOp<const>:bool(),<empty>,,true,,,isAssignmentOp,,,0,bool()
111669156462,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.getValue<const>:ValueFlow.Value*(longlongint),<empty>,,true,,,getValue,,,0,ValueFlow.Value*(longlongint)
111669156463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"isOppositeCond:bool(bool,Token*,Token*,Settings&,bool,bool,ANY)",<empty>,,true,,,isOppositeCond,,,0,"bool(bool,Token*,Token*,Settings&,bool,bool,ANY)"
111669156464,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isContainerYield:<unresolvedSignature>(3),<empty>,,true,,,isContainerYield,,,0,<unresolvedSignature>
111669156465,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isPointer<const>:bool(),<empty>,,true,,,isPointer,,,0,bool()
111669156466,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.getOverloadedFunctions<const>:ANY(),<empty>,,true,,,getOverloadedFunctions,,,0,ANY()
111669156467,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isConstexpr<const>:bool(),<empty>,,true,,,isConstexpr,,,0,bool()
111669156468,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.Container.getYield<const>:Library.Container.Yield(ANY),<empty>,,true,,,getYield,,,0,Library.Container.Yield(ANY)
111669156469,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.Container.getAction<const>:Library.Container.Action(ANY),<empty>,,true,,,getAction,,,0,Library.Container.Action(ANY)
111669156470,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.all_of:<unresolvedSignature>(3),<empty>,,true,,,all_of,,,0,<unresolvedSignature>
111669156471,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isClass<const>:bool(),<empty>,,true,,,isClass,,,0,bool()
111669156472,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isStlType<const>:bool(),<empty>,,true,,,isStlType,,,0,bool()
111669156473,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isStlType<const>:bool(ANY),<empty>,,true,,,isStlType,,,0,bool(ANY)
111669156474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Type.name<const>:ANY(),<empty>,,true,,,name,,,0,ANY()
111669156475,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.stringifyList<const>:ANY(Token*,bool)",<empty>,,true,,,stringifyList,,,0,"ANY(Token*,bool)"
111669156476,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.returnDefEnd<const>:Token*(),<empty>,,true,,,returnDefEnd,,,0,Token*()
111669156477,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.name<const>:ANY(),<empty>,,true,,,name,,,0,ANY()
111669156478,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.type<const>:Type*(),<empty>,,true,,,type,,,0,Type*()
111669156479,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.name<const>:ANY(),<empty>,,true,,,name,,,0,ANY()
111669156480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isFloatingType<const>:bool(),<empty>,,true,,,isFloatingType,,,0,bool()
111669156481,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isEnumType<const>:bool(),<empty>,,true,,,isEnumType,,,0,bool()
111669156482,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isEscapeFunction<const>:bool(),<empty>,,true,,,isEscapeFunction,,,0,bool()
111669156483,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isAttributeNoreturn<const>:bool(),<empty>,,true,,,isAttributeNoreturn,,,0,bool()
111669156484,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.getFunctionName<const>:ANY(Token*),<empty>,,true,,,getFunctionName,,,0,ANY(Token*)
111669156485,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isConstOp<const>:bool(),<empty>,,true,,,isConstOp,,,0,bool()
111669156486,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findsimplematch:<unresolvedSignature>(3),<empty>,,true,,,findsimplematch,,,0,<unresolvedSignature>
111669156487,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isIncompleteVar<const>:bool(),<empty>,,true,,,isIncompleteVar,,,0,bool()
111669156488,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.astParent:<unresolvedSignature>(0),<empty>,,true,,,astParent,,,0,<unresolvedSignature>
111669156489,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isIncDecOp:<unresolvedSignature>(0),<empty>,,true,,,isIncDecOp,,,0,<unresolvedSignature>
111669156490,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isCast:<unresolvedSignature>(0),<empty>,,true,,,isCast,,,0,<unresolvedSignature>
111669156491,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getArgumentPos:ANY(),<empty>,,true,,,getArgumentPos,,,0,ANY()
111669156492,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getTokenArgumentFunctionImpl:<unresolvedSignature>(2),<empty>,,true,,,getTokenArgumentFunctionImpl,,,0,<unresolvedSignature>
111669156493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.argCount<const>:int(),<empty>,,true,,,argCount,,,0,int()
111669156494,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isConstructor<const>:bool(),<empty>,,true,,,isConstructor,,,0,bool()
111669156495,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isEnumerator<const>:bool(),<empty>,,true,,,isEnumerator,,,0,bool()
111669156496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"isConstVarExpression:bool(Token*,ANY)",<empty>,,true,,,isConstVarExpression,,,0,"bool(Token*,ANY)"
111669156497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():Token*(Token*,Token*)",<empty>,,true,,,<operator>(),,,0,"Token*(Token*,Token*)"
111669156498,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isArithmeticalOp<const>:bool(),<empty>,,true,,,isArithmeticalOp,,,0,bool()
111669156499,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isIncDecOp<const>:bool(),<empty>,,true,,,isIncDecOp,,,0,bool()
111669156500,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Scope.nestedInFunction:Function*(Scope*),<empty>,,true,,,nestedInFunction,,,0,Function*(Scope*)
111669156501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Scope.isExecutable<const>:bool(),<empty>,,true,,,isExecutable,,,0,bool()
111669156502,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getExprTok:<unresolvedSignature>(0),<empty>,,true,,,getExprTok,,,0,<unresolvedSignature>
111669156503,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isAliasOf:ANY(),<empty>,,true,,,isAliasOf,,,0,ANY()
111669156504,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isExpressionChangedAt:<unresolvedSignature>(7),<empty>,,true,,,isExpressionChangedAt,,,0,<unresolvedSignature>
111669156505,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.memoize:<unresolvedSignature>(1),<empty>,,true,,,memoize,,,0,<unresolvedSignature>
111669156506,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.next:Token*(),<empty>,,true,,,next,,,0,Token*()
111669156507,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isGlobal<const>:bool(),<empty>,,true,,,isGlobal,,,0,bool()
111669156508,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isIncompleteConstant<const>:bool(),<empty>,,true,,,isIncompleteConstant,,,0,bool()
111669156509,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,findAstNode:ANY(),<empty>,,true,,,findAstNode,,,0,ANY()
111669156510,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,findToken:ANY(),<empty>,,true,,,findToken,,,0,ANY()
111669156511,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,findTokenSkipDeadCode:ANY(),<empty>,,true,,,findTokenSkipDeadCode,,,0,ANY()
111669156512,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"findExpressionChangedImpl:Token*(Token*,Token*,Token*,Settings&,int,ExpressionChangedSimpleFind)",<empty>,,true,,,findExpressionChangedImpl,,,0,"Token*(Token*,Token*,Token*,Settings&,int,ExpressionChangedSimpleFind)"
111669156513,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"findExpressionChangedImpl:Token*(Token*,Token*,Token*,Settings&,int,ExpressionChangedSkipDeadCode)",<empty>,,true,,,findExpressionChangedImpl,,,0,"Token*(Token*,Token*,Token*,Settings&,int,ExpressionChangedSkipDeadCode)"
111669156514,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExpressionChangedSkipDeadCode,<empty>,,true,,,ExpressionChangedSkipDeadCode,,,0,
111669156515,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.astIsPointer:<unresolvedSignature>(1),<empty>,,true,,,astIsPointer,,,0,<unresolvedSignature>
111669156516,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.astIsIterator:<unresolvedSignature>(1),<empty>,,true,,,astIsIterator,,,0,<unresolvedSignature>
111669156517,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getLifetimeObjValue:<unresolvedSignature>(1),<empty>,,true,,,getLifetimeObjValue,,,0,<unresolvedSignature>
111669156518,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getIteratorExpression:<unresolvedSignature>(1),<empty>,,true,,,getIteratorExpression,,,0,<unresolvedSignature>
111669156519,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isCpp:<unresolvedSignature>(0),<empty>,,true,,,isCpp,,,0,<unresolvedSignature>
111669156520,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>():bool(T*),<empty>,,true,,,<operator>(),,,0,bool(T*)
111669156521,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findLambdaEndTokenGeneric:<unresolvedSignature>(1),<empty>,,true,,,findLambdaEndTokenGeneric,,,0,<unresolvedSignature>
111669156522,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.skipPredicate:<unresolvedSignature>(1),<empty>,,true,,,skipPredicate,,,0,<unresolvedSignature>
111669156523,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.hasBody<const>:bool(),<empty>,,true,,,hasBody,,,0,bool()
111669156524,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isControlFlowKeyword<const>:bool(),<empty>,,true,,,isControlFlowKeyword,,,0,bool()
111669156525,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getLHSVariablesRecursive:void(ANY,Token*)",<empty>,,true,,,getLHSVariablesRecursive,,,0,"void(ANY,Token*)"
111669156526,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MathLib.isInt:bool(ANY),<empty>,,true,,,isInt,,,0,bool(ANY)
111669156527,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MathLib.isNullValue:bool(ANY),<empty>,,true,,,isNullValue,,,0,bool(ANY)
111669156528,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isExtern<const>:bool(),<empty>,,true,,,isExtern,,,0,bool()
111669156529,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getSwitchValues:ANY(Token*,bool&)",<empty>,,true,,,getSwitchValues,,,0,"ANY(Token*,bool&)"
111669156530,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueType.isEnum<const>:bool(),<empty>,,true,,,isEnum,,,0,bool()
111669156531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.getValueNE<const>:ValueFlow.Value*(longlongint),<empty>,,true,,,getValueNE,,,0,ValueFlow.Value*(longlongint)
111669156532,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.reportError:<unresolvedSignature>(4),<empty>,,true,,,reportError,,,0,<unresolvedSignature>
111669156533,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.toupper:<unresolvedSignature>(1),<empty>,,true,,,toupper,,,0,<unresolvedSignature>
111669156534,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Check.logChecker:void(char*),<empty>,,true,,,logChecker,,,0,void(char*)
111669156535,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.getSymbolDatabase<const>:SymbolDatabase*(),<empty>,,true,,,getSymbolDatabase,,,0,SymbolDatabase*()
111669156536,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.reportError:<unresolvedSignature>(6),<empty>,,true,,,reportError,,,0,<unresolvedSignature>
111669156537,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.getSettings<const>:Settings&(),<empty>,,true,,,getSettings,,,0,Settings&()
111669156538,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TokenList.front<const>:Token*(),<empty>,,true,,,front,,,0,Token*()
111669156539,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckAssert.sideEffectInAssertError:void(Token*,ANY)",<empty>,,true,,,sideEffectInAssertError,,,0,"void(Token*,ANY)"
111669156540,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckAssert.assignmentInAssertError:void(Token*,ANY)",<empty>,,true,,,assignmentInAssertError,,,0,"void(Token*,ANY)"
111669156541,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sideEffectInAssertError:<unresolvedSignature>(2),<empty>,,true,,,sideEffectInAssertError,,,0,<unresolvedSignature>
111669156542,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.assignmentInAssertError:<unresolvedSignature>(2),<empty>,,true,,,assignmentInAssertError,,,0,<unresolvedSignature>
111669156543,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.isentrypoint<const>:bool(ANY),<empty>,,true,,,isentrypoint,,,0,bool(ANY)
111669156544,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.isTokValue<const>:bool(),<empty>,,true,,,isTokValue,,,0,bool()
111669156545,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Settings.isPremiumEnabled<const>:bool(char*),<empty>,,true,,,isPremiumEnabled,,,0,bool(char*)
111669156546,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.variableIsUsedInScope:<unresolvedSignature>(3),<empty>,,true,,,variableIsUsedInScope,,,0,<unresolvedSignature>
111669156547,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findsimplematch:<unresolvedSignature>(2),<empty>,,true,,,findsimplematch,,,0,<unresolvedSignature>
111669156548,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isC<const>:bool(),<empty>,,true,,,isC,,,0,bool()
111669156549,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SimpleEnableGroup<enumCertainty>.isEnabled<const>:bool(Certainty),<empty>,,true,,,isEnabled,,,0,bool(Certainty)
111669156550,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.findmatch:Token*(Token*,char*,int)",<empty>,,true,,,findmatch,,,0,"Token*(Token*,char*,int)"
111669156551,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Scope.isNestedIn<const>:bool(Scope*),<empty>,,true,,,isNestedIn,,,0,bool(Scope*)
111669156552,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Scope.isClassOrStructOrUnion<const>:bool(),<empty>,,true,,,isClassOrStructOrUnion,,,0,bool()
111669156553,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueFlow.getLifetimeTokens:ANY(Token*,Settings&,bool,ANY)",<empty>,,true,,,getLifetimeTokens,,,0,"ANY(Token*,Settings&,bool,ANY)"
111669156554,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckAutoVariables.errorReturnReference:void(Token*,ANY,bool)",<empty>,,true,,,errorReturnReference,,,0,"void(Token*,ANY,bool)"
111669156555,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckAutoVariables.errorReturnTempReference:void(Token*,ANY,bool)",<empty>,,true,,,errorReturnTempReference,,,0,"void(Token*,ANY,bool)"
111669156556,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueFlow.getLifetimeVariable:Variable*(Token*,ANY,Settings&,bool*)",<empty>,,true,,,getLifetimeVariable,,,0,"Variable*(Token*,ANY,Settings&,bool*)"
111669156557,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.errorDanglingReference:<unresolvedSignature>(3),<empty>,,true,,,errorDanglingReference,,,0,<unresolvedSignature>
111669156558,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckAutoVariables.errorDanglingTempReference:void(Token*,ANY,bool)",<empty>,,true,,,errorDanglingTempReference,,,0,"void(Token*,ANY,bool)"
111669156559,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.isSubFunctionLifetimeValue<const>:bool(),<empty>,,true,,,isSubFunctionLifetimeValue,,,0,bool()
111669156560,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ErrorPath:<unresolvedSignature>(0),<empty>,,true,,,ErrorPath,,,0,<unresolvedSignature>
111669156561,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueFlow.lifetimeMessage:ANY(Token*,ValueFlow.Value*,ANY)",<empty>,,true,,,lifetimeMessage,,,0,"ANY(Token*,ValueFlow.Value*,ANY)"
111669156562,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Check.reportError:void(ANY,Severity,char*,ANY,CWE&,Certainty)",<empty>,,true,,,reportError,,,0,"void(ANY,Severity,char*,ANY,CWE&,Certainty)"
111669156563,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getErrorPath:<unresolvedSignature>(3),<empty>,,true,,,getErrorPath,,,0,<unresolvedSignature>
111669156564,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckAutoVariables.errorDanglingReference:void(Token*,Variable*,ANY)",<empty>,,true,,,errorDanglingReference,,,0,"void(Token*,Variable*,ANY)"
111669156565,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.typeEndToken<const>:Token*(),<empty>,,true,,,typeEndToken,,,0,Token*()
111669156566,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.bitwiseOnBooleanError:<unresolvedSignature>(4),<empty>,,true,,,bitwiseOnBooleanError,,,0,<unresolvedSignature>
111669156567,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.isCPP<const>:bool(),<empty>,,true,,,isCPP,,,0,bool()
111669156568,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckBool.comparisonOfBoolWithInvalidComparator:void(Token*,ANY)",<empty>,,true,,,comparisonOfBoolWithInvalidComparator,,,0,"void(Token*,ANY)"
111669156569,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>():Token(Token*),<empty>,,true,,,<operator>(),,,0,Token(Token*)
111669156570,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckBool.comparisonOfTwoFuncsReturningBoolError:void(Token*,ANY,ANY)",<empty>,,true,,,comparisonOfTwoFuncsReturningBoolError,,,0,"void(Token*,ANY,ANY)"
111669156571,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckBool.comparisonOfFuncReturningBoolError:void(Token*,ANY)",<empty>,,true,,,comparisonOfFuncReturningBoolError,,,0,"void(Token*,ANY)"
111669156572,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckBool.comparisonOfBoolWithBoolError:void(Token*,ANY)",<empty>,,true,,,comparisonOfBoolWithBoolError,,,0,"void(Token*,ANY)"
111669156573,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isOp<const>:bool(),<empty>,,true,,,isOp,,,0,bool()
111669156574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.getValueLE<const>:ValueFlow.Value*(longlongint,Settings&)",<empty>,,true,,,getValueLE,,,0,"ValueFlow.Value*(longlongint,Settings&)"
111669156575,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.getValueGE<const>:ValueFlow.Value*(longlongint,Settings&)",<empty>,,true,,,getValueGE,,,0,"ValueFlow.Value*(longlongint,Settings&)"
111669156576,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.comparisonOfFuncReturningBoolError:<unresolvedSignature>(2),<empty>,,true,,,comparisonOfFuncReturningBoolError,,,0,<unresolvedSignature>
111669156577,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.comparisonOfTwoFuncsReturningBoolError:<unresolvedSignature>(3),<empty>,,true,,,comparisonOfTwoFuncsReturningBoolError,,,0,<unresolvedSignature>
111669156578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.comparisonOfBoolWithBoolError:<unresolvedSignature>(2),<empty>,,true,,,comparisonOfBoolWithBoolError,,,0,<unresolvedSignature>
111669156579,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.bitwiseOnBooleanError:<unresolvedSignature>(3),<empty>,,true,,,bitwiseOnBooleanError,,,0,<unresolvedSignature>
111669156580,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.comparisonOfBoolWithInvalidComparator:<unresolvedSignature>(2),<empty>,,true,,,comparisonOfBoolWithInvalidComparator,,,0,<unresolvedSignature>
111669156581,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.tokType:<unresolvedSignature>(0),<empty>,,true,,,tokType,,,0,<unresolvedSignature>
111669156582,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasKnownIntValue:<unresolvedSignature>(0),<empty>,,true,,,hasKnownIntValue,,,0,<unresolvedSignature>
111669156583,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getKnownIntValue:<unresolvedSignature>(0),<empty>,,true,,,getKnownIntValue,,,0,<unresolvedSignature>
111669156584,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getStrLength:<unresolvedSignature>(1),<empty>,,true,,,getStrLength,,,0,<unresolvedSignature>
111669156585,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.append:<unresolvedSignature>(2),<empty>,,true,,,append,,,0,<unresolvedSignature>
111669156586,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.abs:<unresolvedSignature>(1),<empty>,,true,,,abs,,,0,<unresolvedSignature>
111669156587,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.getValueTokenMinStrSize<const>:Token*(Settings&,longlongint*)",<empty>,,true,,,getValueTokenMinStrSize,,,0,"Token*(Settings&,longlongint*)"
111669156588,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.isKnown<const>:bool(),<empty>,,true,,,isKnown,,,0,bool()
111669156589,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isOutOfBounds:<unresolvedSignature>(2),<empty>,,true,,,isOutOfBounds,,,0,<unresolvedSignature>
111669156590,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"makeSizeValue:ValueFlow.Value(longlongint,longlongint)",<empty>,,true,,,makeSizeValue,,,0,"ValueFlow.Value(longlongint,longlongint)"
111669156591,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getKnownValue:<unresolvedSignature>(1),<empty>,,true,,,getKnownValue,,,0,<unresolvedSignature>
111669156592,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.unknown:ValueFlow.Value(),<empty>,,true,,,unknown,,,0,ValueFlow.Value()
111669156593,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.tokens<const>:Token*(),<empty>,,true,,,tokens,,,0,Token*()
111669156594,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getDimensionsEtc:bool(Token*,Settings&,ANY,ANY,bool&,longlongint&)",<empty>,,true,,,getDimensionsEtc,,,0,"bool(Token*,Settings&,ANY,ANY,bool&,longlongint&)"
111669156595,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getOverrunIndexValues:ANY(Token*,Token*,ANY,ANY,longlongint)",<empty>,,true,,,getOverrunIndexValues,,,0,"ANY(Token*,Token*,ANY,ANY,longlongint)"
111669156596,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckBufferOverrun.arrayIndexError:void(Token*,ANY,ANY)",<empty>,,true,,,arrayIndexError,,,0,"void(Token*,ANY,ANY)"
111669156597,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckBufferOverrun.negativeIndexError:void(Token*,ANY,ANY)",<empty>,,true,,,negativeIndexError,,,0,"void(Token*,ANY,ANY)"
111669156598,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.isNonValue<const>:bool(),<empty>,,true,,,isNonValue,,,0,bool()
111669156599,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.eitherTheConditionIsRedundant:ANY(Token*),<empty>,,true,,,eitherTheConditionIsRedundant,,,0,ANY(Token*)
111669156600,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"stringifyIndexes:ANY(ANY,ANY)",<empty>,,true,,,stringifyIndexes,,,0,"ANY(ANY,ANY)"
111669156601,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.errorSeverity<const>:bool(),<empty>,,true,,,errorSeverity,,,0,bool()
111669156602,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"arrayIndexMessage:ANY(Token*,ANY,ANY,Token*)",<empty>,,true,,,arrayIndexMessage,,,0,"ANY(Token*,ANY,ANY,Token*)"
111669156603,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.pointerArithmeticError:<unresolvedSignature>(3),<empty>,,true,,,pointerArithmeticError,,,0,<unresolvedSignature>
111669156604,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Value:<unresolvedSignature>(1),<empty>,,true,,,Value,,,0,<unresolvedSignature>
111669156605,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.setKnown:void(),<empty>,,true,,,setKnown,,,0,void()
111669156606,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Library.isargformatstr<const>:bool(Token*,int)",<empty>,,true,,,isargformatstr,,,0,"bool(Token*,int)"
111669156607,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getMinFormatStringOutputLength:int(ANY,int)",<empty>,,true,,,getMinFormatStringOutputLength,,,0,"int(ANY,int)"
111669156608,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.sizeOfType<const>:int(ANY),<empty>,,true,,,sizeOfType,,,0,int(ANY)
111669156609,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"checkBufferSize:bool(Token*,Library.ArgumentChecks.MinSize&,ANY,longlong,Settings&,Tokenizer*)",<empty>,,true,,,checkBufferSize,,,0,"bool(Token*,Library.ArgumentChecks.MinSize&,ANY,longlong,Settings&,Tokenizer*)"
111669156610,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Library.argminsizes<const>:ANY(Token*,int)",<empty>,,true,,,argminsizes,,,0,"ANY(Token*,int)"
111669156611,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckBufferOverrun.getBufferSize:ValueFlow.Value(Token*),<empty>,,true,,,getBufferSize,,,0,ValueFlow.Value(Token*)
111669156612,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.none_of:<unresolvedSignature>(3),<empty>,,true,,,none_of,,,0,<unresolvedSignature>
111669156613,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.bufferOverflowError:<unresolvedSignature>(3),<empty>,,true,,,bufferOverflowError,,,0,<unresolvedSignature>
111669156614,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckBufferOverrun.arrayIndexThenCheckError:void(Token*,ANY)",<empty>,,true,,,arrayIndexThenCheckError,,,0,"void(Token*,ANY)"
111669156615,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.isContainerSizeValue<const>:bool(),<empty>,,true,,,isContainerSizeValue,,,0,bool()
111669156616,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getBufferSize:<unresolvedSignature>(1),<empty>,,true,,,getBufferSize,,,0,<unresolvedSignature>
111669156617,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getValueTokenMaxStrLength:<unresolvedSignature>(0),<empty>,,true,,,getValueTokenMaxStrLength,,,0,<unresolvedSignature>
111669156618,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isSameExpression:<unresolvedSignature>(6),<empty>,,true,,,isSameExpression,,,0,<unresolvedSignature>
111669156619,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.terminateStrncpyError:<unresolvedSignature>(2),<empty>,,true,,,terminateStrncpyError,,,0,<unresolvedSignature>
111669156620,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.expressionString:<unresolvedSignature>(0),<empty>,,true,,,expressionString,,,0,<unresolvedSignature>
111669156621,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.argumentSizeError:<unresolvedSignature>(6),<empty>,,true,,,argumentSizeError,,,0,<unresolvedSignature>
111669156622,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getOrdinalText:char*(int),<empty>,,true,,,getOrdinalText,,,0,char*(int)
111669156623,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CTU.toString:ANY(ANY),<empty>,,true,,,toString,,,0,ANY(ANY)
111669156624,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CTU.getUnsafeUsage:ANY(Tokenizer&,Settings&,bool(*)(constSettings&,Token*,CTU.FileInfo.Value*))",<empty>,,true,,,getUnsafeUsage,,,0,"ANY(Tokenizer&,Settings&,bool(*)(constSettings&,Token*,CTU.FileInfo.Value*))"
111669156625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TokenList.getFiles<const>:ANY(),<empty>,,true,,,getFiles,,,0,ANY()
111669156626,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CTU.loadUnsafeUsageListFromXml:ANY(tinyxml2.XMLElement*),<empty>,,true,,,loadUnsafeUsageListFromXml,,,0,ANY(tinyxml2.XMLElement*)
111669156627,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckBufferOverrun.logChecker:void(char*),<empty>,,true,,,logChecker,,,0,void(char*)
111669156628,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CTU.FileInfo.getCallsMap<const>:ANY(),<empty>,,true,,,getCallsMap,,,0,ANY()
111669156629,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckBufferOverrun.analyseWholeProgram1:bool(ANY,CTU.FileInfo.UnsafeUsage&,int,ErrorLogger&,int,ANY)",<empty>,,true,,,analyseWholeProgram1,,,0,"bool(ANY,CTU.FileInfo.UnsafeUsage&,int,ErrorLogger&,int,ANY)"
111669156630,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CTU.FileInfo.getErrorPath:ANY(CTU.FileInfo.InvalidValueType,CTU.FileInfo.UnsafeUsage&,ANY,char*,CTU.FileInfo.FunctionCall**,bool,int,ValueFlow.Value.UnknownFunctionReturn*)",<empty>,,true,,,getErrorPath,,,0,"ANY(CTU.FileInfo.InvalidValueType,CTU.FileInfo.UnsafeUsage&,ANY,char*,CTU.FileInfo.FunctionCall**,bool,int,ValueFlow.Value.UnknownFunctionReturn*)"
111669156631,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.isIntValue<const>:bool(),<empty>,,true,,,isIntValue,,,0,bool()
111669156632,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueFlow.getLifetimeObjValues:ANY(Token*,bool,longlongint)",<empty>,,true,,,getLifetimeObjValues,,,0,"ANY(Token*,bool,longlongint)"
111669156633,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueFlow.isOutOfBounds:ANY(ValueFlow.Value&,Token*,bool)",<empty>,,true,,,isOutOfBounds,,,0,"ANY(ValueFlow.Value&,Token*,bool)"
111669156634,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SymbolDatabase.variableList<const>:ANY(),<empty>,,true,,,variableList,,,0,ANY()
111669156635,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.string:<unresolvedSignature>(0),<empty>,,true,,,string,,,0,<unresolvedSignature>
111669156636,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Check.getErrorPath:ANY(Token*,ValueFlow.Value*,ANY)",<empty>,,true,,,getErrorPath,,,0,"ANY(Token*,ValueFlow.Value*,ANY)"
111669156637,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.arrayIndexError:<unresolvedSignature>(3),<empty>,,true,,,arrayIndexError,,,0,<unresolvedSignature>
111669156638,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.vector<Dimension>:<unresolvedSignature>(0),<empty>,,true,,,vector<Dimension>,,,0,<unresolvedSignature>
111669156639,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.vector<ValueFlow::Value>:<unresolvedSignature>(0),<empty>,,true,,,vector<ValueFlow::Value>,,,0,<unresolvedSignature>
111669156640,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.negativeIndexError:<unresolvedSignature>(3),<empty>,,true,,,negativeIndexError,,,0,<unresolvedSignature>
111669156641,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.arrayIndexThenCheckError:<unresolvedSignature>(2),<empty>,,true,,,arrayIndexThenCheckError,,,0,<unresolvedSignature>
111669156642,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.hasDefault<const>:bool(),<empty>,,true,,,hasDefault,,,0,bool()
111669156643,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasLib:<unresolvedSignature>(1),<empty>,,true,,,hasLib,,,0,<unresolvedSignature>
111669156644,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isInit<const>:bool(),<empty>,,true,,,isInit,,,0,bool()
111669156645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.noConstructorError:void(Token*,ANY,bool)",<empty>,,true,,,noConstructorError,,,0,"void(Token*,ANY,bool)"
111669156646,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.uninitVarError:void(Token*,ANY,ANY)",<empty>,,true,,,uninitVarError,,,0,"void(Token*,ANY,ANY)"
111669156647,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.typeStartToken<const>:Token*(),<empty>,,true,,,typeStartToken,,,0,Token*()
111669156648,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckClass.createUsageList:ANY(Scope*),<empty>,,true,,,createUsageList,,,0,ANY(Scope*)
111669156649,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isDefault<const>:bool(),<empty>,,true,,,isDefault,,,0,bool()
111669156650,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckClass.clearAllVar:void(ANY),<empty>,,true,,,clearAllVar,,,0,void(ANY)
111669156651,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.initializeVarList:void(Function&,ANY,Scope*,ANY)",<empty>,,true,,,initializeVarList,,,0,"void(Function&,ANY,Scope*,ANY)"
111669156652,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isOperator<const>:bool(),<empty>,,true,,,isOperator,,,0,bool()
111669156653,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.getTypeName<const>:ANY(),<empty>,,true,,,getTypeName,,,0,ANY()
111669156654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.podtype<const>:Library.PodType*(ANY),<empty>,,true,,,podtype,,,0,Library.PodType*(ANY)
111669156655,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.typeScope<const>:Scope*(),<empty>,,true,,,typeScope,,,0,Scope*()
111669156656,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getTypeCheck:<unresolvedSignature>(2),<empty>,,true,,,getTypeCheck,,,0,<unresolvedSignature>
111669156657,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.operatorEqVarError:void(Token*,ANY,ANY,bool)",<empty>,,true,,,operatorEqVarError,,,0,"void(Token*,ANY,ANY,bool)"
111669156658,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.uninitVarError:void(Token*,bool,FunctionType,ANY,ANY,bool,bool)",<empty>,,true,,,uninitVarError,,,0,"void(Token*,bool,FunctionType,ANY,ANY,bool,bool)"
111669156659,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.missingMemberCopyError:void(Token*,FunctionType,ANY,ANY)",<empty>,,true,,,missingMemberCopyError,,,0,"void(Token*,FunctionType,ANY,ANY)"
111669156660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isPure<const>:bool(),<empty>,,true,,,isPure,,,0,bool()
111669156661,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isDelete<const>:bool(),<empty>,,true,,,isDelete,,,0,bool()
111669156662,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isExplicit<const>:bool(),<empty>,,true,,,isExplicit,,,0,bool()
111669156663,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.minArgCount<const>:int(),<empty>,,true,,,minArgCount,,,0,int()
111669156664,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.typeEndToken:<unresolvedSignature>(0),<empty>,,true,,,typeEndToken,,,0,<unresolvedSignature>
111669156665,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getTypeName:<unresolvedSignature>(0),<empty>,,true,,,getTypeName,,,0,<unresolvedSignature>
111669156666,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.noExplicitConstructorError:void(Token*,ANY,bool)",<empty>,,true,,,noExplicitConstructorError,,,0,"void(Token*,ANY,bool)"
111669156667,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.noCopyConstructorError:<unresolvedSignature>(4),<empty>,,true,,,noCopyConstructorError,,,0,<unresolvedSignature>
111669156668,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.noOperatorEqError:<unresolvedSignature>(4),<empty>,,true,,,noOperatorEqError,,,0,<unresolvedSignature>
111669156669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Match:<unresolvedSignature>(2),<empty>,,true,,,Match,,,0,<unresolvedSignature>
111669156670,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isIntegral:<unresolvedSignature>(0),<empty>,,true,,,isIntegral,,,0,<unresolvedSignature>
111669156671,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.variable:<unresolvedSignature>(0),<empty>,,true,,,variable,,,0,<unresolvedSignature>
111669156672,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.copyConstructorShallowCopyError:void(Token*,ANY)",<empty>,,true,,,copyConstructorShallowCopyError,,,0,"void(Token*,ANY)"
111669156673,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"noMemberErrorMessage:ANY(Scope*,char*,bool)",<empty>,,true,,,noMemberErrorMessage,,,0,"ANY(Scope*,char*,bool)"
111669156674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getAllVariableMembers:void(Scope*,ANY)",<empty>,,true,,,getAllVariableMembers,,,0,"void(Scope*,ANY)"
111669156675,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Usage:<unresolvedSignature>(1),<empty>,,true,,,Usage,,,0,<unresolvedSignature>
111669156676,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.assignVar:void(ANY,int)",<empty>,,true,,,assignVar,,,0,"void(ANY,int)"
111669156677,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.assignAllVarsVisibleFromScope:void(ANY,Scope*)",<empty>,,true,,,assignAllVarsVisibleFromScope,,,0,"void(ANY,Scope*)"
111669156678,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.initVar:void(ANY,int)",<empty>,,true,,,initVar,,,0,"void(ANY,int)"
111669156679,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckClass.assignAllVar:void(ANY),<empty>,,true,,,assignAllVar,,,0,void(ANY)
111669156680,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isMutable<const>:bool(),<empty>,,true,,,isMutable,,,0,bool()
111669156681,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.assignVar:void(ANY,Token*)",<empty>,,true,,,assignVar,,,0,"void(ANY,Token*)"
111669156682,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Check.reportError:void(Token*,Severity,ANY,ANY,CWE&,Certainty)",<empty>,,true,,,reportError,,,0,"void(Token*,Severity,ANY,ANY,CWE&,Certainty)"
111669156683,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lib/check.h,lib/check.h:50:50:WRONG_DATA:2,<empty>,,true,50,50,WRONG_DATA,,,0,
111669156684,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.linenr:<unresolvedSignature>(0),<empty>,,true,,,linenr,,,0,<unresolvedSignature>
111669156685,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.findExpressionStartEndTokens<const>:ANY(),<empty>,,true,,,findExpressionStartEndTokens,,,0,ANY()
111669156686,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.linenr<const>:int(),<empty>,,true,,,linenr,,,0,int()
111669156687,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.suggestInitializationList:void(Token*,ANY)",<empty>,,true,,,suggestInitializationList,,,0,"void(Token*,ANY)"
111669156688,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isImplicitlyVirtual:<unresolvedSignature>(1),<empty>,,true,,,isImplicitlyVirtual,,,0,<unresolvedSignature>
111669156689,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isAttributeMaybeUnused:<unresolvedSignature>(0),<empty>,,true,,,isAttributeMaybeUnused,,,0,<unresolvedSignature>
111669156690,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.pop_front:<unresolvedSignature>(0),<empty>,,true,,,pop_front,,,0,<unresolvedSignature>
111669156691,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.checkFunctionUsage:<unresolvedSignature>(2),<empty>,,true,,,checkFunctionUsage,,,0,<unresolvedSignature>
111669156692,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.unusedPrivateFunctionError:<unresolvedSignature>(3),<empty>,,true,,,unusedPrivateFunctionError,,,0,<unresolvedSignature>
111669156693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isArrayOrPointer<const>:bool(),<empty>,,true,,,isArrayOrPointer,,,0,bool()
111669156694,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.memsetError:void(Token*,ANY,ANY,ANY,bool)",<empty>,,true,,,memsetError,,,0,"void(Token*,ANY,ANY,ANY,bool)"
111669156695,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.checkMemsetType:void(Scope*,Token*,Scope*,bool,ANY)",<empty>,,true,,,checkMemsetType,,,0,"void(Scope*,Token*,Scope*,bool,ANY)"
111669156696,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.checkMemsetType:<unresolvedSignature>(5),<empty>,,true,,,checkMemsetType,,,0,<unresolvedSignature>
111669156697,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.mallocOnClassWarning:void(Token*,ANY,Token*)",<empty>,,true,,,mallocOnClassWarning,,,0,"void(Token*,ANY,Token*)"
111669156698,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.hasVirtualSpecifier<const>:bool(),<empty>,,true,,,hasVirtualSpecifier,,,0,bool()
111669156699,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.mallocOnClassError:<unresolvedSignature>(4),<empty>,,true,,,mallocOnClassError,,,0,<unresolvedSignature>
111669156700,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.memsetError:<unresolvedSignature>(4),<empty>,,true,,,memsetError,,,0,<unresolvedSignature>
111669156701,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.memsetErrorReference:void(Token*,ANY,ANY)",<empty>,,true,,,memsetErrorReference,,,0,"void(Token*,ANY,ANY)"
111669156702,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.mallocOnClassError:void(Token*,ANY,Token*,ANY)",<empty>,,true,,,mallocOnClassError,,,0,"void(Token*,ANY,Token*,ANY)"
111669156703,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.memsetErrorFloat:void(Token*,ANY)",<empty>,,true,,,memsetErrorFloat,,,0,"void(Token*,ANY)"
111669156704,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasBody:<unresolvedSignature>(0),<empty>,,true,,,hasBody,,,0,<unresolvedSignature>
111669156705,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.strAt:<unresolvedSignature>(1),<empty>,,true,,,strAt,,,0,<unresolvedSignature>
111669156706,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.checkReturnPtrThis:<unresolvedSignature>(4),<empty>,,true,,,checkReturnPtrThis,,,0,<unresolvedSignature>
111669156707,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.checkReturnPtrThis:void(Scope*,Function*,Token*,Token*,ANY)",<empty>,,true,,,checkReturnPtrThis,,,0,"void(Scope*,Function*,Token*,Token*,ANY)"
111669156708,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.simpleMatch:<unresolvedSignature>(3),<empty>,,true,,,simpleMatch,,,0,<unresolvedSignature>
111669156709,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isConst:<unresolvedSignature>(0),<empty>,,true,,,isConst,,,0,<unresolvedSignature>
111669156710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.checkReturnPtrThis:<unresolvedSignature>(5),<empty>,,true,,,checkReturnPtrThis,,,0,<unresolvedSignature>
111669156711,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Library.isScopeNoReturn<const>:bool(Token*,ANY)",<empty>,,true,,,isScopeNoReturn,,,0,"bool(Token*,ANY)"
111669156712,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.nameToken:<unresolvedSignature>(0),<empty>,,true,,,nameToken,,,0,<unresolvedSignature>
111669156713,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.hasAllocation:bool(Function*,Scope*)",<empty>,,true,,,hasAllocation,,,0,"bool(Function*,Scope*)"
111669156714,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.hasAllocationInIfScope:bool(Function*,Scope*,Token*)",<empty>,,true,,,hasAllocationInIfScope,,,0,"bool(Function*,Scope*,Token*)"
111669156715,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.hasAllocation:bool(Function*,Scope*,Token*,Token*)",<empty>,,true,,,hasAllocation,,,0,"bool(Function*,Scope*,Token*,Token*)"
111669156716,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.isMemberVar:bool(Scope*,Token*)",<empty>,,true,,,isMemberVar,,,0,"bool(Scope*,Token*)"
111669156717,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.virtualDestructorError:void(Token*,ANY,ANY,bool)",<empty>,,true,,,virtualDestructorError,,,0,"void(Token*,ANY,ANY,bool)"
111669156718,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.virtualDestructorError:<unresolvedSignature>(4),<empty>,,true,,,virtualDestructorError,,,0,<unresolvedSignature>
111669156719,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.debugMessage:<unresolvedSignature>(3),<empty>,,true,,,debugMessage,,,0,<unresolvedSignature>
111669156720,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isFriend<const>:bool(),<empty>,,true,,,isFriend,,,0,bool()
111669156721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.hasRvalRefQualifier<const>:bool(),<empty>,,true,,,hasRvalRefQualifier,,,0,bool()
111669156722,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():bool(Token*,Token*)",<empty>,,true,,,<operator>(),,,0,"bool(Token*,Token*)"
111669156723,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.checkConstFunc:bool(Scope*,Function*,CheckClass.MemberAccess&)",<empty>,,true,,,checkConstFunc,,,0,"bool(Scope*,Function*,CheckClass.MemberAccess&)"
111669156724,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.hasLvalRefQualifier<const>:bool(),<empty>,,true,,,hasLvalRefQualifier,,,0,bool()
111669156725,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isInline<const>:bool(),<empty>,,true,,,isInline,,,0,bool()
111669156726,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.checkConstError:void(Token*,ANY,ANY,bool,bool)",<empty>,,true,,,checkConstError,,,0,"void(Token*,ANY,ANY,bool,bool)"
111669156727,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.checkConstError2:void(Token*,Token*,ANY,ANY,bool,bool)",<empty>,,true,,,checkConstError2,,,0,"void(Token*,Token*,ANY,ANY,bool,bool)"
111669156728,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isVariadic<const>:bool(),<empty>,,true,,,isVariadic,,,0,bool()
111669156729,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.min<int>:<unresolvedSignature>(2),<empty>,,true,,,min<int>,,,0,<unresolvedSignature>
111669156730,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.returnsConst:<unresolvedSignature>(1),<empty>,,true,,,returnsConst,,,0,<unresolvedSignature>
111669156731,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findFunction:<unresolvedSignature>(2),<empty>,,true,,,findFunction,,,0,<unresolvedSignature>
111669156732,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>():bool(ValueType*),<empty>,,true,,,<operator>(),,,0,bool(ValueType*)
111669156733,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isSmartPointer<const>:bool(),<empty>,,true,,,isSmartPointer,,,0,bool()
111669156734,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():bool(Token*,Scope*)",<empty>,,true,,,<operator>(),,,0,"bool(Token*,Scope*)"
111669156735,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():bool(Token*,Scope*,Function*)",<empty>,,true,,,<operator>(),,,0,"bool(Token*,Scope*,Function*)"
111669156736,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isConstructor:<unresolvedSignature>(0),<empty>,,true,,,isConstructor,,,0,<unresolvedSignature>
111669156737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Scope.getVariable<const>:Variable*(ANY),<empty>,,true,,,getVariable,,,0,Variable*(ANY)
111669156738,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.initializerListError:<unresolvedSignature>(5),<empty>,,true,,,initializerListError,,,0,<unresolvedSignature>
111669156739,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.initializerListError:<unresolvedSignature>(4),<empty>,,true,,,initializerListError,,,0,<unresolvedSignature>
111669156740,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.selfInitializationError:void(Token*,ANY)",<empty>,,true,,,selfInitializationError,,,0,"void(Token*,ANY)"
111669156741,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isDestructor<const>:bool(),<empty>,,true,,,isDestructor,,,0,bool()
111669156742,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.getVirtualFunctionCalls:ANY(Function&,ANY)",<empty>,,true,,,getVirtualFunctionCalls,,,0,"ANY(Function&,ANY)"
111669156743,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.getFirstVirtualFunctionCallStack:void(ANY,Token*,ANY)",<empty>,,true,,,getFirstVirtualFunctionCallStack,,,0,"void(ANY,Token*,ANY)"
111669156744,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.function:<unresolvedSignature>(0),<empty>,,true,,,function,,,0,<unresolvedSignature>
111669156745,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.hasOverrideSpecifier<const>:bool(),<empty>,,true,,,hasOverrideSpecifier,,,0,bool()
111669156746,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.pureVirtualFunctionCallInConstructorError:<unresolvedSignature>(3),<empty>,,true,,,pureVirtualFunctionCallInConstructorError,,,0,<unresolvedSignature>
111669156747,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.hasFinalSpecifier<const>:bool(),<empty>,,true,,,hasFinalSpecifier,,,0,bool()
111669156748,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isFinalType<const>:bool(),<empty>,,true,,,isFinalType,,,0,bool()
111669156749,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.virtualFunctionCallInConstructorError:<unresolvedSignature>(3),<empty>,,true,,,virtualFunctionCallInConstructorError,,,0,<unresolvedSignature>
111669156750,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.list<const Token *>:<unresolvedSignature>(0),<empty>,,true,,,list<const Token *>,,,0,<unresolvedSignature>
111669156751,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.ignorefunction<const>:bool(ANY),<empty>,,true,,,ignorefunction,,,0,bool(ANY)
111669156752,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ErrorPathItem:<unresolvedSignature>(2),<empty>,,true,,,ErrorPathItem,,,0,<unresolvedSignature>
111669156753,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.CWE:<unresolvedSignature>(1),<empty>,,true,,,CWE,,,0,<unresolvedSignature>
111669156754,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getDuplInheritedMembersRecursive:ANY(Type*,Type*,bool)",<empty>,,true,,,getDuplInheritedMembersRecursive,,,0,"ANY(Type*,Type*,bool)"
111669156755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Function.argsMatch<const>:bool(Scope*,Token*,Token*,ANY,int)",<empty>,,true,,,argsMatch,,,0,"bool(Scope*,Token*,Token*,ANY,int)"
111669156756,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getDuplInheritedMemberFunctionsRecursive:ANY(Type*,Type*,bool)",<empty>,,true,,,getDuplInheritedMemberFunctionsRecursive,,,0,"ANY(Type*,Type*,bool)"
111669156757,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.duplInheritedMembersError:<unresolvedSignature>(7),<empty>,,true,,,duplInheritedMembersError,,,0,<unresolvedSignature>
111669156758,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.duplInheritedMembersError:<unresolvedSignature>(8),<empty>,,true,,,duplInheritedMembersError,,,0,<unresolvedSignature>
111669156759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.copyCtorAndEqOperatorError:void(Token*,ANY,bool,bool)",<empty>,,true,,,copyCtorAndEqOperatorError,,,0,"void(Token*,ANY,bool,bool)"
111669156760,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,char,<empty>,,true,,,char,,,0,
111669156761,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findsimplematch:<unresolvedSignature>(4),<empty>,,true,,,findsimplematch,,,0,<unresolvedSignature>
111669156762,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.equal:<unresolvedSignature>(4),<empty>,,true,,,equal,,,0,<unresolvedSignature>
111669156763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueFlow.getSizeOf:ANY(ValueType&,Settings&,int)",<empty>,,true,,,getSizeOf,,,0,"ANY(ValueType&,Settings&,int)"
111669156764,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.checkThisUseAfterFreeRecursive:<unresolvedSignature>(5),<empty>,,true,,,checkThisUseAfterFreeRecursive,,,0,<unresolvedSignature>
111669156765,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.checkThisUseAfterFreeRecursive:bool(Scope*,Function*,Variable*,ANY,Token*&)",<empty>,,true,,,checkThisUseAfterFreeRecursive,,,0,"bool(Scope*,Function*,Variable*,ANY,Token*&)"
111669156766,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckClass.unsafeClassRefMemberError:void(Token*,ANY)",<empty>,,true,,,unsafeClassRefMemberError,,,0,"void(Token*,ANY)"
111669156767,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorLogger.toxml:ANY(ANY),<empty>,,true,,,toxml,,,0,ANY(ANY)
111669156768,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Scope.isAnonymous<const>:bool(),<empty>,,true,,,isAnonymous,,,0,bool()
111669156769,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.column<const>:int(),<empty>,,true,,,column,,,0,int()
111669156770,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.<operator>():<unresolvedSignature>(1),<empty>,,true,,,<operator>(),,,0,<unresolvedSignature>
111669156771,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.strToInt<int>:<unresolvedSignature>(1),<empty>,,true,,,strToInt<int>,,,0,<unresolvedSignature>
111669156772,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.strToInt<std::size_t>:<unresolvedSignature>(1),<empty>,,true,,,strToInt<std::size_t>,,,0,<unresolvedSignature>
111669156773,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckClass.logChecker:void(char*),<empty>,,true,,,logChecker,,,0,void(char*)
111669156774,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isSameLocation:<unresolvedSignature>(1),<empty>,,true,,,isSameLocation,,,0,<unresolvedSignature>
111669156775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.isC<const>:bool(),<empty>,,true,,,isC,,,0,bool()
111669156776,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.noConstructorError:<unresolvedSignature>(3),<empty>,,true,,,noConstructorError,,,0,<unresolvedSignature>
111669156777,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.noExplicitConstructorError:<unresolvedSignature>(3),<empty>,,true,,,noExplicitConstructorError,,,0,<unresolvedSignature>
111669156778,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.copyConstructorShallowCopyError:<unresolvedSignature>(2),<empty>,,true,,,copyConstructorShallowCopyError,,,0,<unresolvedSignature>
111669156779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.uninitVarError:<unresolvedSignature>(7),<empty>,,true,,,uninitVarError,,,0,<unresolvedSignature>
111669156780,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.missingMemberCopyError:<unresolvedSignature>(4),<empty>,,true,,,missingMemberCopyError,,,0,<unresolvedSignature>
111669156781,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.operatorEqVarError:<unresolvedSignature>(4),<empty>,,true,,,operatorEqVarError,,,0,<unresolvedSignature>
111669156782,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.memsetErrorReference:<unresolvedSignature>(3),<empty>,,true,,,memsetErrorReference,,,0,<unresolvedSignature>
111669156783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.memsetErrorFloat:<unresolvedSignature>(2),<empty>,,true,,,memsetErrorFloat,,,0,<unresolvedSignature>
111669156784,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.mallocOnClassWarning:<unresolvedSignature>(3),<empty>,,true,,,mallocOnClassWarning,,,0,<unresolvedSignature>
111669156785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.checkConstError:<unresolvedSignature>(4),<empty>,,true,,,checkConstError,,,0,<unresolvedSignature>
111669156786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.suggestInitializationList:<unresolvedSignature>(2),<empty>,,true,,,suggestInitializationList,,,0,<unresolvedSignature>
111669156787,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.selfInitializationError:<unresolvedSignature>(2),<empty>,,true,,,selfInitializationError,,,0,<unresolvedSignature>
111669156788,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.copyCtorAndEqOperatorError:<unresolvedSignature>(4),<empty>,,true,,,copyCtorAndEqOperatorError,,,0,<unresolvedSignature>
111669156789,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.unsafeClassRefMemberError:<unresolvedSignature>(2),<empty>,,true,,,unsafeClassRefMemberError,,,0,<unresolvedSignature>
111669156790,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.at:<unresolvedSignature>(1),<empty>,,true,,,at,,,0,<unresolvedSignature>
111669156791,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckCondition.assignIfParseScope:bool(Token*,Token*,int,bool,char,longlongint)",<empty>,,true,,,assignIfParseScope,,,0,"bool(Token*,Token*,int,bool,char,longlongint)"
111669156792,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.string:<unresolvedSignature>(2),<empty>,,true,,,string,,,0,<unresolvedSignature>
111669156793,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckCondition.mismatchingBitAndError:void(Token*,longlongint,Token*,longlongint)",<empty>,,true,,,mismatchingBitAndError,,,0,"void(Token*,longlongint,Token*,longlongint)"
111669156794,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckCondition.assignIfError:void(Token*,Token*,ANY,bool)",<empty>,,true,,,assignIfError,,,0,"void(Token*,Token*,ANY,bool)"
111669156795,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getnumchildren:void(Token*,ANY)",<empty>,,true,,,getnumchildren,,,0,"void(Token*,ANY)"
111669156796,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Scope.isLocal<const>:bool(),<empty>,,true,,,isLocal,,,0,bool()
111669156797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasIfdef:<unresolvedSignature>(2),<empty>,,true,,,hasIfdef,,,0,<unresolvedSignature>
111669156798,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckCondition.comparisonError:void(Token*,ANY,longlongint,ANY,longlongint,bool)",<empty>,,true,,,comparisonError,,,0,"void(Token*,ANY,longlongint,ANY,longlongint,bool)"
111669156799,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MathLib.isNegative:bool(ANY),<empty>,,true,,,isNegative,,,0,bool(ANY)
111669156800,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.duplicateConditionError:<unresolvedSignature>(3),<empty>,,true,,,duplicateConditionError,,,0,<unresolvedSignature>
111669156801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckCondition.isOverlappingCond:bool(Token*,Token*,bool)",<empty>,,true,,,isOverlappingCond,,,0,"bool(Token*,Token*,bool)"
111669156802,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.oppositeElseIfConditionError:<unresolvedSignature>(3),<empty>,,true,,,oppositeElseIfConditionError,,,0,<unresolvedSignature>
111669156803,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckCondition.isAliased:bool(ANY),<empty>,,true,,,isAliased,,,0,bool(ANY)
111669156804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckCondition.oppositeInnerConditionError:void(Token*,Token*,ANY)",<empty>,,true,,,oppositeInnerConditionError,,,0,"void(Token*,Token*,ANY)"
111669156805,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckCondition.identicalInnerConditionError:void(Token*,Token*,ANY)",<empty>,,true,,,identicalInnerConditionError,,,0,"void(Token*,Token*,ANY)"
111669156806,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckCondition.identicalConditionAfterEarlyExitError:void(Token*,Token*,ANY)",<empty>,,true,,,identicalConditionAfterEarlyExitError,,,0,"void(Token*,Token*,ANY)"
111669156807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"isVariablesChanged:bool(Token*,Token*,int,ANY,Settings&)",<empty>,,true,,,isVariablesChanged,,,0,"bool(Token*,Token*,int,ANY,Settings&)"
111669156808,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,innerSmtString:ANY(Token*),<empty>,,true,,,innerSmtString,,,0,ANY(Token*)
111669156809,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():void(std.string&,bool)",<empty>,,true,,,<operator>(),,,0,"void(std.string&,bool)"
111669156810,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sign:ANY(),<empty>,,true,,,sign,,,0,ANY()
111669156811,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.lowest:<unresolvedSignature>(0),<empty>,,true,,,lowest,,,0,<unresolvedSignature>
111669156812,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getvalue3:ANY(),<empty>,,true,,,getvalue3<T>,,,0,ANY()
111669156813,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,invertOperatorForOperandSwap:ANY(ANY),<empty>,,true,,,invertOperatorForOperandSwap,,,0,ANY(ANY)
111669156814,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MathLib.isFloat:bool(ANY),<empty>,,true,,,isFloat,,,0,bool(ANY)
111669156815,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"parseComparison:bool(Token*,bool&,ANY,ANY,Token*&,bool&)",<empty>,,true,,,parseComparison,,,0,"bool(Token*,bool&,ANY,ANY,Token*&,bool&)"
111669156816,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"conditionString:ANY(bool,Token*,ANY,ANY)",<empty>,,true,,,conditionString,,,0,"ANY(bool,Token*,ANY,ANY)"
111669156817,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,conditionString:ANY(Token*),<empty>,,true,,,conditionString,,,0,ANY(Token*)
111669156818,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isConstexpr<const>:bool(),<empty>,,true,,,isConstexpr,,,0,bool()
111669156819,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckCondition.redundantConditionError:void(Token*,ANY,bool)",<empty>,,true,,,redundantConditionError,,,0,"void(Token*,ANY,bool)"
111669156820,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckCondition.incorrectLogicOperatorError:void(Token*,ANY,bool,bool,ANY)",<empty>,,true,,,incorrectLogicOperatorError,,,0,"void(Token*,ANY,bool,bool,ANY)"
111669156821,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"MathLib.toDoubleNumber:double(ANY,Token*)",<empty>,,true,,,toDoubleNumber,,,0,"double(ANY,Token*)"
111669156822,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"MathLib.toBigNumber:longlongint(ANY,Token*)",<empty>,,true,,,toBigNumber,,,0,"longlongint(ANY,Token*)"
111669156823,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"MathLib.toBigUNumber:unsigned longlongint(ANY,Token*)",<empty>,,true,,,toBigUNumber,,,0,"unsigned longlongint(ANY,Token*)"
111669156824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getvalue:double(int,double,double)",<empty>,,true,,,getvalue<double>,,,0,"double(int,double,double)"
111669156825,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"checkFloatRelation:bool(ANY,double,double)",<empty>,,true,,,checkFloatRelation,,,0,"bool(ANY,double,double)"
111669156826,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getvalue:unsigned longlongint(int,unsigned longlongint,unsigned longlongint)",<empty>,,true,,,getvalue<MathLib::biguint>,,,0,"unsigned longlongint(int,unsigned longlongint,unsigned longlongint)"
111669156827,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.checkIntRelation:<unresolvedSignature>(3),<empty>,,true,,,checkIntRelation,,,0,<unresolvedSignature>
111669156828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getvalue:longlongint(int,longlongint,longlongint)",<empty>,,true,,,getvalue<MathLib::bigint>,,,0,"longlongint(int,longlongint,longlongint)"
111669156829,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.incorrectLogicOperatorError:<unresolvedSignature>(5),<empty>,,true,,,incorrectLogicOperatorError,,,0,<unresolvedSignature>
111669156830,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sufficientCondition:<unresolvedSignature>(7),<empty>,,true,,,sufficientCondition,,,0,<unresolvedSignature>
111669156831,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"MathLib.isLessEqual:bool(ANY,ANY)",<empty>,,true,,,isLessEqual,,,0,"bool(ANY,ANY)"
111669156832,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckCondition.moduloAlwaysTrueFalseError:void(Token*,ANY)",<empty>,,true,,,moduloAlwaysTrueFalseError,,,0,"void(Token*,ANY)"
111669156833,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isConstVarExpression:<unresolvedSignature>(2),<empty>,,true,,,isConstVarExpression,,,0,<unresolvedSignature>
111669156834,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.alwaysTrueFalseError:<unresolvedSignature>(3),<empty>,,true,,,alwaysTrueFalseError,,,0,<unresolvedSignature>
111669156835,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.invalidTestForOverflow:<unresolvedSignature>(3),<empty>,,true,,,invalidTestForOverflow,,,0,<unresolvedSignature>
111669156836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckCondition.invalidTestForOverflow:void(Token*,ValueType*,ANY)",<empty>,,true,,,invalidTestForOverflow,,,0,"void(Token*,ValueType*,ANY)"
111669156837,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckCondition.compareValueOutOfTypeRangeError:void(Token*,ANY,longlongint,bool)",<empty>,,true,,,compareValueOutOfTypeRangeError,,,0,"void(Token*,ANY,longlongint,bool)"
111669156838,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueType.str<const>:ANY(),<empty>,,true,,,str,,,0,ANY()
111669156839,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.assignIfError:<unresolvedSignature>(4),<empty>,,true,,,assignIfError,,,0,<unresolvedSignature>
111669156840,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.comparisonError:<unresolvedSignature>(6),<empty>,,true,,,comparisonError,,,0,<unresolvedSignature>
111669156841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckCondition.duplicateConditionError:void(Token*,Token*,ANY)",<empty>,,true,,,duplicateConditionError,,,0,"void(Token*,Token*,ANY)"
111669156842,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.redundantConditionError:<unresolvedSignature>(3),<empty>,,true,,,redundantConditionError,,,0,<unresolvedSignature>
111669156843,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.moduloAlwaysTrueFalseError:<unresolvedSignature>(2),<empty>,,true,,,moduloAlwaysTrueFalseError,,,0,<unresolvedSignature>
111669156844,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.compareValueOutOfTypeRangeError:<unresolvedSignature>(4),<empty>,,true,,,compareValueOutOfTypeRangeError,,,0,<unresolvedSignature>
111669156845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"isMisraRuleActive:bool(ANY,ANY)",<empty>,,true,,,isMisraRuleActive,,,0,"bool(ANY,ANY)"
111669156846,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():void(std.string&,Settings&,std.set<std.string>&,std.map<std.string,std.string>&,std.string&)",<empty>,,true,,,<operator>(),,,0,"void(std.string&,Settings&,std.set<std.string>&,std.map<std.string,std.string>&,std.string&)"
111669156847,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isNoExcept<const>:bool(),<empty>,,true,,,isNoExcept,,,0,bool()
111669156848,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckExceptionSafety.destructorsError:void(Token*,ANY)",<empty>,,true,,,destructorsError,,,0,"void(Token*,ANY)"
111669156849,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckExceptionSafety.deallocThrowError:void(Token*,ANY)",<empty>,,true,,,deallocThrowError,,,0,"void(Token*,ANY)"
111669156850,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckExceptionSafety.rethrowCopyError:void(Token*,ANY)",<empty>,,true,,,rethrowCopyError,,,0,"void(Token*,ANY)"
111669156851,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isThrow<const>:bool(),<empty>,,true,,,isThrow,,,0,bool()
111669156852,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"functionThrowsRecursive:Token*(Function*,ANY)",<empty>,,true,,,functionThrowsRecursive,,,0,"Token*(Function*,ANY)"
111669156853,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isAttributeNothrow<const>:bool(),<empty>,,true,,,isAttributeNothrow,,,0,bool()
111669156854,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckExceptionSafety.unhandledExceptionSpecificationError:void(Token*,Token*,ANY)",<empty>,,true,,,unhandledExceptionSpecificationError,,,0,"void(Token*,Token*,ANY)"
111669156855,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.destructorsError:<unresolvedSignature>(2),<empty>,,true,,,destructorsError,,,0,<unresolvedSignature>
111669156856,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.deallocThrowError:<unresolvedSignature>(2),<empty>,,true,,,deallocThrowError,,,0,<unresolvedSignature>
111669156857,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.rethrowCopyError:<unresolvedSignature>(2),<empty>,,true,,,rethrowCopyError,,,0,<unresolvedSignature>
111669156858,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.unhandledExceptionSpecificationError:<unresolvedSignature>(3),<empty>,,true,,,unhandledExceptionSpecificationError,,,0,<unresolvedSignature>
111669156859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckFunctions.invalidFunctionArgError:void(Token*,ANY,int,ValueFlow.Value*,ANY)",<empty>,,true,,,invalidFunctionArgError,,,0,"void(Token*,ANY,int,ValueFlow.Value*,ANY)"
111669156860,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Library.validarg<const>:ANY(Token*,int)",<empty>,,true,,,validarg,,,0,"ANY(Token*,int)"
111669156861,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Library.isboolargbad<const>:bool(Token*,int)",<empty>,,true,,,isboolargbad,,,0,"bool(Token*,int)"
111669156862,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckFunctions.invalidFunctionArgBoolError:void(Token*,ANY,int)",<empty>,,true,,,invalidFunctionArgBoolError,,,0,"void(Token*,ANY,int)"
111669156863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Library.isIntArgValid<const>:bool(Token*,int,longlongint)",<empty>,,true,,,isIntArgValid,,,0,"bool(Token*,int,longlongint)"
111669156864,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Library.isargstrz<const>:bool(Token*,int)",<empty>,,true,,,isargstrz,,,0,"bool(Token*,int)"
111669156865,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckFunctions.invalidFunctionArgStrError:void(Token*,ANY,int)",<empty>,,true,,,invalidFunctionArgStrError,,,0,"void(Token*,ANY,int)"
111669156866,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isVariablesChanged:<unresolvedSignature>(5),<empty>,,true,,,isVariablesChanged,,,0,<unresolvedSignature>
111669156867,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setprecision:<unresolvedSignature>(1),<empty>,,true,,,setprecision,,,0,<unresolvedSignature>
111669156868,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isAttributeNodiscard<const>:bool(),<empty>,,true,,,isAttributeNodiscard,,,0,bool()
111669156869,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckFunctions.ignoredReturnValueError:void(Token*,ANY)",<empty>,,true,,,ignoredReturnValueError,,,0,"void(Token*,ANY)"
111669156870,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckFunctions.ignoredReturnErrorCode:void(Token*,ANY)",<empty>,,true,,,ignoredReturnErrorCode,,,0,"void(Token*,ANY)"
111669156871,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.isOneNumber:bool(ANY),<empty>,,true,,,isOneNumber,,,0,bool(ANY)
111669156872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.mathfunctionCallWarning:<unresolvedSignature>(3),<empty>,,true,,,mathfunctionCallWarning,,,0,<unresolvedSignature>
111669156873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckFunctions.memsetFloatError:void(Token*,ANY)",<empty>,,true,,,memsetFloatError,,,0,"void(Token*,ANY)"
111669156874,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Platform.signedCharMin<const>:longlong(),<empty>,,true,,,signedCharMin,,,0,longlong()
111669156875,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Platform.unsignedCharMax<const>:longlong(),<empty>,,true,,,unsignedCharMax,,,0,longlong()
111669156876,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckFunctions.memsetValueOutOfRangeError:void(Token*,ANY)",<empty>,,true,,,memsetValueOutOfRangeError,,,0,"void(Token*,ANY)"
111669156877,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckFunctions.useStandardLibraryError:void(Token*,ANY)",<empty>,,true,,,useStandardLibraryError,,,0,"void(Token*,ANY)"
111669156878,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.invalidFunctionArgError:<unresolvedSignature>(5),<empty>,,true,,,invalidFunctionArgError,,,0,<unresolvedSignature>
111669156879,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.invalidFunctionArgBoolError:<unresolvedSignature>(3),<empty>,,true,,,invalidFunctionArgBoolError,,,0,<unresolvedSignature>
111669156880,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.invalidFunctionArgStrError:<unresolvedSignature>(3),<empty>,,true,,,invalidFunctionArgStrError,,,0,<unresolvedSignature>
111669156881,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ignoredReturnValueError:<unresolvedSignature>(2),<empty>,,true,,,ignoredReturnValueError,,,0,<unresolvedSignature>
111669156882,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.memsetFloatError:<unresolvedSignature>(2),<empty>,,true,,,memsetFloatError,,,0,<unresolvedSignature>
111669156883,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.memsetValueOutOfRangeError:<unresolvedSignature>(2),<empty>,,true,,,memsetValueOutOfRangeError,,,0,<unresolvedSignature>
111669156884,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.useStandardLibraryError:<unresolvedSignature>(2),<empty>,,true,,,useStandardLibraryError,,,0,<unresolvedSignature>
111669156885,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckIO.coutCerrMisusageError:void(Token*,ANY)",<empty>,,true,,,coutCerrMisusageError,,,0,"void(Token*,ANY)"
111669156886,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Platform.isWindows<const>:bool(),<empty>,,true,,,isWindows,,,0,bool()
111669156887,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.emplace:<unresolvedSignature>(2),<empty>,,true,,,emplace,,,0,<unresolvedSignature>
111669156888,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Filepointer:<unresolvedSignature>(1),<empty>,,true,,,Filepointer,,,0,<unresolvedSignature>
111669156889,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.strValue<const>:ANY(),<empty>,,true,,,strValue,,,0,ANY()
111669156890,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckIO.fflushOnInputStreamError:void(Token*,ANY)",<empty>,,true,,,fflushOnInputStreamError,,,0,"void(Token*,ANY)"
111669156891,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Library.isFunctionConst<const>:bool(ANY,bool)",<empty>,,true,,,isFunctionConst,,,0,"bool(ANY,bool)"
111669156892,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getVariableFromVarId:<unresolvedSignature>(1),<empty>,,true,,,getVariableFromVarId,,,0,<unresolvedSignature>
111669156893,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckIO.incompatibleFileOpenError:void(Token*,ANY)",<empty>,,true,,,incompatibleFileOpenError,,,0,"void(Token*,ANY)"
111669156894,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getMode:OpenMode(ANY),<empty>,,true,,,getMode,,,0,OpenMode(ANY)
111669156895,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isalpha:<unresolvedSignature>(1),<empty>,,true,,,isalpha,,,0,<unresolvedSignature>
111669156896,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.dimensionKnown<const>:bool(int),<empty>,,true,,,dimensionKnown,,,0,bool(int)
111669156897,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.dimension<const>:longlongint(int),<empty>,,true,,,dimension,,,0,longlongint(int)
111669156898,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isTokValue:<unresolvedSignature>(0),<empty>,,true,,,isTokValue,,,0,<unresolvedSignature>
111669156899,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std::string,<empty>,,true,,,std::string,,,0,
111669156900,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckIO.invalidScanfFormatWidthError:void(Token*,int,int,Variable*,ANY)",<empty>,,true,,,invalidScanfFormatWidthError,,,0,"void(Token*,int,int,Variable*,ANY)"
111669156901,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckIO.invalidScanfArgTypeError_s:void(Token*,int,ANY,CheckIO.ArgumentInfo*)",<empty>,,true,,,invalidScanfArgTypeError_s,,,0,"void(Token*,int,ANY,CheckIO.ArgumentInfo*)"
111669156902,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.invalidScanfFormatWidthError:<unresolvedSignature>(5),<empty>,,true,,,invalidScanfFormatWidthError,,,0,<unresolvedSignature>
111669156903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckIO.invalidScanfArgTypeError_int:void(Token*,int,ANY,CheckIO.ArgumentInfo*,bool)",<empty>,,true,,,invalidScanfArgTypeError_int,,,0,"void(Token*,int,ANY,CheckIO.ArgumentInfo*,bool)"
111669156904,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.typesMatch:<unresolvedSignature>(2),<empty>,,true,,,typesMatch,,,0,<unresolvedSignature>
111669156905,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckIO.invalidScanfArgTypeError_float:void(Token*,int,ANY,CheckIO.ArgumentInfo*)",<empty>,,true,,,invalidScanfArgTypeError_float,,,0,"void(Token*,int,ANY,CheckIO.ArgumentInfo*)"
111669156906,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckIO.invalidLengthModifierError:void(Token*,int,ANY)",<empty>,,true,,,invalidLengthModifierError,,,0,"void(Token*,int,ANY)"
111669156907,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckIO.invalidPrintfArgTypeError_uint:void(Token*,int,ANY,CheckIO.ArgumentInfo*)",<empty>,,true,,,invalidPrintfArgTypeError_uint,,,0,"void(Token*,int,ANY,CheckIO.ArgumentInfo*)"
111669156908,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckIO.invalidPrintfArgTypeError_sint:void(Token*,int,ANY,CheckIO.ArgumentInfo*)",<empty>,,true,,,invalidPrintfArgTypeError_sint,,,0,"void(Token*,int,ANY,CheckIO.ArgumentInfo*)"
111669156909,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckIO.invalidPrintfArgTypeError_float:void(Token*,int,ANY,CheckIO.ArgumentInfo*)",<empty>,,true,,,invalidPrintfArgTypeError_float,,,0,"void(Token*,int,ANY,CheckIO.ArgumentInfo*)"
111669156910,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckIO.wrongPrintfScanfPosixParameterPositionError:void(Token*,ANY,int,int)",<empty>,,true,,,wrongPrintfScanfPosixParameterPositionError,,,0,"void(Token*,ANY,int,int)"
111669156911,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckIO.wrongPrintfScanfArgumentsError:void(Token*,ANY,int,int)",<empty>,,true,,,wrongPrintfScanfArgumentsError,,,0,"void(Token*,ANY,int,int)"
111669156912,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.str:void(char(&)[6]),<empty>,,true,,,str,,,0,void(char(&)[6])
111669156913,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.insertToken:<unresolvedSignature>(1),<empty>,,true,,,insertToken,,,0,<unresolvedSignature>
111669156914,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.str:void(char(&)[5]),<empty>,,true,,,str,,,0,void(char(&)[5])
111669156915,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.str:void(char(&)[8]),<empty>,,true,,,str,,,0,void(char(&)[8])
111669156916,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.str:void(char(&)[4]),<empty>,,true,,,str,,,0,void(char(&)[4])
111669156917,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isLong:void(bool),<empty>,,true,,,isLong,,,0,void(bool)
111669156918,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.str:void(char(&)[7]),<empty>,,true,,,str,,,0,void(char(&)[7])
111669156919,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isUnsigned:void(bool),<empty>,,true,,,isUnsigned,,,0,void(bool)
111669156920,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isSigned:void(bool),<empty>,,true,,,isSigned,,,0,void(bool)
111669156921,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.originalName:<unresolvedSignature>(1),<empty>,,true,,,originalName,,,0,<unresolvedSignature>
111669156922,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.tokType:void(Token.Type),<empty>,,true,,,tokType,,,0,void(Token.Type)
111669156923,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.originalName:void(char(&)[7]),<empty>,,true,,,originalName,,,0,void(char(&)[7])
111669156924,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isStlStringType<const>:bool(),<empty>,,true,,,isStlStringType,,,0,bool()
111669156925,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckIO.ArgumentInfo.isComplexType:bool(),<empty>,,true,,,isComplexType,,,0,bool()
111669156926,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckIO.argumentType:void(ANY,CheckIO.ArgumentInfo*)",<empty>,,true,,,argumentType,,,0,"void(ANY,CheckIO.ArgumentInfo*)"
111669156927,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"printfFormatType:void(ANY,ANY,bool)",<empty>,,true,,,printfFormatType,,,0,"void(ANY,ANY,bool)"
111669156928,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.stringify<const>:ANY(bool,bool,bool)",<empty>,,true,,,stringify,,,0,"ANY(bool,bool,bool)"
111669156929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.coutCerrMisusageError:<unresolvedSignature>(2),<empty>,,true,,,coutCerrMisusageError,,,0,<unresolvedSignature>
111669156930,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fflushOnInputStreamError:<unresolvedSignature>(2),<empty>,,true,,,fflushOnInputStreamError,,,0,<unresolvedSignature>
111669156931,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.incompatibleFileOpenError:<unresolvedSignature>(2),<empty>,,true,,,incompatibleFileOpenError,,,0,<unresolvedSignature>
111669156932,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.wrongPrintfScanfArgumentsError:<unresolvedSignature>(4),<empty>,,true,,,wrongPrintfScanfArgumentsError,,,0,<unresolvedSignature>
111669156933,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.invalidScanfArgTypeError_s:<unresolvedSignature>(4),<empty>,,true,,,invalidScanfArgTypeError_s,,,0,<unresolvedSignature>
111669156934,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.invalidScanfArgTypeError_int:<unresolvedSignature>(5),<empty>,,true,,,invalidScanfArgTypeError_int,,,0,<unresolvedSignature>
111669156935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.invalidScanfArgTypeError_float:<unresolvedSignature>(4),<empty>,,true,,,invalidScanfArgTypeError_float,,,0,<unresolvedSignature>
111669156936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.invalidPrintfArgTypeError_uint:<unresolvedSignature>(4),<empty>,,true,,,invalidPrintfArgTypeError_uint,,,0,<unresolvedSignature>
111669156937,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.invalidPrintfArgTypeError_sint:<unresolvedSignature>(4),<empty>,,true,,,invalidPrintfArgTypeError_sint,,,0,<unresolvedSignature>
111669156938,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.invalidPrintfArgTypeError_float:<unresolvedSignature>(4),<empty>,,true,,,invalidPrintfArgTypeError_float,,,0,<unresolvedSignature>
111669156939,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.invalidLengthModifierError:<unresolvedSignature>(3),<empty>,,true,,,invalidLengthModifierError,,,0,<unresolvedSignature>
111669156940,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.wrongPrintfScanfPosixParameterPositionError:<unresolvedSignature>(4),<empty>,,true,,,wrongPrintfScanfPosixParameterPositionError,,,0,<unresolvedSignature>
111669156941,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.isresource:bool(int),<empty>,,true,,,isresource,,,0,bool(int)
111669156942,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckMemoryLeak.resourceLeakError<const>:void(Token*,ANY)",<empty>,,true,,,resourceLeakError,,,0,"void(Token*,ANY)"
111669156943,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckMemoryLeak.memleakError<const>:void(Token*,ANY)",<empty>,,true,,,memleakError,,,0,"void(Token*,ANY)"
111669156944,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckMemoryLeak.mismatchAllocDealloc<const>:void(ANY,ANY)",<empty>,,true,,,mismatchAllocDealloc,,,0,"void(ANY,ANY)"
111669156945,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckMemoryLeak.deallocuseError<const>:void(Token*,ANY)",<empty>,,true,,,deallocuseError,,,0,"void(Token*,ANY)"
111669156946,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getFunctionName:<unresolvedSignature>(1),<empty>,,true,,,getFunctionName,,,0,<unresolvedSignature>
111669156947,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckLeakAutoVar.checkScope:bool(Token*,VarInfo&,ANY,int)",<empty>,,true,,,checkScope,,,0,"bool(Token*,VarInfo&,ANY,int)"
111669156948,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getReturnValueFromOutparamAlloc:<unresolvedSignature>(2),<empty>,,true,,,getReturnValueFromOutparamAlloc,,,0,<unresolvedSignature>
111669156949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isVarTokComparison:<unresolvedSignature>(3),<empty>,,true,,,isVarTokComparison,,,0,<unresolvedSignature>
111669156950,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VarInfo.erase:void(int),<empty>,,true,,,erase,,,0,void(int)
111669156951,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VarInfo.reallocToAlloc:void(int),<empty>,,true,,,reallocToAlloc,,,0,void(int)
111669156952,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VarInfo.clear:void(),<empty>,,true,,,clear,,,0,void()
111669156953,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.InternalError:<unresolvedSignature>(3),<empty>,,true,,,InternalError,,,0,<unresolvedSignature>
111669156954,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isVariable<const>:bool(),<empty>,,true,,,isVariable,,,0,bool()
111669156955,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckLeakAutoVar.changeAllocStatusIfRealloc:void(ANY,Token*,Token*)",<empty>,,true,,,changeAllocStatusIfRealloc,,,0,"void(ANY,Token*,Token*)"
111669156956,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VarInfo.swap:void(VarInfo&),<empty>,,true,,,swap,,,0,void(VarInfo&)
111669156957,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.managed:<unresolvedSignature>(0),<empty>,,true,,,managed,,,0,<unresolvedSignature>
111669156958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.isLeakIgnore<const>:bool(ANY),<empty>,,true,,,isLeakIgnore,,,0,bool(ANY)
111669156959,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.isUse<const>:bool(ANY),<empty>,,true,,,isUse,,,0,bool(ANY)
111669156960,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.possibleUsageAll:<unresolvedSignature>(1),<empty>,,true,,,possibleUsageAll,,,0,<unresolvedSignature>
111669156961,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.findmatch:Token*(Token*,char*,Token*,int)",<empty>,,true,,,findmatch,,,0,"Token*(Token*,char*,Token*,int)"
111669156962,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckLeakAutoVar.deallocUseError:void(Token*,ANY)",<empty>,,true,,,deallocUseError,,,0,"void(Token*,ANY)"
111669156963,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckLeakAutoVar.mismatchError:void(Token*,Token*,ANY)",<empty>,,true,,,mismatchError,,,0,"void(Token*,Token*,ANY)"
111669156964,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.doubleFreeError:<unresolvedSignature>(4),<empty>,,true,,,doubleFreeError,,,0,<unresolvedSignature>
111669156965,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.mismatchError:<unresolvedSignature>(3),<empty>,,true,,,mismatchError,,,0,<unresolvedSignature>
111669156966,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.leakError:<unresolvedSignature>(3),<empty>,,true,,,leakError,,,0,<unresolvedSignature>
111669156967,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.configurationInfo:<unresolvedSignature>(2),<empty>,,true,,,configurationInfo,,,0,<unresolvedSignature>
111669156968,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SymbolDatabase.getVariableFromVarId<const>:Variable*(int),<empty>,,true,,,getVariableFromVarId,,,0,Variable*(int)
111669156969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getOutparamAllocation:<unresolvedSignature>(2),<empty>,,true,,,getOutparamAllocation,,,0,<unresolvedSignature>
111669156970,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.deallocReturnError:<unresolvedSignature>(3),<empty>,,true,,,deallocReturnError,,,0,<unresolvedSignature>
111669156971,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckMemoryLeak.getReallocationType:CheckMemoryLeak.AllocType(Token*,int)",<empty>,,true,,,getReallocationType,,,0,"CheckMemoryLeak.AllocType(Token*,int)"
111669156972,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.deallocId<const>:int(char*),<empty>,,true,,,deallocId,,,0,int(char*)
111669156973,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.ismemory:bool(int),<empty>,,true,,,ismemory,,,0,bool(int)
111669156974,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckMemoryLeak.functionReturnType:CheckMemoryLeak.AllocType(Function*,ANY)",<empty>,,true,,,functionReturnType,,,0,"CheckMemoryLeak.AllocType(Function*,ANY)"
111669156975,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckMemoryLeak.resourceLeakError:void(Token*,ANY)",<empty>,,true,,,resourceLeakError,,,0,"void(Token*,ANY)"
111669156976,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckMemoryLeak.memleakError:void(Token*,ANY)",<empty>,,true,,,memleakError,,,0,"void(Token*,ANY)"
111669156977,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckMemoryLeak.reportErr:void(ANY,Severity,ANY,ANY,CWE&)",<empty>,,true,,,reportErr,,,0,"void(ANY,Severity,ANY,ANY,CWE&)"
111669156978,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.reportErr:<unresolvedSignature>(5),<empty>,,true,,,reportErr,,,0,<unresolvedSignature>
111669156979,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckMemoryLeak.getAllocationType:CheckMemoryLeak.AllocType(Token*,int,ANY)",<empty>,,true,,,getAllocationType,,,0,"CheckMemoryLeak.AllocType(Token*,int,ANY)"
111669156980,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.astIsVariableComparison:<unresolvedSignature>(3),<empty>,,true,,,astIsVariableComparison,,,0,<unresolvedSignature>
111669156981,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"astIsVariableComparison:Token*(Token*,ANY,ANY,Token**)",<empty>,,true,,,astIsVariableComparison,,,0,"Token*(Token*,ANY,ANY,Token**)"
111669156982,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckMemoryLeak.memleakUponReallocFailureError:void(Token*,ANY,ANY)",<empty>,,true,,,memleakUponReallocFailureError,,,0,"void(Token*,ANY,ANY)"
111669156983,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.memleakError:<unresolvedSignature>(2),<empty>,,true,,,memleakError,,,0,<unresolvedSignature>
111669156984,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.resourceLeakError:<unresolvedSignature>(2),<empty>,,true,,,resourceLeakError,,,0,<unresolvedSignature>
111669156985,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.deallocuseError:<unresolvedSignature>(2),<empty>,,true,,,deallocuseError,,,0,<unresolvedSignature>
111669156986,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.mismatchAllocDealloc:<unresolvedSignature>(2),<empty>,,true,,,mismatchAllocDealloc,,,0,<unresolvedSignature>
111669156987,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.memleakUponReallocFailureError:<unresolvedSignature>(3),<empty>,,true,,,memleakUponReallocFailureError,,,0,<unresolvedSignature>
111669156988,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckMemoryLeak.getDeallocationType:CheckMemoryLeak.AllocType(Token*,int)",<empty>,,true,,,getDeallocationType,,,0,"CheckMemoryLeak.AllocType(Token*,int)"
111669156989,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckMemoryLeakInClass.unsafeClassError:void(Token*,ANY,ANY)",<empty>,,true,,,unsafeClassError,,,0,"void(Token*,ANY,ANY)"
111669156990,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckMemoryLeakInClass.publicAllocationError:void(Token*,ANY)",<empty>,,true,,,publicAllocationError,,,0,"void(Token*,ANY)"
111669156991,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.publicAllocationError:<unresolvedSignature>(2),<empty>,,true,,,publicAllocationError,,,0,<unresolvedSignature>
111669156992,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.unsafeClassError:<unresolvedSignature>(3),<empty>,,true,,,unsafeClassError,,,0,<unresolvedSignature>
111669156993,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckMemoryLeakStructMember.checkStructVariable:void(Variable*),<empty>,,true,,,checkStructVariable,,,0,void(Variable*)
111669156994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckMemoryLeakStructMember.isMalloc:bool(Variable*),<empty>,,true,,,isMalloc,,,0,bool(Variable*)
111669156995,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():pair<const Token*,const Token*>(Token*,int)",<empty>,,true,,,<operator>(),,,0,"pair<const Token*,const Token*>(Token*,int)"
111669156996,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.varId:<unresolvedSignature>(0),<empty>,,true,,,varId,,,0,<unresolvedSignature>
111669156997,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getAllocationType:<unresolvedSignature>(2),<empty>,,true,,,getAllocationType,,,0,<unresolvedSignature>
111669156998,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckMemoryLeak.memoryLeak:void(Token*,ANY,CheckMemoryLeak.AllocType)",<empty>,,true,,,memoryLeak,,,0,"void(Token*,ANY,CheckMemoryLeak.AllocType)"
111669156999,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ifvar:<unresolvedSignature>(4),<empty>,,true,,,ifvar,,,0,<unresolvedSignature>
111669157000,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():bool(Token*,int)",<empty>,,true,,,<operator>(),,,0,"bool(Token*,int)"
111669157001,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckMemoryLeak.isReopenStandardStream:bool(Token*),<empty>,,true,,,isReopenStandardStream,,,0,bool(Token*)
111669157002,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckMemoryLeakNoVar.functionCallLeak:void(Token*,ANY,ANY)",<empty>,,true,,,functionCallLeak,,,0,"void(Token*,ANY,ANY)"
111669157003,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckMemoryLeak.isOpenDevNull:bool(Token*),<empty>,,true,,,isOpenDevNull,,,0,bool(Token*)
111669157004,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckMemoryLeakNoVar.returnValueNotUsedError:void(Token*,ANY)",<empty>,,true,,,returnValueNotUsedError,,,0,"void(Token*,ANY)"
111669157005,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckMemoryLeakNoVar.unsafeArgAllocError:void(Token*,ANY,ANY,ANY)",<empty>,,true,,,unsafeArgAllocError,,,0,"void(Token*,ANY,ANY,ANY)"
111669157006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.functionCallLeak:<unresolvedSignature>(3),<empty>,,true,,,functionCallLeak,,,0,<unresolvedSignature>
111669157007,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.returnValueNotUsedError:<unresolvedSignature>(2),<empty>,,true,,,returnValueNotUsedError,,,0,<unresolvedSignature>
111669157008,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.unsafeArgAllocError:<unresolvedSignature>(4),<empty>,,true,,,unsafeArgAllocError,,,0,<unresolvedSignature>
111669157009,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.strValue:<unresolvedSignature>(0),<empty>,,true,,,strValue,,,0,<unresolvedSignature>
111669157010,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckNullPointer.parseFunctionCall:void(Token&,ANY,Library&,bool)",<empty>,,true,,,parseFunctionCall,,,0,"void(Token&,ANY,Library&,bool)"
111669157011,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findTokensSkipDeadAndUnevaluatedCode:<unresolvedSignature>(4),<empty>,,true,,,findTokensSkipDeadAndUnevaluatedCode,,,0,<unresolvedSignature>
111669157012,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckNullPointer.isPointerDeRef:bool(Token*,bool&)",<empty>,,true,,,isPointerDeRef,,,0,"bool(Token*,bool&)"
111669157013,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckNullPointer.nullPointerError:void(Token*,ANY,ValueFlow.Value*,bool)",<empty>,,true,,,nullPointerError,,,0,"void(Token*,ANY,ValueFlow.Value*,bool)"
111669157014,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.nullPointerError:<unresolvedSignature>(4),<empty>,,true,,,nullPointerError,,,0,<unresolvedSignature>
111669157015,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,arithmeticTypeString:ANY(Token*),<empty>,,true,,,arithmeticTypeString,,,0,ANY(Token*)
111669157016,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckNullPointer.logChecker:void(char*),<empty>,,true,,,logChecker,,,0,void(char*)
111669157017,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.checkCastIntToCharAndBackError:void(Token*,ANY)",<empty>,,true,,,checkCastIntToCharAndBackError,,,0,"void(Token*,ANY)"
111669157018,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.checkCastIntToCharAndBackError:<unresolvedSignature>(2),<empty>,,true,,,checkCastIntToCharAndBackError,,,0,<unresolvedSignature>
111669157019,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.clarifyCalculationError:void(Token*,ANY)",<empty>,,true,,,clarifyCalculationError,,,0,"void(Token*,ANY)"
111669157020,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VTT,<empty>,,true,,,VTT,,,0,
111669157021,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.invalidPointerCastError:void(Token*,ANY,ANY,bool,bool)",<empty>,,true,,,invalidPointerCastError,,,0,"void(Token*,ANY,ANY,bool,bool)"
111669157022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isSplittedVarDeclEq<const>:bool(),<empty>,,true,,,isSplittedVarDeclEq,,,0,bool()
111669157023,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckOther.diag:bool(Token*),<empty>,,true,,,diag,,,0,bool(Token*)
111669157024,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.redundantAssignmentSameValueError:void(Token*,ValueFlow.Value*,ANY)",<empty>,,true,,,redundantAssignmentSameValueError,,,0,"void(Token*,ValueFlow.Value*,ANY)"
111669157025,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.redundantAssignmentInSwitchError:void(Token*,Token*,ANY)",<empty>,,true,,,redundantAssignmentInSwitchError,,,0,"void(Token*,Token*,ANY)"
111669157026,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.redundantInitializationError:void(Token*,Token*,ANY,bool)",<empty>,,true,,,redundantInitializationError,,,0,"void(Token*,Token*,ANY,bool)"
111669157027,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.redundantAssignmentError:void(Token*,Token*,ANY,bool)",<empty>,,true,,,redundantAssignmentError,,,0,"void(Token*,Token*,ANY,bool)"
111669157028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.redundantBitwiseOperationInSwitchError:<unresolvedSignature>(2),<empty>,,true,,,redundantBitwiseOperationInSwitchError,,,0,<unresolvedSignature>
111669157029,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.suspiciousCaseInSwitchError:void(Token*,ANY)",<empty>,,true,,,suspiciousCaseInSwitchError,,,0,"void(Token*,ANY)"
111669157030,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isEnumType<const>:bool(),<empty>,,true,,,isEnumType,,,0,bool()
111669157031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.checkInnerScope:bool(Token*,Variable*,bool&)",<empty>,,true,,,checkInnerScope,,,0,"bool(Token*,Variable*,bool&)"
111669157032,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.variableScopeError:void(Token*,ANY)",<empty>,,true,,,variableScopeError,,,0,"void(Token*,ANY)"
111669157033,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findExpression:<unresolvedSignature>(4),<empty>,,true,,,findExpression,,,0,<unresolvedSignature>
111669157034,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findmatch:<unresolvedSignature>(4),<empty>,,true,,,findmatch,,,0,<unresolvedSignature>
111669157035,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isSimplifiedScope<const>:bool(),<empty>,,true,,,isSimplifiedScope,,,0,bool()
111669157036,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isExternC<const>:bool(),<empty>,,true,,,isExternC,,,0,bool()
111669157037,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.emplace_front:<unresolvedSignature>(2),<empty>,,true,,,emplace_front,,,0,<unresolvedSignature>
111669157038,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isMaybeUnused<const>:bool(),<empty>,,true,,,isMaybeUnused,,,0,bool()
111669157039,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isSimplifiedTypedef<const>:bool(),<empty>,,true,,,isSimplifiedTypedef,,,0,bool()
111669157040,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.getMaxValue<const>:ValueFlow.Value*(bool,longlongint)",<empty>,,true,,,getMaxValue,,,0,"ValueFlow.Value*(bool,longlongint)"
111669157041,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.constStatementError:<unresolvedSignature>(3),<empty>,,true,,,constStatementError,,,0,<unresolvedSignature>
111669157042,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():Token(Token*,std.string&)",<empty>,,true,,,<operator>(),,,0,"Token(Token*,std.string&)"
111669157043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():bool(Token*,std.string&)",<empty>,,true,,,<operator>(),,,0,"bool(Token*,std.string&)"
111669157044,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.misusedScopeObjectError:void(Token*,ANY,bool)",<empty>,,true,,,misusedScopeObjectError,,,0,"void(Token*,ANY,bool)"
111669157045,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.duplicateBranchError:void(Token*,Token*,ANY)",<empty>,,true,,,duplicateBranchError,,,0,"void(Token*,Token*,ANY)"
111669157046,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.duplicateBranchError:<unresolvedSignature>(3),<empty>,,true,,,duplicateBranchError,,,0,<unresolvedSignature>
111669157047,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.invalidFreeError:<unresolvedSignature>(3),<empty>,,true,,,invalidFreeError,,,0,<unresolvedSignature>
111669157048,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.splice:<unresolvedSignature>(2),<empty>,,true,,,splice,,,0,<unresolvedSignature>
111669157049,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.duplicateExpressionError:void(Token*,Token*,Token*,ANY,bool)",<empty>,,true,,,duplicateExpressionError,,,0,"void(Token*,Token*,Token*,ANY,bool)"
111669157050,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getConstFunctions:void(SymbolDatabase*,ANY)",<empty>,,true,,,getConstFunctions,,,0,"void(SymbolDatabase*,ANY)"
111669157051,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.selfAssignmentError:void(Token*,ANY)",<empty>,,true,,,selfAssignmentError,,,0,"void(Token*,ANY)"
111669157052,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.duplicateExpressionError:<unresolvedSignature>(4),<empty>,,true,,,duplicateExpressionError,,,0,<unresolvedSignature>
111669157053,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"isOppositeExpression:bool(Token*,Token*,Settings&,bool,bool,ANY)",<empty>,,true,,,isOppositeExpression,,,0,"bool(Token*,Token*,Settings&,bool,bool,ANY)"
111669157054,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.oppositeExpressionError:<unresolvedSignature>(2),<empty>,,true,,,oppositeExpressionError,,,0,<unresolvedSignature>
111669157055,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():void(Token*,Token*,Token*)",<empty>,,true,,,<operator>(),,,0,"void(Token*,Token*,Token*)"
111669157056,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.duplicateExpressionTernaryError:<unresolvedSignature>(2),<empty>,,true,,,duplicateExpressionTernaryError,,,0,<unresolvedSignature>
111669157057,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.checkComparisonFunctionIsAlwaysTrueOrFalseError:void(Token*,ANY,ANY,bool)",<empty>,,true,,,checkComparisonFunctionIsAlwaysTrueOrFalseError,,,0,"void(Token*,ANY,ANY,bool)"
111669157058,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.unsignedLessThanZeroError:void(Token*,ValueFlow.Value*,ANY)",<empty>,,true,,,unsignedLessThanZeroError,,,0,"void(Token*,ValueFlow.Value*,ANY)"
111669157059,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.unsignedPositiveError:void(Token*,ValueFlow.Value*,ANY)",<empty>,,true,,,unsignedPositiveError,,,0,"void(Token*,ValueFlow.Value*,ANY)"
111669157060,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.redundantCopyError:void(Token*,ANY)",<empty>,,true,,,redundantCopyError,,,0,"void(Token*,ANY)"
111669157061,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.incompleteArrayFillError:void(Token*,ANY,ANY,bool)",<empty>,,true,,,incompleteArrayFillError,,,0,"void(Token*,ANY,ANY,bool)"
111669157062,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.redundantPointerOpError:void(Token*,ANY,bool,bool)",<empty>,,true,,,redundantPointerOpError,,,0,"void(Token*,ANY,bool,bool)"
111669157063,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.accessMovedError:void(Token*,ANY,ValueFlow.Value*,bool)",<empty>,,true,,,accessMovedError,,,0,"void(Token*,ANY,ValueFlow.Value*,bool)"
111669157064,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.funcArgOrderDifferent:void(ANY,Token*,Token*,ANY,ANY)",<empty>,,true,,,funcArgOrderDifferent,,,0,"void(ANY,Token*,Token*,ANY,ANY)"
111669157065,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.funcArgNamesDifferent:<unresolvedSignature>(4),<empty>,,true,,,funcArgNamesDifferent,,,0,<unresolvedSignature>
111669157066,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.shadowError:<unresolvedSignature>(3),<empty>,,true,,,shadowError,,,0,<unresolvedSignature>
111669157067,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strTolower:void(ANY),<empty>,,true,,,strTolower,,,0,void(ANY)
111669157068,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.knownArgumentError:<unresolvedSignature>(5),<empty>,,true,,,knownArgumentError,,,0,<unresolvedSignature>
111669157069,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"findParent:Token*(Token*,ANY)",<empty>,,true,,,findParent,,,0,"Token*(Token*,ANY)"
111669157070,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.overlappingWriteFunction:void(Token*,ANY)",<empty>,,true,,,overlappingWriteFunction,,,0,"void(Token*,ANY)"
111669157071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getBufAndOffset:bool(Token*,Token*&,longlongint*,Settings&,longlongint*)",<empty>,,true,,,getBufAndOffset,,,0,"bool(Token*,Token*&,longlongint*,Settings&,longlongint*)"
111669157072,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.misusedScopeObjectError:<unresolvedSignature>(2),<empty>,,true,,,misusedScopeObjectError,,,0,<unresolvedSignature>
111669157073,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.invalidPointerCastError:<unresolvedSignature>(5),<empty>,,true,,,invalidPointerCastError,,,0,<unresolvedSignature>
111669157074,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.overlappingWriteFunction:<unresolvedSignature>(2),<empty>,,true,,,overlappingWriteFunction,,,0,<unresolvedSignature>
111669157075,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.redundantCopyError:<unresolvedSignature>(2),<empty>,,true,,,redundantCopyError,,,0,<unresolvedSignature>
111669157076,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.redundantCopyError:<unresolvedSignature>(3),<empty>,,true,,,redundantCopyError,,,0,<unresolvedSignature>
111669157077,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.checkComparisonFunctionIsAlwaysTrueOrFalseError:<unresolvedSignature>(4),<empty>,,true,,,checkComparisonFunctionIsAlwaysTrueOrFalseError,,,0,<unresolvedSignature>
111669157078,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.variableScopeError:<unresolvedSignature>(2),<empty>,,true,,,variableScopeError,,,0,<unresolvedSignature>
111669157079,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.redundantAssignmentInSwitchError:<unresolvedSignature>(3),<empty>,,true,,,redundantAssignmentInSwitchError,,,0,<unresolvedSignature>
111669157080,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.suspiciousCaseInSwitchError:<unresolvedSignature>(2),<empty>,,true,,,suspiciousCaseInSwitchError,,,0,<unresolvedSignature>
111669157081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.selfAssignmentError:<unresolvedSignature>(2),<empty>,,true,,,selfAssignmentError,,,0,<unresolvedSignature>
111669157082,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.clarifyCalculationError:<unresolvedSignature>(2),<empty>,,true,,,clarifyCalculationError,,,0,<unresolvedSignature>
111669157083,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.oppositeExpressionError:void(Token*,ANY)",<empty>,,true,,,oppositeExpressionError,,,0,"void(Token*,ANY)"
111669157084,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckOther.duplicateExpressionTernaryError:void(Token*,ANY)",<empty>,,true,,,duplicateExpressionTernaryError,,,0,"void(Token*,ANY)"
111669157085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.unsignedLessThanZeroError:<unresolvedSignature>(3),<empty>,,true,,,unsignedLessThanZeroError,,,0,<unresolvedSignature>
111669157086,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.unsignedPositiveError:<unresolvedSignature>(3),<empty>,,true,,,unsignedPositiveError,,,0,<unresolvedSignature>
111669157087,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.incompleteArrayFillError:<unresolvedSignature>(4),<empty>,,true,,,incompleteArrayFillError,,,0,<unresolvedSignature>
111669157088,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.redundantPointerOpError:<unresolvedSignature>(4),<empty>,,true,,,redundantPointerOpError,,,0,<unresolvedSignature>
111669157089,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.accessMovedError:<unresolvedSignature>(4),<empty>,,true,,,accessMovedError,,,0,<unresolvedSignature>
111669157090,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.redundantAssignmentError:<unresolvedSignature>(4),<empty>,,true,,,redundantAssignmentError,,,0,<unresolvedSignature>
111669157091,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.redundantInitializationError:<unresolvedSignature>(4),<empty>,,true,,,redundantInitializationError,,,0,<unresolvedSignature>
111669157092,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.funcArgOrderDifferent:<unresolvedSignature>(5),<empty>,,true,,,funcArgOrderDifferent,,,0,<unresolvedSignature>
111669157093,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.begin:<unresolvedSignature>(1),<empty>,,true,,,begin,,,0,<unresolvedSignature>
111669157094,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.end:<unresolvedSignature>(1),<empty>,,true,,,end,,,0,<unresolvedSignature>
111669157095,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>():bool(Token*),<empty>,,true,,,<operator>(),,,0,bool(Token*)
111669157096,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckSizeof.divideBySizeofError:void(Token*,ANY)",<empty>,,true,,,divideBySizeofError,,,0,"void(Token*,ANY)"
111669157097,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckSizeof.sizeofForPointerError:void(Token*,ANY)",<empty>,,true,,,sizeofForPointerError,,,0,"void(Token*,ANY)"
111669157098,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckSizeof.sizeofDereferencedVoidPointerError:void(Token*,ANY)",<empty>,,true,,,sizeofDereferencedVoidPointerError,,,0,"void(Token*,ANY)"
111669157099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckSizeof.arithOperationsOnVoidPointerError:void(Token*,ANY,ANY)",<empty>,,true,,,arithOperationsOnVoidPointerError,,,0,"void(Token*,ANY,ANY)"
111669157100,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sizeofForPointerError:<unresolvedSignature>(2),<empty>,,true,,,sizeofForPointerError,,,0,<unresolvedSignature>
111669157101,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.divideBySizeofError:<unresolvedSignature>(2),<empty>,,true,,,divideBySizeofError,,,0,<unresolvedSignature>
111669157102,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sizeofDereferencedVoidPointerError:<unresolvedSignature>(2),<empty>,,true,,,sizeofDereferencedVoidPointerError,,,0,<unresolvedSignature>
111669157103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.arithOperationsOnVoidPointerError:<unresolvedSignature>(3),<empty>,,true,,,arithOperationsOnVoidPointerError,,,0,<unresolvedSignature>
111669157104,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckStl.outOfBoundsError:void(Token*,ANY,ValueFlow.Value*,ANY,ValueFlow.Value*)",<empty>,,true,,,outOfBoundsError,,,0,"void(Token*,ANY,ValueFlow.Value*,ANY,ValueFlow.Value*)"
111669157105,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.outOfBoundsError:<unresolvedSignature>(5),<empty>,,true,,,outOfBoundsError,,,0,<unresolvedSignature>
111669157106,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findValue:<unresolvedSignature>(3),<empty>,,true,,,findValue,,,0,<unresolvedSignature>
111669157107,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.isIteratorStartValue<const>:bool(),<empty>,,true,,,isIteratorStartValue,,,0,bool()
111669157108,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.isIteratorEndValue<const>:bool(),<empty>,,true,,,isIteratorEndValue,,,0,bool()
111669157109,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.isPossible<const>:bool(),<empty>,,true,,,isPossible,,,0,bool()
111669157110,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"indexValueString:ANY(ValueFlow.Value&,ANY)",<empty>,,true,,,indexValueString,,,0,"ANY(ValueFlow.Value&,ANY)"
111669157111,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckStl.isContainerSize:bool(Token*,Token*)",<empty>,,true,,,isContainerSize,,,0,"bool(Token*,Token*)"
111669157112,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckStl.isContainerSizeGE:bool(Token*,Token*)",<empty>,,true,,,isContainerSizeGE,,,0,"bool(Token*,Token*)"
111669157113,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getFunction:<unresolvedSignature>(1),<empty>,,true,,,getFunction,,,0,<unresolvedSignature>
111669157114,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckStl.invalidIteratorError:void(Token*,ANY)",<empty>,,true,,,invalidIteratorError,,,0,"void(Token*,ANY)"
111669157115,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckStl.iteratorsError:void(Token*,ANY,ANY)",<empty>,,true,,,iteratorsError,,,0,"void(Token*,ANY,ANY)"
111669157116,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getContainerName:ANY(Token*),<empty>,,true,,,getContainerName,,,0,ANY(Token*)
111669157117,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckStl.dereferenceErasedError:void(Token*,Token*,ANY,bool)",<empty>,,true,,,dereferenceErasedError,,,0,"void(Token*,Token*,ANY,bool)"
111669157118,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getAddressContainer:ANY(Token*),<empty>,,true,,,getAddressContainer,,,0,ANY(Token*)
111669157119,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.partition:<unresolvedSignature>(3),<empty>,,true,,,partition,,,0,<unresolvedSignature>
111669157120,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.min_element:<unresolvedSignature>(3),<empty>,,true,,,min_element,,,0,<unresolvedSignature>
111669157121,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pruneLifetimes:ANY(ANY),<empty>,,true,,,pruneLifetimes,,,0,ANY(ANY)
111669157122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():ANY(std.vector<ValueFlow.Value>&,std.vector<ValueFlow.Value>.const_iterator)",<empty>,,true,,,<operator>(),,,0,"ANY(std.vector<ValueFlow.Value>&,std.vector<ValueFlow.Value>.const_iterator)"
111669157123,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getLifetimeIteratorValue:ValueFlow.Value(Token*,longlongint)",<empty>,,true,,,getLifetimeIteratorValue,,,0,"ValueFlow.Value(Token*,longlongint)"
111669157124,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckStl.iteratorsError:void(Token*,Token*,ANY)",<empty>,,true,,,iteratorsError,,,0,"void(Token*,Token*,ANY)"
111669157125,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Library.getArgIteratorInfo<const>:Library.ArgumentChecks.IteratorInfo*(Token*,int)",<empty>,,true,,,getArgIteratorInfo,,,0,"Library.ArgumentChecks.IteratorInfo*(Token*,int)"
111669157126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ArgIteratorInfo,<empty>,,true,,,ArgIteratorInfo,,,0,
111669157127,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>():void(),<empty>,,true,,,<operator>(),,,0,void()
111669157128,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.invalidTokens:<unresolvedSignature>(0),<empty>,,true,,,invalidTokens,,,0,<unresolvedSignature>
111669157129,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Info::Reference,<empty>,,true,,,Info::Reference,,,0,
111669157130,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InvalidContainerAnalyzer.invalidatesContainer:ANY(Token*),<empty>,,true,,,invalidatesContainer,,,0,ANY(Token*)
111669157131,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.add:<unresolvedSignature>(1),<empty>,,true,,,add,,,0,<unresolvedSignature>
111669157132,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getInnerLifetime:ValueFlow.Value*(Token*,int,ANY,int)",<empty>,,true,,,getInnerLifetime,,,0,"ValueFlow.Value*(Token*,int,ANY,int)"
111669157133,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"reaches:bool(Token*,Token*,Library&,ANY)",<empty>,,true,,,reaches,,,0,"bool(Token*,Token*,Library&,ANY)"
111669157134,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InvalidContainerAnalyzer.invalidatesContainer<const>:ANY(Token*),<empty>,,true,,,invalidatesContainer,,,0,ANY(Token*)
111669157135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckStl.invalidContainerLoopError:void(Token*,Token*,ANY)",<empty>,,true,,,invalidContainerLoopError,,,0,"void(Token*,Token*,ANY)"
111669157136,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.forwardFind:<unresolvedSignature>(1),<empty>,,true,,,forwardFind,,,0,<unresolvedSignature>
111669157137,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PathAnalysis,<empty>,,true,,,PathAnalysis,,,0,
111669157138,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.invalidContainerError:<unresolvedSignature>(4),<empty>,,true,,,invalidContainerError,,,0,<unresolvedSignature>
111669157139,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.invalidContainerReferenceError:<unresolvedSignature>(3),<empty>,,true,,,invalidContainerReferenceError,,,0,<unresolvedSignature>
111669157140,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.remove_if:<unresolvedSignature>(1),<empty>,,true,,,remove_if,,,0,<unresolvedSignature>
111669157141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckStl.stlOutOfBoundsError:void(Token*,ANY,ANY,bool)",<empty>,,true,,,stlOutOfBoundsError,,,0,"void(Token*,ANY,ANY,bool)"
111669157142,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.tie:<unresolvedSignature>(2),<empty>,,true,,,tie,,,0,<unresolvedSignature>
111669157143,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isMapFind:ANY(Token*),<empty>,,true,,,isMapFind,,,0,ANY(Token*)
111669157144,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isStlType:<unresolvedSignature>(1),<empty>,,true,,,isStlType,,,0,<unresolvedSignature>
111669157145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StrArg,<empty>,,true,,,StrArg,,,0,
111669157146,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckStl.string_c_strAssignment:void(Token*,ANY)",<empty>,,true,,,string_c_strAssignment,,,0,"void(Token*,ANY)"
111669157147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.equal_range:<unresolvedSignature>(1),<empty>,,true,,,equal_range,,,0,<unresolvedSignature>
111669157148,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.string_c_strParam:<unresolvedSignature>(3),<empty>,,true,,,string_c_strParam,,,0,<unresolvedSignature>
111669157149,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckStl.string_c_strConstructor:void(Token*,ANY)",<empty>,,true,,,string_c_strConstructor,,,0,"void(Token*,ANY)"
111669157150,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckStl.uselessCallsReturnValueError:void(Token*,ANY,ANY)",<empty>,,true,,,uselessCallsReturnValueError,,,0,"void(Token*,ANY,ANY)"
111669157151,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckStl.uselessCallsSwapError:void(Token*,ANY)",<empty>,,true,,,uselessCallsSwapError,,,0,"void(Token*,ANY)"
111669157152,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckStl.uselessCallsRemoveError:void(Token*,ANY)",<empty>,,true,,,uselessCallsRemoveError,,,0,"void(Token*,ANY)"
111669157153,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Match:<unresolvedSignature>(3),<empty>,,true,,,Match,,,0,<unresolvedSignature>
111669157154,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckStl.dereferenceInvalidIteratorError:void(Token*,ANY)",<empty>,,true,,,dereferenceInvalidIteratorError,,,0,"void(Token*,ANY)"
111669157155,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,flipMinMax:ANY(ANY),<empty>,,true,,,flipMinMax,,,0,ANY(ANY)
111669157156,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"minmaxCompare:ANY(Token*,int,int,LoopType,bool)",<empty>,,true,,,minmaxCompare,,,0,"ANY(Token*,int,int,LoopType,bool)"
111669157157,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LoopAnalyzer.valid:bool(),<empty>,,true,,,valid,,,0,bool()
111669157158,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.f:<unresolvedSignature>(1),<empty>,,true,,,f,,,0,<unresolvedSignature>
111669157159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LoopAnalyzer.findToken:Token*(std.function),<empty>,,true,,,findToken,,,0,Token*(std.function)
111669157160,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LoopAnalyzer.isLoopVarChanged:bool(),<empty>,,true,,,isLoopVarChanged,,,0,bool()
111669157161,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LoopAnalyzer.hasGotoOrBreak:bool(),<empty>,,true,,,hasGotoOrBreak,,,0,bool()
111669157162,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"LoopAnalyzer.findTokens:void(std.function,std.function)",<empty>,,true,,,findTokens,,,0,"void(std.function,std.function)"
111669157163,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LoopAnalyzer.isLocalVar:bool(Variable*),<empty>,,true,,,isLocalVar,,,0,bool(Variable*)
111669157164,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LoopAnalyzer.isModified:bool(Token*),<empty>,,true,,,isModified,,,0,bool(Token*)
111669157165,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LoopAnalyzer.findAlgo<const>:ANY(),<empty>,,true,,,findAlgo,,,0,ANY()
111669157166,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckStl.useStlAlgorithmError:void(Token*,ANY)",<empty>,,true,,,useStlAlgorithmError,,,0,"void(Token*,ANY)"
111669157167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"isTernaryAssignment:bool(Token*,int,int,LoopType,ANY)",<empty>,,true,,,isTernaryAssignment,,,0,"bool(Token*,int,int,LoopType,ANY)"
111669157168,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():bool(Token*,ConditionOpType&)",<empty>,,true,,,<operator>(),,,0,"bool(Token*,ConditionOpType&)"
111669157169,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.useStlAlgorithmError:<unresolvedSignature>(2),<empty>,,true,,,useStlAlgorithmError,,,0,<unresolvedSignature>
111669157170,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.knownEmptyContainerError:<unresolvedSignature>(2),<empty>,,true,,,knownEmptyContainerError,,,0,<unresolvedSignature>
111669157171,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckStl.knownEmptyContainerError:void(Token*,ANY)",<empty>,,true,,,knownEmptyContainerError,,,0,"void(Token*,ANY)"
111669157172,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getOOBIterValue:<unresolvedSignature>(2),<empty>,,true,,,getOOBIterValue,,,0,<unresolvedSignature>
111669157173,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.eraseIteratorOutOfBoundsError:<unresolvedSignature>(3),<empty>,,true,,,eraseIteratorOutOfBoundsError,,,0,<unresolvedSignature>
111669157174,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.invalidIteratorError:<unresolvedSignature>(2),<empty>,,true,,,invalidIteratorError,,,0,<unresolvedSignature>
111669157175,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.iteratorsError:<unresolvedSignature>(3),<empty>,,true,,,iteratorsError,,,0,<unresolvedSignature>
111669157176,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.iteratorsError:<unresolvedSignature>(4),<empty>,,true,,,iteratorsError,,,0,<unresolvedSignature>
111669157177,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckStl.invalidContainerError:void(Token*,Token*,ValueFlow.Value*,ANY)",<empty>,,true,,,invalidContainerError,,,0,"void(Token*,Token*,ValueFlow.Value*,ANY)"
111669157178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.dereferenceErasedError:<unresolvedSignature>(4),<empty>,,true,,,dereferenceErasedError,,,0,<unresolvedSignature>
111669157179,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.stlOutOfBoundsError:<unresolvedSignature>(4),<empty>,,true,,,stlOutOfBoundsError,,,0,<unresolvedSignature>
111669157180,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckStl.string_c_strParam:void(Token*,int,ANY)",<empty>,,true,,,string_c_strParam,,,0,"void(Token*,int,ANY)"
111669157181,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.uselessCallsReturnValueError:<unresolvedSignature>(3),<empty>,,true,,,uselessCallsReturnValueError,,,0,<unresolvedSignature>
111669157182,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.uselessCallsSwapError:<unresolvedSignature>(2),<empty>,,true,,,uselessCallsSwapError,,,0,<unresolvedSignature>
111669157183,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.uselessCallsRemoveError:<unresolvedSignature>(2),<empty>,,true,,,uselessCallsRemoveError,,,0,<unresolvedSignature>
111669157184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.dereferenceInvalidIteratorError:<unresolvedSignature>(2),<empty>,,true,,,dereferenceInvalidIteratorError,,,0,<unresolvedSignature>
111669157185,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckString.alwaysTrueFalseStringCompareError:void(Token*,ANY,ANY)",<empty>,,true,,,alwaysTrueFalseStringCompareError,,,0,"void(Token*,ANY,ANY)"
111669157186,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckString.alwaysTrueStringVariableCompareError:void(Token*,ANY,ANY)",<empty>,,true,,,alwaysTrueStringVariableCompareError,,,0,"void(Token*,ANY,ANY)"
111669157187,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckString.suspiciousStringCompareError:void(Token*,ANY,bool)",<empty>,,true,,,suspiciousStringCompareError,,,0,"void(Token*,ANY,bool)"
111669157188,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckString.suspiciousStringCompareError_char:void(Token*,ANY)",<empty>,,true,,,suspiciousStringCompareError_char,,,0,"void(Token*,ANY)"
111669157189,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.incorrectStringCompareError:<unresolvedSignature>(3),<empty>,,true,,,incorrectStringCompareError,,,0,<unresolvedSignature>
111669157190,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckString.incorrectStringBooleanError:void(Token*,ANY)",<empty>,,true,,,incorrectStringBooleanError,,,0,"void(Token*,ANY)"
111669157191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isCharLiteral:bool(ANY),<empty>,,true,,,isCharLiteral,,,0,bool(ANY)
111669157192,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getCharLiteral:ANY(ANY),<empty>,,true,,,getCharLiteral,,,0,ANY(ANY)
111669157193,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isLiteral:<unresolvedSignature>(0),<empty>,,true,,,isLiteral,,,0,<unresolvedSignature>
111669157194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sprintfOverlappingDataError:<unresolvedSignature>(3),<empty>,,true,,,sprintfOverlappingDataError,,,0,<unresolvedSignature>
111669157195,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.suspiciousStringCompareError:<unresolvedSignature>(3),<empty>,,true,,,suspiciousStringCompareError,,,0,<unresolvedSignature>
111669157196,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.suspiciousStringCompareError_char:<unresolvedSignature>(2),<empty>,,true,,,suspiciousStringCompareError_char,,,0,<unresolvedSignature>
111669157197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.incorrectStringBooleanError:<unresolvedSignature>(2),<empty>,,true,,,incorrectStringBooleanError,,,0,<unresolvedSignature>
111669157198,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.alwaysTrueFalseStringCompareError:<unresolvedSignature>(3),<empty>,,true,,,alwaysTrueFalseStringCompareError,,,0,<unresolvedSignature>
111669157199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.alwaysTrueStringVariableCompareError:<unresolvedSignature>(3),<empty>,,true,,,alwaysTrueStringVariableCompareError,,,0,<unresolvedSignature>
111669157200,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getValueGE:<unresolvedSignature>(2),<empty>,,true,,,getValueGE,,,0,<unresolvedSignature>
111669157201,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.tooBigBitwiseShiftError:<unresolvedSignature>(3),<empty>,,true,,,tooBigBitwiseShiftError,,,0,<unresolvedSignature>
111669157202,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.tooBigSignedBitwiseShiftError:<unresolvedSignature>(3),<empty>,,true,,,tooBigSignedBitwiseShiftError,,,0,<unresolvedSignature>
111669157203,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Check.getMessageId:ANY(ValueFlow.Value&,char*)",<empty>,,true,,,getMessageId,,,0,"ANY(ValueFlow.Value&,char*)"
111669157204,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Platform.isIntValue<const>:bool(longlongint),<empty>,,true,,,isIntValue,,,0,bool(longlongint)
111669157205,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,makeBaseTypeString:void(ANY),<empty>,,true,,,makeBaseTypeString,,,0,void(ANY)
111669157206,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckType.checkFloatToIntegerOverflow:void(Token*,ValueType*,ValueType*,ANY)",<empty>,,true,,,checkFloatToIntegerOverflow,,,0,"void(Token*,ValueType*,ValueType*,ANY)"
111669157207,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.exp2:<unresolvedSignature>(1),<empty>,,true,,,exp2,,,0,<unresolvedSignature>
111669157208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.VariableValue:<unresolvedSignature>(1),<empty>,,true,,,VariableValue,,,0,<unresolvedSignature>
111669157209,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.checkScope:<unresolvedSignature>(2),<empty>,,true,,,checkScope,,,0,<unresolvedSignature>
111669157210,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isThrow<const>:bool(),<empty>,,true,,,isThrow,,,0,bool()
111669157211,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckUninitVar.checkRhs:void(Token*,Variable&,CheckUninitVar.Alloc,int,ANY)",<empty>,,true,,,checkRhs,,,0,"void(Token*,Variable&,CheckUninitVar.Alloc,int,ANY)"
111669157212,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isPointerToArray<const>:bool(),<empty>,,true,,,isPointerToArray,,,0,bool()
111669157213,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckUninitVar.checkLoopBody:bool(Token*,Variable&,CheckUninitVar.Alloc,ANY,bool)",<empty>,,true,,,checkLoopBody,,,0,"bool(Token*,Variable&,CheckUninitVar.Alloc,ANY,bool)"
111669157214,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getVariableValues:ANY(Token*),<empty>,,true,,,getVariableValues,,,0,ANY(Token*)
111669157215,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckUninitVar.checkScopeForVariable:bool(Token*,Variable&,bool*,bool*,CheckUninitVar.Alloc*,ANY,ANY)",<empty>,,true,,,checkScopeForVariable,,,0,"bool(Token*,Variable&,bool*,bool*,CheckUninitVar.Alloc*,ANY,ANY)"
111669157216,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"conditionAlwaysTrueOrFalse:void(Token*,ANY,bool*,bool*)",<empty>,,true,,,conditionAlwaysTrueOrFalse,,,0,"void(Token*,ANY,bool*,bool*)"
111669157217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.isUninitValue<const>:bool(),<empty>,,true,,,isUninitValue,,,0,bool()
111669157218,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckUninitVar.isMemberVariableAssignment:bool(Token*,ANY)",<empty>,,true,,,isMemberVariableAssignment,,,0,"bool(Token*,ANY)"
111669157219,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckUninitVar.checkIfForWhileHead:bool(Token*,Variable&,bool,bool,CheckUninitVar.Alloc,ANY)",<empty>,,true,,,checkIfForWhileHead,,,0,"bool(Token*,Variable&,bool,bool,CheckUninitVar.Alloc,ANY)"
111669157220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckUninitVar.uninitStructMemberError:void(Token*,ANY)",<empty>,,true,,,uninitStructMemberError,,,0,"void(Token*,ANY)"
111669157221,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckUninitVar.uninitvarError:void(Token*,ANY,CheckUninitVar.Alloc)",<empty>,,true,,,uninitvarError,,,0,"void(Token*,ANY,CheckUninitVar.Alloc)"
111669157222,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckUninitVar.isVariableUsage:Token*(Token*,bool,CheckUninitVar.Alloc,int)",<empty>,,true,,,isVariableUsage,,,0,"Token*(Token*,bool,CheckUninitVar.Alloc,int)"
111669157223,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckUninitVar.isMemberVariableUsage:bool(Token*,bool,CheckUninitVar.Alloc,ANY)",<empty>,,true,,,isMemberVariableUsage,,,0,"bool(Token*,bool,CheckUninitVar.Alloc,ANY)"
111669157224,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckUninitVar.checkExpr:Token*(Token*,Variable&,CheckUninitVar.Alloc,bool,bool*)",<empty>,,true,,,checkExpr,,,0,"Token*(Token*,Variable&,CheckUninitVar.Alloc,bool,bool*)"
111669157225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckUninitVar.checkLoopBodyRecursive:Token*(Token*,Variable&,CheckUninitVar.Alloc,ANY,bool&,bool&)",<empty>,,true,,,checkLoopBodyRecursive,,,0,"Token*(Token*,Variable&,CheckUninitVar.Alloc,ANY,bool&,bool&)"
111669157226,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckUninitVar.isFunctionParUsage:int(Token*,bool,CheckUninitVar.Alloc,int)",<empty>,,true,,,isFunctionParUsage,,,0,"int(Token*,bool,CheckUninitVar.Alloc,int)"
111669157227,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.exprId:<unresolvedSignature>(0),<empty>,,true,,,exprId,,,0,<unresolvedSignature>
111669157228,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isInconclusive:<unresolvedSignature>(0),<empty>,,true,,,isInconclusive,,,0,<unresolvedSignature>
111669157229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getExprUsage:<unresolvedSignature>(3),<empty>,,true,,,getExprUsage,,,0,<unresolvedSignature>
111669157230,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isVariableChanged:<unresolvedSignature>(3),<empty>,,true,,,isVariableChanged,,,0,<unresolvedSignature>
111669157231,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isVariableChangedByFunctionCall:<unresolvedSignature>(4),<empty>,,true,,,isVariableChangedByFunctionCall,,,0,<unresolvedSignature>
111669157232,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.uninitvarError:<unresolvedSignature>(2),<empty>,,true,,,uninitvarError,,,0,<unresolvedSignature>
111669157233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"isVariableUsage:bool(Settings&,Token*,longlongint*)",<empty>,,true,,,isVariableUsage,,,0,"bool(Settings&,Token*,longlongint*)"
111669157234,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckUninitVar.logChecker:void(char*),<empty>,,true,,,logChecker,,,0,void(char*)
111669157235,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.uninitdataError:<unresolvedSignature>(2),<empty>,,true,,,uninitdataError,,,0,<unresolvedSignature>
111669157236,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.uninitStructMemberError:<unresolvedSignature>(2),<empty>,,true,,,uninitStructMemberError,,,0,<unresolvedSignature>
111669157237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isAttributeConstructor<const>:bool(),<empty>,,true,,,isAttributeConstructor,,,0,bool()
111669157238,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isAttributeDestructor<const>:bool(),<empty>,,true,,,isAttributeDestructor,,,0,bool()
111669157239,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isAttributeUnused<const>:bool(),<empty>,,true,,,isAttributeUnused,,,0,bool()
111669157240,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isAttributeMaybeUnused<const>:bool(),<empty>,,true,,,isAttributeMaybeUnused,,,0,bool()
111669157241,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isExtern<const>:bool(),<empty>,,true,,,isExtern,,,0,bool()
111669157242,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,stripTemplateParameters:ANY(ANY),<empty>,,true,,,stripTemplateParameters,,,0,ANY(ANY)
111669157243,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAttributeUnused<const>:bool(),<empty>,,true,,,isAttributeUnused,,,0,bool()
111669157244,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAttributeMaybeUnused<const>:bool(),<empty>,,true,,,isAttributeMaybeUnused,,,0,bool()
111669157245,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isexecutableblock:<unresolvedSignature>(2),<empty>,,true,,,isexecutableblock,,,0,<unresolvedSignature>
111669157246,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.blockstartoffset:<unresolvedSignature>(1),<empty>,,true,,,blockstartoffset,,,0,<unresolvedSignature>
111669157247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.blockstart:<unresolvedSignature>(1),<empty>,,true,,,blockstart,,,0,<unresolvedSignature>
111669157248,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.blockend:<unresolvedSignature>(1),<empty>,,true,,,blockend,,,0,<unresolvedSignature>
111669157249,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.iskeyword:<unresolvedSignature>(2),<empty>,,true,,,iskeyword,,,0,<unresolvedSignature>
111669157250,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.isexporter<const>:bool(ANY),<empty>,,true,,,isexporter,,,0,bool(ANY)
111669157251,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Library.isexportedprefix<const>:bool(ANY,ANY)",<empty>,,true,,,isexportedprefix,,,0,"bool(ANY,ANY)"
111669157252,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Library.isexportedsuffix<const>:bool(ANY,ANY)",<empty>,,true,,,isexportedsuffix,,,0,"bool(ANY,ANY)"
111669157253,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isimporter:<unresolvedSignature>(2),<empty>,,true,,,isimporter,,,0,<unresolvedSignature>
111669157254,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.isreflection<const>:bool(ANY),<empty>,,true,,,isreflection,,,0,bool(ANY)
111669157255,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.reflectionArgument<const>:int(ANY),<empty>,,true,,,reflectionArgument,,,0,int(ANY)
111669157256,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.hasAttributeCleanup<const>:bool(),<empty>,,true,,,hasAttributeCleanup,,,0,bool()
111669157257,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.getAttributeCleanup<const>:ANY(),<empty>,,true,,,getAttributeCleanup,,,0,ANY()
111669157258,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lib/checkunusedfunctions.cpp,lib/checkunusedfunctions.cpp:359:363:logChecker:1,<empty>,,true,359,363,logChecker,,,0,
111669157259,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isentrypoint:<unresolvedSignature>(1),<empty>,,true,,,isentrypoint,,,0,<unresolvedSignature>
111669157260,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isOperatorFunction:<unresolvedSignature>(1),<empty>,,true,,,isOperatorFunction,,,0,<unresolvedSignature>
111669157261,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.emplace_back:<unresolvedSignature>(4),<empty>,,true,,,emplace_back,,,0,<unresolvedSignature>
111669157262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sort:<unresolvedSignature>(2),<empty>,,true,,,sort,,,0,<unresolvedSignature>
111669157263,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.unusedFunctionError:<unresolvedSignature>(5),<empty>,,true,,,unusedFunctionError,,,0,<unresolvedSignature>
111669157264,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.staticFunctionError:<unresolvedSignature>(5),<empty>,,true,,,staticFunctionError,,,0,<unresolvedSignature>
111669157265,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Location:<unresolvedSignature>(2),<empty>,,true,,,Location,,,0,<unresolvedSignature>
111669157266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.stripTemplateParameters:<unresolvedSignature>(1),<empty>,,true,,,stripTemplateParameters,,,0,<unresolvedSignature>
111669157267,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isOperatorFunction:bool(ANY),<empty>,,true,,,isOperatorFunction,,,0,bool(ANY)
111669157268,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckUnusedFunctions.unusedFunctionError:void(ErrorLogger&,ANY,unsigned int,unsigned int,ANY)",<empty>,,true,,,unusedFunctionError,,,0,"void(ErrorLogger&,ANY,unsigned int,unsigned int,ANY)"
111669157269,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.VariableUsage:<unresolvedSignature>(5),<empty>,,true,,,VariableUsage,,,0,<unresolvedSignature>
111669157270,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isThrow:<unresolvedSignature>(0),<empty>,,true,,,isThrow,,,0,<unresolvedSignature>
111669157271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isExtern:<unresolvedSignature>(0),<empty>,,true,,,isExtern,,,0,<unresolvedSignature>
111669157272,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isArray:<unresolvedSignature>(0),<empty>,,true,,,isArray,,,0,<unresolvedSignature>
111669157273,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isReference:<unresolvedSignature>(0),<empty>,,true,,,isReference,,,0,<unresolvedSignature>
111669157274,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.typeStartToken:<unresolvedSignature>(0),<empty>,,true,,,typeStartToken,,,0,<unresolvedSignature>
111669157275,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isPointerToArray:<unresolvedSignature>(0),<empty>,,true,,,isPointerToArray,,,0,<unresolvedSignature>
111669157276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isPointer:<unresolvedSignature>(0),<empty>,,true,,,isPointer,,,0,<unresolvedSignature>
111669157277,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isStandardType:<unresolvedSignature>(0),<empty>,,true,,,isStandardType,,,0,<unresolvedSignature>
111669157278,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isStlType:<unresolvedSignature>(0),<empty>,,true,,,isStlType,,,0,<unresolvedSignature>
111669157279,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isRecordTypeWithoutSideEffects:<unresolvedSignature>(1),<empty>,,true,,,isRecordTypeWithoutSideEffects,,,0,<unresolvedSignature>
111669157280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.type:<unresolvedSignature>(0),<empty>,,true,,,type,,,0,<unresolvedSignature>
111669157281,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.detectContainer:<unresolvedSignature>(1),<empty>,,true,,,detectContainer,,,0,<unresolvedSignature>
111669157282,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isPartOfClassStructUnion:<unresolvedSignature>(1),<empty>,,true,,,isPartOfClassStructUnion,,,0,<unresolvedSignature>
111669157283,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addVar:<unresolvedSignature>(3),<empty>,,true,,,addVar,,,0,<unresolvedSignature>
111669157284,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isStatic:<unresolvedSignature>(0),<empty>,,true,,,isStatic,,,0,<unresolvedSignature>
111669157285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.scope:<unresolvedSignature>(0),<empty>,,true,,,scope,,,0,<unresolvedSignature>
111669157286,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isClass:<unresolvedSignature>(0),<empty>,,true,,,isClass,,,0,<unresolvedSignature>
111669157287,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.write:<unresolvedSignature>(2),<empty>,,true,,,write,,,0,<unresolvedSignature>
111669157288,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.declarationId:<unresolvedSignature>(0),<empty>,,true,,,declarationId,,,0,<unresolvedSignature>
111669157289,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.read:<unresolvedSignature>(2),<empty>,,true,,,read,,,0,<unresolvedSignature>
111669157290,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.doAssignment:<unresolvedSignature>(4),<empty>,,true,,,doAssignment,,,0,<unresolvedSignature>
111669157291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isExtendedOp<const>:bool(),<empty>,,true,,,isExtendedOp,,,0,bool()
111669157292,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():void(Token*,std.string&)",<empty>,,true,,,<operator>(),,,0,"void(Token*,std.string&)"
111669157293,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckUnusedVar.unreadVariableError:void(Token*,ANY,bool)",<empty>,,true,,,unreadVariableError,,,0,"void(Token*,ANY,bool)"
111669157294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAttributeUsed<const>:bool(),<empty>,,true,,,isAttributeUsed,,,0,bool()
111669157295,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckUnusedVar.allocatedButUnusedVariableError:void(Token*,ANY)",<empty>,,true,,,allocatedButUnusedVariableError,,,0,"void(Token*,ANY)"
111669157296,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckUnusedVar.unusedVariableError:void(Token*,ANY)",<empty>,,true,,,unusedVariableError,,,0,"void(Token*,ANY)"
111669157297,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckUnusedVar.unassignedVariableError:void(Token*,ANY)",<empty>,,true,,,unassignedVariableError,,,0,"void(Token*,ANY)"
111669157298,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAttributePacked<const>:bool(),<empty>,,true,,,isAttributePacked,,,0,bool()
111669157299,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findmatch:<unresolvedSignature>(2),<empty>,,true,,,findmatch,,,0,<unresolvedSignature>
111669157300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckUnusedVar.unusedStructMemberError:void(Token*,ANY,ANY,ANY)",<empty>,,true,,,unusedStructMemberError,,,0,"void(Token*,ANY,ANY,ANY)"
111669157301,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<unresolvedNamespace>.pair<const Type *, bool>:<unresolvedSignature>(2)",<empty>,,true,,,"pair<const Type *, bool>",,,0,<unresolvedSignature>
111669157302,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckUnusedVar.isFunctionWithoutSideEffects:bool(Function&,Token*,ANY)",<empty>,,true,,,isFunctionWithoutSideEffects,,,0,"bool(Function&,Token*,ANY)"
111669157303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isNameOnly<const>:bool(),<empty>,,true,,,isNameOnly,,,0,bool()
111669157304,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.unusedVariableError:<unresolvedSignature>(2),<empty>,,true,,,unusedVariableError,,,0,<unresolvedSignature>
111669157305,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.allocatedButUnusedVariableError:<unresolvedSignature>(2),<empty>,,true,,,allocatedButUnusedVariableError,,,0,<unresolvedSignature>
111669157306,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.unreadVariableError:<unresolvedSignature>(3),<empty>,,true,,,unreadVariableError,,,0,<unresolvedSignature>
111669157307,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.unassignedVariableError:<unresolvedSignature>(2),<empty>,,true,,,unassignedVariableError,,,0,<unresolvedSignature>
111669157308,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.unusedStructMemberError:<unresolvedSignature>(3),<empty>,,true,,,unusedStructMemberError,,,0,<unresolvedSignature>
111669157309,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckVaarg.referenceAs_va_start_error:void(Token*,ANY)",<empty>,,true,,,referenceAs_va_start_error,,,0,"void(Token*,ANY)"
111669157310,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.index<const>:int(),<empty>,,true,,,index,,,0,int()
111669157311,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.advance:<unresolvedSignature>(2),<empty>,,true,,,advance,,,0,<unresolvedSignature>
111669157312,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.wrongParameterTo_va_start_error:<unresolvedSignature>(3),<empty>,,true,,,wrongParameterTo_va_start_error,,,0,<unresolvedSignature>
111669157313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckVaarg.va_start_subsequentCallsError:void(Token*,ANY)",<empty>,,true,,,va_start_subsequentCallsError,,,0,"void(Token*,ANY)"
111669157314,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckVaarg.va_list_usedBeforeStartedError:void(Token*,ANY)",<empty>,,true,,,va_list_usedBeforeStartedError,,,0,"void(Token*,ANY)"
111669157315,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckVaarg.va_end_missingError:void(Token*,ANY)",<empty>,,true,,,va_end_missingError,,,0,"void(Token*,ANY)"
111669157316,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.referenceAs_va_start_error:<unresolvedSignature>(2),<empty>,,true,,,referenceAs_va_start_error,,,0,<unresolvedSignature>
111669157317,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.va_end_missingError:<unresolvedSignature>(2),<empty>,,true,,,va_end_missingError,,,0,<unresolvedSignature>
111669157318,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.va_list_usedBeforeStartedError:<unresolvedSignature>(2),<empty>,,true,,,va_list_usedBeforeStartedError,,,0,<unresolvedSignature>
111669157319,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.va_start_subsequentCallsError:<unresolvedSignature>(2),<empty>,,true,,,va_start_subsequentCallsError,,,0,<unresolvedSignature>
111669157320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.find_first_not_of:<unresolvedSignature>(1),<empty>,,true,,,find_first_not_of,,,0,<unresolvedSignature>
111669157321,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.find_first_not_of:<unresolvedSignature>(2),<empty>,,true,,,find_first_not_of,,,0,<unresolvedSignature>
111669157322,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.compare:<unresolvedSignature>(5),<empty>,,true,,,compare,,,0,<unresolvedSignature>
111669157323,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.enumerator:void(Enumerator*),<empty>,,true,,,enumerator,,,0,void(Enumerator*)
111669157324,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.variable:void(Variable*),<empty>,,true,,,variable,,,0,void(Variable*)
111669157325,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.varId:void(int),<empty>,,true,,,varId,,,0,void(int)
111669157326,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,clangimport.Data.notFound:void(ANY),<empty>,,true,,,notFound,,,0,void(ANY)
111669157327,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ref:<unresolvedSignature>(1),<empty>,,true,,,ref,,,0,<unresolvedSignature>
111669157328,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"clangimport.Data.ref:void(ANY,Token*)",<empty>,,true,,,ref,,,0,"void(ANY,Token*)"
111669157329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,clangimport.AstNode.isPrologueTypedefDecl:bool(),<empty>,,true,,,isPrologueTypedefDecl,,,0,bool()
111669157330,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TokenList.back:Token*(),<empty>,,true,,,back,,,0,Token*()
111669157331,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addtoken:<unresolvedSignature>(2),<empty>,,true,,,addtoken,,,0,<unresolvedSignature>
111669157332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.InternalError:<unresolvedSignature>(2),<empty>,,true,,,InternalError,,,0,<unresolvedSignature>
111669157333,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,clangimport.AstNode.getFullType:ANY(int),<empty>,,true,,,getFullType,,,0,ANY(int)
111669157334,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.dumpAst:<unresolvedSignature>(2),<empty>,,true,,,dumpAst,,,0,<unresolvedSignature>
111669157335,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.find_first_of:<unresolvedSignature>(2),<empty>,,true,,,find_first_of,,,0,<unresolvedSignature>
111669157336,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.appendFileIfNew:<unresolvedSignature>(1),<empty>,,true,,,appendFileIfNew,,,0,<unresolvedSignature>
111669157337,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setLocations:<unresolvedSignature>(4),<empty>,,true,,,setLocations,,,0,<unresolvedSignature>
111669157338,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TokenList.addtoken:void(ANY,int,int,int,bool)",<empty>,,true,,,addtoken,,,0,"void(ANY,int,int,int,bool)"
111669157339,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.scope:void(Scope*),<empty>,,true,,,scope,,,0,void(Scope*)
111669157340,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addTypeTokens:<unresolvedSignature>(3),<empty>,,true,,,addTypeTokens,,,0,<unresolvedSignature>
111669157341,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,splitString:ANY(ANY),<empty>,,true,,,splitString,,,0,ANY(ANY)
111669157342,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"clangimport.AstNode.addtoken:Token*(TokenList&,ANY,bool)",<empty>,,true,,,addtoken,,,0,"Token*(TokenList&,ANY,bool)"
111669157343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.createMutualLinks:<unresolvedSignature>(2),<empty>,,true,,,createMutualLinks,,,0,<unresolvedSignature>
111669157344,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,clangimport.AstNode.getType:ANY(int),<empty>,,true,,,getType,,,0,ANY(int)
111669157345,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"clangimport.AstNode.addTypeTokens:Type*(TokenList&,ANY,Scope*)",<empty>,,true,,,addTypeTokens,,,0,"Type*(TokenList&,ANY,Scope*)"
111669157346,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TokenList.front:Token*(),<empty>,,true,,,front,,,0,Token*()
111669157347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.createScope:<unresolvedSignature>(4),<empty>,,true,,,createScope,,,0,<unresolvedSignature>
111669157348,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.variable:<unresolvedSignature>(1),<empty>,,true,,,variable,,,0,<unresolvedSignature>
111669157349,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.createTokens:<unresolvedSignature>(1),<empty>,,true,,,createTokens,,,0,<unresolvedSignature>
111669157350,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getChild:<unresolvedSignature>(1),<empty>,,true,,,getChild,,,0,<unresolvedSignature>
111669157351,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,clangimport.AstNode.getChild:ANY(int),<empty>,,true,,,getChild,,,0,ANY(int)
111669157352,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.link:void(Token*),<empty>,,true,,,link,,,0,void(Token*)
111669157353,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.toBigNumber:<unresolvedSignature>(1),<empty>,,true,,,toBigNumber,,,0,<unresolvedSignature>
111669157354,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,clangimport.AstNode.getSpelling:ANY(),<empty>,,true,,,getSpelling,,,0,ANY()
111669157355,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.astOperand1:<unresolvedSignature>(1),<empty>,,true,,,astOperand1,,,0,<unresolvedSignature>
111669157356,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,clangimport.Data.hasDecl<const>:bool(ANY),<empty>,,true,,,hasDecl,,,0,bool(ANY)
111669157357,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.enumDecl:<unresolvedSignature>(3),<empty>,,true,,,enumDecl,,,0,<unresolvedSignature>
111669157358,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addTypeTokens:<unresolvedSignature>(2),<empty>,,true,,,addTypeTokens,,,0,<unresolvedSignature>
111669157359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.astOperand2:<unresolvedSignature>(1),<empty>,,true,,,astOperand2,,,0,<unresolvedSignature>
111669157360,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.originalName:void(char(&)[3]),<empty>,,true,,,originalName,,,0,void(char(&)[3])
111669157361,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ref:<unresolvedSignature>(2),<empty>,,true,,,ref,,,0,<unresolvedSignature>
111669157362,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,clangimport.AstNode.isDefinition:bool(),<empty>,,true,,,isDefinition,,,0,bool()
111669157363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setValueType:<unresolvedSignature>(1),<empty>,,true,,,setValueType,,,0,<unresolvedSignature>
111669157364,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,clangimport.Data.getScope:Scope*(ANY),<empty>,,true,,,getScope,,,0,Scope*(ANY)
111669157365,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,clangimport.AstNode.getTemplateParameters:ANY(),<empty>,,true,,,getTemplateParameters,,,0,ANY()
111669157366,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.funcDecl:<unresolvedSignature>(3),<empty>,,true,,,funcDecl,,,0,<unresolvedSignature>
111669157367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.hasBody:void(bool),<empty>,,true,,,hasBody,,,0,void(bool)
111669157368,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getSpelling:<unresolvedSignature>(0),<empty>,,true,,,getSpelling,,,0,<unresolvedSignature>
111669157369,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.emplace_back:<unresolvedSignature>(8),<empty>,,true,,,emplace_back,,,0,<unresolvedSignature>
111669157370,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getType:<unresolvedSignature>(0),<empty>,,true,,,getType,,,0,<unresolvedSignature>
111669157371,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.varDecl:<unresolvedSignature>(3),<empty>,,true,,,varDecl,,,0,<unresolvedSignature>
111669157372,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"clangimport.Data.scopeDecl:void(ANY,Scope*)",<empty>,,true,,,scopeDecl,,,0,"void(ANY,Scope*)"
111669157373,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.tokAt:Token*(int),<empty>,,true,,,tokAt,,,0,Token*(int)
111669157374,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Scope.findType<const>:Type*(ANY),<empty>,,true,,,findType,,,0,Type*(ANY)
111669157375,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.strToInt<long long>:<unresolvedSignature>(1),<empty>,,true,,,strToInt<long long>,,,0,<unresolvedSignature>
111669157376,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.createTokens1:<unresolvedSignature>(1),<empty>,,true,,,createTokens1,,,0,<unresolvedSignature>
111669157377,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SymbolDatabase.clangSetVariables:void(ANY),<empty>,,true,,,clangSetVariables,,,0,void(ANY)
111669157378,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,clangimport.Data.getVariableList<const>:ANY(),<empty>,,true,,,getVariableList,,,0,ANY()
111669157379,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isatty:<unresolvedSignature>(1),<empty>,,true,,,isatty,,,0,<unresolvedSignature>
111669157380,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isStreamATty:bool(ANY),<empty>,,true,,,isStreamATty,,,0,bool(ANY)
111669157381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isColorEnabled:bool(ANY),<empty>,,true,,,isColorEnabled,,,0,bool(ANY)
111669157382,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.plistHeader:<unresolvedSignature>(2),<empty>,,true,,,plistHeader,,,0,<unresolvedSignature>
111669157383,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorLogger.plistFooter:char*(),<empty>,,true,,,plistFooter,,,0,char*()
111669157384,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.reportErrors<const>:bool(ANY),<empty>,,true,,,reportErrors,,,0,bool(ANY)
111669157385,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fromErrorMessage:<unresolvedSignature>(2),<empty>,,true,,,fromErrorMessage,,,0,<unresolvedSignature>
111669157386,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isSuppressed:<unresolvedSignature>(2),<empty>,,true,,,isSuppressed,,,0,<unresolvedSignature>
111669157387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isSuppressedExplicitly:<unresolvedSignature>(2),<empty>,,true,,,isSuppressedExplicitly,,,0,<unresolvedSignature>
111669157388,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isSuppressed:<unresolvedSignature>(1),<empty>,,true,,,isSuppressed,,,0,<unresolvedSignature>
111669157389,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorLogger.plistData:ANY(ErrorMessage&),<empty>,,true,,,plistData,,,0,ANY(ErrorMessage&)
111669157390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ErrorLogger.reportProgress:void(ANY,char*,ANY)",<empty>,,true,,,reportProgress,,,0,"void(ANY,char*,ANY)"
111669157391,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getAnalyzerInfoFile:<unresolvedSignature>(3),<empty>,,true,,,getAnalyzerInfoFile,,,0,<unresolvedSignature>
111669157392,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getDumpFileName:ANY(Settings&,ANY)",<empty>,,true,,,getDumpFileName,,,0,"ANY(Settings&,ANY)"
111669157393,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FileWithDetails.spath<const>:ANY(),<empty>,,true,,,spath,,,0,ANY()
111669157394,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getCtuInfoFileName:ANY(ANY),<empty>,,true,,,getCtuInfoFileName,,,0,ANY(ANY)
111669157395,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Path.identify:Standards.Language(ANY,bool,bool*)",<empty>,,true,,,identify,,,0,"Standards.Language(ANY,bool,bool*)"
111669157396,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Platform.toString<const>:char*(),<empty>,,true,,,toString,,,0,char*()
111669157397,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cmdFileName:ANY(ANY),<empty>,,true,,,cmdFileName,,,0,ANY(ANY)
111669157398,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,detectPython:ANY(ANY),<empty>,,true,,,detectPython,,,0,ANY(ANY)
111669157399,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"split:ANY(ANY,ANY)",<empty>,,true,,,split,,,0,"ANY(ANY,ANY)"
111669157400,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setAnalyzerInfo:<unresolvedSignature>(1),<empty>,,true,,,setAnalyzerInfo,,,0,<unresolvedSignature>
111669157401,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.strToInt<unsigned int>:<unresolvedSignature>(1),<empty>,,true,,,strToInt<unsigned int>,,,0,<unresolvedSignature>
111669157402,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getDefinesFlags:ANY(ANY),<empty>,,true,,,getDefinesFlags,,,0,ANY(ANY)
111669157403,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.reset:<unresolvedSignature>(1),<empty>,,true,,,reset,,,0,<unresolvedSignature>
111669157404,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CppCheck.getClangFlags:ANY(Standards.Language),<empty>,,true,,,getClangFlags,,,0,ANY(Standards.Language)
111669157405,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.mExecuteCommand:<unresolvedSignature>(4),<empty>,,true,,,mExecuteCommand,,,0,<unresolvedSignature>
111669157406,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.reportClangErrors:<unresolvedSignature>(3),<empty>,,true,,,reportClangErrors,,,0,<unresolvedSignature>
111669157407,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TokenList.appendFileIfNew:int(ANY),<empty>,,true,,,appendFileIfNew,,,0,int(ANY)
111669157408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"clangimport.parseClangAstDump:void(Tokenizer&,ANY)",<empty>,,true,,,parseClangAstDump,,,0,"void(Tokenizer&,ANY)"
111669157409,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.printDebugOutput:<unresolvedSignature>(2),<empty>,,true,,,printDebugOutput,,,0,<unresolvedSignature>
111669157410,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"createDumpFile:void(Settings&,FileWithDetails&,ANY,ANY)",<empty>,,true,,,createDumpFile,,,0,"void(Settings&,FileWithDetails&,ANY,ANY)"
111669157411,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CppCheck.getLibraryDumpData:ANY(),<empty>,,true,,,getLibraryDumpData,,,0,ANY()
111669157412,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.toxml:<unresolvedSignature>(1),<empty>,,true,,,toxml,,,0,<unresolvedSignature>
111669157413,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getfile:<unresolvedSignature>(0),<empty>,,true,,,getfile,,,0,<unresolvedSignature>
111669157414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Standards.getC<const>:ANY(),<empty>,,true,,,getC,,,0,ANY()
111669157415,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.dump<const>:void(ANY),<empty>,,true,,,dump,,,0,void(ANY)
111669157416,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CppCheck.executeAddons:void(ANY,FileWithDetails&)",<empty>,,true,,,executeAddons,,,0,"void(ANY,FileWithDetails&)"
111669157417,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fromInternalError:<unresolvedSignature>(4),<empty>,,true,,,fromInternalError,,,0,<unresolvedSignature>
111669157418,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.internalError:<unresolvedSignature>(2),<empty>,,true,,,internalError,,,0,<unresolvedSignature>
111669157419,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.exitcode:<unresolvedSignature>(0),<empty>,,true,,,exitcode,,,0,<unresolvedSignature>
111669157420,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.checkFile:<unresolvedSignature>(2),<empty>,,true,,,checkFile,,,0,<unresolvedSignature>
111669157421,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.checkFile:<unresolvedSignature>(3),<empty>,,true,,,checkFile,,,0,<unresolvedSignature>
111669157422,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FileSettings.cppcheckDefines<const>:ANY(),<empty>,,true,,,cppcheckDefines,,,0,ANY()
111669157423,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Standards.setCPP:bool(ANY),<empty>,,true,,,setCPP,,,0,bool(ANY)
111669157424,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Standards.setC:bool(ANY),<empty>,,true,,,setC,,,0,bool(ANY)
111669157425,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.updateFunctionData:<unresolvedSignature>(1),<empty>,,true,,,updateFunctionData,,,0,<unresolvedSignature>
111669157426,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CppCheck.checkFile:unsigned int(FileWithDetails&,ANY,ANY)",<empty>,,true,,,checkFile,,,0,"unsigned int(FileWithDetails&,ANY,ANY)"
111669157427,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lib/version.h,lib/version.h:36:36:CPPCHECK_VERSION_STRING:0,<empty>,,true,36,36,CPPCHECK_VERSION_STRING,,,0,
111669157428,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.calculateHash:<unresolvedSignature>(2),<empty>,,true,,,calculateHash,,,0,<unresolvedSignature>
111669157429,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Preprocessor.hasErrors:bool(ANY),<empty>,,true,,,hasErrors,,,0,bool(ANY)
111669157430,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Preprocessor.getConfigs<const>:ANY(simplecpp.TokenList&),<empty>,,true,,,getConfigs,,,0,ANY(simplecpp.TokenList&)
111669157431,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getcode:<unresolvedSignature>(4),<empty>,,true,,,getcode,,,0,<unresolvedSignature>
111669157432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.preprocess:<unresolvedSignature>(4),<empty>,,true,,,preprocess,,,0,<unresolvedSignature>
111669157433,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.resetExitCode:<unresolvedSignature>(0),<empty>,,true,,,resetExitCode,,,0,<unresolvedSignature>
111669157434,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.closePlist:<unresolvedSignature>(0),<empty>,,true,,,closePlist,,,0,<unresolvedSignature>
111669157435,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,files,<empty>,,true,,,files,,,0,
111669157436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"calculateHash:ANY(Preprocessor&,simplecpp.TokenList&,Settings&,Suppressions&)",<empty>,,true,,,calculateHash,,,0,"ANY(Preprocessor&,simplecpp.TokenList&,Settings&,Suppressions&)"
111669157437,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.parseTokens:<unresolvedSignature>(2),<empty>,,true,,,parseTokens,,,0,<unresolvedSignature>
111669157438,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.analyzeFile:<unresolvedSignature>(5),<empty>,,true,,,analyzeFile,,,0,<unresolvedSignature>
111669157439,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setFileInfo:<unresolvedSignature>(2),<empty>,,true,,,setFileInfo,,,0,<unresolvedSignature>
111669157440,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.analyzerInfo:<unresolvedSignature>(0),<empty>,,true,,,analyzerInfo,,,0,<unresolvedSignature>
111669157441,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.createTokenList:<unresolvedSignature>(4),<empty>,,true,,,createTokenList,,,0,<unresolvedSignature>
111669157442,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.file:<unresolvedSignature>(0),<empty>,,true,,,file,,,0,<unresolvedSignature>
111669157443,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Path.getRelativePath:ANY(ANY,ANY)",<empty>,,true,,,getRelativePath,,,0,"ANY(ANY,ANY)"
111669157444,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.loadFiles:<unresolvedSignature>(2),<empty>,,true,,,loadFiles,,,0,<unresolvedSignature>
111669157445,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.openPlist:<unresolvedSignature>(2),<empty>,,true,,,openPlist,,,0,<unresolvedSignature>
111669157446,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getDumpFileContentsRawTokens:<unresolvedSignature>(2),<empty>,,true,,,getDumpFileContentsRawTokens,,,0,<unresolvedSignature>
111669157447,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setRemarkComments:<unresolvedSignature>(1),<empty>,,true,,,setRemarkComments,,,0,<unresolvedSignature>
111669157448,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Preprocessor.getRemarkComments<const>:ANY(simplecpp.TokenList&),<empty>,,true,,,getRemarkComments,,,0,ANY(simplecpp.TokenList&)
111669157449,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Preprocessor.createDirectives<const>:ANY(simplecpp.TokenList&),<empty>,,true,,,createDirectives,,,0,ANY(simplecpp.TokenList&)
111669157450,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.run:<unresolvedSignature>(4),<empty>,,true,,,run,,,0,<unresolvedSignature>
111669157451,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FilesDeleter.addFile:void(ANY),<empty>,,true,,,addFile,,,0,void(ANY)
111669157452,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.setTimerResults:void(TimerResults*),<empty>,,true,,,setTimerResults,,,0,void(TimerResults*)
111669157453,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.setDirectives:void(ANY),<empty>,,true,,,setDirectives,,,0,void(ANY)
111669157454,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setLocationMacros:<unresolvedSignature>(2),<empty>,,true,,,setLocationMacros,,,0,<unresolvedSignature>
111669157455,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.tokens:Token*(),<empty>,,true,,,tokens,,,0,Token*()
111669157456,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.simplifyTokens1:bool(ANY),<empty>,,true,,,simplifyTokens1,,,0,bool(ANY)
111669157457,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Preprocessor.dump<const>:void(ANY),<empty>,,true,,,dump,,,0,void(ANY)
111669157458,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TokenList.calculateHash<const>:ANY(),<empty>,,true,,,calculateHash,,,0,ANY()
111669157459,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CppCheck.purgedConfigurationMessage:void(ANY,ANY)",<empty>,,true,,,purgedConfigurationMessage,,,0,"void(ANY,ANY)"
111669157460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.checkNormalTokens:<unresolvedSignature>(2),<empty>,,true,,,checkNormalTokens,,,0,<unresolvedSignature>
111669157461,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ErrorMessage.fromInternalError:ErrorMessage(InternalError&,TokenList*,ANY,ANY)",<empty>,,true,,,fromInternalError,,,0,"ErrorMessage(InternalError&,TokenList*,ANY,ANY)"
111669157462,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SuppressionList.getUnmatchedLocalSuppressions<const>:ANY(FileWithDetails&,bool)",<empty>,,true,,,getUnmatchedLocalSuppressions,,,0,"ANY(FileWithDetails&,bool)"
111669157463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.reset:<unresolvedSignature>(0),<empty>,,true,,,reset,,,0,<unresolvedSignature>
111669157464,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Check.runChecks:void(Tokenizer&,ErrorLogger*)",<empty>,,true,,,runChecks,,,0,"void(Tokenizer&,ErrorLogger*)"
111669157465,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CTU.FileInfo.toString<const>:ANY(),<empty>,,true,,,toString,,,0,ANY()
111669157466,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Check.getFileInfo<const>:Check.FileInfo*(Tokenizer&,Settings&)",<empty>,,true,,,getFileInfo,,,0,"Check.FileInfo*(Tokenizer&,Settings&)"
111669157467,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"AnalyzerInformation.setFileInfo:void(ANY,ANY)",<empty>,,true,,,setFileInfo,,,0,"void(ANY,ANY)"
111669157468,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Check.FileInfo.toString<const>:ANY(),<empty>,,true,,,toString,,,0,ANY()
111669157469,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckUnusedFunctions.analyzerInfo<const>:ANY(),<empty>,,true,,,analyzerInfo,,,0,ANY()
111669157470,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.executeAddons:<unresolvedSignature>(2),<empty>,,true,,,executeAddons,,,0,<unresolvedSignature>
111669157471,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"executeAddon:ANY(AddonInfo&,ANY,ANY,ANY,ANY)",<empty>,,true,,,executeAddon,,,0,"ANY(AddonInfo&,ANY,ANY,ANY,ANY)"
111669157472,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setmsg:<unresolvedSignature>(1),<empty>,,true,,,setmsg,,,0,<unresolvedSignature>
111669157473,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.get<int64_t>:<unresolvedSignature>(0),<empty>,,true,,,get<int64_t>,,,0,<unresolvedSignature>
111669157474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getMisraRuleText:<unresolvedSignature>(2),<empty>,,true,,,getMisraRuleText,,,0,<unresolvedSignature>
111669157475,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,severityFromString:Severity(ANY),<empty>,,true,,,severityFromString,,,0,Severity(ANY)
111669157476,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CppCheck.isPremiumCodingStandardId:bool(ANY),<empty>,,true,,,isPremiumCodingStandardId,,,0,bool(ANY)
111669157477,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getDumpFileName:<unresolvedSignature>(2),<empty>,,true,,,getDumpFileName,,,0,<unresolvedSignature>
111669157478,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.purgedConfigurationMessage:<unresolvedSignature>(2),<empty>,,true,,,purgedConfigurationMessage,,,0,<unresolvedSignature>
111669157479,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getErrorMessages:<unresolvedSignature>(2),<empty>,,true,,,getErrorMessages,,,0,<unresolvedSignature>
111669157480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckUnusedFunctions.getErrorMessages:void(ErrorLogger&),<empty>,,true,,,getErrorMessages,,,0,void(ErrorLogger&)
111669157481,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.strToInt<int64_t>:<unresolvedSignature>(1),<empty>,,true,,,strToInt<int64_t>,,,0,<unresolvedSignature>
111669157482,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Check.analyseWholeProgram:bool(CTU.FileInfo&,ANY,Settings&,ErrorLogger&)",<empty>,,true,,,analyseWholeProgram,,,0,"bool(CTU.FileInfo&,ANY,Settings&,ErrorLogger&)"
111669157483,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CppCheck.executeAddonsWholeProgram:void(ANY,ANY,ANY)",<empty>,,true,,,executeAddonsWholeProgram,,,0,"void(ANY,ANY,ANY)"
111669157484,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CheckUnusedFunctions.analyseWholeProgram:void(Settings&,ErrorLogger&,ANY)",<empty>,,true,,,analyseWholeProgram,,,0,"void(Settings&,ErrorLogger&,ANY)"
111669157485,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Check.loadFileInfoFromXml<const>:Check.FileInfo*(tinyxml2.XMLElement*),<empty>,,true,,,loadFileInfoFromXml,,,0,Check.FileInfo*(tinyxml2.XMLElement*)
111669157486,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CTU.FileInfo.FunctionCall.toXmlString<const>:ANY(),<empty>,,true,,,toXmlString,,,0,ANY()
111669157487,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CTU.FileInfo.NestedCall.toXmlString<const>:ANY(),<empty>,,true,,,toXmlString,,,0,ANY()
111669157488,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CTU.FileInfo.CallBase.toBaseXmlString:ANY(),<empty>,,true,,,toBaseXmlString,,,0,ANY()
111669157489,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorMessage.FileLocation.getfile<const>:ANY(bool),<empty>,,true,,,getfile,,,0,ANY(bool)
111669157490,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorMessage.FileLocation.getinfo<const>:ANY(),<empty>,,true,,,getinfo,,,0,ANY()
111669157491,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CTU.FileInfo.UnsafeUsage.toString<const>:ANY(),<empty>,,true,,,toString,,,0,ANY()
111669157492,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,empty_if_null:char*(char*),<empty>,,true,,,empty_if_null,,,0,char*(char*)
111669157493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QueryInt64Attribute:<unresolvedSignature>(2),<empty>,,true,,,QueryInt64Attribute,,,0,<unresolvedSignature>
111669157494,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"readAttrString:ANY(tinyxml2.XMLElement*,char*,bool*)",<empty>,,true,,,readAttrString,,,0,"ANY(tinyxml2.XMLElement*,char*,bool*)"
111669157495,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.isBufferSizeValue<const>:bool(),<empty>,,true,,,isBufferSizeValue,,,0,bool()
111669157496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CTU.getFunctionId:ANY(Tokenizer&,Function*)",<empty>,,true,,,getFunctionId,,,0,"ANY(Tokenizer&,Function*)"
111669157497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.file:<unresolvedSignature>(1),<empty>,,true,,,file,,,0,<unresolvedSignature>
111669157498,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.pointerCall,<empty>,,true,,,<operator>.pointerCall,,,0,
111669157499,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getUnsafeFunction:ANY(Settings&,Scope*,int,bool(*)(constSettings&,Token*,CTU.FileInfo.Value*))",<empty>,,true,,,getUnsafeFunction,,,0,"ANY(Settings&,Scope*,int,bool(*)(constSettings&,Token*,CTU.FileInfo.Value*))"
111669157500,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.emplace_back:<unresolvedSignature>(5),<empty>,,true,,,emplace_back,,,0,<unresolvedSignature>
111669157501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"findPath:bool(ANY,int,longlongint,CTU.FileInfo.InvalidValueType,ANY,CTU.FileInfo.CallBase**,int,bool,int)",<empty>,,true,,,findPath,,,0,"bool(ANY,int,longlongint,CTU.FileInfo.InvalidValueType,ANY,CTU.FileInfo.CallBase**,int,bool,int)"
111669157502,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.replaceStr:<unresolvedSignature>(3),<empty>,,true,,,replaceStr,,,0,<unresolvedSignature>
111669157503,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.severityFromString:<unresolvedSignature>(1),<empty>,,true,,,severityFromString,,,0,<unresolvedSignature>
111669157504,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.strToInt<unsigned short>:<unresolvedSignature>(1),<empty>,,true,,,strToInt<unsigned short>,,,0,<unresolvedSignature>
111669157505,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.emplace_front:<unresolvedSignature>(4),<empty>,,true,,,emplace_front,,,0,<unresolvedSignature>
111669157506,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.GetText:<unresolvedSignature>(0),<empty>,,true,,,GetText,,,0,<unresolvedSignature>
111669157507,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"serializeString:void(ANY,ANY)",<empty>,,true,,,serializeString,,,0,"void(ANY,ANY)"
111669157508,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.serializeString:<unresolvedSignature>(2),<empty>,,true,,,serializeString,,,0,<unresolvedSignature>
111669157509,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorMessage.fixInvalidChars:ANY(ANY),<empty>,,true,,,fixInvalidChars,,,0,ANY(ANY)
111669157510,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getOrigFile:<unresolvedSignature>(1),<empty>,,true,,,getOrigFile,,,0,<unresolvedSignature>
111669157511,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getinfo:<unresolvedSignature>(0),<empty>,,true,,,getinfo,,,0,<unresolvedSignature>
111669157512,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setfile:<unresolvedSignature>(1),<empty>,,true,,,setfile,,,0,<unresolvedSignature>
111669157513,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.PushDeclaration:<unresolvedSignature>(1),<empty>,,true,,,PushDeclaration,,,0,<unresolvedSignature>
111669157514,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.OpenElement:<unresolvedSignature>(2),<empty>,,true,,,OpenElement,,,0,<unresolvedSignature>
111669157515,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.PushAttribute:<unresolvedSignature>(2),<empty>,,true,,,PushAttribute,,,0,<unresolvedSignature>
111669157516,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.CloseElement:<unresolvedSignature>(1),<empty>,,true,,,CloseElement,,,0,<unresolvedSignature>
111669157517,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.CStr:<unresolvedSignature>(0),<empty>,,true,,,CStr,,,0,<unresolvedSignature>
111669157518,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isprint:<unresolvedSignature>(1),<empty>,,true,,,isprint,,,0,<unresolvedSignature>
111669157519,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setbase:<unresolvedSignature>(1),<empty>,,true,,,setbase,,,0,<unresolvedSignature>
111669157520,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setw:<unresolvedSignature>(1),<empty>,,true,,,setw,,,0,<unresolvedSignature>
111669157521,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setfill:<unresolvedSignature>(1),<empty>,,true,,,setfill,,,0,<unresolvedSignature>
111669157522,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fixInvalidChars:<unresolvedSignature>(1),<empty>,,true,,,fixInvalidChars,,,0,<unresolvedSignature>
111669157523,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.PushText:<unresolvedSignature>(1),<empty>,,true,,,PushText,,,0,<unresolvedSignature>
111669157524,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,toString:ANY(Color),<empty>,,true,,,toString,,,0,ANY(Color)
111669157525,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"replace:void(ANY,ANY)",<empty>,,true,,,replace,,,0,"void(ANY,ANY)"
111669157526,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorLogger.callStackToString:ANY(ANY),<empty>,,true,,,callStackToString,,,0,ANY(ANY)
111669157527,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findAndReplace:<unresolvedSignature>(3),<empty>,,true,,,findAndReplace,,,0,<unresolvedSignature>
111669157528,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"findAndReplace:void(ANY,ANY,ANY)",<empty>,,true,,,findAndReplace,,,0,"void(ANY,ANY,ANY)"
111669157529,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.readCode:<unresolvedSignature>(4),<empty>,,true,,,readCode,,,0,<unresolvedSignature>
111669157530,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getOrigFile:<unresolvedSignature>(0),<empty>,,true,,,getOrigFile,,,0,<unresolvedSignature>
111669157531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"readCode:ANY(ANY,int,int,char*)",<empty>,,true,,,readCode,,,0,"ANY(ANY,int,int,char*)"
111669157532,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorMessage.FileLocation.getOrigFile<const>:ANY(bool),<empty>,,true,,,getOrigFile,,,0,ANY(bool)
111669157533,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.stringify:<unresolvedSignature>(0),<empty>,,true,,,stringify,,,0,<unresolvedSignature>
111669157534,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.plistLoc:<unresolvedSignature>(2),<empty>,,true,,,plistLoc,,,0,<unresolvedSignature>
111669157535,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,replaceSpecialChars:void(ANY),<empty>,,true,,,replaceSpecialChars,,,0,void(ANY)
111669157536,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,replaceColors:void(ANY),<empty>,,true,,,replaceColors,,,0,void(ANY)
111669157537,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.caseInsensitiveStringCompare:<unresolvedSignature>(2),<empty>,,true,,,caseInsensitiveStringCompare,,,0,<unresolvedSignature>
111669157538,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cppcheck.unreachable:void(),<empty>,,true,,,unreachable,,,0,void()
111669157539,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.found:<unresolvedSignature>(1),<empty>,,true,,,found,,,0,<unresolvedSignature>
111669157540,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.evaluate:<unresolvedSignature>(1),<empty>,,true,,,evaluate,,,0,<unresolvedSignature>
111669157541,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,internal.findTokensSkipDeadCodeImpl:ANY(),<empty>,,true,,,findTokensSkipDeadCodeImpl,,,0,ANY()
111669157542,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isReturnScope:ANY(),<empty>,,true,,,isReturnScope,,,0,ANY()
111669157543,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,astIsLHS:ANY(),<empty>,,true,,,astIsLHS,,,0,ANY()
111669157544,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nextAfterAstRightmostLeaf:ANY(),<empty>,,true,,,nextAfterAstRightmostLeaf,,,0,ANY()
111669157545,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isUnevaluated:ANY(),<empty>,,true,,,isUnevaluated,,,0,ANY()
111669157546,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findTokensSkipDeadCodeImpl:<unresolvedSignature>(7),<empty>,,true,,,findTokensSkipDeadCodeImpl,,,0,<unresolvedSignature>
111669157547,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Analyzer.Action.isModified<const>:bool(),<empty>,,true,,,isModified,,,0,bool()
111669157548,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ForwardTraversal.Branch.isConclusiveEscape:bool(),<empty>,,true,,,isConclusiveEscape,,,0,bool()
111669157549,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Analyzer.Action.isInconclusive<const>:bool(),<empty>,,true,,,isInconclusive,,,0,bool()
111669157550,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ForwardTraversal.Branch.isEscape:bool(),<empty>,,true,,,isEscape,,,0,bool()
111669157551,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Analyzer.analyze<const>:Analyzer.Action(Token*,Analyzer.Direction)",<empty>,,true,,,analyze,,,0,"Analyzer.Action(Token*,Analyzer.Direction)"
111669157552,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Analyzer.isConditional<const>:bool(),<empty>,,true,,,isConditional,,,0,bool()
111669157553,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Analyzer.stopOnCondition<const>:bool(Token*),<empty>,,true,,,stopOnCondition,,,0,bool(Token*)
111669157554,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Analyzer.evaluate<const>:ANY(Token*,Token*)",<empty>,,true,,,evaluate,,,0,"ANY(Token*,Token*)"
111669157555,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ForwardTraversal.evalCond:ANY(Token*,Token*)",<empty>,,true,,,evalCond,,,0,"ANY(Token*,Token*)"
111669157556,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ForwardTraversal.traverseRecursive:ANY(),<empty>,,true,,,traverseRecursive,,,0,ANY()
111669157557,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isEscapeFunction:ANY(),<empty>,,true,,,isEscapeFunction,,,0,ANY()
111669157558,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ForwardTraversal.traverseConditional:ANY(),<empty>,,true,,,traverseConditional,,,0,ANY()
111669157559,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isModified:<unresolvedSignature>(0),<empty>,,true,,,isModified,,,0,<unresolvedSignature>
111669157560,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ForwardTraversal.checkScope:ANY(),<empty>,,true,,,checkScope,,,0,ANY()
111669157561,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isClassOrStruct:<unresolvedSignature>(0),<empty>,,true,,,isClassOrStruct,,,0,<unresolvedSignature>
111669157562,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isAssignmentOp:<unresolvedSignature>(0),<empty>,,true,,,isAssignmentOp,,,0,<unresolvedSignature>
111669157563,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ForwardTraversal.isFunctionCall:ANY(),<empty>,,true,,,isFunctionCall,,,0,ANY()
111669157564,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ForwardTraversal.traverseTok:ANY(),<empty>,,true,,,traverseTok,,,0,ANY()
111669157565,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ForwardTraversal.evalCond:ANY(),<empty>,,true,,,evalCond,,,0,ANY()
111669157566,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ForwardTraversal.stopOnCondition:ANY(),<empty>,,true,,,stopOnCondition,,,0,ANY()
111669157567,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Analyzer.Action.isNone<const>:bool(),<empty>,,true,,,isNone,,,0,bool()
111669157568,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Analyzer.update:void(Token*,Analyzer.Action,Analyzer.Direction)",<empty>,,true,,,update,,,0,"void(Token*,Analyzer.Action,Analyzer.Direction)"
111669157569,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Analyzer.lowerToInconclusive:bool(),<empty>,,true,,,lowerToInconclusive,,,0,bool()
111669157570,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Analyzer.Action.isInvalid<const>:bool(),<empty>,,true,,,isInvalid,,,0,bool()
111669157571,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Analyzer.Action.isWrite<const>:bool(),<empty>,,true,,,isWrite,,,0,bool()
111669157572,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Analyzer.Action.isRead<const>:bool(),<empty>,,true,,,isRead,,,0,bool()
111669157573,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.traverseTok:<unresolvedSignature>(4),<empty>,,true,,,traverseTok,,,0,<unresolvedSignature>
111669157574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.traverseRecursive:<unresolvedSignature>(3),<empty>,,true,,,traverseRecursive,,,0,<unresolvedSignature>
111669157575,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Analyzer.updateScope<const>:bool(Token*,bool)",<empty>,,true,,,updateScope,,,0,"bool(Token*,bool)"
111669157576,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ForwardTraversal.fork:ForwardTraversal(bool),<empty>,,true,,,fork,,,0,ForwardTraversal(bool)
111669157577,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ForwardTraversal.tryForkScope:ANY(Token*,bool)",<empty>,,true,,,tryForkScope,,,0,"ANY(Token*,bool)"
111669157578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ForwardTraversal.analyzeRange:Analyzer.Action(Token*,Token*)",<empty>,,true,,,analyzeRange,,,0,"Analyzer.Action(Token*,Token*)"
111669157579,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ForwardTraversal.analyzeScope:Analyzer.Action(Token*),<empty>,,true,,,analyzeScope,,,0,Analyzer.Action(Token*)
111669157580,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ForwardTraversal.tryForkUpdateScope:ANY(Token*,bool)",<empty>,,true,,,tryForkUpdateScope,,,0,"ANY(Token*,bool)"
111669157581,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ForwardTraversal.hasInnerReturnScope:bool(Token*,Token*)",<empty>,,true,,,hasInnerReturnScope,,,0,"bool(Token*,Token*)"
111669157582,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findExpressionChanged:<unresolvedSignature>(4),<empty>,,true,,,findExpressionChanged,,,0,<unresolvedSignature>
111669157583,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Analyzer.lowerToPossible:bool(),<empty>,,true,,,lowerToPossible,,,0,bool()
111669157584,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Analyzer.Action.isIdempotent<const>:bool(),<empty>,,true,,,isIdempotent,,,0,bool()
111669157585,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ForwardTraversal.stopOnCondition:bool(Token*),<empty>,,true,,,stopOnCondition,,,0,bool(Token*)
111669157586,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Analyzer.assume:void(Token*,bool,unsigned int)",<empty>,,true,,,assume,,,0,"void(Token*,bool,unsigned int)"
111669157587,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ForwardTraversal.reentersLoop:bool(Token*,Token*,Token*)",<empty>,,true,,,reentersLoop,,,0,"bool(Token*,Token*,Token*)"
111669157588,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Analyzer.Action.isIncremental<const>:bool(),<empty>,,true,,,isIncremental,,,0,bool()
111669157589,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Analyzer.updateState:void(Token*),<empty>,,true,,,updateState,,,0,void(Token*)
111669157590,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.astOperand2:Token*(),<empty>,,true,,,astOperand2,,,0,Token*()
111669157591,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.astTop:Token*(),<empty>,,true,,,astTop,,,0,Token*()
111669157592,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.reportError:<unresolvedSignature>(3),<empty>,,true,,,reportError,,,0,<unresolvedSignature>
111669157593,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Analyzer.evaluate<const>:ANY(Analyzer.Evaluate,Token*,Token*)",<empty>,,true,,,evaluate,,,0,"ANY(Analyzer.Evaluate,Token*,Token*)"
111669157594,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ForwardTraversal.isEscapeScope:bool(Token*,bool&)",<empty>,,true,,,isEscapeScope,,,0,"bool(Token*,bool&)"
111669157595,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ForwardTraversal.checkBranch:bool(ForwardTraversal.Branch&),<empty>,,true,,,checkBranch,,,0,bool(ForwardTraversal.Branch&)
111669157596,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.astOperand1:Token*(),<empty>,,true,,,astOperand1,,,0,Token*()
111669157597,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Analyzer.invalid<const>:bool(),<empty>,,true,,,invalid,,,0,bool()
111669157598,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Analyzer::Result,<empty>,,true,,,Analyzer::Result,,,0,
111669157599,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.TerminateException:<unresolvedSignature>(0),<empty>,,true,,,TerminateException,,,0,<unresolvedSignature>
111669157600,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Result:<unresolvedSignature>(1),<empty>,,true,,,Result,,,0,<unresolvedSignature>
111669157601,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Result:<unresolvedSignature>(2),<empty>,,true,,,Result,,,0,<unresolvedSignature>
111669157602,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FwdAnalysis.checkRecursive:FwdAnalysis.Result(Token*,Token*,Token*,ANY,bool,bool,int)",<empty>,,true,,,checkRecursive,,,0,"FwdAnalysis.Result(Token*,Token*,Token*,ANY,bool,bool,int)"
111669157603,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.checkRecursive:<unresolvedSignature>(7),<empty>,,true,,,checkRecursive,,,0,<unresolvedSignature>
111669157604,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"isUnchanged:bool(Token*,Token*,ANY,bool)",<empty>,,true,,,isUnchanged,,,0,"bool(Token*,Token*,ANY,bool)"
111669157605,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FwdAnalysis.hasOperand:bool(Token*,Token*)",<empty>,,true,,,hasOperand,,,0,"bool(Token*,Token*)"
111669157606,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FwdAnalysis.getExprVarIds:ANY(Token*,bool*,bool*)",<empty>,,true,,,getExprVarIds,,,0,"ANY(Token*,bool*,bool*)"
111669157607,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FwdAnalysis.possiblyAliased:bool(Token*,Token*)",<empty>,,true,,,possiblyAliased,,,0,"bool(Token*,Token*)"
111669157608,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isValidGlobPattern:bool(ANY),<empty>,,true,,,isValidGlobPattern,,,0,bool(ANY)
111669157609,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.matchglob:<unresolvedSignature>(2),<empty>,,true,,,matchglob,,,0,<unresolvedSignature>
111669157610,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Path.isAbsolute:bool(ANY),<empty>,,true,,,isAbsolute,,,0,bool(ANY)
111669157611,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplifyPathWithVariables:bool(ANY,ANY)",<empty>,,true,,,simplifyPathWithVariables,,,0,"bool(ANY,ANY)"
111669157612,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.vector<std::string>:<unresolvedSignature>(0),<empty>,,true,,,vector<std::string>,,,0,<unresolvedSignature>
111669157613,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ImportProject.importCompileCommands:bool(ANY),<empty>,,true,,,importCompileCommands,,,0,bool(ANY)
111669157614,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ImportProject.setRelativePaths:void(ANY),<empty>,,true,,,setRelativePaths,,,0,void(ANY)
111669157615,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ImportProject.importSln:bool(ANY,ANY,ANY)",<empty>,,true,,,importSln,,,0,"bool(ANY,ANY,ANY)"
111669157616,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.importVcxproj:<unresolvedSignature>(5),<empty>,,true,,,importVcxproj,,,0,<unresolvedSignature>
111669157617,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ImportProject.importBcb6Prj:bool(ANY),<empty>,,true,,,importBcb6Prj,,,0,bool(ANY)
111669157618,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ImportProject.importCppcheckGuiProject:bool(ANY,Settings&,Suppressions&)",<empty>,,true,,,importCppcheckGuiProject,,,0,"bool(ANY,Settings&,Suppressions&)"
111669157619,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"readUntil:ANY(ANY,ANY,char*)",<empty>,,true,,,readUntil,,,0,"ANY(ANY,ANY,char*)"
111669157620,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.unescape:<unresolvedSignature>(1),<empty>,,true,,,unescape,,,0,<unresolvedSignature>
111669157621,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fsSetDefines:<unresolvedSignature>(2),<empty>,,true,,,fsSetDefines,,,0,<unresolvedSignature>
111669157622,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Path.acceptFile:bool(ANY,Standards.Language*)",<empty>,,true,,,acceptFile,,,0,"bool(ANY,Standards.Language*)"
111669157623,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ImportProject.sourceFileExists:bool(ANY),<empty>,,true,,,sourceFileExists,,,0,bool(ANY)
111669157624,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ImportProject.printError:void(ANY),<empty>,,true,,,printError,,,0,void(ANY)
111669157625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ImportProject.fsParseCommand:void(FileSettings&,ANY)",<empty>,,true,,,fsParseCommand,,,0,"void(FileSettings&,ANY)"
111669157626,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ImportProject.fsSetIncludePaths:void(FileSettings&,ANY,ANY,ANY)",<empty>,,true,,,fsSetIncludePaths,,,0,"void(FileSettings&,ANY,ANY,ANY)"
111669157627,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TokenList.createTokens:bool(ANY,Standards.Language)",<empty>,,true,,,createTokens,,,0,"bool(ANY,Standards.Language)"
111669157628,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.empty_if_null:<unresolvedSignature>(1),<empty>,,true,,,empty_if_null,,,0,<unresolvedSignature>
111669157629,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getAbsoluteFilePath:<unresolvedSignature>(1),<empty>,,true,,,getAbsoluteFilePath,,,0,<unresolvedSignature>
111669157630,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"loadVisualStudioProperties:void(ANY,ANY,ANY,ANY,ANY)",<empty>,,true,,,loadVisualStudioProperties,,,0,"void(ANY,ANY,ANY,ANY,ANY)"
111669157631,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"importPropertyGroup:void(tinyxml2.XMLElement*,ANY,ANY,bool*)",<empty>,,true,,,importPropertyGroup,,,0,"void(tinyxml2.XMLElement*,ANY,ANY,bool*)"
111669157632,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ErrorIDToName:<unresolvedSignature>(1),<empty>,,true,,,ErrorIDToName,,,0,<unresolvedSignature>
111669157633,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.acceptFile:<unresolvedSignature>(1),<empty>,,true,,,acceptFile,,,0,<unresolvedSignature>
111669157634,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isAbsolute:<unresolvedSignature>(1),<empty>,,true,,,isAbsolute,,,0,<unresolvedSignature>
111669157635,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.loadVisualStudioProperties:<unresolvedSignature>(5),<empty>,,true,,,loadVisualStudioProperties,,,0,<unresolvedSignature>
111669157636,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ImportProject.importVcxitems:ImportProject.SharedItemsProject(ANY,ANY,ANY)",<empty>,,true,,,importVcxitems,,,0,"ImportProject.SharedItemsProject(ANY,ANY,ANY)"
111669157637,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Standards.getCPP:ANY(Standards.cppstd_t),<empty>,,true,,,getCPP,,,0,ANY(Standards.cppstd_t)
111669157638,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ImportProject.fsSetDefines:void(FileSettings&,ANY)",<empty>,,true,,,fsSetDefines,,,0,"void(FileSettings&,ANY)"
111669157639,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,toStringList:ANY(ANY),<empty>,,true,,,toStringList,,,0,ANY(ANY)
111669157640,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Path.getFilenameExtensionInLowerCase:ANY(ANY),<empty>,,true,,,getFilenameExtensionInLowerCase,,,0,ANY(ANY)
111669157641,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.joinRelativePath:<unresolvedSignature>(2),<empty>,,true,,,joinRelativePath,,,0,<unresolvedSignature>
111669157642,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.istreambuf_iterator<char>:<unresolvedSignature>(1),<empty>,,true,,,istreambuf_iterator<char>,,,0,<unresolvedSignature>
111669157643,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,istream_to_string:ANY(ANY),<empty>,,true,,,istream_to_string,,,0,ANY(ANY)
111669157644,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Parse:<unresolvedSignature>(2),<empty>,,true,,,Parse,,,0,<unresolvedSignature>
111669157645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"readXmlStringList:ANY(tinyxml2.XMLElement*,ANY,char*,char*)",<empty>,,true,,,readXmlStringList,,,0,"ANY(tinyxml2.XMLElement*,ANY,char*,char*)"
111669157646,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.readXmlStringList:<unresolvedSignature>(4),<empty>,,true,,,readXmlStringList,,,0,<unresolvedSignature>
111669157647,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"joinRelativePath:ANY(ANY,ANY)",<empty>,,true,,,joinRelativePath,,,0,"ANY(ANY,ANY)"
111669157648,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.IntAttribute:<unresolvedSignature>(2),<empty>,,true,,,IntAttribute,,,0,<unresolvedSignature>
111669157649,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.default_if_null:<unresolvedSignature>(2),<empty>,,true,,,default_if_null,,,0,<unresolvedSignature>
111669157650,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addSuppressions:<unresolvedSignature>(1),<empty>,,true,,,addSuppressions,,,0,<unresolvedSignature>
111669157651,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Path.getCurrentPath:ANY(),<empty>,,true,,,getCurrentPath,,,0,ANY()
111669157652,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getRelativePath:<unresolvedSignature>(2),<empty>,,true,,,getRelativePath,,,0,<unresolvedSignature>
111669157653,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.min:<unresolvedSignature>(3),<empty>,,true,,,min,,,0,<unresolvedSignature>
111669157654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.calculate:<unresolvedSignature>(3),<empty>,,true,,,calculate,,,0,<unresolvedSignature>
111669157655,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Interval.empty:bool(),<empty>,,true,,,empty,,,0,bool()
111669157656,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Interval.isScalar:bool(),<empty>,,true,,,isScalar,,,0,bool()
111669157657,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Interval.merge:ANY(ANY,ANY)",<empty>,,true,,,merge,,,0,"ANY(ANY,ANY)"
111669157658,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Interval.setMinValue:void(longlongint,ValueFlow.Value*)",<empty>,,true,,,setMinValue,,,0,"void(longlongint,ValueFlow.Value*)"
111669157659,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Interval.setMaxValue:void(longlongint,ValueFlow.Value*)",<empty>,,true,,,setMaxValue,,,0,"void(longlongint,ValueFlow.Value*)"
111669157660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getCompareValue:ANY(),<empty>,,true,,,getCompareValue,,,0,ANY()
111669157661,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.count_if:<unresolvedSignature>(3),<empty>,,true,,,count_if,,,0,<unresolvedSignature>
111669157662,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Interval.fromInt:Interval(longlongint,ValueFlow.Value*)",<empty>,,true,,,fromInt,,,0,"Interval(longlongint,ValueFlow.Value*)"
111669157663,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fromValues:<unresolvedSignature>(2),<empty>,,true,,,fromValues,,,0,<unresolvedSignature>
111669157664,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.apply:<unresolvedSignature>(3),<empty>,,true,,,apply,,,0,<unresolvedSignature>
111669157665,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Interval.getScalarRef<const>:ANY(),<empty>,,true,,,getScalarRef,,,0,ANY()
111669157666,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Interval.isGreaterThan<const>:bool(longlongint,ANY)",<empty>,,true,,,isGreaterThan,,,0,"bool(longlongint,ANY)"
111669157667,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Interval.isLessThan<const>:bool(longlongint,ANY)",<empty>,,true,,,isLessThan,,,0,"bool(longlongint,ANY)"
111669157668,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Interval.equal:ANY(Interval&,Interval&,ANY)",<empty>,,true,,,equal,,,0,"ANY(Interval&,Interval&,ANY)"
111669157669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Interval.compare:ANY(Interval&,Interval&,ANY)",<empty>,,true,,,compare,,,0,"ANY(Interval&,Interval&,ANY)"
111669157670,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.setInconclusive:void(bool),<empty>,,true,,,setInconclusive,,,0,void(bool)
111669157671,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.setPossible:void(),<empty>,,true,,,setPossible,,,0,void()
111669157672,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InferModel.match<const>:bool(ValueFlow.Value&),<empty>,,true,,,match,,,0,bool(ValueFlow.Value&)
111669157673,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Interval.fromValues:Interval(ANY),<empty>,,true,,,fromValues,,,0,Interval(ANY)
111669157674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"addToErrorPath:void(ValueFlow.Value&,ANY)",<empty>,,true,,,addToErrorPath,,,0,"void(ValueFlow.Value&,ANY)"
111669157675,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"setValueKind:void(ValueFlow.Value&,ANY)",<empty>,,true,,,setValueKind,,,0,"void(ValueFlow.Value&,ANY)"
111669157676,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.setImpossible:void(),<empty>,,true,,,setImpossible,,,0,void()
111669157677,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"inferNotEqual:bool(ANY,longlongint)",<empty>,,true,,,inferNotEqual,,,0,"bool(ANY,longlongint)"
111669157678,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Interval.compare:ANY(ANY,Interval&,Interval&,ANY)",<empty>,,true,,,compare,,,0,"ANY(ANY,Interval&,Interval&,ANY)"
111669157679,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.infer:<unresolvedSignature>(4),<empty>,,true,,,infer,,,0,<unresolvedSignature>
111669157680,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InferModel.yield<const>:ValueFlow.Value(longlongint),<empty>,,true,,,yield,,,0,ValueFlow.Value(longlongint)
111669157681,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"infer:ANY(ValuePtr<InferModel>&,ANY,ANY,longlongint)",<empty>,,true,,,infer,,,0,"ANY(ValuePtr<InferModel>&,ANY,ANY,longlongint)"
111669157682,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isKnown:<unresolvedSignature>(0),<empty>,,true,,,isKnown,,,0,<unresolvedSignature>
111669157683,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lib/keywords.cpp,lib/keywords.cpp:25:29:C90_KEYWORDS:0,<empty>,,true,25,29,C90_KEYWORDS,,,0,
111669157684,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lib/keywords.cpp,lib/keywords.cpp:31:32:C99_KEYWORDS:0,<empty>,,true,31,32,C99_KEYWORDS,,,0,
111669157685,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lib/keywords.cpp,lib/keywords.cpp:34:35:C11_KEYWORDS:0,<empty>,,true,34,35,C11_KEYWORDS,,,0,
111669157686,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lib/keywords.cpp,lib/keywords.cpp:37:39:C23_KEYWORDS:0,<empty>,,true,37,39,C23_KEYWORDS,,,0,
111669157687,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lib/keywords.cpp,lib/keywords.cpp:82:92:CPP03_KEYWORDS:0,<empty>,,true,82,92,CPP03_KEYWORDS,,,0,
111669157688,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lib/keywords.cpp,lib/keywords.cpp:94:96:CPP11_KEYWORDS:0,<empty>,,true,94,96,CPP11_KEYWORDS,,,0,
111669157689,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lib/keywords.cpp,lib/keywords.cpp:98:100:CPP20_KEYWORDS:0,<empty>,,true,98,100,CPP20_KEYWORDS,,,0,
111669157690,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.str:<unresolvedSignature>(1),<empty>,,true,,,str,,,0,<unresolvedSignature>
111669157691,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"xml_LoadFile:ANY(tinyxml2.XMLDocument&,char*)",<empty>,,true,,,xml_LoadFile,,,0,"ANY(tinyxml2.XMLDocument&,char*)"
111669157692,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Path.getFilenameExtension:ANY(ANY,bool)",<empty>,,true,,,getFilenameExtension,,,0,"ANY(ANY,bool)"
111669157693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.xml_LoadFile:<unresolvedSignature>(2),<empty>,,true,,,xml_LoadFile,,,0,<unresolvedSignature>
111669157694,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Path.getAbsoluteFilePath:ANY(ANY),<empty>,,true,,,getAbsoluteFilePath,,,0,ANY(ANY)
111669157695,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Error:<unresolvedSignature>(1),<empty>,,true,,,Error,,,0,<unresolvedSignature>
111669157696,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.PrintError:<unresolvedSignature>(0),<empty>,,true,,,PrintError,,,0,<unresolvedSignature>
111669157697,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getnames:<unresolvedSignature>(1),<empty>,,true,,,getnames,,,0,<unresolvedSignature>
111669157698,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ismemory:<unresolvedSignature>(1),<empty>,,true,,,ismemory,,,0,<unresolvedSignature>
111669157699,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isresource:<unresolvedSignature>(1),<empty>,,true,,,isresource,,,0,<unresolvedSignature>
111669157700,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.BoolAttribute:<unresolvedSignature>(2),<empty>,,true,,,BoolAttribute,,,0,<unresolvedSignature>
111669157701,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getnames:ANY(char*),<empty>,,true,,,getnames,,,0,ANY(char*)
111669157702,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.loadFunction:<unresolvedSignature>(3),<empty>,,true,,,loadFunction,,,0,<unresolvedSignature>
111669157703,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Attribute:<unresolvedSignature>(2),<empty>,,true,,,Attribute,,,0,<unresolvedSignature>
111669157704,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addPrefix:<unresolvedSignature>(1),<empty>,,true,,,addPrefix,,,0,<unresolvedSignature>
111669157705,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addSuffix:<unresolvedSignature>(1),<empty>,,true,,,addSuffix,,,0,<unresolvedSignature>
111669157706,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addBlock:<unresolvedSignature>(1),<empty>,,true,,,addBlock,,,0,<unresolvedSignature>
111669157707,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setStart:<unresolvedSignature>(1),<empty>,,true,,,setStart,,,0,<unresolvedSignature>
111669157708,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setEnd:<unresolvedSignature>(1),<empty>,,true,,,setEnd,,,0,<unresolvedSignature>
111669157709,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setOffset:<unresolvedSignature>(1),<empty>,,true,,,setOffset,,,0,<unresolvedSignature>
111669157710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.Container.actionFrom:Library.Container.Action(ANY),<empty>,,true,,,actionFrom,,,0,Library.Container.Action(ANY)
111669157711,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.Container.yieldFrom:Library.Container.Yield(ANY),<empty>,,true,,,yieldFrom,,,0,Library.Container.Yield(ANY)
111669157712,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<unresolvedNamespace>.pair<std::string, std::string>:<unresolvedSignature>(2)",<empty>,,true,,,"pair<std::string, std::string>",,,0,<unresolvedSignature>
111669157713,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.platform_type:<unresolvedSignature>(2),<empty>,,true,,,platform_type,,,0,<unresolvedSignature>
111669157714,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fill:<unresolvedSignature>(1),<empty>,,true,,,fill,,,0,<unresolvedSignature>
111669157715,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.FindAttribute:<unresolvedSignature>(1),<empty>,,true,,,FindAttribute,,,0,<unresolvedSignature>
111669157716,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.BoolValue:<unresolvedSignature>(0),<empty>,,true,,,BoolValue,,,0,<unresolvedSignature>
111669157717,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Library.getarg:Library.ArgumentChecks*(Token*,int)",<empty>,,true,,,getarg,,,0,"Library.ArgumentChecks*(Token*,int)"
111669157718,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Library.isFloatArgValid:bool(Token*,int,double)",<empty>,,true,,,isFloatArgValid,,,0,"bool(Token*,int,double)"
111669157719,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"gettokenlistfromvalid:void(ANY,bool,TokenList&)",<empty>,,true,,,gettokenlistfromvalid,,,0,"void(ANY,bool,TokenList&)"
111669157720,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isEqual:<unresolvedSignature>(2),<empty>,,true,,,isEqual,,,0,<unresolvedSignature>
111669157721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isNotEqual:<unresolvedSignature>(2),<empty>,,true,,,isNotEqual,,,0,<unresolvedSignature>
111669157722,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Library.matchArguments:bool(Token*,ANY,Library.Function**)",<empty>,,true,,,matchArguments,,,0,"bool(Token*,ANY,Library.Function**)"
111669157723,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Library.getFunctionName:ANY(Token*,bool&)",<empty>,,true,,,getFunctionName,,,0,"ANY(Token*,bool&)"
111669157724,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"astCanonicalType:ANY(Token*,bool)",<empty>,,true,,,astCanonicalType,,,0,"ANY(Token*,bool)"
111669157725,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.getFunctionName:ANY(Token*),<empty>,,true,,,getFunctionName,,,0,ANY(Token*)
111669157726,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Library.isNotLibraryFunction:bool(Token*,Library.Function**)",<empty>,,true,,,isNotLibraryFunction,,,0,"bool(Token*,Library.Function**)"
111669157727,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getAllocDealloc:<unresolvedSignature>(2),<empty>,,true,,,getAllocDealloc,,,0,<unresolvedSignature>
111669157728,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.getAllocFuncInfo:Library.AllocFunc*(Token*),<empty>,,true,,,getAllocFuncInfo,,,0,Library.AllocFunc*(Token*)
111669157729,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.getDeallocFuncInfo:Library.AllocFunc*(Token*),<empty>,,true,,,getDeallocFuncInfo,,,0,Library.AllocFunc*(Token*)
111669157730,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.getReallocFuncInfo:Library.AllocFunc*(Token*),<empty>,,true,,,getReallocFuncInfo,,,0,Library.AllocFunc*(Token*)
111669157731,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.isnoreturn:bool(Token*),<empty>,,true,,,isnoreturn,,,0,bool(Token*)
111669157732,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.isnotnoreturn:bool(Token*),<empty>,,true,,,isnotnoreturn,,,0,bool(Token*)
111669157733,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Library.detectContainerInternal:Library.Container*(Token*,Library.DetectContainer,bool*,bool)",<empty>,,true,,,detectContainerInternal,,,0,"Library.Container*(Token*,Library.DetectContainer,bool*,bool)"
111669157734,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.Container.getReturnType<const>:ANY(ANY),<empty>,,true,,,getReturnType,,,0,ANY(ANY)
111669157735,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.vector<MathLib::bigint>:<unresolvedSignature>(0),<empty>,,true,,,vector<MathLib::bigint>,,,0,<unresolvedSignature>
111669157736,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.formatstr_function:bool(Token*),<empty>,,true,,,formatstr_function,,,0,bool(Token*)
111669157737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.formatstr_argno:int(Token*),<empty>,,true,,,formatstr_argno,,,0,int(Token*)
111669157738,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.formatstr_scan:bool(Token*),<empty>,,true,,,formatstr_scan,,,0,bool(Token*)
111669157739,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAttributeNoreturn<const>:bool(),<empty>,,true,,,isAttributeNoreturn,,,0,bool()
111669157740,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.hasAnyTypeCheck:bool(ANY),<empty>,,true,,,hasAnyTypeCheck,,,0,bool(ANY)
111669157741,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isBlock:<unresolvedSignature>(1),<empty>,,true,,,isBlock,,,0,<unresolvedSignature>
111669157742,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.offset:<unresolvedSignature>(0),<empty>,,true,,,offset,,,0,<unresolvedSignature>
111669157743,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Library.detectSmartPointer:Library.SmartPointer*(Token*,bool)",<empty>,,true,,,detectSmartPointer,,,0,"Library.SmartPointer*(Token*,bool)"
111669157744,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isPrefix:<unresolvedSignature>(1),<empty>,,true,,,isPrefix,,,0,<unresolvedSignature>
111669157745,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isSuffix:<unresolvedSignature>(1),<empty>,,true,,,isSuffix,,,0,<unresolvedSignature>
111669157746,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.platform_type:<unresolvedSignature>(1),<empty>,,true,,,platform_type,,,0,<unresolvedSignature>
111669157747,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MathLib.isIntHex:bool(ANY),<empty>,,true,,,isIntHex,,,0,bool(ANY)
111669157748,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isnan:<unresolvedSignature>(1),<empty>,,true,,,isnan,,,0,<unresolvedSignature>
111669157749,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isinf:<unresolvedSignature>(1),<empty>,,true,,,isinf,,,0,<unresolvedSignature>
111669157750,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.precision:<unresolvedSignature>(1),<empty>,,true,,,precision,,,0,<unresolvedSignature>
111669157751,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MathLib.value.isInt:bool(),<empty>,,true,,,isInt,,,0,bool()
111669157752,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MathLib.value.isInt<const>:bool(),<empty>,,true,,,isInt,,,0,bool()
111669157753,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MathLib.value.isFloat:bool(),<empty>,,true,,,isFloat,,,0,bool()
111669157754,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MathLib.value.isFloat<const>:bool(),<empty>,,true,,,isFloat,,,0,bool()
111669157755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MathLib.value.getDoubleValue<const>:double(),<empty>,,true,,,getDoubleValue,,,0,double()
111669157756,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentModulo,<empty>,,true,,,<operators>.assignmentModulo,,,0,
111669157757,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.stoull:<unresolvedSignature>(3),<empty>,,true,,,stoull,,,0,<unresolvedSignature>
111669157758,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MathLib.isOct:bool(ANY),<empty>,,true,,,isOct,,,0,bool(ANY)
111669157759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MathLib.isBin:bool(ANY),<empty>,,true,,,isBin,,,0,bool(ANY)
111669157760,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.characterLiteralToLL:<unresolvedSignature>(1),<empty>,,true,,,characterLiteralToLL,,,0,<unresolvedSignature>
111669157761,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"MathLib.isValidIntegerSuffix:bool(ANY,bool)",<empty>,,true,,,isValidIntegerSuffix,,,0,"bool(ANY,bool)"
111669157762,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.uint32_t:<unresolvedSignature>(0),<empty>,,true,,,uint32_t,,,0,<unresolvedSignature>
111669157763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>():int(char),<empty>,,true,,,<operator>(),,,0,int(char)
111669157764,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.pow:<unresolvedSignature>(2),<empty>,,true,,,pow,,,0,<unresolvedSignature>
111669157765,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.myStod:<unresolvedSignature>(4),<empty>,,true,,,myStod,,,0,<unresolvedSignature>
111669157766,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MathLib.isFloatHex:bool(ANY),<empty>,,true,,,isFloatHex,,,0,bool(ANY)
111669157767,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,floatHexToDoubleNumber:double(ANY),<empty>,,true,,,floatHexToDoubleNumber,,,0,double(ANY)
111669157768,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.imbue:<unresolvedSignature>(1),<empty>,,true,,,imbue,,,0,<unresolvedSignature>
111669157769,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.classic:<unresolvedSignature>(0),<empty>,,true,,,classic,,,0,<unresolvedSignature>
111669157770,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MathLib.isDecimalFloat:bool(ANY),<empty>,,true,,,isDecimalFloat,,,0,bool(ANY)
111669157771,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isValidIntegerSuffixIt:<unresolvedSignature>(3),<empty>,,true,,,isValidIntegerSuffixIt,,,0,<unresolvedSignature>
111669157772,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isValidIntegerSuffixIt:<unresolvedSignature>(2),<empty>,,true,,,isValidIntegerSuffixIt,,,0,<unresolvedSignature>
111669157773,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isxdigit:<unresolvedSignature>(1),<empty>,,true,,,isxdigit,,,0,<unresolvedSignature>
111669157774,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MathLib.isDec:bool(ANY),<empty>,,true,,,isDec,,,0,bool(ANY)
111669157775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MathLib.getSuffix:ANY(ANY),<empty>,,true,,,getSuffix,,,0,ANY(ANY)
111669157776,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"intsuffix:ANY(ANY,ANY)",<empty>,,true,,,intsuffix,,,0,"ANY(ANY,ANY)"
111669157777,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MathLib.isPositive:bool(ANY),<empty>,,true,,,isPositive,,,0,bool(ANY)
111669157778,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fmod:<unresolvedSignature>(2),<empty>,,true,,,fmod,,,0,<unresolvedSignature>
111669157779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"MathLib.add:ANY(ANY,ANY)",<empty>,,true,,,add,,,0,"ANY(ANY,ANY)"
111669157780,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"MathLib.subtract:ANY(ANY,ANY)",<empty>,,true,,,subtract,,,0,"ANY(ANY,ANY)"
111669157781,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"MathLib.multiply:ANY(ANY,ANY)",<empty>,,true,,,multiply,,,0,"ANY(ANY,ANY)"
111669157782,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"MathLib.divide:ANY(ANY,ANY)",<empty>,,true,,,divide,,,0,"ANY(ANY,ANY)"
111669157783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"MathLib.mod:ANY(ANY,ANY)",<empty>,,true,,,mod,,,0,"ANY(ANY,ANY)"
111669157784,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sin:<unresolvedSignature>(1),<empty>,,true,,,sin,,,0,<unresolvedSignature>
111669157785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.cos:<unresolvedSignature>(1),<empty>,,true,,,cos,,,0,<unresolvedSignature>
111669157786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.tan:<unresolvedSignature>(1),<empty>,,true,,,tan,,,0,<unresolvedSignature>
111669157787,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"MathLib.isEqual:bool(ANY,ANY)",<empty>,,true,,,isEqual,,,0,"bool(ANY,ANY)"
111669157788,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"caseInsensitiveStringCompare:int(ANY,ANY)",<empty>,,true,,,caseInsensitiveStringCompare,,,0,"int(ANY,ANY)"
111669157789,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.remove:<unresolvedSignature>(3),<empty>,,true,,,remove,,,0,<unresolvedSignature>
111669157790,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getcwd:<unresolvedSignature>(2),<empty>,,true,,,getcwd,,,0,<unresolvedSignature>
111669157791,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.readlink:<unresolvedSignature>(3),<empty>,,true,,,readlink,,,0,<unresolvedSignature>
111669157792,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"trim:ANY(ANY,ANY)",<empty>,,true,,,trim,,,0,"ANY(ANY,ANY)"
111669157793,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.trim:<unresolvedSignature>(2),<empty>,,true,,,trim,,,0,<unresolvedSignature>
111669157794,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasEmacsCppMarker:<unresolvedSignature>(1),<empty>,,true,,,hasEmacsCppMarker,,,0,<unresolvedSignature>
111669157795,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,file_type:ANY(ANY),<empty>,,true,,,file_type,,,0,ANY(ANY)
111669157796,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"PathAnalysis.forwardRecursive:PathAnalysis.Progress(Token*,PathAnalysis.Info,ANY)",<empty>,,true,,,forwardRecursive,,,0,"PathAnalysis.Progress(Token*,PathAnalysis.Info,ANY)"
111669157797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.forwardRecursive:<unresolvedSignature>(3),<empty>,,true,,,forwardRecursive,,,0,<unresolvedSignature>
111669157798,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"PathAnalysis.forwardRange:PathAnalysis.Progress(Token*,Token*,PathAnalysis.Info,ANY)",<empty>,,true,,,forwardRange,,,0,"PathAnalysis.Progress(Token*,Token*,PathAnalysis.Info,ANY)"
111669157799,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"PathAnalysis.checkCond:ANY(Token*,bool&)",<empty>,,true,,,checkCond,,,0,"ANY(Token*,bool&)"
111669157800,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.forwardRange:<unresolvedSignature>(4),<empty>,,true,,,forwardRange,,,0,<unresolvedSignature>
111669157801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PathMatch.removeFilename:ANY(ANY),<empty>,,true,,,removeFilename,,,0,ANY(ANY)
111669157802,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.loadFromFile:<unresolvedSignature>(3),<empty>,,true,,,loadFromFile,,,0,<unresolvedSignature>
111669157803,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,filenames,<empty>,,true,,,filenames,,,0,
111669157804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ErrorStr:<unresolvedSignature>(0),<empty>,,true,,,ErrorStr,,,0,<unresolvedSignature>
111669157805,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QueryUnsignedText:<unresolvedSignature>(1),<empty>,,true,,,QueryUnsignedText,,,0,<unresolvedSignature>
111669157806,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"xmlTextAsUInt:unsigned int(ANY,bool&)",<empty>,,true,,,xmlTextAsUInt,,,0,"unsigned int(ANY,bool&)"
111669157807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Platform.min_value:longlong(ANY),<empty>,,true,,,min_value,,,0,longlong(ANY)
111669157808,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Platform.max_value:longlong(ANY),<empty>,,true,,,max_value,,,0,longlong(ANY)
111669157809,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Platform.max_value_unsigned:longlong(ANY),<empty>,,true,,,max_value_unsigned,,,0,longlong(ANY)
111669157810,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Platform.getLimitsDefines:ANY(bool),<empty>,,true,,,getLimitsDefines,,,0,ANY(bool)
111669157811,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sameline:<unresolvedSignature>(1),<empty>,,true,,,sameline,,,0,<unresolvedSignature>
111669157812,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SuppressionList.parseMultiSuppressComment:ANY(ANY,ANY)",<empty>,,true,,,parseMultiSuppressComment,,,0,"ANY(ANY,ANY)"
111669157813,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SuppressionList.Suppression.parseComment:bool(ANY,ANY)",<empty>,,true,,,parseComment,,,0,"bool(ANY,ANY)"
111669157814,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"parseInlineSuppressionCommentToken:bool(ANY,ANY,ANY)",<empty>,,true,,,parseInlineSuppressionCommentToken,,,0,"bool(ANY,ANY,ANY)"
111669157815,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sameline:<unresolvedSignature>(2),<empty>,,true,,,sameline,,,0,<unresolvedSignature>
111669157816,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getRelativeFilename:ANY(ANY,Settings&)",<empty>,,true,,,getRelativeFilename,,,0,"ANY(ANY,Settings&)"
111669157817,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"sameline:bool(ANY,ANY)",<empty>,,true,,,sameline,,,0,"bool(ANY,ANY)"
111669157818,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"addInlineSuppressions:void(ANY,Settings&,SuppressionList&,ANY)",<empty>,,true,,,addInlineSuppressions,,,0,"void(ANY,Settings&,SuppressionList&,ANY)"
111669157819,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addInlineSuppressions:<unresolvedSignature>(4),<empty>,,true,,,addInlineSuppressions,,,0,<unresolvedSignature>
111669157820,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Preprocessor.error:void(ANY,unsigned int,ANY)",<empty>,,true,,,error,,,0,"void(ANY,unsigned int,ANY)"
111669157821,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Preprocessor.addRemarkComments:void(ANY,ANY)",<empty>,,true,,,addRemarkComments,,,0,"void(ANY,ANY)"
111669157822,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addRemarkComments:<unresolvedSignature>(2),<empty>,,true,,,addRemarkComments,,,0,<unresolvedSignature>
111669157823,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.configs2:<unresolvedSignature>(2),<empty>,,true,,,configs2,,,0,<unresolvedSignature>
111669157824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"hasDefine:bool(ANY,ANY)",<empty>,,true,,,hasDefine,,,0,"bool(ANY,ANY)"
111669157825,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"readcondition:ANY(ANY,ANY,ANY)",<empty>,,true,,,readcondition,,,0,"ANY(ANY,ANY,ANY)"
111669157826,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"isUndefined:bool(ANY,ANY)",<empty>,,true,,,isUndefined,,,0,"bool(ANY,ANY)"
111669157827,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.emplace_back:<unresolvedSignature>(0),<empty>,,true,,,emplace_back,,,0,<unresolvedSignature>
111669157828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.cfg:<unresolvedSignature>(2),<empty>,,true,,,cfg,,,0,<unresolvedSignature>
111669157829,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getConfigsElseIsFalse:<unresolvedSignature>(2),<empty>,,true,,,getConfigsElseIsFalse,,,0,<unresolvedSignature>
111669157830,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gotoEndIf:ANY(ANY),<empty>,,true,,,gotoEndIf,,,0,ANY(ANY)
111669157831,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.configs:<unresolvedSignature>(1),<empty>,,true,,,configs,,,0,<unresolvedSignature>
111669157832,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getConfigs:<unresolvedSignature>(5),<empty>,,true,,,getConfigs,,,0,<unresolvedSignature>
111669157833,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.configurationExcluded:<unresolvedSignature>(1),<empty>,,true,,,configurationExcluded,,,0,<unresolvedSignature>
111669157834,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.splitcfg:<unresolvedSignature>(3),<empty>,,true,,,splitcfg,,,0,<unresolvedSignature>
111669157835,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getLimitsDefines:<unresolvedSignature>(1),<empty>,,true,,,getLimitsDefines,,,0,<unresolvedSignature>
111669157836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getCPP:<unresolvedSignature>(1),<empty>,,true,,,getCPP,,,0,<unresolvedSignature>
111669157837,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getC:<unresolvedSignature>(1),<empty>,,true,,,getC,,,0,<unresolvedSignature>
111669157838,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Preprocessor.reportOutput:void(ANY,bool)",<empty>,,true,,,reportOutput,,,0,"void(ANY,bool)"
111669157839,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.createDUI:<unresolvedSignature>(3),<empty>,,true,,,createDUI,,,0,<unresolvedSignature>
111669157840,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.load:<unresolvedSignature>(4),<empty>,,true,,,load,,,0,<unresolvedSignature>
111669157841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Preprocessor.handleErrors:void(ANY,bool)",<empty>,,true,,,handleErrors,,,0,"void(ANY,bool)"
111669157842,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.removeComments:<unresolvedSignature>(0),<empty>,,true,,,removeComments,,,0,<unresolvedSignature>
111669157843,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"createDUI:ANY(Settings&,ANY,ANY)",<empty>,,true,,,createDUI,,,0,"ANY(Settings&,ANY,ANY)"
111669157844,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.preprocess:<unresolvedSignature>(8),<empty>,,true,,,preprocess,,,0,<unresolvedSignature>
111669157845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Preprocessor.preprocess:ANY(ANY,ANY,ANY,bool)",<empty>,,true,,,preprocess,,,0,"ANY(ANY,ANY,ANY,bool)"
111669157846,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.error:<unresolvedSignature>(3),<empty>,,true,,,error,,,0,<unresolvedSignature>
111669157847,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.missingInclude:<unresolvedSignature>(4),<empty>,,true,,,missingInclude,,,0,<unresolvedSignature>
111669157848,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ErrorMessage:<unresolvedSignature>(6),<empty>,,true,,,ErrorMessage,,,0,<unresolvedSignature>
111669157849,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.bool_to_string:<unresolvedSignature>(1),<empty>,,true,,,bool_to_string,,,0,<unresolvedSignature>
111669157850,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Preprocessor.simplifyPragmaAsmPrivate:void(ANY),<empty>,,true,,,simplifyPragmaAsmPrivate,,,0,void(ANY)
111669157851,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.simplifyPragmaAsmPrivate:<unresolvedSignature>(1),<empty>,,true,,,simplifyPragmaAsmPrivate,,,0,<unresolvedSignature>
111669157852,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.previousSkipComments:<unresolvedSignature>(0),<empty>,,true,,,previousSkipComments,,,0,<unresolvedSignature>
111669157853,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.nextSkipComments:<unresolvedSignature>(0),<empty>,,true,,,nextSkipComments,,,0,<unresolvedSignature>
111669157854,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.deleteToken:<unresolvedSignature>(1),<empty>,,true,,,deleteToken,,,0,<unresolvedSignature>
111669157855,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hash<int>:<unresolvedSignature>(0),<empty>,,true,,,hash<int>,,,0,<unresolvedSignature>
111669157856,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ProgramMemory.getIntValue:bool(int,longlongint&)",<empty>,,true,,,getIntValue,,,0,"bool(int,longlongint&)"
111669157857,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.solveExprValue:<unresolvedSignature>(3),<empty>,,true,,,solveExprValue,,,0,<unresolvedSignature>
111669157858,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isImpossible:<unresolvedSignature>(0),<empty>,,true,,,isImpossible,,,0,<unresolvedSignature>
111669157859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ProgramMemory.getValue:ValueFlow.Value*(int,bool)",<empty>,,true,,,getValue,,,0,"ValueFlow.Value*(int,bool)"
111669157860,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.use_count:<unresolvedSignature>(0),<empty>,,true,,,use_count,,,0,<unresolvedSignature>
111669157861,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"execute:void(Token*,ProgramMemory&,longlongint*,bool*,Settings&)",<empty>,,true,,,execute,,,0,"void(Token*,ProgramMemory&,longlongint*,bool*,Settings&)"
111669157862,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"evaluateCondition:bool(longlongint,Token*,ProgramMemory&,Settings&)",<empty>,,true,,,evaluateCondition,,,0,"bool(longlongint,Token*,ProgramMemory&,Settings&)"
111669157863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.parseCompareInt:<unresolvedSignature>(4),<empty>,,true,,,parseCompareInt,,,0,<unresolvedSignature>
111669157864,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ProgramMemory.setContainerSizeValue:void(Token*,longlongint,bool)",<empty>,,true,,,setContainerSizeValue,,,0,"void(Token*,longlongint,bool)"
111669157865,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>():vector<MathLib::bigint>(Token*),<empty>,,true,,,<operator>(),,,0,vector<MathLib::bigint>(Token*)
111669157866,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"frontIs:bool(ANY,bool)",<empty>,,true,,,frontIs,,,0,"bool(ANY,bool)"
111669157867,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ProgramMemory.setIntValue:void(Token*,longlongint,bool)",<empty>,,true,,,setIntValue,,,0,"void(Token*,longlongint,bool)"
111669157868,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.erase_if:<unresolvedSignature>(1),<empty>,,true,,,erase_if,,,0,<unresolvedSignature>
111669157869,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"fillProgramMemoryFromAssignments:void(ProgramMemory&,Token*,Settings&,ProgramMemory&,ANY)",<empty>,,true,,,fillProgramMemoryFromAssignments,,,0,"void(ProgramMemory&,Token*,Settings&,ProgramMemory&,ANY)"
111669157870,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getExpressionId:<unresolvedSignature>(0),<empty>,,true,,,getExpressionId,,,0,<unresolvedSignature>
111669157871,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.replace:<unresolvedSignature>(1),<empty>,,true,,,replace,,,0,<unresolvedSignature>
111669157872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"addVars:void(ProgramMemory&,ANY)",<empty>,,true,,,addVars,,,0,"void(ProgramMemory&,ANY)"
111669157873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findExpressionChangedSkipDeadCode:<unresolvedSignature>(5),<empty>,,true,,,findExpressionChangedSkipDeadCode,,,0,<unresolvedSignature>
111669157874,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ProgramMemoryState.addState:void(Token*,ANY)",<empty>,,true,,,addState,,,0,"void(Token*,ANY)"
111669157875,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getInitialProgramState:ProgramMemory(Token*,Token*,Settings&,ANY)",<empty>,,true,,,getInitialProgramState,,,0,"ProgramMemory(Token*,Token*,Settings&,ANY)"
111669157876,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fillProgramMemoryFromAssignments:<unresolvedSignature>(5),<empty>,,true,,,fillProgramMemoryFromAssignments,,,0,<unresolvedSignature>
111669157877,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.isFloatValue<const>:bool(),<empty>,,true,,,isFloatValue,,,0,bool()
111669157878,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.calculate:<unresolvedSignature>(4),<empty>,,true,,,calculate,,,0,<unresolvedSignature>
111669157879,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.compare:<unresolvedSignature>(1),<empty>,,true,,,compare,,,0,<unresolvedSignature>
111669157880,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getStringLiteral:ANY(ANY),<empty>,,true,,,getStringLiteral,,,0,ANY(ANY)
111669157881,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.asFloat:<unresolvedSignature>(1),<empty>,,true,,,asFloat,,,0,<unresolvedSignature>
111669157882,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.lgamma:<unresolvedSignature>(1),<empty>,,true,,,lgamma,,,0,<unresolvedSignature>
111669157883,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.asin:<unresolvedSignature>(1),<empty>,,true,,,asin,,,0,<unresolvedSignature>
111669157884,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.acos:<unresolvedSignature>(1),<empty>,,true,,,acos,,,0,<unresolvedSignature>
111669157885,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.atan:<unresolvedSignature>(1),<empty>,,true,,,atan,,,0,<unresolvedSignature>
111669157886,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.combineValueProperties:<unresolvedSignature>(3),<empty>,,true,,,combineValueProperties,,,0,<unresolvedSignature>
111669157887,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.atan2:<unresolvedSignature>(2),<empty>,,true,,,atan2,,,0,<unresolvedSignature>
111669157888,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.remainder:<unresolvedSignature>(2),<empty>,,true,,,remainder,,,0,<unresolvedSignature>
111669157889,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.nextafter:<unresolvedSignature>(2),<empty>,,true,,,nextafter,,,0,<unresolvedSignature>
111669157890,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.nexttoward:<unresolvedSignature>(2),<empty>,,true,,,nexttoward,,,0,<unresolvedSignature>
111669157891,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hypot:<unresolvedSignature>(2),<empty>,,true,,,hypot,,,0,<unresolvedSignature>
111669157892,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fdim:<unresolvedSignature>(2),<empty>,,true,,,fdim,,,0,<unresolvedSignature>
111669157893,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fmax:<unresolvedSignature>(2),<empty>,,true,,,fmax,,,0,<unresolvedSignature>
111669157894,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fmin:<unresolvedSignature>(2),<empty>,,true,,,fmin,,,0,<unresolvedSignature>
111669157895,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.scalbln:<unresolvedSignature>(2),<empty>,,true,,,scalbln,,,0,<unresolvedSignature>
111669157896,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.asInt:<unresolvedSignature>(1),<empty>,,true,,,asInt,,,0,<unresolvedSignature>
111669157897,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ldexp:<unresolvedSignature>(2),<empty>,,true,,,ldexp,,,0,<unresolvedSignature>
111669157898,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ilogb:<unresolvedSignature>(1),<empty>,,true,,,ilogb,,,0,<unresolvedSignature>
111669157899,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.erf:<unresolvedSignature>(1),<empty>,,true,,,erf,,,0,<unresolvedSignature>
111669157900,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.erfc:<unresolvedSignature>(1),<empty>,,true,,,erfc,,,0,<unresolvedSignature>
111669157901,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.floor:<unresolvedSignature>(1),<empty>,,true,,,floor,,,0,<unresolvedSignature>
111669157902,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sqrt:<unresolvedSignature>(1),<empty>,,true,,,sqrt,,,0,<unresolvedSignature>
111669157903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.cbrt:<unresolvedSignature>(1),<empty>,,true,,,cbrt,,,0,<unresolvedSignature>
111669157904,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ceil:<unresolvedSignature>(1),<empty>,,true,,,ceil,,,0,<unresolvedSignature>
111669157905,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.exp:<unresolvedSignature>(1),<empty>,,true,,,exp,,,0,<unresolvedSignature>
111669157906,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.expm1:<unresolvedSignature>(1),<empty>,,true,,,expm1,,,0,<unresolvedSignature>
111669157907,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fabs:<unresolvedSignature>(1),<empty>,,true,,,fabs,,,0,<unresolvedSignature>
111669157908,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.log10:<unresolvedSignature>(1),<empty>,,true,,,log10,,,0,<unresolvedSignature>
111669157909,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.log1p:<unresolvedSignature>(1),<empty>,,true,,,log1p,,,0,<unresolvedSignature>
111669157910,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.log2:<unresolvedSignature>(1),<empty>,,true,,,log2,,,0,<unresolvedSignature>
111669157911,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.logb:<unresolvedSignature>(1),<empty>,,true,,,logb,,,0,<unresolvedSignature>
111669157912,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.nearbyint:<unresolvedSignature>(1),<empty>,,true,,,nearbyint,,,0,<unresolvedSignature>
111669157913,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sinh:<unresolvedSignature>(1),<empty>,,true,,,sinh,,,0,<unresolvedSignature>
111669157914,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.cosh:<unresolvedSignature>(1),<empty>,,true,,,cosh,,,0,<unresolvedSignature>
111669157915,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.tanh:<unresolvedSignature>(1),<empty>,,true,,,tanh,,,0,<unresolvedSignature>
111669157916,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.asinh:<unresolvedSignature>(1),<empty>,,true,,,asinh,,,0,<unresolvedSignature>
111669157917,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.acosh:<unresolvedSignature>(1),<empty>,,true,,,acosh,,,0,<unresolvedSignature>
111669157918,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.atanh:<unresolvedSignature>(1),<empty>,,true,,,atanh,,,0,<unresolvedSignature>
111669157919,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.round:<unresolvedSignature>(1),<empty>,,true,,,round,,,0,<unresolvedSignature>
111669157920,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.tgamma:<unresolvedSignature>(1),<empty>,,true,,,tgamma,,,0,<unresolvedSignature>
111669157921,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.trunc:<unresolvedSignature>(1),<empty>,,true,,,trunc,,,0,<unresolvedSignature>
111669157922,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,createBuiltinLibraryFunctions:ANY(),<empty>,,true,,,createBuiltinLibraryFunctions,,,0,ANY()
111669157923,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.set_difference:<unresolvedSignature>(6),<empty>,,true,,,set_difference,,,0,<unresolvedSignature>
111669157924,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.conditionIsTrue:<unresolvedSignature>(3),<empty>,,true,,,conditionIsTrue,,,0,<unresolvedSignature>
111669157925,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isContainerSizeChanged:<unresolvedSignature>(3),<empty>,,true,,,isContainerSizeChanged,,,0,<unresolvedSignature>
111669157926,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.astFlatten:<unresolvedSignature>(2),<empty>,,true,,,astFlatten,,,0,<unresolvedSignature>
111669157927,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sort:<unresolvedSignature>(3),<empty>,,true,,,sort,,,0,<unresolvedSignature>
111669157928,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.unique:<unresolvedSignature>(3),<empty>,,true,,,unique,,,0,<unresolvedSignature>
111669157929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.astCount:<unresolvedSignature>(2),<empty>,,true,,,astCount,,,0,<unresolvedSignature>
111669157930,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Executor.flattenConditions:ANY(Token*),<empty>,,true,,,flattenConditions,,,0,ANY(Token*)
111669157931,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Executor.executeAll:ANY(ANY,bool*)",<empty>,,true,,,executeAll,,,0,"ANY(ANY,bool*)"
111669157932,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Executor.sortConditions:bool(ANY),<empty>,,true,,,sortConditions,,,0,bool(ANY)
111669157933,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"setDifference:ANY(ANY,ANY)",<empty>,,true,,,setDifference,,,0,"ANY(ANY,ANY)"
111669157934,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"pruneConditions:void(ANY,bool,ANY)",<empty>,,true,,,pruneConditions,,,0,"void(ANY,bool,ANY)"
111669157935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow::Value,<empty>,,true,,,ValueFlow::Value,,,0,
111669157936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"evaluate:ValueFlow.Value(ANY,ValueFlow.Value&,ValueFlow.Value&)",<empty>,,true,,,evaluate,,,0,"ValueFlow.Value(ANY,ValueFlow.Value&,ValueFlow.Value&)"
111669157937,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,removeAssign:ANY(ANY),<empty>,,true,,,removeAssign,,,0,ANY(ANY)
111669157938,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.visitValue:<unresolvedSignature>(2),<empty>,,true,,,visitValue,,,0,<unresolvedSignature>
111669157939,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.bind:<unresolvedSignature>(3),<empty>,,true,,,bind,,,0,<unresolvedSignature>
111669157940,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getArgumentVar:<unresolvedSignature>(1),<empty>,,true,,,getArgumentVar,,,0,<unresolvedSignature>
111669157941,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Executor.execute:ANY(Scope*),<empty>,,true,,,execute,,,0,ANY(Scope*)
111669157942,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getBuiltinLibraryFunction:ANY(ANY),<empty>,,true,,,getBuiltinLibraryFunction,,,0,ANY(ANY)
111669157943,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.lf:<unresolvedSignature>(1),<empty>,,true,,,lf,,,0,<unresolvedSignature>
111669157944,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"evaluateLibraryFunction:ValueFlow.Value(ANY,ANY,Settings&,bool)",<empty>,,true,,,evaluateLibraryFunction,,,0,"ValueFlow.Value(ANY,ANY,Settings&,bool)"
111669157945,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addressof:<unresolvedSignature>(1),<empty>,,true,,,addressof,,,0,<unresolvedSignature>
111669157946,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.max_element:<unresolvedSignature>(3),<empty>,,true,,,max_element,,,0,<unresolvedSignature>
111669157947,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.updateValue:<unresolvedSignature>(2),<empty>,,true,,,updateValue,,,0,<unresolvedSignature>
111669157948,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.createTokens:<unresolvedSignature>(2),<empty>,,true,,,createTokens,,,0,<unresolvedSignature>
111669157949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.createAst:<unresolvedSignature>(0),<empty>,,true,,,createAst,,,0,<unresolvedSignature>
111669157950,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.execute:<unresolvedSignature>(3),<empty>,,true,,,execute,,,0,<unresolvedSignature>
111669157951,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"createTokenFromExpression:ANY(ANY,Settings&,bool,ANY)",<empty>,,true,,,createTokenFromExpression,,,0,"ANY(ANY,Settings&,bool,ANY)"
111669157952,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.<operator>():<unresolvedSignature>(2),<empty>,,true,,,<operator>(),,,0,<unresolvedSignature>
111669157953,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ReverseTraversal.isDeadCode:Token*(Token*,Token*)",<empty>,,true,,,isDeadCode,,,0,"Token*(Token*,Token*)"
111669157954,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReverseTraversal.evalCond:ANY(Token*),<empty>,,true,,,evalCond,,,0,ANY(Token*)
111669157955,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Analyzer.reanalyze<const>:ValuePtr<Analyzer>(Token*,ANY)",<empty>,,true,,,reanalyze,,,0,"ValuePtr<Analyzer>(Token*,ANY)"
111669157956,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Analyzer.Action.matches<const>:bool(),<empty>,,true,,,matches,,,0,bool()
111669157957,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReverseTraversal.analyzeRecursive:Analyzer.Action(Token*),<empty>,,true,,,analyzeRecursive,,,0,Analyzer.Action(Token*)
111669157958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ReverseTraversal.analyzeRange:Analyzer.Action(Token*,Token*)",<empty>,,true,,,analyzeRange,,,0,"Analyzer.Action(Token*,Token*)"
111669157959,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getpid:<unresolvedSignature>(0),<empty>,,true,,,getpid,,,0,<unresolvedSignature>
111669157960,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SimpleEnableGroup<enumSeverity>.setEnabled:void(Severity,bool)",<empty>,,true,,,setEnabled,,,0,"void(Severity,bool)"
111669157961,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SimpleEnableGroup<enumCertainty>.setEnabled:void(Certainty,bool)",<empty>,,true,,,setEnabled,,,0,"void(Certainty,bool)"
111669157962,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.parseEnabled:<unresolvedSignature>(2),<empty>,,true,,,parseEnabled,,,0,<unresolvedSignature>
111669157963,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SimpleEnableGroup<enumSeverity>.fill:void(),<empty>,,true,,,fill,,,0,void()
111669157964,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SimpleEnableGroup<enumSeverity>.disable:void(Severity),<empty>,,true,,,disable,,,0,void(Severity)
111669157965,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.enable:<unresolvedSignature>(1),<empty>,,true,,,enable,,,0,<unresolvedSignature>
111669157966,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Settings.applyEnabled:ANY(ANY,bool)",<empty>,,true,,,applyEnabled,,,0,"ANY(ANY,bool)"
111669157967,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Settings.parseEnabled:ANY(ANY,ANY)",<empty>,,true,,,parseEnabled,,,0,"ANY(ANY,ANY)"
111669157968,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.disable:<unresolvedSignature>(1),<empty>,,true,,,disable,,,0,<unresolvedSignature>
111669157969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Summaries.loadReturn:void(ANY,ANY)",<empty>,,true,,,loadReturn,,,0,"void(ANY,ANY)"
111669157970,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Settings.setMisraRuleTexts:void(ANY),<empty>,,true,,,setMisraRuleTexts,,,0,void(ANY)
111669157971,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SourceLocation,<empty>,,true,,,SourceLocation,,,0,
111669157972,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getCStd:<unresolvedSignature>(1),<empty>,,true,,,getCStd,,,0,<unresolvedSignature>
111669157973,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mapC:Standards.cstd_t(ANY),<empty>,,true,,,mapC,,,0,Standards.cstd_t(ANY)
111669157974,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Standards.getC:ANY(Standards.cstd_t),<empty>,,true,,,getC,,,0,ANY(Standards.cstd_t)
111669157975,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.mapC:<unresolvedSignature>(1),<empty>,,true,,,mapC,,,0,<unresolvedSignature>
111669157976,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getCppStd:<unresolvedSignature>(1),<empty>,,true,,,getCppStd,,,0,<unresolvedSignature>
111669157977,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mapCPP:Standards.cppstd_t(ANY),<empty>,,true,,,mapCPP,,,0,Standards.cppstd_t(ANY)
111669157978,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.mapCPP:<unresolvedSignature>(1),<empty>,,true,,,mapCPP,,,0,<unresolvedSignature>
111669157979,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>():string(std.set<std.string>&),<empty>,,true,,,<operator>(),,,0,string(std.set<std.string>&)
111669157980,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"removeFunctionCalls:void(ANY,ANY,ANY,ANY)",<empty>,,true,,,removeFunctionCalls,,,0,"void(ANY,ANY,ANY,ANY)"
111669157981,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getSummaryFiles:ANY(ANY),<empty>,,true,,,getSummaryFiles,,,0,ANY(ANY)
111669157982,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getSummaryData:<unresolvedSignature>(2),<empty>,,true,,,getSummaryData,,,0,<unresolvedSignature>
111669157983,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.removeFunctionCalls:<unresolvedSignature>(4),<empty>,,true,,,removeFunctionCalls,,,0,<unresolvedSignature>
111669157984,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SuppressionList.ErrorMessage.setFileName:void(ANY),<empty>,,true,,,setFileName,,,0,void(ANY)
111669157985,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorMessage.symbolNames<const>:ANY(),<empty>,,true,,,symbolNames,,,0,ANY()
111669157986,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"startsWith:bool(ANY,ANY)",<empty>,,true,,,startsWith,,,0,"bool(ANY,ANY)"
111669157987,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getline:<unresolvedSignature>(3),<empty>,,true,,,getline,,,0,<unresolvedSignature>
111669157988,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SuppressionList.parseLine:SuppressionList.Suppression(ANY),<empty>,,true,,,parseLine,,,0,SuppressionList.Suppression(ANY)
111669157989,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isAcceptedErrorIdChar:<unresolvedSignature>(1),<empty>,,true,,,isAcceptedErrorIdChar,,,0,<unresolvedSignature>
111669157990,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SuppressionList.Suppression.isLocal<const>:bool(),<empty>,,true,,,isLocal,,,0,bool()
111669157991,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"matchglob:bool(ANY,ANY)",<empty>,,true,,,matchglob,,,0,"bool(ANY,ANY)"
111669157992,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SuppressionList.ErrorMessage.getFileName<const>:ANY(),<empty>,,true,,,getFileName,,,0,ANY()
111669157993,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SuppressionList.Suppression.isSuppressed:bool(SuppressionList.ErrorMessage&),<empty>,,true,,,isSuppressed,,,0,bool(SuppressionList.ErrorMessage&)
111669157994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SuppressionList.ErrorMessage.fromErrorMessage:SuppressionList.ErrorMessage(ErrorMessage&,ANY)",<empty>,,true,,,fromErrorMessage,,,0,"SuppressionList.ErrorMessage(ErrorMessage&,ANY)"
111669157995,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SymbolDatabase.debugSymbolDatabase:void(),<empty>,,true,,,debugSymbolDatabase,,,0,void()
111669157996,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Tokenizer.syntaxError<const>:void(Token*,ANY)",<empty>,,true,,,syntaxError,,,0,"void(Token*,ANY)"
111669157997,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.reportProgress:<unresolvedSignature>(3),<empty>,,true,,,reportProgress,,,0,<unresolvedSignature>
111669157998,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.progressValue<const>:int(),<empty>,,true,,,progressValue,,,0,int()
111669157999,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isFunctionHead:<unresolvedSignature>(2),<empty>,,true,,,isFunctionHead,,,0,<unresolvedSignature>
111669158000,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SymbolDatabase.findScope:Scope*(Token*,Scope*)",<empty>,,true,,,findScope,,,0,"Scope*(Token*,Scope*)"
111669158001,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Scope.setBodyStartEnd:void(Token*),<empty>,,true,,,setBodyStartEnd,,,0,void(Token*)
111669158002,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SymbolDatabase.findType:Type*(Token*,Scope*,bool)",<empty>,,true,,,findType,,,0,"Type*(Token*,Scope*,bool)"
111669158003,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SymbolDatabase.findNamespace:Scope*(Token*,Scope*)",<empty>,,true,,,findNamespace,,,0,"Scope*(Token*,Scope*)"
111669158004,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addVariable:<unresolvedSignature>(7),<empty>,,true,,,addVariable,,,0,<unresolvedSignature>
111669158005,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>():bool(),<empty>,,true,,,<operator>(),,,0,bool()
111669158006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SymbolDatabase.isFunction:bool(Token*,Scope*,Token*&,Token*&,Token*&)",<empty>,,true,,,isFunction,,,0,"bool(Token*,Scope*,Token*&,Token*&,Token*&)"
111669158007,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addFunction:<unresolvedSignature>(1),<empty>,,true,,,addFunction,,,0,<unresolvedSignature>
111669158008,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Scope.addFunction:void(Function),<empty>,,true,,,addFunction,,,0,void(Function)
111669158009,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Scope.findInNestedListRecursive:Scope*(ANY),<empty>,,true,,,findInNestedListRecursive,,,0,Scope*(ANY)
111669158010,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.argsMatch:<unresolvedSignature>(5),<empty>,,true,,,argsMatch,,,0,<unresolvedSignature>
111669158011,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():Token(Token*,Token*)",<empty>,,true,,,<operator>(),,,0,"Token(Token*,Token*)"
111669158012,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addArguments:<unresolvedSignature>(2),<empty>,,true,,,addArguments,,,0,<unresolvedSignature>
111669158013,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.minArgCount:<unresolvedSignature>(0),<empty>,,true,,,minArgCount,,,0,<unresolvedSignature>
111669158014,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findTypeInNested:<unresolvedSignature>(2),<empty>,,true,,,findTypeInNested,,,0,<unresolvedSignature>
111669158015,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.initializedArgCount<const>:int(),<empty>,,true,,,initializedArgCount,,,0,int()
111669158016,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.varIdCount<const>:int(),<empty>,,true,,,varIdCount,,,0,int()
111669158017,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fill_n:<unresolvedSignature>(3),<empty>,,true,,,fill_n,,,0,<unresolvedSignature>
111669158018,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.type:void(Type*),<empty>,,true,,,type,,,0,void(Type*)
111669158019,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SymbolDatabase.findTypeInNested:Type*(Token*,Scope*)",<empty>,,true,,,findTypeInNested,,,0,"Type*(Token*,Scope*)"
111669158020,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():void(Scope&,Token*,Token*)",<empty>,,true,,,<operator>(),,,0,"void(Scope&,Token*,Token*)"
111669158021,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SymbolDatabase.findFunction:Function*(Token*),<empty>,,true,,,findFunction,,,0,Function*(Token*)
111669158022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SymbolDatabase.findVariableType:Type*(Scope*,Token*)",<empty>,,true,,,findVariableType,,,0,"Type*(Scope*,Token*)"
111669158023,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.newVarId:int(),<empty>,,true,,,newVarId,,,0,int()
111669158024,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.varId:<unresolvedSignature>(1),<empty>,,true,,,varId,,,0,<unresolvedSignature>
111669158025,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SymbolDatabase.fixVarId:void(ANY,Token*,Token*,Variable*)",<empty>,,true,,,fixVarId,,,0,"void(ANY,Token*,Token*,Variable*)"
111669158026,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SymbolDatabase.getVariableFromVarId:Variable*(int),<empty>,,true,,,getVariableFromVarId,,,0,Variable*(int)
111669158027,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():void(Variable*,Token*,Token*)",<empty>,,true,,,<operator>(),,,0,"void(Variable*,Token*,Token*)"
111669158028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isContainerYieldElement:<unresolvedSignature>(1),<empty>,,true,,,isContainerYieldElement,,,0,<unresolvedSignature>
111669158029,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findEnumerator:<unresolvedSignature>(2),<empty>,,true,,,findEnumerator,,,0,<unresolvedSignature>
111669158030,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isIncompleteVar:void(bool),<empty>,,true,,,isIncompleteVar,,,0,void(bool)
111669158031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isEscapeFunction:void(bool),<empty>,,true,,,isEscapeFunction,,,0,void(bool)
111669158032,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.tie:<unresolvedSignature>(3),<empty>,,true,,,tie,,,0,<unresolvedSignature>
111669158033,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.exprId:void(int),<empty>,,true,,,exprId,,,0,void(int)
111669158034,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.exprId:<unresolvedSignature>(1),<empty>,,true,,,exprId,,,0,<unresolvedSignature>
111669158035,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getIncompleteNameID:ANY(Token*),<empty>,,true,,,getIncompleteNameID,,,0,ANY(Token*)
111669158036,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isIncompleteConstant:void(bool),<empty>,,true,,,isIncompleteConstant,,,0,void(bool)
111669158037,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"setParentExprId:void(Token*,ANY,int&)",<empty>,,true,,,setParentExprId,,,0,"void(Token*,ANY,int&)"
111669158038,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.compareTokenFlags:<unresolvedSignature>(3),<empty>,,true,,,compareTokenFlags,,,0,<unresolvedSignature>
111669158039,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setUniqueExprId:<unresolvedSignature>(0),<empty>,,true,,,setUniqueExprId,,,0,<unresolvedSignature>
111669158040,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addtoken:<unresolvedSignature>(5),<empty>,,true,,,addtoken,,,0,<unresolvedSignature>
111669158041,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SymbolDatabase.returnImplicitIntError:void(Token*),<empty>,,true,,,returnImplicitIntError,,,0,void(Token*)
111669158042,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SymbolDatabase.validateExecutableScopes:void(),<empty>,,true,,,validateExecutableScopes,,,0,void()
111669158043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SymbolDatabase.validateVariables:void(),<empty>,,true,,,validateVariables,,,0,void()
111669158044,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.getTokenDebug<const>:TokenDebug(),<empty>,,true,,,getTokenDebug,,,0,TokenDebug()
111669158045,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Variable.setFlag:void(unsigned int,bool)",<empty>,,true,,,setFlag,,,0,"void(unsigned int,bool)"
111669158046,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isArray:bool(),<empty>,,true,,,isArray,,,0,bool()
111669158047,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.nameToken:Token*(),<empty>,,true,,,nameToken,,,0,Token*()
111669158048,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.typeStartToken:Token*(),<empty>,,true,,,typeStartToken,,,0,Token*()
111669158049,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isReference:bool(),<empty>,,true,,,isReference,,,0,bool()
111669158050,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isEnumType:bool(),<empty>,,true,,,isEnumType,,,0,bool()
111669158051,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isPointer:bool(),<empty>,,true,,,isPointer,,,0,bool()
111669158052,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setFlag:<unresolvedSignature>(2),<empty>,,true,,,setFlag,,,0,<unresolvedSignature>
111669158053,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.declEndToken:Token*(),<empty>,,true,,,declEndToken,,,0,Token*()
111669158054,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.isSmartPointer:bool(),<empty>,,true,,,isSmartPointer,,,0,bool()
111669158055,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.getFlag:bool(unsigned int),<empty>,,true,,,getFlag,,,0,bool(unsigned int)
111669158056,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.valueType:ValueType*(),<empty>,,true,,,valueType,,,0,ValueType*()
111669158057,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isOperator:void(bool),<empty>,,true,,,isOperator,,,0,void(bool)
111669158058,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isNoExcept:void(bool),<empty>,,true,,,isNoExcept,,,0,void(bool)
111669158059,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isExplicit:void(bool),<empty>,,true,,,isExplicit,,,0,void(bool)
111669158060,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isConstructor:bool(),<empty>,,true,,,isConstructor,,,0,bool()
111669158061,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isDestructor:bool(),<empty>,,true,,,isDestructor,,,0,bool()
111669158062,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.hasTrailingReturnType:void(bool),<empty>,,true,,,hasTrailingReturnType,,,0,void(bool)
111669158063,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isLambda:bool(),<empty>,,true,,,isLambda,,,0,bool()
111669158064,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isConst:void(bool),<empty>,,true,,,isConst,,,0,void(bool)
111669158065,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.hasLvalRefQualifier:void(bool),<empty>,,true,,,hasLvalRefQualifier,,,0,void(bool)
111669158066,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.hasRvalRefQualifier:void(bool),<empty>,,true,,,hasRvalRefQualifier,,,0,void(bool)
111669158067,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Function.setFlag:void(unsigned int,bool)",<empty>,,true,,,setFlag,,,0,"void(unsigned int,bool)"
111669158068,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isVolatile:void(bool),<empty>,,true,,,isVolatile,,,0,void(bool)
111669158069,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isThrow:void(bool),<empty>,,true,,,isThrow,,,0,void(bool)
111669158070,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isPure:void(bool),<empty>,,true,,,isPure,,,0,void(bool)
111669158071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isDefault:void(bool),<empty>,,true,,,isDefault,,,0,void(bool)
111669158072,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isDelete:void(bool),<empty>,,true,,,isDelete,,,0,void(bool)
111669158073,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isInline:void(bool),<empty>,,true,,,isInline,,,0,void(bool)
111669158074,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isInline<const>:bool(),<empty>,,true,,,isInline,,,0,bool()
111669158075,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isInlineKeyword:void(bool),<empty>,,true,,,isInlineKeyword,,,0,void(bool)
111669158076,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isExtern:void(bool),<empty>,,true,,,isExtern,,,0,void(bool)
111669158077,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.hasVirtualSpecifier:void(bool),<empty>,,true,,,hasVirtualSpecifier,,,0,void(bool)
111669158078,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isStatic:void(bool),<empty>,,true,,,isStatic,,,0,void(bool)
111669158079,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isStaticLocal:void(bool),<empty>,,true,,,isStaticLocal,,,0,void(bool)
111669158080,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isFriend:void(bool),<empty>,,true,,,isFriend,,,0,void(bool)
111669158081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isConstexpr:void(bool),<empty>,,true,,,isConstexpr,,,0,void(bool)
111669158082,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.name:ANY(),<empty>,,true,,,name,,,0,ANY()
111669158083,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.qualifiedName:<unresolvedSignature>(1),<empty>,,true,,,qualifiedName,,,0,<unresolvedSignature>
111669158084,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Type.isDerivedFrom<const>:bool(ANY),<empty>,,true,,,isDerivedFrom,,,0,bool(ANY)
111669158085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.pred:<unresolvedSignature>(2),<empty>,,true,,,pred,,,0,<unresolvedSignature>
111669158086,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"checkReturns:bool(Function*,bool,bool,std.function)",<empty>,,true,,,checkReturns,,,0,"bool(Function*,bool,bool,std.function)"
111669158087,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isStatic:bool(),<empty>,,true,,,isStatic,,,0,bool()
111669158088,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findFunctionInScope:<unresolvedSignature>(4),<empty>,,true,,,findFunctionInScope,,,0,<unresolvedSignature>
111669158089,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Scope.findRecordInNestedList:Scope*(ANY,bool)",<empty>,,true,,,findRecordInNestedList,,,0,"Scope*(ANY,bool)"
111669158090,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Type.isEnumType:bool(),<empty>,,true,,,isEnumType,,,0,bool()
111669158091,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Type.getFunction<const>:Function*(ANY),<empty>,,true,,,getFunction,,,0,Function*(ANY)
111669158092,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasCircularDependencies:<unresolvedSignature>(1),<empty>,,true,,,hasCircularDependencies,,,0,<unresolvedSignature>
111669158093,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isDerivedFrom:<unresolvedSignature>(1),<empty>,,true,,,isDerivedFrom,,,0,<unresolvedSignature>
111669158094,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,scopeTypeToString:ANY(ScopeType),<empty>,,true,,,scopeTypeToString,,,0,ANY(ScopeType)
111669158095,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TokenList.fileLine<const>:ANY(Token*),<empty>,,true,,,fileLine,,,0,ANY(Token*)
111669158096,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"tokenToString:ANY(Token*,Tokenizer&)",<empty>,,true,,,tokenToString,,,0,"ANY(Token*,Tokenizer&)"
111669158097,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tokenType:ANY(Token*),<empty>,,true,,,tokenType,,,0,ANY(Token*)
111669158098,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,accessControlToString:ANY(AccessControl),<empty>,,true,,,accessControlToString,,,0,ANY(AccessControl)
111669158099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.accessControl<const>:AccessControl(),<empty>,,true,,,accessControl,,,0,AccessControl()
111669158100,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Type.type<const>:ANY(),<empty>,,true,,,type,,,0,ANY()
111669158101,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"scopeToString:ANY(Scope*,Tokenizer&)",<empty>,,true,,,scopeToString,,,0,"ANY(Scope*,Tokenizer&)"
111669158102,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.dimension:<unresolvedSignature>(1),<empty>,,true,,,dimension,,,0,<unresolvedSignature>
111669158103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setiosflags:<unresolvedSignature>(1),<empty>,,true,,,setiosflags,,,0,<unresolvedSignature>
111669158104,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.tokenToString:<unresolvedSignature>(2),<empty>,,true,,,tokenToString,,,0,<unresolvedSignature>
111669158105,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.functionTypeToString:<unresolvedSignature>(1),<empty>,,true,,,functionTypeToString,,,0,<unresolvedSignature>
111669158106,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.accessControlToString:<unresolvedSignature>(1),<empty>,,true,,,accessControlToString,,,0,<unresolvedSignature>
111669158107,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isInline:<unresolvedSignature>(0),<empty>,,true,,,isInline,,,0,<unresolvedSignature>
111669158108,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasVirtualSpecifier:<unresolvedSignature>(0),<empty>,,true,,,hasVirtualSpecifier,,,0,<unresolvedSignature>
111669158109,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isPure:<unresolvedSignature>(0),<empty>,,true,,,isPure,,,0,<unresolvedSignature>
111669158110,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isStaticLocal:<unresolvedSignature>(0),<empty>,,true,,,isStaticLocal,,,0,<unresolvedSignature>
111669158111,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isFriend:<unresolvedSignature>(0),<empty>,,true,,,isFriend,,,0,<unresolvedSignature>
111669158112,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isExplicit:<unresolvedSignature>(0),<empty>,,true,,,isExplicit,,,0,<unresolvedSignature>
111669158113,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isDefault:<unresolvedSignature>(0),<empty>,,true,,,isDefault,,,0,<unresolvedSignature>
111669158114,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isDelete:<unresolvedSignature>(0),<empty>,,true,,,isDelete,,,0,<unresolvedSignature>
111669158115,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasOverrideSpecifier:<unresolvedSignature>(0),<empty>,,true,,,hasOverrideSpecifier,,,0,<unresolvedSignature>
111669158116,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasFinalSpecifier:<unresolvedSignature>(0),<empty>,,true,,,hasFinalSpecifier,,,0,<unresolvedSignature>
111669158117,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isNoExcept:<unresolvedSignature>(0),<empty>,,true,,,isNoExcept,,,0,<unresolvedSignature>
111669158118,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isOperator:<unresolvedSignature>(0),<empty>,,true,,,isOperator,,,0,<unresolvedSignature>
111669158119,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasLvalRefQualifier:<unresolvedSignature>(0),<empty>,,true,,,hasLvalRefQualifier,,,0,<unresolvedSignature>
111669158120,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasRvalRefQualifier:<unresolvedSignature>(0),<empty>,,true,,,hasRvalRefQualifier,,,0,<unresolvedSignature>
111669158121,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isVariadic:<unresolvedSignature>(0),<empty>,,true,,,isVariadic,,,0,<unresolvedSignature>
111669158122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isVolatile:<unresolvedSignature>(0),<empty>,,true,,,isVolatile,,,0,<unresolvedSignature>
111669158123,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasTrailingReturnType:<unresolvedSignature>(0),<empty>,,true,,,hasTrailingReturnType,,,0,<unresolvedSignature>
111669158124,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isAttributeConst:<unresolvedSignature>(0),<empty>,,true,,,isAttributeConst,,,0,<unresolvedSignature>
111669158125,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isAttributePure:<unresolvedSignature>(0),<empty>,,true,,,isAttributePure,,,0,<unresolvedSignature>
111669158126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isAttributeNoreturn:<unresolvedSignature>(0),<empty>,,true,,,isAttributeNoreturn,,,0,<unresolvedSignature>
111669158127,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isAttributeNothrow:<unresolvedSignature>(0),<empty>,,true,,,isAttributeNothrow,,,0,<unresolvedSignature>
111669158128,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isAttributeConstructor:<unresolvedSignature>(0),<empty>,,true,,,isAttributeConstructor,,,0,<unresolvedSignature>
111669158129,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isAttributeDestructor:<unresolvedSignature>(0),<empty>,,true,,,isAttributeDestructor,,,0,<unresolvedSignature>
111669158130,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isAttributeNodiscard:<unresolvedSignature>(0),<empty>,,true,,,isAttributeNodiscard,,,0,<unresolvedSignature>
111669158131,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isDestructor:<unresolvedSignature>(0),<empty>,,true,,,isDestructor,,,0,<unresolvedSignature>
111669158132,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.scopeToString:<unresolvedSignature>(2),<empty>,,true,,,scopeToString,,,0,<unresolvedSignature>
111669158133,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.printVariable:<unresolvedSignature>(2),<empty>,,true,,,printVariable,,,0,<unresolvedSignature>
111669158134,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.stringify:<unresolvedSignature>(3),<empty>,,true,,,stringify,,,0,<unresolvedSignature>
111669158135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fileLine:<unresolvedSignature>(1),<empty>,,true,,,fileLine,,,0,<unresolvedSignature>
111669158136,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.resetiosflags:<unresolvedSignature>(1),<empty>,,true,,,resetiosflags,,,0,<unresolvedSignature>
111669158137,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,id_string:ANY(void*),<empty>,,true,,,id_string,,,0,ANY(void*)
111669158138,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.scopeTypeToString:<unresolvedSignature>(1),<empty>,,true,,,scopeTypeToString,,,0,<unresolvedSignature>
111669158139,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.id_string:<unresolvedSignature>(1),<empty>,,true,,,id_string,,,0,<unresolvedSignature>
111669158140,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isImplicitlyVirtual:<unresolvedSignature>(0),<empty>,,true,,,isImplicitlyVirtual,,,0,<unresolvedSignature>
111669158141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isInlineKeyword:<unresolvedSignature>(0),<empty>,,true,,,isInlineKeyword,,,0,<unresolvedSignature>
111669158142,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getOverriddenFunction:<unresolvedSignature>(0),<empty>,,true,,,getOverriddenFunction,,,0,<unresolvedSignature>
111669158143,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.argCount:<unresolvedSignature>(0),<empty>,,true,,,argCount,,,0,<unresolvedSignature>
111669158144,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.hasBody:bool(),<empty>,,true,,,hasBody,,,0,bool()
111669158145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isVariadic:void(bool),<empty>,,true,,,isVariadic,,,0,void(bool)
111669158146,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.hasVirtualSpecifier:bool(),<empty>,,true,,,hasVirtualSpecifier,,,0,bool()
111669158147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.hasOverrideSpecifier:bool(),<empty>,,true,,,hasOverrideSpecifier,,,0,bool()
111669158148,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.hasFinalSpecifier:bool(),<empty>,,true,,,hasFinalSpecifier,,,0,bool()
111669158149,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.getOverriddenFunction:Function*(bool*),<empty>,,true,,,getOverriddenFunction,,,0,Function*(bool*)
111669158150,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Function.getOverriddenFunctionRecursive:Function*(Type*,bool*)",<empty>,,true,,,getOverriddenFunctionRecursive,,,0,"Function*(Type*,bool*)"
111669158151,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Function.argsMatch:bool(Scope*,Token*,Token*,ANY,int)",<empty>,,true,,,argsMatch,,,0,"bool(Scope*,Token*,Token*,ANY,int)"
111669158152,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isConst:bool(),<empty>,,true,,,isConst,,,0,bool()
111669158153,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isVolatile:bool(),<empty>,,true,,,isVolatile,,,0,bool()
111669158154,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isVolatile<const>:bool(),<empty>,,true,,,isVolatile,,,0,bool()
111669158155,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.hasRvalRefQualifier:bool(),<empty>,,true,,,hasRvalRefQualifier,,,0,bool()
111669158156,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.hasLvalRefQualifier:bool(),<empty>,,true,,,hasLvalRefQualifier,,,0,bool()
111669158157,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Type.hasCircularDependencies<const>:bool(ANY),<empty>,,true,,,hasCircularDependencies,,,0,bool(ANY)
111669158158,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"isDerivedFromItself:bool(ANY,ANY)",<empty>,,true,,,isDerivedFromItself,,,0,"bool(ANY,ANY)"
111669158159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Scope.defaultAccess:AccessControl(),<empty>,,true,,,defaultAccess,,,0,AccessControl()
111669158160,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Scope.isVariableDeclaration:bool(Token*,Token*&,Token*&)",<empty>,,true,,,isVariableDeclaration,,,0,"bool(Token*,Token*&,Token*&)"
111669158161,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Scope.findRecordInNestedList<const>:Scope*(ANY,bool)",<empty>,,true,,,findRecordInNestedList,,,0,"Scope*(ANY,bool)"
111669158162,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Scope.findEnumerator<const>:Enumerator*(ANY),<empty>,,true,,,findEnumerator,,,0,Enumerator*(ANY)
111669158163,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"findEnumScopeInBase:Scope*(Scope*,ANY)",<empty>,,true,,,findEnumScopeInBase,,,0,"Scope*(Scope*,ANY)"
111669158164,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findEnumerator:<unresolvedSignature>(1),<empty>,,true,,,findEnumerator,,,0,<unresolvedSignature>
111669158165,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"findEnumeratorInUsingList:Enumerator*(Scope*,ANY)",<empty>,,true,,,findEnumeratorInUsingList,,,0,"Enumerator*(Scope*,ANY)"
111669158166,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Scope.isClassOrStruct:bool(),<empty>,,true,,,isClassOrStruct,,,0,bool()
111669158167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Scope.findFunctionInBase<const>:void(ANY,int,ANY)",<empty>,,true,,,findFunctionInBase,,,0,"void(ANY,int,ANY)"
111669158168,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>():void(Scope*),<empty>,,true,,,<operator>(),,,0,void(Scope*)
111669158169,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findFunctionInBase:<unresolvedSignature>(3),<empty>,,true,,,findFunctionInBase,,,0,<unresolvedSignature>
111669158170,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getTypeString:ANY(Token*),<empty>,,true,,,getTypeString,,,0,ANY(Token*)
111669158171,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>():ValueType(Token*),<empty>,,true,,,<operator>(),,,0,ValueType(Token*)
111669158172,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"checkVariableCallMatch:void(Variable*,Variable*,ANY,ANY,ANY)",<empty>,,true,,,checkVariableCallMatch,,,0,"void(Variable*,Variable*,ANY,ANY,ANY)"
111669158173,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isNullValue:<unresolvedSignature>(1),<empty>,,true,,,isNullValue,,,0,<unresolvedSignature>
111669158174,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasMatchingConstructor:<unresolvedSignature>(2),<empty>,,true,,,hasMatchingConstructor,,,0,<unresolvedSignature>
111669158175,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findFunction:<unresolvedSignature>(1),<empty>,,true,,,findFunction,,,0,<unresolvedSignature>
111669158176,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findRecordInNestedList:<unresolvedSignature>(2),<empty>,,true,,,findRecordInNestedList,,,0,<unresolvedSignature>
111669158177,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,findRecordInNestedListImpl:ANY(),<empty>,,true,,,"findRecordInNestedListImpl<S, T>",,,0,ANY()
111669158178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findType:<unresolvedSignature>(1),<empty>,,true,,,findType,,,0,<unresolvedSignature>
111669158179,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isTypeAlias:<unresolvedSignature>(0),<empty>,,true,,,isTypeAlias,,,0,<unresolvedSignature>
111669158180,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findRecordInNestedList:<unresolvedSignature>(1),<empty>,,true,,,findRecordInNestedList,,,0,<unresolvedSignature>
111669158181,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<unresolvedNamespace>.findRecordInNestedListImpl<const Scope, const Type>:<unresolvedSignature>(4)",<empty>,,true,,,"findRecordInNestedListImpl<const Scope, const Type>",,,0,<unresolvedSignature>
111669158182,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<unresolvedNamespace>.findRecordInNestedListImpl<Scope, Type>:<unresolvedSignature>(4)",<empty>,,true,,,"findRecordInNestedListImpl<Scope, Type>",,,0,<unresolvedSignature>
111669158183,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isClassOrStructOrUnion:<unresolvedSignature>(0),<empty>,,true,,,isClassOrStructOrUnion,,,0,<unresolvedSignature>
111669158184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<unresolvedNamespace>.findTypeImpl<const Scope, const Type>:<unresolvedSignature>(2)",<empty>,,true,,,"findTypeImpl<const Scope, const Type>",,,0,<unresolvedSignature>
111669158185,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<unresolvedNamespace>.findTypeImpl<Scope, Type>:<unresolvedSignature>(2)",<empty>,,true,,,"findTypeImpl<Scope, Type>",,,0,<unresolvedSignature>
111669158186,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Scope.findRecordInBase<const>:Scope*(ANY),<empty>,,true,,,findRecordInBase,,,0,Scope*(ANY)
111669158187,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SymbolDatabase.findFunctionInScope:Function*(Token*,Scope*,ANY,int)",<empty>,,true,,,findFunctionInScope,,,0,"Function*(Token*,Scope*,ANY,int)"
111669158188,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.bits<const>:unsigned char(),<empty>,,true,,,bits,,,0,unsigned char()
111669158189,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueType.typeFromString:ValueType.Type(ANY,bool)",<empty>,,true,,,typeFromString,,,0,"ValueType.Type(ANY,bool)"
111669158190,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueType.fromLibraryType:bool(ANY,Settings&)",<empty>,,true,,,fromLibraryType,,,0,"bool(ANY,Settings&)"
111669158191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isStandardType:void(bool),<empty>,,true,,,isStandardType,,,0,void(bool)
111669158192,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ValueType:<unresolvedSignature>(5),<empty>,,true,,,ValueType,,,0,<unresolvedSignature>
111669158193,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ValueType:<unresolvedSignature>(3),<empty>,,true,,,ValueType,,,0,<unresolvedSignature>
111669158194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Platform.isLongValue<const>:bool(longlongint),<empty>,,true,,,isLongValue,,,0,bool(longlongint)
111669158195,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Type.isTypeAlias<const>:bool(),<empty>,,true,,,isTypeAlias,,,0,bool()
111669158196,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MathLib.abs:ANY(ANY),<empty>,,true,,,abs,,,0,ANY(ANY)
111669158197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Platform.isIntValue<const>:bool(unsigned longlongint),<empty>,,true,,,isIntValue,,,0,bool(unsigned longlongint)
111669158198,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Platform.isLongValue<const>:bool(unsigned longlongint),<empty>,,true,,,isLongValue,,,0,bool(unsigned longlongint)
111669158199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Platform.isLongLongValue<const>:bool(unsigned longlongint),<empty>,,true,,,isLongLongValue,,,0,bool(unsigned longlongint)
111669158200,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isUtf8<const>:bool(),<empty>,,true,,,isUtf8,,,0,bool()
111669158201,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isUtf16<const>:bool(),<empty>,,true,,,isUtf16,,,0,bool()
111669158202,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isUtf32<const>:bool(),<empty>,,true,,,isUtf32,,,0,bool()
111669158203,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isCChar<const>:bool(),<empty>,,true,,,isCChar,,,0,bool()
111669158204,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isCMultiChar<const>:bool(),<empty>,,true,,,isCMultiChar,,,0,bool()
111669158205,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.tie:<unresolvedSignature>(5),<empty>,,true,,,tie,,,0,<unresolvedSignature>
111669158206,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>():ANY(ValueType*),<empty>,,true,,,<operator>(),,,0,ANY(ValueType*)
111669158207,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueType.isIntegral:bool(),<empty>,,true,,,isIntegral,,,0,bool()
111669158208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SourceLocation.file_name<const>:char*(),<empty>,,true,,,file_name,,,0,char*()
111669158209,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Path.stripDirectoryPart:ANY(ANY),<empty>,,true,,,stripDirectoryPart,,,0,ANY(ANY)
111669158210,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SourceLocation.line<const>:ANY(),<empty>,,true,,,line,,,0,ANY()
111669158211,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SourceLocation.function_name<const>:char*(),<empty>,,true,,,function_name,,,0,char*()
111669158212,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.token<const>:Token*(),<empty>,,true,,,token,,,0,Token*()
111669158213,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.name<const>:ANY(),<empty>,,true,,,name,,,0,ANY()
111669158214,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.fullName<const>:ANY(),<empty>,,true,,,fullName,,,0,ANY()
111669158215,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isFunction:void(bool),<empty>,,true,,,isFunction,,,0,void(bool)
111669158216,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.templateSimplifierPointer:void(TemplateSimplifier.TokenAndName*),<empty>,,true,,,templateSimplifierPointer,,,0,void(TemplateSimplifier.TokenAndName*)
111669158217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isSpecialization:<unresolvedSignature>(1),<empty>,,true,,,isSpecialization,,,0,<unresolvedSignature>
111669158218,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isSpecialization:bool(),<empty>,,true,,,isSpecialization,,,0,bool()
111669158219,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isPartialSpecialization:void(bool),<empty>,,true,,,isPartialSpecialization,,,0,void(bool)
111669158220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isAlias:void(bool),<empty>,,true,,,isAlias,,,0,void(bool)
111669158221,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isAlias:bool(),<empty>,,true,,,isAlias,,,0,bool()
111669158222,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isPartialSpecialization:bool(),<empty>,,true,,,isPartialSpecialization,,,0,bool()
111669158223,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isFriend:void(bool),<empty>,,true,,,isFriend,,,0,void(bool)
111669158224,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isFriend:bool(),<empty>,,true,,,isFriend,,,0,bool()
111669158225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isClass:void(bool),<empty>,,true,,,isClass,,,0,void(bool)
111669158226,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isVariadic:void(bool),<empty>,,true,,,isVariadic,,,0,void(bool)
111669158227,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isVariable:void(bool),<empty>,,true,,,isVariable,,,0,void(bool)
111669158228,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isClass:bool(),<empty>,,true,,,isClass,,,0,bool()
111669158229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isVariable:bool(),<empty>,,true,,,isVariable,,,0,bool()
111669158230,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isForwardDeclaration:void(bool),<empty>,,true,,,isForwardDeclaration,,,0,void(bool)
111669158231,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isFunction:bool(),<empty>,,true,,,isFunction,,,0,bool()
111669158232,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.templateSimplifierPointers:ANY(),<empty>,,true,,,templateSimplifierPointers,,,0,ANY()
111669158233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.aliasStartToken:Token*(),<empty>,,true,,,aliasStartToken,,,0,Token*()
111669158234,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.aliasEndToken:Token*(),<empty>,,true,,,aliasEndToken,,,0,Token*()
111669158235,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findClosingBracket:<unresolvedSignature>(0),<empty>,,true,,,findClosingBracket,,,0,<unresolvedSignature>
111669158236,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findTemplateDeclarationEndImpl:<unresolvedSignature>(1),<empty>,,true,,,findTemplateDeclarationEndImpl,,,0,<unresolvedSignature>
111669158237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"invalidateForwardDecls:void(Token*,Token*,ANY)",<empty>,,true,,,invalidateForwardDecls,,,0,"void(Token*,Token*,ANY)"
111669158238,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.scopeInfo<const>:ANY(),<empty>,,true,,,scopeInfo,,,0,ANY()
111669158239,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isForwardDeclaration<const>:bool(),<empty>,,true,,,isForwardDeclaration,,,0,bool()
111669158240,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TemplateSimplifier.simplifyTemplateArgs:void(Token*,Token*,ANY)",<empty>,,true,,,simplifyTemplateArgs,,,0,"void(Token*,Token*,ANY)"
111669158241,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isFunction:<unresolvedSignature>(0),<empty>,,true,,,isFunction,,,0,<unresolvedSignature>
111669158242,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getFunctionArguments:void(Token*,ANY)",<empty>,,true,,,getFunctionArguments,,,0,"void(Token*,ANY)"
111669158243,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.fullName:<unresolvedSignature>(0),<empty>,,true,,,fullName,,,0,<unresolvedSignature>
111669158244,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getTemplateParametersInDeclaration:<unresolvedSignature>(2),<empty>,,true,,,getTemplateParametersInDeclaration,,,0,<unresolvedSignature>
111669158245,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.token:<unresolvedSignature>(0),<empty>,,true,,,token,,,0,<unresolvedSignature>
111669158246,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,areAllParamsTypes:bool(ANY),<empty>,,true,,,areAllParamsTypes,,,0,bool(ANY)
111669158247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getFunctionArguments:<unresolvedSignature>(2),<empty>,,true,,,getFunctionArguments,,,0,<unresolvedSignature>
111669158248,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addInstantiation:<unresolvedSignature>(2),<empty>,,true,,,addInstantiation,,,0,<unresolvedSignature>
111669158249,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.FindFullName:<unresolvedSignature>(1),<empty>,,true,,,FindFullName,,,0,<unresolvedSignature>
111669158250,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.insertTokenBefore:<unresolvedSignature>(1),<empty>,,true,,,insertTokenBefore,,,0,<unresolvedSignature>
111669158251,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TemplateSimplifier.addInstantiation:void(Token*,ANY)",<empty>,,true,,,addInstantiation,,,0,"void(Token*,ANY)"
111669158252,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isSpecialization<const>:bool(),<empty>,,true,,,isSpecialization,,,0,bool()
111669158253,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isAlias<const>:bool(),<empty>,,true,,,isAlias,,,0,bool()
111669158254,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isFriend<const>:bool(),<empty>,,true,,,isFriend,,,0,bool()
111669158255,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Default,<empty>,,true,,,Default,,,0,
111669158256,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.insertToken:Token*(ANY,ANY,ANY,bool)",<empty>,,true,,,insertToken,,,0,"Token*(ANY,ANY,ANY,bool)"
111669158257,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.FindToken:<unresolvedSignature>(1),<empty>,,true,,,FindToken,,,0,<unresolvedSignature>
111669158258,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.FindName:<unresolvedSignature>(1),<empty>,,true,,,FindName,,,0,<unresolvedSignature>
111669158259,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.paramEnd:void(Token*),<empty>,,true,,,paramEnd,,,0,void(Token*)
111669158260,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TemplateSimplifier.getTemplateParametersInDeclaration:void(Token*,ANY)",<empty>,,true,,,getTemplateParametersInDeclaration,,,0,"void(Token*,ANY)"
111669158261,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isVariadic<const>:bool(),<empty>,,true,,,isVariadic,,,0,bool()
111669158262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.scope<const>:ANY(),<empty>,,true,,,scope,,,0,ANY()
111669158263,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.insertToken:<unresolvedSignature>(2),<empty>,,true,,,insertToken,,,0,<unresolvedSignature>
111669158264,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addtoken:<unresolvedSignature>(4),<empty>,,true,,,addtoken,,,0,<unresolvedSignature>
111669158265,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.nameToken<const>:Token*(),<empty>,,true,,,nameToken,,,0,Token*()
111669158266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.paramEnd<const>:Token*(),<empty>,,true,,,paramEnd,,,0,Token*()
111669158267,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isClass<const>:bool(),<empty>,,true,,,isClass,,,0,bool()
111669158268,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isFunction<const>:bool(),<empty>,,true,,,isFunction,,,0,bool()
111669158269,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isVariable<const>:bool(),<empty>,,true,,,isVariable,,,0,bool()
111669158270,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.insertTokenBefore:Token*(ANY,ANY,ANY)",<empty>,,true,,,insertTokenBefore,,,0,"Token*(ANY,ANY,ANY)"
111669158271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.linenr:void(int),<empty>,,true,,,linenr,,,0,void(int)
111669158272,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.column:void(int),<empty>,,true,,,column,,,0,void(int)
111669158273,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isTemplateArg:void(bool),<empty>,,true,,,isTemplateArg,,,0,void(bool)
111669158274,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.insertToken:<unresolvedSignature>(4),<empty>,,true,,,insertToken,,,0,<unresolvedSignature>
111669158275,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.instantiateMatch:<unresolvedSignature>(4),<empty>,,true,,,instantiateMatch,,,0,<unresolvedSignature>
111669158276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TokenList.addtoken:void(ANY,Token*)",<empty>,,true,,,addtoken,,,0,"void(ANY,Token*)"
111669158277,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.simplifyTemplateArgs:<unresolvedSignature>(3),<empty>,,true,,,simplifyTemplateArgs,,,0,<unresolvedSignature>
111669158278,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isNumber:<unresolvedSignature>(0),<empty>,,true,,,isNumber,,,0,<unresolvedSignature>
111669158279,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MathLib.value.str<const>:ANY(),<empty>,,true,,,str,,,0,ANY()
111669158280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.str:void(char(&)[2]),<empty>,,true,,,str,,,0,void(char(&)[2])
111669158281,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"invalidateInst:void(Token*,Token*,ANY)",<empty>,,true,,,invalidateInst,,,0,"void(Token*,Token*,ANY)"
111669158282,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getNewName:<unresolvedSignature>(2),<empty>,,true,,,getNewName,,,0,<unresolvedSignature>
111669158283,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TemplateSimplifier.matchSpecialization:bool(Token*,Token*,ANY)",<empty>,,true,,,matchSpecialization,,,0,"bool(Token*,Token*,ANY)"
111669158284,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TemplateSimplifier.expandTemplate:void(TemplateSimplifier.TokenAndName&,TemplateSimplifier.TokenAndName&,ANY,ANY,bool)",<empty>,,true,,,expandTemplate,,,0,"void(TemplateSimplifier.TokenAndName&,TemplateSimplifier.TokenAndName&,ANY,ANY,bool)"
111669158285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.replaceTemplateUsage:<unresolvedSignature>(3),<empty>,,true,,,replaceTemplateUsage,,,0,<unresolvedSignature>
111669158286,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"matchTemplateParameters:bool(Token*,ANY)",<empty>,,true,,,matchTemplateParameters,,,0,"bool(Token*,ANY)"
111669158287,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.templateSimplifierPointers<const>:ANY(),<empty>,,true,,,templateSimplifierPointers,,,0,ANY()
111669158288,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.eraseTokens:<unresolvedSignature>(2),<empty>,,true,,,eraseTokens,,,0,<unresolvedSignature>
111669158289,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isPartialSpecialization<const>:bool(),<empty>,,true,,,isPartialSpecialization,,,0,bool()
111669158290,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.isSameFamily<const>:bool(TemplateSimplifier.TokenAndName&),<empty>,,true,,,isSameFamily,,,0,bool(TemplateSimplifier.TokenAndName&)
111669158291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.specMatch:<unresolvedSignature>(2),<empty>,,true,,,specMatch,,,0,<unresolvedSignature>
111669158292,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isSpecialization:<unresolvedSignature>(0),<empty>,,true,,,isSpecialization,,,0,<unresolvedSignature>
111669158293,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isPartialSpecialization:<unresolvedSignature>(0),<empty>,,true,,,isPartialSpecialization,,,0,<unresolvedSignature>
111669158294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isAlias:<unresolvedSignature>(0),<empty>,,true,,,isAlias,,,0,<unresolvedSignature>
111669158295,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.copyTokens:<unresolvedSignature>(3),<empty>,,true,,,copyTokens,,,0,<unresolvedSignature>
111669158296,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.paramEnd:<unresolvedSignature>(1),<empty>,,true,,,paramEnd,,,0,<unresolvedSignature>
111669158297,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.printOut:<unresolvedSignature>(1),<empty>,,true,,,printOut,,,0,<unresolvedSignature>
111669158298,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>():int(Token*),<empty>,,true,,,<operator>(),,,0,int(Token*)
111669158299,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.lexicographical_compare:<unresolvedSignature>(5),<empty>,,true,,,lexicographical_compare,,,0,<unresolvedSignature>
111669158300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.str:void(char(&)[10]),<empty>,,true,,,str,,,0,void(char(&)[10])
111669158301,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.TokenAndName.dump<const>:ANY(ANY),<empty>,,true,,,dump,,,0,ANY(ANY)
111669158302,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.printOut:<unresolvedSignature>(4),<empty>,,true,,,printOut,,,0,<unresolvedSignature>
111669158303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.simplifyTemplateInstantiations:<unresolvedSignature>(4),<empty>,,true,,,simplifyTemplateInstantiations,,,0,<unresolvedSignature>
111669158304,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.removeTemplate:<unresolvedSignature>(2),<empty>,,true,,,removeTemplate,,,0,<unresolvedSignature>
111669158305,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.removeTemplate:<unresolvedSignature>(1),<empty>,,true,,,removeTemplate,,,0,<unresolvedSignature>
111669158306,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.seconds:<unresolvedSignature>(0),<empty>,,true,,,seconds,,,0,<unresolvedSignature>
111669158307,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TimerResultsData.seconds<const>:double(),<empty>,,true,,,seconds,,,0,double()
111669158308,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.clock:<unresolvedSignature>(0),<empty>,,true,,,clock,,,0,<unresolvedSignature>
111669158309,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TimerResultsIntf.addResults:void(ANY,ANY)",<empty>,,true,,,addResults,,,0,"void(ANY,ANY)"
111669158310,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.fileIndex:void(int),<empty>,,true,,,fileIndex,,,0,void(int)
111669158311,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ConstTokenRange:<unresolvedSignature>(2),<empty>,,true,,,ConstTokenRange,,,0,<unresolvedSignature>
111669158312,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isStringLiteral:bool(ANY),<empty>,,true,,,isStringLiteral,,,0,bool(ANY)
111669158313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isLong:<unresolvedSignature>(1),<empty>,,true,,,isLong,,,0,<unresolvedSignature>
111669158314,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isPrefixStringCharLiteral:<unresolvedSignature>(3),<empty>,,true,,,isPrefixStringCharLiteral,,,0,<unresolvedSignature>
111669158315,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TokenList.isKeyword<const>:bool(ANY),<empty>,,true,,,isKeyword,,,0,bool(ANY)
111669158316,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,simplecpp.Token.isNumberLike:bool(ANY),<empty>,,true,,,isNumberLike,,,0,bool(ANY)
111669158317,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isStandardType:bool(ANY),<empty>,,true,,,isStandardType,,,0,bool(ANY)
111669158318,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.islower:<unresolvedSignature>(1),<empty>,,true,,,islower,,,0,<unresolvedSignature>
111669158319,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isName:bool(),<empty>,,true,,,isName,,,0,bool()
111669158320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isCChar:bool(),<empty>,,true,,,isCChar,,,0,bool()
111669158321,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.previous:void(Token*),<empty>,,true,,,previous,,,0,void(Token*)
111669158322,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.next:void(Token*),<empty>,,true,,,next,,,0,void(Token*)
111669158323,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.token:<unresolvedSignature>(1),<empty>,,true,,,token,,,0,<unresolvedSignature>
111669158324,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.memchr:<unresolvedSignature>(3),<empty>,,true,,,memchr,,,0,<unresolvedSignature>
111669158325,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.firstWordEquals:<unresolvedSignature>(2),<empty>,,true,,,firstWordEquals,,,0,<unresolvedSignature>
111669158326,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,replaceEscapeSequences:ANY(ANY),<empty>,,true,,,replaceEscapeSequences,,,0,ANY(ANY)
111669158327,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.nextArgumentImpl:<unresolvedSignature>(1),<empty>,,true,,,nextArgumentImpl,,,0,<unresolvedSignature>
111669158328,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.strAt:ANY(int),<empty>,,true,,,strAt,,,0,ANY(int)
111669158329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findsimplematchImpl:<unresolvedSignature>(3),<empty>,,true,,,findsimplematchImpl,,,0,<unresolvedSignature>
111669158330,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findsimplematchImpl:<unresolvedSignature>(4),<empty>,,true,,,findsimplematchImpl,,,0,<unresolvedSignature>
111669158331,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findmatchImpl:<unresolvedSignature>(3),<empty>,,true,,,findmatchImpl,,,0,<unresolvedSignature>
111669158332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findmatchImpl:<unresolvedSignature>(4),<empty>,,true,,,findmatchImpl,,,0,<unresolvedSignature>
111669158333,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Function.isLambda<const>:bool(),<empty>,,true,,,isLambda,,,0,bool()
111669158334,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.setMacroName:void(ANY),<empty>,,true,,,setMacroName,,,0,void(ANY)
111669158335,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.scopeInfo:<unresolvedSignature>(1),<empty>,,true,,,scopeInfo,,,0,<unresolvedSignature>
111669158336,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.printOut:<unresolvedSignature>(2),<empty>,,true,,,printOut,,,0,<unresolvedSignature>
111669158337,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.stringifyList:ANY(Token.stringifyOptions&,ANY,Token*)",<empty>,,true,,,stringifyList,,,0,"ANY(Token.stringifyOptions&,ANY,Token*)"
111669158338,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.stringifyOptions.forPrintOut:Token.stringifyOptions(),<empty>,,true,,,forPrintOut,,,0,Token.stringifyOptions()
111669158339,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.linenr:int(),<empty>,,true,,,linenr,,,0,int()
111669158340,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.stringifyOptions.forDebugExprId:Token.stringifyOptions(),<empty>,,true,,,forDebugExprId,,,0,Token.stringifyOptions()
111669158341,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isUnsigned:bool(),<empty>,,true,,,isUnsigned,,,0,bool()
111669158342,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isSigned:bool(),<empty>,,true,,,isSigned,,,0,bool()
111669158343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isComplex:bool(),<empty>,,true,,,isComplex,,,0,bool()
111669158344,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isLong:bool(),<empty>,,true,,,isLong,,,0,bool()
111669158345,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isExpandedMacro:bool(),<empty>,,true,,,isExpandedMacro,,,0,bool()
111669158346,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.stringify:ANY(Token.stringifyOptions&),<empty>,,true,,,stringify,,,0,ANY(Token.stringifyOptions&)
111669158347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.stringify<const>:ANY(Token.stringifyOptions&),<empty>,,true,,,stringify,,,0,ANY(Token.stringifyOptions&)
111669158348,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.stringifyList:ANY(bool,bool,bool,bool,bool,ANY,Token*)",<empty>,,true,,,stringifyList,,,0,"ANY(bool,bool,bool,bool,bool,ANY,Token*)"
111669158349,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<unresolvedNamespace>.pair<const Token *, const Token *>:<unresolvedSignature>(2)",<empty>,,true,,,"pair<const Token *, const Token *>",,,0,<unresolvedSignature>
111669158350,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sprintf:<unresolvedSignature>(3),<empty>,,true,,,sprintf,,,0,<unresolvedSignature>
111669158351,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.findExpressionStartEndTokens:ANY(),<empty>,,true,,,findExpressionStartEndTokens,,,0,ANY()
111669158352,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.stringFromTokenRange:<unresolvedSignature>(2),<empty>,,true,,,stringFromTokenRange,,,0,<unresolvedSignature>
111669158353,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"astStringXml:void(Token*,int,ANY)",<empty>,,true,,,astStringXml,,,0,"void(Token*,int,ANY)"
111669158354,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.astStringVerbose<const>:ANY(),<empty>,,true,,,astStringVerbose,,,0,ANY()
111669158355,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.astString<const>:ANY(char*),<empty>,,true,,,astString,,,0,ANY(char*)
111669158356,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.function:Function*(),<empty>,,true,,,function,,,0,Function*()
111669158357,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"indent:void(ANY,int,int)",<empty>,,true,,,indent,,,0,"void(ANY,int,int)"
111669158358,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.astStringVerboseRecursive<const>:void(ANY,int,int)",<empty>,,true,,,astStringVerboseRecursive,,,0,"void(ANY,int,int)"
111669158359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.astStringVerboseRecursive:void(ANY,int,int)",<empty>,,true,,,astStringVerboseRecursive,,,0,"void(ANY,int,int)"
111669158360,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.str:ANY(),<empty>,,true,,,str,,,0,ANY()
111669158361,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.astStringZ3<const>:ANY(),<empty>,,true,,,astStringZ3,,,0,ANY()
111669158362,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.toString<const>:ANY(),<empty>,,true,,,toString,,,0,ANY()
111669158363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isIntValue:<unresolvedSignature>(0),<empty>,,true,,,isIntValue,,,0,<unresolvedSignature>
111669158364,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isIntArgValid:<unresolvedSignature>(3),<empty>,,true,,,isIntArgValid,,,0,<unresolvedSignature>
111669158365,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isFloatValue:<unresolvedSignature>(0),<empty>,,true,,,isFloatValue,,,0,<unresolvedSignature>
111669158366,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isFloatArgValid:<unresolvedSignature>(3),<empty>,,true,,,isFloatArgValid,,,0,<unresolvedSignature>
111669158367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getStrSize:<unresolvedSignature>(2),<empty>,,true,,,getStrSize,,,0,<unresolvedSignature>
111669158368,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.decreaseRange:<unresolvedSignature>(0),<empty>,,true,,,decreaseRange,,,0,<unresolvedSignature>
111669158369,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.compareValue:<unresolvedSignature>(2),<empty>,,true,,,compareValue,,,0,<unresolvedSignature>
111669158370,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.sameToken:<unresolvedSignature>(2),<empty>,,true,,,sameToken,,,0,<unresolvedSignature>
111669158371,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.equalValue:<unresolvedSignature>(1),<empty>,,true,,,equalValue,,,0,<unresolvedSignature>
111669158372,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.max:<unresolvedSignature>(3),<empty>,,true,,,max,,,0,<unresolvedSignature>
111669158373,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.removePointValue:<unresolvedSignature>(2),<empty>,,true,,,removePointValue,,,0,<unresolvedSignature>
111669158374,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isAdjacent:<unresolvedSignature>(2),<empty>,,true,,,isAdjacent,,,0,<unresolvedSignature>
111669158375,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isAdjacent:ANY(),<empty>,,true,,,isAdjacent,,,0,ANY()
111669158376,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.adjacent_find:<unresolvedSignature>(3),<empty>,,true,,,adjacent_find,,,0,<unresolvedSignature>
111669158377,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.for_each:<unresolvedSignature>(3),<empty>,,true,,,for_each,,,0,<unresolvedSignature>
111669158378,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.removeAdjacentValues:<unresolvedSignature>(4),<empty>,,true,,,removeAdjacentValues,,,0,<unresolvedSignature>
111669158379,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mergeAdjacent:void(ANY),<empty>,,true,,,mergeAdjacent,,,0,void(ANY)
111669158380,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,removeOverlaps:void(ANY),<empty>,,true,,,removeOverlaps,,,0,void(ANY)
111669158381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,removeContradiction:bool(ANY),<empty>,,true,,,removeContradiction,,,0,bool(ANY)
111669158382,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,removeContradictions:void(ANY),<empty>,,true,,,removeContradictions,,,0,void(ANY)
111669158383,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isEnumType:void(bool),<empty>,,true,,,isEnumType,,,0,void(bool)
111669158384,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.stringifyList:<unresolvedSignature>(2),<empty>,,true,,,stringifyList,,,0,<unresolvedSignature>
111669158385,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getCompareValue:<unresolvedSignature>(4),<empty>,,true,,,getCompareValue,,,0,<unresolvedSignature>
111669158386,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.isMovedValue<const>:bool(),<empty>,,true,,,isMovedValue,,,0,bool()
111669158387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Tokenizer.syntaxError:void(Token*,ANY)",<empty>,,true,,,syntaxError,,,0,"void(Token*,ANY)"
111669158388,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.isCPP:bool(),<empty>,,true,,,isCPP,,,0,bool()
111669158389,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.printTypedef:<unresolvedSignature>(2),<empty>,,true,,,printTypedef,,,0,<unresolvedSignature>
111669158390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TypedefSimplifier.insertTokens:Token*(Token*,ANY)",<empty>,,true,,,insertTokens,,,0,"Token*(Token*,ANY)"
111669158391,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isSimplifiedTypedef:void(bool),<empty>,,true,,,isSimplifiedTypedef,,,0,void(bool)
111669158392,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.insertTokens:<unresolvedSignature>(2),<empty>,,true,,,insertTokens,,,0,<unresolvedSignature>
111669158393,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<unresolvedNamespace>.pair<Token*, Token*>:<unresolvedSignature>(2)",<empty>,,true,,,"pair<Token*, Token*>",,,0,<unresolvedSignature>
111669158394,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isExternC:void(bool),<empty>,,true,,,isExternC,,,0,void(bool)
111669158395,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TypedefSimplifier.name<const>:ANY(),<empty>,,true,,,name,,,0,ANY()
111669158396,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TypedefSimplifier.isInvalidConstFunctionType<const>:bool(ANY),<empty>,,true,,,isInvalidConstFunctionType,,,0,bool(ANY)
111669158397,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.invalidConstFunctionTypeError:void(Token*),<empty>,,true,,,invalidConstFunctionTypeError,,,0,void(Token*)
111669158398,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.canReplace:<unresolvedSignature>(1),<empty>,,true,,,canReplace,,,0,<unresolvedSignature>
111669158399,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.replaceFailed:<unresolvedSignature>(0),<empty>,,true,,,replaceFailed,,,0,<unresolvedSignature>
111669158400,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.syntaxError:<unresolvedSignature>(1),<empty>,,true,,,syntaxError,,,0,<unresolvedSignature>
111669158401,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getTypedefToken:<unresolvedSignature>(0),<empty>,,true,,,getTypedefToken,,,0,<unresolvedSignature>
111669158402,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isUsed:<unresolvedSignature>(0),<empty>,,true,,,isUsed,,,0,<unresolvedSignature>
111669158403,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.removeDeclaration:<unresolvedSignature>(0),<empty>,,true,,,removeDeclaration,,,0,<unresolvedSignature>
111669158404,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.isC:bool(),<empty>,,true,,,isC,,,0,bool()
111669158405,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.unsupportedTypedef:void(Token*),<empty>,,true,,,unsupportedTypedef,,,0,void(Token*)
111669158406,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Tokenizer.duplicateTypedef:bool(Token*&,Token*,Token*)",<empty>,,true,,,duplicateTypedef,,,0,"bool(Token*&,Token*,Token*)"
111669158407,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.simplifyTypedefInsertToken:<unresolvedSignature>(3),<empty>,,true,,,simplifyTypedefInsertToken,,,0,<unresolvedSignature>
111669158408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"simplifyTypedefInsertToken:Token*(Token*,ANY,Token*)",<empty>,,true,,,simplifyTypedefInsertToken,,,0,"Token*(Token*,ANY,Token*)"
111669158409,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findInChildren:<unresolvedSignature>(1),<empty>,,true,,,findInChildren,,,0,<unresolvedSignature>
111669158410,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ScopeInfo3.findScope:ScopeInfo3*(ANY),<empty>,,true,,,findScope,,,0,ScopeInfo3*(ANY)
111669158411,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ScopeInfo3.findTypeInBase<const>:bool(ANY),<empty>,,true,,,findTypeInBase,,,0,bool(ANY)
111669158412,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findScope:<unresolvedSignature>(1),<empty>,,true,,,findScope,,,0,<unresolvedSignature>
111669158413,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ScopeInfo3.addChild:ScopeInfo3*(ScopeInfo3.Type,ANY,Token*,Token*)",<empty>,,true,,,addChild,,,0,"ScopeInfo3*(ScopeInfo3.Type,ANY,Token*,Token*)"
111669158414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hasChild:<unresolvedSignature>(1),<empty>,,true,,,hasChild,,,0,<unresolvedSignature>
111669158415,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isSimplifiedTypedef:<unresolvedSignature>(1),<empty>,,true,,,isSimplifiedTypedef,,,0,<unresolvedSignature>
111669158416,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ScopeInfo3.findScope<const>:ScopeInfo3*(ANY),<empty>,,true,,,findScope,,,0,ScopeInfo3*(ANY)
111669158417,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memberFunctionScope:ANY(Token*),<empty>,,true,,,memberFunctionScope,,,0,ANY(Token*)
111669158418,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"usingMatch:bool(Token*,ANY,Token*&,ANY,ScopeInfo3*,ScopeInfo3*)",<empty>,,true,,,usingMatch,,,0,"bool(Token*,ANY,Token*&,ANY,ScopeInfo3*,ScopeInfo3*)"
111669158419,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"scopesMatch:bool(ANY,ANY,ScopeInfo3*)",<empty>,,true,,,scopesMatch,,,0,"bool(ANY,ANY,ScopeInfo3*)"
111669158420,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.simplifyTokenList1:<unresolvedSignature>(1),<empty>,,true,,,simplifyTokenList1,,,0,<unresolvedSignature>
111669158421,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Summaries.create:ANY(Tokenizer&,ANY)",<empty>,,true,,,create,,,0,"ANY(Tokenizer&,ANY)"
111669158422,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.unhandledCharLiteral:<unresolvedSignature>(2),<empty>,,true,,,unhandledCharLiteral,,,0,<unresolvedSignature>
111669158423,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.validate:void(),<empty>,,true,,,validate,,,0,void()
111669158424,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.simplifyString:ANY(ANY),<empty>,,true,,,simplifyString,,,0,ANY(ANY)
111669158425,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.concatStr:void(ANY),<empty>,,true,,,concatStr,,,0,void(ANY)
111669158426,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.setRemovedVoidParameter:void(bool),<empty>,,true,,,setRemovedVoidParameter,,,0,void(bool)
111669158427,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():Token(Token*,bool,Token*&)",<empty>,,true,,,<operator>(),,,0,"Token(Token*,bool,Token*&)"
111669158428,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Variable.setDimensions:void(ANY),<empty>,,true,,,setDimensions,,,0,void(ANY)
111669158429,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.scopeInfo:void(ANY),<empty>,,true,,,scopeInfo,,,0,void(ANY)
111669158430,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.simplifyTemplates:void(ANY),<empty>,,true,,,simplifyTemplates,,,0,void(ANY)
111669158431,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.emplace:<unresolvedSignature>(0),<empty>,,true,,,emplace,,,0,<unresolvedSignature>
111669158432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"setVarIdStructMembers:void(Token*&,ANY,int&)",<empty>,,true,,,setVarIdStructMembers,,,0,"void(Token*&,ANY,int&)"
111669158433,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.cppcheckError:void(Token*),<empty>,,true,,,cppcheckError,,,0,void(Token*)
111669158434,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.emplace:<unresolvedSignature>(4),<empty>,,true,,,emplace,,,0,<unresolvedSignature>
111669158435,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setVarIdClassDeclaration:<unresolvedSignature>(4),<empty>,,true,,,setVarIdClassDeclaration,,,0,<unresolvedSignature>
111669158436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"VariableMap.addVariable:void(ANY,bool)",<empty>,,true,,,addVariable,,,0,"void(ANY,bool)"
111669158437,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setVarIdParseDeclaration:<unresolvedSignature>(3),<empty>,,true,,,setVarIdParseDeclaration,,,0,<unresolvedSignature>
111669158438,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VariableMap.hasVariable<const>:bool(ANY),<empty>,,true,,,hasVariable,,,0,bool(ANY)
111669158439,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Tokenizer.syntaxErrorC:void(Token*,ANY)",<empty>,,true,,,syntaxErrorC,,,0,"void(Token*,ANY)"
111669158440,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"matchMemberName:Token*(ANY,Token*,Token*,ANY)",<empty>,,true,,,matchMemberName,,,0,"Token*(ANY,Token*,Token*,ANY)"
111669158441,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"matchMemberName:Token*(Member&,ANY)",<empty>,,true,,,matchMemberName,,,0,"Token*(Member&,ANY)"
111669158442,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ScopeInfo2:<unresolvedSignature>(2),<empty>,,true,,,ScopeInfo2,,,0,<unresolvedSignature>
111669158443,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getScopeName:ANY(ANY),<empty>,,true,,,getScopeName,,,0,ANY(ANY)
111669158444,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Tokenizer.setVarIdClassFunction:void(ANY,Token*,Token*,ANY,ANY,int&)",<empty>,,true,,,setVarIdClassFunction,,,0,"void(ANY,Token*,Token*,ANY,ANY,int&)"
111669158445,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,skipInitializerList:Token*(Token*),<empty>,,true,,,skipInitializerList,,,0,Token*(Token*)
111669158446,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"matchMemberVarName:Token*(Member&,ANY)",<empty>,,true,,,matchMemberVarName,,,0,"Token*(Member&,ANY)"
111669158447,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"matchMemberFunctionName:Token*(Member&,ANY)",<empty>,,true,,,matchMemberFunctionName,,,0,"Token*(Member&,ANY)"
111669158448,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.unmatchedToken:<unresolvedSignature>(1),<empty>,,true,,,unmatchedToken,,,0,<unresolvedSignature>
111669158449,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"linkBrackets:void(Tokenizer&,ANY,ANY,Token*,char,char)",<empty>,,true,,,linkBrackets,,,0,"void(Tokenizer&,ANY,ANY,Token*,char,char)"
111669158450,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isTemplate<const>:bool(),<empty>,,true,,,isTemplate,,,0,bool()
111669158451,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isCast:void(bool),<empty>,,true,,,isCast,,,0,void(bool)
111669158452,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.findGarbageCode:void(),<empty>,,true,,,findGarbageCode,,,0,void()
111669158453,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isConstexpr:void(bool),<empty>,,true,,,isConstexpr,,,0,void(bool)
111669158454,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.validateC:void(),<empty>,,true,,,validateC,,,0,void()
111669158455,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.checkConfiguration:void(),<empty>,,true,,,checkConfiguration,,,0,void()
111669158456,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.reportUnknownMacros:void(),<empty>,,true,,,reportUnknownMacros,,,0,void()
111669158457,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Tokenizer.unhandled_macro_class_x_y:void(Token*,ANY,ANY,ANY,ANY)",<empty>,,true,,,unhandled_macro_class_x_y,,,0,"void(Token*,ANY,ANY,ANY,ANY)"
111669158458,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.printOut<const>:void(ANY,bool,char*,ANY)",<empty>,,true,,,printOut,,,0,"void(ANY,bool,char*,ANY)"
111669158459,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SymbolDatabase.printXml<const>:void(ANY),<empty>,,true,,,printXml,,,0,void(ANY)
111669158460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.printAst<const>:void(bool,bool,ANY,ANY)",<empty>,,true,,,printAst,,,0,"void(bool,bool,ANY,ANY)"
111669158461,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.printValueFlow<const>:void(bool,ANY)",<empty>,,true,,,printValueFlow,,,0,"void(bool,ANY)"
111669158462,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.printUnknownTypes:void(),<empty>,,true,,,printUnknownTypes,,,0,void()
111669158463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isRemovedVoidParameter<const>:bool(),<empty>,,true,,,isRemovedVoidParameter,,,0,bool()
111669158464,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isSplittedVarDeclComma<const>:bool(),<empty>,,true,,,isSplittedVarDeclComma,,,0,bool()
111669158465,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isImplicitInt<const>:bool(),<empty>,,true,,,isImplicitInt,,,0,bool()
111669158466,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isRestrict<const>:bool(),<empty>,,true,,,isRestrict,,,0,bool()
111669158467,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAtomic<const>:bool(),<empty>,,true,,,isAtomic,,,0,bool()
111669158468,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAttributeExport<const>:bool(),<empty>,,true,,,isAttributeExport,,,0,bool()
111669158469,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isInitBracket<const>:bool(),<empty>,,true,,,isInitBracket,,,0,bool()
111669158470,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.hasAttributeAlignas<const>:bool(),<empty>,,true,,,hasAttributeAlignas,,,0,bool()
111669158471,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.getAttributeAlignas<const>:ANY(),<empty>,,true,,,getAttributeAlignas,,,0,ANY()
111669158472,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueType.dump<const>:ANY(),<empty>,,true,,,dump,,,0,ANY()
111669158473,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.dumpTypedefInfo:ANY(),<empty>,,true,,,dumpTypedefInfo,,,0,ANY()
111669158474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TemplateSimplifier.dump<const>:ANY(),<empty>,,true,,,dump,,,0,ANY()
111669158475,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isTemplate:void(bool),<empty>,,true,,,isTemplate,,,0,void(bool)
111669158476,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.reportError:<unresolvedSignature>(5),<empty>,,true,,,reportError,,,0,<unresolvedSignature>
111669158477,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getExpression:ANY(Token*),<empty>,,true,,,getExpression,,,0,ANY(Token*)
111669158478,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Tokenizer.unknownMacroError:void(Token*),<empty>,,true,,,unknownMacroError,,,0,void(Token*)
111669158479,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isSplittedVarDeclEq:void(bool),<empty>,,true,,,isSplittedVarDeclEq,,,0,void(bool)
111669158480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isSplittedVarDeclComma:void(bool),<empty>,,true,,,isSplittedVarDeclComma,,,0,void(bool)
111669158481,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isInitBracket:void(bool),<empty>,,true,,,isInitBracket,,,0,void(bool)
111669158482,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isSimplifiedScope:void(bool),<empty>,,true,,,isSimplifiedScope,,,0,void(bool)
111669158483,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.InternalError:<unresolvedSignature>(4),<empty>,,true,,,InternalError,,,0,<unresolvedSignature>
111669158484,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"isNumberOneOf:bool(ANY,longlongint,char*)",<empty>,,true,,,isNumberOneOf,,,0,"bool(ANY,longlongint,char*)"
111669158485,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Tokenizer.macroWithSemicolonError:void(Token*,ANY)",<empty>,,true,,,macroWithSemicolonError,,,0,"void(Token*,ANY)"
111669158486,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.syntaxErrorC:<unresolvedSignature>(2),<empty>,,true,,,syntaxErrorC,,,0,<unresolvedSignature>
111669158487,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.cppcheckError:<unresolvedSignature>(1),<empty>,,true,,,cppcheckError,,,0,<unresolvedSignature>
111669158488,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TokenList.back<const>:Token*(),<empty>,,true,,,back,,,0,Token*()
111669158489,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isCPPAttribute:ANY(),<empty>,,true,,,isCPPAttribute,,,0,ANY()
111669158490,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isAlignAttribute:ANY(),<empty>,,true,,,isAlignAttribute,,,0,ANY()
111669158491,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isupper:<unresolvedSignature>(1),<empty>,,true,,,isupper,,,0,<unresolvedSignature>
111669158492,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,skipCPPOrAlignAttribute:Token*(Token*),<empty>,,true,,,skipCPPOrAlignAttribute,,,0,Token*(Token*)
111669158493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isOctalDigit:<unresolvedSignature>(1),<empty>,,true,,,isOctalDigit,,,0,<unresolvedSignature>
111669158494,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.syntaxError:<unresolvedSignature>(2),<empty>,,true,,,syntaxError,,,0,<unresolvedSignature>
111669158495,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Tokenizer.getAttributeFuncTok:Token*(Token*,bool)",<empty>,,true,,,getAttributeFuncTok,,,0,"Token*(Token*,bool)"
111669158496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAttributeNoreturn:void(bool),<empty>,,true,,,isAttributeNoreturn,,,0,void(bool)
111669158497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAttributeNothrow:void(bool),<empty>,,true,,,isAttributeNothrow,,,0,void(bool)
111669158498,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAttributeExport:void(bool),<empty>,,true,,,isAttributeExport,,,0,void(bool)
111669158499,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAttributePure:void(bool),<empty>,,true,,,isAttributePure,,,0,void(bool)
111669158500,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAttributeConst:void(bool),<empty>,,true,,,isAttributeConst,,,0,void(bool)
111669158501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAttributeConstructor:void(bool),<empty>,,true,,,isAttributeConstructor,,,0,void(bool)
111669158502,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAttributeDestructor:void(bool),<empty>,,true,,,isAttributeDestructor,,,0,void(bool)
111669158503,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAttributeUnused:void(bool),<empty>,,true,,,isAttributeUnused,,,0,void(bool)
111669158504,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAttributeUsed:void(bool),<empty>,,true,,,isAttributeUsed,,,0,void(bool)
111669158505,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAttributeNodiscard:void(bool),<empty>,,true,,,isAttributeNodiscard,,,0,void(bool)
111669158506,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAttributePacked:void(bool),<empty>,,true,,,isAttributePacked,,,0,void(bool)
111669158507,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.addAttributeCleanup:void(ANY),<empty>,,true,,,addAttributeCleanup,,,0,void(ANY)
111669158508,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.setCppcheckAttribute:void(TokenImpl.CppcheckAttributes.Type,longlongint)",<empty>,,true,,,setCppcheckAttribute,,,0,"void(TokenImpl.CppcheckAttributes.Type,longlongint)"
111669158509,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAttributeMaybeUnused:void(bool),<empty>,,true,,,isAttributeMaybeUnused,,,0,void(bool)
111669158510,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.addAttributeAlignas:<unresolvedSignature>(1),<empty>,,true,,,addAttributeAlignas,,,0,<unresolvedSignature>
111669158511,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isInline:void(bool),<empty>,,true,,,isInline,,,0,void(bool)
111669158512,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isRestrict:void(bool),<empty>,,true,,,isRestrict,,,0,void(bool)
111669158513,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>():ANY(),<empty>,,true,,,<operator>(),,,0,ANY()
111669158514,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAtomic:void(bool),<empty>,,true,,,isAtomic,,,0,void(bool)
111669158515,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isFinalType:void(bool),<empty>,,true,,,isFinalType,,,0,void(bool)
111669158516,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.setTokenDebug:void(TokenDebug),<empty>,,true,,,setTokenDebug,,,0,void(TokenDebug)
111669158517,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setTokenDebug:<unresolvedSignature>(2),<empty>,,true,,,setTokenDebug,,,0,<unresolvedSignature>
111669158518,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isAtAddress:void(bool),<empty>,,true,,,isAtAddress,,,0,void(bool)
111669158519,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.setBits:void(unsigned char),<empty>,,true,,,setBits,,,0,void(unsigned char)
111669158520,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,skipEnumBody:void(Token*&),<empty>,,true,,,skipEnumBody,,,0,void(Token*&)
111669158521,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Library.matchArguments<const>:bool(Token*,ANY,Library.Function**)",<empty>,,true,,,matchArguments,,,0,"bool(Token*,ANY,Library.Function**)"
111669158522,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.hasAnyTypeCheck<const>:bool(ANY),<empty>,,true,,,hasAnyTypeCheck,,,0,bool(ANY)
111669158523,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isOperatorKeyword:void(bool),<empty>,,true,,,isOperatorKeyword,,,0,void(bool)
111669158524,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Tokenizer.reportError:void(ANY,Severity,ANY,ANY,bool)",<empty>,,true,,,reportError,,,0,"void(ANY,Severity,ANY,ANY,bool)"
111669158525,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.unhandled_macro_class_x_y:<unresolvedSignature>(5),<empty>,,true,,,unhandled_macro_class_x_y,,,0,<unresolvedSignature>
111669158526,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.macroWithSemicolonError:<unresolvedSignature>(2),<empty>,,true,,,macroWithSemicolonError,,,0,<unresolvedSignature>
111669158527,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lib/tokenize.cpp,lib/tokenize.cpp:4518:4518:NOTSTART_C:0,<empty>,,true,4518,4518,NOTSTART_C,,,0,
111669158528,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.triplet:<unresolvedSignature>(2),<empty>,,true,,,triplet,,,0,<unresolvedSignature>
111669158529,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TokenList.getFiles:ANY(),<empty>,,true,,,getFiles,,,0,ANY()
111669158530,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lib/tokenlist.cpp,lib/tokenlist.cpp:52:52:ASSERT_LANG:1,<empty>,,true,52,52,ASSERT_LANG,,,0,
111669158531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TokenList.getSourceFilePath:ANY(),<empty>,,true,,,getSourceFilePath,,,0,ANY()
111669158532,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Path.sameFileName:bool(ANY,ANY)",<empty>,,true,,,sameFileName,,,0,"bool(ANY,ANY)"
111669158533,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.flags:void(ANY),<empty>,,true,,,flags,,,0,void(ANY)
111669158534,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.flags<const>:ANY(),<empty>,,true,,,flags,,,0,ANY()
111669158535,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TokenList.createTokensInternal:bool(ANY,ANY)",<empty>,,true,,,createTokensInternal,,,0,"bool(ANY,ANY)"
111669158536,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.createTokensInternal:<unresolvedSignature>(2),<empty>,,true,,,createTokensInternal,,,0,<unresolvedSignature>
111669158537,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getFiles:<unresolvedSignature>(0),<empty>,,true,,,getFiles,,,0,<unresolvedSignature>
111669158538,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.linenr:<unresolvedSignature>(1),<empty>,,true,,,linenr,,,0,<unresolvedSignature>
111669158539,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.column:<unresolvedSignature>(1),<empty>,,true,,,column,,,0,<unresolvedSignature>
111669158540,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setMacroName:<unresolvedSignature>(1),<empty>,,true,,,setMacroName,,,0,<unresolvedSignature>
111669158541,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isCpp11init<const>:TokenImpl.Cpp11init(),<empty>,,true,,,isCpp11init,,,0,TokenImpl.Cpp11init()
111669158542,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.setCpp11init<const>:void(bool),<empty>,,true,,,setCpp11init,,,0,void(bool)
111669158543,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.precedes:<unresolvedSignature>(2),<empty>,,true,,,precedes,,,0,<unresolvedSignature>
111669158544,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"compileUnaryOp:void(Token*&,AST_state&,void(*)(Token*&,AST_state&))",<empty>,,true,,,compileUnaryOp,,,0,"void(Token*&,AST_state&,void(*)(Token*&,AST_state&))"
111669158545,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"compileBinOp:void(Token*&,AST_state&,void(*)(Token*&,AST_state&))",<empty>,,true,,,compileBinOp,,,0,"void(Token*&,AST_state&,void(*)(Token*&,AST_state&))"
111669158546,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"skipDecl:Token*(Token*,ANY)",<empty>,,true,,,skipDecl,,,0,"Token*(Token*,ANY)"
111669158547,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.uncaught_exception:<unresolvedSignature>(0),<empty>,,true,,,uncaught_exception,,,0,<unresolvedSignature>
111669158548,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.f:<unresolvedSignature>(0),<empty>,,true,,,f,,,0,<unresolvedSignature>
111669158549,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorMessage.FileLocation.stringify<const>:ANY(),<empty>,,true,,,stringify,,,0,ANY()
111669158550,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.FileLocation:<unresolvedSignature>(2),<empty>,,true,,,FileLocation,,,0,<unresolvedSignature>
111669158551,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TokenList.isCPP:bool(),<empty>,,true,,,isCPP,,,0,bool()
111669158552,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Library.platform_type<const>:Library.PlatformType*(ANY,ANY)",<empty>,,true,,,platform_type,,,0,"Library.PlatformType*(ANY,ANY)"
111669158553,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TokenList.isC:bool(),<empty>,,true,,,isC,,,0,bool()
111669158554,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isImplicitInt:void(bool),<empty>,,true,,,isImplicitInt,,,0,void(bool)
111669158555,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isComplex:void(bool),<empty>,,true,,,isComplex,,,0,void(bool)
111669158556,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.stoi:<unresolvedSignature>(3),<empty>,,true,,,stoi,,,0,<unresolvedSignature>
111669158557,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.changeKnownToPossible:void(),<empty>,,true,,,changeKnownToPossible,,,0,void()
111669158558,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"changeKnownToPossible:void(ANY,int)",<empty>,,true,,,changeKnownToPossible,,,0,"void(ANY,int)"
111669158559,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"removeImpossible:void(ANY,int)",<empty>,,true,,,removeImpossible,,,0,"void(ANY,int)"
111669158560,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"setConditionalValue:void(ValueFlow.Value&,Token*,longlongint)",<empty>,,true,,,setConditionalValue,,,0,"void(ValueFlow.Value&,Token*,longlongint)"
111669158561,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isSaturated:bool(longlongint),<empty>,,true,,,isSaturated,,,0,bool(longlongint)
111669158562,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"setConditionalValues:void(Token*,bool,longlongint,ValueFlow.Value&,ValueFlow.Value&)",<empty>,,true,,,setConditionalValues,,,0,"void(Token*,bool,longlongint,ValueFlow.Value&,ValueFlow.Value&)"
111669158563,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.each:<unresolvedSignature>(3),<empty>,,true,,,each,,,0,<unresolvedSignature>
111669158564,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.parseCompareEachInt:<unresolvedSignature>(3),<empty>,,true,,,parseCompareEachInt,,,0,<unresolvedSignature>
111669158565,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.f:<unresolvedSignature>(3),<empty>,,true,,,f,,,0,<unresolvedSignature>
111669158566,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getAlignOf:ANY(ValueType&,Settings&,int)",<empty>,,true,,,getAlignOf,,,0,"ANY(ValueType&,Settings&,int)"
111669158567,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.accumulateStructMembers:<unresolvedSignature>(2),<empty>,,true,,,accumulateStructMembers,,,0,<unresolvedSignature>
111669158568,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.bitCeil:<unresolvedSignature>(1),<empty>,,true,,,bitCeil,,,0,<unresolvedSignature>
111669158569,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setTokenValue:<unresolvedSignature>(3),<empty>,,true,,,setTokenValue,,,0,<unresolvedSignature>
111669158570,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getExpressionRange:bool(Token*,longlongint*,longlongint*)",<empty>,,true,,,getExpressionRange,,,0,"bool(Token*,longlongint*,longlongint*)"
111669158571,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"minUnsignedValue:ANY(Token*,int)",<empty>,,true,,,minUnsignedValue,,,0,"ANY(Token*,int)"
111669158572,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.calculate<std::vector<MathLib::bigint>>:<unresolvedSignature>(3),<empty>,,true,,,calculate<std::vector<MathLib::bigint>>,,,0,<unresolvedSignature>
111669158573,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.makeArray:<unresolvedSignature>(2),<empty>,,true,,,makeArray,,,0,<unresolvedSignature>
111669158574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.valueFlowGenericForward:<unresolvedSignature>(6),<empty>,,true,,,valueFlowGenericForward,,,0,<unresolvedSignature>
111669158575,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.makeAnalyzer:<unresolvedSignature>(3),<empty>,,true,,,makeAnalyzer,,,0,<unresolvedSignature>
111669158576,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.update:<unresolvedSignature>(1),<empty>,,true,,,update,,,0,<unresolvedSignature>
111669158577,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.valueFlowForward:<unresolvedSignature>(8),<empty>,,true,,,valueFlowForward,,,0,<unresolvedSignature>
111669158578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,valueFlowForward:ANY(),<empty>,,true,,,valueFlowForward,,,0,ANY()
111669158579,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.valueFlowGenericForward:<unresolvedSignature>(5),<empty>,,true,,,valueFlowGenericForward,,,0,<unresolvedSignature>
111669158580,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.valueFlowGenericReverse:<unresolvedSignature>(6),<empty>,,true,,,valueFlowGenericReverse,,,0,<unresolvedSignature>
111669158581,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.makeReverseAnalyzer:<unresolvedSignature>(3),<empty>,,true,,,makeReverseAnalyzer,,,0,<unresolvedSignature>
111669158582,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.valueFlowReverse:<unresolvedSignature>(8),<empty>,,true,,,valueFlowReverse,,,0,<unresolvedSignature>
111669158583,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"lifetimeType:ANY(Token*,ValueFlow.Value*)",<empty>,,true,,,lifetimeType,,,0,"ANY(Token*,ValueFlow.Value*)"
111669158584,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getLifetimeTokens:ANY(),<empty>,,true,,,getLifetimeTokens,,,0,ANY()
111669158585,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.LifetimeToken.setAddressOf:ANY(),<empty>,,true,,,setAddressOf,,,0,ANY()
111669158586,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.LifetimeToken.setInconclusive:ANY(),<empty>,,true,,,setInconclusive,,,0,ANY()
111669158587,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getLifetimeTokens:<unresolvedSignature>(5),<empty>,,true,,,getLifetimeTokens,,,0,<unresolvedSignature>
111669158588,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getLifetimeToken:Token*(Token*,ANY,Settings&,bool*)",<empty>,,true,,,getLifetimeToken,,,0,"Token*(Token*,ANY,Settings&,bool*)"
111669158589,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.skipCVRefs:<unresolvedSignature>(2),<empty>,,true,,,skipCVRefs,,,0,<unresolvedSignature>
111669158590,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"isNotEqual:bool(ANY,ANY,bool)",<empty>,,true,,,isNotEqual,,,0,"bool(ANY,ANY,bool)"
111669158591,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"isNotEqual:bool(ANY,ANY)",<empty>,,true,,,isNotEqual,,,0,"bool(ANY,ANY)"
111669158592,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"isNotEqual:bool(ANY,ValueType*,bool)",<empty>,,true,,,isNotEqual,,,0,"bool(ANY,ValueType*,bool)"
111669158593,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.valueFlowForward:<unresolvedSignature>(7),<empty>,,true,,,valueFlowForward,,,0,<unresolvedSignature>
111669158594,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"valueFlowForward:Analyzer.Result(Token*,Token*,Token*,ANY,TokenList&,ErrorLogger&,Settings&,SourceLocation)",<empty>,,true,,,valueFlowForward,,,0,"Analyzer.Result(Token*,Token*,Token*,ANY,TokenList&,ErrorLogger&,Settings&,SourceLocation)"
111669158595,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.valueFlowForwardLifetime:<unresolvedSignature>(4),<empty>,,true,,,valueFlowForwardLifetime,,,0,<unresolvedSignature>
111669158596,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lib/valueflow.cpp,lib/valueflow.cpp:158:159:bailout:4,<empty>,,true,158,159,bailout,,,0,
111669158597,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.bailoutInternal:<unresolvedSignature>(8),<empty>,,true,,,bailoutInternal,,,0,<unresolvedSignature>
111669158598,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LifetimeStore,<empty>,,true,,,LifetimeStore,,,0,
111669158599,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"LifetimeStore.byRef:bool(Token*,TokenList&,ErrorLogger&,Settings&,ANY,SourceLocation)",<empty>,,true,,,byRef,,,0,"bool(Token*,TokenList&,ErrorLogger&,Settings&,ANY,SourceLocation)"
111669158600,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"LifetimeStore.byVal:bool(Token*,TokenList&,ErrorLogger&,Settings&,ANY,SourceLocation)",<empty>,,true,,,byVal,,,0,"bool(Token*,TokenList&,ErrorLogger&,Settings&,ANY,SourceLocation)"
111669158601,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.byVal:<unresolvedSignature>(6),<empty>,,true,,,byVal,,,0,<unresolvedSignature>
111669158602,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"LifetimeStore.byDerefCopy:bool(Token*,TokenList&,ErrorLogger&,Settings&,std.function,SourceLocation)",<empty>,,true,,,byDerefCopy,,,0,"bool(Token*,TokenList&,ErrorLogger&,Settings&,std.function,SourceLocation)"
111669158603,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"hasBorrowingVariables:bool(ANY,ANY,int)",<empty>,,true,,,hasBorrowingVariables,,,0,"bool(ANY,ANY,int)"
111669158604,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.isArgumentLifetimeValue<const>:bool(),<empty>,,true,,,isArgumentLifetimeValue,,,0,bool()
111669158605,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.forEach:<unresolvedSignature>(7),<empty>,,true,,,forEach,,,0,<unresolvedSignature>
111669158606,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.typeStr:<unresolvedSignature>(1),<empty>,,true,,,typeStr,,,0,<unresolvedSignature>
111669158607,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isLifetimeBorrowed:<unresolvedSignature>(2),<empty>,,true,,,isLifetimeBorrowed,,,0,<unresolvedSignature>
111669158608,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"valueFlowLifetimeUserConstructor:void(Token*,Function*,ANY,ANY,TokenList&,ErrorLogger&,Settings&)",<empty>,,true,,,valueFlowLifetimeUserConstructor,,,0,"void(Token*,Function*,ANY,ANY,TokenList&,ErrorLogger&,Settings&)"
111669158609,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"findConstructor:Function*(Scope*,Token*,ANY)",<empty>,,true,,,findConstructor,,,0,"Function*(Scope*,Token*,ANY)"
111669158610,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.astIsContainerOwned:<unresolvedSignature>(1),<empty>,,true,,,astIsContainerOwned,,,0,<unresolvedSignature>
111669158611,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Lambda.getCaptures:ANY(),<empty>,,true,,,getCaptures,,,0,ANY()
111669158612,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.byRef:<unresolvedSignature>(5),<empty>,,true,,,byRef,,,0,<unresolvedSignature>
111669158613,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.byVal:<unresolvedSignature>(5),<empty>,,true,,,byVal,,,0,<unresolvedSignature>
111669158614,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():void(Token*,LifetimeCapture)",<empty>,,true,,,<operator>(),,,0,"void(Token*,LifetimeCapture)"
111669158615,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():void(Token*,LifetimeCapture,std.function<bool(constToken*)>&)",<empty>,,true,,,<operator>(),,,0,"void(Token*,LifetimeCapture,std.function<bool(constToken*)>&)"
111669158616,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lib/valueflow.cpp,lib/valueflow.cpp:161:162:bailoutIncompleteVar:4,<empty>,,true,161,162,bailoutIncompleteVar,,,0,
111669158617,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getConditions:ANY(Token*,char*)",<empty>,,true,,,getConditions,,,0,"ANY(Token*,char*)"
111669158618,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getVarIds:ANY(Token*),<empty>,,true,,,getVarIds,,,0,ANY(Token*)
111669158619,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getLHSVariables:ANY(Token*),<empty>,,true,,,getLHSVariables,,,0,ANY(Token*)
111669158620,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"makeSymbolic:ValueFlow.Value(Token*,longlongint)",<empty>,,true,,,makeSymbolic,,,0,"ValueFlow.Value(Token*,longlongint)"
111669158621,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.inferCondition:<unresolvedSignature>(3),<empty>,,true,,,inferCondition,,,0,<unresolvedSignature>
111669158622,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"infer:ANY(ValuePtr<InferModel>&,ANY,longlongint,ANY)",<empty>,,true,,,infer,,,0,"ANY(ValuePtr<InferModel>&,ANY,longlongint,ANY)"
111669158623,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setTokenValue:ANY(),<empty>,,true,,,setTokenValue,,,0,ANY()
111669158624,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.valueFlowForwardConst:<unresolvedSignature>(6),<empty>,,true,,,valueFlowForwardConst,,,0,<unresolvedSignature>
111669158625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.infoString<const>:ANY(),<empty>,,true,,,infoString,,,0,ANY()
111669158626,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"lowerToPossible:void(ANY,int)",<empty>,,true,,,lowerToPossible,,,0,"void(ANY,int)"
111669158627,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.splice:<unresolvedSignature>(4),<empty>,,true,,,splice,,,0,<unresolvedSignature>
111669158628,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"valueFlowForwardConst:void(Token*,Token*,Variable*,ANY,Settings&)",<empty>,,true,,,valueFlowForwardConst,,,0,"void(Token*,Token*,Variable*,ANY,Settings&)"
111669158629,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.invertRange:void(),<empty>,,true,,,invertRange,,,0,void()
111669158630,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.valueFlowForwardConst:<unresolvedSignature>(5),<empty>,,true,,,valueFlowForwardConst,,,0,<unresolvedSignature>
111669158631,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.valueFlowForwardAssign:<unresolvedSignature>(8),<empty>,,true,,,valueFlowForwardAssign,,,0,<unresolvedSignature>
111669158632,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueFlow.truncateIntValue:longlongint(longlongint,ANY,ValueType.Sign)",<empty>,,true,,,truncateIntValue,,,0,"longlongint(longlongint,ANY,ValueType.Sign)"
111669158633,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,intersects:ANY(),<empty>,,true,,,intersects,,,0,ANY()
111669158634,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"truncateValues:ANY(ANY,ValueType*,ValueType*,Settings&)",<empty>,,true,,,truncateValues,,,0,"ANY(ANY,ValueType*,ValueType*,Settings&)"
111669158635,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.intersects:<unresolvedSignature>(2),<empty>,,true,,,intersects,,,0,<unresolvedSignature>
111669158636,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getVariables:<unresolvedSignature>(1),<empty>,,true,,,getVariables,,,0,<unresolvedSignature>
111669158637,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"changePossibleToKnown:void(ANY,int)",<empty>,,true,,,changePossibleToKnown,,,0,"void(ANY,int)"
111669158638,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ConditionHandler.Condition.findPath:longlongint(ANY),<empty>,,true,,,findPath,,,0,longlongint(ANY)
111669158639,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ConditionHandler.Condition.getPath:longlongint(),<empty>,,true,,,getPath,,,0,longlongint()
111669158640,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"insertImpossible:void(ANY,ANY)",<empty>,,true,,,insertImpossible,,,0,"void(ANY,ANY)"
111669158641,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ConditionHandler.Condition.isBool:bool(),<empty>,,true,,,isBool,,,0,bool()
111669158642,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"insertNegateKnown:void(ANY,ANY)",<empty>,,true,,,insertNegateKnown,,,0,"void(ANY,ANY)"
111669158643,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ConditionHandler.reverse:void(Token*,Token*,Token*,ANY,TokenList&,ErrorLogger&,Settings&,SourceLocation)",<empty>,,true,,,reverse,,,0,"void(Token*,Token*,Token*,ANY,TokenList&,ErrorLogger&,Settings&,SourceLocation)"
111669158644,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ConditionHandler.Condition.getContextAndValues<const>:Token*(Token*,ANY,ANY,bool)",<empty>,,true,,,getContextAndValues,,,0,"Token*(Token*,ANY,ANY,bool)"
111669158645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ConditionHandler.forward:Analyzer.Result(Token*,Token*,ANY,TokenList&,ErrorLogger&,Settings&,SourceLocation)",<empty>,,true,,,forward,,,0,"Analyzer.Result(Token*,Token*,ANY,TokenList&,ErrorLogger&,Settings&,SourceLocation)"
111669158646,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ConditionHandler.fillFromPath:void(ProgramMemory&,Token*,longlongint,Settings&)",<empty>,,true,,,fillFromPath,,,0,"void(ProgramMemory&,Token*,longlongint,Settings&)"
111669158647,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"valueFlowSetConditionToKnown:void(Token*,ANY,bool)",<empty>,,true,,,valueFlowSetConditionToKnown,,,0,"void(Token*,ANY,bool)"
111669158648,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ConditionHandler.forward:Analyzer.Result(Token*,Token*,Token*,ANY,TokenList&,ErrorLogger&,Settings&,SourceLocation)",<empty>,,true,,,forward,,,0,"Analyzer.Result(Token*,Token*,Token*,ANY,TokenList&,ErrorLogger&,Settings&,SourceLocation)"
111669158649,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"valueFlowForwardRecursive:Analyzer.Result(Token*,Token*,ANY,TokenList&,ErrorLogger&,Settings&,SourceLocation)",<empty>,,true,,,valueFlowForwardRecursive,,,0,"Analyzer.Result(Token*,Token*,ANY,TokenList&,ErrorLogger&,Settings&,SourceLocation)"
111669158650,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"valueFlowReverse:void(Token*,Token*,Token*,ANY,TokenList&,ErrorLogger&,Settings&,SourceLocation)",<empty>,,true,,,valueFlowReverse,,,0,"void(Token*,Token*,Token*,ANY,TokenList&,ErrorLogger&,Settings&,SourceLocation)"
111669158651,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ConditionHandler.parse:ANY(Token*,Settings&)",<empty>,,true,,,parse,,,0,"ANY(Token*,Settings&)"
111669158652,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.traverseCondition:<unresolvedSignature>(4),<empty>,,true,,,traverseCondition,,,0,<unresolvedSignature>
111669158653,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.astSibling:Token*(),<empty>,,true,,,astSibling,,,0,Token*()
111669158654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ConditionHandler.beforeCondition<const>:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,ANY)",<empty>,,true,,,beforeCondition,,,0,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,ANY)"
111669158655,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ConditionHandler.afterCondition<const>:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,ANY)",<empty>,,true,,,afterCondition,,,0,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,ANY)"
111669158656,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.parseCompareEachInt:<unresolvedSignature>(2),<empty>,,true,,,parseCompareEachInt,,,0,<unresolvedSignature>
111669158657,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IteratorInferModel.getType:ValueFlow.Value.ValueType(),<empty>,,true,,,getType,,,0,ValueFlow.Value.ValueType()
111669158658,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"infer:ANY(ValuePtr<InferModel>&,ANY,ANY,ANY)",<empty>,,true,,,infer,,,0,"ANY(ValuePtr<InferModel>&,ANY,ANY,ANY)"
111669158659,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():void(Token*,Token*,bool)",<empty>,,true,,,<operator>(),,,0,"void(Token*,Token*,bool)"
111669158660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"extractForLoopValues:bool(Token*,int&,bool&,longlongint&,bool&,longlongint&,longlongint&)",<empty>,,true,,,extractForLoopValues,,,0,"bool(Token*,int&,bool&,longlongint&,bool&,longlongint&,longlongint&)"
111669158661,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.asImpossible:<unresolvedSignature>(1),<empty>,,true,,,asImpossible,,,0,<unresolvedSignature>
111669158662,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"valueFlowForLoopSimplifyAfter:void(Token*,int,longlong,TokenList&,ErrorLogger&,Settings&)",<empty>,,true,,,valueFlowForLoopSimplifyAfter,,,0,"void(Token*,int,longlong,TokenList&,ErrorLogger&,Settings&)"
111669158663,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.valueFlowForLoopSimplify:<unresolvedSignature>(7),<empty>,,true,,,valueFlowForLoopSimplify,,,0,<unresolvedSignature>
111669158664,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.valueFlowForLoopSimplifyAfter:<unresolvedSignature>(6),<empty>,,true,,,valueFlowForLoopSimplifyAfter,,,0,<unresolvedSignature>
111669158665,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"makeMultiValueFlowAnalyzer:ValuePtr<Analyzer>(ANY,Settings&)",<empty>,,true,,,makeMultiValueFlowAnalyzer,,,0,"ValuePtr<Analyzer>(ANY,Settings&)"
111669158666,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.productParams:<unresolvedSignature>(3),<empty>,,true,,,productParams,,,0,<unresolvedSignature>
111669158667,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.valueFlowReverse:<unresolvedSignature>(6),<empty>,,true,,,valueFlowReverse,,,0,<unresolvedSignature>
111669158668,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setKnown:<unresolvedSignature>(0),<empty>,,true,,,setKnown,,,0,<unresolvedSignature>
111669158669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isPossible:<unresolvedSignature>(0),<empty>,,true,,,isPossible,,,0,<unresolvedSignature>
111669158670,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getFunctionArgumentValues:ANY(Token*),<empty>,,true,,,getFunctionArgumentValues,,,0,ANY(Token*)
111669158671,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"valueFlowLibraryFunction:void(Token*,ANY,Settings&)",<empty>,,true,,,valueFlowLibraryFunction,,,0,"void(Token*,ANY,Settings&)"
111669158672,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isUninitValue:<unresolvedSignature>(0),<empty>,,true,,,isUninitValue,,,0,<unresolvedSignature>
111669158673,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"valueFlowInjectParameter:void(TokenList&,ErrorLogger&,Settings&,Scope*,ANY)",<empty>,,true,,,valueFlowInjectParameter,,,0,"void(TokenList&,ErrorLogger&,Settings&,Scope*,ANY)"
111669158674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"valueFlowInjectParameter:void(TokenList&,ErrorLogger&,Settings&,Variable*,Scope*,ANY)",<empty>,,true,,,valueFlowInjectParameter,,,0,"void(TokenList&,ErrorLogger&,Settings&,Variable*,Scope*,ANY)"
111669158675,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getKnownValueFromToken:<unresolvedSignature>(1),<empty>,,true,,,getKnownValueFromToken,,,0,<unresolvedSignature>
111669158676,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getKnownValueFromTokens:ValueFlow.Value*(ANY),<empty>,,true,,,getKnownValueFromTokens,,,0,ValueFlow.Value*(ANY)
111669158677,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"execute:ANY(Scope*,ProgramMemory&,Settings&)",<empty>,,true,,,execute,,,0,"ANY(Scope*,ProgramMemory&,Settings&)"
111669158678,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.findTokensSkipDeadCode:<unresolvedSignature>(4),<empty>,,true,,,findTokensSkipDeadCode,,,0,<unresolvedSignature>
111669158679,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"findAllUsages:ANY(Variable*,Token*,Library&)",<empty>,,true,,,findAllUsages,,,0,"ANY(Variable*,Token*,Library&)"
111669158680,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.make_shared<PartialReadContainer>:<unresolvedSignature>(0),<empty>,,true,,,make_shared<PartialReadContainer>,,,0,<unresolvedSignature>
111669158681,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.makeMemberExpressionAnalyzer:<unresolvedSignature>(5),<empty>,,true,,,makeMemberExpressionAnalyzer,,,0,<unresolvedSignature>
111669158682,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.eval:<unresolvedSignature>(1),<empty>,,true,,,eval,,,0,<unresolvedSignature>
111669158683,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"parseBinaryIntOp:Token*(Token*,ANY,longlongint&)",<empty>,,true,,,parseBinaryIntOp,,,0,"Token*(Token*,ANY,longlongint&)"
111669158684,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueFlow.solveExprValue:Token*(Token*,ANY,ValueFlow.Value&)",<empty>,,true,,,solveExprValue,,,0,"Token*(Token*,ANY,ValueFlow.Value&)"
111669158685,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"valueFlowForwardAssign:void(Token*,Variable*,ANY,bool,bool,TokenList&,ErrorLogger&,Settings&)",<empty>,,true,,,valueFlowForwardAssign,,,0,"void(Token*,Variable*,ANY,bool,bool,TokenList&,ErrorLogger&,Settings&)"
111669158686,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getVariables:ANY(Token*),<empty>,,true,,,getVariables,,,0,ANY(Token*)
111669158687,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.removeValues:<unresolvedSignature>(1),<empty>,,true,,,removeValues,,,0,<unresolvedSignature>
111669158688,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getIteratorValues:ANY(ANY,ValueFlow.Value.ValueKind*)",<empty>,,true,,,getIteratorValues,,,0,"ANY(ANY,ValueFlow.Value.ValueKind*)"
111669158689,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.astIsIntegral:<unresolvedSignature>(2),<empty>,,true,,,astIsIntegral,,,0,<unresolvedSignature>
111669158690,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.astIsContainer:<unresolvedSignature>(1),<empty>,,true,,,astIsContainer,,,0,<unresolvedSignature>
111669158691,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getContainerValues:<unresolvedSignature>(1),<empty>,,true,,,getContainerValues,,,0,<unresolvedSignature>
111669158692,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isIteratorPair:bool(ANY),<empty>,,true,,,isIteratorPair,,,0,bool(ANY)
111669158693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.astIsGenericChar:<unresolvedSignature>(1),<empty>,,true,,,astIsGenericChar,,,0,<unresolvedSignature>
111669158694,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getContainerSizeFromConstructorArgs:ANY(ANY,Library.Container*,bool)",<empty>,,true,,,getContainerSizeFromConstructorArgs,,,0,"ANY(ANY,Library.Container*,bool)"
111669158695,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getInitListSize:<unresolvedSignature>(4),<empty>,,true,,,getInitListSize,,,0,<unresolvedSignature>
111669158696,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.valueFlowForward:<unresolvedSignature>(6),<empty>,,true,,,valueFlowForward,,,0,<unresolvedSignature>
111669158697,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getInitListSize:ANY(Token*,ValueType*,Settings&,bool)",<empty>,,true,,,getInitListSize,,,0,"ANY(Token*,ValueType*,Settings&,bool)"
111669158698,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getContainerSizeFromConstructor:ANY(Token*,ValueType*,Settings&,bool)",<empty>,,true,,,getContainerSizeFromConstructor,,,0,"ANY(Token*,ValueType*,Settings&,bool)"
111669158699,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"valueFlowForward:Analyzer.Result(Token*,Token*,ValueFlow.Value,TokenList&,ErrorLogger&,Settings&,SourceLocation)",<empty>,,true,,,valueFlowForward,,,0,"Analyzer.Result(Token*,Token*,ValueFlow.Value,TokenList&,ErrorLogger&,Settings&,SourceLocation)"
111669158700,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"<operator>():void(MathLib.bigint,Token*,Token*)",<empty>,,true,,,<operator>(),,,0,"void(MathLib.bigint,Token*,Token*)"
111669158701,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>():bigint(Token*),<empty>,,true,,,<operator>(),,,0,bigint(Token*)
111669158702,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueFlow.getMinMaxValues:bool(ValueType*,Platform&,longlongint&,longlongint&)",<empty>,,true,,,getMinMaxValues,,,0,"bool(ValueType*,Platform&,longlongint&,longlongint&)"
111669158703,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Token.getCppcheckAttribute<const>:bool(TokenImpl.CppcheckAttributes.Type,longlongint&)",<empty>,,true,,,getCppcheckAttribute,,,0,"bool(TokenImpl.CppcheckAttributes.Type,longlongint&)"
111669158704,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Library.unknownReturnValues<const>:ANY(Token*),<empty>,,true,,,unknownReturnValues,,,0,ANY(Token*)
111669158705,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getMinMaxValues:bool(ANY,Settings&,bool,longlongint&,longlongint&)",<empty>,,true,,,getMinMaxValues,,,0,"bool(ANY,Settings&,bool,longlongint&,longlongint&)"
111669158706,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.debugString:ANY(ValueFlow.Value&),<empty>,,true,,,debugString,,,0,ANY(ValueFlow.Value&)
111669158707,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowPassRunner.run:bool(ValuePtr<ValueFlowPass>&),<empty>,,true,,,run,,,0,bool(ValuePtr<ValueFlowPass>&)
111669158708,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowPassRunner.getTotalValues:ANY(),<empty>,,true,,,getTotalValues,,,0,ANY()
111669158709,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.now:<unresolvedSignature>(0),<empty>,,true,,,now,,,0,<unresolvedSignature>
111669158710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std::chrono::seconds,<empty>,,true,,,std::chrono::seconds,,,0,
111669158711,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.mRun:<unresolvedSignature>(5),<empty>,,true,,,mRun,,,0,<unresolvedSignature>
111669158712,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"valueFlowCondition:void(ValuePtr<ConditionHandler>&,TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,ANY)",<empty>,,true,,,valueFlowCondition,,,0,"void(ValuePtr<ConditionHandler>&,TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,ANY)"
111669158713,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"valueFlowAfterAssign:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,ANY)",<empty>,,true,,,valueFlowAfterAssign,,,0,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,ANY)"
111669158714,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"valueFlowContainerSize:void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,ANY)",<empty>,,true,,,valueFlowContainerSize,,,0,"void(TokenList&,SymbolDatabase&,ErrorLogger&,Settings&,ANY)"
111669158715,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.clearValueFlow:void(),<empty>,,true,,,clearValueFlow,,,0,void()
111669158716,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isInitComma:void(bool),<empty>,,true,,,isInitComma,,,0,void(bool)
111669158717,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowState,<empty>,,true,,,ValueFlowState,,,0,
111669158718,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.run_once:<unresolvedSignature>(1),<empty>,,true,,,run_once,,,0,<unresolvedSignature>
111669158719,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lib/valueflow.cpp,lib/valueflow.cpp:7228:7228:VFA:1,<empty>,,true,7228,7228,VFA,,,0,
111669158720,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"makeValueFlowPassAdaptor:ANY(char*,bool,std.function)",<empty>,,true,,,makeValueFlowPassAdaptor,,,0,"ANY(char*,bool,std.function)"
111669158721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.run:<unresolvedSignature>(1),<empty>,,true,,,run,,,0,<unresolvedSignature>
111669158722,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lib/valueflow.cpp,lib/valueflow.cpp:7229:7229:VFA_CPP:1,<empty>,,true,7229,7229,VFA_CPP,,,0,
111669158723,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"isOutOfBoundsImpl:ANY(ValueFlow.Value&,Token*,bool)",<empty>,,true,,,isOutOfBoundsImpl,,,0,"ANY(ValueFlow.Value&,Token*,bool)"
111669158724,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueFlowAnalyzer.analyzeCondition:ValueFlowAnalyzer.ConditionState(Token*,int)",<empty>,,true,,,analyzeCondition,,,0,"ValueFlowAnalyzer.ConditionState(Token*,int)"
111669158725,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowAnalyzer.match:bool(Token*),<empty>,,true,,,match,,,0,bool(Token*)
111669158726,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowAnalyzer.getProgramState:ANY(),<empty>,,true,,,getProgramState,,,0,ANY()
111669158727,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ProgramMemoryState.get<const>:ProgramMemory(Token*,Token*,ANY)",<empty>,,true,,,get,,,0,"ProgramMemory(Token*,Token*,ANY)"
111669158728,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueFlowAnalyzer.analyze:Analyzer.Action(Token*,Analyzer.Direction)",<empty>,,true,,,analyze,,,0,"Analyzer.Action(Token*,Analyzer.Direction)"
111669158729,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueFlowAnalyzer.evaluate:ANY(Analyzer.Evaluate,Token*,Token*)",<empty>,,true,,,evaluate,,,0,"ANY(Analyzer.Evaluate,Token*,Token*)"
111669158730,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowAnalyzer.getSymbols:ANY(Token*),<empty>,,true,,,getSymbols,,,0,ANY(Token*)
111669158731,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowAnalyzer.getIndirect:int(Token*),<empty>,,true,,,getIndirect,,,0,int(Token*)
111669158732,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowAnalyzer.getSettings:Settings&(),<empty>,,true,,,getSettings,,,0,Settings&()
111669158733,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowAnalyzer.evaluateInt:ANY(Token*),<empty>,,true,,,evaluateInt,,,0,ANY(Token*)
111669158734,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.equalTo:<unresolvedSignature>(1),<empty>,,true,,,equalTo,,,0,<unresolvedSignature>
111669158735,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.evalAssignment:<unresolvedSignature>(3),<empty>,,true,,,evalAssignment,,,0,<unresolvedSignature>
111669158736,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlow.Value.invertBound:void(),<empty>,,true,,,invertBound,,,0,void()
111669158737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowAnalyzer.analyzeLifetime:Analyzer.Action(Token*),<empty>,,true,,,analyzeLifetime,,,0,Analyzer.Action(Token*)
111669158738,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowAnalyzer.invertAssign:ANY(ANY),<empty>,,true,,,invertAssign,,,0,ANY(ANY)
111669158739,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,calculate:ANY(),<empty>,,true,,,"calculate<T, T>",,,0,ANY()
111669158740,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowAnalyzer.removeAssign:ANY(ANY),<empty>,,true,,,removeAssign,,,0,ANY(ANY)
111669158741,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowAnalyzer.assignValueIfMutable:ANY(),<empty>,,true,,,assignValueIfMutable,,,0,ANY()
111669158742,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowAnalyzer.calculateAssign:ANY(),<empty>,,true,,,calculateAssign,,,0,ANY()
111669158743,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowAnalyzer.useSymbolicValues:bool(),<empty>,,true,,,useSymbolicValues,,,0,bool()
111669158744,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowAnalyzer.findMatch:Token*(Token*),<empty>,,true,,,findMatch,,,0,Token*(Token*)
111669158745,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowAnalyzer.isGlobal:bool(),<empty>,,true,,,isGlobal,,,0,bool()
111669158746,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowAnalyzer.dependsOnThis:bool(),<empty>,,true,,,dependsOnThis,,,0,bool()
111669158747,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowAnalyzer.isGlobalModified:Analyzer.Action(Token*),<empty>,,true,,,isGlobalModified,,,0,Analyzer.Action(Token*)
111669158748,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueFlowAnalyzer.isWritable:Analyzer.Action(Token*,Analyzer.Direction)",<empty>,,true,,,isWritable,,,0,"Analyzer.Action(Token*,Analyzer.Direction)"
111669158749,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowAnalyzer.isModified:Analyzer.Action(Token*),<empty>,,true,,,isModified,,,0,Analyzer.Action(Token*)
111669158750,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueFlowAnalyzer.analyzeMatch:Analyzer.Action(Token*,Analyzer.Direction)",<empty>,,true,,,analyzeMatch,,,0,"Analyzer.Action(Token*,Analyzer.Direction)"
111669158751,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueFlowAnalyzer.isAliasModified:Analyzer.Action(Token*,int)",<empty>,,true,,,isAliasModified,,,0,"Analyzer.Action(Token*,int)"
111669158752,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueFlowAnalyzer.isAlias:bool(Token*,bool&)",<empty>,,true,,,isAlias,,,0,"bool(Token*,bool&)"
111669158753,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueFlowAnalyzer.isSameSymbolicValue:bool(Token*,ValueFlow.Value*)",<empty>,,true,,,isSameSymbolicValue,,,0,"bool(Token*,ValueFlow.Value*)"
111669158754,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Analyzer.invalid:bool(),<empty>,,true,,,invalid,,,0,bool()
111669158755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReferenceToken,<empty>,,true,,,ReferenceToken,,,0,
111669158756,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueFlowAnalyzer.analyzeToken:Analyzer.Action(Token*,Token*,Analyzer.Direction,bool)",<empty>,,true,,,analyzeToken,,,0,"Analyzer.Action(Token*,Token*,Analyzer.Direction,bool)"
111669158757,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowAnalyzer.internalMatch:bool(Token*),<empty>,,true,,,internalMatch,,,0,bool(Token*)
111669158758,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowAnalyzer.isVariable:bool(),<empty>,,true,,,isVariable,,,0,bool()
111669158759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ValueFlowAnalyzer.isThisModified:Analyzer.Action(Token*),<empty>,,true,,,isThisModified,,,0,Analyzer.Action(Token*)
111669158760,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getProgramMemory:<unresolvedSignature>(0),<empty>,,true,,,getProgramMemory,,,0,<unresolvedSignature>
111669158761,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.conditionIsFalse:<unresolvedSignature>(3),<empty>,,true,,,conditionIsFalse,,,0,<unresolvedSignature>
111669158762,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.evaluateInt:<unresolvedSignature>(2),<empty>,,true,,,evaluateInt,,,0,<unresolvedSignature>
111669158763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ProgramMemory.getContainerEmptyValue<const>:bool(int,longlongint&)",<empty>,,true,,,getContainerEmptyValue,,,0,"bool(int,longlongint&)"
111669158764,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueFlowAnalyzer.addErrorPath:void(Token*,ANY)",<empty>,,true,,,addErrorPath,,,0,"void(Token*,ANY)"
111669158765,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Analyzer.Action.isSymbolicMatch<const>:bool(),<empty>,,true,,,isSymbolicMatch,,,0,bool()
111669158766,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Analyzer.Action.isInternal<const>:bool(),<empty>,,true,,,isInternal,,,0,bool()
111669158767,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ValueFlowAnalyzer.writeValue:void(ValueFlow.Value*,Token*,Analyzer.Direction)",<empty>,,true,,,writeValue,,,0,"void(ValueFlow.Value*,Token*,Analyzer.Direction)"
111669158768,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"bifurcate:bool(Token*,ANY,Settings&,int)",<empty>,,true,,,bifurcate,,,0,"bool(Token*,ANY,Settings&,int)"
111669158769,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"bifurcateVariableChanged:bool(Variable*,ANY,Token*,Token*,Settings&,int)",<empty>,,true,,,bifurcateVariableChanged,,,0,"bool(Variable*,ANY,Token*,Token*,Settings&,int)"
111669158770,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.Iterator:<unresolvedSignature>(1),<empty>,,true,,,Iterator,,,0,<unresolvedSignature>
111669158771,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.isLifetimeValue:<unresolvedSignature>(0),<empty>,,true,,,isLifetimeValue,,,0,<unresolvedSignature>
111669158772,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.SelectValueFromVarIdMapRange:<unresolvedSignature>(1),<empty>,,true,,,SelectValueFromVarIdMapRange,,,0,<unresolvedSignature>
111669158773,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MultiValueFlowAnalyzer.getVars:ANY(),<empty>,,true,,,getVars,,,0,ANY()
111669158774,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"isAliasOf:bool(Variable*,Token*,int,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange&,bool*)",<empty>,,true,,,isAliasOf,,,0,"bool(Variable*,Token*,int,MultiValueFlowAnalyzer.SelectValueFromVarIdMapRange&,bool*)"
111669158775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.changeKnownToPossible:<unresolvedSignature>(0),<empty>,,true,,,changeKnownToPossible,,,0,<unresolvedSignature>
111669158776,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setInconclusive:<unresolvedSignature>(0),<empty>,,true,,,setInconclusive,,,0,<unresolvedSignature>
111669158777,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MultiValueFlowAnalyzer.isConditional:bool(),<empty>,,true,,,isConditional,,,0,bool()
111669158778,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.bind:<unresolvedSignature>(2),<empty>,,true,,,bind,,,0,<unresolvedSignature>
111669158779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MultiValueFlowAnalyzer,<empty>,,true,,,MultiValueFlowAnalyzer,,,0,
111669158780,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SingleValueFlowAnalyzer.getVars:ANY(),<empty>,,true,,,getVars,,,0,ANY()
111669158781,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SingleValueFlowAnalyzer.getAliasedVars:ANY(),<empty>,,true,,,getAliasedVars,,,0,ANY()
111669158782,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"isAliasOf:bool(Variable*,Token*,int,SingleValueFlowAnalyzer.SingleRange<constValueFlow.Value>&,bool*)",<empty>,,true,,,isAliasOf,,,0,"bool(Variable*,Token*,int,SingleValueFlowAnalyzer.SingleRange<constValueFlow.Value>&,bool*)"
111669158783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SingleValueFlowAnalyzer.MakeSingleRange:SingleValueFlowAnalyzer.SingleRange<constValueFlow.Value>(ValueFlow.Value&),<empty>,,true,,,MakeSingleRange,,,0,SingleValueFlowAnalyzer.SingleRange<constValueFlow.Value>(ValueFlow.Value&)
111669158784,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SingleValueFlowAnalyzer.isConditional:bool(),<empty>,,true,,,isConditional,,,0,bool()
111669158785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Token.isUniqueExprId<const>:bool(),<empty>,,true,,,isUniqueExprId,,,0,bool()
111669158786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExpressionAnalyzer.skipUniqueExprIds:bool(),<empty>,,true,,,skipUniqueExprIds,,,0,bool()
111669158787,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SameExpressionAnalyzer,<empty>,,true,,,SameExpressionAnalyzer,,,0,
111669158788,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OppositeExpressionAnalyzer,<empty>,,true,,,OppositeExpressionAnalyzer,,,0,
111669158789,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SubExpressionAnalyzer.submatch:bool(Token*,bool)",<empty>,,true,,,submatch,,,0,"bool(Token*,bool)"
111669158790,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"SingleValueFlowAnalyzer.isAlias:bool(Token*,bool&)",<empty>,,true,,,isAlias,,,0,"bool(Token*,bool&)"
111669158791,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MemberExpressionAnalyzer,<empty>,,true,,,MemberExpressionAnalyzer,,,0,
111669158792,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ContainerExpressionAnalyzer.getIndirect:int(Token*),<empty>,,true,,,getIndirect,,,0,int(Token*)
111669158793,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ContainerExpressionAnalyzer:<unresolvedSignature>(3),<empty>,,true,,,ContainerExpressionAnalyzer,,,0,<unresolvedSignature>
111669158794,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.ExpressionAnalyzer:<unresolvedSignature>(3),<empty>,,true,,,ExpressionAnalyzer,,,0,<unresolvedSignature>
111669158795,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.dimensionKnown:<unresolvedSignature>(1),<empty>,,true,,,dimensionKnown,,,0,<unresolvedSignature>
111669158796,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.castValue:<unresolvedSignature>(3),<empty>,,true,,,castValue,,,0,<unresolvedSignature>
111669158797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Platform.signedCharMax<const>:longlong(),<empty>,,true,,,signedCharMax,,,0,longlong()
111669158798,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.bigint:<unresolvedSignature>(1),<empty>,,true,,,bigint,,,0,<unresolvedSignature>
111669158799,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.intValue1:<unresolvedSignature>(0),<empty>,,true,,,intValue1,,,0,<unresolvedSignature>
111669158800,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.intValue2:<unresolvedSignature>(0),<empty>,,true,,,intValue2,,,0,<unresolvedSignature>
111669158801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"CppCheck.check:unsigned int(FileWithDetails&,ANY)",<empty>,,true,,,check,,,0,"unsigned int(FileWithDetails&,ANY)"
111669158802,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"generateCode2:ANY(ANY,ANY)",<empty>,,true,,,generateCode2,,,0,"ANY(ANY,ANY)"
111669158803,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,doCheck:void(ANY),<empty>,,true,,,doCheck,,,0,void(ANY)
111669158804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.istreambuf_iterator<char>:<unresolvedSignature>(0),<empty>,,true,,,istreambuf_iterator<char>,,,0,<unresolvedSignature>
111669158805,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.generateCode2:<unresolvedSignature>(2),<empty>,,true,,,generateCode2,,,0,<unresolvedSignature>
111669158806,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getValue:<unresolvedSignature>(3),<empty>,,true,,,getValue,,,0,<unresolvedSignature>
111669158807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"generateExpression2_lvalue:ANY(ANY,ANY)",<empty>,,true,,,generateExpression2_lvalue,,,0,"ANY(ANY,ANY)"
111669158808,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getValue:int(ANY,ANY,ANY,bool*)",<empty>,,true,,,getValue,,,0,"int(ANY,ANY,ANY,bool*)"
111669158809,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"generateExpression2_Op:ANY(ANY,ANY,ANY)",<empty>,,true,,,generateExpression2_Op,,,0,"ANY(ANY,ANY,ANY)"
111669158810,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"generateExpression2_Expr:ANY(ANY,ANY,ANY,int)",<empty>,,true,,,generateExpression2_Expr,,,0,"ANY(ANY,ANY,ANY,int)"
111669158811,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,functionStart:ANY(),<empty>,,true,,,functionStart,,,0,ANY()
111669158812,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getValue:<unresolvedSignature>(4),<empty>,,true,,,getValue,,,0,<unresolvedSignature>
111669158813,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"generateExpression2_Cond:ANY(ANY,ANY,ANY)",<empty>,,true,,,generateExpression2_Cond,,,0,"ANY(ANY,ANY,ANY)"
111669158814,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"generateExpression2_conditionalCode:ANY(ANY,ANY,ANY,ANY)",<empty>,,true,,,generateExpression2_conditionalCode,,,0,"ANY(ANY,ANY,ANY,ANY)"
111669158815,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.generateExpression2_conditionalCode:<unresolvedSignature>(4),<empty>,,true,,,generateExpression2_conditionalCode,,,0,<unresolvedSignature>
111669158816,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.foo:<unresolvedSignature>(1),<empty>,,true,,,foo,,,0,<unresolvedSignature>
111669158817,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,foo:void(ANY),<empty>,,true,,,foo,,,0,void(ANY)
111669158818,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strcpy,<empty>,,true,,,strcpy,,,0,
111669158819,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,snprintf,<empty>,,true,,,snprintf,,,0,
111669158820,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,malloc,<empty>,,true,,,malloc,,,0,
111669158821,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,free,<empty>,,true,,,free,,,0,
111669158822,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,foo:bool(ANY),<empty>,,true,,,foo,,,0,bool(ANY)
111669158823,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fopen,<empty>,,true,,,fopen,,,0,
111669158824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fclose,<empty>,,true,,,fclose,,,0,
111669158825,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"foo:void(ANY,ANY)",<empty>,,true,,,foo,,,0,"void(ANY,ANY)"
111669158826,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,tools/defines/float.c,tools/defines/float.c:4:5:PRINT_DEF:2,<empty>,,true,4,5,PRINT_DEF,,,0,
111669158827,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fprintf,<empty>,,true,,,fprintf,,,0,
111669158828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,tools/defines/limits.c,tools/defines/limits.c:4:5:PRINT_DEF:2,<empty>,,true,4,5,PRINT_DEF,,,0,
111669158829,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,tools/defines/stdint.c,tools/defines/stdint.c:4:5:PRINT_DEF:2,<empty>,,true,4,5,PRINT_DEF,,,0,
111669158830,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,tools/defines/stdint.c,tools/defines/stdint.c:7:13:PRINT_DEF_N:3,<empty>,,true,7,13,PRINT_DEF_N,,,0,
111669158831,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,builddir:ANY(ANY),<empty>,,true,,,builddir,,,0,ANY(ANY)
111669158832,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,objfile:ANY(ANY),<empty>,,true,,,objfile,,,0,ANY(ANY)
111669158833,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getDeps:<unresolvedSignature>(2),<empty>,,true,,,getDeps,,,0,<unresolvedSignature>
111669158834,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"getDeps:void(ANY,ANY)",<empty>,,true,,,getDeps,,,0,"void(ANY,ANY)"
111669158835,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.source_f:<unresolvedSignature>(1),<empty>,,true,,,source_f,,,0,<unresolvedSignature>
111669158836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.header_f:<unresolvedSignature>(1),<empty>,,true,,,header_f,,,0,<unresolvedSignature>
111669158837,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.makeMatchcompiler:<unresolvedSignature>(3),<empty>,,true,,,makeMatchcompiler,,,0,<unresolvedSignature>
111669158838,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,objfiles:ANY(ANY),<empty>,,true,,,objfiles,,,0,ANY(ANY)
111669158839,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.compilefiles:<unresolvedSignature>(3),<empty>,,true,,,compilefiles,,,0,<unresolvedSignature>
111669158840,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"make_vcxproj_cl_entry:ANY(ANY,ClType)",<empty>,,true,,,make_vcxproj_cl_entry,,,0,"ANY(ANY,ClType)"
111669158841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.make_vcxproj_cl_entry:<unresolvedSignature>(2),<empty>,,true,,,make_vcxproj_cl_entry,,,0,<unresolvedSignature>
111669158842,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.getCppFiles:<unresolvedSignature>(3),<empty>,,true,,,getCppFiles,,,0,<unresolvedSignature>
111669158843,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.prioritizelib:<unresolvedSignature>(1),<empty>,,true,,,prioritizelib,,,0,<unresolvedSignature>
111669158844,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.write_vcxproj:<unresolvedSignature>(3),<empty>,,true,,,write_vcxproj,,,0,<unresolvedSignature>
111669158845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.makeConditionalVariable:<unresolvedSignature>(3),<empty>,,true,,,makeConditionalVariable,,,0,<unresolvedSignature>
111669158846,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.objfiles:<unresolvedSignature>(1),<empty>,,true,,,objfiles,,,0,<unresolvedSignature>
111669158847,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.write_ossfuzz_makefile:<unresolvedSignature>(2),<empty>,,true,,,write_ossfuzz_makefile,,,0,<unresolvedSignature>
111669158848,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.srand:<unresolvedSignature>(1),<empty>,,true,,,srand,,,0,<unresolvedSignature>
111669158849,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.mkdir:<unresolvedSignature>(1),<empty>,,true,,,mkdir,,,0,<unresolvedSignature>
111669158850,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setRootPath:<unresolvedSignature>(1),<empty>,,true,,,setRootPath,,,0,<unresolvedSignature>
111669158851,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setReadOnly:<unresolvedSignature>(1),<empty>,,true,,,setReadOnly,,,0,<unresolvedSignature>
111669158852,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.header:<unresolvedSignature>(0),<empty>,,true,,,header,,,0,<unresolvedSignature>
111669158853,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.hideSection:<unresolvedSignature>(1),<empty>,,true,,,hideSection,,,0,<unresolvedSignature>
111669158854,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setRootIndex:<unresolvedSignature>(1),<empty>,,true,,,setRootIndex,,,0,<unresolvedSignature>
111669158855,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.index:<unresolvedSignature>(1),<empty>,,true,,,index,,,0,<unresolvedSignature>
111669158856,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.clearMessage:<unresolvedSignature>(0),<empty>,,true,,,clearMessage,,,0,<unresolvedSignature>
111669158857,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.filter:<unresolvedSignature>(1),<empty>,,true,,,filter,,,0,<unresolvedSignature>
111669158858,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.shuffle:<unresolvedSignature>(3),<empty>,,true,,,shuffle,,,0,<unresolvedSignature>
111669158859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.mt19937:<unresolvedSignature>(1),<empty>,,true,,,mt19937,,,0,<unresolvedSignature>
111669158860,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.<operator>():<unresolvedSignature>(0),<empty>,,true,,,<operator>(),,,0,<unresolvedSignature>
111669158861,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.random_device:<unresolvedSignature>(0),<empty>,,true,,,random_device,,,0,<unresolvedSignature>
111669158862,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setWindowModality:<unresolvedSignature>(1),<empty>,,true,,,setWindowModality,,,0,<unresolvedSignature>
111669158863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setMinimumDuration:<unresolvedSignature>(1),<empty>,,true,,,setMinimumDuration,,,0,<unresolvedSignature>
111669158864,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.state:<unresolvedSignature>(0),<empty>,,true,,,state,,,0,<unresolvedSignature>
111669158865,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.processEvents:<unresolvedSignature>(0),<empty>,,true,,,processEvents,,,0,<unresolvedSignature>
111669158866,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.wasCanceled:<unresolvedSignature>(0),<empty>,,true,,,wasCanceled,,,0,<unresolvedSignature>
111669158867,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.kill:<unresolvedSignature>(0),<empty>,,true,,,kill,,,0,<unresolvedSignature>
111669158868,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.showMessage:<unresolvedSignature>(1),<empty>,,true,,,showMessage,,,0,<unresolvedSignature>
111669158869,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.runProcess:<unresolvedSignature>(2),<empty>,,true,,,runProcess,,,0,<unresolvedSignature>
111669158870,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MainWindow.unpackArchive:bool(ANY),<empty>,,true,,,unpackArchive,,,0,bool(ANY)
111669158871,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MainWindow.wget:bool(ANY),<empty>,,true,,,wget,,,0,bool(ANY)
111669158872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"MainWindow.showSrcFile:void(ANY,ANY,int)",<empty>,,true,,,showSrcFile,,,0,"void(ANY,ANY,int)"
111669158873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setFocus:<unresolvedSignature>(0),<empty>,,true,,,setFocus,,,0,<unresolvedSignature>
111669158874,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.setNameFilterDisables:<unresolvedSignature>(1),<empty>,,true,,,setNameFilterDisables,,,0,<unresolvedSignature>
111669158875,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.mimeTypeForFile:<unresolvedSignature>(1),<empty>,,true,,,mimeTypeForFile,,,0,<unresolvedSignature>
111669158876,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.inherits:<unresolvedSignature>(1),<empty>,,true,,,inherits,,,0,<unresolvedSignature>
111669158877,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.QStringLiteral:<unresolvedSignature>(1),<empty>,,true,,,QStringLiteral,,,0,<unresolvedSignature>
111669158878,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,QString,<empty>,,true,,,QString,,,0,
111669158879,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.showSrcFile:<unresolvedSignature>(3),<empty>,,true,,,showSrcFile,,,0,<unresolvedSignature>
111669158880,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<unresolvedNamespace>.filePath:<unresolvedSignature>(1),<empty>,,true,,,filePath,,,0,<unresolvedSignature>
