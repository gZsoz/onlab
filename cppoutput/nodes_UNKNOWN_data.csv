184683593728,UNKNOWN,1,,"class CmdLineLogger
{
public:
    virtual ~CmdLineLogger() = default;

    /** print a regular message */
    virtual void printMessage(const std::string &message) = 0;
    /** print an error message */
    virtual void printError(const std::string &message) = 0;
    /** print to the output */
    virtual void printRaw(const std::string &message) = 0;
};",1,<empty>,,24,,,1,CASTProblemDeclaration,,<empty>
184683593729,UNKNOWN,4,,"class CmdLineParser {
public:
    /**
     * The constructor.
     * @param logger The logger instance to log messages through
     * @param settings Settings instance that will be modified according to
     * options user has given.
     * @param suppressions Suppressions instance that keeps the suppressions
     */
    CmdLineParser(CmdLineLogger &logger, Settings &settings, Suppressions &suppressions);

    enum class Result : std::uint8_t { Success, Exit, Fail };

    /**
     * @brief Parse command line args and fill settings and file lists
     * from there.
     *
     * @param argc argc from main()
     * @param argv argv from main()
     * @return false when errors are found in the input
     */
    bool fillSettingsFromArgs(int argc, const char* const argv[]);

    /**
     * Parse given command line.
     * @return true if command line was ok, false if there was an error.
     */
    Result parseFromArgs(int argc, const char* const argv[]);

    /**
     * Return the path...",1,<empty>,,48,,,4,CASTProblemDeclaration,,<empty>
184683593730,UNKNOWN,1,,int64_t,67,<empty>,,138,,,1,CPPASTTypeId,,<empty>
184683593731,UNKNOWN,1,,int64_t,69,<empty>,,139,,,1,CPPASTTypeId,,<empty>
184683593732,UNKNOWN,1,,void,6,<empty>,,598,,,1,CPPASTTypeId,,<empty>
184683593733,UNKNOWN,5,,"class CppCheckExecutor {
public:
    friend class TestSuppressions;

    /**
     * Constructor
     */
    CppCheckExecutor() = default;
    CppCheckExecutor(const CppCheckExecutor &) = delete;
    CppCheckExecutor& operator=(const CppCheckExecutor&) = delete;

    /**
     * Starts the checking.
     *
     * @param argc from main()
     * @param argv from main()
     * @return EXIT_FAILURE if arguments are invalid or no input files
     *         were found.
     *         If errors are found and --error-exitcode is used,
     *         given value is returned instead of default 0.
     *         If no errors are found, 0 is returned.
     */
    int check(int argc, const char* const argv[]);

private:

    /**
     * Execute a shell command and read the output from it. Returns exitcode of the executed command,.
     */
    static int executeCommand(std::string exe, std::vector<std::string> args, std::string redirect, std::string &output_);

protected:

    static bool reportSupp...",1,<empty>,,40,,,5,CASTProblemDeclaration,,<empty>
184683593734,UNKNOWN,7,,"class Executor {
public:
    Executor(const std::list<FileWithDetails> &files, const std::list<FileSettings>& fileSettings, const Settings &settings, Suppressions &suppressions, ErrorLogger &errorLogger);
    virtual ~Executor() = default;

    Executor(const Executor &) = delete;
    Executor& operator=(const Executor &) = delete;

    virtual unsigned int check() = 0;

    /**
     * Information about how many files have been checked
     *
     * @param fileindex This many files have been checked.
     * @param filecount This many files there are in total.
     * @param sizedone The sum of sizes of the files checked.
     * @param sizetotal The total sizes of the files.
     */
    void reportStatus(std::size_t fileindex, std::size_t filecount, std::size_t sizedone, std::size_t sizetotal);

protected:
    /**
     * @brief Check if message is being suppressed and unique.
     * @param msg the message to check
     * @return true if message is not suppressed and unique
     */
   ...",1,<empty>,,42,,,7,CASTProblemDeclaration,,<empty>
184683593735,UNKNOWN,3,,"class FileLister {
public:
    /**
     * @brief Recursively add source files to a map.
     * Add source files from given directory and all subdirectries to the
     * given map. Only files with accepted extensions
     * (*.c;*.cpp;*.cxx;*.c++;*.cc;*.txx) are added.
     * @param files output list that associates the size of each file with its name
     * @param path root path
     * @param extra Extra file extensions
     * @param ignored ignored paths
     * @param debug log if path was ignored
     * @return On success, an empty string is returned. On error, a error message is returned.
     */
    static std::string recursiveAddFiles(std::list<FileWithDetails> &files, const std::string &path, const std::set<std::string> &extra, const PathMatch& ignored, bool debug = false);

    /**
     * @brief (Recursively) add source files to a map.
     * Add source files from given directory and all subdirectries to the
     * given map. Only files with accepted extensions
     * (*.c;*....",1,<empty>,,33,,,3,CASTProblemDeclaration,,<empty>
184683593736,UNKNOWN,1,,char,49,<empty>,,86,,,1,CPPASTTypeId,,<empty>
184683593737,UNKNOWN,1,,char,44,<empty>,,138,,,1,CPPASTTypeId,,<empty>
184683593738,UNKNOWN,1,,unsigned int,42,<empty>,,142,,,1,CPPASTTypeId,,<empty>
184683593739,UNKNOWN,1,,Color,36,<empty>,,219,,,1,CPPASTTypeId,,<empty>
184683593740,UNKNOWN,6,,"class ProcessExecutor : public Executor {
public:
    ProcessExecutor(const std::list<FileWithDetails> &files, const std::list<FileSettings>& fileSettings, const Settings &settings, Suppressions &suppressions, ErrorLogger &errorLogger, CppCheck::ExecuteCmdFn executeCommand);
    ProcessExecutor(const ProcessExecutor &) = delete;
    ProcessExecutor& operator=(const ProcessExecutor &) = delete;

    unsigned int check() override;

private:
    /**
     * Read from the pipe, parse and handle what ever is in there.
     * @return False in case of an recoverable error - will exit process on others
     */
    bool handleRead(int rpipe, unsigned int &result, const std::string& filename);

    /**
     * @brief Check load average condition
     * @param nchildren - count of currently ran children
     * @return true - if new process can be started
     */
    bool checkLoadAverage(size_t nchildren);

    /**
     * @brief Reports internal errors related to child processes
     * @param ms...",1,<empty>,,42,,,6,CASTProblemDeclaration,,<empty>
184683593741,UNKNOWN,1,,"namespace internal
{
    int filter_seh_exeception(int code, void* ex);
}",1,<empty>,,33,,,1,CASTProblemDeclaration,,<empty>
184683593742,UNKNOWN,7,,"class SingleExecutor : public Executor
{
public:
    SingleExecutor(CppCheck &cppcheck, const std::list<FileWithDetails> &files, const std::list<FileSettings>& fileSettings, const Settings &settings, Suppressions &suppressions, ErrorLogger &errorLogger);
    SingleExecutor(const SingleExecutor &) = delete;
    SingleExecutor& operator=(const SingleExecutor &) = delete;

    unsigned int check() override;

private:
    CppCheck &mCppcheck;
};",1,<empty>,,33,,,7,CASTProblemDeclaration,,<empty>
184683593743,UNKNOWN,4,,"static unsigned int STDCALL threadProc(ThreadData *data)
{
    unsigned int result = 0;

    const FileWithDetails *file;
    const FileSettings *fs;
    std::size_t fileSize;

    while (data->next(file, fs, fileSize)) {
        result += data->check(data->logForwarder, file, fs);

        data->status(fileSize);
    }

    return result;
}",1,<empty>,,177,,,4,CPPASTProblemDeclaration,,<empty>
184683593744,UNKNOWN,6,,"class ThreadExecutor : public Executor {
    friend class SyncLogForwarder;

public:
    ThreadExecutor(const std::list<FileWithDetails> &files, const std::list<FileSettings>& fileSettings, const Settings &settings, Suppressions &suppressions, ErrorLogger &errorLogger, CppCheck::ExecuteCmdFn executeCommand);
    ThreadExecutor(const ThreadExecutor &) = delete;
    ThreadExecutor& operator=(const ThreadExecutor &) = delete;

    unsigned int check() override;

    CppCheck::ExecuteCmdFn mExecuteCommand;
};",1,<empty>,,40,,,6,CASTProblemDeclaration,,<empty>
184683593745,UNKNOWN,1,,int,52,<empty>,,107,,,1,CPPASTTypeId,,<empty>
184683593746,UNKNOWN,1,,"extern ""C"" {
#ifdef _MSC_VER
#include <float.h>
#elif defined(__INTEL_COMPILER)
#include <mathimf.h>
#else
#include <math.h>
#endif
}",1,<empty>,,49,,,1,CASTProblemDeclaration,,<empty>
184683593747,UNKNOWN,2,,"extern ""C"" {
#include <locale.h>
}",1,<empty>,,94,,,2,CASTProblemDeclaration,,<empty>
184683593748,UNKNOWN,3,,"namespace picojson {

enum {
  null_type,
  boolean_type,
  number_type,
  string_type,
  array_type,
  object_type
#ifdef PICOJSON_USE_INT64
  ,
  int64_type
#endif
};

enum { INDENT_WIDTH = 2, DEFAULT_MAX_DEPTHS = 100 };

struct null {};

class value {
public:
  typedef std::vector<value> array;
  typedef std::map<std::string, value> object;
  union _storage {
    bool boolean_;
    double number_;
#ifdef PICOJSON_USE_INT64
    int64_t int64_;
#endif
    std::string *string_;
    array *array_;
    object *object_;
  };

protected:
  int type_;
  _storage u_;

public:
  value();
  value(int type, bool);
  explicit value(bool b);
#ifdef PICOJSON_USE_INT64
  explicit value(int64_t i);
#endif
  explicit value(double n);
  explicit value(const std::string &s);
  explicit value(const array &a);
  explicit value(const object &o);
#if PICOJSON_USE_RVALUE_REFERENCE
  explicit value(std::string &&s);
  explicit value(array &&a);
  explicit value(object &&o);
#endif
  explicit value(const c...",1,<empty>,,118,,,3,CASTProblemDeclaration,,<empty>
184683593749,UNKNOWN,4,,"namespace std {
template <> inline void swap(picojson::value &x, picojson::value &y) {
  x.swap(y);
}
}",1,<empty>,,1175,,,4,CASTProblemDeclaration,,<empty>
184683593750,UNKNOWN,5,,"inline std::istream &operator>>(std::istream &is, picojson::value &x) {
  picojson::set_last_error(std::string());
  const std::string err(picojson::parse(x, is));
  if (!err.empty()) {
    picojson::set_last_error(err);
    is.setstate(std::ios::failbit);
  }
  return is;
}",1,<empty>,,1182,,,5,CASTProblemDeclaration,,<empty>
184683593751,UNKNOWN,6,,"inline std::ostream &operator<<(std::ostream &os, const picojson::value &x) {
  x.serialize(std::ostream_iterator<char>(os));
  return os;
}",1,<empty>,,1192,,,6,CASTProblemDeclaration,,<empty>
184683593752,UNKNOWN,1,,unsigned char,40,<empty>,,255,,,1,CPPASTTypeId,,<empty>
184683593753,UNKNOWN,1,,unsigned char,51,<empty>,,260,,,1,CPPASTTypeId,,<empty>
184683593754,UNKNOWN,1,,unsigned char,30,<empty>,,262,,,1,CPPASTTypeId,,<empty>
184683593755,UNKNOWN,1,,unsigned char,40,<empty>,,283,,,1,CPPASTTypeId,,<empty>
184683593756,UNKNOWN,1,,void,14,<empty>,,288,,,1,CPPASTTypeId,,<empty>
184683593757,UNKNOWN,1,,unsigned char,51,<empty>,,289,,,1,CPPASTTypeId,,<empty>
184683593758,UNKNOWN,1,,unsigned char,30,<empty>,,292,,,1,CPPASTTypeId,,<empty>
184683593759,UNKNOWN,1,,void,14,<empty>,,326,,,1,CPPASTTypeId,,<empty>
184683593760,UNKNOWN,1,,unsigned char,54,<empty>,,327,,,1,CPPASTTypeId,,<empty>
184683593761,UNKNOWN,1,,unsigned char,43,<empty>,,329,,,1,CPPASTTypeId,,<empty>
184683593762,UNKNOWN,1,,void,14,<empty>,,336,,,1,CPPASTTypeId,,<empty>
184683593763,UNKNOWN,1,,void,18,<empty>,,338,,,1,CPPASTTypeId,,<empty>
184683593764,UNKNOWN,1,,void,22,<empty>,,340,,,1,CPPASTTypeId,,<empty>
184683593765,UNKNOWN,1,,const unsigned char*,46,<empty>,,490,,,1,CPPASTTypeId,,<empty>
184683593766,UNKNOWN,1,,int,34,<empty>,,680,,,1,CPPASTTypeId,,<empty>
184683593767,UNKNOWN,1,,void,14,<empty>,,794,,,1,CPPASTTypeId,,<empty>
184683593768,UNKNOWN,1,,const unsigned char*,54,<empty>,,1496,,,1,CPPASTTypeId,,<empty>
184683593769,UNKNOWN,1,,unsigned char,37,<empty>,,2872,,,1,CPPASTTypeId,,<empty>
184683593770,UNKNOWN,1,,unsigned char,37,<empty>,,2876,,,1,CPPASTTypeId,,<empty>
184683593771,UNKNOWN,1,,unsigned char,37,<empty>,,2879,,,1,CPPASTTypeId,,<empty>
184683593772,UNKNOWN,1,,unsigned char,37,<empty>,,2882,,,1,CPPASTTypeId,,<empty>
184683593773,UNKNOWN,1,,unsigned char,37,<empty>,,2885,,,1,CPPASTTypeId,,<empty>
184683593774,UNKNOWN,1,,unsigned char,37,<empty>,,2888,,,1,CPPASTTypeId,,<empty>
184683593775,UNKNOWN,1,,unsigned char,37,<empty>,,2891,,,1,CPPASTTypeId,,<empty>
184683593776,UNKNOWN,1,,unsigned char,37,<empty>,,2894,,,1,CPPASTTypeId,,<empty>
184683593777,UNKNOWN,1,,unsigned char,37,<empty>,,2900,,,1,CPPASTTypeId,,<empty>
184683593778,UNKNOWN,1,,unsigned char,33,<empty>,,2941,,,1,CPPASTTypeId,,<empty>
184683593779,UNKNOWN,1,,char,28,<empty>,,3000,,,1,CPPASTTypeId,,<empty>
184683593780,UNKNOWN,1,,int,28,<empty>,,3004,,,1,CPPASTTypeId,,<empty>
184683593781,UNKNOWN,1,,"namespace simplecpp {
    /** C code standard */
    enum cstd_t { CUnknown=-1, C89, C99, C11, C17, C23 };

    /** C++ code standard */
    enum cppstd_t { CPPUnknown=-1, CPP03, CPP11, CPP14, CPP17, CPP20, CPP23, CPP26 };

    typedef std::string TokenString;
    class Macro;

    /**
     * Location in source code
     */
    class SIMPLECPP_LIB Location {
    public:
        explicit Location(const std::vector<std::string> &f) : files(f), fileIndex(0), line(1U), col(0U) {}

        Location(const Location &loc) : files(loc.files), fileIndex(loc.fileIndex), line(loc.line), col(loc.col) {}

        Location &operator=(const Location &other) {
            if (this != &other) {
                fileIndex = other.fileIndex;
                line = other.line;
                col  = other.col;
            }
            return *this;
        }

        /** increment this location by string */
        void adjust(const std::string &str);

        bool operator<(const Location &rhs) const {...",1,<empty>,,41,,,1,CASTProblemDeclaration,,<empty>
184683593782,UNKNOWN,1,,unsigned char,38,<empty>,,242,,,1,CPPASTTypeId,,<empty>
184683593783,UNKNOWN,1,,unsigned char,41,<empty>,,248,,,1,CPPASTTypeId,,<empty>
184683593784,UNKNOWN,1,,char*,59,<empty>,,332,,,1,CPPASTTypeId,,<empty>
184683593785,UNKNOWN,1,,const unsigned char*,48,<empty>,,409,,,1,CPPASTTypeId,,<empty>
184683593786,UNKNOWN,1,,char,35,<empty>,,452,,,1,CPPASTTypeId,,<empty>
184683593787,UNKNOWN,1,,char,35,<empty>,,457,,,1,CPPASTTypeId,,<empty>
184683593788,UNKNOWN,1,,char,35,<empty>,,462,,,1,CPPASTTypeId,,<empty>
184683593789,UNKNOWN,1,,char,35,<empty>,,467,,,1,CPPASTTypeId,,<empty>
184683593790,UNKNOWN,1,,long long,57,<empty>,,607,,,1,CPPASTTypeId,,<empty>
184683593791,UNKNOWN,1,,long long,49,<empty>,,613,,,1,CPPASTTypeId,,<empty>
184683593792,UNKNOWN,1,,int,34,<empty>,,621,,,1,CPPASTTypeId,,<empty>
184683593793,UNKNOWN,1,,int64_t,34,<empty>,,690,,,1,CPPASTTypeId,,<empty>
184683593794,UNKNOWN,1,,int64_t,34,<empty>,,697,,,1,CPPASTTypeId,,<empty>
184683593795,UNKNOWN,1,,uint64_t,19,<empty>,,708,,,1,CPPASTTypeId,,<empty>
184683593796,UNKNOWN,1,,unsigned char,40,<empty>,,1985,,,1,CPPASTTypeId,,<empty>
184683593797,UNKNOWN,1,,unsigned long long,34,<empty>,,2397,,,1,CPPASTTypeId,,<empty>
184683593798,UNKNOWN,1,,size_t,41,<empty>,,2400,,,1,CPPASTTypeId,,<empty>
184683593799,UNKNOWN,1,,unsigned long long,36,<empty>,,2403,,,1,CPPASTTypeId,,<empty>
184683593800,UNKNOWN,1,,size_t,37,<empty>,,2414,,,1,CPPASTTypeId,,<empty>
184683593801,UNKNOWN,1,,size_t,32,<empty>,,2468,,,1,CPPASTTypeId,,<empty>
184683593802,UNKNOWN,1,,char*,20,<empty>,,2570,,,1,CPPASTTypeId,,<empty>
184683593803,UNKNOWN,1,,unsigned char,53,<empty>,,2609,,,1,CPPASTTypeId,,<empty>
184683593804,UNKNOWN,1,,unsigned char,39,<empty>,,2613,,,1,CPPASTTypeId,,<empty>
184683593805,UNKNOWN,1,,unsigned char,39,<empty>,,2614,,,1,CPPASTTypeId,,<empty>
184683593806,UNKNOWN,1,,unsigned char,39,<empty>,,2615,,,1,CPPASTTypeId,,<empty>
184683593807,UNKNOWN,1,,int,48,<empty>,,2648,,,1,CPPASTTypeId,,<empty>
184683593808,UNKNOWN,1,,unsigned char,39,<empty>,,2690,,,1,CPPASTTypeId,,<empty>
184683593809,UNKNOWN,1,,int,89,<empty>,,2693,,,1,CPPASTTypeId,,<empty>
184683593810,UNKNOWN,1,,int,77,<empty>,,2721,,,1,CPPASTTypeId,,<empty>
184683593811,UNKNOWN,1,,const char*,34,<empty>,,2735,,,1,CPPASTTypeId,,<empty>
184683593812,UNKNOWN,1,,char,46,<empty>,,123,,,1,CPPASTTypeId,,<empty>
184683593813,UNKNOWN,1,,char,50,<empty>,,125,,,1,CPPASTTypeId,,<empty>
184683593814,UNKNOWN,9,,"namespace tinyxml2
{
class XMLDocument;
class XMLElement;
class XMLAttribute;
class XMLComment;
class XMLText;
class XMLDeclaration;
class XMLUnknown;
class XMLPrinter;

/*
	A class that wraps strings. Normally stores the start and end
	pointers into the XML file itself, and will apply normalization
	and entity translation if actually read. Can also store (and memory
	manage) a traditional char[]

    Isn't clear why TINYXML2_LIB is needed; but seems to fix #719
*/
class TINYXML2_LIB StrPair
{
public:
    enum Mode {
        NEEDS_ENTITY_PROCESSING			= 0x01,
        NEEDS_NEWLINE_NORMALIZATION		= 0x02,
        NEEDS_WHITESPACE_COLLAPSING     = 0x04,

        TEXT_ELEMENT		            = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,
        TEXT_ELEMENT_LEAVE_ENTITIES		= NEEDS_NEWLINE_NORMALIZATION,
        ATTRIBUTE_NAME		            = 0,
        ATTRIBUTE_VALUE		            = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,
        ATTRIBUTE_VALUE_LEAVE_ENTITIES  = NE...",1,<empty>,,114,,,9,CASTProblemDeclaration,,<empty>
184683593815,UNKNOWN,2,,"namespace Ui {
    class About;
}",1,<empty>,,27,,,2,CASTProblemDeclaration,,<empty>
184683593816,UNKNOWN,3,,"class AboutDialog : public QDialog {
    Q_OBJECT
public:
    AboutDialog(const QString &version,
                const QString &extraVersion,
                QWidget *parent = nullptr);

    ~AboutDialog() override;

private:
    Ui::About* mUI;
};",1,<empty>,,38,,,3,CASTProblemDeclaration,,<empty>
184683593817,UNKNOWN,1,,"class Application {
public:
    Application() = default;
    Application(QString name, QString path, QString params);

    /**
     * @brief Get application name.
     * @return Application name.
     */
    const QString& getName() const {
        return mName;
    }

    /**
     * @brief Get application path.
     * @return Application path.
     */
    const QString& getPath() const {
        return mPath;
    }

    /**
     * @brief Get application command line parameters.
     * @return Application command line parameters.
     */
    const QString& getParameters() const {
        return mParameters;
    }

    /**
     * @brief Set application name.
     * @param name Application name.
     */
    void setName(const QString &name) {
        mName = name;
    }

    /**
     * @brief Set application path.
     * @param path Application path.
     */
    void setPath(const QString &path) {
        mPath = path;
    }

    /**
     * @brief Set application command line paramete...",1,<empty>,,43,,,1,CASTProblemDeclaration,,<empty>
184683593818,UNKNOWN,3,,"namespace Ui {
    class ApplicationDialog;
}",1,<empty>,,28,,,3,CASTProblemDeclaration,,<empty>
184683593819,UNKNOWN,4,,"class ApplicationDialog : public QDialog {
    Q_OBJECT

public:
    /**
     * @brief Constructor.
     * @param title Title for the dialog.
     * @param app Application definition.
     * @param parent Parent widget.
     */
    ApplicationDialog(const QString &title,
                      Application &app,
                      QWidget *parent = nullptr);
    ~ApplicationDialog() override;

protected slots:

    void ok();

    /**
     * @brief Slot to browse for an application
     *
     */
    void browse();

protected:

    /**
     * @brief UI from the Qt designer
     *
     */
    Ui::ApplicationDialog* mUI;

private:

    /**
     * @brief Underlying Application
     */
    Application& mApplication;
};",1,<empty>,,41,,,4,CASTProblemDeclaration,,<empty>
184683593820,UNKNOWN,1,,"class ApplicationList : public QObject {
    Q_OBJECT
public:

    explicit ApplicationList(QObject *parent = nullptr);
    ~ApplicationList() override;

    /**
     * @brief Load all applications
     *
     * @return true if loading succeeded, false if there is problem with
     *  application list. Most probably because of older version settings need
     *  to be upgraded.
     */
    bool loadSettings();

    /**
     * @brief Save all applications
     */
    void saveSettings() const;

    /**
     * @brief Get the amount of applications in the list
     * @return The count of applications
     */
    int getApplicationCount() const;

    /**
     * @brief Get specific application's name
     *
     * @param index Index of the application whose name to get
     * @return Name of the application
     */
    const Application& getApplication(int index) const;
    Application& getApplication(int index);

    /**
     * @brief Return the default application.
     * @return Index...",1,<empty>,,35,,,1,CASTProblemDeclaration,,<empty>
184683593821,UNKNOWN,1,,"class CheckStatistics : public QObject {
public:
    explicit CheckStatistics(QObject *parent = nullptr);

    /**
     * @brief Add new checked item to statistics.
     *
     * @param tool Tool.
     * @param type Type of the item to add.
     */
    void addItem(const QString &tool, ShowTypes::ShowType type);

    /**
     * @brief Add checker to statistics
     */
    void addChecker(const QString& checker);

    /**
     * @brief Clear the statistics.
     *
     */
    void clear();

    /**
     * @brief Return statistics for given type.
     *
     * @param tool Tool.
     * @param type Type for which the statistics are returned.
     * @return Number of items of given type.
     */
    unsigned getCount(const QString &tool, ShowTypes::ShowType type) const;

    const std::set<std::string>& getActiveCheckers() const {
        return mActiveCheckers;
    }

    int getNumberOfActiveCheckers() const {
        return mActiveCheckers.size();
    }

    /** Get tools with results...",1,<empty>,,39,,,1,CASTProblemDeclaration,,<empty>
184683593822,UNKNOWN,3,,"class CheckThread : public QThread {
    Q_OBJECT
public:
    explicit CheckThread(ThreadResult &result);

    /**
     * @brief Set settings for cppcheck
     *
     * @param settings settings for cppcheck
     * @param supprs suppressions for cppcheck
     */
    void setSettings(const Settings &settings, std::shared_ptr<Suppressions> supprs);

    /**
     * @brief Run whole program analysis
     * @param files    All files
     * @param ctuInfo  Ctu info for addons
     */
    void analyseWholeProgram(const QStringList &files, const std::string& ctuInfo);

    void setAddonsAndTools(const QStringList &addonsAndTools) {
        mAddonsAndTools = addonsAndTools;
    }

    void setClangIncludePaths(const QStringList &s) {
        mClangIncludePaths = s;
    }

    void setSuppressions(const QList<SuppressionList::Suppression> &s) {
        mSuppressionsUi = s;
    }

    /**
     * @brief method that is run in a thread
     *
     */
    void run() override;

    void stop();

   ...",1,<empty>,,48,,,3,CASTProblemDeclaration,,<empty>
184683593823,UNKNOWN,1,,int,16,<empty>,,428,,,1,CPPASTTypeId,,<empty>
184683593824,UNKNOWN,1,,int,25,<empty>,,429,,,1,CPPASTTypeId,,<empty>
184683593825,UNKNOWN,1,,int,25,<empty>,,441,,,1,CPPASTTypeId,,<empty>
184683593826,UNKNOWN,5,,"class Highlighter : public QSyntaxHighlighter {
    Q_OBJECT

public:
    explicit Highlighter(QTextDocument *parent,
                         CodeEditorStyle *widgetStyle);

    void setSymbols(const QStringList &symbols);

    void setStyle(const CodeEditorStyle &newStyle);

protected:
    void highlightBlock(const QString &text) override;

private:
    enum RuleRole : std::uint8_t {
        Keyword = 1,
        Class   = 2,
        Comment = 3,
        Quote   = 4,
        Symbol  = 5
    };
    struct HighlightingRule {
        QRegularExpression pattern;
        QTextCharFormat format;
        RuleRole ruleRole;
    };

    void applyFormat(HighlightingRule &rule);

    QVector<HighlightingRule> mHighlightingRules;
    QVector<HighlightingRule> mHighlightingRulesWithSymbols;

    QRegularExpression mCommentStartExpression;
    QRegularExpression mCommentEndExpression;

    QTextCharFormat mKeywordFormat;
    QTextCharFormat mClassFormat;
    QTextCharFormat mSingleLineCommentFo...",1,<empty>,,40,,,5,CASTProblemDeclaration,,<empty>
184683593827,UNKNOWN,6,,"class CodeEditor : public QPlainTextEdit {
    Q_OBJECT

public:
    explicit CodeEditor(QWidget *parent);
    CodeEditor(const CodeEditor &) = delete;
    CodeEditor &operator=(const CodeEditor &) = delete;
    ~CodeEditor() override;

    void lineNumberAreaPaintEvent(const QPaintEvent *event);
    int lineNumberAreaWidth();
    void setStyle(const CodeEditorStyle& newStyle);

    /**
     * Set source code to show, goto error line and highlight that line.
     * \\param code         The source code.
     * \\param errorLine    line number
     * \\param symbols      the related symbols, these are marked
     */
    void setError(const QString &code, int errorLine, const QStringList &symbols);

    /**
     * Goto another error in existing source file
     * \\param errorLine    line number
     * \\param symbols      the related symbols, these are marked
     */
    void setError(int errorLine, const QStringList &symbols);

    void setFileName(const QString &fileName) {
        mFile...",1,<empty>,,86,,,6,CASTProblemDeclaration,,<empty>
184683593828,UNKNOWN,7,,"class LineNumberArea : public QWidget {
public:
    explicit LineNumberArea(CodeEditor *editor) : QWidget(editor) {
        mCodeEditor = editor;
    }

    QSize sizeHint() const override {
        return QSize(mCodeEditor->lineNumberAreaWidth(), 0);
    }

protected:
    void paintEvent(QPaintEvent *event) override {
        mCodeEditor->lineNumberAreaPaintEvent(event);
    }

private:
    CodeEditor *mCodeEditor;
};",1,<empty>,,147,,,7,CASTProblemDeclaration,,<empty>
184683593829,UNKNOWN,1,,int,40,<empty>,,138,,,1,CPPASTTypeId,,<empty>
184683593830,UNKNOWN,1,,QFont::Weight,46,<empty>,,139,,,1,CPPASTTypeId,,<empty>
184683593831,UNKNOWN,1,,int,39,<empty>,,144,,,1,CPPASTTypeId,,<empty>
184683593832,UNKNOWN,1,,QFont::Weight,44,<empty>,,145,,,1,CPPASTTypeId,,<empty>
184683593833,UNKNOWN,1,,int,39,<empty>,,150,,,1,CPPASTTypeId,,<empty>
184683593834,UNKNOWN,1,,QFont::Weight,44,<empty>,,151,,,1,CPPASTTypeId,,<empty>
184683593835,UNKNOWN,1,,int,39,<empty>,,156,,,1,CPPASTTypeId,,<empty>
184683593836,UNKNOWN,1,,QFont::Weight,46,<empty>,,157,,,1,CPPASTTypeId,,<empty>
184683593837,UNKNOWN,1,,int,39,<empty>,,165,,,1,CPPASTTypeId,,<empty>
184683593838,UNKNOWN,1,,QFont::Weight,45,<empty>,,166,,,1,CPPASTTypeId,,<empty>
184683593839,UNKNOWN,1,,int,49,<empty>,,210,,,1,CPPASTTypeId,,<empty>
184683593840,UNKNOWN,1,,int,49,<empty>,,214,,,1,CPPASTTypeId,,<empty>
184683593841,UNKNOWN,1,,int,49,<empty>,,218,,,1,CPPASTTypeId,,<empty>
184683593842,UNKNOWN,1,,int,49,<empty>,,222,,,1,CPPASTTypeId,,<empty>
184683593843,UNKNOWN,1,,int,49,<empty>,,228,,,1,CPPASTTypeId,,<empty>
184683593844,UNKNOWN,1,,"const QString SETTINGS_STYLE_GROUP(""EditorStyle"");",1,<empty>,,27,,,1,CASTProblemDeclaration,,<empty>
184683593845,UNKNOWN,2,,"const QString SETTINGS_STYLE_TYPE(""StyleType"");",1,<empty>,,28,,,2,CASTProblemDeclaration,,<empty>
184683593846,UNKNOWN,3,,"const QString SETTINGS_STYLE_TYPE_LIGHT(""DefaultLight"");",1,<empty>,,29,,,3,CASTProblemDeclaration,,<empty>
184683593847,UNKNOWN,4,,"const QString SETTINGS_STYLE_TYPE_DARK(""DefaultDark"");",1,<empty>,,30,,,4,CASTProblemDeclaration,,<empty>
184683593848,UNKNOWN,5,,"const QString SETTINGS_STYLE_TYPE_CUSTOM(""Custom"");",1,<empty>,,31,,,5,CASTProblemDeclaration,,<empty>
184683593849,UNKNOWN,6,,"const QString SETTINGS_STYLE_WIDGETFG(""StyleWidgetFG"");",1,<empty>,,32,,,6,CASTProblemDeclaration,,<empty>
184683593850,UNKNOWN,7,,"const QString SETTINGS_STYLE_WIDGETBG(""StyleWidgetBG"");",1,<empty>,,33,,,7,CASTProblemDeclaration,,<empty>
184683593851,UNKNOWN,8,,"const QString SETTINGS_STYLE_HILIFG(""StyleHighlightFG"");",1,<empty>,,34,,,8,CASTProblemDeclaration,,<empty>
184683593852,UNKNOWN,9,,"const QString SETTINGS_STYLE_LINENUMFG(""StyleLineNumFG"");",1,<empty>,,35,,,9,CASTProblemDeclaration,,<empty>
184683593853,UNKNOWN,10,,"const QString SETTINGS_STYLE_LINENUMBG(""StyleLineNumBG"");",1,<empty>,,36,,,10,CASTProblemDeclaration,,<empty>
184683593854,UNKNOWN,11,,"const QString SETTINGS_STYLE_KEYWORDFG(""StyleKeywordFG"");",1,<empty>,,37,,,11,CASTProblemDeclaration,,<empty>
184683593855,UNKNOWN,12,,"const QString SETTINGS_STYLE_KEYWORDWT(""StyleKeywordWeight"");",1,<empty>,,38,,,12,CASTProblemDeclaration,,<empty>
184683593856,UNKNOWN,13,,"const QString SETTINGS_STYLE_CLASSFG(""StyleClassFG"");",1,<empty>,,39,,,13,CASTProblemDeclaration,,<empty>
184683593857,UNKNOWN,14,,"const QString SETTINGS_STYLE_CLASSWT(""StyleClassWeight"");",1,<empty>,,40,,,14,CASTProblemDeclaration,,<empty>
184683593858,UNKNOWN,15,,"const QString SETTINGS_STYLE_QUOTEFG(""StyleQuoteFG"");",1,<empty>,,41,,,15,CASTProblemDeclaration,,<empty>
184683593859,UNKNOWN,16,,"const QString SETTINGS_STYLE_QUOTEWT(""StyleQuoteWeight"");",1,<empty>,,42,,,16,CASTProblemDeclaration,,<empty>
184683593860,UNKNOWN,17,,"const QString SETTINGS_STYLE_COMMENTFG(""StyleCommentFG"");",1,<empty>,,43,,,17,CASTProblemDeclaration,,<empty>
184683593861,UNKNOWN,18,,"const QString SETTINGS_STYLE_COMMENTWT(""StyleCommentWeight"");",1,<empty>,,44,,,18,CASTProblemDeclaration,,<empty>
184683593862,UNKNOWN,19,,"const QString SETTINGS_STYLE_SYMBOLFG(""StyleSymbolFG"");",1,<empty>,,45,,,19,CASTProblemDeclaration,,<empty>
184683593863,UNKNOWN,20,,"const QString SETTINGS_STYLE_SYMBOLBG(""StyleSymbolBG"");",1,<empty>,,46,,,20,CASTProblemDeclaration,,<empty>
184683593864,UNKNOWN,21,,"const QString SETTINGS_STYLE_SYMBOLWT(""StyleSymbolWeight"");",1,<empty>,,47,,,21,CASTProblemDeclaration,,<empty>
184683593865,UNKNOWN,23,,"class CodeEditorStyle {
public:
    explicit CodeEditorStyle(
        // cppcheck-suppress naming-varname - TODO: fix this
        QColor CtrlFGColor, QColor CtrlBGColor,
        // cppcheck-suppress naming-varname - TODO: fix this
        QColor HiLiBGColor,
        // cppcheck-suppress naming-varname - TODO: fix this
        QColor LnNumFGColor, QColor LnNumBGColor,
        // cppcheck-suppress naming-varname - TODO: fix this
        QColor KeyWdFGColor, QFont::Weight KeyWdWeight,
        // cppcheck-suppress naming-varname - TODO: fix this
        QColor ClsFGColor, QFont::Weight ClsWeight,
        // cppcheck-suppress naming-varname - TODO: fix this
        QColor QteFGColor, QFont::Weight QteWeight,
        // cppcheck-suppress naming-varname - TODO: fix this
        QColor CmtFGColor, QFont::Weight CmtWeight,
        // cppcheck-suppress naming-varname - TODO: fix this
        QColor SymbFGColor, QColor SymbBGColor,
        // cppcheck-suppress naming-varname - TODO: fix this
...",1,<empty>,,51,,,23,CASTProblemDeclaration,,<empty>
184683593866,UNKNOWN,24,,"static const CodeEditorStyle defaultStyleLight(
    /* editor FG/BG */ Qt::black, QColor(240, 240, 240),
    /* highlight BG */ QColor(255, 220, 220),
    /* line number FG/BG */ Qt::black, QColor(240, 240, 240),
    /* keyword FG/Weight */ Qt::darkBlue, QFont::Bold,
    /* class FG/Weight */ Qt::darkMagenta, QFont::Bold,
    /* quote FG/Weight */ Qt::darkGreen, QFont::Normal,
    /* comment FG/Weight */ Qt::gray, QFont::Normal,
    /* Symbol FG/BG/Weight */ Qt::red, QColor(220, 220, 255), QFont::Normal
    );",1,<empty>,,104,,,24,CASTProblemDeclaration,,<empty>
184683593867,UNKNOWN,25,,"static const CodeEditorStyle defaultStyleDark(
    /* editor FG/BG */ QColor(218, 218, 218), QColor(16, 16, 32),
    /* highlight BG */ QColor(64, 64, 64),
    /* line number FG/BG */ QColor(43, 145, 175), QColor(16, 16, 32),
    /* keyword FG/Weight */ QColor(0, 204, 204), QFont::Bold,
    /* class FG/Weight */ QColor(218, 0, 218), QFont::Bold,
    /* quote FG/Weight */ QColor(0, 204, 0), QFont::Normal,
    /* comment FG/Weight */ QColor(180, 180, 180), QFont::Normal,
    /* Symbol FG/BG/Weight */ QColor(218, 32, 32), QColor(32, 32, 108), QFont::Normal
    );",1,<empty>,,117,,,25,CASTProblemDeclaration,,<empty>
184683593868,UNKNOWN,1,,int,34,<empty>,,77,,,1,CPPASTTypeId,,<empty>
184683593869,UNKNOWN,1,,int,34,<empty>,,79,,,1,CPPASTTypeId,,<empty>
184683593870,UNKNOWN,1,,int,34,<empty>,,81,,,1,CPPASTTypeId,,<empty>
184683593871,UNKNOWN,1,,int,34,<empty>,,83,,,1,CPPASTTypeId,,<empty>
184683593872,UNKNOWN,1,,int,34,<empty>,,85,,,1,CPPASTTypeId,,<empty>
184683593873,UNKNOWN,1,,int,34,<empty>,,87,,,1,CPPASTTypeId,,<empty>
184683593874,UNKNOWN,1,,int,34,<empty>,,89,,,1,CPPASTTypeId,,<empty>
184683593875,UNKNOWN,1,,int,34,<empty>,,91,,,1,CPPASTTypeId,,<empty>
184683593876,UNKNOWN,1,,int,34,<empty>,,93,,,1,CPPASTTypeId,,<empty>
184683593877,UNKNOWN,1,,int,55,<empty>,,101,,,1,CPPASTTypeId,,<empty>
184683593878,UNKNOWN,1,,int,46,<empty>,,106,,,1,CPPASTTypeId,,<empty>
184683593879,UNKNOWN,1,,QFont::Weight,31,<empty>,,113,,,1,CPPASTTypeId,,<empty>
184683593880,UNKNOWN,2,,"class SelectColorButton : public QPushButton {
    Q_OBJECT
public:
    explicit SelectColorButton(QWidget* parent);

    void setColor(const QColor& color);
    const QColor& getColor() const;

signals:
    // NOLINTNEXTLINE(readability-inconsistent-declaration-parameter-name) - caused by generated MOC code
    void colorChanged(const QColor& newColor);

public slots:
    void updateColor();
    void changeColor();

private:
    QColor mColor;
};",1,<empty>,,33,,,2,CASTProblemDeclaration,,<empty>
184683593881,UNKNOWN,3,,"class SelectFontWeightCombo : public QComboBox {
    Q_OBJECT
public:
    explicit SelectFontWeightCombo(QWidget* parent);

    void setWeight(QFont::Weight weight);
    const QFont::Weight& getWeight() const;

signals:
    // NOLINTNEXTLINE(readability-inconsistent-declaration-parameter-name) - caused by generated MOC code
    void weightChanged(QFont::Weight newWeight);

public slots:
    void updateWeight();
    void changeWeight(int index);

private:
    QFont::Weight mWeight = QFont::Normal;
};",1,<empty>,,54,,,3,CASTProblemDeclaration,,<empty>
184683593882,UNKNOWN,8,,"class StyleEditDialog : public QDialog {
    Q_OBJECT
public:
    explicit StyleEditDialog(const CodeEditorStyle& newStyle,
                             QWidget *parent = nullptr);

    CodeEditorStyle getStyle() const;

private:
    void updateControls();
    void updateStyle();

public slots:
    void resetStyle();
    void setStyleDefaultLight();
    void setStyleDefaultDark();
    void colorChangedWidgetFG(const QColor& newColor);
    void colorChangedWidgetBG(const QColor& newColor);
    void colorChangedHighlightBG(const QColor& newColor);
    void colorChangedLineNumFG(const QColor& newColor);
    void colorChangedLineNumBG(const QColor& newColor);
    void colorChangedKeywordFG(const QColor& newColor);
    void weightChangedKeyword(QFont::Weight newWeight);
    void colorChangedClassFG(const QColor& newColor);
    void weightChangedClass(QFont::Weight newWeight);
    void colorChangedQuoteFG(const QColor& newColor);
    void weightChangedQuote(QFont::Weight newWeight);
    v...",1,<empty>,,40,,,8,CASTProblemDeclaration,,<empty>
184683593883,UNKNOWN,1,,QString getPath(const QString &type);,1,<empty>,,116,,,1,CASTProblemDeclaration,,<empty>
184683593884,UNKNOWN,2,,"void setPath(const QString &type, const QString &value);",1,<empty>,,124,,,2,CASTProblemDeclaration,,<empty>
184683593885,UNKNOWN,3,,"QString toFilterString(const QMap<QString,QString>& filters, bool addAllSupported=true, bool addAll=true);",1,<empty>,,150,,,3,CASTProblemDeclaration,,<empty>
184683593886,UNKNOWN,1,,unsigned char,49,<empty>,,200,,,1,CPPASTTypeId,,<empty>
184683593887,UNKNOWN,1,,"namespace Ui {
    class ComplianceReportDialog;
}",1,<empty>,,26,,,1,CASTProblemDeclaration,,<empty>
184683593888,UNKNOWN,4,,"class ComplianceReportDialog final : public QDialog
{
    Q_OBJECT

public:
    explicit ComplianceReportDialog(ProjectFile* projectFile, QString resultsFile, QString checkersReport);
    ~ComplianceReportDialog() final;

private slots:
    void buttonClicked(QAbstractButton* button);

private:
    void save();

    Ui::ComplianceReportDialog *mUI;
    ProjectFile* mProjectFile;
    const QString mResultsFile;
    const QString mCheckersReport;
};",1,<empty>,,33,,,4,CASTProblemDeclaration,,<empty>
184683593889,UNKNOWN,2,,"class CppcheckLibraryData {
public:
    CppcheckLibraryData() = default;

    struct Container {
        QString id;
        QString inherits;
        QString startPattern;
        QString endPattern;
        QString opLessAllowed;
        QString itEndPattern;

        bool access_arrayLike{};
        int size_templateParameter = -1;

        struct {
            QString templateParameter;
            QString string;
        } type;

        struct RangeItemRecordType {
            QString name;
            QString templateParameter;
        };

        struct Function {
            QString name;
            QString yields;
            QString action;
        };
        QList<Function> accessFunctions;
        QList<Function> otherFunctions;
        QList<Function> sizeFunctions;
        QList<RangeItemRecordType> rangeItemRecordTypeList;
    };

    struct Define {
        QString name;
        QString value;
    };

    struct Function {
        QString comments;
        QString ...",1,<empty>,,34,,,2,CASTProblemDeclaration,,<empty>
184683593890,UNKNOWN,1,,"class CsvReport : public Report {
public:
    explicit CsvReport(const QString &filename);

    /**
     * @brief Create the report (file).
     * @return true if succeeded, false if file could not be created.
     */
    bool create() override;

    /**
     * @brief Write report header.
     */
    void writeHeader() override;

    /**
     * @brief Write report footer.
     */
    void writeFooter() override;

    /**
     * @brief Write error to report.
     * @param error Error data.
     */
    void writeError(const ErrorItem &error) override;

private:

    /**
     * @brief Text stream writer for writing the report in text format.
     */
    QTextStream mTxtWriter;
};",1,<empty>,,37,,,1,CASTProblemDeclaration,,<empty>
184683593891,UNKNOWN,1,,"class GuiSeverity {
public:
    static QString toString(Severity severity) {
        return QString::fromStdString(severityToString(severity));
    }

    static Severity fromString(const QString &severity) {
        return severityFromString(severity.toStdString());
    }
};",1,<empty>,,38,,,1,CASTProblemDeclaration,,<empty>
184683593892,UNKNOWN,2,,"class QErrorPathItem {
public:
    QErrorPathItem() : line(0), column(-1) {}
    explicit QErrorPathItem(const ErrorMessage::FileLocation &loc);
    QString file;
    int line;
    int column;
    QString info;
};",1,<empty>,,52,,,2,CASTProblemDeclaration,,<empty>
184683593893,UNKNOWN,3,,"bool operator==(const QErrorPathItem &i1, const QErrorPathItem &i2);",1,<empty>,,62,,,3,CASTProblemDeclaration,,<empty>
184683593894,UNKNOWN,4,,"class ErrorItem {
public:
    ErrorItem();
    explicit ErrorItem(const ErrorMessage &errmsg);

    /**
     * @brief Convert error item to string.
     * @return Error item as string.
     */
    QString toString() const;
    QString tool() const;

    QString file0;
    QString errorId;
    Severity severity;
    bool inconclusive;
    QString summary;
    QString message;
    int cwe;
    unsigned long long hash;
    QList<QErrorPathItem> errorPath;
    QString symbolNames;
    QString remark;
    QString classification; // misra/cert/etc: classification/level
    QString guideline; // misra/cert/etc: guideline/rule

    // Special GUI properties
    QString sinceDate;
    QString tags;

    /**
     * Compare ""CID""
     */
    static bool sameCID(const ErrorItem &errorItem1, const ErrorItem &errorItem2);
};",1,<empty>,,72,,,4,CASTProblemDeclaration,,<empty>
184683593895,UNKNOWN,5,,),29,<empty>,,109,,,5,CASTProblemDeclaration,,<empty>
184683593896,UNKNOWN,6,,"class ErrorLine {
public:
    QString file;
    int line;
    QString file0;
    QString errorId;
    int cwe;
    unsigned long long hash;
    bool inconclusive;
    Severity severity;
    QString summary;
    QString message;
    QString sinceDate;
    QString tags;
    QString remark;
};",1,<empty>,,114,,,6,CASTProblemDeclaration,,<empty>
184683593897,UNKNOWN,1,,"class FileList {
public:

    /**
     * @brief Add filename to the list.
     * @param filepath Full path to the file.
     */
    void addFile(const QString &filepath);

    /**
     * @brief Add files in the directory to the list.
     * @param directory Full pathname to directory to add.
     * @param recursive If true also files in subdirectories are added.
     */
    void addDirectory(const QString &directory, bool recursive = false);

    /**
     * @brief Add list of filenames and directories to the list.
     * @param paths List of paths to add.
     */
    void addPathList(const QStringList &paths);

    /**
     * @brief Return list of filenames (to check).
     * @return list of filenames to check.
     */
    QStringList getFileList() const;

    /**
     * @brief Add list of paths to exclusion list.
     * @param paths Paths to exclude.
     */
    void addExcludeList(const QStringList &paths);

    /**
     * @brief Return list of default filename extensions included...",1,<empty>,,39,,,1,CASTProblemDeclaration,,<empty>
184683593898,UNKNOWN,3,,"namespace Ui {
    class Fileview;
}",1,<empty>,,28,,,3,CASTProblemDeclaration,,<empty>
184683593899,UNKNOWN,4,,"class FileViewDialog : public QDialog {
    Q_OBJECT
public:
    FileViewDialog(const QString &file,
                   const QString &title,
                   QWidget *parent = nullptr);

    ~FileViewDialog() override;

protected:

    /**
     * @brief Load text file contents to edit control.
     *
     * @param filename File to load.
     * @param edit Control where to load the file contents.
     */
    void loadTextFile(const QString &filename, QTextEdit *edit);

    Ui::Fileview* mUI;
};",1,<empty>,,42,,,4,CASTProblemDeclaration,,<empty>
184683593900,UNKNOWN,3,,"namespace Ui {
    class HelpDialog;
}",1,<empty>,,29,,,3,CASTProblemDeclaration,,<empty>
184683593901,UNKNOWN,4,,"class HelpBrowser : public QTextBrowser {
public:
    explicit HelpBrowser(QWidget* parent = nullptr) : QTextBrowser(parent) {}
    HelpBrowser(const HelpBrowser&) = delete;
    HelpBrowser(HelpBrowser&&) = delete;
    HelpBrowser& operator=(const HelpBrowser&) = delete;
    HelpBrowser& operator=(HelpBrowser&&) = delete;
    void setHelpEngine(QHelpEngine *helpEngine);
    QVariant loadResource(int type, const QUrl& name) override;
private:
    QHelpEngine* mHelpEngine{};
};",1,<empty>,,33,,,4,CASTProblemDeclaration,,<empty>
184683593902,UNKNOWN,5,,"class HelpDialog : public QDialog {
    Q_OBJECT

public:
    explicit HelpDialog(QWidget *parent = nullptr);
    ~HelpDialog() override;

private:
    Ui::HelpDialog *mUi;
    QHelpEngine* mHelpEngine;
};",1,<empty>,,46,,,5,CASTProblemDeclaration,,<empty>
184683593903,UNKNOWN,2,,"namespace Ui {
    class LibraryAddFunctionDialog;
}",1,<empty>,,27,,,2,CASTProblemDeclaration,,<empty>
184683593904,UNKNOWN,3,,"class LibraryAddFunctionDialog : public QDialog {
    Q_OBJECT

public:
    explicit LibraryAddFunctionDialog(QWidget *parent = nullptr);
    LibraryAddFunctionDialog(const LibraryAddFunctionDialog &) = delete;
    ~LibraryAddFunctionDialog() override;
    LibraryAddFunctionDialog &operator=(const LibraryAddFunctionDialog &) = delete;

    QString functionName() const;
    int     numberOfArguments() const;

private:
    Ui::LibraryAddFunctionDialog *mUi;
};",1,<empty>,,35,,,3,CASTProblemDeclaration,,<empty>
184683593905,UNKNOWN,1,,FunctionListItem *,25,<empty>,,90,,,1,CPPASTTypeId,,<empty>
184683593906,UNKNOWN,1,,FunctionListItem*,67,<empty>,,214,,,1,CPPASTTypeId,,<empty>
184683593907,UNKNOWN,1,,CppcheckLibraryData::Function::TrueFalseUnknown,29,<empty>,,316,,,1,CPPASTTypeId,,<empty>
184683593908,UNKNOWN,3,,"namespace Ui {
    class LibraryDialog;
}",1,<empty>,,30,,,3,CASTProblemDeclaration,,<empty>
184683593909,UNKNOWN,4,,"class LibraryDialog : public QDialog {
    Q_OBJECT

public:
    explicit LibraryDialog(QWidget *parent = nullptr);
    LibraryDialog(const LibraryDialog &) = delete;
    ~LibraryDialog() override;
    LibraryDialog &operator=(const LibraryDialog &) = delete;

private slots:
    void openCfg();
    void saveCfg();
    void saveCfgAs();
    void addFunction();
    void changeFunction();
    void editArg();
    void editFunctionName(QListWidgetItem* /*item*/);
    void filterFunctions(const QString& /*filter*/);
    void selectFunction();
    void sortFunctions(bool /*sort*/);

private:
    Ui::LibraryDialog *mUi;
    CppcheckLibraryData mData;
    QString mFileName;
    bool mIgnoreChanges{};

    static QString getArgText(const CppcheckLibraryData::Function::Arg &arg);
    CppcheckLibraryData::Function *currentFunction();
    void updateArguments(const CppcheckLibraryData::Function &function);
};",1,<empty>,,34,,,4,CASTProblemDeclaration,,<empty>
184683593910,UNKNOWN,2,,"namespace Ui {
    class LibraryEditArgDialog;
}",1,<empty>,,29,,,2,CASTProblemDeclaration,,<empty>
184683593911,UNKNOWN,3,,"class LibraryEditArgDialog : public QDialog {
    Q_OBJECT

public:
    LibraryEditArgDialog(QWidget *parent, const CppcheckLibraryData::Function::Arg &arg);
    LibraryEditArgDialog(const LibraryEditArgDialog &) = delete;
    ~LibraryEditArgDialog() override;
    LibraryEditArgDialog &operator=(const LibraryEditArgDialog &) = delete;

    CppcheckLibraryData::Function::Arg getArg() const;

private slots:
    void minsizeChanged();

private:
    Ui::LibraryEditArgDialog *mUi;

    QList<CppcheckLibraryData::Function::Arg::MinSize> mMinSizes;
};",1,<empty>,,33,,,3,CASTProblemDeclaration,,<empty>
184683593912,UNKNOWN,1,,Platform::Type,46,<empty>,,312,,,1,CPPASTTypeId,,<empty>
184683593913,UNKNOWN,1,,ReportType,36,<empty>,,388,,,1,CPPASTTypeId,,<empty>
184683593914,UNKNOWN,1,,int,87,<empty>,,388,,,1,CPPASTTypeId,,<empty>
184683593915,UNKNOWN,1,,Standards::Language,51,<empty>,,436,,,1,CPPASTTypeId,,<empty>
184683593916,UNKNOWN,1,,int,48,<empty>,,486,,,1,CPPASTTypeId,,<empty>
184683593917,UNKNOWN,1,,Platform::Type,46,<empty>,,562,,,1,CPPASTTypeId,,<empty>
184683593918,UNKNOWN,1,,Platform::Type,33,<empty>,,1128,,,1,CPPASTTypeId,,<empty>
184683593919,UNKNOWN,1,,Platform::Type,32,<empty>,,1208,,,1,CPPASTTypeId,,<empty>
184683593920,UNKNOWN,1,,Standards::Language,30,<empty>,,1211,,,1,CPPASTTypeId,,<empty>
184683593921,UNKNOWN,1,,int,58,<empty>,,2136,,,1,CPPASTTypeId,,<empty>
184683593922,UNKNOWN,1,,Platform::Type,42,<empty>,,2175,,,1,CPPASTTypeId,,<empty>
184683593923,UNKNOWN,16,,"namespace Ui {
    class MainWindow;
}",1,<empty>,,48,,,16,CASTProblemDeclaration,,<empty>
184683593924,UNKNOWN,17,,"class MainWindow : public QMainWindow {
    Q_OBJECT
public:

    /**
     * @brief Maximum number of MRU project items in File-menu.
     */
    enum : std::uint8_t { MaxRecentProjects = 5 };

    MainWindow(TranslationHandler* th, QSettings* settings);
    MainWindow(const MainWindow &) = delete;
    ~MainWindow() override;
    MainWindow &operator=(const MainWindow &) = delete;

    /**
     * List of checked platforms.
     */
    Platforms mPlatforms;

    /**
     * @brief Analyze given code
     *
     * @param code Content of the (virtual) file to be analyzed
     * @param filename Name of the (virtual) file to be analyzed - determines language.
     */
    void analyzeCode(const QString& code, const QString& filename);

public slots:
    /** @brief Slot for analyze files menu item */
    void analyzeFiles();

    /** @brief Slot to reanalyze all files */
    void reAnalyzeAll();

    /** @brief Slot to reanalyze with checking library configuration */
    void checkLibrary()...",1,<empty>,,59,,,17,CASTProblemDeclaration,,<empty>
184683593925,UNKNOWN,2,,"namespace Ui {
    class NewSuppressionDialog;
}",1,<empty>,,28,,,2,CASTProblemDeclaration,,<empty>
184683593926,UNKNOWN,3,,"class NewSuppressionDialog : public QDialog {
    Q_OBJECT

public:
    explicit NewSuppressionDialog(QWidget *parent = nullptr);
    NewSuppressionDialog(const NewSuppressionDialog &) = delete;
    ~NewSuppressionDialog() override;
    NewSuppressionDialog &operator=(const NewSuppressionDialog &) = delete;

    /**
     * @brief Translate the user input in the GUI into a suppression
     * @return Cppcheck suppression
     */
    SuppressionList::Suppression getSuppression() const;

    /**
     * @brief Update the GUI so it corresponds with the given
     * Cppcheck suppression
     * @param suppression Cppcheck suppression
     */
    void setSuppression(const SuppressionList::Suppression &suppression);

private:
    Ui::NewSuppressionDialog *mUI;
};",1,<empty>,,32,,,3,CASTProblemDeclaration,,<empty>
184683593927,UNKNOWN,-1,,Platform::Type mType;,5,<empty>,,38,,,2,CASTProblemDeclaration,,<empty>
184683593928,UNKNOWN,3,,"class Platforms : public QObject {
    Q_OBJECT

public:
    explicit Platforms(QObject *parent = nullptr);
    void add(const QString &title, Platform::Type platform);
    int getCount() const;
    void init();
    PlatformData& get(Platform::Type platform);

    QList<PlatformData> mPlatforms;
};",1,<empty>,,45,,,3,CASTProblemDeclaration,,<empty>
184683593929,UNKNOWN,1,,"class PrintableReport : public Report {
public:
    PrintableReport();

    /**
     * @brief Create the report (file).
     * @return true if succeeded, false if file could not be created.
     */
    bool create() override;

    /**
     * @brief Write report header.
     */
    void writeHeader() override;

    /**
     * @brief Write report footer.
     */
    void writeFooter() override;

    /**
     * @brief Write error to report.
     * @param error Error data.
     */
    void writeError(const ErrorItem &error) override;

    /**
     * @brief Returns the formatted report.
     */
    const QString& getFormattedReportText() const;

private:

    /**
     * @brief Stores the formatted report contents.
     */
    QString mFormattedReport;
};",1,<empty>,,34,,,1,CASTProblemDeclaration,,<empty>
184683593930,UNKNOWN,3,,"class ProjectFile : public QObject {
    Q_OBJECT

public:
    explicit ProjectFile(QObject *parent = nullptr);
    explicit ProjectFile(QString filename, QObject *parent = nullptr);
    ~ProjectFile() override {
        if (this == mActiveProject) mActiveProject = nullptr;
    }

    enum class CheckLevel : std::uint8_t {
        reduced,
        normal,
        exhaustive
    };

    static ProjectFile* getActiveProject() {
        return mActiveProject;
    }
    void setActiveProject() {
        mActiveProject = this;
    }

    /**
     * @brief Read the project file.
     * @param filename Filename (can be also given to constructor).
     */
    bool read(const QString &filename = QString());

    /**
     * @brief Get project root path.
     * @return project root path.
     */
    const QString& getRootPath() const {
        return mRootPath;
    }

    const QString& getBuildDir() const {
        return mBuildDir;
    }

    const QString& getImportProject() const {
       ...",1,<empty>,,47,,,3,CASTProblemDeclaration,,<empty>
184683593931,UNKNOWN,1,,int,58,<empty>,,951,,,1,CPPASTTypeId,,<empty>
184683593932,UNKNOWN,3,,"namespace Ui {
    class ProjectFile;
}",1,<empty>,,32,,,3,CASTProblemDeclaration,,<empty>
184683593933,UNKNOWN,5,,"class ProjectFileDialog : public QDialog {
    Q_OBJECT
public:
    explicit ProjectFileDialog(ProjectFile *projectFile, bool premium, QWidget *parent = nullptr);
    ~ProjectFileDialog() override;

private:
    void loadFromProjectFile(const ProjectFile *projectFile);
    void saveToProjectFile(ProjectFile *projectFile) const;

    /** Enable and disable widgets in the 'Paths and Defines' tab */
    void updatePathsAndDefines();

    /**
     * @brief Return project root path from the dialog control.
     * @return Project root path.
     */
    QString getRootPath() const;

    QStringList getProjectConfigurations() const;
    void setProjectConfigurations(const QStringList &configs);

    QString getImportProject() const;

    /** Get Cppcheck build dir */
    QString getBuildDir() const;

    /**
     * @brief Return include paths from the dialog control.
     * @return List of include paths.
     */
    QStringList getIncludePaths() const;

    /**
     * @brief Return define n...",1,<empty>,,45,,,5,CASTProblemDeclaration,,<empty>
184683593934,UNKNOWN,2,,"class Report : public QObject {
public:
    enum Type : std::uint8_t {
        TXT,
        XMLV2,
        CSV,
    };

    explicit Report(QString filename);
    ~Report() override;

    /**
     * @brief Create the report (file).
     * @return true if succeeded, false if file could not be created.
     */
    virtual bool create();

    /**
     * @brief Open the existing report (file).
     * @return true if succeeded, false if file could not be created.
     */
    virtual bool open();

    /**
     * @brief Close the report (file).
     */
    void close();

    /**
     * @brief Write report header.
     */
    virtual void writeHeader() = 0;

    /**
     * @brief Write report footer.
     */
    virtual void writeFooter() = 0;

    /**
     * @brief Write error to report.
     * @param error Error data.
     */
    virtual void writeError(const ErrorItem &error) = 0;

protected:

    /**
     * @brief Get the file object where the report is written to.
     */
    QFile* ge...",1,<empty>,,36,,,2,CASTProblemDeclaration,,<empty>
184683593935,UNKNOWN,1,,ShowTypes::ShowType,90,<empty>,,1009,,,1,CPPASTTypeId,,<empty>
184683593936,UNKNOWN,1,,int,49,<empty>,,1296,,,1,CPPASTTypeId,,<empty>
184683593937,UNKNOWN,10,,enum class Severity : std::uint8_t;,1,<empty>,,45,,,10,CASTProblemDeclaration,,<empty>
184683593938,UNKNOWN,11,,"class ResultsTree : public QTreeView {
    Q_OBJECT
public:
    explicit ResultsTree(QWidget * parent = nullptr);

    void initialize(QSettings *settings, ApplicationList *list, ThreadHandler *checkThreadHandler);

    /**
     * @brief Add a new item to the tree
     *
     * @param item Error item data
     */
    bool addErrorItem(const ErrorItem &item);

    /**
     * @brief Clear all errors from the tree
     *
     */
    void clear();

    /**
     * @brief Clear errors for a specific file from the tree
     */
    void clear(const QString &filename);

    /**
     * @brief Clear errors of a file selected for recheck
     */
    void clearRecheckFile(const QString &filename);

    /**
     * @brief Function to filter the displayed list of errors.
     * Refreshes the tree.
     *
     * @param filter String that must be found in the summary, description, file or id
     */
    void filterResults(const QString& filter);

    /**
     * @brief Function to show results that we...",1,<empty>,,55,,,11,CASTProblemDeclaration,,<empty>
184683593939,UNKNOWN,10,,enum class ReportType : std::uint8_t;,1,<empty>,,40,,,10,CASTProblemDeclaration,,<empty>
184683593940,UNKNOWN,11,,"namespace Ui {
    class ResultsView;
}",1,<empty>,,41,,,11,CASTProblemDeclaration,,<empty>
184683593941,UNKNOWN,12,,"class ResultsView : public QWidget {
    Q_OBJECT
public:

    explicit ResultsView(QWidget * parent = nullptr);
    void initialize(QSettings *settings, ApplicationList *list, ThreadHandler *checkThreadHandler);
    ResultsView(const ResultsView &) = delete;
    ~ResultsView() override;
    ResultsView &operator=(const ResultsView &) = delete;

    /**
     * @brief Clear results and statistics and reset progressinfo.
     * @param results Remove all the results from view?
     */
    void clear(bool results);

    /**
     * @brief Remove a file from the results.
     */
    void clear(const QString &filename);

    /**
     * @brief Remove a recheck file from the results.
     */
    void clearRecheckFile(const QString &filename);

    /**
     * @brief Write statistics in file
     *
     * @param filename Filename to save statistics to
     */
    void saveStatistics(const QString &filename) const;

    /**
     * @brief Save results to a file
     *
     * @param filename File...",1,<empty>,,52,,,12,CASTProblemDeclaration,,<empty>
184683593942,UNKNOWN,2,,"namespace Ui {
    class ScratchPad;
}",1,<empty>,,26,,,2,CASTProblemDeclaration,,<empty>
184683593943,UNKNOWN,3,,"class ScratchPad : public QDialog {
    Q_OBJECT
public:
    explicit ScratchPad(MainWindow& mainWindow);
    ~ScratchPad() override;

    /**
     * @brief Translate dialog
     */
    void translate();

private slots:
    /**
     * @brief Called when check button is clicked.
     */
    void checkButtonClicked();

private:
    Ui::ScratchPad *mUI;
    MainWindow& mMainWindow;
};",1,<empty>,,36,,,3,CASTProblemDeclaration,,<empty>
184683593944,UNKNOWN,7,,"namespace Ui {
    class Settings;
}",1,<empty>,,34,,,7,CASTProblemDeclaration,,<empty>
184683593945,UNKNOWN,8,,"class SettingsDialog : public QDialog {
    Q_OBJECT
public:
    SettingsDialog(ApplicationList *list,
                   TranslationHandler *translator,
                   bool premium,
                   QWidget *parent = nullptr);
    SettingsDialog(const SettingsDialog &) = delete;
    ~SettingsDialog() override;
    SettingsDialog &operator=(const SettingsDialog &) = delete;

    /**
     * @brief Save all values to QSettings
     *
     */
    void saveSettingValues() const;

    /**
     * @brief Get checkbox value for mShowFullPath
     *
     * @return should full path of errors be shown in the tree
     */
    bool showFullPath() const;

    /**
     * @brief Get checkbox value for mSaveFullPath
     *
     * @return should full path of files be saved when creating a report
     */
    bool saveFullPath() const;


    /**
     * @brief Get checkbox value for mNoErrorsMessage
     *
     * @return Should ""no errors message"" be hidden
     */
    bool showNoErrorsMessage() c...",1,<empty>,,45,,,8,CASTProblemDeclaration,,<empty>
184683593946,UNKNOWN,1,,ShowTypes::ShowType,13,<empty>,,92,,,1,CPPASTTypeId,,<empty>
184683593947,UNKNOWN,1,,enum class Severity : std::uint8_t;,1,<empty>,,26,,,1,CASTProblemDeclaration,,<empty>
184683593948,UNKNOWN,2,,"class ShowTypes {
public:

    /**
     * @brief Show types we have (i.e. severities in the GUI).
     */
    enum ShowType : std::uint8_t {
        ShowStyle = 0,
        ShowWarnings,
        ShowPerformance,
        ShowPortability,
        ShowInformation,
        ShowErrors, // Keep this as last real item
        ShowNone
    };

    /**
     * @brief Constructor.
     * @note Loads visibility settings.
     */
    ShowTypes();

    /**
     * @brief Destructor.
     * @note Saves visibility settings.
     */
    ~ShowTypes();

    /**
     * @brief Load visibility settings from the platform's settings storage.
     */
    void load();

    /**
     * @brief Save visibility settings to the platform's settings storage.
     */
    void save() const;

    /**
     * @brief Is the showtype visible in the GUI?
     * @param category Showtype to check.
     * @return true if the showtype is visible.
     */
    bool isShown(ShowTypes::ShowType category) const;

    /**
     * @brief...",1,<empty>,,40,,,2,CASTProblemDeclaration,,<empty>
184683593949,UNKNOWN,1,,int,28,<empty>,,152,,,1,CPPASTTypeId,,<empty>
184683593950,UNKNOWN,1,,QWidget*,54,<empty>,,202,,,1,CPPASTTypeId,,<empty>
184683593951,UNKNOWN,1,,"QT_CHARTS_USE_NAMESPACE
",1,<empty>,,67,,,1,CPPASTProblemDeclaration,,<empty>
184683593952,UNKNOWN,4,,"namespace Ui {
    class StatsDialog;
}",1,<empty>,,29,,,4,CASTProblemDeclaration,,<empty>
184683593953,UNKNOWN,5,,"class StatsDialog : public QDialog {
    Q_OBJECT
public:
    explicit StatsDialog(QWidget *parent = nullptr);
    ~StatsDialog() override;

    /**
     * @brief Sets the project to extract statistics from
     */
    void setProject(const ProjectFile *projectFile);

    /**
     * @brief Sets the string to display beside ""Path Selected:""
     */
    void setPathSelected(const QString& path);

    /**
     * @brief Sets the number to display beside ""Number of Files Scanned:""
     */
    void setNumberOfFilesScanned(int num);

    /**
     * @brief Sets the number of seconds to display beside ""Scan Duration:""
     */
    void setScanDuration(double seconds);

    /**
     * @brief Sets the numbers of different error/warnings found.""
     */
    void setStatistics(const CheckStatistics *stats);

private slots:
    void copyToClipboard();
    void pdfExport();
private:
    Ui::StatsDialog *mUI;
    const CheckStatistics* mStatistics{};
};",1,<empty>,,40,,,5,CASTProblemDeclaration,,<empty>
184683593954,UNKNOWN,7,,"class ThreadHandler : public QObject {
    Q_OBJECT
public:
    explicit ThreadHandler(QObject *parent = nullptr);
    ~ThreadHandler() override;

    /**
     * @brief Set the number of threads to use
     * @param count The number of threads to use
     */
    void setThreadCount(int count);

    /**
     * @brief Initialize the threads (connect all signals to resultsview's slots)
     *
     * @param view View to show error results
     */
    void initialize(const ResultsView *view);

    /**
     * @brief Load settings
     * @param settings QSettings to load settings from
     */
    void loadSettings(const QSettings &settings);

    /**
     * @brief Save settings
     * @param settings QSettings to save settings to
     */
    void saveSettings(QSettings &settings) const;

    void setAddonsAndTools(const QStringList &addonsAndTools) {
        mAddonsAndTools = addonsAndTools;
    }

    void setSuppressions(const QList<SuppressionList::Suppression> &s) {
        mSuppressio...",1,<empty>,,52,,,7,CASTProblemDeclaration,,<empty>
184683593955,UNKNOWN,1,,int,39,<empty>,,44,,,1,CPPASTTypeId,,<empty>
184683593956,UNKNOWN,3,,"class ThreadResult : public QObject, public ErrorLogger {
    Q_OBJECT
public:
    ThreadResult() = default;

    /**
     * @brief Get next unprocessed file
     * @return File path
     */
    QString getNextFile();

    void getNextFileSettings(const FileSettings*& fs);

    /**
     * @brief Set list of files to check
     * @param files List of files to check
     */
    void setFiles(const QStringList &files);

    void setProject(const ImportProject &prj);

    /**
     * @brief Clear files to check
     *
     */
    void clearFiles();

    /**
     * @brief Get the number of files to check
     *
     */
    int getFileCount() const;

    /**
     * ErrorLogger methods
     */
    void reportOut(const std::string &outmsg, Color c = Color::Reset) override;
    void reportErr(const ErrorMessage &msg) override;

public slots:

    /**
     * @brief Slot threads use to signal this class that a specific file is checked
     * @param file File that is checked
     */
    void fil...",1,<empty>,,46,,,3,CASTProblemDeclaration,,<empty>
184683593957,UNKNOWN,1,,int,58,<empty>,,183,,,1,CPPASTTypeId,,<empty>
184683593958,UNKNOWN,3,,"class TranslationHandler : QObject {
    Q_OBJECT
public:
    explicit TranslationHandler(QObject *parent = nullptr);

    /**
     * @brief Get a list of available translations.
     * @return List of available translations.
     *
     */
    const QList<TranslationInfo>& getTranslations() const {
        return mTranslations;
    }

    /**
     * @brief Set active translation.
     * @param code ISO 639 language code for new selected translation.
     * @return true if succeeds, false otherwise.
     *
     */
    bool setLanguage(const QString &code);

    /**
     * @brief Get currently selected translation.
     * @return ISO 639 language code for current translation.
     *
     */
    const QString& getCurrentLanguage() const;

    /**
     * @brief Get translation suggestion for the system.
     * This function checks the current system locale and determines which of
     * the available translations is best as current translation. If none of
     * the available translati...",1,<empty>,,62,,,3,CASTProblemDeclaration,,<empty>
184683593959,UNKNOWN,1,,"class TxtReport : public Report {
    Q_OBJECT

public:
    explicit TxtReport(const QString &filename);

    /**
     * @brief Create the report (file).
     * @return true if succeeded, false if file could not be created.
     */
    bool create() override;

    /**
     * @brief Write report header.
     */
    void writeHeader() override;

    /**
     * @brief Write report footer.
     */
    void writeFooter() override;

    /**
     * @brief Write error to report.
     * @param error Error data.
     */
    void writeError(const ErrorItem &error) override;

private:

    /**
     * @brief Text stream writer for writing the report in text format.
     */
    QTextStream mTxtWriter;
};",1,<empty>,,36,,,1,CASTProblemDeclaration,,<empty>
184683593960,UNKNOWN,2,,"class XmlReport : public Report {
public:
    explicit XmlReport(const QString &filename);

    /**
     * @brief Read contents of the report file.
     */
    virtual QList<ErrorItem> read() = 0;

    /**
     * @brief Quote the message.
     * @param message Message to quote.
     * @return quoted message.
     */
    static QString quoteMessage(const QString &message);

    /**
     * @brief Unquote the message.
     * @param message Message to quote.
     * @return quoted message.
     */
    static QString unquoteMessage(const QString &message);

    /**
     * @brief Get the XML report format version from the file.
     * @param filename Filename of the report file.
     * @return XML report format version or 0 if error happened.
     */
    static int determineVersion(const QString &filename);
};",1,<empty>,,36,,,2,CASTProblemDeclaration,,<empty>
184683593961,UNKNOWN,3,,"class XmlReportV2 : public XmlReport {
public:
    explicit XmlReportV2(const QString &filename, QString productName);
    ~XmlReportV2() override;

    /**
     * @brief Create the report (file).
     * @return true if succeeded, false if file could not be created.
     */
    bool create() override;

    /**
     * @brief Open existing report file.
     */
    bool open() override;

    /**
     * @brief Write report header.
     */
    void writeHeader() override;

    /**
     * @brief Write report footer.
     */
    void writeFooter() override;

    /**
     * @brief Write error to report.
     * @param error Error data.
     */
    void writeError(const ErrorItem &error) override;

    /**
     * @brief Read contents of the report file.
     */
    QList<ErrorItem> read() override;

protected:
    /**
     * @brief Read and parse error item from XML stream.
     * @param reader XML stream reader to use.
     */
    ErrorItem readError(const QXmlStreamReader *reader);

private...",1,<empty>,,40,,,3,CASTProblemDeclaration,,<empty>
184683593962,UNKNOWN,1,,void,10,<empty>,,141,,,1,CPPASTTypeId,,<empty>
184683593963,UNKNOWN,-1,,std::string name;,5,<empty>,,27,,,1,CASTProblemDeclaration,,<empty>
184683593964,UNKNOWN,-1,,std::string scriptFile;,5,<empty>,,28,,,2,CASTProblemDeclaration,,<empty>
184683593965,UNKNOWN,-1,,std::string executable;,5,<empty>,,29,,,3,CASTProblemDeclaration,,<empty>
184683593966,UNKNOWN,-1,,std::string args;,5,<empty>,,30,,,4,CASTProblemDeclaration,,<empty>
184683593967,UNKNOWN,-1,,std::string python;,5,<empty>,,31,,,5,CASTProblemDeclaration,,<empty>
184683593968,UNKNOWN,-1,,std::string runScript;,5,<empty>,,33,,,7,CASTProblemDeclaration,,<empty>
184683593969,UNKNOWN,-1,,"std::string getAddonInfo(const std::string &fileName, const std::string &exename, bool debug = false);",5,<empty>,,35,,,8,CASTProblemDeclaration,,<empty>
184683593970,UNKNOWN,-1,,Action() = default;,9,<empty>,,37,,,1,CASTProblemDeclaration,,<empty>
184683593971,UNKNOWN,-1,,Action(const Action&) = default;,9,<empty>,,38,,,2,CASTProblemDeclaration,,<empty>
184683593972,UNKNOWN,-1,,Action& operator=(const Action& rhs) & = default;,9,<empty>,,39,,,3,CASTProblemDeclaration,,<empty>
184683593973,UNKNOWN,-1,,"template<class T,
                 REQUIRES(""T must be convertible to unsigned int"", std::is_convertible<T, unsigned int> ),
                 REQUIRES(""T must not be a bool"", !std::is_same<T, bool> )>
        // NOLINTNEXTLINE(google-explicit-constructor)
        Action(T f) : mFlag(f) // cppcheck-suppress noExplicitConstructor
        {}",9,<empty>,,41,,,4,CASTProblemDeclaration,,<empty>
184683593974,UNKNOWN,-1,,"enum : std::uint16_t {
            None = 0,
            Read = (1 << 0),
            Write = (1 << 1),
            Invalid = (1 << 2),
            Inconclusive = (1 << 3),
            Match = (1 << 4),
            Idempotent = (1 << 5),
            Incremental = (1 << 6),
            SymbolicMatch = (1 << 7),
            Internal = (1 << 8),
        };",9,<empty>,,48,,,5,CASTProblemDeclaration,,<empty>
184683593975,UNKNOWN,-1,,),32,<empty>,,65,,,7,CASTProblemDeclaration,,<empty>
184683593976,UNKNOWN,-1,,"const {
            return ((mFlag & f) != 0);
        }",34,<empty>,,65,,,8,CASTProblemDeclaration,,<empty>
184683593977,UNKNOWN,-1,,),21,<empty>,,69,,,9,CASTProblemDeclaration,,<empty>
184683593978,UNKNOWN,-1,,"const {
            return get(Read);
        }",23,<empty>,,69,,,10,CASTProblemDeclaration,,<empty>
184683593979,UNKNOWN,-1,,),22,<empty>,,73,,,11,CASTProblemDeclaration,,<empty>
184683593980,UNKNOWN,-1,,"const {
            return get(Write);
        }",24,<empty>,,73,,,12,CASTProblemDeclaration,,<empty>
184683593981,UNKNOWN,-1,,),24,<empty>,,77,,,13,CASTProblemDeclaration,,<empty>
184683593982,UNKNOWN,-1,,"const {
            return get(Invalid);
        }",26,<empty>,,77,,,14,CASTProblemDeclaration,,<empty>
184683593983,UNKNOWN,-1,,),29,<empty>,,81,,,15,CASTProblemDeclaration,,<empty>
184683593984,UNKNOWN,-1,,"const {
            return get(Inconclusive);
        }",31,<empty>,,81,,,16,CASTProblemDeclaration,,<empty>
184683593985,UNKNOWN,-1,,),21,<empty>,,85,,,17,CASTProblemDeclaration,,<empty>
184683593986,UNKNOWN,-1,,"const {
            return mFlag == None;
        }",23,<empty>,,85,,,18,CASTProblemDeclaration,,<empty>
184683593987,UNKNOWN,-1,,),25,<empty>,,89,,,19,CASTProblemDeclaration,,<empty>
184683593988,UNKNOWN,-1,,"const {
            return isWrite() || isInvalid();
        }",27,<empty>,,89,,,20,CASTProblemDeclaration,,<empty>
184683593989,UNKNOWN,-1,,),27,<empty>,,93,,,21,CASTProblemDeclaration,,<empty>
184683593990,UNKNOWN,-1,,"const {
            return get(Idempotent);
        }",29,<empty>,,93,,,22,CASTProblemDeclaration,,<empty>
184683593991,UNKNOWN,-1,,),28,<empty>,,97,,,23,CASTProblemDeclaration,,<empty>
184683593992,UNKNOWN,-1,,"const {
            return get(Incremental);
        }",30,<empty>,,97,,,24,CASTProblemDeclaration,,<empty>
184683593993,UNKNOWN,-1,,),30,<empty>,,101,,,25,CASTProblemDeclaration,,<empty>
184683593994,UNKNOWN,-1,,"const {
            return get(SymbolicMatch);
        }",32,<empty>,,101,,,26,CASTProblemDeclaration,,<empty>
184683593995,UNKNOWN,-1,,),25,<empty>,,105,,,27,CASTProblemDeclaration,,<empty>
184683593996,UNKNOWN,-1,,"const {
            return get(Internal);
        }",27,<empty>,,105,,,28,CASTProblemDeclaration,,<empty>
184683593997,UNKNOWN,-1,,),22,<empty>,,109,,,29,CASTProblemDeclaration,,<empty>
184683593998,UNKNOWN,-1,,"const {
            return get(Match);
        }",24,<empty>,,109,,,30,CASTProblemDeclaration,,<empty>
184683593999,UNKNOWN,-1,,"Action& operator|=(Action a) {
            set(a.mFlag);
            return *this;
        }",9,<empty>,,113,,,31,CASTProblemDeclaration,,<empty>
184683594000,UNKNOWN,-1,,"friend Action operator|(Action a, Action b) {
            a |= b;
            return a;
        }",9,<empty>,,118,,,32,CASTProblemDeclaration,,<empty>
184683594001,UNKNOWN,-1,,"friend bool operator==(Action a, Action b) {
            return a.mFlag == b.mFlag;
        }",9,<empty>,,123,,,33,CASTProblemDeclaration,,<empty>
184683594002,UNKNOWN,-1,,"friend bool operator!=(Action a, Action b) {
            return a.mFlag != b.mFlag;
        }",9,<empty>,,127,,,34,CASTProblemDeclaration,,<empty>
184683594003,UNKNOWN,-1,,"private:
        unsigned int mFlag{};",5,<empty>,,131,,,35,CASTProblemDeclaration,,<empty>
184683594004,UNKNOWN,-1,,"explicit Result(Action action = Action::None, Terminate terminate = Terminate::None)
            : action(action), terminate(terminate)
        {}",9,<empty>,,138,,,1,CASTProblemDeclaration,,<empty>
184683594005,UNKNOWN,-1,,terminate == Terminate::None,17,<empty>,,145,,,1,CASTProblemExpression,,<empty>
184683594006,UNKNOWN,-1,,"enum Flags : std::uint8_t {
            None = 0,
            Quiet = (1 << 0),
            Absolute = (1 << 1),
            ContainerEmpty = (1 << 2),
        };",9,<empty>,,154,,,1,CASTProblemDeclaration,,<empty>
184683594007,UNKNOWN,-1,,"enum class Terminate : std::uint8_t { None, Bail, Escape, Modified, Inconclusive, Conditional };",5,<empty>,,135,,,2,CASTProblemDeclaration,,<empty>
184683594008,UNKNOWN,-1,,"enum class Direction : std::uint8_t { Forward, Reverse };",5,<empty>,,151,,,4,CASTProblemDeclaration,,<empty>
184683594009,UNKNOWN,-1,,"enum class Evaluate : std::uint8_t { Integral, ContainerEmpty };",5,<empty>,,162,,,6,CASTProblemDeclaration,,<empty>
184683594010,UNKNOWN,-1,,virtual,5,<empty>,,165,,,7,CASTProblemDeclaration,,<empty>
184683594011,UNKNOWN,-1,,),57,<empty>,,165,,,8,CASTProblemDeclaration,,<empty>
184683594012,UNKNOWN,-1,,virtual,5,<empty>,,167,,,10,CASTProblemDeclaration,,<empty>
184683594013,UNKNOWN,-1,,"virtual std::vector<MathLib::bigint> evaluate(Evaluate e, const Token* tok, const Token* ctx = nullptr) const = 0;",5,<empty>,,169,,,11,CASTProblemDeclaration,,<empty>
184683594014,UNKNOWN,-1,,"std::vector<MathLib::bigint> evaluate(const Token* tok, const Token* ctx = nullptr) const
    {
        return evaluate(Evaluate::Integral, tok, ctx);
    }",5,<empty>,,170,,,12,CASTProblemDeclaration,,<empty>
184683594015,UNKNOWN,-1,,virtual,5,<empty>,,175,,,13,CASTProblemDeclaration,,<empty>
184683594016,UNKNOWN,-1,,virtual,5,<empty>,,177,,,14,CASTProblemDeclaration,,<empty>
184683594017,UNKNOWN,-1,,virtual,5,<empty>,,179,,,15,CASTProblemDeclaration,,<empty>
184683594018,UNKNOWN,-1,,),66,<empty>,,179,,,16,CASTProblemDeclaration,,<empty>
184683594019,UNKNOWN,-1,,virtual,5,<empty>,,181,,,18,CASTProblemDeclaration,,<empty>
184683594020,UNKNOWN,-1,,),32,<empty>,,181,,,19,CASTProblemDeclaration,,<empty>
184683594021,UNKNOWN,-1,,virtual,5,<empty>,,183,,,21,CASTProblemDeclaration,,<empty>
184683594022,UNKNOWN,-1,,),54,<empty>,,183,,,22,CASTProblemDeclaration,,<empty>
184683594023,UNKNOWN,-1,,virtual,5,<empty>,,185,,,24,CASTProblemDeclaration,,<empty>
184683594024,UNKNOWN,-1,,virtual,5,<empty>,,187,,,25,CASTProblemDeclaration,,<empty>
184683594025,UNKNOWN,-1,,"virtual ValuePtr<Analyzer> reanalyze(Token* tok, const std::string& msg = emptyString) const = 0;",5,<empty>,,189,,,26,CASTProblemDeclaration,,<empty>
184683594026,UNKNOWN,-1,,virtual,5,<empty>,,190,,,27,CASTProblemDeclaration,,<empty>
184683594027,UNKNOWN,-1,,),26,<empty>,,190,,,28,CASTProblemDeclaration,,<empty>
184683594028,UNKNOWN,-1,,"const {
        return false;
    }",28,<empty>,,190,,,29,CASTProblemDeclaration,,<empty>
184683594029,UNKNOWN,-1,,virtual ~Analyzer() = default;,5,<empty>,,193,,,30,CASTProblemDeclaration,,<empty>
184683594030,UNKNOWN,-1,,Analyzer(const Analyzer&) = default;,5,<empty>,,194,,,31,CASTProblemDeclaration,,<empty>
184683594031,UNKNOWN,-1,,"protected:
    Analyzer() = default;",1,<empty>,,195,,,32,CASTProblemDeclaration,,<empty>
184683594032,UNKNOWN,2,,"template<class T>
class ValuePtr;",1,<empty>,,31,,,2,CASTProblemDeclaration,,<empty>
184683594033,UNKNOWN,3,,"class CPPCHECKLIB AnalyzerInformation {
public:
    ~AnalyzerInformation();

    static void writeFilesTxt(const std::string &buildDir, const std::list<std::string> &sourcefiles, const std::string &userDefines, const std::list<FileSettings> &fileSettings);

    /** Close current TU.analyzerinfo file */
    void close();
    bool analyzeFile(const std::string &buildDir, const std::string &sourcefile, const std::string &cfg, std::size_t hash, std::list<ErrorMessage> &errors);
    void reportErr(const ErrorMessage &msg);
    void setFileInfo(const std::string &check, const std::string &fileInfo);
    static std::string getAnalyzerInfoFile(const std::string &buildDir, const std::string &sourcefile, const std::string &cfg);
protected:
    static std::string getAnalyzerInfoFileFromFilesTxt(std::istream& filesTxt, const std::string &sourcefile, const std::string &cfg);
private:
    std::ofstream mOutputStream;
    std::string mAnalyzerInfoFile;
};",1,<empty>,,50,,,3,CASTProblemDeclaration,,<empty>
184683594034,UNKNOWN,1,,Token*,43,<empty>,,576,,,1,CPPASTTypeId,,<empty>
184683594035,UNKNOWN,1,,Token*,43,<empty>,,2954,,,1,CPPASTTypeId,,<empty>
184683594036,UNKNOWN,1,,bool,64,<empty>,,3782,,,1,CPPASTTypeId,,<empty>
184683594037,UNKNOWN,-1,,),47,<empty>,,248,,,1,CASTProblemDeclaration,,<empty>
184683594038,UNKNOWN,-1,,": token(t)
        , errors(std::move(e))
    {}",9,<empty>,,249,,,2,CASTProblemDeclaration,,<empty>
184683594039,UNKNOWN,6,,enum class ScopeType : std::uint8_t;,1,<empty>,,46,,,6,CASTProblemDeclaration,,<empty>
184683594040,UNKNOWN,7,,"enum class ChildrenToVisit : std::uint8_t {
    none,
    op1,
    op2,
    op1_and_op2,
    done  // found what we looked for, don't visit any more children
};",1,<empty>,,48,,,7,CASTProblemDeclaration,,<empty>
184683594041,UNKNOWN,8,,"template<class T, class TFunc, REQUIRES(""T must be a Token class"", std::is_convertible<T*, const Token*> )>
void visitAstNodes(T *ast, const TFunc &visitor)
{
    if (!ast)
        return;

    // the size of 8 was determined in tests to be sufficient to avoid excess allocations. also add 1 as a buffer.
    // we might need to increase that value in the future.
    std::stack<T *, SmallVector<T *, 8 + 1>> tokens;
    T *tok = ast;
    do {
        const ChildrenToVisit c = visitor(tok);

        if (c == ChildrenToVisit::done)
            break;
        if (c == ChildrenToVisit::op2 || c == ChildrenToVisit::op1_and_op2) {
            T *t2 = tok->astOperand2();
            if (t2)
                tokens.push(t2);
        }
        if (c == ChildrenToVisit::op1 || c == ChildrenToVisit::op1_and_op2) {
            T *t1 = tok->astOperand1();
            if (t1)
                tokens.push(t1);
        }

        if (tokens.empty())
            break;

        tok = tokens.top();
      ...",1,<empty>,,59,,,8,CASTProblemDeclaration,,<empty>
184683594042,UNKNOWN,9,,"template<class TFunc>
const Token* findAstNode(const Token* ast, const TFunc& pred)
{
    const Token* result = nullptr;
    visitAstNodes(ast, [&](const Token* tok) {
        if (pred(tok)) {
            result = tok;
            return ChildrenToVisit::done;
        }
        return ChildrenToVisit::op1_and_op2;
    });
    return result;
}",1,<empty>,,93,,,9,CASTProblemDeclaration,,<empty>
184683594043,UNKNOWN,10,,"template<class TFunc>
const Token* findParent(const Token* tok, const TFunc& pred)
{
    if (!tok)
        return nullptr;
    const Token* parent = tok->astParent();
    while (parent && !pred(parent)) {
        parent = parent->astParent();
    }
    return parent;
}",1,<empty>,,107,,,10,CASTProblemDeclaration,,<empty>
184683594044,UNKNOWN,11,,"const Token* findExpression(nonneg int exprid,
                            const Token* start,
                            const Token* end,
                            const std::function<bool(const Token*)>& pred);",1,<empty>,,119,,,11,CASTProblemDeclaration,,<empty>
184683594045,UNKNOWN,12,,"std::vector<const Token*> astFlatten(const Token* tok, const char* op);",1,<empty>,,128,,,12,CASTProblemDeclaration,,<empty>
184683594046,UNKNOWN,13,,"std::vector<Token*> astFlatten(Token* tok, const char* op);",1,<empty>,,129,,,13,CASTProblemDeclaration,,<empty>
184683594047,UNKNOWN,14,,"Library::Container::Action astContainerAction(const Token* tok, const Token** ftok = nullptr, const Settings* settings = nullptr);",1,<empty>,,167,,,14,CASTProblemDeclaration,,<empty>
184683594048,UNKNOWN,15,,"Library::Container::Yield astContainerYield(const Token* tok, const Token** ftok = nullptr, const Settings* settings = nullptr);",1,<empty>,,168,,,15,CASTProblemDeclaration,,<empty>
184683594049,UNKNOWN,16,,"Library::Container::Yield astFunctionYield(const Token* tok, const Settings& settings, const Token** ftok = nullptr);",1,<empty>,,170,,,16,CASTProblemDeclaration,,<empty>
184683594050,UNKNOWN,17,,"std::string astCanonicalType(const Token *expr, bool pointedToType);",1,<empty>,,184,,,17,CASTProblemDeclaration,,<empty>
184683594051,UNKNOWN,18,,"const Token * astIsVariableComparison(const Token *tok, const std::string &comp, const std::string &rhs, const Token **vartok=nullptr);",1,<empty>,,187,,,18,CASTProblemDeclaration,,<empty>
184683594052,UNKNOWN,19,,"const Token* getParentLifetime(const Token* tok, const Library& library);",1,<empty>,,206,,,19,CASTProblemDeclaration,,<empty>
184683594053,UNKNOWN,20,,"std::vector<ValueType> getParentValueTypes(const Token* tok,
                                           const Settings& settings,
                                           const Token** parent = nullptr);",1,<empty>,,208,,,20,CASTProblemDeclaration,,<empty>
184683594054,UNKNOWN,21,,"bool extractForLoopValues(const Token *forToken,
                          nonneg int &varid,
                          bool &knownInitValue,
                          MathLib::bigint &initValue,
                          bool &partialCond,
                          MathLib::bigint &stepValue,
                          MathLib::bigint &lastValue);",1,<empty>,,234,,,21,CASTProblemDeclaration,,<empty>
184683594055,UNKNOWN,23,,"SmallVector<ReferenceToken> followAllReferences(const Token* tok,
                                                bool temporary = true,
                                                bool inconclusive = true,
                                                ErrorPath errors = ErrorPath{}",1,<empty>,,256,,,23,CASTProblemDeclaration,,<empty>
184683594056,UNKNOWN,24,,",
                                                int depth = 20);",79,<empty>,,259,,,24,CASTProblemDeclaration,,<empty>
184683594057,UNKNOWN,25,,"bool isSameExpression(bool macro, const Token *tok1, const Token *tok2, const Settings& settings, bool pure, bool followVar, ErrorPath* errors=nullptr);",13,<empty>,,263,,,25,CASTProblemDeclaration,,<empty>
184683594058,UNKNOWN,26,,"bool isUsedAsBool(const Token* tok, const Settings& settings);",13,<empty>,,274,,,26,CASTProblemDeclaration,,<empty>
184683594059,UNKNOWN,27,,"bool isOppositeCond(bool isNot, const Token * cond1, const Token * cond2, const Settings& settings, bool pure, bool followVar, ErrorPath* errors=nullptr);",1,<empty>,,289,,,27,CASTProblemDeclaration,,<empty>
184683594060,UNKNOWN,28,,"bool isOppositeExpression(const Token * tok1, const Token * tok2, const Settings& settings, bool pure, bool followVar, ErrorPath* errors=nullptr);",1,<empty>,,291,,,28,CASTProblemDeclaration,,<empty>
184683594061,UNKNOWN,29,,"bool isConstFunctionCall(const Token* ftok, const Library& library);",1,<empty>,,293,,,29,CASTProblemDeclaration,,<empty>
184683594062,UNKNOWN,30,,"bool isConstExpression(const Token *tok, const Library& library);",1,<empty>,,295,,,30,CASTProblemDeclaration,,<empty>
184683594063,UNKNOWN,31,,"bool isReturnScope(const Token* endToken,
                               const Library& library,
                               const Token** unknownFunc = nullptr,
                               bool functionScope = false);",13,<empty>,,304,,,31,CASTProblemDeclaration,,<empty>
184683594064,UNKNOWN,32,,"const Token * getTokenArgumentFunction(const Token * tok, int& argn);",1,<empty>,,315,,,32,CASTProblemDeclaration,,<empty>
184683594065,UNKNOWN,33,,"Token* getTokenArgumentFunction(Token* tok, int& argn);",1,<empty>,,316,,,33,CASTProblemDeclaration,,<empty>
184683594066,UNKNOWN,34,,"std::vector<const Variable*> getArgumentVars(const Token* tok, int argnr);",1,<empty>,,318,,,34,CASTProblemDeclaration,,<empty>
184683594067,UNKNOWN,35,,"bool isVariableChangedByFunctionCall(const Token *tok, int indirect, nonneg int varid, const Settings &settings, bool *inconclusive);",1,<empty>,,329,,,35,CASTProblemDeclaration,,<empty>
184683594068,UNKNOWN,36,,"bool isVariableChangedByFunctionCall(const Token *tok, int indirect, const Settings &settings, bool *inconclusive);",13,<empty>,,339,,,36,CASTProblemDeclaration,,<empty>
184683594069,UNKNOWN,37,,"bool isVariableChanged(const Token *start, const Token *end, nonneg int exprid, bool globalvar, const Settings &settings, int depth = 20);",13,<empty>,,342,,,37,CASTProblemDeclaration,,<empty>
184683594070,UNKNOWN,38,,"bool isVariableChanged(const Token *start, const Token *end, int indirect, nonneg int exprid, bool globalvar, const Settings &settings, int depth = 20);",1,<empty>,,343,,,38,CASTProblemDeclaration,,<empty>
184683594071,UNKNOWN,39,,"bool isVariableChanged(const Token *tok, int indirect, const Settings &settings, int depth = 20);",1,<empty>,,345,,,39,CASTProblemDeclaration,,<empty>
184683594072,UNKNOWN,40,,"bool isVariableChanged(const Variable * var, const Settings &settings, int depth = 20);",1,<empty>,,347,,,40,CASTProblemDeclaration,,<empty>
184683594073,UNKNOWN,41,,"bool isVariablesChanged(const Token* start,
                        const Token* end,
                        int indirect,
                        const std::vector<const Variable*> &vars,
                        const Settings& settings);",1,<empty>,,349,,,41,CASTProblemDeclaration,,<empty>
184683594074,UNKNOWN,42,,"bool isThisChanged(const Token* tok, int indirect, const Settings& settings);",1,<empty>,,355,,,42,CASTProblemDeclaration,,<empty>
184683594075,UNKNOWN,43,,"const Token* findVariableChanged(const Token *start, const Token *end, int indirect, nonneg int exprid, bool globalvar, const Settings &settings, int depth = 20);",1,<empty>,,357,,,43,CASTProblemDeclaration,,<empty>
184683594076,UNKNOWN,44,,"Token* findVariableChanged(Token *start, const Token *end, int indirect, nonneg int exprid, bool globalvar, const Settings &settings, int depth = 20);",1,<empty>,,358,,,44,CASTProblemDeclaration,,<empty>
184683594077,UNKNOWN,45,,"const Token* findExpressionChanged(const Token* expr,
                                               const Token* start,
                                               const Token* end,
                                               const Settings& settings,
                                               int depth = 20);",13,<empty>,,360,,,45,CASTProblemDeclaration,,<empty>
184683594078,UNKNOWN,46,,"const Token* findExpressionChangedSkipDeadCode(const Token* expr,
                                               const Token* start,
                                               const Token* end,
                                               const Settings& settings,
                                               const std::function<std::vector<MathLib::bigint>(const Token* tok)>& evaluate,
                                               int depth = 20);",1,<empty>,,366,,,46,CASTProblemDeclaration,,<empty>
184683594079,UNKNOWN,47,,"bool isExpressionChangedAt(const Token* expr,
                           const Token* tok,
                           int indirect,
                           bool globalvar,
                           const Settings& settings,
                           int depth = 20);",1,<empty>,,373,,,47,CASTProblemDeclaration,,<empty>
184683594080,UNKNOWN,48,,std::vector<const Token *> getArguments(const Token *ftok);,1,<empty>,,399,,,48,CASTProblemDeclaration,,<empty>
184683594081,UNKNOWN,49,,bool isIteratorPair(const std::vector<const Token*>& args);,1,<empty>,,408,,,49,CASTProblemDeclaration,,<empty>
184683594082,UNKNOWN,50,,"bool isConstVarExpression(const Token* tok, const std::function<bool(const Token*)>& skipPredicate = nullptr);",1,<empty>,,431,,,50,CASTProblemDeclaration,,<empty>
184683594083,UNKNOWN,51,,"enum class ExprUsage : std::uint8_t { None, NotUsed, PassedByReference, Used, Inconclusive };",1,<empty>,,435,,,51,CASTProblemDeclaration,,<empty>
184683594084,UNKNOWN,52,,"ExprUsage getExprUsage(const Token* tok, int indirect, const Settings& settings);",1,<empty>,,437,,,52,CASTProblemDeclaration,,<empty>
184683594085,UNKNOWN,53,,std::vector<const Variable*> getLHSVariables(const Token* tok);,1,<empty>,,443,,,53,CASTProblemDeclaration,,<empty>
184683594086,UNKNOWN,54,,"const Token* findAllocFuncCallToken(const Token *expr, const Library &library);",1,<empty>,,446,,,54,CASTProblemDeclaration,,<empty>
184683594087,UNKNOWN,1,,"template<class T>
bool isEqual(T x, T y)
{
    return x == y;
}",1,<empty>,,27,,,1,CASTProblemDeclaration,,<empty>
184683594088,UNKNOWN,4,,"template<class T>
bool isZero(T x)
{
    return isEqual(x, T(0));
}",1,<empty>,,43,,,4,CASTProblemDeclaration,,<empty>
184683594089,UNKNOWN,5,,"template<class R, class T>
R calculate(const std::string& s, const T& x, const T& y, bool* error = nullptr)
{
    auto wrap = [](T z) {
        return R{z};
    };
    constexpr MathLib::bigint maxBitsShift = sizeof(MathLib::bigint) * 8;
    // For portability we cannot shift signed integers by 63 bits
    constexpr MathLib::bigint maxBitsSignedShift = maxBitsShift - 1;
    switch (MathLib::encodeMultiChar(s)) {
    case '+':
        return wrap(x + y);
    case '-':
        return wrap(x - y);
    case '*':
        return wrap(x * y);
    case '/':
        if (isZero(y) || (std::is_signed<T>{} && y < 0)) {
            if (error)
                *error = true;
            return R{};
        }
        return wrap(x / y);
    case '%':
        if (isZero(MathLib::bigint(y)) || (std::is_signed<T>{} && MathLib::bigint(y) < 0)) {
            if (error)
                *error = true;
            return R{};
        }
        return wrap(MathLib::bigint(x) % MathLib::bigint(y));
    case ...",1,<empty>,,49,,,5,CASTProblemDeclaration,,<empty>
184683594090,UNKNOWN,6,,"template<class T>
T calculate(const std::string& s, const T& x, const T& y, bool* error = nullptr)
{
    return calculate<T, T>(s, x, y, error);
}",1,<empty>,,121,,,6,CASTProblemDeclaration,,<empty>
184683594091,UNKNOWN,1,,char,39,<empty>,,109,,,1,CPPASTTypeId,,<empty>
184683594092,UNKNOWN,1,,"namespace tinyxml2 {
    class XMLElement;
}",1,<empty>,,31,,,1,CASTProblemDeclaration,,<empty>
184683594093,UNKNOWN,2,,"namespace CTU {
    class FileInfo;
}",1,<empty>,,35,,,2,CASTProblemDeclaration,,<empty>
184683594094,UNKNOWN,3,,"namespace ValueFlow {
    class Value;
}",1,<empty>,,39,,,3,CASTProblemDeclaration,,<empty>
184683594095,UNKNOWN,9,,"class CPPCHECKLIB Check {
public:
    /** This constructor is used when registering the CheckClass */
    explicit Check(const std::string &aname);

protected:
    /** This constructor is used when running checks. */
    Check(std::string aname, const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : mTokenizer(tokenizer), mSettings(settings), mErrorLogger(errorLogger), mName(std::move(aname)) {}

public:
    virtual ~Check() {
        if (!mTokenizer)
            instances().remove(this);
    }

    Check(const Check &) = delete;
    Check& operator=(const Check &) = delete;

    /** List of registered check classes. This is used by Cppcheck to run checks and generate documentation */
    static std::list<Check *> &instances();

    /** run checks, the token list is not simplified */
    virtual void runChecks(const Tokenizer &, ErrorLogger *) = 0;

    /** get error messages */
    virtual void getErrorMessages(ErrorLogger *errorLogger, const Sett...",1,<empty>,,59,,,9,CASTProblemDeclaration,,<empty>
184683594096,UNKNOWN,5,,"class CPPCHECKLIB Check64BitPortability : public Check {
    friend class Test64BitPortability;

public:
    /** This constructor is used when registering the Check64BitPortability */
    Check64BitPortability() : Check(myName()) {}

private:
    /** This constructor is used when running checks. */
    Check64BitPortability(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger) {}

    /** @brief Run checks against the normal token list */
    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    /** Check for pointer assignment */
    void pointerassignment();

    void assignmentAddressToIntegerError(const Token *tok);
    void assignmentIntegerToAddressError(const Token *tok);
    void returnIntegerError(const Token *tok);
    void returnPointerError(const Token *tok);

    void getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const override;

   ...",1,<empty>,,42,,,5,CASTProblemDeclaration,,<empty>
184683594097,UNKNOWN,6,,"class CPPCHECKLIB CheckAssert : public Check {
public:
    CheckAssert() : Check(myName()) {}

private:
    CheckAssert(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger) {}

    /** run checks, the token list is not simplified */
    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    void assertWithSideEffects();

    void checkVariableAssignment(const Token* assignTok, const Scope *assertionScope);
    static bool inSameScope(const Token* returnTok, const Token* assignTok);

    void sideEffectInAssertError(const Token *tok, const std::string& functionName);
    void assignmentInAssertError(const Token *tok, const std::string &varname);

    void getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const override;

    static std::string myName() {
        return ""Assert"";
    }

    std::string classInfo() const override {
        return ""Warn ...",1,<empty>,,43,,,6,CASTProblemDeclaration,,<empty>
184683594098,UNKNOWN,6,,"namespace ValueFlow {
    class Value;
}",1,<empty>,,38,,,6,CASTProblemDeclaration,,<empty>
184683594099,UNKNOWN,7,,"class CPPCHECKLIB CheckAutoVariables : public Check {
public:
    /** This constructor is used when registering the CheckClass */
    CheckAutoVariables() : Check(myName()) {}

private:
    /** This constructor is used when running checks. */
    CheckAutoVariables(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger) {}

    /** @brief Run checks against the normal token list */
    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    /** assign function argument */
    void assignFunctionArg();

    /** Check auto variables */
    void autoVariables();

    /**
     * Check variable assignment.. value must be changed later or there will be a error reported
     * @return true if error is reported */
    bool checkAutoVariableAssignment(const Token *expr, bool inconclusive, const Token *startToken = nullptr);

    void checkVarLifetime();

    void checkVarLifetimeSc...",1,<empty>,,47,,,7,CASTProblemDeclaration,,<empty>
184683594100,UNKNOWN,5,,"class CPPCHECKLIB CheckBool : public Check {
public:
    /** @brief This constructor is used when registering the CheckClass */
    CheckBool() : Check(myName()) {}

private:
    /** @brief This constructor is used when running checks. */
    CheckBool(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger) {}

    /** @brief Run checks against the normal token list */
    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    /** @brief %Check for comparison of function returning bool*/
    void checkComparisonOfFuncReturningBool();

    /** @brief %Check for comparison of variable of type bool*/
    void checkComparisonOfBoolWithBool();

    /** @brief %Check for using postfix increment on bool */
    void checkIncrementBoolean();

    /** @brief %Check for suspicious comparison of a bool and a non-zero (and non-one) value (e.g. ""if (!x==4)"") */
    void checkComparison...",1,<empty>,,41,,,5,CASTProblemDeclaration,,<empty>
184683594101,UNKNOWN,1,,const MyFileInfo*,39,<empty>,,1001,,,1,CPPASTTypeId,,<empty>
184683594102,UNKNOWN,40,,"inline namespace CheckBufferOverrun_internal
",1,<empty>,,890,,,40,CPPASTProblemDeclaration,,<empty>
184683594103,UNKNOWN,7,,enum class Certainty : std::uint8_t;,1,<empty>,,41,,,7,CASTProblemDeclaration,,<empty>
184683594104,UNKNOWN,8,,"namespace ValueFlow
{
    class Value;
}",1,<empty>,,43,,,8,CASTProblemDeclaration,,<empty>
184683594105,UNKNOWN,9,,"class CPPCHECKLIB CheckBufferOverrun : public Check {
public:
    /** This constructor is used when registering the CheckClass */
    CheckBufferOverrun() : Check(myName()) {}

private:
    /** This constructor is used when running checks. */
    CheckBufferOverrun(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger) {}

    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    void getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const override;

    /** @brief Parse current TU and extract file info */
    Check::FileInfo *getFileInfo(const Tokenizer &tokenizer, const Settings &settings) const override;

    /** @brief Analyse all file infos for all TU */
    bool analyseWholeProgram(const CTU::FileInfo &ctu, const std::list<Check::FileInfo*> &fileInfo, const Settings& settings, ErrorLogger &errorLogger) override;

    void arrayIndex();
    void ...",1,<empty>,,60,,,9,CASTProblemDeclaration,,<empty>
184683594106,UNKNOWN,1,,void,6,<empty>,,3702,,,1,CPPASTTypeId,,<empty>
184683594107,UNKNOWN,1,,void,6,<empty>,,3703,,,1,CPPASTTypeId,,<empty>
184683594108,UNKNOWN,1,,const MyFileInfo*,39,<empty>,,3717,,,1,CPPASTTypeId,,<empty>
184683594109,UNKNOWN,121,,"inline namespace CheckClass_internal
",1,<empty>,,3562,,,121,CPPASTProblemDeclaration,,<empty>
184683594110,UNKNOWN,10,,enum class FunctionType : std::uint8_t;,1,<empty>,,43,,,10,CASTProblemDeclaration,,<empty>
184683594111,UNKNOWN,11,,"class CPPCHECKLIB CheckClass : public Check {
    friend class TestClass;
    friend class TestConstructors;
    friend class TestUnusedPrivateFunction;

public:
    /** @brief This constructor is used when registering the CheckClass */
    CheckClass() : Check(myName()) {}

    /** @brief Set of the STL types whose operator[] is not const */
    static const std::set<std::string> stl_containers_not_const;

private:
    /** @brief This constructor is used when running checks. */
    CheckClass(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger);

    /** @brief Run checks on the normal token list */
    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    /** @brief %Check that all class constructors are ok */
    void constructors();

    /** @brief %Check that constructors with single parameter are explicit,
     *  if they has to be.*/
    void checkExplicitConstructors();

    /** @brief %Check that all private functions...",1,<empty>,,50,,,11,CASTProblemDeclaration,,<empty>
184683594112,UNKNOWN,1,,int,24,<empty>,,927,,,1,CPPASTTypeId,,<empty>
184683594113,UNKNOWN,1,,int,50,<empty>,,927,,,1,CPPASTTypeId,,<empty>
184683594114,UNKNOWN,6,,"namespace ValueFlow {
    class Value;
}",1,<empty>,,39,,,6,CASTProblemDeclaration,,<empty>
184683594115,UNKNOWN,7,,"class CPPCHECKLIB CheckCondition : public Check {
public:
    /** This constructor is used when registering the CheckAssignIf */
    CheckCondition() : Check(myName()) {}

private:
    /** This constructor is used when running checks. */
    CheckCondition(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger) {}

    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    /** mismatching assignment / comparison */
    void assignIf();

    /** parse scopes recursively */
    bool assignIfParseScope(const Token * assignTok,
                            const Token * startTok,
                            nonneg int varid,
                            bool islocal,
                            char bitop,
                            MathLib::bigint num);

    /** check bitmask using | instead of & */
    void checkBadBitmaskCheck();

    /** mismatching lhs and rhs in comparis...",1,<empty>,,50,,,7,CASTProblemDeclaration,,<empty>
184683594116,UNKNOWN,1,,"enum class ReportType : std::uint8_t {
    normal = 0,
    autosar = 1,
    certC = 2,
    certCpp = 3,
    misraC = 4,
    misraCpp2008 = 5,
    misraCpp2023 = 6,
};",1,<empty>,,29,,,1,CASTProblemDeclaration,,<empty>
184683594117,UNKNOWN,2,,"namespace checkers {
    extern CPPCHECKLIB const std::map<std::string, std::string> allCheckers;
    extern CPPCHECKLIB const std::map<std::string, std::string> premiumCheckers;

    struct CPPCHECKLIB MisraInfo {
        int a;
        int b;
        const char* str;
        int amendment;
    };

    struct CPPCHECKLIB MisraCppInfo {
        int a;
        int b;
        int c;
        const char* classification;
    };

    extern CPPCHECKLIB const char Req[]; // = ""Required"";
    extern CPPCHECKLIB const char Adv[]; // = ""Advisory"";
    extern CPPCHECKLIB const char Man[]; // = ""Mandatory"";
    extern CPPCHECKLIB const char Doc[]; // = ""Document"";

    extern CPPCHECKLIB const std::vector<MisraInfo> misraC2012Directives;
    extern CPPCHECKLIB const std::vector<MisraInfo> misraC2012Rules;
    extern CPPCHECKLIB const std::vector<MisraCppInfo> misraCpp2008Rules;
    extern CPPCHECKLIB const std::vector<MisraCppInfo> misraCpp2023Rules;

    extern CPPCHECKLIB const std::map<std::...",1,<empty>,,39,,,2,CASTProblemDeclaration,,<empty>
184683594118,UNKNOWN,2,,"class CPPCHECKLIB CheckersReport {
public:
    CheckersReport(const Settings& settings, const std::set<std::string>& activeCheckers);

    int getActiveCheckersCount();
    int getAllCheckersCount();

    std::string getReport(const std::string& criticalErrors) const;
    std::string getXmlReport(const std::string& criticalErrors) const;

private:
    const Settings& mSettings;
    const std::set<std::string>& mActiveCheckers;

    void countCheckers();

    int mActiveCheckersCount = 0;
    int mAllCheckersCount = 0;
};",1,<empty>,,29,,,2,CASTProblemDeclaration,,<empty>
184683594119,UNKNOWN,5,,"class CPPCHECKLIB CheckExceptionSafety : public Check {
public:
    /** This constructor is used when registering the CheckClass */
    CheckExceptionSafety() : Check(myName()) {}

private:
    /** This constructor is used when running checks. */
    CheckExceptionSafety(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger) {}

    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    /** Don't throw exceptions in destructors */
    void destructors();

    /** deallocating memory and then throw (dead pointer) */
    void deallocThrow();

    /** Don't rethrow a copy of the caught exception; use a bare throw instead */
    void checkRethrowCopy();

    /** @brief %Check for exceptions that are caught by value instead of by reference */
    void checkCatchExceptionByValue();

    /** @brief %Check for functions that throw that shouldn't */
    void nothrowThrows();

   ...",1,<empty>,,46,,,5,CASTProblemDeclaration,,<empty>
184683594120,UNKNOWN,5,,"namespace ValueFlow {
    class Value;
}",1,<empty>,,35,,,5,CASTProblemDeclaration,,<empty>
184683594121,UNKNOWN,6,,"class CPPCHECKLIB CheckFunctions : public Check {
public:
    /** This constructor is used when registering the CheckFunctions */
    CheckFunctions() : Check(myName()) {}

private:
    /** This constructor is used when running checks. */
    CheckFunctions(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger) {}

    /** @brief Run checks against the normal token list */
    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    /** Check for functions that should not be used */
    void checkProhibitedFunctions();

    /**
     * @brief Invalid function usage (invalid input value / overlapping data)
     *
     * %Check that given function parameters are valid according to the standard
     * - wrong radix given for strtol/strtoul
     * - overlapping data when using sprintf/snprintf
     * - wrong input value according to library
     */
    void invalidFunctionUsage...",1,<empty>,,47,,,6,CASTProblemDeclaration,,<empty>
184683594122,UNKNOWN,5,,"class CPPCHECKLIB CheckInternal : public Check {
public:
    /** This constructor is used when registering the CheckClass */
    CheckInternal() : Check(myName()) {}

private:
    /** This constructor is used when running checks. */
    CheckInternal(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger) {}

    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    /** @brief %Check if a simple pattern is used inside Token::Match or Token::findmatch */
    void checkTokenMatchPatterns();

    /** @brief %Check if a complex pattern is used inside Token::simpleMatch or Token::findsimplematch */
    void checkTokenSimpleMatchPatterns();

    /** @brief %Check for missing % end character in Token::Match pattern */
    void checkMissingPercentCharacter();

    /** @brief %Check for unknown (invalid) complex patterns like ""%typ%"" */
    void checkUnknownPattern();

    /** @b...",1,<empty>,,40,,,5,CASTProblemDeclaration,,<empty>
184683594123,UNKNOWN,1,,unsigned char,40,<empty>,,448,,,1,CPPASTTypeId,,<empty>
184683594124,UNKNOWN,1,,unsigned char,76,<empty>,,648,,,1,CPPASTTypeId,,<empty>
184683594125,UNKNOWN,1,,Token*,36,<empty>,,1401,,,1,CPPASTTypeId,,<empty>
184683594126,UNKNOWN,7,,enum class Severity : std::uint8_t;,1,<empty>,,37,,,7,CASTProblemDeclaration,,<empty>
184683594127,UNKNOWN,8,,"class CPPCHECKLIB CheckIO : public Check {
    friend class TestIO;

public:
    /** @brief This constructor is used when registering CheckIO */
    CheckIO() : Check(myName()) {}

private:
    /** @brief This constructor is used when running checks. */
    CheckIO(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger) {}

    /** @brief Run checks on the normal token list */
    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    /** @brief %Check for missusage of std::cout */
    void checkCoutCerrMisusage();

    /** @brief %Check usage of files*/
    void checkFileUsage();

    /** @brief scanf can crash if width specifiers are not used */
    void invalidScanf();

    /** @brief %Checks type and number of arguments given to functions like printf or scanf*/
    void checkWrongPrintfScanfArguments();

    class ArgumentInfo {
    public:
        ArgumentInfo(const ...",1,<empty>,,43,,,8,CASTProblemDeclaration,,<empty>
184683594128,UNKNOWN,5,,"class CPPCHECKLIB VarInfo {
public:
    enum AllocStatus : std::int8_t { REALLOC = -3, OWNED = -2, DEALLOC = -1, NOALLOC = 0, ALLOC = 1 };
    struct AllocInfo {
        AllocStatus status;
        /** Allocation type. If it is a positive value then it corresponds to
         * a Library allocation id. A negative value is a builtin
         * checkleakautovar allocation type.
         */
        int type;
        int reallocedFromType = -1;
        const Token * allocTok;
        explicit AllocInfo(int type_ = 0, AllocStatus status_ = NOALLOC, const Token* allocTok_ = nullptr) : status(status_), type(type_), allocTok(allocTok_) {}

        bool managed() const {
            return status < 0;
        }
    };
    enum Usage : std::uint8_t { USED, NORET };
    std::map<int, AllocInfo> alloctype;
    std::map<int, std::pair<const Token*, Usage>> possibleUsage;
    std::set<int> conditionalAlloc;
    std::set<int> referenced;

    void clear() {
        alloctype.clear();
        possi...",1,<empty>,,40,,,5,CASTProblemDeclaration,,<empty>
184683594129,UNKNOWN,6,,"class CPPCHECKLIB CheckLeakAutoVar : public Check {
public:
    /** This constructor is used when registering the CheckLeakAutoVar */
    CheckLeakAutoVar() : Check(myName()) {}

private:
    /** This constructor is used when running checks. */
    CheckLeakAutoVar(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger) {}

    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    /** check for leaks in all scopes */
    void check();

    /** check for leaks in a function scope */
    bool checkScope(const Token * startToken,
                    VarInfo &varInfo,
                    std::set<int> notzero,
                    nonneg int recursiveCount);

    /** Check token inside expression.
     * @param tok token inside expression.
     * @param varInfo Variable info
     * @return next token to process (if no other checks needed for this token). NULL if other checks ...",1,<empty>,,107,,,6,CASTProblemDeclaration,,<empty>
184683594130,UNKNOWN,9,,enum class Severity : std::uint8_t;,1,<empty>,,50,,,9,CASTProblemDeclaration,,<empty>
184683594131,UNKNOWN,10,,"class CPPCHECKLIB CheckMemoryLeak {
private:
    /** For access to the tokens */
    const Tokenizer * const mTokenizer_;

    /** ErrorLogger used to report errors */
    ErrorLogger * const mErrorLogger_;

    /** Enabled standards */
    const Settings * const mSettings_;

    /**
     * Report error. Similar with the function Check::reportError
     * @param tok the token where the error occurs
     * @param severity the severity of the bug
     * @param id type of message
     * @param msg text
     * @param cwe cwe number
     */
    void reportErr(const Token *tok, Severity severity, const std::string &id, const std::string &msg, const CWE &cwe) const;

    /**
     * Report error. Similar with the function Check::reportError
     * @param callstack callstack of error
     * @param severity the severity of the bug
     * @param id type of message
     * @param msg text
     * @param cwe cwe number
     */
    void reportErr(const std::list<const Token *> &callstack, Severity ...",1,<empty>,,56,,,10,CASTProblemDeclaration,,<empty>
184683594132,UNKNOWN,11,,"class CPPCHECKLIB CheckMemoryLeakInFunction : public Check, public CheckMemoryLeak {
    friend class TestMemleakInFunction;

public:
    /** @brief This constructor is used when registering this class */
    CheckMemoryLeakInFunction() : Check(myName()), CheckMemoryLeak(nullptr, nullptr, nullptr) {}

private:
    /** @brief This constructor is used when running checks */
    CheckMemoryLeakInFunction(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger), CheckMemoryLeak(tokenizer, errorLogger, settings) {}

    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    /**
     * Checking for a memory leak caused by improper realloc usage.
     */
    void checkReallocUsage();

    /** Report all possible errors (for the --errorlist) */
    void getErrorMessages(ErrorLogger *e, const Settings *settings) const override;

    /**
     * Get name of class (--doc)
     * @retu...",1,<empty>,,168,,,11,CASTProblemDeclaration,,<empty>
184683594133,UNKNOWN,12,,"class CPPCHECKLIB CheckMemoryLeakInClass : public Check, private CheckMemoryLeak {
    friend class TestMemleakInClass;

public:
    CheckMemoryLeakInClass() : Check(myName()), CheckMemoryLeak(nullptr, nullptr, nullptr) {}

private:
    CheckMemoryLeakInClass(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger), CheckMemoryLeak(tokenizer, errorLogger, settings) {}

    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    void check();

    void variable(const Scope *scope, const Token *tokVarname);

    /** Public functions: possible double-allocation */
    void checkPublicFunctions(const Scope *scope, const Token *classtok);
    void publicAllocationError(const Token *tok, const std::string &varname);

    void unsafeClassError(const Token *tok, const std::string &classname, const std::string &varname);

    void getErrorMessages(ErrorLogger *e, const Settings *set...",1,<empty>,,213,,,12,CASTProblemDeclaration,,<empty>
184683594134,UNKNOWN,13,,"class CPPCHECKLIB CheckMemoryLeakStructMember : public Check, private CheckMemoryLeak {
    friend class TestMemleakStructMember;

public:
    CheckMemoryLeakStructMember() : Check(myName()), CheckMemoryLeak(nullptr, nullptr, nullptr) {}

private:
    CheckMemoryLeakStructMember(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger), CheckMemoryLeak(tokenizer, errorLogger, settings) {}

    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    void check();

    /** Is local variable allocated with malloc? */
    bool isMalloc(const Variable *variable) const;

    void checkStructVariable(const Variable*  variable) const;

    void getErrorMessages(ErrorLogger * errorLogger, const Settings * settings) const override;

    static std::string myName() {
        return ""Memory leaks (struct members)"";
    }

    std::string classInfo() const override {
        return ""Don'...",1,<empty>,,250,,,13,CASTProblemDeclaration,,<empty>
184683594135,UNKNOWN,14,,"class CPPCHECKLIB CheckMemoryLeakNoVar : public Check, private CheckMemoryLeak {
    friend class TestMemleakNoVar;

public:
    CheckMemoryLeakNoVar() : Check(myName()), CheckMemoryLeak(nullptr, nullptr, nullptr) {}

private:
    CheckMemoryLeakNoVar(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger), CheckMemoryLeak(tokenizer, errorLogger, settings) {}

    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    void check();

    /**
     * @brief %Check if an input argument to a function is the return value of an allocation function
     * like malloc(), and the function does not release it.
     * @param scope     The scope of the function to check.
     */
    void checkForUnreleasedInputArgument(const Scope *scope);

    /**
     * @brief %Check if a call to an allocation function like malloc() is made and its return value is not assigned.
     * @param scope  ...",1,<empty>,,284,,,14,CASTProblemDeclaration,,<empty>
184683594136,UNKNOWN,1,,unsigned char,39,<empty>,,109,,,1,CPPASTTypeId,,<empty>
184683594137,UNKNOWN,1,,char,73,<empty>,,477,,,1,CPPASTTypeId,,<empty>
184683594138,UNKNOWN,1,,char,75,<empty>,,481,,,1,CPPASTTypeId,,<empty>
184683594139,UNKNOWN,1,,char,53,<empty>,,556,,,1,CPPASTTypeId,,<empty>
184683594140,UNKNOWN,1,,char,55,<empty>,,560,,,1,CPPASTTypeId,,<empty>
184683594141,UNKNOWN,1,,void,6,<empty>,,595,,,1,CPPASTTypeId,,<empty>
184683594142,UNKNOWN,1,,void,6,<empty>,,647,,,1,CPPASTTypeId,,<empty>
184683594143,UNKNOWN,1,,const MyFileInfo*,39,<empty>,,661,,,1,CPPASTTypeId,,<empty>
184683594144,UNKNOWN,23,,"inline namespace CheckNullPointer_internal
",1,<empty>,,603,,,23,CPPASTProblemDeclaration,,<empty>
184683594145,UNKNOWN,6,,"namespace ValueFlow
{
    class Value;
}",1,<empty>,,37,,,6,CASTProblemDeclaration,,<empty>
184683594146,UNKNOWN,7,,"class CPPCHECKLIB CheckNullPointer : public Check {
    friend class TestNullPointer;

public:
    /** @brief This constructor is used when registering the CheckNullPointer */
    CheckNullPointer() : Check(myName()) {}

    /**
     * Is there a pointer dereference? Everything that should result in
     * a nullpointer dereference error message will result in a true
     * return value. If it's unknown if the pointer is dereferenced false
     * is returned.
     * @param tok token for the pointer
     * @param unknown it is not known if there is a pointer dereference (could be reported as a debug message)
     * @return true => there is a dereference
     */
    bool isPointerDeRef(const Token *tok, bool &unknown) const;

    static bool isPointerDeRef(const Token *tok, bool &unknown, const Settings &settings, bool checkNullArg = true);

private:
    /**
     * @brief parse a function call and extract information about variable usage
     * @param tok first token
     * @param var...",1,<empty>,,48,,,7,CASTProblemDeclaration,,<empty>
184683594147,UNKNOWN,1,,"namespace ValueFlow {
    class Value;
}",1,<empty>,,33,,,1,CASTProblemDeclaration,,<empty>
184683594148,UNKNOWN,8,,"class CPPCHECKLIB CheckOther : public Check {
    friend class TestCharVar;
    friend class TestIncompleteStatement;
    friend class TestOther;

public:
    /** @brief This constructor is used when registering the CheckClass */
    CheckOther() : Check(myName()) {}

    /** Is expression a comparison that checks if a nonzero (unsigned/pointer) expression is less than zero? */
    static bool comparisonNonZeroExpressionLessThanZero(const Token *tok, const ValueFlow::Value *&zeroValue, const Token *&nonZeroExpr, bool suppress = false);

    /** Is expression a comparison that checks if a nonzero (unsigned/pointer) expression is positive? */
    static bool testIfNonZeroExpressionIsPositive(const Token *tok, const ValueFlow::Value *&zeroValue, const Token *&nonZeroExpr);

private:
    /** @brief This constructor is used when running checks. */
    CheckOther(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, ...",1,<empty>,,50,,,8,CASTProblemDeclaration,,<empty>
184683594149,UNKNOWN,5,,"class CPPCHECKLIB CheckPostfixOperator : public Check {
    friend class TestPostfixOperator;

public:
    /** This constructor is used when registering the CheckPostfixOperator */
    CheckPostfixOperator() : Check(myName()) {}

private:
    /** This constructor is used when running checks. */
    CheckPostfixOperator(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger) {}

    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    /** Check postfix operators */
    void postfixOperator();

    /** Report Error */
    void postfixOperatorError(const Token *tok);

    void getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const override;

    static std::string myName() {
        return ""Using postfix operators"";
    }

    std::string classInfo() const override {
        return ""Warn if using postfix operators ++ or -- rather than prefix operator\\n""...",1,<empty>,,42,,,5,CASTProblemDeclaration,,<empty>
184683594150,UNKNOWN,5,,"class CPPCHECKLIB CheckSizeof : public Check {
public:
    /** @brief This constructor is used when registering the CheckClass */
    CheckSizeof() : Check(myName()) {}

private:
    /** @brief This constructor is used when running checks. */
    CheckSizeof(const Tokenizer* tokenizer, const Settings* settings, ErrorLogger* errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger) {}

    /** @brief Run checks against the normal token list */
    void runChecks(const Tokenizer& tokenizer, ErrorLogger* errorLogger) override;

    /** @brief %Check for 'sizeof sizeof ..' */
    void sizeofsizeof();

    /** @brief %Check for calculations inside sizeof */
    void sizeofCalculation();

    /** @brief %Check for function call inside sizeof */
    void sizeofFunction();

    /** @brief %Check for suspicious calculations with sizeof results */
    void suspiciousSizeofCalculation();

    /** @brief %Check for using sizeof with array given as function argument */
    void ch...",1,<empty>,,41,,,5,CASTProblemDeclaration,,<empty>
184683594151,UNKNOWN,7,,"namespace ValueFlow
{
    class Value;
}",1,<empty>,,38,,,7,CASTProblemDeclaration,,<empty>
184683594152,UNKNOWN,8,,"class CPPCHECKLIB CheckStl : public Check {
public:
    /** This constructor is used when registering the CheckClass */
    CheckStl() : Check(myName()) {}

private:
    /** This constructor is used when running checks. */
    CheckStl(const Tokenizer* tokenizer, const Settings* settings, ErrorLogger* errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger) {}

    /** run checks, the token list is not simplified */
    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    /** Accessing container out of bounds using ValueFlow */
    void outOfBounds();

    /** Accessing container out of bounds, following index expression */
    void outOfBoundsIndexExpression();

    /**
     * Finds errors like this:
     * for (unsigned ii = 0; ii <= foo.size(); ++ii)
     */
    void stlOutOfBounds();

    /**
     * negative index for array like containers
     */
    void negativeIndex();

    /**
     * Finds errors like this:
     * for (it = foo...",1,<empty>,,48,,,8,CASTProblemDeclaration,,<empty>
184683594153,UNKNOWN,5,,"class CPPCHECKLIB CheckString : public Check {
public:
    /** @brief This constructor is used when registering the CheckClass */
    CheckString() : Check(myName()) {}

private:
    /** @brief This constructor is used when running checks. */
    CheckString(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger) {}

    /** @brief Run checks against the normal token list */
    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    /** @brief undefined behaviour, writing string literal */
    void stringLiteralWrite();

    /** @brief str plus char (unusual pointer arithmetic) */
    void strPlusChar();

    /** @brief %Check for using bad usage of strncmp and substr */
    void checkIncorrectStringCompare();

    /** @brief %Check for comparison of a string literal with a char* variable */
    void checkSuspiciousStringCompare();

    /** @brief %Check for suspicious co...",1,<empty>,,41,,,5,CASTProblemDeclaration,,<empty>
184683594154,UNKNOWN,1,,MathLib::biguint,45,<empty>,,203,,,1,CPPASTTypeId,,<empty>
184683594155,UNKNOWN,1,,MathLib::bigint,79,<empty>,,216,,,1,CPPASTTypeId,,<empty>
184683594156,UNKNOWN,1,,MathLib::biguint,67,<empty>,,510,,,1,CPPASTTypeId,,<empty>
184683594157,UNKNOWN,6,,"namespace ValueFlow
{
    class Value;
}",1,<empty>,,36,,,6,CASTProblemDeclaration,,<empty>
184683594158,UNKNOWN,7,,"class CPPCHECKLIB CheckType : public Check {
public:
    /** @brief This constructor is used when registering the CheckClass */
    CheckType() : Check(myName()) {}

private:
    /** @brief This constructor is used when running checks. */
    CheckType(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger) {}

    /** @brief Run checks against the normal token list */
    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    /** @brief %Check for bitwise shift with too big right operand */
    void checkTooBigBitwiseShift();

    /** @brief %Check for integer overflow */
    void checkIntegerOverflow();

    /** @brief %Check for dangerous sign conversion */
    void checkSignConversion();

    /** @brief %Check for implicit long cast of int result */
    void checkLongCast();

    /** @brief %Check for float to integer overflow */
    void checkFloatToIntegerOverflow()...",1,<empty>,,47,,,7,CASTProblemDeclaration,,<empty>
184683594159,UNKNOWN,1,,void,6,<empty>,,1698,,,1,CPPASTTypeId,,<empty>
184683594160,UNKNOWN,1,,void,6,<empty>,,1753,,,1,CPPASTTypeId,,<empty>
184683594161,UNKNOWN,1,,const MyFileInfo*,39,<empty>,,1767,,,1,CPPASTTypeId,,<empty>
184683594162,UNKNOWN,36,,"inline namespace CheckUninitVar_internal
",1,<empty>,,1705,,,36,CPPASTProblemDeclaration,,<empty>
184683594163,UNKNOWN,-1,,explicit VariableValue(MathLib::bigint val = 0) : value(val) {},5,<empty>,,48,,,1,CASTProblemDeclaration,,<empty>
184683594164,UNKNOWN,-1,,MathLib::bigint value;,5,<empty>,,49,,,2,CASTProblemDeclaration,,<empty>
184683594165,UNKNOWN,-1,,bool notEqual{};,5,<empty>,,50,,,3,CASTProblemDeclaration,,<empty>
184683594166,UNKNOWN,8,,"namespace ValueFlow
{
    class Value;
}",1,<empty>,,42,,,8,CASTProblemDeclaration,,<empty>
184683594167,UNKNOWN,10,,"class CPPCHECKLIB CheckUninitVar : public Check {
    friend class TestUninitVar;

public:
    /** @brief This constructor is used when registering the CheckUninitVar */
    CheckUninitVar() : Check(myName()) {}

    enum Alloc : std::uint8_t { NO_ALLOC, NO_CTOR_CALL, CTOR_CALL, ARRAY };

    static const Token *isVariableUsage(const Token *vartok, const Library &library, bool pointer, Alloc alloc, int indirect = 0);
    const Token *isVariableUsage(const Token *vartok, bool pointer, Alloc alloc, int indirect = 0) const;

private:
    /** @brief This constructor is used when running checks. */
    CheckUninitVar(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger) {}

    /** @brief Run checks against the normal token list */
    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    bool diag(const Token* tok);
    /** Check for uninitialized variables */
    void che...",1,<empty>,,59,,,10,CASTProblemDeclaration,,<empty>
184683594168,UNKNOWN,5,,"class CPPCHECKLIB CheckUnusedFunctions {
    friend class TestSuppressions;
    friend class TestSingleExecutorBase;
    friend class TestProcessExecutorBase;
    friend class TestThreadExecutorBase;
    friend class TestUnusedFunctions;

public:
    CheckUnusedFunctions() = default;

    // Parse current tokens and determine..
    // * Check what functions are used
    // * What functions are declared
    void parseTokens(const Tokenizer &tokenizer, const Settings &settings);

    std::string analyzerInfo() const;

    static void analyseWholeProgram(const Settings &settings, ErrorLogger& errorLogger, const std::string &buildDir);

    static void getErrorMessages(ErrorLogger &errorLogger) {
        unusedFunctionError(errorLogger, """", 0, 0, ""funcName"");
    }

    // Return true if an error is reported.
    bool check(const Settings& settings, ErrorLogger& errorLogger) const;

    void updateFunctionData(const CheckUnusedFunctions& check);

private:
    static void unusedFunctionE...",1,<empty>,,40,,,5,CASTProblemDeclaration,,<empty>
184683594169,UNKNOWN,10,,"class CPPCHECKLIB CheckUnusedVar : public Check {
    friend class TestUnusedVar;

public:
    /** @brief This constructor is used when registering the CheckClass */
    CheckUnusedVar() : Check(myName()) {}

private:
    /** @brief This constructor is used when running checks. */
    CheckUnusedVar(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger) {}

    /** @brief Run checks against the normal token list */
    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    /** @brief %Check for unused function variables */
    void checkFunctionVariableUsage_iterateScopes(const Scope* scope, Variables& variables);
    void checkFunctionVariableUsage();

    /** @brief %Check that all struct members are used */
    void checkStructMemberUsage();

    bool isRecordTypeWithoutSideEffects(const Type* type);
    bool isVariableWithoutSideEffects(const Variable& var, const Typ...",1,<empty>,,47,,,10,CASTProblemDeclaration,,<empty>
184683594170,UNKNOWN,5,,"class CPPCHECKLIB CheckVaarg : public Check {
public:
    CheckVaarg() : Check(myName()) {}

private:
    CheckVaarg(const Tokenizer *tokenizer, const Settings *settings, ErrorLogger *errorLogger)
        : Check(myName(), tokenizer, settings, errorLogger) {}

    void runChecks(const Tokenizer &tokenizer, ErrorLogger *errorLogger) override;

    void va_start_argument();
    void va_list_usage();

    void wrongParameterTo_va_start_error(const Token *tok, const std::string& paramIsName, const std::string& paramShouldName);
    void referenceAs_va_start_error(const Token *tok, const std::string& paramName);
    void va_end_missingError(const Token *tok, const std::string& varname);
    void va_list_usedBeforeStartedError(const Token *tok, const std::string& varname);
    void va_start_subsequentCallsError(const Token *tok, const std::string& varname);

    void getErrorMessages(ErrorLogger *errorLogger, const Settings *settings) const override;

    static std::string myName() {
   ...",1,<empty>,,42,,,5,CASTProblemDeclaration,,<empty>
184683594171,UNKNOWN,1,,int,25,<empty>,,142,,,1,CPPASTTypeId,,<empty>
184683594172,UNKNOWN,1,,unsigned char,99,<empty>,,146,,,1,CPPASTTypeId,,<empty>
184683594173,UNKNOWN,1,,void,6,<empty>,,492,,,1,CPPASTTypeId,,<empty>
184683594174,UNKNOWN,1,,Token*,24,<empty>,,633,,,1,CPPASTTypeId,,<empty>
184683594175,UNKNOWN,1,,Scope *,33,<empty>,,699,,,1,CPPASTTypeId,,<empty>
184683594176,UNKNOWN,1,,Token *,28,<empty>,,722,,,1,CPPASTTypeId,,<empty>
184683594177,UNKNOWN,1,,Scope *,51,<empty>,,724,,,1,CPPASTTypeId,,<empty>
184683594178,UNKNOWN,1,,Token*,41,<empty>,,756,,,1,CPPASTTypeId,,<empty>
184683594179,UNKNOWN,1,,Token*,79,<empty>,,756,,,1,CPPASTTypeId,,<empty>
184683594180,UNKNOWN,1,,Scope *,34,<empty>,,1024,,,1,CPPASTTypeId,,<empty>
184683594181,UNKNOWN,1,,Token *,24,<empty>,,1058,,,1,CPPASTTypeId,,<empty>
184683594182,UNKNOWN,1,,Scope *,24,<empty>,,1064,,,1,CPPASTTypeId,,<empty>
184683594183,UNKNOWN,1,,Scope *,24,<empty>,,1232,,,1,CPPASTTypeId,,<empty>
184683594184,UNKNOWN,1,,int,22,<empty>,,1265,,,1,CPPASTTypeId,,<empty>
184683594185,UNKNOWN,1,,Scope *,33,<empty>,,1376,,,1,CPPASTTypeId,,<empty>
184683594186,UNKNOWN,1,,Function*,40,<empty>,,1393,,,1,CPPASTTypeId,,<empty>
184683594187,UNKNOWN,1,,Scope *,20,<empty>,,1513,,,1,CPPASTTypeId,,<empty>
184683594188,UNKNOWN,1,,Scope *,30,<empty>,,1536,,,1,CPPASTTypeId,,<empty>
184683594189,UNKNOWN,1,,Token*,33,<empty>,,1592,,,1,CPPASTTypeId,,<empty>
184683594190,UNKNOWN,1,,SymbolDatabase *,39,<empty>,,1618,,,1,CPPASTTypeId,,<empty>
184683594191,UNKNOWN,2,,"namespace clangimport {
    void CPPCHECKLIB parseClangAstDump(Tokenizer &tokenizer, std::istream &f);
}",1,<empty>,,31,,,2,CASTProblemDeclaration,,<empty>
184683594192,UNKNOWN,1,,std::size_t,45,<empty>,,68,,,1,CPPASTTypeId,,<empty>
184683594193,UNKNOWN,1,,"enum class Color : std::uint8_t {
    Reset      = 0,
    Bold       = 1,
    Dim        = 2,
    FgRed      = 31,
    FgGreen    = 32,
    FgBlue     = 34,
    FgMagenta  = 35,
    FgDefault  = 39
};",1,<empty>,,28,,,1,CASTProblemDeclaration,,<empty>
184683594194,UNKNOWN,2,,"std::ostream& operator<<(std::ostream& os, Color c);",13,<empty>,,38,,,2,CASTProblemDeclaration,,<empty>
184683594195,UNKNOWN,3,,std::string toString(Color c);,13,<empty>,,40,,,3,CASTProblemDeclaration,,<empty>
184683594196,UNKNOWN,1,,static const std::string emptyString;,1,<empty>,,137,,,1,CASTProblemDeclaration,,<empty>
184683594197,UNKNOWN,1,,unsigned,44,<empty>,,395,,,1,CPPASTTypeId,,<empty>
184683594198,UNKNOWN,1,,unsigned,45,<empty>,,396,,,1,CPPASTTypeId,,<empty>
184683594199,UNKNOWN,1,,unsigned,43,<empty>,,397,,,1,CPPASTTypeId,,<empty>
184683594200,UNKNOWN,1,,unsigned,44,<empty>,,398,,,1,CPPASTTypeId,,<empty>
184683594201,UNKNOWN,1,,unsigned,49,<empty>,,399,,,1,CPPASTTypeId,,<empty>
184683594202,UNKNOWN,1,,SymbolDatabase&,41,<empty>,,724,,,1,CPPASTTypeId,,<empty>
184683594203,UNKNOWN,1,,std::uint8_t,44,<empty>,,843,,,1,CPPASTTypeId,,<empty>
184683594204,UNKNOWN,1,,void,18,<empty>,,1028,,,1,CPPASTTypeId,,<empty>
184683594205,UNKNOWN,1,,bool,115,<empty>,,1268,,,1,CPPASTTypeId,,<empty>
184683594206,UNKNOWN,1,,const CTU::FileInfo *,44,<empty>,,1975,,,1,CPPASTTypeId,,<empty>
184683594207,UNKNOWN,2,,enum class SHOWTIME_MODES : std::uint8_t;,1,<empty>,,37,,,2,CASTProblemDeclaration,,<empty>
184683594208,UNKNOWN,11,,namespace simplecpp { class TokenList; },1,<empty>,,47,,,11,CASTProblemDeclaration,,<empty>
184683594209,UNKNOWN,12,,"class CPPCHECKLIB CppCheck {
public:
    using ExecuteCmdFn = std::function<int (std::string,std::vector<std::string>,std::string,std::string&)>;

    /**
     * @brief Constructor.
     */
    CppCheck(const Settings& settings,
             Suppressions& supprs,
             ErrorLogger &errorLogger,
             bool useGlobalSuppressions,
             ExecuteCmdFn executeCommand);

    /**
     * @brief Destructor.
     */
    ~CppCheck();

    /**
     * @brief This starts the actual checking. Note that you must call
     * parseFromArgs() or settings() and addFile() before calling this.
     * @return amount of errors found or 0 if none were found.
     */

    /**
     * @brief Check the file.
     * This function checks one given file for errors.
     * @param file The file to check.
     * @return amount of errors found or 0 if none were found.
     * @note You must set settings before calling this function (by calling
     *  settings()).
     */
    unsigned int check(cons...",1,<empty>,,58,,,12,CASTProblemDeclaration,,<empty>
184683594210,UNKNOWN,1,,int,66,<empty>,,105,,,1,CPPASTTypeId,,<empty>
184683594211,UNKNOWN,1,,int,66,<empty>,,107,,,1,CPPASTTypeId,,<empty>
184683594212,UNKNOWN,1,,ValueFlow::Value::ValueType,22,<empty>,,205,,,1,CPPASTTypeId,,<empty>
184683594213,UNKNOWN,1,,ValueFlow::Value::UnknownFunctionReturn,43,<empty>,,208,,,1,CPPASTTypeId,,<empty>
184683594214,UNKNOWN,1,,const CTU::FileInfo::FunctionCall *,49,<empty>,,522,,,1,CPPASTTypeId,,<empty>
184683594215,UNKNOWN,1,,const CTU::FileInfo::NestedCall *,47,<empty>,,548,,,1,CPPASTTypeId,,<empty>
184683594216,UNKNOWN,1,,const CTU::FileInfo::FunctionCall *,49,<empty>,,576,,,1,CPPASTTypeId,,<empty>
184683594217,UNKNOWN,1,,const CTU::FileInfo::FunctionCall *,49,<empty>,,589,,,1,CPPASTTypeId,,<empty>
184683594218,UNKNOWN,5,,"namespace tinyxml2 {
    class XMLElement;
}",1,<empty>,,43,,,5,CASTProblemDeclaration,,<empty>
184683594219,UNKNOWN,6,,"namespace CTU {
    class CPPCHECKLIB FileInfo : public Check::FileInfo {
    public:
        enum class InvalidValueType : std::uint8_t { null, uninit, bufferOverflow };

        std::string toString() const override;

        struct Location {
            Location() = default;
            Location(const Tokenizer &tokenizer, const Token *tok);
            Location(std::string fileName, nonneg int lineNumber, nonneg int column) : fileName(std::move(fileName)), lineNumber(lineNumber), column(column) {}
            std::string fileName;
            nonneg int lineNumber{};
            nonneg int column{};
        };

        struct Value {
            Value& operator=(const ValueFlow::Value& val) & {
                value = val.intvalue;
                unknownFunctionReturn = val.unknownFunctionReturn;
                return *this;
            }
            MathLib::bigint value{};
            ValueFlow::Value::UnknownFunctionReturn unknownFunctionReturn{};
        };

        struc...",1,<empty>,,52,,,6,CASTProblemDeclaration,,<empty>
184683594220,UNKNOWN,1,,unsigned char,38,<empty>,,470,,,1,CPPASTTypeId,,<empty>
184683594221,UNKNOWN,1,,unsigned char,37,<empty>,,475,,,1,CPPASTTypeId,,<empty>
184683594222,UNKNOWN,1,,int (*)(int),59,<empty>,,1032,,,1,CPPASTTypeId,,<empty>
184683594223,UNKNOWN,3,,enum class ReportType : std::uint8_t;,1,<empty>,,38,,,3,CASTProblemDeclaration,,<empty>
184683594224,UNKNOWN,4,,enum class Color : std::uint8_t;,1,<empty>,,39,,,4,CASTProblemDeclaration,,<empty>
184683594225,UNKNOWN,5,,"namespace tinyxml2 {
    class XMLElement;
}",1,<empty>,,41,,,5,CASTProblemDeclaration,,<empty>
184683594226,UNKNOWN,6,,"class CPPCHECKLIB ErrorMessage {
public:
    /**
     * File name and line number.
     * Internally paths are stored with / separator. When getting the filename
     * it is by default converted to native separators.
     */
    class CPPCHECKLIB WARN_UNUSED FileLocation {
    public:
        FileLocation(const std::string &file, int line, unsigned int column)
            : fileIndex(0), line(line), column(column), mOrigFileName(file), mFileName(file) {}

        FileLocation(const std::string &file, std::string info, int line, unsigned int column)
            : fileIndex(0), line(line), column(column), mOrigFileName(file), mFileName(file), mInfo(std::move(info)) {}

        FileLocation(const Token* tok, const TokenList* tokenList);
        FileLocation(const Token* tok, std::string info, const TokenList* tokenList);

        /**
         * Return the filename.
         * @param convert If true convert path to native separators.
         * @return filename.
         */
        std...",1,<empty>,,51,,,6,CASTProblemDeclaration,,<empty>
184683594227,UNKNOWN,7,,"class CPPCHECKLIB ErrorLogger {
public:
    ErrorLogger() = default;
    virtual ~ErrorLogger() = default;

    /**
     * Information about progress is directed here.
     * Override this to receive the progress messages.
     *
     * @param outmsg Message to show e.g. ""Checking main.cpp...""
     */
    virtual void reportOut(const std::string &outmsg, Color c) = 0;

    /**
     * Information about found errors and warnings is directed
     * here. Override this to receive the errormessages.
     *
     * @param msg Location and other information about the found error.
     */
    virtual void reportErr(const ErrorMessage &msg) = 0;

    /**
     * Report progress to client
     * @param filename main file that is checked
     * @param stage for example preprocess / tokenize / simplify / check
     * @param value progress value (0-100)
     */
    virtual void reportProgress(const std::string &filename, const char stage[], const std::size_t value) {
        (void)filename;
      ...",1,<empty>,,227,,,7,CASTProblemDeclaration,,<empty>
184683594228,UNKNOWN,8,,"std::string replaceStr(std::string s, const std::string &from, const std::string &to);",1,<empty>,,286,,,8,CASTProblemDeclaration,,<empty>
184683594229,UNKNOWN,9,,void substituteTemplateFormatStatic(std::string& templateFormat);,13,<empty>,,289,,,9,CASTProblemDeclaration,,<empty>
184683594230,UNKNOWN,10,,void substituteTemplateLocationStatic(std::string& templateLocation);,13,<empty>,,292,,,10,CASTProblemDeclaration,,<empty>
184683594231,UNKNOWN,11,,"std::string getClassification(const std::string &guideline, ReportType reportType);",13,<empty>,,295,,,11,CASTProblemDeclaration,,<empty>
184683594232,UNKNOWN,12,,"std::string getGuideline(const std::string &errId, ReportType reportType,
                                     const std::map<std::string, std::string> &guidelineMapping,
                                     Severity severity);",13,<empty>,,298,,,12,CASTProblemDeclaration,,<empty>
184683594233,UNKNOWN,13,,"std::map<std::string, std::string> createGuidelineMapping(ReportType reportType);",13,<empty>,,303,,,13,CASTProblemDeclaration,,<empty>
184683594234,UNKNOWN,-1,,"enum Type : std::uint8_t {AST, SYNTAX, UNKNOWN_MACRO, INTERNAL, LIMIT, INSTANTIATION};",5,<empty>,,38,,,1,CASTProblemDeclaration,,<empty>
184683594235,UNKNOWN,-1,,"InternalError(const Token *tok, std::string errorMsg, Type type = INTERNAL);",5,<empty>,,40,,,2,CASTProblemDeclaration,,<empty>
184683594236,UNKNOWN,-1,,"InternalError(const Token *tok, std::string errorMsg, std::string details, Type type = INTERNAL);",5,<empty>,,41,,,3,CASTProblemDeclaration,,<empty>
184683594237,UNKNOWN,-1,,std::string errorMessage;,5,<empty>,,44,,,5,CASTProblemDeclaration,,<empty>
184683594238,UNKNOWN,-1,,std::string details;,5,<empty>,,45,,,6,CASTProblemDeclaration,,<empty>
184683594239,UNKNOWN,-1,,std::string id;,5,<empty>,,47,,,8,CASTProblemDeclaration,,<empty>
184683594240,UNKNOWN,-1,,),38,<empty>,,126,,,1,CASTProblemDeclaration,,<empty>
184683594241,UNKNOWN,-1,,: id(cweId) {},40,<empty>,,126,,,2,CASTProblemDeclaration,,<empty>
184683594242,UNKNOWN,3,,"class TerminateException : public std::runtime_error {
public:
    TerminateException() : std::runtime_error(""terminate"") {}
};",1,<empty>,,50,,,3,CASTProblemDeclaration,,<empty>
184683594243,UNKNOWN,4,,"enum class Certainty : std::uint8_t {
    normal, inconclusive
};",1,<empty>,,55,,,4,CASTProblemDeclaration,,<empty>
184683594244,UNKNOWN,5,,"enum class Checks : std::uint8_t {
    unusedFunction, missingInclude, internalCheck
};",1,<empty>,,59,,,5,CASTProblemDeclaration,,<empty>
184683594245,UNKNOWN,6,,"enum class Severity : std::uint8_t {
    /**
     * No severity (default value).
     */
    none,
    /**
     * Programming error.
     * This indicates severe error like memory leak etc.
     * The error is certain.
     */
    error,
    /**
     * Warning.
     * Used for dangerous coding style that can cause severe runtime errors.
     * For example: forgetting to initialize a member variable in a constructor.
     */
    warning,
    /**
     * Style warning.
     * Used for general code cleanup recommendations. Fixing these
     * will not fix any bugs but will make the code easier to maintain.
     * For example: redundant code, unreachable code, etc.
     */
    style,
    /**
     * Performance warning.
     * Not an error as is but suboptimal code and fixing it probably leads
     * to faster performance of the compiled code.
     */
    performance,
    /**
     * Portability warning.
     * This warning indicates the code is not properly portable for
     * different p...",1,<empty>,,64,,,6,CASTProblemDeclaration,,<empty>
184683594246,UNKNOWN,7,,std::string severityToString(Severity severity);,13,<empty>,,122,,,7,CASTProblemDeclaration,,<empty>
184683594247,UNKNOWN,8,,Severity severityFromString(const std::string &severity);,13,<empty>,,123,,,8,CASTProblemDeclaration,,<empty>
184683594248,UNKNOWN,10,,"using ErrorPathItem = std::pair<const Token *, std::string>;",1,<empty>,,130,,,10,CASTProblemDeclaration,,<empty>
184683594249,UNKNOWN,11,,using ErrorPath = std::list<ErrorPathItem>;,1,<empty>,,131,,,11,CASTProblemDeclaration,,<empty>
184683594250,UNKNOWN,-1,,"explicit FileSettings(std::string path)
        : file(std::move(path))
    {}",5,<empty>,,83,,,1,CASTProblemDeclaration,,<empty>
184683594251,UNKNOWN,-1,,"FileSettings(std::string path, Standards::Language lang, std::size_t size)
        : file(std::move(path), lang, size)
    {}",5,<empty>,,87,,,2,CASTProblemDeclaration,,<empty>
184683594252,UNKNOWN,-1,,std::string cfg;,5,<empty>,,91,,,3,CASTProblemDeclaration,,<empty>
184683594253,UNKNOWN,-1,,"const std::string& filename() const
    {
        return file.path();
    }",5,<empty>,,93,,,5,CASTProblemDeclaration,,<empty>
184683594254,UNKNOWN,-1,,"const std::string& sfilename() const
    {
        return file.spath();
    }",5,<empty>,,98,,,6,CASTProblemDeclaration,,<empty>
184683594255,UNKNOWN,-1,,std::string defines;,5,<empty>,,102,,,7,CASTProblemDeclaration,,<empty>
184683594256,UNKNOWN,-1,,"std::string cppcheckDefines() const {
        return defines + (msc ? "";_MSC_VER=1900"" : """") + (useMfc ? "";__AFXWIN_H__=1"" : """");
    }",5,<empty>,,104,,,8,CASTProblemDeclaration,,<empty>
184683594257,UNKNOWN,-1,,std::set<std::string> undefs;,5,<empty>,,107,,,9,CASTProblemDeclaration,,<empty>
184683594258,UNKNOWN,-1,,std::list<std::string> includePaths;,5,<empty>,,108,,,10,CASTProblemDeclaration,,<empty>
184683594259,UNKNOWN,-1,,std::list<std::string> systemIncludePaths;,5,<empty>,,110,,,11,CASTProblemDeclaration,,<empty>
184683594260,UNKNOWN,-1,,std::string standard;,5,<empty>,,111,,,12,CASTProblemDeclaration,,<empty>
184683594261,UNKNOWN,-1,,Platform::Type platformType = Platform::Type::Unspecified;,5,<empty>,,112,,,13,CASTProblemDeclaration,,<empty>
184683594262,UNKNOWN,-1,,bool msc{};,5,<empty>,,114,,,14,CASTProblemDeclaration,,<empty>
184683594263,UNKNOWN,-1,,bool useMfc{};,5,<empty>,,115,,,15,CASTProblemDeclaration,,<empty>
184683594264,UNKNOWN,1,,"class FileWithDetails
{
public:
    explicit FileWithDetails(std::string path)
        : FileWithDetails(std::move(path), Standards::Language::None, 0)
    {}

    FileWithDetails(std::string path, Standards::Language lang, std::size_t size)
        : mPath(std::move(path))
        , mPathSimplified(Path::simplifyPath(mPath))
        , mLang(lang)
        , mSize(size)
    {
        if (mPath.empty())
            throw std::runtime_error(""empty path specified"");
    }

    const std::string& path() const
    {
        return mPath;
    }

    const std::string& spath() const
    {
        return mPathSimplified;
    }

    std::size_t size() const
    {
        return mSize;
    }

    void setLang(Standards::Language lang)
    {
        mLang = lang;
    }

    Standards::Language lang() const
    {
        return mLang;
    }
private:
    std::string mPath;
    std::string mPathSimplified;
    Standards::Language mLang = Standards::Language::None;
    std::size_t mSize;
};",1,<empty>,,33,,,1,CASTProblemDeclaration,,<empty>
184683594265,UNKNOWN,2,,"inline std::vector<MathLib::bigint> evaluateKnownValues(const Token* tok)
{
    if (!tok->hasKnownIntValue())
        return {};
    return {tok->getKnownIntValue()};
}",1,<empty>,,34,,,2,CASTProblemDeclaration,,<empty>
184683594266,UNKNOWN,3,,"template<class T, class Predicate, class Found, REQUIRES(""T must be a Token class"", std::is_convertible<T*, const Token*> )>
void findTokensImpl(T* start, const Token* end, const Predicate& pred, Found found)
{
    for (T* tok = start; precedes(tok, end); tok = tok->next()) {
        if (pred(tok)) {
            if (found(tok))
                break;
        }
    }
}",1,<empty>,,41,,,3,CASTProblemDeclaration,,<empty>
184683594267,UNKNOWN,4,,"template<class T, class Predicate, REQUIRES(""T must be a Token class"", std::is_convertible<T*, const Token*> )>
std::vector<T*> findTokens(T* start, const Token* end, const Predicate& pred)
{
    std::vector<T*> result;
    findTokensImpl(start, end, pred, [&](T* tok) {
        result.push_back(tok);
        return false;
    });
    return result;
}",1,<empty>,,52,,,4,CASTProblemDeclaration,,<empty>
184683594268,UNKNOWN,5,,"template<class T, class Predicate, REQUIRES(""T must be a Token class"", std::is_convertible<T*, const Token*> )>
T* findToken(T* start, const Token* end, const Predicate& pred)
{
    T* result = nullptr;
    findTokensImpl(start, end, pred, [&](T* tok) {
        result = tok;
        return true;
    });
    return result;
}",1,<empty>,,63,,,5,CASTProblemDeclaration,,<empty>
184683594269,UNKNOWN,6,,"namespace internal {
    bool findTokensSkipDeadCodeImpl(const Library &library,
                                    Token *start,
                                    const Token *end,
                                    const std::function<bool(const Token *)> &pred,
                                    const std::function<bool(Token *)>& found,
                                    const std::function<std::vector<MathLib::bigint>(const Token *)> &evaluate,
                                    bool skipUnevaluated);

    bool findTokensSkipDeadCodeImpl(const Library &library,
                                    const Token *start,
                                    const Token *end,
                                    const std::function<bool(const Token *)> &pred,
                                    const std::function<bool(const Token *)>& found,
                                    const std::function<std::vector<MathLib::bigint>(const Token *)> &evaluate,
                          ...",1,<empty>,,74,,,6,CASTProblemDeclaration,,<empty>
184683594270,UNKNOWN,7,,"template<class T, class Predicate, class Evaluate, REQUIRES(""T must be a Token class"", std::is_convertible<T*, const Token*> )>
std::vector<T*> findTokensSkipDeadCode(const Library& library,
                                       T* start,
                                       const Token* end,
                                       const Predicate& pred,
                                       const Evaluate& evaluate)
{
    std::vector<T*> result;
    (void)internal::findTokensSkipDeadCodeImpl(
        library,
        start,
        end,
        pred,
        [&](T* tok) {
        result.push_back(tok);
        return false;
    },
        evaluate,
        false);
    return result;
}",1,<empty>,,92,,,7,CASTProblemDeclaration,,<empty>
184683594271,UNKNOWN,8,,"template<class T, class Predicate, REQUIRES(""T must be a Token class"", std::is_convertible<T*, const Token*> )>
std::vector<T*> findTokensSkipDeadCode(const Library& library, T* start, const Token* end, const Predicate& pred)
{
    return findTokensSkipDeadCode(library, start, end, pred, &evaluateKnownValues);
}",1,<empty>,,114,,,8,CASTProblemDeclaration,,<empty>
184683594272,UNKNOWN,9,,"template<class T, class Predicate, class Evaluate, REQUIRES(""T must be a Token class"", std::is_convertible<T*, const Token*> )>
std::vector<T*> findTokensSkipDeadAndUnevaluatedCode(const Library& library,
                                                     T* start,
                                                     const Token* end,
                                                     const Predicate& pred,
                                                     const Evaluate& evaluate)
{
    std::vector<T*> result;
    (void)internal::findTokensSkipDeadCodeImpl(
        library,
        start,
        end,
        pred,
        [&](T* tok) {
        result.push_back(tok);
        return false;
    },
        evaluate,
        true);
    return result;
}",1,<empty>,,120,,,9,CASTProblemDeclaration,,<empty>
184683594273,UNKNOWN,10,,"template<class T, class Predicate, REQUIRES(""T must be a Token class"", std::is_convertible<T*, const Token*> )>
std::vector<T*> findTokensSkipDeadAndUnevaluatedCode(const Library& library, T* start, const Token* end, const Predicate& pred)
{
    return findTokensSkipDeadAndUnevaluatedCode(library, start, end, pred, &evaluateKnownValues);
}",1,<empty>,,142,,,10,CASTProblemDeclaration,,<empty>
184683594274,UNKNOWN,11,,"template<class T, class Predicate, class Evaluate, REQUIRES(""T must be a Token class"", std::is_convertible<T*, const Token*> )>
T* findTokenSkipDeadCode(const Library& library, T* start, const Token* end, const Predicate& pred, const Evaluate& evaluate)
{
    T* result = nullptr;
    (void)internal::findTokensSkipDeadCodeImpl(
        library,
        start,
        end,
        pred,
        [&](T* tok) {
        result = tok;
        return true;
    },
        evaluate,
        false);
    return result;
}",1,<empty>,,149,,,11,CASTProblemDeclaration,,<empty>
184683594275,UNKNOWN,12,,"template<class T, class Predicate, REQUIRES(""T must be a Token class"", std::is_convertible<T*, const Token*> )>
T* findTokenSkipDeadCode(const Library& library, T* start, const Token* end, const Predicate& pred)
{
    return findTokenSkipDeadCode(library, start, end, pred, &evaluateKnownValues);
}",1,<empty>,,167,,,12,CASTProblemDeclaration,,<empty>
184683594276,UNKNOWN,1,,void,6,<empty>,,921,,,1,CPPASTTypeId,,<empty>
184683594277,UNKNOWN,5,,template<class T> class ValuePtr;,1,<empty>,,28,,,5,CASTProblemDeclaration,,<empty>
184683594278,UNKNOWN,6,,"Analyzer::Result valueFlowGenericForward(Token* start,
                                         const Token* end,
                                         const ValuePtr<Analyzer>& a,
                                         const TokenList& tokenList,
                                         ErrorLogger& errorLogger,
                                         const Settings& settings);",1,<empty>,,30,,,6,CASTProblemDeclaration,,<empty>
184683594279,UNKNOWN,7,,"Analyzer::Result valueFlowGenericForward(Token* start, const ValuePtr<Analyzer>& a, const TokenList& tokenList, ErrorLogger& errorLogger, const Settings& settings);",1,<empty>,,37,,,7,CASTProblemDeclaration,,<empty>
184683594280,UNKNOWN,3,,"class FwdAnalysis {
public:
    explicit FwdAnalysis(const Settings &settings) : mSettings(settings) {}

    bool hasOperand(const Token *tok, const Token *lhs) const;

    /**
     * Check if ""expr"" is reassigned. The ""expr"" can be a tree (x.y[12]).
     * @param expr Symbolic expression to perform forward analysis for
     * @param startToken First token in forward analysis
     * @param endToken Last token in forward analysis
     * @return Token where expr is reassigned. If it's not reassigned then nullptr is returned.
     */
    const Token *reassign(const Token *expr, const Token *startToken, const Token *endToken);

    /**
     * Check if ""expr"" is used. The ""expr"" can be a tree (x.y[12]).
     * @param expr Symbolic expression to perform forward analysis for
     * @param startToken First token in forward analysis
     * @param endToken Last token in forward analysis
     * @return true if expr is used.
     */
    bool unusedValue(const Token *expr, const Token *startToke...",1,<empty>,,39,,,3,CASTProblemDeclaration,,<empty>
184683594281,UNKNOWN,3,,"namespace cppcheck {
    struct stricmp {
        bool operator()(const std::string &lhs, const std::string &rhs) const {
            return caseInsensitiveStringCompare(lhs,rhs) < 0;
        }
    };
}",1,<empty>,,43,,,3,CASTProblemDeclaration,,<empty>
184683594282,UNKNOWN,4,,"class CPPCHECKLIB WARN_UNUSED ImportProject {
public:
    enum class Type : std::uint8_t {
        NONE,
        UNKNOWN,
        MISSING,
        FAILURE,
        COMPILE_DB,
        VS_SLN,
        VS_VCXPROJ,
        BORLAND,
        CPPCHECK_GUI
    };

    static void fsParseCommand(FileSettings& fs, const std::string& command);
    static void fsSetDefines(FileSettings& fs, std::string defs);
    static void fsSetIncludePaths(FileSettings& fs, const std::string &basepath, const std::list<std::string> &in, std::map<std::string, std::string, cppcheck::stricmp> &variables);

    std::list<FileSettings> fileSettings;
    Type projectType{Type::NONE};

    ImportProject() = default;
    virtual ~ImportProject() = default;
    ImportProject(const ImportProject&) = default;
    ImportProject& operator=(const ImportProject&) & = default;

    void selectOneVsConfig(Platform::Type platform);
    void selectVsConfigurations(Platform::Type platform, const std::vector<std::string> &config...",1,<empty>,,54,,,4,CASTProblemDeclaration,,<empty>
184683594283,UNKNOWN,5,,"namespace CppcheckXml {
    static constexpr char ProjectElementName[] = ""project"";
    static constexpr char ProjectVersionAttrib[] = ""version"";
    static constexpr char ProjectFileVersion[] = ""1"";
    static constexpr char BuildDirElementName[] = ""builddir"";
    static constexpr char ImportProjectElementName[] = ""importproject"";
    static constexpr char AnalyzeAllVsConfigsElementName[] = ""analyze-all-vs-configs"";
    static constexpr char Parser[] = ""parser"";
    static constexpr char IncludeDirElementName[] = ""includedir"";
    static constexpr char DirElementName[] = ""dir"";
    static constexpr char DirNameAttrib[] = ""name"";
    static constexpr char DefinesElementName[] = ""defines"";
    static constexpr char DefineName[] = ""define"";
    static constexpr char DefineNameAttrib[] = ""name"";
    static constexpr char UndefinesElementName[] = ""undefines"";
    static constexpr char UndefineName[] = ""undefine"";
    static constexpr char PathsElementName[] = ""paths"";
    static constex...",1,<empty>,,127,,,5,CASTProblemDeclaration,,<empty>
184683594284,UNKNOWN,1,,int,48,<empty>,,353,,,1,CPPASTTypeId,,<empty>
184683594285,UNKNOWN,-1,,virtual bool match(const ValueFlow::Value& value) const = 0;,5,<empty>,,38,,,1,CASTProblemDeclaration,,<empty>
184683594286,UNKNOWN,-1,,virtual ValueFlow::Value yield(MathLib::bigint value) const = 0;,5,<empty>,,39,,,2,CASTProblemDeclaration,,<empty>
184683594287,UNKNOWN,-1,,virtual ~InferModel() = default;,5,<empty>,,40,,,3,CASTProblemDeclaration,,<empty>
184683594288,UNKNOWN,-1,,InferModel(const InferModel&) = default;,5,<empty>,,41,,,4,CASTProblemDeclaration,,<empty>
184683594289,UNKNOWN,-1,,"protected:
    InferModel() = default;",1,<empty>,,42,,,5,CASTProblemDeclaration,,<empty>
184683594290,UNKNOWN,2,,template<class T> class ValuePtr;,1,<empty>,,30,,,2,CASTProblemDeclaration,,<empty>
184683594291,UNKNOWN,3,,"namespace ValueFlow
{
    class Value;
}",1,<empty>,,32,,,3,CASTProblemDeclaration,,<empty>
184683594292,UNKNOWN,5,,"std::vector<ValueFlow::Value> infer(const ValuePtr<InferModel>& model,
                                    const std::string& op,
                                    std::list<ValueFlow::Value> lhsValues,
                                    std::list<ValueFlow::Value> rhsValues);",1,<empty>,,46,,,5,CASTProblemDeclaration,,<empty>
184683594293,UNKNOWN,6,,"std::vector<ValueFlow::Value> infer(const ValuePtr<InferModel>& model,
                                    const std::string& op,
                                    MathLib::bigint lhs,
                                    std::list<ValueFlow::Value> rhsValues);",1,<empty>,,51,,,6,CASTProblemDeclaration,,<empty>
184683594294,UNKNOWN,7,,"std::vector<ValueFlow::Value> infer(const ValuePtr<InferModel>& model,
                                    const std::string& op,
                                    std::list<ValueFlow::Value> lhsValues,
                                    MathLib::bigint rhs);",1,<empty>,,56,,,7,CASTProblemDeclaration,,<empty>
184683594295,UNKNOWN,8,,"std::vector<MathLib::bigint> getMinValue(const ValuePtr<InferModel>& model, const std::list<ValueFlow::Value>& values);",13,<empty>,,61,,,8,CASTProblemDeclaration,,<empty>
184683594296,UNKNOWN,9,,"std::vector<MathLib::bigint> getMaxValue(const ValuePtr<InferModel>& model, const std::list<ValueFlow::Value>& values);",1,<empty>,,62,,,9,CASTProblemDeclaration,,<empty>
184683594297,UNKNOWN,10,,ValuePtr<InferModel> makeIntegralInferModel();,1,<empty>,,64,,,10,CASTProblemDeclaration,,<empty>
184683594298,UNKNOWN,11,,"ValueFlow::Value inferCondition(const std::string& op, const Token* varTok, MathLib::bigint val);",1,<empty>,,66,,,11,CASTProblemDeclaration,,<empty>
184683594299,UNKNOWN,1,,"class Keywords
{
public:
    static const std::unordered_set<std::string>& getAll(Standards::cstd_t cStd);
    static const std::unordered_set<std::string>& getAll(Standards::cppstd_t cppStd);

    static const std::unordered_set<std::string>& getOnly(Standards::cstd_t cStd);
    static const std::unordered_set<std::string>& getOnly(Standards::cppstd_t cppStd);
};",1,<empty>,,27,,,1,CASTProblemDeclaration,,<empty>
184683594300,UNKNOWN,1,,double,57,<empty>,,1063,,,1,CPPASTTypeId,,<empty>
184683594301,UNKNOWN,2,,enum class Severity : std::uint8_t;,1,<empty>,,39,,,2,CASTProblemDeclaration,,<empty>
184683594302,UNKNOWN,3,,"namespace tinyxml2 {
    class XMLDocument;
    class XMLElement;
}",1,<empty>,,41,,,3,CASTProblemDeclaration,,<empty>
184683594303,UNKNOWN,4,,"class CPPCHECKLIB Library {
    friend struct LibraryHelper; // for testing

    static const std::string mEmptyString;

public:
    Library();
    ~Library();

    Library(const Library& other);
    Library& operator=(const Library& other) &;

    enum class ErrorCode : std::uint8_t {
        OK,
        FILE_NOT_FOUND, BAD_XML, UNKNOWN_ELEMENT, MISSING_ATTRIBUTE, BAD_ATTRIBUTE_VALUE,
        UNSUPPORTED_FORMAT, DUPLICATE_PLATFORM_TYPE, PLATFORM_TYPE_REDEFINED, DUPLICATE_DEFINE
    };

    class Error {
    public:
        Error() : errorcode(ErrorCode::OK) {}
        explicit Error(ErrorCode e) : errorcode(e) {}
        template<typename T>
        Error(ErrorCode e, T&& r) : errorcode(e), reason(r) {}
        ErrorCode errorcode;
        std::string reason;
    };

    Error load(const char exename[], const char path[], bool debug = false);

    struct AllocFunc {
        int groupId{};
        int arg{};
        enum class BufferSize : std::uint8_t {none,malloc,calloc,strdup};
 ...",1,<empty>,,52,,,4,CASTProblemDeclaration,,<empty>
184683594304,UNKNOWN,5,,const Library::Container * getLibraryContainer(const Token * tok);,13,<empty>,,488,,,5,CASTProblemDeclaration,,<empty>
184683594305,UNKNOWN,1,,"namespace MatchCompiler {

    template<unsigned int n>
    class ConstString {
    public:
        using StringRef = const char (&)[n];
        explicit ConstString(StringRef s)
            : _s(s) {}

        operator StringRef() const {
            return _s;
        }

    private:
        StringRef _s;
    };

    template<unsigned int n>
    inline bool equalN(const char s1[], const char s2[])
    {
        return (*s1 == *s2) && equalN<n-1>(s1+1, s2+1);
    }

    template<>
    inline bool equalN<0>(const char /*s1*/[], const char /*s2*/[])
    {
        return true;
    }

    template<unsigned int n>
    inline bool operator==(const std::string & s1, ConstString<n> const & s2)
    {
        return equalN<n>(s1.c_str(), s2);
    }

    template<unsigned int n>
    inline bool operator!=(const std::string & s1, ConstString<n> const & s2)
    {
        return !operator==(s1,s2);
    }

    template<unsigned int n>
    inline ConstString<n> makeConstString(const char (&s)[n])
...",1,<empty>,,25,,,1,CASTProblemDeclaration,,<empty>
184683594306,UNKNOWN,1,,biguint,29,<empty>,,99,,,1,CPPASTTypeId,,<empty>
184683594307,UNKNOWN,1,,double,36,<empty>,,120,,,1,CPPASTTypeId,,<empty>
184683594308,UNKNOWN,1,,unsigned long long,32,<empty>,,155,,,1,CPPASTTypeId,,<empty>
184683594309,UNKNOWN,1,,unsigned long long,32,<empty>,,158,,,1,CPPASTTypeId,,<empty>
184683594310,UNKNOWN,1,,unsigned long long,32,<empty>,,161,,,1,CPPASTTypeId,,<empty>
184683594311,UNKNOWN,1,,unsigned long long,32,<empty>,,168,,,1,CPPASTTypeId,,<empty>
184683594312,UNKNOWN,1,,unsigned long long,32,<empty>,,173,,,1,CPPASTTypeId,,<empty>
184683594313,UNKNOWN,1,,unsigned long long,32,<empty>,,176,,,1,CPPASTTypeId,,<empty>
184683594314,UNKNOWN,1,,unsigned long long,32,<empty>,,179,,,1,CPPASTTypeId,,<empty>
184683594315,UNKNOWN,1,,unsigned long long,32,<empty>,,182,,,1,CPPASTTypeId,,<empty>
184683594316,UNKNOWN,1,,unsigned long long,14,<empty>,,241,,,1,CPPASTTypeId,,<empty>
184683594317,UNKNOWN,1,,unsigned long long,46,<empty>,,241,,,1,CPPASTTypeId,,<empty>
184683594318,UNKNOWN,1,,unsigned long long,14,<empty>,,243,,,1,CPPASTTypeId,,<empty>
184683594319,UNKNOWN,1,,unsigned long long,46,<empty>,,243,,,1,CPPASTTypeId,,<empty>
184683594320,UNKNOWN,1,,double,26,<empty>,,341,,,1,CPPASTTypeId,,<empty>
184683594321,UNKNOWN,1,,biguint,28,<empty>,,344,,,1,CPPASTTypeId,,<empty>
184683594322,UNKNOWN,1,,bigint,49,<empty>,,344,,,1,CPPASTTypeId,,<empty>
184683594323,UNKNOWN,1,,bigint,21,<empty>,,385,,,1,CPPASTTypeId,,<empty>
184683594324,UNKNOWN,1,,double,26,<empty>,,425,,,1,CPPASTTypeId,,<empty>
184683594325,UNKNOWN,1,,double,26,<empty>,,427,,,1,CPPASTTypeId,,<empty>
184683594326,UNKNOWN,1,,bigint,28,<empty>,,429,,,1,CPPASTTypeId,,<empty>
184683594327,UNKNOWN,1,,double,28,<empty>,,513,,,1,CPPASTTypeId,,<empty>
184683594328,UNKNOWN,1,,unsigned char,47,<empty>,,593,,,1,CPPASTTypeId,,<empty>
184683594329,UNKNOWN,1,,unsigned char,42,<empty>,,599,,,1,CPPASTTypeId,,<empty>
184683594330,UNKNOWN,1,,unsigned char,48,<empty>,,609,,,1,CPPASTTypeId,,<empty>
184683594331,UNKNOWN,1,,unsigned char,47,<empty>,,621,,,1,CPPASTTypeId,,<empty>
184683594332,UNKNOWN,1,,unsigned char,48,<empty>,,635,,,1,CPPASTTypeId,,<empty>
184683594333,UNKNOWN,1,,unsigned char,47,<empty>,,641,,,1,CPPASTTypeId,,<empty>
184683594334,UNKNOWN,1,,unsigned char,43,<empty>,,647,,,1,CPPASTTypeId,,<empty>
184683594335,UNKNOWN,1,,unsigned char,48,<empty>,,657,,,1,CPPASTTypeId,,<empty>
184683594336,UNKNOWN,1,,unsigned char,42,<empty>,,828,,,1,CPPASTTypeId,,<empty>
184683594337,UNKNOWN,1,,unsigned char,42,<empty>,,834,,,1,CPPASTTypeId,,<empty>
184683594338,UNKNOWN,1,,unsigned char,38,<empty>,,869,,,1,CPPASTTypeId,,<empty>
184683594339,UNKNOWN,1,,unsigned char,38,<empty>,,875,,,1,CPPASTTypeId,,<empty>
184683594340,UNKNOWN,1,,unsigned char,38,<empty>,,910,,,1,CPPASTTypeId,,<empty>
184683594341,UNKNOWN,1,,unsigned char,38,<empty>,,918,,,1,CPPASTTypeId,,<empty>
184683594342,UNKNOWN,1,,unsigned char,38,<empty>,,929,,,1,CPPASTTypeId,,<empty>
184683594343,UNKNOWN,1,,unsigned char,37,<empty>,,937,,,1,CPPASTTypeId,,<empty>
184683594344,UNKNOWN,1,,unsigned char,37,<empty>,,945,,,1,CPPASTTypeId,,<empty>
184683594345,UNKNOWN,1,,unsigned char,37,<empty>,,951,,,1,CPPASTTypeId,,<empty>
184683594346,UNKNOWN,1,,unsigned char,37,<empty>,,1029,,,1,CPPASTTypeId,,<empty>
184683594347,UNKNOWN,1,,unsigned char,37,<empty>,,1035,,,1,CPPASTTypeId,,<empty>
184683594348,UNKNOWN,1,,unsigned char,51,<empty>,,1293,,,1,CPPASTTypeId,,<empty>
184683594349,UNKNOWN,1,,unsigned char,38,<empty>,,1300,,,1,CPPASTTypeId,,<empty>
184683594350,UNKNOWN,2,,"class CPPCHECKLIB MathLib {
    friend class TestMathLib;

public:
#if defined(HAVE_BOOST) && defined(HAVE_BOOST_INT128)
    using bigint = boost::multiprecision::int128_t;
    using biguint = boost::multiprecision::uint128_t;
#else
    using bigint = long long;
    using biguint = unsigned long long;
#endif

    /** @brief value class */
    class value {
    private:
        bigint mIntValue{};
        double mDoubleValue{};
        enum class Type : std::uint8_t { INT, LONG, LONGLONG, FLOAT } mType;
        bool mIsUnsigned{};

        void promote(const value &v);

    public:
        explicit value(const std::string &s);
        std::string str() const;
        bool isInt() const {
            return mType != Type::FLOAT;
        }
        bool isFloat() const {
            return mType == Type::FLOAT;
        }

        double getDoubleValue() const {
            return isFloat() ? mDoubleValue : (double)mIntValue;
        }

        static value calc(char op, const value &v1,...",1,<empty>,,40,,,2,CASTProblemDeclaration,,<empty>
184683594351,UNKNOWN,3,,"MathLib::value operator+(const MathLib::value &v1, const MathLib::value &v2);",1,<empty>,,149,,,3,CASTProblemDeclaration,,<empty>
184683594352,UNKNOWN,4,,"MathLib::value operator-(const MathLib::value &v1, const MathLib::value &v2);",1,<empty>,,150,,,4,CASTProblemDeclaration,,<empty>
184683594353,UNKNOWN,5,,"MathLib::value operator*(const MathLib::value &v1, const MathLib::value &v2);",1,<empty>,,151,,,5,CASTProblemDeclaration,,<empty>
184683594354,UNKNOWN,6,,"MathLib::value operator/(const MathLib::value &v1, const MathLib::value &v2);",1,<empty>,,152,,,6,CASTProblemDeclaration,,<empty>
184683594355,UNKNOWN,7,,"MathLib::value operator%(const MathLib::value &v1, const MathLib::value &v2);",1,<empty>,,153,,,7,CASTProblemDeclaration,,<empty>
184683594356,UNKNOWN,8,,"MathLib::value operator&(const MathLib::value &v1, const MathLib::value &v2);",1,<empty>,,154,,,8,CASTProblemDeclaration,,<empty>
184683594357,UNKNOWN,9,,"MathLib::value operator|(const MathLib::value &v1, const MathLib::value &v2);",1,<empty>,,155,,,9,CASTProblemDeclaration,,<empty>
184683594358,UNKNOWN,10,,"MathLib::value operator^(const MathLib::value &v1, const MathLib::value &v2);",1,<empty>,,156,,,10,CASTProblemDeclaration,,<empty>
184683594359,UNKNOWN,11,,"MathLib::value operator<<(const MathLib::value &v1, const MathLib::value &v2);",1,<empty>,,157,,,11,CASTProblemDeclaration,,<empty>
184683594360,UNKNOWN,12,,"MathLib::value operator>>(const MathLib::value &v1, const MathLib::value &v2);",1,<empty>,,158,,,12,CASTProblemDeclaration,,<empty>
184683594361,UNKNOWN,13,,template<> CPPCHECKLIB std::string MathLib::toString<MathLib::bigint>(MathLib::bigint value);,1,<empty>,,160,,,13,CASTProblemDeclaration,,<empty>
184683594362,UNKNOWN,14,,template<> CPPCHECKLIB std::string MathLib::toString<MathLib::biguint>(MathLib::biguint value);,1,<empty>,,161,,,14,CASTProblemDeclaration,,<empty>
184683594363,UNKNOWN,15,,template<> CPPCHECKLIB std::string MathLib::toString<double>(double value);,1,<empty>,,162,,,15,CASTProblemDeclaration,,<empty>
184683594364,UNKNOWN,1,,char*,51,<empty>,,245,,,1,CPPASTTypeId,,<empty>
184683594365,UNKNOWN,1,,void,6,<empty>,,361,,,1,CPPASTTypeId,,<empty>
184683594366,UNKNOWN,1,,"class CPPCHECKLIB Path {
public:
    /**
     * Convert path to use native separators.
     * @param path Path string to convert.
     * @return converted path.
     */
    static std::string toNativeSeparators(std::string path);

    /**
     * Convert path to use internal path separators.
     * @param path Path string to convert.
     * @return converted path.
     */
    static std::string fromNativeSeparators(std::string path);

    /**
     * @brief Simplify path ""foo/bar/.."" => ""foo""
     * @param originalPath path to be simplified, must have / -separators.
     * @return simplified path
     */
    static std::string simplifyPath(std::string originalPath);

    /**
     * @brief Lookup the path part from a filename (e.g., '/tmp/a.h' -> '/tmp/', 'a.h' -> '')
     * @param filename filename to lookup, must have / -separators.
     * @return path part of the filename
     */
    static std::string getPathFromFilename(const std::string &filename);

    /**
     * @brief Compare ...",1,<empty>,,41,,,1,CASTProblemDeclaration,,<empty>
184683594367,UNKNOWN,-1,,"enum class Progress : std::uint8_t {
        Continue,
        Break
    };",5,<empty>,,34,,,1,CASTProblemDeclaration,,<empty>
184683594368,UNKNOWN,-1,,"PathAnalysis(const Token* start, const Library& library)
        : start(start), library(&library)
    {}",5,<empty>,,38,,,2,CASTProblemDeclaration,,<empty>
184683594369,UNKNOWN,-1,,void forward(const std::function<Progress(const Info&)>& f) const;,5,<empty>,,50,,,6,CASTProblemDeclaration,,<empty>
184683594370,UNKNOWN,-1,,"Info forwardFind(std::function<bool(const Info&)> pred) const {
        Info result{};
        forward([&](const Info& info) {
            if (pred(info)) {
                result = info;
                return Progress::Break;
            }
            return Progress::Continue;
        });
        return result;
    }",5,<empty>,,52,,,7,CASTProblemDeclaration,,<empty>
184683594371,UNKNOWN,-1,,"private:

    static Progress forwardRecursive(const Token* tok, Info info, const std::function<PathAnalysis::Progress(const Info&)>& f);",1,<empty>,,63,,,8,CASTProblemDeclaration,,<empty>
184683594372,UNKNOWN,-1,,"Progress forwardRange(const Token* startToken, const Token* endToken, Info info, const std::function<Progress(const Info&)>& f) const;",5,<empty>,,66,,,9,CASTProblemDeclaration,,<empty>
184683594373,UNKNOWN,-1,,"static std::pair<bool, bool> checkCond(const Token * tok, bool& known);",5,<empty>,,70,,,10,CASTProblemDeclaration,,<empty>
184683594374,UNKNOWN,5,,"bool reaches(const Token * start, const Token * dest, const Library& library, ErrorPath* errorPath);",1,<empty>,,80,,,5,CASTProblemDeclaration,,<empty>
184683594375,UNKNOWN,1,,"class CPPCHECKLIB PathMatch {
public:

    /**
     * The constructor.
     *
     * If a path is a directory it needs to end with a file separator.
     *
     * @param paths List of masks.
     * @param caseSensitive Match the case of the characters when
     *   matching paths?
     */
    explicit PathMatch(std::vector<std::string> paths, bool caseSensitive = true);

    /**
     * @brief Match path against list of masks.
     *
     * If you want to match a directory the given path needs to end with a path separator.
     *
     * @param path Path to match.
     * @return true if any of the masks match the path, false otherwise.
     */
    bool match(const std::string &path) const;

protected:

    /**
     * @brief Remove filename part from the path.
     * @param path Path to edit.
     * @return path without filename part.
     */
    static std::string removeFilename(const std::string &path);

private:
    std::vector<std::string> mPaths;
    bool mCaseSensitive;
    std::...",1,<empty>,,33,,,1,CASTProblemDeclaration,,<empty>
184683594376,UNKNOWN,1,,"namespace tinyxml2 {
    class XMLDocument;
}",1,<empty>,,39,,,1,CASTProblemDeclaration,,<empty>
184683594377,UNKNOWN,2,,"class CPPCHECKLIB Platform {
private:
    static long long min_value(std::uint8_t bit) {
        assert(bit > 0);
        if (bit >= 64)
            return LLONG_MIN;
        return -(1LL << (bit-1));
    }

    static long long max_value(std::uint8_t bit) {
        assert(bit > 0);
        if (bit >= 64)
            return (~0ULL) >> 1;
        return (1LL << (bit-1)) - 1LL;
    }

    static unsigned long long max_value_unsigned(std::uint8_t bit) {
        assert(bit > 0);
        if (bit >= 64)
            return ~0ULL;
        return (1ULL << bit) - 1ULL;
    }

    /** provides list of defines specified by the limit.h/climits includes */
    std::string getLimitsDefines(bool c99) const;
public:
    Platform();

    bool isIntValue(MathLib::bigint value) const {
        return value >= min_value(int_bit) && value <= max_value(int_bit);
    }

    bool isIntValue(MathLib::biguint value) const {
        const unsigned long long intMax = max_value(int_bit);
        return value <= ...",1,<empty>,,46,,,2,CASTProblemDeclaration,,<empty>
184683594378,UNKNOWN,1,,char,37,<empty>,,978,,,1,CPPASTTypeId,,<empty>
184683594379,UNKNOWN,1,,char,37,<empty>,,979,,,1,CPPASTTypeId,,<empty>
184683594380,UNKNOWN,1,,char,41,<empty>,,986,,,1,CPPASTTypeId,,<empty>
184683594381,UNKNOWN,1,,char,41,<empty>,,987,,,1,CPPASTTypeId,,<empty>
184683594382,UNKNOWN,1,,simplecpp::Token *,20,<empty>,,1036,,,1,CPPASTTypeId,,<empty>
184683594383,UNKNOWN,1,,simplecpp::Token *,20,<empty>,,1037,,,1,CPPASTTypeId,,<empty>
184683594384,UNKNOWN,1,,simplecpp::Token *,20,<empty>,,1038,,,1,CPPASTTypeId,,<empty>
184683594385,UNKNOWN,-1,,explicit DirectiveToken(const simplecpp::Token & _tok);,9,<empty>,,62,,,1,CASTProblemDeclaration,,<empty>
184683594386,UNKNOWN,-1,,std::string tokStr;,9,<empty>,,65,,,4,CASTProblemDeclaration,,<empty>
184683594387,UNKNOWN,-1,,std::string file;,5,<empty>,,53,,,1,CASTProblemDeclaration,,<empty>
184683594388,UNKNOWN,-1,,std::string str;,5,<empty>,,59,,,3,CASTProblemDeclaration,,<empty>
184683594389,UNKNOWN,-1,,std::vector<DirectiveToken> strTokens;,5,<empty>,,68,,,5,CASTProblemDeclaration,,<empty>
184683594390,UNKNOWN,-1,,"Directive(const simplecpp::Location & _loc, std::string _str);",5,<empty>,,71,,,6,CASTProblemDeclaration,,<empty>
184683594391,UNKNOWN,-1,,"Directive(std::string _file, int _linenr, std::string _str);",5,<empty>,,72,,,7,CASTProblemDeclaration,,<empty>
184683594392,UNKNOWN,5,,"class CPPCHECKLIB RemarkComment {
public:
    RemarkComment(std::string file, unsigned int lineNumber, std::string str)
        : file(std::move(file))
        , lineNumber(lineNumber)
        , str(std::move(str))
    {}

    /** name of file */
    std::string file;

    /** line number for the code that the remark comment is about */
    unsigned int lineNumber;

    /** remark text */
    std::string str;
};",1,<empty>,,75,,,5,CASTProblemDeclaration,,<empty>
184683594393,UNKNOWN,6,,"class CPPCHECKLIB WARN_UNUSED Preprocessor {
    // TODO: get rid of this
    friend class PreprocessorHelper;
    friend class TestPreprocessor;
    friend class TestUnusedVar;

public:
    /** character that is inserted in expanded macros */
    static char macroChar;

    explicit Preprocessor(const Settings& settings, ErrorLogger &errorLogger);
    virtual ~Preprocessor();

    void inlineSuppressions(const simplecpp::TokenList &tokens, SuppressionList &suppressions);

    std::list<Directive> createDirectives(const simplecpp::TokenList &tokens) const;

    std::set<std::string> getConfigs(const simplecpp::TokenList &tokens) const;

    std::vector<RemarkComment> getRemarkComments(const simplecpp::TokenList &tokens) const;

    bool loadFiles(const simplecpp::TokenList &rawtokens, std::vector<std::string> &files);

    void removeComments(simplecpp::TokenList &tokens);

    static void setPlatformInfo(simplecpp::TokenList &tokens, const Settings& settings);

    simplecpp::Token...",1,<empty>,,101,,,6,CASTProblemDeclaration,,<empty>
184683594394,UNKNOWN,1,,double,66,<empty>,,578,,,1,CPPASTTypeId,,<empty>
184683594395,UNKNOWN,1,,MathLib::bigint,47,<empty>,,583,,,1,CPPASTTypeId,,<empty>
184683594396,UNKNOWN,1,,T,29,<empty>,,595,,,1,CPPASTTypeId,,<empty>
184683594397,UNKNOWN,1,,std::size_t,66,<empty>,,1475,,,1,CPPASTTypeId,,<empty>
184683594398,UNKNOWN,-1,,std::size_t operator()(ExprIdToken etok) const;,9,<empty>,,96,,,1,CASTProblemDeclaration,,<empty>
184683594399,UNKNOWN,-1,,ExprIdToken() = default;,5,<empty>,,44,,,3,CASTProblemDeclaration,,<empty>
184683594400,UNKNOWN,-1,,),34,<empty>,,51,,,4,CASTProblemDeclaration,,<empty>
184683594401,UNKNOWN,-1,,: exprid(exprid) {},36,<empty>,,51,,,5,CASTProblemDeclaration,,<empty>
184683594402,UNKNOWN,-1,,),32,<empty>,,53,,,6,CASTProblemDeclaration,,<empty>
184683594403,UNKNOWN,-1,,"bool operator==(const ExprIdToken& rhs) const {
        return getExpressionId() == rhs.getExpressionId();
    }",5,<empty>,,55,,,8,CASTProblemDeclaration,,<empty>
184683594404,UNKNOWN,-1,,"bool operator<(const ExprIdToken& rhs) const {
        return getExpressionId() < rhs.getExpressionId();
    }",5,<empty>,,59,,,9,CASTProblemDeclaration,,<empty>
184683594405,UNKNOWN,-1,,"template<class T, class U>
    friend bool operator!=(const T& lhs, const U& rhs)
    {
        return !(lhs == rhs);
    }",5,<empty>,,63,,,10,CASTProblemDeclaration,,<empty>
184683594406,UNKNOWN,-1,,"template<class T, class U>
    friend bool operator<=(const T& lhs, const U& rhs)
    {
        return !(lhs > rhs);
    }",5,<empty>,,69,,,11,CASTProblemDeclaration,,<empty>
184683594407,UNKNOWN,-1,,"template<class T, class U>
    friend bool operator>(const T& lhs, const U& rhs)
    {
        return rhs < lhs;
    }",5,<empty>,,75,,,12,CASTProblemDeclaration,,<empty>
184683594408,UNKNOWN,-1,,"template<class T, class U>
    friend bool operator>=(const T& lhs, const U& rhs)
    {
        return !(lhs < rhs);
    }",5,<empty>,,81,,,13,CASTProblemDeclaration,,<empty>
184683594409,UNKNOWN,-1,,"const Token& operator*() const NOEXCEPT {
        return *tok;
    }",5,<empty>,,87,,,14,CASTProblemDeclaration,,<empty>
184683594410,UNKNOWN,-1,,"const Token* operator->() const NOEXCEPT {
        return tok;
    }",5,<empty>,,91,,,15,CASTProblemDeclaration,,<empty>
184683594411,UNKNOWN,-1,,"using Map = std::unordered_map<ExprIdToken, ValueFlow::Value, ExprIdToken::Hash>;",5,<empty>,,101,,,1,CASTProblemDeclaration,,<empty>
184683594412,UNKNOWN,-1,,),19,<empty>,,103,,,2,CASTProblemDeclaration,,<empty>
184683594413,UNKNOWN,-1,,: mValues(new Map()) {},21,<empty>,,103,,,3,CASTProblemDeclaration,,<empty>
184683594414,UNKNOWN,-1,,),38,<empty>,,105,,,4,CASTProblemDeclaration,,<empty>
184683594415,UNKNOWN,-1,,: mValues(new Map(std::move(values))) {},40,<empty>,,105,,,5,CASTProblemDeclaration,,<empty>
184683594416,UNKNOWN,-1,,"void setValue(const Token* expr, const ValueFlow::Value& value);",5,<empty>,,107,,,6,CASTProblemDeclaration,,<empty>
184683594417,UNKNOWN,-1,,"const ValueFlow::Value* getValue(nonneg int exprid, bool impossible = false) const;",5,<empty>,,108,,,7,CASTProblemDeclaration,,<empty>
184683594418,UNKNOWN,-1,,"bool getIntValue(nonneg int exprid, MathLib::bigint& result) const;",5,<empty>,,110,,,8,CASTProblemDeclaration,,<empty>
184683594419,UNKNOWN,-1,,"void setIntValue(const Token* expr, MathLib::bigint value, bool impossible = false);",5,<empty>,,111,,,9,CASTProblemDeclaration,,<empty>
184683594420,UNKNOWN,-1,,"bool getContainerSizeValue(nonneg int exprid, MathLib::bigint& result) const;",5,<empty>,,113,,,10,CASTProblemDeclaration,,<empty>
184683594421,UNKNOWN,-1,,"bool getContainerEmptyValue(nonneg int exprid, MathLib::bigint& result) const;",5,<empty>,,114,,,11,CASTProblemDeclaration,,<empty>
184683594422,UNKNOWN,-1,,"void setContainerSizeValue(const Token* expr, MathLib::bigint value, bool isEqual = true);",5,<empty>,,115,,,12,CASTProblemDeclaration,,<empty>
184683594423,UNKNOWN,-1,,"bool getTokValue(nonneg int exprid, const Token*& result) const;",5,<empty>,,119,,,13,CASTProblemDeclaration,,<empty>
184683594424,UNKNOWN,-1,,const ValueFlow::Value& at(nonneg int exprid) const;,5,<empty>,,122,,,14,CASTProblemDeclaration,,<empty>
184683594425,UNKNOWN,-1,,ValueFlow::Value& at(nonneg int exprid);,5,<empty>,,123,,,15,CASTProblemDeclaration,,<empty>
184683594426,UNKNOWN,-1,,void erase_if(const std::function<bool(const ExprIdToken&)>& pred);,5,<empty>,,125,,,16,CASTProblemDeclaration,,<empty>
184683594427,UNKNOWN,-1,,void swap(ProgramMemory &pm) NOEXCEPT;,5,<empty>,,127,,,17,CASTProblemDeclaration,,<empty>
184683594428,UNKNOWN,-1,,),16,<empty>,,131,,,18,CASTProblemDeclaration,,<empty>
184683594429,UNKNOWN,-1,,"Map::const_iterator begin() const {
        return mValues->cbegin();
    }",5,<empty>,,135,,,20,CASTProblemDeclaration,,<empty>
184683594430,UNKNOWN,-1,,"Map::const_iterator end() const {
        return mValues->cend();
    }",5,<empty>,,139,,,21,CASTProblemDeclaration,,<empty>
184683594431,UNKNOWN,-1,,"friend bool operator==(const ProgramMemory& x, const ProgramMemory& y) {
        return x.mValues == y.mValues;
    }",5,<empty>,,143,,,22,CASTProblemDeclaration,,<empty>
184683594432,UNKNOWN,-1,,"friend bool operator!=(const ProgramMemory& x, const ProgramMemory& y) {
        return x.mValues != y.mValues;
    }",5,<empty>,,147,,,23,CASTProblemDeclaration,,<empty>
184683594433,UNKNOWN,-1,,"private:
    void copyOnWrite();",1,<empty>,,151,,,24,CASTProblemDeclaration,,<empty>
184683594434,UNKNOWN,-1,,std::shared_ptr<Map> mValues;,5,<empty>,,154,,,25,CASTProblemDeclaration,,<empty>
184683594435,UNKNOWN,-1,,"std::map<nonneg int, const Token*> origins;",5,<empty>,,159,,,2,CASTProblemDeclaration,,<empty>
184683594436,UNKNOWN,-1,,const Settings& settings;,5,<empty>,,160,,,3,CASTProblemDeclaration,,<empty>
184683594437,UNKNOWN,-1,,explicit ProgramMemoryState(const Settings& s);,5,<empty>,,162,,,4,CASTProblemDeclaration,,<empty>
184683594438,UNKNOWN,-1,,"void addState(const Token* tok, const ProgramMemory::Map& vars);",5,<empty>,,166,,,5,CASTProblemDeclaration,,<empty>
184683594439,UNKNOWN,-1,,"ProgramMemory get(const Token* tok, const Token* ctx, const ProgramMemory::Map& vars) const;",5,<empty>,,172,,,6,CASTProblemDeclaration,,<empty>
184683594440,UNKNOWN,7,,"std::vector<ValueFlow::Value> execute(const Scope* scope, ProgramMemory& pm, const Settings& settings);",1,<empty>,,175,,,7,CASTProblemDeclaration,,<empty>
184683594441,UNKNOWN,8,,"void execute(const Token* expr,
             ProgramMemory& programMemory,
             MathLib::bigint* result,
             bool* error,
             const Settings& settings);",1,<empty>,,177,,,8,CASTProblemDeclaration,,<empty>
184683594442,UNKNOWN,9,,"bool conditionIsFalse(const Token* condition, ProgramMemory pm, const Settings& settings);",1,<empty>,,188,,,9,CASTProblemDeclaration,,<empty>
184683594443,UNKNOWN,10,,"bool conditionIsTrue(const Token* condition, ProgramMemory pm, const Settings& settings);",1,<empty>,,195,,,10,CASTProblemDeclaration,,<empty>
184683594444,UNKNOWN,11,,"ProgramMemory getProgramMemory(const Token* tok, const Token* expr, const ValueFlow::Value& value, const Settings& settings);",1,<empty>,,200,,,11,CASTProblemDeclaration,,<empty>
184683594445,UNKNOWN,12,,"ValueFlow::Value evaluateLibraryFunction(const std::unordered_map<nonneg int, ValueFlow::Value>& args,
                                         const std::string& returnValue,
                                         const Settings& settings,
                                         bool cpp);",1,<empty>,,202,,,12,CASTProblemDeclaration,,<empty>
184683594446,UNKNOWN,6,,"template<class T>
class ValuePtr;",1,<empty>,,27,,,6,CASTProblemDeclaration,,<empty>
184683594447,UNKNOWN,7,,"void valueFlowGenericReverse(Token* start, const Token* end, const ValuePtr<Analyzer>& a, const TokenList& tokenlist, ErrorLogger& errorLogger, const Settings& settings);",1,<empty>,,30,,,7,CASTProblemDeclaration,,<empty>
184683594448,UNKNOWN,2,,enum class SHOWTIME_MODES : std::uint8_t;,1,<empty>,,50,,,2,CASTProblemDeclaration,,<empty>
184683594449,UNKNOWN,3,,"namespace ValueFlow {
    class Value;
}",1,<empty>,,51,,,3,CASTProblemDeclaration,,<empty>
184683594450,UNKNOWN,4,,"template<typename T>
class SimpleEnableGroup {
    uint32_t mFlags = 0;
public:
    uint32_t intValue() const {
        return mFlags;
    }
    void clear() {
        mFlags = 0;
    }
    void fill() {
        mFlags = 0xFFFFFFFF;
    }
    bool isEnabled(T flag) const {
        return (mFlags & (1U << (uint32_t)flag)) != 0;
    }
    void enable(T flag) {
        mFlags |= (1U << (uint32_t)flag);
    }
    void enable(SimpleEnableGroup<T> group) {
        mFlags |= group.intValue();
    }
    void disable(T flag) {
        mFlags &= ~(1U << (uint32_t)flag);
    }
    void disable(SimpleEnableGroup<T> group) {
        mFlags &= ~(group.intValue());
    }
    void setEnabled(T flag, bool enabled) {
        if (enabled)
            enable(flag);
        else
            disable(flag);
    }
};",1,<empty>,,58,,,4,CASTProblemDeclaration,,<empty>
184683594451,UNKNOWN,5,,"class CPPCHECKLIB WARN_UNUSED Settings {
private:

    /** @brief terminate checking */
    static std::atomic<bool> mTerminated;

public:
    Settings();

    static std::string loadCppcheckCfg(Settings& settings, Suppressions& suppressions, bool debug = false);

    static std::pair<std::string, std::string> getNameAndVersion(const std::string& productName);

    /** @brief Report type */
    ReportType reportType = ReportType::normal;

    /** @brief addons, either filename of python/json file or json data */
    std::unordered_set<std::string> addons;

    /** @brief the loaded addons infos */
    std::vector<AddonInfo> addonInfos;

    /** @brief Path to the python interpreter to be used to run addons. */
    std::string addonPython;

    /** @brief Paths used as base for conversion to relative paths. */
    std::vector<std::string> basePaths;

    /** @brief --cppcheck-build-dir. Always uses / as path separator. No trailing path separator. */
    std::string buildDir;

    /**...",1,<empty>,,100,,,5,CASTProblemDeclaration,,<empty>
184683594452,UNKNOWN,1,,static constexpr std::size_t DefaultSmallVectorSize = 3;,1,<empty>,,24,,,1,CASTProblemDeclaration,,<empty>
184683594453,UNKNOWN,2,,"template<typename T, std::size_t N = DefaultSmallVectorSize>
using SmallVector = boost::container::small_vector<T, N>;",1,<empty>,,29,,,2,CASTProblemDeclaration,,<empty>
184683594454,UNKNOWN,3,,"template<class T, std::size_t N>
struct TaggedAllocator : std::allocator<T>
{
    template<class ... Ts>
    // cppcheck-suppress noExplicitConstructor
    // NOLINTNEXTLINE(google-explicit-constructor)
    TaggedAllocator(Ts&&... ts)
        : std::allocator<T>(std::forward<Ts>(ts)...)
    {}

    template<class U>
    // cppcheck-suppress noExplicitConstructor
    // NOLINTNEXTLINE(google-explicit-constructor)
    TaggedAllocator(const TaggedAllocator<U, N> /*unused*/) {}

    template<class U>
    struct rebind
    {
        using other = TaggedAllocator<U, N>;
    };
};",1,<empty>,,35,,,3,CASTProblemDeclaration,,<empty>
184683594455,UNKNOWN,4,,"template<typename T, std::size_t N = DefaultSmallVectorSize>
class SmallVector : public std::vector<T, TaggedAllocator<T, N>>
{
public:
    template<class ... Ts>
    // NOLINTNEXTLINE(google-explicit-constructor)
    SmallVector(Ts&&... ts)
        : std::vector<T, TaggedAllocator<T, N>>(std::forward<Ts>(ts)...)
    {
        this->reserve(N);
    }
};",1,<empty>,,57,,,4,CASTProblemDeclaration,,<empty>
184683594456,UNKNOWN,-1,,"static SourceLocation current(std::uint_least32_t line = __builtin_LINE(),
                                  std::uint_least32_t column = __builtin_COLUMN(),
                                  const char* file_name = __builtin_FILE(),
                                  const char* function_name = __builtin_FUNCTION())
    {
        SourceLocation result{};
        result.m_line = line;
        result.m_column = column;
        result.m_file_name = file_name;
        result.m_function_name = function_name;
        return result;
    }",5,<empty>,,62,,,1,CASTProblemDeclaration,,<empty>
184683594457,UNKNOWN,-1,,std::uint_least32_t m_line = 0;,5,<empty>,,79,,,3,CASTProblemDeclaration,,<empty>
184683594458,UNKNOWN,-1,,std::uint_least32_t m_column = 0;,5,<empty>,,80,,,4,CASTProblemDeclaration,,<empty>
184683594459,UNKNOWN,-1,,"std::uint_least32_t line() const {
        return m_line;
    }",5,<empty>,,83,,,7,CASTProblemDeclaration,,<empty>
184683594460,UNKNOWN,-1,,"std::uint_least32_t column() const {
        return m_column;
    }",5,<empty>,,86,,,8,CASTProblemDeclaration,,<empty>
184683594461,UNKNOWN,-1,,),27,<empty>,,89,,,9,CASTProblemDeclaration,,<empty>
184683594462,UNKNOWN,-1,,"const {
        return m_file_name;
    }",29,<empty>,,89,,,10,CASTProblemDeclaration,,<empty>
184683594463,UNKNOWN,-1,,),31,<empty>,,92,,,11,CASTProblemDeclaration,,<empty>
184683594464,UNKNOWN,-1,,"const {
        return m_function_name;
    }",33,<empty>,,92,,,12,CASTProblemDeclaration,,<empty>
184683594465,UNKNOWN,1,,using SourceLocation = std::source_location;,1,<empty>,,54,,,1,CASTProblemDeclaration,,<empty>
184683594466,UNKNOWN,2,,using SourceLocation = std::experimental::source_location;,1,<empty>,,57,,,2,CASTProblemDeclaration,,<empty>
184683594467,UNKNOWN,-1,,"enum Language : std::uint8_t { None, C, CPP };",5,<empty>,,38,,,1,CASTProblemDeclaration,,<empty>
184683594468,UNKNOWN,-1,,"enum cstd_t : std::uint8_t { C89, C99, C11, C17, C23, CLatest = C23 }",5,<empty>,,41,,,2,CASTProblemDeclaration,,<empty>
184683594469,UNKNOWN,-1,,"enum cppstd_t : std::uint8_t { CPP03, CPP11, CPP14, CPP17, CPP20, CPP23, CPP26, CPPLatest = CPP26 }",5,<empty>,,44,,,4,CASTProblemDeclaration,,<empty>
184683594470,UNKNOWN,-1,,std::string stdValueC;,5,<empty>,,47,,,6,CASTProblemDeclaration,,<empty>
184683594471,UNKNOWN,-1,,std::string stdValueCPP;,5,<empty>,,50,,,7,CASTProblemDeclaration,,<empty>
184683594472,UNKNOWN,-1,,bool setC(std::string str);,5,<empty>,,52,,,8,CASTProblemDeclaration,,<empty>
184683594473,UNKNOWN,-1,,std::string getC() const;,5,<empty>,,53,,,9,CASTProblemDeclaration,,<empty>
184683594474,UNKNOWN,-1,,static std::string getC(cstd_t c_std);,5,<empty>,,54,,,10,CASTProblemDeclaration,,<empty>
184683594475,UNKNOWN,-1,,static cstd_t getC(const std::string &std);,5,<empty>,,55,,,11,CASTProblemDeclaration,,<empty>
184683594476,UNKNOWN,-1,,bool setCPP(std::string str);,5,<empty>,,56,,,12,CASTProblemDeclaration,,<empty>
184683594477,UNKNOWN,-1,,std::string getCPP() const;,5,<empty>,,57,,,13,CASTProblemDeclaration,,<empty>
184683594478,UNKNOWN,-1,,static std::string getCPP(cppstd_t std);,5,<empty>,,58,,,14,CASTProblemDeclaration,,<empty>
184683594479,UNKNOWN,-1,,static cppstd_t getCPP(const std::string &std);,5,<empty>,,59,,,15,CASTProblemDeclaration,,<empty>
184683594480,UNKNOWN,-1,,bool setStd(const std::string& str);,5,<empty>,,60,,,16,CASTProblemDeclaration,,<empty>
184683594481,UNKNOWN,2,,"namespace Summaries {
    CPPCHECKLIB std::string create(const Tokenizer &tokenizer, const std::string &cfg);
    CPPCHECKLIB void loadReturn(const std::string &buildDir, std::set<std::string> &summaryReturn);
}",1,<empty>,,31,,,2,CASTProblemDeclaration,,<empty>
184683594482,UNKNOWN,4,,enum class Certainty : std::uint8_t;,1,<empty>,,38,,,4,CASTProblemDeclaration,,<empty>
184683594483,UNKNOWN,6,,"class CPPCHECKLIB SuppressionList {
public:

    enum class Type : std::uint8_t {
        unique, file, block, blockBegin, blockEnd, macro
    };

    struct CPPCHECKLIB ErrorMessage {
        std::size_t hash;
        std::string errorId;
        void setFileName(std::string s);
        const std::string &getFileName() const {
            return mFileName;
        }
        int lineNumber;
        Certainty certainty;
        std::string symbolNames;
        std::set<std::string> macroNames;

        static SuppressionList::ErrorMessage fromErrorMessage(const ::ErrorMessage &msg, const std::set<std::string> &macroNames);
    private:
        std::string mFileName;
    };

    struct CPPCHECKLIB Suppression {
        Suppression() = default;
        Suppression(std::string id, std::string file, int line=NO_LINE) : errorId(std::move(id)), fileName(std::move(file)), lineNumber(line) {}

        bool operator<(const Suppression &other) const {
            if (errorId != other.errorId)
...",1,<empty>,,45,,,6,CASTProblemDeclaration,,<empty>
184683594484,UNKNOWN,1,,Scope*,36,<empty>,,516,,,1,CPPASTTypeId,,<empty>
184683594485,UNKNOWN,1,,Token *,20,<empty>,,1102,,,1,CPPASTTypeId,,<empty>
184683594486,UNKNOWN,1,,Token *,37,<empty>,,1104,,,1,CPPASTTypeId,,<empty>
184683594487,UNKNOWN,1,,Token *,32,<empty>,,1144,,,1,CPPASTTypeId,,<empty>
184683594488,UNKNOWN,1,,Token *,32,<empty>,,1147,,,1,CPPASTTypeId,,<empty>
184683594489,UNKNOWN,1,,Function *,28,<empty>,,1170,,,1,CPPASTTypeId,,<empty>
184683594490,UNKNOWN,1,,Token *,44,<empty>,,1196,,,1,CPPASTTypeId,,<empty>
184683594491,UNKNOWN,1,,Token *,24,<empty>,,1417,,,1,CPPASTTypeId,,<empty>
184683594492,UNKNOWN,1,,Token *,40,<empty>,,1435,,,1,CPPASTTypeId,,<empty>
184683594493,UNKNOWN,1,,Token*,37,<empty>,,1704,,,1,CPPASTTypeId,,<empty>
184683594494,UNKNOWN,1,,Token*,37,<empty>,,1727,,,1,CPPASTTypeId,,<empty>
184683594495,UNKNOWN,1,,Token*,37,<empty>,,1759,,,1,CPPASTTypeId,,<empty>
184683594496,UNKNOWN,1,,Dimension &,42,<empty>,,1798,,,1,CPPASTTypeId,,<empty>
184683594497,UNKNOWN,1,,Function *,39,<empty>,,3244,,,1,CPPASTTypeId,,<empty>
184683594498,UNKNOWN,1,,Function *,42,<empty>,,3400,,,1,CPPASTTypeId,,<empty>
184683594499,UNKNOWN,1,,Token *,60,<empty>,,3748,,,1,CPPASTTypeId,,<empty>
184683594500,UNKNOWN,1,,Token *,24,<empty>,,4546,,,1,CPPASTTypeId,,<empty>
184683594501,UNKNOWN,1,,Token *,24,<empty>,,5002,,,1,CPPASTTypeId,,<empty>
184683594502,UNKNOWN,1,,S&,70,<empty>,,6220,,,1,CPPASTTypeId,,<empty>
184683594503,UNKNOWN,1,,S*,31,<empty>,,6232,,,1,CPPASTTypeId,,<empty>
184683594504,UNKNOWN,1,,Function *,23,<empty>,,6559,,,1,CPPASTTypeId,,<empty>
184683594505,UNKNOWN,1,,Variable *,40,<empty>,,6777,,,1,CPPASTTypeId,,<empty>
184683594506,UNKNOWN,1,,Variable *,36,<empty>,,6948,,,1,CPPASTTypeId,,<empty>
184683594507,UNKNOWN,1,,Variable *,41,<empty>,,7022,,,1,CPPASTTypeId,,<empty>
184683594508,UNKNOWN,1,,Variable*,24,<empty>,,7053,,,1,CPPASTTypeId,,<empty>
184683594509,UNKNOWN,1,,Variable*,28,<empty>,,7828,,,1,CPPASTTypeId,,<empty>
184683594510,UNKNOWN,-1,,const Token* tok{};,5,<empty>,,67,,,1,CASTProblemDeclaration,,<empty>
184683594511,UNKNOWN,-1,,MathLib::bigint num{};,5,<empty>,,68,,,2,CASTProblemDeclaration,,<empty>
184683594512,UNKNOWN,-1,,),45,<empty>,,163,,,1,CASTProblemDeclaration,,<empty>
184683594513,UNKNOWN,-1,,: scope(scope_) {},47,<empty>,,163,,,2,CASTProblemDeclaration,,<empty>
184683594514,UNKNOWN,-1,,const Token* name{};,5,<empty>,,165,,,4,CASTProblemDeclaration,,<empty>
184683594515,UNKNOWN,-1,,MathLib::bigint value{};,5,<empty>,,166,,,5,CASTProblemDeclaration,,<empty>
184683594516,UNKNOWN,-1,,const Token* start{};,5,<empty>,,167,,,6,CASTProblemDeclaration,,<empty>
184683594517,UNKNOWN,-1,,const Token* end{};,5,<empty>,,168,,,7,CASTProblemDeclaration,,<empty>
184683594518,UNKNOWN,-1,,bool value_known{};,5,<empty>,,169,,,8,CASTProblemDeclaration,,<empty>
184683594519,UNKNOWN,9,,"enum class Reference : std::uint8_t {
    None,
    LValue,
    RValue
};",1,<empty>,,52,,,9,CASTProblemDeclaration,,<empty>
184683594520,UNKNOWN,10,,"enum class AccessControl : std::uint8_t { Public, Protected, Private, Global, Namespace, Argument, Local, Throw };",1,<empty>,,61,,,10,CASTProblemDeclaration,,<empty>
184683594521,UNKNOWN,12,,"class CPPCHECKLIB Type {
public:
    const Token* classDef;     ///< Points to ""class"" token
    const Scope* classScope;
    const Scope* enclosingScope;
    enum class NeedInitialization : std::uint8_t {
        Unknown, True, False
    } needInitialization = NeedInitialization::Unknown;

    struct BaseInfo {
        std::string name;
        const Type* type{};
        const Token* nameTok{};
        AccessControl access{};  // public/protected/private
        bool isVirtual{};
        // allow ordering within containers
        bool operator<(const BaseInfo& rhs) const {
            return this->type < rhs.type;
        }
    };

    struct FriendInfo {
        const Token* nameStart{};
        const Token* nameEnd{};
        const Type* type{};
    };

    std::vector<BaseInfo> derivedFrom;
    std::vector<FriendInfo> friendList;

    const Token* typeStart{};
    const Token* typeEnd{};
    MathLib::bigint sizeOf{};

    explicit Type(const Token* classDef_ = nullptr, const S...",1,<empty>,,73,,,12,CASTProblemDeclaration,,<empty>
184683594522,UNKNOWN,14,,"class CPPCHECKLIB Variable {
    /** @brief flags mask used to access specific bit. */
    enum {
        fIsMutable    = (1 << 0),   /** @brief mutable variable */
        fIsStatic     = (1 << 1),   /** @brief static variable */
        fIsConst      = (1 << 2),   /** @brief const variable */
        fIsExtern     = (1 << 3),   /** @brief extern variable */
        fIsClass      = (1 << 4),   /** @brief user defined type */
        fIsArray      = (1 << 5),   /** @brief array variable */
        fIsPointer    = (1 << 6),   /** @brief pointer variable */
        fIsReference  = (1 << 7),   /** @brief reference variable */
        fIsRValueRef  = (1 << 8),   /** @brief rvalue reference variable */
        fHasDefault   = (1 << 9),   /** @brief function argument with default value */
        fIsStlType    = (1 << 10),  /** @brief STL type ('std::') */
        fIsStlString  = (1 << 11),  /** @brief std::string|wstring|basic_string&lt;T&gt;|u16string|u32string */
        fIsFloatType  ...",1,<empty>,,173,,,14,CASTProblemDeclaration,,<empty>
184683594523,UNKNOWN,15,,"enum class FunctionType : std::uint8_t { eConstructor, eCopyConstructor, eMoveConstructor, eOperatorEqual, eDestructor, eFunction, eLambda };",1,<empty>,,707,,,15,CASTProblemDeclaration,,<empty>
184683594524,UNKNOWN,16,,"class CPPCHECKLIB Function {
    // only symbol database can change this
    friend class SymbolDatabase;

    /** @brief flags mask used to access specific bit. */
    enum {
        fHasBody               = (1 << 0),  ///< @brief has implementation
        fIsInline              = (1 << 1),  ///< @brief implementation in class definition
        fIsConst               = (1 << 2),  ///< @brief is const
        fHasVirtualSpecifier   = (1 << 3),  ///< @brief does declaration contain 'virtual' specifier
        fIsPure                = (1 << 4),  ///< @brief is pure virtual
        fIsStatic              = (1 << 5),  ///< @brief is static
        fIsStaticLocal         = (1 << 6),  ///< @brief is static local
        fIsExtern              = (1 << 7),  ///< @brief is extern
        fIsFriend              = (1 << 8),  ///< @brief is friend
        fIsExplicit            = (1 << 9),  ///< @brief is explicit
        fIsDefault             = (1 << 10), ///< @brief is default
        fIsD...",1,<empty>,,709,,,16,CASTProblemDeclaration,,<empty>
184683594525,UNKNOWN,17,,"enum class ScopeType : std::uint8_t { eGlobal, eClass, eStruct, eUnion, eNamespace, eFunction, eIf, eElse, eFor, eWhile, eDo, eSwitch, eUnconditional, eTry, eCatch, eLambda, eEnum };",1,<empty>,,1029,,,17,CASTProblemDeclaration,,<empty>
184683594526,UNKNOWN,18,,"class CPPCHECKLIB Scope {
    // let tests access private function for testing
    friend class TestSymbolDatabase;

public:
    struct UsingInfo {
        const Token *start;
        const Scope *scope;
    };

    Scope(const SymbolDatabase *check_, const Token *classDef_, const Scope *nestedIn_);
    Scope(const SymbolDatabase *check_, const Token *classDef_, const Scope *nestedIn_, ScopeType type_, const Token *start_);

    const SymbolDatabase* check{};
    std::string className;
    const Token* classDef{};   ///< class/struct/union/namespace token
    const Token* bodyStart{};  ///< '{' token
    const Token* bodyEnd{};    ///< '}' token
    std::list<Function> functionList;
    std::multimap<std::string, const Function *> functionMap;
    std::list<Variable> varlist;
    const Scope* nestedIn{};
    std::vector<Scope *> nestedList;
    nonneg int numConstructors{};
    nonneg int numCopyOrMoveConstructors{};
    std::vector<UsingInfo> usingList;
    ScopeType type{};
    Ty...",1,<empty>,,1031,,,18,CASTProblemDeclaration,,<empty>
184683594527,UNKNOWN,19,,"class CPPCHECKLIB ValueType {
public:
    enum Sign : std::uint8_t { UNKNOWN_SIGN, SIGNED, UNSIGNED } sign = UNKNOWN_SIGN;
    enum Type : std::uint8_t {
        UNKNOWN_TYPE,
        POD,
        NONSTD,
        RECORD,
        SMART_POINTER,
        CONTAINER,
        ITERATOR,
        VOID,
        BOOL,
        CHAR,
        SHORT,
        WCHAR_T,
        INT,
        LONG,
        LONGLONG,
        UNKNOWN_INT,
        FLOAT,
        DOUBLE,
        LONGDOUBLE
    } type = UNKNOWN_TYPE;
    nonneg int bits{};                         ///< bitfield bitcount
    nonneg int pointer{};                      ///< 0=>not pointer, 1=>*, 2=>**, 3=>***, etc
    nonneg int constness{};                    ///< bit 0=data, bit 1=*, bit 2=**
    nonneg int volatileness{};                 ///< bit 0=data, bit 1=*, bit 2=**
    Reference reference = Reference::None;     ///< Is the outermost indirection of this type a reference or rvalue
    ///< reference or not? pointer=2, Reference=LValue w...",1,<empty>,,1217,,,19,CASTProblemDeclaration,,<empty>
184683594528,UNKNOWN,20,,"class CPPCHECKLIB SymbolDatabase {
    friend class TestSymbolDatabase;
public:
    SymbolDatabase(Tokenizer& tokenizer, const Settings& settings, ErrorLogger& errorLogger);
    ~SymbolDatabase();

    /** @brief Information about all namespaces/classes/structures */
    std::list<Scope> scopeList;

    /** @brief Fast access to function scopes */
    std::vector<const Scope*> functionScopes;

    /** @brief Fast access to class and struct scopes */
    std::vector<const Scope*> classAndStructScopes;

    /** @brief Fast access to types */
    std::list<Type> typeList;

    /**
     * @brief find a variable type if it's a user defined type
     * @param start scope to start looking in
     * @param typeTok token containing variable type
     * @return pointer to type if found or NULL if not found
     */
    const Type* findVariableType(const Scope* start, const Token* typeTok) const;

    /**
     * @brief find a function
     * @param tok token of function call
     * @return poin...",1,<empty>,,1328,,,20,CASTProblemDeclaration,,<empty>
184683594529,UNKNOWN,1,,Token *,36,<empty>,,1393,,,1,CPPASTTypeId,,<empty>
184683594530,UNKNOWN,1,,Token *,34,<empty>,,3264,,,1,CPPASTTypeId,,<empty>
184683594531,UNKNOWN,1,,Token *,66,<empty>,,3557,,,1,CPPASTTypeId,,<empty>
184683594532,UNKNOWN,7,,"class CPPCHECKLIB TemplateSimplifier {
    friend class TestSimplifyTemplate;

public:
    explicit TemplateSimplifier(Tokenizer &tokenizer);

    const std::string& dump() const {
        return mDump;
    }

    /**
     */
    void checkComplicatedSyntaxErrorsInTemplates();

    /**
     * is the token pointing at a template parameters block
     * < int , 3 > => yes
     * \\param tok start token that must point at ""<""
     * \\return number of parameters (invalid parameters => 0)
     */
    static unsigned int templateParameters(const Token *tok);

    /**
     * Token and its full scopename
     */
    class TokenAndName {
        Token *mToken;
        std::string mScope;
        std::string mName;
        std::string mFullName;
        const Token *mNameToken;
        const Token *mParamEnd;
        unsigned int mFlags;

        enum : std::uint16_t {
            fIsClass                 = (1 << 0), // class template
            fIsFunction              = (1 << 1), // functio...",1,<empty>,,47,,,7,CASTProblemDeclaration,,<empty>
184683594533,UNKNOWN,1,,double,42,<empty>,,65,,,1,CPPASTTypeId,,<empty>
184683594534,UNKNOWN,1,,double,33,<empty>,,130,,,1,CPPASTTypeId,,<empty>
184683594535,UNKNOWN,1,,double,33,<empty>,,134,,,1,CPPASTTypeId,,<empty>
184683594536,UNKNOWN,-1,,std::clock_t mClocks{};,5,<empty>,,50,,,1,CASTProblemDeclaration,,<empty>
184683594537,UNKNOWN,-1,,long mNumberOfResults{};,5,<empty>,,51,,,2,CASTProblemDeclaration,,<empty>
184683594538,UNKNOWN,-1,,),20,<empty>,,53,,,3,CASTProblemDeclaration,,<empty>
184683594539,UNKNOWN,-1,,"const {
        const double ret = (double)((unsigned long)mClocks) / (double)CLOCKS_PER_SEC;
        return ret;
    }",22,<empty>,,53,,,4,CASTProblemDeclaration,,<empty>
184683594540,UNKNOWN,1,,"enum class SHOWTIME_MODES : std::uint8_t {
    SHOWTIME_NONE,
    SHOWTIME_FILE,
    SHOWTIME_FILE_TOTAL,
    SHOWTIME_SUMMARY,
    SHOWTIME_TOP5_SUMMARY,
    SHOWTIME_TOP5_FILE
};",1,<empty>,,33,,,1,CASTProblemDeclaration,,<empty>
184683594541,UNKNOWN,2,,"class CPPCHECKLIB TimerResultsIntf {
public:
    virtual ~TimerResultsIntf() = default;

    virtual void addResults(const std::string& str, std::clock_t clocks) = 0;
};",1,<empty>,,42,,,2,CASTProblemDeclaration,,<empty>
184683594542,UNKNOWN,4,,"class CPPCHECKLIB TimerResults : public TimerResultsIntf {
public:
    TimerResults() = default;

    void showResults(SHOWTIME_MODES mode) const;
    void addResults(const std::string& str, std::clock_t clocks) override;

    void reset();

private:
    std::map<std::string, TimerResultsData> mResults;
    mutable std::mutex mResultsSync;
};",1,<empty>,,59,,,4,CASTProblemDeclaration,,<empty>
184683594543,UNKNOWN,5,,"class CPPCHECKLIB Timer {
public:
    Timer(std::string str, SHOWTIME_MODES showtimeMode, TimerResultsIntf* timerResults = nullptr);
    Timer(bool fileTotal, std::string filename);
    ~Timer();

    Timer(const Timer&) = delete;
    Timer& operator=(const Timer&) = delete;

    void stop();

    static void run(std::string str, SHOWTIME_MODES showtimeMode, TimerResultsIntf* timerResults, const std::function<void()>& f) {
        Timer t(std::move(str), showtimeMode, timerResults);
        f();
    }

private:
    const std::string mStr;
    TimerResultsIntf* mTimerResults{};
    std::clock_t mStart = std::clock();
    const SHOWTIME_MODES mShowTimeMode = SHOWTIME_MODES::SHOWTIME_FILE_TOTAL;
    bool mStopped{};
};",1,<empty>,,73,,,5,CASTProblemDeclaration,,<empty>
184683594544,UNKNOWN,1,,unsigned char,32,<empty>,,125,,,1,CPPASTTypeId,,<empty>
184683594545,UNKNOWN,1,,const char*,36,<empty>,,607,,,1,CPPASTTypeId,,<empty>
184683594546,UNKNOWN,1,,int,26,<empty>,,764,,,1,CPPASTTypeId,,<empty>
184683594547,UNKNOWN,1,,Token*,23,<empty>,,929,,,1,CPPASTTypeId,,<empty>
184683594548,UNKNOWN,1,,const Token*,43,<empty>,,929,,,1,CPPASTTypeId,,<empty>
184683594549,UNKNOWN,1,,Token*,23,<empty>,,961,,,1,CPPASTTypeId,,<empty>
184683594550,UNKNOWN,1,,const Token*,43,<empty>,,961,,,1,CPPASTTypeId,,<empty>
184683594551,UNKNOWN,1,,MathLib::biguint,63,<empty>,,1805,,,1,CPPASTTypeId,,<empty>
184683594552,UNKNOWN,1,,void,14,<empty>,,2149,,,1,CPPASTTypeId,,<empty>
184683594553,UNKNOWN,1,,Token*,42,<empty>,,2714,,,1,CPPASTTypeId,,<empty>
184683594554,UNKNOWN,-1,,"ScopeInfo2(std::string name_, const Token *bodyEnd_, std::set<std::string> usingNamespaces_ = std::set<std::string>()) : name(std::move(name_)), bodyEnd(bodyEnd_), usingNamespaces(std::move(usingNamespaces_)) {}",5,<empty>,,57,,,1,CASTProblemDeclaration,,<empty>
184683594555,UNKNOWN,-1,,std::string name;,5,<empty>,,58,,,2,CASTProblemDeclaration,,<empty>
184683594556,UNKNOWN,-1,,const Token* const bodyEnd{};,5,<empty>,,59,,,3,CASTProblemDeclaration,,<empty>
184683594557,UNKNOWN,-1,,std::set<std::string> usingNamespaces;,5,<empty>,,60,,,4,CASTProblemDeclaration,,<empty>
184683594558,UNKNOWN,-1,,const ::Type* mType;,9,<empty>,,96,,,3,CASTProblemDeclaration,,<empty>
184683594559,UNKNOWN,-1,,"enum Type : std::uint8_t { LOW, HIGH }",9,<empty>,,121,,,1,CASTProblemDeclaration,,<empty>
184683594560,UNKNOWN,-1,,MathLib::bigint value{};,9,<empty>,,122,,,3,CASTProblemDeclaration,,<empty>
184683594561,UNKNOWN,-1,,CppcheckAttributes* next{};,9,<empty>,,123,,,4,CASTProblemDeclaration,,<empty>
184683594562,UNKNOWN,-1,,int mVarId{};,12,<empty>,,66,,,1,CASTProblemDeclaration,,<empty>
184683594563,UNKNOWN,-1,,int mFileIndex{};,12,<empty>,,67,,,2,CASTProblemDeclaration,,<empty>
184683594564,UNKNOWN,-1,,int mLineNumber{};,12,<empty>,,68,,,3,CASTProblemDeclaration,,<empty>
184683594565,UNKNOWN,-1,,int mColumn{};,12,<empty>,,69,,,4,CASTProblemDeclaration,,<empty>
184683594566,UNKNOWN,-1,,int mExprId{};,12,<empty>,,70,,,5,CASTProblemDeclaration,,<empty>
184683594567,UNKNOWN,-1,,int mProgressValue{};,12,<empty>,,76,,,6,CASTProblemDeclaration,,<empty>
184683594568,UNKNOWN,-1,,int mIndex{};,12,<empty>,,81,,,7,CASTProblemDeclaration,,<empty>
184683594569,UNKNOWN,-1,,unsigned char mBits{};,5,<empty>,,84,,,8,CASTProblemDeclaration,,<empty>
184683594570,UNKNOWN,-1,,Token* mAstOperand1{};,5,<empty>,,87,,,9,CASTProblemDeclaration,,<empty>
184683594571,UNKNOWN,-1,,Token* mAstOperand2{};,5,<empty>,,88,,,10,CASTProblemDeclaration,,<empty>
184683594572,UNKNOWN,-1,,Token* mAstParent{};,5,<empty>,,89,,,11,CASTProblemDeclaration,,<empty>
184683594573,UNKNOWN,-1,,const Scope* mScope{};,5,<empty>,,92,,,12,CASTProblemDeclaration,,<empty>
184683594574,UNKNOWN,-1,,std::string* mOriginalName{};,5,<empty>,,101,,,14,CASTProblemDeclaration,,<empty>
184683594575,UNKNOWN,-1,,std::string* mMacroName{};,5,<empty>,,104,,,15,CASTProblemDeclaration,,<empty>
184683594576,UNKNOWN,-1,,ValueType* mValueType{};,5,<empty>,,107,,,16,CASTProblemDeclaration,,<empty>
184683594577,UNKNOWN,-1,,std::list<ValueFlow::Value>* mValues{};,5,<empty>,,110,,,17,CASTProblemDeclaration,,<empty>
184683594578,UNKNOWN,-1,,static const std::list<ValueFlow::Value> mEmptyValueList;,5,<empty>,,111,,,18,CASTProblemDeclaration,,<empty>
184683594579,UNKNOWN,-1,,std::set<TemplateSimplifier::TokenAndName*>* mTemplateSimplifierPointers{};,5,<empty>,,114,,,19,CASTProblemDeclaration,,<empty>
184683594580,UNKNOWN,-1,,std::shared_ptr<ScopeInfo2> mScopeInfo;,5,<empty>,,117,,,20,CASTProblemDeclaration,,<empty>
184683594581,UNKNOWN,-1,,CppcheckAttributes* mCppcheckAttributes{};,5,<empty>,,125,,,22,CASTProblemDeclaration,,<empty>
184683594582,UNKNOWN,-1,,std::unique_ptr<std::vector<std::string>> mAttributeAlignas;,5,<empty>,,128,,,23,CASTProblemDeclaration,,<empty>
184683594583,UNKNOWN,-1,,"void addAttributeAlignas(const std::string& a) {
        if (!mAttributeAlignas)
            mAttributeAlignas = std::unique_ptr<std::vector<std::string>>(new std::vector<std::string>());
        if (std::find(mAttributeAlignas->cbegin(), mAttributeAlignas->cend(), a) == mAttributeAlignas->cend())
            mAttributeAlignas->push_back(a);
    }",5,<empty>,,129,,,24,CASTProblemDeclaration,,<empty>
184683594584,UNKNOWN,-1,,std::string mAttributeCleanup;,5,<empty>,,136,,,25,CASTProblemDeclaration,,<empty>
184683594585,UNKNOWN,-1,,"enum class Cpp11init : std::uint8_t { UNKNOWN, CPP11INIT, NOINIT }",5,<empty>,,139,,,26,CASTProblemDeclaration,,<empty>
184683594586,UNKNOWN,-1,,mCpp11init = Cpp11init::UNKNOWN;,72,<empty>,,139,,,27,CASTProblemDeclaration,,<empty>
184683594587,UNKNOWN,-1,,TokenDebug mDebug{};,5,<empty>,,141,,,28,CASTProblemDeclaration,,<empty>
184683594588,UNKNOWN,-1,,"void setCppcheckAttribute(CppcheckAttributes::Type type, MathLib::bigint value);",5,<empty>,,143,,,29,CASTProblemDeclaration,,<empty>
184683594589,UNKNOWN,-1,,"bool getCppcheckAttribute(CppcheckAttributes::Type type, MathLib::bigint &value) const;",5,<empty>,,144,,,30,CASTProblemDeclaration,,<empty>
184683594590,UNKNOWN,-1,,),15,<empty>,,146,,,31,CASTProblemDeclaration,,<empty>
184683594591,UNKNOWN,-1,,: mFunction(nullptr) {},17,<empty>,,146,,,32,CASTProblemDeclaration,,<empty>
184683594592,UNKNOWN,-1,,~TokenImpl();,5,<empty>,,148,,,33,CASTProblemDeclaration,,<empty>
184683594593,UNKNOWN,12,,"enum class TokenDebug : std::uint8_t { None, ValueFlow, ValueType };",1,<empty>,,63,,,12,CASTProblemDeclaration,,<empty>
184683594594,UNKNOWN,14,,"class CPPCHECKLIB Token {
    friend class TestToken;

private:
    TokensFrontBack& mTokensFrontBack;

    static const std::string mEmptyString;

public:
    Token(const Token &) = delete;
    Token& operator=(const Token &) = delete;

    enum Type : std::uint8_t {
        eVariable, eType, eFunction, eKeyword, eName, // Names: Variable (varId), Type (typeId, later), Function (FuncId, later), Language keyword, Name (unknown identifier)
        eNumber, eString, eChar, eBoolean, eLiteral, eEnumerator, // Literals: Number, String, Character, Boolean, User defined literal (C++11), Enumerator
        eArithmeticalOp, eComparisonOp, eAssignmentOp, eLogicalOp, eBitOp, eIncDecOp, eExtendedOp, // Operators: Arithmetical, Comparison, Assignment, Logical, Bitwise, ++/--, Extended
        eBracket, // {, }, <, >: < and > only if link() is set. Otherwise they are comparison operators.
        eLambda, // A function without a name
        eEllipsis, // ""...""
        eOther,
        eNone
    ...",1,<empty>,,164,,,14,CASTProblemDeclaration,,<empty>
184683594595,UNKNOWN,1,,Token*,23,<empty>,,503,,,1,CPPASTTypeId,,<empty>
184683594596,UNKNOWN,1,,const Token*,54,<empty>,,503,,,1,CPPASTTypeId,,<empty>
184683594597,UNKNOWN,1,,Token*,34,<empty>,,2667,,,1,CPPASTTypeId,,<empty>
184683594598,UNKNOWN,1,,Token*,35,<empty>,,3042,,,1,CPPASTTypeId,,<empty>
184683594599,UNKNOWN,1,,Token*,36,<empty>,,3862,,,1,CPPASTTypeId,,<empty>
184683594600,UNKNOWN,1,,Variable*,24,<empty>,,3876,,,1,CPPASTTypeId,,<empty>
184683594601,UNKNOWN,1,,Token *,34,<empty>,,3950,,,1,CPPASTTypeId,,<empty>
184683594602,UNKNOWN,1,,Token*,51,<empty>,,5162,,,1,CPPASTTypeId,,<empty>
184683594603,UNKNOWN,1,,Token *,40,<empty>,,5218,,,1,CPPASTTypeId,,<empty>
184683594604,UNKNOWN,1,,Token *,34,<empty>,,7584,,,1,CPPASTTypeId,,<empty>
184683594605,UNKNOWN,1,,unsigned char,14,<empty>,,8145,,,1,CPPASTTypeId,,<empty>
184683594606,UNKNOWN,1,,unsigned char,45,<empty>,,8947,,,1,CPPASTTypeId,,<empty>
184683594607,UNKNOWN,1,,char,55,<empty>,,8959,,,1,CPPASTTypeId,,<empty>
184683594608,UNKNOWN,1,,char,49,<empty>,,8966,,,1,CPPASTTypeId,,<empty>
184683594609,UNKNOWN,1,,unsigned char,43,<empty>,,9935,,,1,CPPASTTypeId,,<empty>
184683594610,UNKNOWN,8,,enum class Severity : std::uint8_t;,1,<empty>,,41,,,8,CASTProblemDeclaration,,<empty>
184683594611,UNKNOWN,9,,"class CPPCHECKLIB Tokenizer {

    friend class SymbolDatabase;
    friend class TemplateSimplifier;

    friend class TestSimplifyTemplate;
    friend class TestSimplifyTypedef;
    friend class TestTokenizer;

public:
    explicit Tokenizer(const Settings & settings, ErrorLogger &errorLogger);
    ~Tokenizer();

    void setTimerResults(TimerResults *tr) {
        mTimerResults = tr;
    }

    /** Is the code C. Used for bailouts */
    bool isC() const {
        return list.isC();
    }

    /** Is the code CPP. Used for bailouts */
    bool isCPP() const {
        return list.isCPP();
    }

    /**
     * Check if inner scope ends with a call to a noreturn function
     * \\param endScopeToken The '}' token
     * \\param unknown set to true if it's unknown if the scope is noreturn
     * \\return true if scope ends with a function call that might be 'noreturn'
     */
    bool isScopeNoReturn(const Token *endScopeToken, bool *unknown = nullptr) const;

    bool simplifyTokens1(c...",1,<empty>,,47,,,9,CASTProblemDeclaration,,<empty>
184683594612,UNKNOWN,1,,int,28,<empty>,,122,,,1,CPPASTTypeId,,<empty>
184683594613,UNKNOWN,1,,Token*,36,<empty>,,1583,,,1,CPPASTTypeId,,<empty>
184683594614,UNKNOWN,-1,,explicit TokensFrontBack(const TokenList& list) : list(list) {},5,<empty>,,47,,,1,CASTProblemDeclaration,,<empty>
184683594615,UNKNOWN,-1,,Token *front{};,5,<empty>,,48,,,2,CASTProblemDeclaration,,<empty>
184683594616,UNKNOWN,-1,,Token* back{};,5,<empty>,,49,,,3,CASTProblemDeclaration,,<empty>
184683594617,UNKNOWN,-1,,const TokenList& list;,5,<empty>,,50,,,4,CASTProblemDeclaration,,<empty>
184683594618,UNKNOWN,4,,"namespace simplecpp {
    class TokenList;
}",1,<empty>,,36,,,4,CASTProblemDeclaration,,<empty>
184683594619,UNKNOWN,6,,"class CPPCHECKLIB TokenList {
public:
    // TODO: pass settings as reference
    explicit TokenList(const Settings* settings);
    ~TokenList();

    TokenList(const TokenList &) = delete;
    TokenList &operator=(const TokenList &) = delete;

    /** @return the source file path. e.g. ""file.cpp"" */
    const std::string& getSourceFilePath() const;

    /** @return true if the code is C */
    bool isC() const;

    /** @return true if the code is C++ */
    bool isCPP() const;

    // TODO: get rid of this
    void setLang(Standards::Language lang, bool force = false);

    /**
     * Delete all tokens in given token list
     * @param tok token list to delete
     */
    static void deleteTokens(Token *tok);

    void addtoken(const std::string& str, nonneg int lineno, nonneg int column, nonneg int fileno, bool split = false);
    void addtoken(const std::string& str, const Token *locationTok);

    void addtoken(const Token *tok, nonneg int lineno, nonneg int column, nonneg int ...",1,<empty>,,53,,,6,CASTProblemDeclaration,,<empty>
184683594620,UNKNOWN,2,,"template<typename T, REQUIRES(""T must be a Token class"", std::is_convertible<T*, const Token*> )>
class TokenRangeBase {
    T* mFront;
    T* mBack;

public:
    TokenRangeBase(T* front, T* back) : mFront(front), mBack(back) {}

    struct TokenIterator {
        using iterator_category = std::forward_iterator_tag;
        using value_type = T*;
        using difference_type = std::ptrdiff_t;
        using pointer = void;
        using reference = T*;

        T* mt;
        TokenIterator() : mt(nullptr) {}
        explicit TokenIterator(T* t) : mt(t) {}
        TokenIterator& operator++() {
            mt = mt->next();
            return *this;
        }
        bool operator==(const TokenIterator& b) const {
            return mt == b.mt;
        }
        bool operator!=(const TokenIterator& b) const {
            return mt != b.mt;
        }
        T* operator*() const {
            return mt;
        }
    };

    TokenIterator begin() const {
        return TokenIterator(mFr...",1,<empty>,,32,,,2,CASTProblemDeclaration,,<empty>
184683594621,UNKNOWN,3,,"class TokenRange : public TokenRangeBase<Token> {
public:
    TokenRange(Token* front, Token* back) : TokenRangeBase<Token>(front, back) {}
};",1,<empty>,,73,,,3,CASTProblemDeclaration,,<empty>
184683594622,UNKNOWN,4,,"class ConstTokenRange : public TokenRangeBase<const Token> {
public:
    ConstTokenRange(const Token* front, const Token* back) : TokenRangeBase<const Token>(front, back) {}
};",1,<empty>,,78,,,4,CASTProblemDeclaration,,<empty>
184683594623,UNKNOWN,1,,char,39,<empty>,,171,,,1,CPPASTTypeId,,<empty>
184683594624,UNKNOWN,1,,char,39,<empty>,,178,,,1,CPPASTTypeId,,<empty>
184683594625,UNKNOWN,-1,,"template<class Pair>
    // NOLINTNEXTLINE(readability-const-return-type) - false positive
    typename Pair::first_type operator()(const Pair& p) const {
        return p.first;
    }",5,<empty>,,40,,,1,CASTProblemDeclaration,,<empty>
184683594626,UNKNOWN,-1,,"template<class Pair>
    typename Pair::second_type operator()(const Pair& p) const {
        return p.second;
    }",5,<empty>,,48,,,1,CASTProblemDeclaration,,<empty>
184683594627,UNKNOWN,-1,,std::function<void()> f;,5,<empty>,,55,,,1,CASTProblemDeclaration,,<empty>
184683594628,UNKNOWN,-1,,"~OnExit() {
        f();
    }",5,<empty>,,57,,,2,CASTProblemDeclaration,,<empty>
184683594629,UNKNOWN,-1,,"template<typename T>
    std::size_t operator()(T t) const
    {
        return static_cast<std::size_t>(t);
    }",5,<empty>,,88,,,1,CASTProblemDeclaration,,<empty>
184683594630,UNKNOWN,4,,"template<class Range, class T>
bool contains(const Range& r, const T& x)
{
    return std::find(r.cbegin(), r.cend(), x) != r.cend();
}",1,<empty>,,62,,,4,CASTProblemDeclaration,,<empty>
184683594631,UNKNOWN,5,,"template<class T>
bool contains(const std::initializer_list<T>& r, const T& x)
{
    return std::find(r.begin(), r.end(), x) != r.end();
}",1,<empty>,,68,,,5,CASTProblemDeclaration,,<empty>
184683594632,UNKNOWN,6,,"template<class T, class U>
bool contains(const std::initializer_list<T>& r, const U& x)
{
    return std::find(r.begin(), r.end(), x) != r.end();
}",1,<empty>,,74,,,6,CASTProblemDeclaration,,<empty>
184683594633,UNKNOWN,7,,"template<class T, class ... Ts>
inline std::array<T, sizeof...(Ts) + 1> makeArray(T x, Ts... xs)
{
    return {std::move(x), std::move(xs)...};
}",1,<empty>,,80,,,7,CASTProblemDeclaration,,<empty>
184683594634,UNKNOWN,9,,"inline bool startsWith(const std::string& str, const char start[], std::size_t startlen)
{
    return str.compare(0, startlen, start) == 0;
}",1,<empty>,,95,,,9,CASTProblemDeclaration,,<empty>
184683594635,UNKNOWN,10,,"template<std::size_t N>
bool startsWith(const std::string& str, const char (&start)[N])
{
    return startsWith(str, start, N - 1);
}",1,<empty>,,100,,,10,CASTProblemDeclaration,,<empty>
184683594636,UNKNOWN,11,,"inline bool startsWith(const std::string& str, const std::string& start)
{
    return startsWith(str, start.c_str(), start.length());
}",1,<empty>,,106,,,11,CASTProblemDeclaration,,<empty>
184683594637,UNKNOWN,12,,"inline bool endsWith(const std::string &str, char c)
{
    return !str.empty() && str.back() == c;
}",1,<empty>,,111,,,12,CASTProblemDeclaration,,<empty>
184683594638,UNKNOWN,13,,"inline bool endsWith(const std::string &str, const char end[], std::size_t endlen)
{
    return (str.size() >= endlen) && (str.compare(str.size()-endlen, endlen, end)==0);
}",1,<empty>,,116,,,13,CASTProblemDeclaration,,<empty>
184683594639,UNKNOWN,14,,"template<std::size_t N>
bool endsWith(const std::string& str, const char (&end)[N])
{
    return endsWith(str, end, N - 1);
}",1,<empty>,,121,,,14,CASTProblemDeclaration,,<empty>
184683594640,UNKNOWN,15,,"inline static bool isPrefixStringCharLiteral(const std::string &str, char q, const std::string& p)
{
    // str must be at least the prefix plus the start and end quote
    if (str.length() < p.length() + 2)
        return false;

    // check for end quote
    if (!endsWith(str, q))
        return false;

    // check for start quote
    if (str[p.size()] != q)
        return false;

    // check for prefix
    if (str.compare(0, p.size(), p) != 0)
        return false;

    return true;
}",1,<empty>,,127,,,15,CASTProblemDeclaration,,<empty>
184683594641,UNKNOWN,16,,"inline static bool isStringCharLiteral(const std::string &str, char q)
{
    // early out to avoid the loop
    if (!endsWith(str, q))
        return false;

    static const std::array<std::string, 5> suffixes{"""", ""u8"", ""u"", ""U"", ""L""};
    return std::any_of(suffixes.cbegin(), suffixes.cend(), [&](const std::string& p) {
        return isPrefixStringCharLiteral(str, q, p);
    });
}",1,<empty>,,148,,,16,CASTProblemDeclaration,,<empty>
184683594642,UNKNOWN,17,,"inline static bool isStringLiteral(const std::string &str)
{
    return isStringCharLiteral(str, '""');
}",1,<empty>,,160,,,17,CASTProblemDeclaration,,<empty>
184683594643,UNKNOWN,18,,"inline static bool isCharLiteral(const std::string &str)
{
    return isStringCharLiteral(str, '\\'');
}",1,<empty>,,165,,,18,CASTProblemDeclaration,,<empty>
184683594644,UNKNOWN,19,,"inline static std::string getStringCharLiteral(const std::string &str, char q)
{
    const std::size_t quotePos = str.find(q);
    return str.substr(quotePos + 1U, str.size() - quotePos - 2U);
}",1,<empty>,,170,,,19,CASTProblemDeclaration,,<empty>
184683594645,UNKNOWN,20,,"inline static std::string getStringLiteral(const std::string &str)
{
    if (isStringLiteral(str))
        return getStringCharLiteral(str, '""');
    return """";
}",1,<empty>,,176,,,20,CASTProblemDeclaration,,<empty>
184683594646,UNKNOWN,21,,"inline static std::string getCharLiteral(const std::string &str)
{
    if (isCharLiteral(str))
        return getStringCharLiteral(str, '\\'');
    return """";
}",1,<empty>,,183,,,21,CASTProblemDeclaration,,<empty>
184683594647,UNKNOWN,23,,"int caseInsensitiveStringCompare(const std::string& lhs, const std::string& rhs);",13,<empty>,,201,,,23,CASTProblemDeclaration,,<empty>
184683594648,UNKNOWN,24,,bool isValidGlobPattern(const std::string& pattern);,13,<empty>,,203,,,24,CASTProblemDeclaration,,<empty>
184683594649,UNKNOWN,25,,"bool matchglob(const std::string& pattern, const std::string& name);",13,<empty>,,205,,,25,CASTProblemDeclaration,,<empty>
184683594650,UNKNOWN,26,,"bool matchglobs(const std::vector<std::string> &patterns, const std::string &name);",13,<empty>,,207,,,26,CASTProblemDeclaration,,<empty>
184683594651,UNKNOWN,27,,void strTolower(std::string& str);,13,<empty>,,209,,,27,CASTProblemDeclaration,,<empty>
184683594652,UNKNOWN,28,,"template<typename T, typename std::enable_if<std::is_signed<T>::value, bool>::type=true>
bool strToInt(const std::string& str, T &num, std::string* err = nullptr)
{
    long long tmp;
    try {
        std::size_t idx = 0;
        tmp = std::stoll(str, &idx);
        if (idx != str.size()) {
            if (err)
                *err = ""not an integer"";
            return false;
        }
    } catch (const std::out_of_range&) {
        if (err)
            *err = ""out of range (stoll)"";
        return false;
    } catch (const std::invalid_argument &) {
        if (err)
            *err = ""not an integer"";
        return false;
    }
    if (str.front() == '-' && std::numeric_limits<T>::min() == 0) {
        if (err)
            *err = ""needs to be positive"";
        return false;
    }
    if (tmp < std::numeric_limits<T>::min() || tmp > std::numeric_limits<T>::max()) {
        if (err)
            *err = ""out of range (limits)"";
        return false;
    }
    num = static_cast<T>...",1,<empty>,,211,,,28,CASTProblemDeclaration,,<empty>
184683594653,UNKNOWN,29,,"template<typename T, typename std::enable_if<std::is_unsigned<T>::value, bool>::type=true>
bool strToInt(const std::string& str, T &num, std::string* err = nullptr)
{
    unsigned long long tmp;
    try {
        std::size_t idx = 0;
        tmp = std::stoull(str, &idx);
        if (idx != str.size()) {
            if (err)
                *err = ""not an integer"";
            return false;
        }
    } catch (const std::out_of_range&) {
        if (err)
            *err = ""out of range (stoull)"";
        return false;
    } catch (const std::invalid_argument &) {
        if (err)
            *err = ""not an integer"";
        return false;
    }
    if (str.front() == '-') {
        if (err)
            *err = ""needs to be positive"";
        return false;
    }
    if (tmp > std::numeric_limits<T>::max()) {
        if (err)
            *err = ""out of range (limits)"";
        return false;
    }
    num = tmp;
    return true;
}",1,<empty>,,246,,,29,CASTProblemDeclaration,,<empty>
184683594654,UNKNOWN,30,,"template<typename T>
T strToInt(const std::string& str)
{
    T tmp = 0;
    std::string err;
    if (!strToInt(str, tmp, &err))
        throw std::runtime_error(""converting '"" + str + ""' to integer failed - "" + err);
    return tmp;
}",1,<empty>,,281,,,30,CASTProblemDeclaration,,<empty>
184683594655,UNKNOWN,31,,"template<typename T, int size>
// cppcheck-suppress unusedFunction - only used in conditional code
std::size_t getArrayLength(const T (& /*unused*/)[size])
{
    return size;
}",1,<empty>,,295,,,31,CASTProblemDeclaration,,<empty>
184683594656,UNKNOWN,32,,"static inline std::string id_string_i(std::uintptr_t l)
{
    if (!l)
        return ""0"";

    static constexpr int ptr_size = sizeof(void*);

    // two characters of each byte / contains terminating \\0
    static constexpr int buf_size = (ptr_size * 2) + 1;

    char buf[buf_size];

    // needs to be signed so we don't underflow in padding loop
    int idx = buf_size - 1;
    buf[idx] = '\\0';

    while (l != 0)
    {
        char c;
        const std::uintptr_t temp = l % 16; // get the remainder
        if (temp < 10) {
            // 0-9
            c = '0' + temp;
        }
        else {
            // a-f
            c = 'a' + (temp - 10);
        }
        buf[--idx] = c; // store in reverse order
        l = l / 16;
    }

    return &buf[idx];
}",1,<empty>,,306,,,32,CASTProblemDeclaration,,<empty>
184683594657,UNKNOWN,33,,"static inline std::string id_string(const void* p)
{
    return id_string_i(reinterpret_cast<std::uintptr_t>(p));
}",1,<empty>,,341,,,33,CASTProblemDeclaration,,<empty>
184683594658,UNKNOWN,35,,"std::string trim(const std::string& s, const std::string& t = "" \\t"");",13,<empty>,,357,,,35,CASTProblemDeclaration,,<empty>
184683594659,UNKNOWN,36,,"void findAndReplace(std::string &source, const std::string &searchFor, const std::string &replaceWith);",13,<empty>,,366,,,36,CASTProblemDeclaration,,<empty>
184683594660,UNKNOWN,37,,std::string replaceEscapeSequences(const std::string &source);,13,<empty>,,372,,,37,CASTProblemDeclaration,,<empty>
184683594661,UNKNOWN,38,,"namespace cppcheck
{
    NORETURN inline void unreachable()
    {
#if defined(__GNUC__)
        __builtin_unreachable();
#elif defined(_MSC_VER)
        __assume(false);
#else
#error ""no unreachable implementation""
#endif
    }
}",1,<empty>,,374,,,38,CASTProblemDeclaration,,<empty>
184683594662,UNKNOWN,39,,"template<typename T>
static inline T* default_if_null(T* p, T* def)
{
    return p ? p : def;
}",1,<empty>,,388,,,39,CASTProblemDeclaration,,<empty>
184683594663,UNKNOWN,40,,"template<typename T>
static inline T* empty_if_null(T* p)
{
    return default_if_null(p, """");
}",1,<empty>,,394,,,40,CASTProblemDeclaration,,<empty>
184683594664,UNKNOWN,41,,"std::vector<std::string> splitString(const std::string& str, char sep);",13,<empty>,,406,,,41,CASTProblemDeclaration,,<empty>
184683594665,UNKNOWN,42,,"namespace utils {
    template<class T>
    constexpr typename std::add_const<T>::type & as_const(T& t) noexcept
    {
        // NOLINTNEXTLINE(bugprone-return-const-ref-from-parameter) - potential false positive
        return t;
    }

    // Thread-unsafe memoization
    template<class F, class R=decltype(std::declval<F>()())>
    static inline std::function<R()> memoize(F f)
    {
        bool init = false;
        R result{};
        return [=]() mutable -> R {
            if (init)
                return result;
            result = f();
            init = true;
            return result;
        };
    }
}",1,<empty>,,408,,,42,CASTProblemDeclaration,,<empty>
184683594666,UNKNOWN,1,,std::size_t,57,<empty>,,762,,,1,CPPASTTypeId,,<empty>
184683594667,UNKNOWN,1,,std::size_t,57,<empty>,,769,,,1,CPPASTTypeId,,<empty>
184683594668,UNKNOWN,1,,MathLib::bigint,57,<empty>,,834,,,1,CPPASTTypeId,,<empty>
184683594669,UNKNOWN,1,,MathLib::bigint,16,<empty>,,837,,,1,CPPASTTypeId,,<empty>
184683594670,UNKNOWN,1,,Token*,40,<empty>,,1151,,,1,CPPASTTypeId,,<empty>
184683594671,UNKNOWN,1,,Token*,37,<empty>,,3172,,,1,CPPASTTypeId,,<empty>
184683594672,UNKNOWN,1,,Token*,37,<empty>,,3340,,,1,CPPASTTypeId,,<empty>
184683594673,UNKNOWN,1,,Token*,37,<empty>,,3487,,,1,CPPASTTypeId,,<empty>
184683594674,UNKNOWN,1,,Token*,37,<empty>,,3578,,,1,CPPASTTypeId,,<empty>
184683594675,UNKNOWN,1,,Token*,37,<empty>,,3691,,,1,CPPASTTypeId,,<empty>
184683594676,UNKNOWN,1,,MathLib::bigint,42,<empty>,,3992,,,1,CPPASTTypeId,,<empty>
184683594677,UNKNOWN,1,,Token*,37,<empty>,,4049,,,1,CPPASTTypeId,,<empty>
184683594678,UNKNOWN,1,,Token*,34,<empty>,,4051,,,1,CPPASTTypeId,,<empty>
184683594679,UNKNOWN,1,,Token*,37,<empty>,,4187,,,1,CPPASTTypeId,,<empty>
184683594680,UNKNOWN,1,,Token*,50,<empty>,,4851,,,1,CPPASTTypeId,,<empty>
184683594681,UNKNOWN,1,,Token *,41,<empty>,,4364,,,1,CPPASTTypeId,,<empty>
184683594682,UNKNOWN,1,,Token*,32,<empty>,,5272,,,1,CPPASTTypeId,,<empty>
184683594683,UNKNOWN,1,,Token*,44,<empty>,,5273,,,1,CPPASTTypeId,,<empty>
184683594684,UNKNOWN,1,,Token*,44,<empty>,,5407,,,1,CPPASTTypeId,,<empty>
184683594685,UNKNOWN,1,,Token*,33,<empty>,,5439,,,1,CPPASTTypeId,,<empty>
184683594686,UNKNOWN,1,,Token*,60,<empty>,,5498,,,1,CPPASTTypeId,,<empty>
184683594687,UNKNOWN,1,,Token*,37,<empty>,,5576,,,1,CPPASTTypeId,,<empty>
184683594688,UNKNOWN,1,,Token*,28,<empty>,,5882,,,1,CPPASTTypeId,,<empty>
184683594689,UNKNOWN,1,,Token*,38,<empty>,,6264,,,1,CPPASTTypeId,,<empty>
184683594690,UNKNOWN,1,,Token*,38,<empty>,,6269,,,1,CPPASTTypeId,,<empty>
184683594691,UNKNOWN,1,,Token*,38,<empty>,,6542,,,1,CPPASTTypeId,,<empty>
184683594692,UNKNOWN,1,,Token*,37,<empty>,,6594,,,1,CPPASTTypeId,,<empty>
184683594693,UNKNOWN,1,,Token*,41,<empty>,,6850,,,1,CPPASTTypeId,,<empty>
184683594694,UNKNOWN,1,,Token*,49,<empty>,,6900,,,1,CPPASTTypeId,,<empty>
184683594695,UNKNOWN,1,,double,71,<empty>,,6926,,,1,CPPASTTypeId,,<empty>
184683594696,UNKNOWN,1,,double,72,<empty>,,6931,,,1,CPPASTTypeId,,<empty>
184683594697,UNKNOWN,1,,Token*,49,<empty>,,6934,,,1,CPPASTTypeId,,<empty>
184683594698,UNKNOWN,1,,Token*,45,<empty>,,6958,,,1,CPPASTTypeId,,<empty>
184683594699,UNKNOWN,1,,void,9,<empty>,,7254,,,1,CPPASTTypeId,,<empty>
184683594700,UNKNOWN,1,,void,9,<empty>,,7254,,,1,CPPASTTypeId,,<empty>
184683594701,UNKNOWN,1,,void,9,<empty>,,7254,,,1,CPPASTTypeId,,<empty>
184683594702,UNKNOWN,1,,void,9,<empty>,,7254,,,1,CPPASTTypeId,,<empty>
184683594703,UNKNOWN,1,,void,9,<empty>,,7254,,,1,CPPASTTypeId,,<empty>
184683594704,UNKNOWN,1,,void,9,<empty>,,7255,,,1,CPPASTTypeId,,<empty>
184683594705,UNKNOWN,1,,void,9,<empty>,,7255,,,1,CPPASTTypeId,,<empty>
184683594706,UNKNOWN,1,,void,9,<empty>,,7255,,,1,CPPASTTypeId,,<empty>
184683594707,UNKNOWN,1,,void,9,<empty>,,7255,,,1,CPPASTTypeId,,<empty>
184683594708,UNKNOWN,1,,void,9,<empty>,,7255,,,1,CPPASTTypeId,,<empty>
184683594709,UNKNOWN,1,,void,9,<empty>,,7256,,,1,CPPASTTypeId,,<empty>
184683594710,UNKNOWN,1,,void,9,<empty>,,7256,,,1,CPPASTTypeId,,<empty>
184683594711,UNKNOWN,1,,void,9,<empty>,,7256,,,1,CPPASTTypeId,,<empty>
184683594712,UNKNOWN,1,,void,9,<empty>,,7256,,,1,CPPASTTypeId,,<empty>
184683594713,UNKNOWN,1,,void,9,<empty>,,7256,,,1,CPPASTTypeId,,<empty>
184683594714,UNKNOWN,1,,void,9,<empty>,,7257,,,1,CPPASTTypeId,,<empty>
184683594715,UNKNOWN,1,,void,9,<empty>,,7257,,,1,CPPASTTypeId,,<empty>
184683594716,UNKNOWN,1,,void,9,<empty>,,7257,,,1,CPPASTTypeId,,<empty>
184683594717,UNKNOWN,1,,void,9,<empty>,,7257,,,1,CPPASTTypeId,,<empty>
184683594718,UNKNOWN,1,,void,9,<empty>,,7257,,,1,CPPASTTypeId,,<empty>
184683594719,UNKNOWN,1,,void,9,<empty>,,7258,,,1,CPPASTTypeId,,<empty>
184683594720,UNKNOWN,1,,void,9,<empty>,,7258,,,1,CPPASTTypeId,,<empty>
184683594721,UNKNOWN,1,,void,9,<empty>,,7258,,,1,CPPASTTypeId,,<empty>
184683594722,UNKNOWN,1,,void,9,<empty>,,7258,,,1,CPPASTTypeId,,<empty>
184683594723,UNKNOWN,1,,void,9,<empty>,,7258,,,1,CPPASTTypeId,,<empty>
184683594724,UNKNOWN,1,,void,9,<empty>,,7259,,,1,CPPASTTypeId,,<empty>
184683594725,UNKNOWN,1,,void,9,<empty>,,7259,,,1,CPPASTTypeId,,<empty>
184683594726,UNKNOWN,1,,void,9,<empty>,,7259,,,1,CPPASTTypeId,,<empty>
184683594727,UNKNOWN,1,,void,9,<empty>,,7259,,,1,CPPASTTypeId,,<empty>
184683594728,UNKNOWN,1,,void,9,<empty>,,7259,,,1,CPPASTTypeId,,<empty>
184683594729,UNKNOWN,1,,void,9,<empty>,,7260,,,1,CPPASTTypeId,,<empty>
184683594730,UNKNOWN,1,,void,9,<empty>,,7260,,,1,CPPASTTypeId,,<empty>
184683594731,UNKNOWN,1,,void,9,<empty>,,7260,,,1,CPPASTTypeId,,<empty>
184683594732,UNKNOWN,1,,void,9,<empty>,,7260,,,1,CPPASTTypeId,,<empty>
184683594733,UNKNOWN,1,,void,9,<empty>,,7260,,,1,CPPASTTypeId,,<empty>
184683594734,UNKNOWN,1,,void,9,<empty>,,7261,,,1,CPPASTTypeId,,<empty>
184683594735,UNKNOWN,1,,void,9,<empty>,,7261,,,1,CPPASTTypeId,,<empty>
184683594736,UNKNOWN,1,,void,9,<empty>,,7261,,,1,CPPASTTypeId,,<empty>
184683594737,UNKNOWN,1,,void,9,<empty>,,7261,,,1,CPPASTTypeId,,<empty>
184683594738,UNKNOWN,1,,void,9,<empty>,,7261,,,1,CPPASTTypeId,,<empty>
184683594739,UNKNOWN,1,,void,9,<empty>,,7262,,,1,CPPASTTypeId,,<empty>
184683594740,UNKNOWN,1,,void,9,<empty>,,7262,,,1,CPPASTTypeId,,<empty>
184683594741,UNKNOWN,1,,void,9,<empty>,,7262,,,1,CPPASTTypeId,,<empty>
184683594742,UNKNOWN,1,,void,9,<empty>,,7262,,,1,CPPASTTypeId,,<empty>
184683594743,UNKNOWN,1,,void,9,<empty>,,7262,,,1,CPPASTTypeId,,<empty>
184683594744,UNKNOWN,1,,void,9,<empty>,,7263,,,1,CPPASTTypeId,,<empty>
184683594745,UNKNOWN,1,,void,9,<empty>,,7263,,,1,CPPASTTypeId,,<empty>
184683594746,UNKNOWN,1,,void,9,<empty>,,7263,,,1,CPPASTTypeId,,<empty>
184683594747,UNKNOWN,1,,void,9,<empty>,,7263,,,1,CPPASTTypeId,,<empty>
184683594748,UNKNOWN,1,,void,9,<empty>,,7263,,,1,CPPASTTypeId,,<empty>
184683594749,UNKNOWN,1,,void,9,<empty>,,7264,,,1,CPPASTTypeId,,<empty>
184683594750,UNKNOWN,1,,void,9,<empty>,,7264,,,1,CPPASTTypeId,,<empty>
184683594751,UNKNOWN,1,,void,9,<empty>,,7264,,,1,CPPASTTypeId,,<empty>
184683594752,UNKNOWN,1,,void,9,<empty>,,7264,,,1,CPPASTTypeId,,<empty>
184683594753,UNKNOWN,1,,void,9,<empty>,,7264,,,1,CPPASTTypeId,,<empty>
184683594754,UNKNOWN,1,,void,9,<empty>,,7265,,,1,CPPASTTypeId,,<empty>
184683594755,UNKNOWN,1,,void,9,<empty>,,7265,,,1,CPPASTTypeId,,<empty>
184683594756,UNKNOWN,1,,void,9,<empty>,,7265,,,1,CPPASTTypeId,,<empty>
184683594757,UNKNOWN,1,,void,9,<empty>,,7265,,,1,CPPASTTypeId,,<empty>
184683594758,UNKNOWN,1,,void,9,<empty>,,7265,,,1,CPPASTTypeId,,<empty>
184683594759,UNKNOWN,1,,void,9,<empty>,,7266,,,1,CPPASTTypeId,,<empty>
184683594760,UNKNOWN,1,,void,9,<empty>,,7266,,,1,CPPASTTypeId,,<empty>
184683594761,UNKNOWN,1,,void,9,<empty>,,7266,,,1,CPPASTTypeId,,<empty>
184683594762,UNKNOWN,1,,void,9,<empty>,,7266,,,1,CPPASTTypeId,,<empty>
184683594763,UNKNOWN,1,,void,9,<empty>,,7266,,,1,CPPASTTypeId,,<empty>
184683594764,UNKNOWN,1,,void,9,<empty>,,7267,,,1,CPPASTTypeId,,<empty>
184683594765,UNKNOWN,1,,void,9,<empty>,,7267,,,1,CPPASTTypeId,,<empty>
184683594766,UNKNOWN,1,,void,9,<empty>,,7267,,,1,CPPASTTypeId,,<empty>
184683594767,UNKNOWN,1,,void,9,<empty>,,7267,,,1,CPPASTTypeId,,<empty>
184683594768,UNKNOWN,1,,void,9,<empty>,,7267,,,1,CPPASTTypeId,,<empty>
184683594769,UNKNOWN,1,,void,9,<empty>,,7271,,,1,CPPASTTypeId,,<empty>
184683594770,UNKNOWN,1,,void,9,<empty>,,7271,,,1,CPPASTTypeId,,<empty>
184683594771,UNKNOWN,1,,void,9,<empty>,,7271,,,1,CPPASTTypeId,,<empty>
184683594772,UNKNOWN,1,,void,9,<empty>,,7271,,,1,CPPASTTypeId,,<empty>
184683594773,UNKNOWN,1,,void,9,<empty>,,7271,,,1,CPPASTTypeId,,<empty>
184683594774,UNKNOWN,1,,void,9,<empty>,,7272,,,1,CPPASTTypeId,,<empty>
184683594775,UNKNOWN,1,,void,9,<empty>,,7272,,,1,CPPASTTypeId,,<empty>
184683594776,UNKNOWN,1,,void,9,<empty>,,7272,,,1,CPPASTTypeId,,<empty>
184683594777,UNKNOWN,1,,void,9,<empty>,,7272,,,1,CPPASTTypeId,,<empty>
184683594778,UNKNOWN,1,,void,9,<empty>,,7272,,,1,CPPASTTypeId,,<empty>
184683594779,UNKNOWN,1,,void,9,<empty>,,7273,,,1,CPPASTTypeId,,<empty>
184683594780,UNKNOWN,1,,void,9,<empty>,,7273,,,1,CPPASTTypeId,,<empty>
184683594781,UNKNOWN,1,,void,9,<empty>,,7273,,,1,CPPASTTypeId,,<empty>
184683594782,UNKNOWN,1,,void,9,<empty>,,7273,,,1,CPPASTTypeId,,<empty>
184683594783,UNKNOWN,1,,void,9,<empty>,,7273,,,1,CPPASTTypeId,,<empty>
184683594784,UNKNOWN,1,,void,9,<empty>,,7274,,,1,CPPASTTypeId,,<empty>
184683594785,UNKNOWN,1,,void,9,<empty>,,7274,,,1,CPPASTTypeId,,<empty>
184683594786,UNKNOWN,1,,void,9,<empty>,,7274,,,1,CPPASTTypeId,,<empty>
184683594787,UNKNOWN,1,,void,9,<empty>,,7274,,,1,CPPASTTypeId,,<empty>
184683594788,UNKNOWN,1,,void,9,<empty>,,7274,,,1,CPPASTTypeId,,<empty>
184683594789,UNKNOWN,1,,void,9,<empty>,,7275,,,1,CPPASTTypeId,,<empty>
184683594790,UNKNOWN,1,,void,9,<empty>,,7275,,,1,CPPASTTypeId,,<empty>
184683594791,UNKNOWN,1,,void,9,<empty>,,7275,,,1,CPPASTTypeId,,<empty>
184683594792,UNKNOWN,1,,void,9,<empty>,,7275,,,1,CPPASTTypeId,,<empty>
184683594793,UNKNOWN,1,,void,9,<empty>,,7275,,,1,CPPASTTypeId,,<empty>
184683594794,UNKNOWN,1,,void,9,<empty>,,7276,,,1,CPPASTTypeId,,<empty>
184683594795,UNKNOWN,1,,void,9,<empty>,,7276,,,1,CPPASTTypeId,,<empty>
184683594796,UNKNOWN,1,,void,9,<empty>,,7276,,,1,CPPASTTypeId,,<empty>
184683594797,UNKNOWN,1,,void,9,<empty>,,7276,,,1,CPPASTTypeId,,<empty>
184683594798,UNKNOWN,1,,void,9,<empty>,,7276,,,1,CPPASTTypeId,,<empty>
184683594799,UNKNOWN,1,,void,9,<empty>,,7277,,,1,CPPASTTypeId,,<empty>
184683594800,UNKNOWN,1,,void,9,<empty>,,7277,,,1,CPPASTTypeId,,<empty>
184683594801,UNKNOWN,1,,void,9,<empty>,,7277,,,1,CPPASTTypeId,,<empty>
184683594802,UNKNOWN,1,,void,9,<empty>,,7277,,,1,CPPASTTypeId,,<empty>
184683594803,UNKNOWN,1,,void,9,<empty>,,7277,,,1,CPPASTTypeId,,<empty>
184683594804,UNKNOWN,1,,void,9,<empty>,,7278,,,1,CPPASTTypeId,,<empty>
184683594805,UNKNOWN,1,,void,9,<empty>,,7278,,,1,CPPASTTypeId,,<empty>
184683594806,UNKNOWN,1,,void,9,<empty>,,7278,,,1,CPPASTTypeId,,<empty>
184683594807,UNKNOWN,1,,void,9,<empty>,,7278,,,1,CPPASTTypeId,,<empty>
184683594808,UNKNOWN,1,,void,9,<empty>,,7278,,,1,CPPASTTypeId,,<empty>
184683594809,UNKNOWN,1,,void,9,<empty>,,7280,,,1,CPPASTTypeId,,<empty>
184683594810,UNKNOWN,1,,void,9,<empty>,,7280,,,1,CPPASTTypeId,,<empty>
184683594811,UNKNOWN,1,,void,9,<empty>,,7280,,,1,CPPASTTypeId,,<empty>
184683594812,UNKNOWN,1,,void,9,<empty>,,7280,,,1,CPPASTTypeId,,<empty>
184683594813,UNKNOWN,1,,void,9,<empty>,,7280,,,1,CPPASTTypeId,,<empty>
184683594814,UNKNOWN,1,,void,9,<empty>,,7281,,,1,CPPASTTypeId,,<empty>
184683594815,UNKNOWN,1,,void,9,<empty>,,7281,,,1,CPPASTTypeId,,<empty>
184683594816,UNKNOWN,1,,void,9,<empty>,,7281,,,1,CPPASTTypeId,,<empty>
184683594817,UNKNOWN,1,,void,9,<empty>,,7281,,,1,CPPASTTypeId,,<empty>
184683594818,UNKNOWN,1,,void,9,<empty>,,7281,,,1,CPPASTTypeId,,<empty>
184683594819,UNKNOWN,1,,void,9,<empty>,,7282,,,1,CPPASTTypeId,,<empty>
184683594820,UNKNOWN,1,,void,9,<empty>,,7282,,,1,CPPASTTypeId,,<empty>
184683594821,UNKNOWN,1,,void,9,<empty>,,7282,,,1,CPPASTTypeId,,<empty>
184683594822,UNKNOWN,1,,void,9,<empty>,,7282,,,1,CPPASTTypeId,,<empty>
184683594823,UNKNOWN,1,,void,9,<empty>,,7282,,,1,CPPASTTypeId,,<empty>
184683594824,UNKNOWN,1,,void,9,<empty>,,7283,,,1,CPPASTTypeId,,<empty>
184683594825,UNKNOWN,1,,void,9,<empty>,,7283,,,1,CPPASTTypeId,,<empty>
184683594826,UNKNOWN,1,,void,9,<empty>,,7283,,,1,CPPASTTypeId,,<empty>
184683594827,UNKNOWN,1,,void,9,<empty>,,7283,,,1,CPPASTTypeId,,<empty>
184683594828,UNKNOWN,1,,void,9,<empty>,,7283,,,1,CPPASTTypeId,,<empty>
184683594829,UNKNOWN,1,,void,9,<empty>,,7284,,,1,CPPASTTypeId,,<empty>
184683594830,UNKNOWN,1,,void,9,<empty>,,7284,,,1,CPPASTTypeId,,<empty>
184683594831,UNKNOWN,1,,void,9,<empty>,,7284,,,1,CPPASTTypeId,,<empty>
184683594832,UNKNOWN,1,,void,9,<empty>,,7284,,,1,CPPASTTypeId,,<empty>
184683594833,UNKNOWN,1,,void,9,<empty>,,7284,,,1,CPPASTTypeId,,<empty>
184683594834,UNKNOWN,1,,void,9,<empty>,,7285,,,1,CPPASTTypeId,,<empty>
184683594835,UNKNOWN,1,,void,9,<empty>,,7285,,,1,CPPASTTypeId,,<empty>
184683594836,UNKNOWN,1,,void,9,<empty>,,7285,,,1,CPPASTTypeId,,<empty>
184683594837,UNKNOWN,1,,void,9,<empty>,,7285,,,1,CPPASTTypeId,,<empty>
184683594838,UNKNOWN,1,,void,9,<empty>,,7285,,,1,CPPASTTypeId,,<empty>
184683594839,UNKNOWN,1,,void,9,<empty>,,7286,,,1,CPPASTTypeId,,<empty>
184683594840,UNKNOWN,1,,void,9,<empty>,,7286,,,1,CPPASTTypeId,,<empty>
184683594841,UNKNOWN,1,,void,9,<empty>,,7286,,,1,CPPASTTypeId,,<empty>
184683594842,UNKNOWN,1,,void,9,<empty>,,7286,,,1,CPPASTTypeId,,<empty>
184683594843,UNKNOWN,1,,void,9,<empty>,,7286,,,1,CPPASTTypeId,,<empty>
184683594844,UNKNOWN,1,,void,9,<empty>,,7287,,,1,CPPASTTypeId,,<empty>
184683594845,UNKNOWN,1,,void,9,<empty>,,7287,,,1,CPPASTTypeId,,<empty>
184683594846,UNKNOWN,1,,void,9,<empty>,,7287,,,1,CPPASTTypeId,,<empty>
184683594847,UNKNOWN,1,,void,9,<empty>,,7287,,,1,CPPASTTypeId,,<empty>
184683594848,UNKNOWN,1,,void,9,<empty>,,7287,,,1,CPPASTTypeId,,<empty>
184683594849,UNKNOWN,1,,void,9,<empty>,,7288,,,1,CPPASTTypeId,,<empty>
184683594850,UNKNOWN,1,,void,9,<empty>,,7288,,,1,CPPASTTypeId,,<empty>
184683594851,UNKNOWN,1,,void,9,<empty>,,7288,,,1,CPPASTTypeId,,<empty>
184683594852,UNKNOWN,1,,void,9,<empty>,,7288,,,1,CPPASTTypeId,,<empty>
184683594853,UNKNOWN,1,,void,9,<empty>,,7288,,,1,CPPASTTypeId,,<empty>
184683594854,UNKNOWN,1,,void,9,<empty>,,7289,,,1,CPPASTTypeId,,<empty>
184683594855,UNKNOWN,1,,void,9,<empty>,,7289,,,1,CPPASTTypeId,,<empty>
184683594856,UNKNOWN,1,,void,9,<empty>,,7289,,,1,CPPASTTypeId,,<empty>
184683594857,UNKNOWN,1,,void,9,<empty>,,7289,,,1,CPPASTTypeId,,<empty>
184683594858,UNKNOWN,1,,void,9,<empty>,,7289,,,1,CPPASTTypeId,,<empty>
184683594859,UNKNOWN,1,,void,9,<empty>,,7290,,,1,CPPASTTypeId,,<empty>
184683594860,UNKNOWN,1,,void,9,<empty>,,7290,,,1,CPPASTTypeId,,<empty>
184683594861,UNKNOWN,1,,void,9,<empty>,,7290,,,1,CPPASTTypeId,,<empty>
184683594862,UNKNOWN,1,,void,9,<empty>,,7290,,,1,CPPASTTypeId,,<empty>
184683594863,UNKNOWN,1,,void,9,<empty>,,7290,,,1,CPPASTTypeId,,<empty>
184683594864,UNKNOWN,1,,void,9,<empty>,,7291,,,1,CPPASTTypeId,,<empty>
184683594865,UNKNOWN,1,,void,9,<empty>,,7291,,,1,CPPASTTypeId,,<empty>
184683594866,UNKNOWN,1,,void,9,<empty>,,7291,,,1,CPPASTTypeId,,<empty>
184683594867,UNKNOWN,1,,void,9,<empty>,,7291,,,1,CPPASTTypeId,,<empty>
184683594868,UNKNOWN,1,,void,9,<empty>,,7291,,,1,CPPASTTypeId,,<empty>
184683594869,UNKNOWN,1,,void,9,<empty>,,7292,,,1,CPPASTTypeId,,<empty>
184683594870,UNKNOWN,1,,void,9,<empty>,,7292,,,1,CPPASTTypeId,,<empty>
184683594871,UNKNOWN,1,,void,9,<empty>,,7292,,,1,CPPASTTypeId,,<empty>
184683594872,UNKNOWN,1,,void,9,<empty>,,7292,,,1,CPPASTTypeId,,<empty>
184683594873,UNKNOWN,1,,void,9,<empty>,,7292,,,1,CPPASTTypeId,,<empty>
184683594874,UNKNOWN,1,,void,9,<empty>,,7293,,,1,CPPASTTypeId,,<empty>
184683594875,UNKNOWN,1,,void,9,<empty>,,7293,,,1,CPPASTTypeId,,<empty>
184683594876,UNKNOWN,1,,void,9,<empty>,,7293,,,1,CPPASTTypeId,,<empty>
184683594877,UNKNOWN,1,,void,9,<empty>,,7293,,,1,CPPASTTypeId,,<empty>
184683594878,UNKNOWN,1,,void,9,<empty>,,7293,,,1,CPPASTTypeId,,<empty>
184683594879,UNKNOWN,1,,void,9,<empty>,,7294,,,1,CPPASTTypeId,,<empty>
184683594880,UNKNOWN,1,,void,9,<empty>,,7294,,,1,CPPASTTypeId,,<empty>
184683594881,UNKNOWN,1,,void,9,<empty>,,7294,,,1,CPPASTTypeId,,<empty>
184683594882,UNKNOWN,1,,void,9,<empty>,,7294,,,1,CPPASTTypeId,,<empty>
184683594883,UNKNOWN,1,,void,9,<empty>,,7294,,,1,CPPASTTypeId,,<empty>
184683594884,UNKNOWN,1,,void,9,<empty>,,7296,,,1,CPPASTTypeId,,<empty>
184683594885,UNKNOWN,1,,void,9,<empty>,,7296,,,1,CPPASTTypeId,,<empty>
184683594886,UNKNOWN,1,,void,9,<empty>,,7296,,,1,CPPASTTypeId,,<empty>
184683594887,UNKNOWN,1,,void,9,<empty>,,7296,,,1,CPPASTTypeId,,<empty>
184683594888,UNKNOWN,1,,void,9,<empty>,,7296,,,1,CPPASTTypeId,,<empty>
184683594889,UNKNOWN,1,,void,9,<empty>,,7297,,,1,CPPASTTypeId,,<empty>
184683594890,UNKNOWN,1,,void,9,<empty>,,7297,,,1,CPPASTTypeId,,<empty>
184683594891,UNKNOWN,1,,void,9,<empty>,,7297,,,1,CPPASTTypeId,,<empty>
184683594892,UNKNOWN,1,,void,9,<empty>,,7297,,,1,CPPASTTypeId,,<empty>
184683594893,UNKNOWN,1,,void,9,<empty>,,7297,,,1,CPPASTTypeId,,<empty>
184683594894,UNKNOWN,1,,void,9,<empty>,,7298,,,1,CPPASTTypeId,,<empty>
184683594895,UNKNOWN,1,,void,9,<empty>,,7298,,,1,CPPASTTypeId,,<empty>
184683594896,UNKNOWN,1,,void,9,<empty>,,7298,,,1,CPPASTTypeId,,<empty>
184683594897,UNKNOWN,1,,void,9,<empty>,,7298,,,1,CPPASTTypeId,,<empty>
184683594898,UNKNOWN,1,,void,9,<empty>,,7298,,,1,CPPASTTypeId,,<empty>
184683594899,UNKNOWN,1,,void,9,<empty>,,7302,,,1,CPPASTTypeId,,<empty>
184683594900,UNKNOWN,1,,void,9,<empty>,,7302,,,1,CPPASTTypeId,,<empty>
184683594901,UNKNOWN,1,,void,9,<empty>,,7302,,,1,CPPASTTypeId,,<empty>
184683594902,UNKNOWN,1,,void,9,<empty>,,7302,,,1,CPPASTTypeId,,<empty>
184683594903,UNKNOWN,1,,void,9,<empty>,,7302,,,1,CPPASTTypeId,,<empty>
184683594904,UNKNOWN,1,,void,9,<empty>,,7303,,,1,CPPASTTypeId,,<empty>
184683594905,UNKNOWN,1,,void,9,<empty>,,7303,,,1,CPPASTTypeId,,<empty>
184683594906,UNKNOWN,1,,void,9,<empty>,,7303,,,1,CPPASTTypeId,,<empty>
184683594907,UNKNOWN,1,,void,9,<empty>,,7303,,,1,CPPASTTypeId,,<empty>
184683594908,UNKNOWN,1,,void,9,<empty>,,7303,,,1,CPPASTTypeId,,<empty>
184683594909,UNKNOWN,10,,"namespace ValueFlow
{
    class Value;
}",1,<empty>,,45,,,10,CASTProblemDeclaration,,<empty>
184683594910,UNKNOWN,11,,"namespace ValueFlow {
    /// Constant folding of expression. This can be used before the full ValueFlow has been executed (ValueFlow::setValues).
    const Value * valueFlowConstantFoldAST(Token *expr, const Settings &settings);

    /// Perform valueflow analysis.
    void setValues(TokenList& tokenlist,
                   SymbolDatabase& symboldatabase,
                   ErrorLogger& errorLogger,
                   const Settings& settings,
                   TimerResultsIntf* timerResults);

    std::string eitherTheConditionIsRedundant(const Token *condition);

    size_t getSizeOf(const ValueType &vt, const Settings &settings, int maxRecursion = 0);

    const Value* findValue(const std::list<Value>& values,
                           const Settings& settings,
                           const std::function<bool(const Value&)> &pred);

    std::vector<Value> isOutOfBounds(const Value& size, const Token* indexTok, bool possible = true);

    Value asImpossible(Value v);

    bo...",1,<empty>,,50,,,11,CASTProblemDeclaration,,<empty>
184683594911,UNKNOWN,1,,"template<class T>
class CPPCHECKLIB ValuePtr {
    template<class U>
    struct cloner {
        static T* apply(const T* x) {
            return new U(*static_cast<const U*>(x));
        }
    };

public:
    using pointer = T*;
    using element_type = T;
    using cloner_type = decltype(&cloner<T>::apply);

    ValuePtr() : mPtr(nullptr), mClone() {}

    template<class U>
    // cppcheck-suppress noExplicitConstructor
    // NOLINTNEXTLINE(google-explicit-constructor)
    ValuePtr(const U& value) : mPtr(cloner<U>::apply(&value)), mClone(&cloner<U>::apply)
    {}

    ValuePtr(const ValuePtr& rhs) : mPtr(nullptr), mClone(rhs.mClone) {
        if (rhs) {
            mPtr.reset(mClone(rhs.get()));
        }
    }
    ValuePtr(ValuePtr&& rhs) NOEXCEPT : mPtr(std::move(rhs.mPtr)), mClone(std::move(rhs.mClone)) {}

    T* get() NOEXCEPT {
        return mPtr.get();
    }
    const T* get() const NOEXCEPT {
        return mPtr.get();
    }

    T& operator*() {
        return *get();
 ...",1,<empty>,,28,,,1,CASTProblemDeclaration,,<empty>
184683594912,UNKNOWN,1,,T,32,<empty>,,474,,,1,CPPASTTypeId,,<empty>
184683594913,UNKNOWN,1,,void,14,<empty>,,771,,,1,CPPASTTypeId,,<empty>
184683594914,UNKNOWN,4,,"namespace ValueFlow {
    class Value;
}",1,<empty>,,34,,,4,CASTProblemDeclaration,,<empty>
184683594915,UNKNOWN,5,,"ValuePtr<Analyzer> makeMultiValueFlowAnalyzer(const std::unordered_map<const Variable*, ValueFlow::Value>& args, const Settings& settings);",1,<empty>,,38,,,5,CASTProblemDeclaration,,<empty>
184683594916,UNKNOWN,6,,"ValuePtr<Analyzer> makeSameExpressionAnalyzer(const Token* e, ValueFlow::Value val, const Settings& s);",1,<empty>,,40,,,6,CASTProblemDeclaration,,<empty>
184683594917,UNKNOWN,7,,"ValuePtr<Analyzer> makeOppositeExpressionAnalyzer(bool pIsNot, const Token* e, ValueFlow::Value val, const Settings& s);",1,<empty>,,42,,,7,CASTProblemDeclaration,,<empty>
184683594918,UNKNOWN,8,,"using PartialReadContainer = std::vector<std::pair<Token *, ValueFlow::Value>>;",1,<empty>,,44,,,8,CASTProblemDeclaration,,<empty>
184683594919,UNKNOWN,9,,"ValuePtr<Analyzer> makeMemberExpressionAnalyzer(std::string varname, const Token* e, ValueFlow::Value val, const std::shared_ptr<PartialReadContainer>& p, const Settings& s);",1,<empty>,,45,,,9,CASTProblemDeclaration,,<empty>
184683594920,UNKNOWN,10,,"ValuePtr<Analyzer> makeAnalyzer(const Token* exprTok, ValueFlow::Value value, const Settings& settings);",1,<empty>,,47,,,10,CASTProblemDeclaration,,<empty>
184683594921,UNKNOWN,11,,"ValuePtr<Analyzer> makeReverseAnalyzer(const Token* exprTok, ValueFlow::Value value, const Settings& settings);",1,<empty>,,49,,,11,CASTProblemDeclaration,,<empty>
184683594922,UNKNOWN,1,,MathLib::bigint,46,<empty>,,340,,,1,CPPASTTypeId,,<empty>
184683594923,UNKNOWN,4,,"namespace ValueFlow
{
    class Value;
}",1,<empty>,,34,,,4,CASTProblemDeclaration,,<empty>
184683594924,UNKNOWN,5,,"namespace ValueFlow
{
    bool getMinMaxValues(const ValueType* vt, const Platform& platform, MathLib::bigint& minValue, MathLib::bigint& maxValue);

    MathLib::bigint truncateIntValue(MathLib::bigint value, size_t value_size, ValueType::Sign dst_sign);

    Token * valueFlowSetConstantValue(Token *tok, const Settings &settings);

    Value castValue(Value value, ValueType::Sign sign, nonneg int bit);

    std::string debugString(const Value& v);

    void setSourceLocation(Value& v,
                           SourceLocation ctx,
                           const Token* tok,
                           SourceLocation local = SourceLocation::current());

    MathLib::bigint valueFlowGetStrLength(const Token* tok);
}",1,<empty>,,39,,,5,CASTProblemDeclaration,,<empty>
184683594925,UNKNOWN,1,,double,53,<empty>,,147,,,1,CPPASTTypeId,,<empty>
184683594926,UNKNOWN,1,,MathLib::bigint,68,<empty>,,502,,,1,CPPASTTypeId,,<empty>
184683594927,UNKNOWN,1,,MathLib::bigint,68,<empty>,,505,,,1,CPPASTTypeId,,<empty>
184683594928,UNKNOWN,1,,double,104,<empty>,,498,,,1,CPPASTTypeId,,<empty>
184683594929,UNKNOWN,1,,double,104,<empty>,,499,,,1,CPPASTTypeId,,<empty>
184683594930,UNKNOWN,1,,MathLib::bigint,63,<empty>,,567,,,1,CPPASTTypeId,,<empty>
184683594931,UNKNOWN,1,,double,65,<empty>,,572,,,1,CPPASTTypeId,,<empty>
184683594932,UNKNOWN,3,,namespace ValueFlow { class Value; },1,<empty>,,26,,,3,CASTProblemDeclaration,,<empty>
184683594933,UNKNOWN,4,,"namespace ValueFlow
{
    void setTokenValue(Token* tok,
                       Value value,
                       const Settings& settings,
                       SourceLocation loc = SourceLocation::current());
}",1,<empty>,,28,,,4,CASTProblemDeclaration,,<empty>
184683594934,UNKNOWN,2,,"namespace ValueFlow
{
    class CPPCHECKLIB Value {
    public:
        enum class Bound : std::uint8_t { Upper, Lower, Point };

        explicit Value(MathLib::bigint val = 0, Bound b = Bound::Point) :
            bound(b),
            safe(false),
            conditional(false),
            macro(false),
            defaultArg(false),
            intvalue(val),
            varvalue(val),
            wideintvalue(val)
        {}
        Value(const Token* c, MathLib::bigint val, Bound b = Bound::Point);

        static Value unknown() {
            Value v;
            v.valueType = ValueType::UNINIT;
            return v;
        }

        bool equalValue(const ValueFlow::Value& rhs) const {
            if (valueType != rhs.valueType)
                return false;
            switch (valueType) {
            case ValueType::INT:
            case ValueType::CONTAINER_SIZE:
            case ValueType::BUFFER_SIZE:
            case ValueType::ITERATOR_START:
            case ValueT...",1,<empty>,,41,,,2,CASTProblemDeclaration,,<empty>
184683594935,UNKNOWN,1,,"inline static tinyxml2::XMLError xml_LoadFile(tinyxml2::XMLDocument& doc, const char* filename)
{
    // tinyxml2 will fail with a misleading XML_ERROR_FILE_READ_ERROR when you try to load a directory as a XML file
    if (Path::isDirectory(filename))
        return tinyxml2::XMLError::XML_ERROR_FILE_NOT_FOUND;
    return doc.LoadFile(filename);
}",1,<empty>,,43,,,1,CASTProblemDeclaration,,<empty>
184683594936,UNKNOWN,1,,const uint8_t *,49,<empty>,,42,,,1,CPPASTTypeId,,<empty>
184683594937,UNKNOWN,1,,"std::string generateCode2(const uint8_t *data, size_t dataSize);",1,<empty>,,24,,,1,CASTProblemDeclaration,,<empty>
184683594938,UNKNOWN,2,,,,<empty>,,,,,2,CASTProblemDeclaration,,<empty>
184683594939,UNKNOWN,1,,unsigned int,28,<empty>,,77,,,1,CPPASTTypeId,,<empty>
184683594940,UNKNOWN,5,,"namespace Ui {
    class MainWindow;
}",1,<empty>,,33,,,5,CASTProblemDeclaration,,<empty>
184683594941,UNKNOWN,6,,"class MainWindow : public QMainWindow {
    Q_OBJECT

public:
    explicit MainWindow(QWidget *parent = nullptr);
    MainWindow(const MainWindow &) = delete;
    MainWindow &operator=(const MainWindow &) = delete;
    ~MainWindow() override;

public slots:
    void loadFile();
    void loadFromClipboard();
    void filter(const QString& filter);
    void showResult(QListWidgetItem *item);
    void refreshResults();
    void fileTreeFilter(const QString &str);
    void findInFilesClicked();
    void directorytreeDoubleClick();
    void searchResultsDoubleClick();
    void resultsContextMenu(const QPoint& pos);

private:
    Ui::MainWindow *ui;

    void load(QTextStream &textStream);
    bool runProcess(const QString &programName, const QStringList & arguments);
    bool wget(const QString &url);
    bool unpackArchive(const QString &archiveName);
    void showSrcFile(const QString &fileName, const QString &url, int lineNumber);

    QStringList mAllErrors;
    QFileSystemModel mFSm...",1,<empty>,,37,,,6,CASTProblemDeclaration,,<empty>
